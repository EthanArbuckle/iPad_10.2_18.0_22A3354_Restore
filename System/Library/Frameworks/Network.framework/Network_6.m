void *assignWithTake for NWActorDiscoveryMechanism.Target(void *a1, const void *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;

  if (a1 != a2)
  {
    sub_183319D48((uint64_t)a1);
    if (swift_getEnumCaseMultiPayload() == 1)
    {
      v6 = type metadata accessor for NWEndpoint();
      if (swift_getEnumCaseMultiPayload() == 3)
      {
        v7 = sub_183B913A4();
        (*(void (**)(void *, const void *, uint64_t))(*(_QWORD *)(v7 - 8) + 32))(a1, a2, v7);
        swift_storeEnumTagMultiPayload();
      }
      else
      {
        memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(v6 - 8) + 64));
      }
      swift_storeEnumTagMultiPayload();
    }
    else
    {
      memcpy(a1, a2, *(_QWORD *)(*(_QWORD *)(a3 - 8) + 64));
    }
  }
  return a1;
}

uint64_t sub_18331A9FC()
{
  uint64_t result;
  unint64_t v1;

  result = type metadata accessor for NWEndpoint();
  if (v1 <= 0x3F)
  {
    swift_initEnumMetadataMultiPayload();
    return 0;
  }
  return result;
}

void sub_18331B2E0(_Unwind_Exception *a1)
{
  void *v1;
  id *v2;
  id *v3;
  id *v4;
  uint64_t v5;

  objc_destroyWeak(v4);
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak((id *)(v5 - 176));
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18331B548(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18331B9D4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18331BB64(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18331C1EC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18331C348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  void *v14;
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  objc_sync_exit(v14);
  _Unwind_Resume(a1);
}

void sub_18331C508(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18331C958(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  id *v19;

  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18331CF38(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18331D37C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  id *v19;

  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void nw::object::_destroy(nw::object *this)
{
  char *v1;
  NSObject *v2;
  os_log_type_t v3;
  const char *v4;
  char *backtrace_string;
  _BOOL4 v6;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "_destroy";
  v1 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (!__nwlog_fault(v1, &type, &v7))
    goto LABEL_15;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    v3 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type))
      goto LABEL_15;
    *(_DWORD *)buf = 136446210;
    v10 = "_destroy";
    v4 = "%{public}s nw::object::_destroy should never be called";
LABEL_14:
    _os_log_impl(&dword_182FBE000, v2, v3, v4, buf, 0xCu);
    goto LABEL_15;
  }
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    v3 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type))
      goto LABEL_15;
    *(_DWORD *)buf = 136446210;
    v10 = "_destroy";
    v4 = "%{public}s nw::object::_destroy should never be called, backtrace limit exceeded";
    goto LABEL_14;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  v3 = type;
  v6 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!backtrace_string)
  {
    if (!v6)
      goto LABEL_15;
    *(_DWORD *)buf = 136446210;
    v10 = "_destroy";
    v4 = "%{public}s nw::object::_destroy should never be called, no backtrace";
    goto LABEL_14;
  }
  if (v6)
  {
    *(_DWORD *)buf = 136446466;
    v10 = "_destroy";
    v11 = 2082;
    v12 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v2, v3, "%{public}s nw::object::_destroy should never be called, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(backtrace_string);
LABEL_15:
  if (v1)
    free(v1);
}

void std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_back(_QWORD *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  __int128 *v26;
  _OWORD *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  char *v31;

  v4 = (char *)a1[2];
  if (v4 != (char *)a1[3])
  {
LABEL_24:
    *(_QWORD *)v4 = *a2;
    a1[2] += 8;
    return;
  }
  v5 = (char *)a1[1];
  v6 = (uint64_t)&v5[-*a1];
  if ((unint64_t)v5 > *a1)
  {
    v7 = v6 >> 3;
    v8 = v6 >> 3 < -1;
    v9 = (v6 >> 3) + 2;
    if (v8)
      v10 = v9;
    else
      v10 = v7 + 1;
    v11 = v10 >> 1;
    v12 = -v11;
    v13 = &v5[-8 * v11];
    v14 = v4 - v5;
    if (v4 != v5)
    {
      memmove(&v5[-8 * v11], v5, v4 - v5);
      v4 = (char *)a1[1];
    }
    v15 = &v4[8 * v12];
    v4 = &v13[v14];
    a1[1] = v15;
    a1[2] = &v13[v14];
    goto LABEL_24;
  }
  if (v4 == (char *)*a1)
    v16 = 1;
  else
    v16 = (uint64_t)&v4[-*a1] >> 2;
  v17 = (char *)malloc_type_calloc(v16, 8uLL, 0x80040B8603338uLL);
  if (v17)
  {
    v18 = &v17[8 * (v16 >> 2)];
    v19 = (uint64_t *)a1[1];
    v4 = v18;
    v20 = a1[2] - (_QWORD)v19;
    if (!v20)
      goto LABEL_22;
    v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    v21 = v20 - 8;
    if (v21 >= 0x38)
    {
      v23 = &v17[8 * (v16 >> 2)];
      v22 = v23;
      if ((unint64_t)(v23 - (char *)v19) >= 0x20)
      {
        v24 = (v21 >> 3) + 1;
        v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        v22 = &v18[v25];
        v26 = (__int128 *)(v19 + 2);
        v27 = v23 + 16;
        v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v29 = *v26;
          *(v27 - 1) = *(v26 - 1);
          *v27 = v29;
          v26 += 2;
          v27 += 2;
          v28 -= 4;
        }
        while (v28);
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_22:
          v31 = (char *)*a1;
          *a1 = v17;
          a1[1] = v18;
          a1[2] = v4;
          a1[3] = &v17[8 * v16];
          if (v31)
          {
            free(v31);
            v4 = (char *)a1[2];
          }
          goto LABEL_24;
        }
        v19 = (uint64_t *)((char *)v19 + v25);
      }
    }
    else
    {
      v22 = &v17[8 * (v16 >> 2)];
    }
    do
    {
      v30 = *v19++;
      *(_QWORD *)v22 = v30;
      v22 += 8;
    }
    while (v22 != v4);
    goto LABEL_22;
  }
  __break(1u);
}

void std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front(const void **a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  unint64_t v13;
  uint64_t *v14;
  char *v15;
  int64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 *v22;
  _OWORD *v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  void *v27;

  v4 = (char *)a1[1];
  if (v4 != *a1)
  {
    v5 = (char *)a1[1];
LABEL_25:
    *((_QWORD *)v5 - 1) = *a2;
    a1[1] = (char *)a1[1] - 8;
    return;
  }
  v6 = a1[2];
  v7 = a1[3];
  if (v6 < v7)
  {
    v8 = (v7 - v6) >> 3;
    if (v8 >= -1)
      v9 = v8 + 1;
    else
      v9 = v8 + 2;
    v10 = v9 >> 1;
    v5 = &v4[8 * (v9 >> 1)];
    if (v6 != v4)
    {
      memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
      v4 = (char *)a1[2];
    }
    a1[1] = v5;
    a1[2] = &v4[8 * v10];
    goto LABEL_25;
  }
  if (v7 == v4)
    v11 = 1;
  else
    v11 = (v7 - v4) >> 2;
  v12 = (char *)malloc_type_calloc(v11, 8uLL, 0x80040B8603338uLL);
  if (v12)
  {
    v13 = (v11 + 3) >> 2;
    v5 = &v12[8 * v13];
    v14 = (uint64_t *)a1[1];
    v15 = v5;
    v16 = (_BYTE *)a1[2] - (_BYTE *)v14;
    if (!v16)
      goto LABEL_23;
    v15 = &v5[v16 & 0xFFFFFFFFFFFFFFF8];
    v17 = v16 - 8;
    if (v17 >= 0x38)
    {
      v18 = &v12[8 * v13];
      v19 = v18;
      if ((unint64_t)(v18 - (char *)v14) >= 0x20)
      {
        v20 = (v17 >> 3) + 1;
        v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
        v18 = &v5[v21];
        v22 = (__int128 *)(v14 + 2);
        v23 = v19 + 16;
        v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v25 = *v22;
          *(v23 - 1) = *(v22 - 1);
          *v23 = v25;
          v22 += 2;
          v23 += 2;
          v24 -= 4;
        }
        while (v24);
        if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_23:
          v27 = (void *)*a1;
          *a1 = v12;
          a1[1] = v5;
          a1[2] = v15;
          a1[3] = &v12[8 * v11];
          if (v27)
          {
            free(v27);
            v5 = (char *)a1[1];
          }
          goto LABEL_25;
        }
        v14 = (uint64_t *)((char *)v14 + v21);
      }
    }
    else
    {
      v18 = &v12[8 * v13];
    }
    do
    {
      v26 = *v14++;
      *(_QWORD *)v18 = v26;
      v18 += 8;
    }
    while (v18 != v15);
    goto LABEL_23;
  }
  __break(1u);
}

uint64_t nw::object::_redacted_description(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  int v6;
  BOOL v7;
  uint64_t (*v8)(_QWORD *);
  _QWORD *v9;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = nw::object::cls(this[2]);
  v3 = nw::object::class_def::lookup_method(v2, nw::object::__description_def_instance, qword_1ECD85060);
  if (v4)
    v5 = (v4 & 1 | v3) == 0;
  else
    v5 = 1;
  v6 = !v5;
  if (v3)
    v7 = 0;
  else
    v7 = v6 == 0;
  if (!v7)
  {
    v8 = (uint64_t (*)(_QWORD *))v3;
    v9 = (uint64_t **)((char *)this + (v4 >> 1));
    if ((v4 & 1) != 0)
      v8 = *(uint64_t (**)(_QWORD *))(*v9 + v8);
    return v8(v9);
  }
  nw::object::cls(this[2]);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v20 = "bad_method_lookup";
  v21 = 2080;
  v22 = "object::description";
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v20 = "bad_method_lookup";
        v21 = 2080;
        v22 = "object::description";
        v14 = "%{public}s unable to lookup %s";
LABEL_27:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0x16u);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      v16 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446722;
          v20 = "bad_method_lookup";
          v21 = 2080;
          v22 = "object::description";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s unable to lookup %s, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_28;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "bad_method_lookup";
        v21 = 2080;
        v22 = "object::description";
        v14 = "%{public}s unable to lookup %s, no backtrace";
        goto LABEL_27;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v20 = "bad_method_lookup";
        v21 = 2080;
        v22 = "object::description";
        v14 = "%{public}s unable to lookup %s, backtrace limit exceeded";
        goto LABEL_27;
      }
    }
  }
LABEL_28:
  if (v11)
    free(v11);
  return 0;
}

uint64_t *nw::object::cls(uint64_t *this)
{
  char *v1;
  uint64_t v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (this)
    return this;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v10 = "cls";
  v1 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  v2 = __nwlog_fault(v1, &type, &v7);
  if ((_DWORD)v2)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      v2 = os_log_type_enabled(v3, type);
      if ((_DWORD)v2)
      {
        *(_DWORD *)buf = 136446210;
        v10 = "cls";
        v5 = "%{public}s called with null m_cls";
LABEL_15:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v7)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v2 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if ((_DWORD)v2)
        {
          *(_DWORD *)buf = 136446466;
          v10 = "cls";
          v11 = 2082;
          v12 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null m_cls, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_16;
      }
      if ((_DWORD)v2)
      {
        *(_DWORD *)buf = 136446210;
        v10 = "cls";
        v5 = "%{public}s called with null m_cls, no backtrace";
        goto LABEL_15;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      v2 = os_log_type_enabled(v3, type);
      if ((_DWORD)v2)
      {
        *(_DWORD *)buf = 136446210;
        v10 = "cls";
        v5 = "%{public}s called with null m_cls, backtrace limit exceeded";
        goto LABEL_15;
      }
    }
  }
LABEL_16:
  if (v1)
    free(v1);
  nw::object::_class((nw::object *)v2);
  return &nw::object::_class(void)::instance;
}

uint64_t nw::object::class_def::lookup_method(_QWORD *a1, unint64_t a2, char a3)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *v8;
  _BOOL4 v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (a1[13] > a2)
      return *(_QWORD *)(*(_QWORD *)(a1[9] + (((a1[12] + a2) >> 5) & 0x7FFFFFFFFFFFFF8))
                       + 16 * (*((_BYTE *)a1 + 96) + a2));
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "lookup_method";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (__nwlog_fault(v4, &type, &v12))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "lookup_method";
        v7 = "%{public}s called with null (def.slot().value() < m_method_table.size())";
        goto LABEL_31;
      }
      if (!v12)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "lookup_method";
        v7 = "%{public}s called with null (def.slot().value() < m_method_table.size()), backtrace limit exceeded";
        goto LABEL_31;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "lookup_method";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null (def.slot().value() < m_method_table.size()), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v4)
          return 0;
        goto LABEL_33;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "lookup_method";
        v7 = "%{public}s called with null (def.slot().value() < m_method_table.size()), no backtrace";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "lookup_method";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "lookup_method";
      v7 = "%{public}s called with null (def.slot())";
      goto LABEL_31;
    }
    if (!v12)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "lookup_method";
      v7 = "%{public}s called with null (def.slot()), backtrace limit exceeded";
      goto LABEL_31;
    }
    v8 = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!v8)
    {
      if (!v9)
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "lookup_method";
      v7 = "%{public}s called with null (def.slot()), no backtrace";
      goto LABEL_31;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "lookup_method";
      v16 = 2082;
      v17 = v8;
      _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null (def.slot()), dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v8);
  }
LABEL_32:
  if (v4)
LABEL_33:
    free(v4);
  return 0;
}

CFStringRef nw::object::_description(nw::object *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  void *v10;
  unint64_t v11;
  const void **v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  void **v16;
  CFStringRef v17;
  void *__p[2];
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[3];
  uint64_t v24;
  unint64_t v25;
  void *v26[2];
  __int128 v27;
  int v28;
  uint64_t v29[19];

  v1 = MEMORY[0x1E0DE4FE0];
  v2 = MEMORY[0x1E0DE4FE0] + 64;
  v3 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v29[0] = MEMORY[0x1E0DE4FE0] + 64;
  v21 = v4;
  *(uint64_t *)((char *)&v21 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)((char *)&v21 + *(_QWORD *)(v21 - 24));
  std::ios_base::init(v6, &v22);
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  v21 = v1 + 24;
  v29[0] = v2;
  std::streambuf::basic_streambuf();
  v7 = MEMORY[0x1E0DE4FB8];
  v22 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)v26 = 0u;
  v27 = 0u;
  v28 = 16;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v21, (uint64_t)"<nw::object ", 12);
  v8 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)">", 1);
  if ((v28 & 0x10) != 0)
  {
    v11 = *((_QWORD *)&v27 + 1);
    if (*((_QWORD *)&v27 + 1) < v25)
    {
      *((_QWORD *)&v27 + 1) = v25;
      v11 = v25;
    }
    v12 = (const void **)&v24;
  }
  else
  {
    if ((v28 & 8) == 0)
    {
      v9 = 0;
      HIBYTE(v20) = 0;
      v10 = __p;
      goto LABEL_16;
    }
    v12 = (const void **)v23;
    v11 = v23[2];
  }
  v13 = *v12;
  v9 = v11 - (_QWORD)*v12;
  if (v9 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (v9 >= 0x17)
  {
    v14 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v14 = v9 | 7;
    v15 = v14 + 1;
    v10 = operator new(v14 + 1);
    __p[1] = (void *)v9;
    v20 = v15 | 0x8000000000000000;
    __p[0] = v10;
    goto LABEL_15;
  }
  HIBYTE(v20) = v11 - *(_BYTE *)v12;
  v10 = __p;
  if (v9)
LABEL_15:
    memmove(v10, v13, v9);
LABEL_16:
  *((_BYTE *)v10 + v9) = 0;
  if (v20 >= 0)
    v16 = __p;
  else
    v16 = (void **)__p[0];
  v17 = CFStringCreateWithCString(0, (const char *)v16, 0x8000100u);
  if (SHIBYTE(v20) < 0)
    operator delete(__p[0]);
  v21 = *v3;
  *(uint64_t *)((char *)&v21 + *(_QWORD *)(v21 - 24)) = v3[3];
  v22 = v7 + 16;
  if (SBYTE7(v27) < 0)
    operator delete(v26[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186DB3548](v29);
  return v17;
}

_QWORD *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const std::locale::facet *v11;
  uint64_t v12;
  BOOL v13;
  size_t v14;
  size_t v15;
  std::locale::__imp *p_b;
  uint64_t v17;
  uint64_t v18;
  void *locale;
  uint64_t v20;
  uint64_t v21;
  _BYTE v23[16];
  std::locale __b;
  size_t v25;
  int64_t v26;

  MEMORY[0x186DB3470](v23, a1);
  if (!v23[0])
    goto LABEL_32;
  v6 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  v7 = *((_QWORD *)v6 + 5);
  v8 = a2 + a3;
  if ((*((_DWORD *)v6 + 2) & 0xB0) == 0x20)
    v9 = a2 + a3;
  else
    v9 = a2;
  v10 = *((_DWORD *)v6 + 36);
  if (v10 == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
    v11 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
    v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
    std::locale::~locale(&__b);
    *((_DWORD *)v6 + 36) = v10;
    if (!v7)
      goto LABEL_31;
  }
  else if (!v7)
  {
    goto LABEL_31;
  }
  v12 = *((_QWORD *)v6 + 3);
  v13 = v12 <= a3;
  v14 = v12 - a3;
  if (v13)
    v15 = 0;
  else
    v15 = v14;
  if (v9 - a2 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, v9 - a2) != v9 - a2)
  {
    goto LABEL_31;
  }
  if ((uint64_t)v15 >= 1)
  {
    if (v15 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (v15 >= 0x17)
    {
      v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v17 = v15 | 7;
      v18 = v17 + 1;
      p_b = (std::locale::__imp *)operator new(v17 + 1);
      v25 = v15;
      v26 = v18 | 0x8000000000000000;
      __b.__locale_ = p_b;
    }
    else
    {
      HIBYTE(v26) = v15;
      p_b = (std::locale::__imp *)&__b;
    }
    memset(p_b, v10, v15);
    *((_BYTE *)p_b + v15) = 0;
    if (v26 >= 0)
      locale = &__b;
    else
      locale = __b.__locale_;
    v20 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(_QWORD *)v7 + 96))(v7, locale, v15);
    v21 = v20;
    if ((SHIBYTE(v26) & 0x80000000) == 0)
    {
      if (v20 != v15)
        goto LABEL_31;
      goto LABEL_28;
    }
    operator delete(__b.__locale_);
    if (v21 != v15)
    {
LABEL_31:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
      goto LABEL_32;
    }
  }
LABEL_28:
  if (v8 - v9 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v9, v8 - v9) != v8 - v9)
  {
    goto LABEL_31;
  }
  *((_QWORD *)v6 + 3) = 0;
LABEL_32:
  MEMORY[0x186DB347C](v23);
  return a1;
}

void ___ZL25nw_protocol_udp_callbacksv_block_invoke()
{
  nw_protocol_udp_callbacks(void)::callbacks = nw_protocol_one_to_one_callbacks_new();
  nw_protocol_callbacks_set_add_input_handler((_QWORD *)nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_add_input_handler);
  nw_protocol_callbacks_set_remove_input_handler(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_remove_input_handler);
  nw_protocol_callbacks_set_get_input_frames(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_get_input_frames);
  nw_protocol_callbacks_set_get_output_frames(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_get_output_frames);
  nw_protocol_callbacks_set_finalize_output_frames(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_finalize_output_frames);
  nw_protocol_callbacks_set_connected(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_connected);
  nw_protocol_callbacks_set_disconnected(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_disconnected);
  nw_protocol_callbacks_set_link_state(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_link_state);
  nw_protocol_callbacks_set_updated_path(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_updated_path);
  nw_protocol_callbacks_set_get_message_properties(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_get_message_properties);
  nw_protocol_callbacks_set_copy_info(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_copy_info);
  nw_protocol_callbacks_set_error(nw_protocol_udp_callbacks(void)::callbacks, (uint64_t)nw_protocol_udp_error);
}

void nw_protocol_udp_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*disconnected)(nw_protocol *, nw_protocol *);
  void *handle;
  nw_protocol_callbacks *v7;
  nw_protocol_callbacks *v8;
  nw_protocol_callbacks *v9;
  nw_protocol_callbacks *v10;
  void (**v11)(_QWORD);
  const void *v12;
  nw_protocol_callbacks *v13;
  nw_protocol_callbacks *v14;
  void (**v15)(_QWORD);
  const void *v16;
  nw_protocol *v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *backtrace_string;
  _BOOL4 v23;
  char *v24;
  _BOOL4 v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_udp_disconnected";
    v18 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v18, &type, &v26))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_udp_disconnected";
      v21 = "%{public}s called with null protocol";
      goto LABEL_66;
    }
    if (!v26)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_udp_disconnected";
      v21 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_66;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v23 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (!v23)
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_udp_disconnected";
      v21 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_66;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_udp_disconnected";
      v30 = 2082;
      v31 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_67:
    if (!v18)
      return;
    goto LABEL_68;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_udp_disconnected";
    v18 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v18, &type, &v26))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_udp_disconnected";
      v21 = "%{public}s called with null udp";
      goto LABEL_66;
    }
    if (!v26)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_udp_disconnected";
      v21 = "%{public}s called with null udp, backtrace limit exceeded";
      goto LABEL_66;
    }
    v24 = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v25 = os_log_type_enabled(v19, type);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_protocol_udp_disconnected";
        v30 = 2082;
        v31 = v24;
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null udp, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v24);
      if (!v18)
        return;
LABEL_68:
      v17 = (nw_protocol *)v18;
LABEL_38:
      free(v17);
      return;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_udp_disconnected";
      v21 = "%{public}s called with null udp, no backtrace";
LABEL_66:
      _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
      goto LABEL_67;
    }
    goto LABEL_67;
  }
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_13);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  a1[2].output_handler = 0;
  a1[2].handle = 0;
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      disconnected = (void (*)(nw_protocol *, nw_protocol *))callbacks->disconnected;
      if (disconnected)
      {
        handle = default_input_handler->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          v7 = default_input_handler[1].callbacks;
          if (v7)
            default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
        }
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v8 = a1[1].callbacks;
          if (v8)
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v8->add_input_handler + 1);
          disconnected(default_input_handler, a1);
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            v9 = a1[1].callbacks;
            if (v9)
            {
              v10 = (nw_protocol_callbacks *)((char *)v9 - 1);
              a1[1].callbacks = v10;
              if (!v10)
              {
                v11 = *(void (***)(_QWORD))a1[1].flow_id;
                if (v11)
                {
                  *(_QWORD *)a1[1].flow_id = 0;
                  v11[2](v11);
                  _Block_release(v11);
                }
                if ((a1[1].flow_id[8] & 1) != 0)
                {
                  v12 = *(const void **)a1[1].flow_id;
                  if (v12)
                    _Block_release(v12);
                }
                free(a1);
              }
            }
          }
        }
        else
        {
          disconnected(default_input_handler, a1);
        }
        if (handle == &nw_protocol_ref_counted_handle
          && default_input_handler->handle == &nw_protocol_ref_counted_handle)
        {
          v13 = default_input_handler[1].callbacks;
          if (v13)
          {
            v14 = (nw_protocol_callbacks *)((char *)v13 - 1);
            default_input_handler[1].callbacks = v14;
            if (!v14)
            {
              v15 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
              if (v15)
              {
                *(_QWORD *)default_input_handler[1].flow_id = 0;
                v15[2](v15);
                _Block_release(v15);
              }
              if ((default_input_handler[1].flow_id[8] & 1) != 0)
              {
                v16 = *(const void **)default_input_handler[1].flow_id;
                if (v16)
                  _Block_release(v16);
              }
              v17 = default_input_handler;
              goto LABEL_38;
            }
          }
        }
      }
    }
  }
}

void nw_protocol_udp_link_state(uint64_t a1, uint64_t a2, void *a3)
{
  _DWORD *v4;
  int v5;
  __int16 v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  void *v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t, _DWORD *);
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void (**v23)(_QWORD);
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  void (**v27)(_QWORD);
  const void *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  void (**v32)(_QWORD);
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  void (**v36)(_QWORD);
  const void *v37;
  const char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  char *backtrace_string;
  _BOOL4 v43;
  char *v44;
  _BOOL4 v45;
  const char *v46;
  _BOOL4 v47;
  NSObject *v48;
  NSObject *v49;
  char v50;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  char *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_protocol_udp_link_state";
    v38 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v38, &type, &v50))
      goto LABEL_118;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_118;
      *(_DWORD *)buf = 136446210;
      v53 = "nw_protocol_udp_link_state";
      v41 = "%{public}s called with null link_info";
    }
    else if (v50)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v39 = __nwlog_obj();
      v40 = type;
      v43 = os_log_type_enabled(v39, type);
      if (backtrace_string)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          v53 = "nw_protocol_udp_link_state";
          v54 = 2082;
          v55 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s called with null link_info, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_118:
        if (!v38)
          return;
        goto LABEL_119;
      }
      if (!v43)
        goto LABEL_118;
      *(_DWORD *)buf = 136446210;
      v53 = "nw_protocol_udp_link_state";
      v41 = "%{public}s called with null link_info, no backtrace";
    }
    else
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_118;
      *(_DWORD *)buf = 136446210;
      v53 = "nw_protocol_udp_link_state";
      v41 = "%{public}s called with null link_info, backtrace limit exceeded";
    }
    goto LABEL_117;
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_protocol_udp_link_state";
    v38 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v38, &type, &v50))
      goto LABEL_118;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v50)
      {
        v39 = __nwlog_obj();
        v40 = type;
        if (!os_log_type_enabled(v39, type))
          goto LABEL_118;
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_udp_link_state";
        v41 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_117;
      }
      v44 = (char *)__nw_create_backtrace_string();
      v39 = __nwlog_obj();
      v40 = type;
      v45 = os_log_type_enabled(v39, type);
      if (!v44)
      {
        if (!v45)
          goto LABEL_118;
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_udp_link_state";
        v41 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_117;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v53 = "nw_protocol_udp_link_state";
        v54 = 2082;
        v55 = v44;
        v46 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_98:
        _os_log_impl(&dword_182FBE000, v39, v40, v46, buf, 0x16u);
      }
LABEL_99:
      free(v44);
      if (!v38)
        return;
LABEL_119:
      v29 = (char *)v38;
LABEL_56:
      free(v29);
      return;
    }
    v39 = __nwlog_obj();
    v40 = type;
    if (!os_log_type_enabled(v39, type))
      goto LABEL_118;
    *(_DWORD *)buf = 136446210;
    v53 = "nw_protocol_udp_link_state";
    v41 = "%{public}s called with null protocol";
LABEL_117:
    _os_log_impl(&dword_182FBE000, v39, v40, v41, buf, 0xCu);
    goto LABEL_118;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_protocol_udp_link_state";
    v38 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v38, &type, &v50))
      goto LABEL_118;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_118;
      *(_DWORD *)buf = 136446210;
      v53 = "nw_protocol_udp_link_state";
      v41 = "%{public}s called with null udp";
      goto LABEL_117;
    }
    if (!v50)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_118;
      *(_DWORD *)buf = 136446210;
      v53 = "nw_protocol_udp_link_state";
      v41 = "%{public}s called with null udp, backtrace limit exceeded";
      goto LABEL_117;
    }
    v44 = (char *)__nw_create_backtrace_string();
    v39 = __nwlog_obj();
    v40 = type;
    v47 = os_log_type_enabled(v39, type);
    if (!v44)
    {
      if (!v47)
        goto LABEL_118;
      *(_DWORD *)buf = 136446210;
      v53 = "nw_protocol_udp_link_state";
      v41 = "%{public}s called with null udp, no backtrace";
      goto LABEL_117;
    }
    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      v53 = "nw_protocol_udp_link_state";
      v54 = 2082;
      v55 = v44;
      v46 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    goto LABEL_99;
  }
  v4 = a3;
  v5 = v4[2];

  if (v5 == 1)
  {
    if (gLogDatapath)
    {
      v49 = __nwlog_obj();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v53 = "nw_protocol_udp_link_state";
        v54 = 2082;
        v55 = (char *)(a1 + 192);
        _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s udp flow controlled", buf, 0x16u);
      }
    }
    v13 = *(_WORD *)(a1 + 190) | 1;
    goto LABEL_25;
  }
  if (!v5)
  {
    if (gLogDatapath)
    {
      v48 = __nwlog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v53 = "nw_protocol_udp_link_state";
        v54 = 2082;
        v55 = (char *)(a1 + 192);
        _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s udp flow resumed", buf, 0x16u);
      }
    }
    v6 = *(_WORD *)(a1 + 190);
    v7 = v6 & 0xFFFE;
    *(_WORD *)(a1 + 190) = v6 & 0xFFFE;
    if ((v6 & 2) != 0)
    {
      v8 = *(_QWORD *)(a1 + 48);
      if (v8)
      {
        v9 = *(_QWORD *)(v8 + 24);
        if (v9)
        {
          v10 = *(void (**)(uint64_t, uint64_t))(v9 + 72);
          if (v10)
          {
            v11 = *(void **)(v8 + 40);
            if (v11 == &nw_protocol_ref_counted_handle)
            {
              v12 = *(_QWORD *)(v8 + 88);
              if (v12)
                *(_QWORD *)(v8 + 88) = v12 + 1;
            }
            if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              v14 = *(_QWORD *)(a1 + 88);
              if (v14)
                *(_QWORD *)(a1 + 88) = v14 + 1;
              v10(v8, a1);
              if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
              {
                v30 = *(_QWORD *)(a1 + 88);
                if (v30)
                {
                  v31 = v30 - 1;
                  *(_QWORD *)(a1 + 88) = v31;
                  if (!v31)
                  {
                    v32 = *(void (***)(_QWORD))(a1 + 64);
                    if (v32)
                    {
                      *(_QWORD *)(a1 + 64) = 0;
                      v32[2](v32);
                      _Block_release(v32);
                    }
                    if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                    {
                      v33 = *(const void **)(a1 + 64);
                      if (v33)
                        _Block_release(v33);
                    }
                    free((void *)a1);
                  }
                }
              }
            }
            else
            {
              v10(v8, a1);
            }
            if (v11 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v8 + 40) == &nw_protocol_ref_counted_handle)
            {
              v34 = *(_QWORD *)(v8 + 88);
              if (v34)
              {
                v35 = v34 - 1;
                *(_QWORD *)(v8 + 88) = v35;
                if (!v35)
                {
                  v36 = *(void (***)(_QWORD))(v8 + 64);
                  if (v36)
                  {
                    *(_QWORD *)(v8 + 64) = 0;
                    v36[2](v36);
                    _Block_release(v36);
                  }
                  if ((*(_BYTE *)(v8 + 72) & 1) != 0)
                  {
                    v37 = *(const void **)(v8 + 64);
                    if (v37)
                      _Block_release(v37);
                  }
                  free((void *)v8);
                }
              }
            }
            v7 = *(_WORD *)(a1 + 190);
          }
        }
      }
      v13 = v7 & 0xFFFD;
LABEL_25:
      *(_WORD *)(a1 + 190) = v13;
    }
  }
  v15 = *(_QWORD *)(a1 + 48);
  if (v15)
  {
    v16 = *(_QWORD *)(v15 + 24);
    if (v16)
    {
      v17 = *(void (**)(uint64_t, uint64_t, _DWORD *))(v16 + 104);
      if (v17)
      {
        v18 = *(void **)(v15 + 40);
        if (v18 == &nw_protocol_ref_counted_handle)
        {
          v19 = *(_QWORD *)(v15 + 88);
          if (v19)
            *(_QWORD *)(v15 + 88) = v19 + 1;
        }
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          v20 = *(_QWORD *)(a1 + 88);
          if (v20)
            *(_QWORD *)(a1 + 88) = v20 + 1;
          v17(v15, a1, v4);
          if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            v21 = *(_QWORD *)(a1 + 88);
            if (v21)
            {
              v22 = v21 - 1;
              *(_QWORD *)(a1 + 88) = v22;
              if (!v22)
              {
                v23 = *(void (***)(_QWORD))(a1 + 64);
                if (v23)
                {
                  *(_QWORD *)(a1 + 64) = 0;
                  v23[2](v23);
                  _Block_release(v23);
                }
                if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                {
                  v24 = *(const void **)(a1 + 64);
                  if (v24)
                    _Block_release(v24);
                }
                free((void *)a1);
              }
            }
          }
        }
        else
        {
          v17(v15, a1, v4);
        }
        if (v18 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v15 + 40) == &nw_protocol_ref_counted_handle)
        {
          v25 = *(_QWORD *)(v15 + 88);
          if (v25)
          {
            v26 = v25 - 1;
            *(_QWORD *)(v15 + 88) = v26;
            if (!v26)
            {
              v27 = *(void (***)(_QWORD))(v15 + 64);
              if (v27)
              {
                *(_QWORD *)(v15 + 64) = 0;
                v27[2](v27);
                _Block_release(v27);
              }
              if ((*(_BYTE *)(v15 + 72) & 1) != 0)
              {
                v28 = *(const void **)(v15 + 64);
                if (v28)
                  _Block_release(v28);
              }
              v29 = (char *)v15;
              goto LABEL_56;
            }
          }
        }
      }
    }
  }
}

uint64_t nw_protocol_udp_updated_path(nw_protocol *a1, nw_protocol *a2, nw_path *object)
{
  nw_protocol *default_input_handler;
  void *output_handler_context;
  void *handle;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v10;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  __int16 output_handler_context_high;
  NSObject *v18;
  const char *v19;
  nw_protocol *v20;
  nw_protocol_callbacks *v21;
  uint64_t v22;
  void *v23;
  nw_protocol_callbacks *v24;
  void *v25;
  nw_protocol_callbacks *v26;
  nw_protocol_callbacks *v27;
  void (*error)(nw_protocol *, nw_protocol *, uint64_t);
  nw_protocol_callbacks *v29;
  nw_protocol_callbacks *v30;
  void (**v31)(_QWORD);
  const void *v32;
  nw_protocol_callbacks *v33;
  nw_protocol_callbacks *v34;
  void (**v35)(_QWORD);
  const void *v36;
  nw_protocol *output_handler;
  nw_protocol_callbacks *v38;
  uint64_t (*updated_path)(nw_protocol *, nw_protocol *, nw_path *);
  void *v40;
  nw_protocol_callbacks *v41;
  uint64_t v42;
  nw_protocol_callbacks *v43;
  nw_protocol_callbacks *v45;
  nw_protocol_callbacks *v46;
  void (**v47)(_QWORD);
  const void *v48;
  nw_protocol_callbacks *v49;
  nw_protocol_callbacks *v50;
  void (**v51)(_QWORD);
  const void *v52;
  nw_protocol_callbacks *v53;
  nw_protocol_callbacks *v54;
  void (**v55)(_QWORD);
  const void *v56;
  nw_protocol_identifier *identifier;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  nw_protocol_identifier *v61;
  const char *v62;
  char *v63;
  NSObject *v64;
  os_log_type_t v65;
  const char *v66;
  NSObject *v67;
  int output_handler_context_low;
  int v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  char *v74;
  NSObject *v75;
  _BOOL4 v76;
  nw_protocol_identifier *v77;
  char *backtrace_string;
  _BOOL4 v79;
  const char *v80;
  _BOOL4 v81;
  _BOOL4 v82;
  char *v83;
  _BOOL4 v84;
  nw_protocol_identifier *v85;
  NSObject *v86;
  NSObject *v87;
  int v88;
  int v89;
  nw_protocol_identifier *v90;
  const char *name;
  char *v92;
  NSObject *v93;
  os_log_type_t v94;
  const char *v95;
  const char *v96;
  char *v97;
  _BOOL4 v98;
  const char *v99;
  const char *v100;
  const char *v101;
  NSObject *log;
  int v103;
  os_log_type_t type[4];
  char v105;
  os_log_type_t v106;
  uint8_t buf[4];
  const char *v108;
  __int16 v109;
  nw_protocol *v110;
  __int16 v111;
  _BYTE v112[10];
  char *v113;
  int v114;
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v108 = "nw_protocol_udp_updated_path";
    v63 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (!__nwlog_fault(v63, type, &v103))
      goto LABEL_194;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v64 = __nwlog_obj();
      v65 = type[0];
      if (!os_log_type_enabled(v64, type[0]))
        goto LABEL_194;
      *(_DWORD *)buf = 136446210;
      v108 = "nw_protocol_udp_updated_path";
      v66 = "%{public}s called with null protocol";
LABEL_193:
      _os_log_impl(&dword_182FBE000, v64, v65, v66, buf, 0xCu);
      goto LABEL_194;
    }
    if (!(_BYTE)v103)
    {
      v64 = __nwlog_obj();
      v65 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_udp_updated_path";
        v66 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_193;
      }
      goto LABEL_194;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v64 = __nwlog_obj();
    v65 = type[0];
    v79 = os_log_type_enabled(v64, type[0]);
    if (!backtrace_string)
    {
      if (v79)
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_udp_updated_path";
        v66 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_193;
      }
      goto LABEL_194;
    }
    if (!v79)
      goto LABEL_157;
    *(_DWORD *)buf = 136446466;
    v108 = "nw_protocol_udp_updated_path";
    v109 = 2082;
    v110 = (nw_protocol *)backtrace_string;
    v80 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_156:
    _os_log_impl(&dword_182FBE000, v64, v65, v80, buf, 0x16u);
    goto LABEL_157;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v108 = "nw_protocol_udp_updated_path";
    v63 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (!__nwlog_fault(v63, type, &v103))
      goto LABEL_194;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v64 = __nwlog_obj();
      v65 = type[0];
      if (!os_log_type_enabled(v64, type[0]))
        goto LABEL_194;
      *(_DWORD *)buf = 136446210;
      v108 = "nw_protocol_udp_updated_path";
      v66 = "%{public}s called with null udp";
      goto LABEL_193;
    }
    if (!(_BYTE)v103)
    {
      v64 = __nwlog_obj();
      v65 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_udp_updated_path";
        v66 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_193;
      }
      goto LABEL_194;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v64 = __nwlog_obj();
    v65 = type[0];
    v81 = os_log_type_enabled(v64, type[0]);
    if (!backtrace_string)
    {
      if (v81)
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_udp_updated_path";
        v66 = "%{public}s called with null udp, no backtrace";
        goto LABEL_193;
      }
      goto LABEL_194;
    }
    if (!v81)
      goto LABEL_157;
    *(_DWORD *)buf = 136446466;
    v108 = "nw_protocol_udp_updated_path";
    v109 = 2082;
    v110 = (nw_protocol *)backtrace_string;
    v80 = "%{public}s called with null udp, dumping backtrace:%{public}s";
    goto LABEL_156;
  }
  if (object)
  {
    if (gLogDatapath)
    {
      v67 = __nwlog_obj();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
      {
        output_handler_context_low = LOWORD(a1[2].output_handler_context);
        v69 = WORD1(a1[2].output_handler_context);
        *(_DWORD *)buf = 136446978;
        v108 = "nw_protocol_udp_updated_path";
        v109 = 2082;
        v110 = a1 + 3;
        v111 = 1024;
        *(_DWORD *)v112 = output_handler_context_low;
        *(_WORD *)&v112[4] = 1024;
        *(_DWORD *)&v112[6] = v69;
        _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s udp[%u,%u]", buf, 0x22u);
      }
    }
    default_input_handler = a1[1].default_input_handler;
    a1[1].default_input_handler = (nw_protocol *)os_retain(object);
    if (default_input_handler)
      os_release(default_input_handler);
    output_handler_context = a1[1].output_handler_context;
    if (a2)
    {
      handle = a2->handle;
      if (handle == &nw_protocol_ref_counted_handle)
      {
        callbacks = a2[1].callbacks;
        if (callbacks)
          a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      v10 = a2->callbacks;
      if (v10)
      {
        get_parameters = (uint64_t (*)(nw_protocol *))v10->get_parameters;
        if (get_parameters)
        {
          v12 = (void *)get_parameters(a2);
          if (handle != &nw_protocol_ref_counted_handle)
            goto LABEL_15;
          goto LABEL_14;
        }
      }
      __nwlog_obj();
      identifier = a2->identifier;
      *(_DWORD *)buf = 136446722;
      v108 = "__nw_protocol_get_parameters";
      if (!identifier)
        identifier = (nw_protocol_identifier *)"invalid";
      v109 = 2082;
      v110 = (nw_protocol *)identifier;
      v111 = 2048;
      *(_QWORD *)v112 = a2;
      v58 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v103) = 0;
      if (!__nwlog_fault(v58, type, &v103))
        goto LABEL_169;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v59 = __nwlog_obj();
        v60 = type[0];
        if (!os_log_type_enabled(v59, type[0]))
          goto LABEL_169;
        v61 = a2->identifier;
        if (!v61)
          v61 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v108 = "__nw_protocol_get_parameters";
        v109 = 2082;
        v110 = (nw_protocol *)v61;
        v111 = 2048;
        *(_QWORD *)v112 = a2;
        v62 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
      }
      else
      {
        if ((_BYTE)v103)
        {
          v74 = (char *)__nw_create_backtrace_string();
          v75 = __nwlog_obj();
          v60 = type[0];
          log = v75;
          v76 = os_log_type_enabled(v75, type[0]);
          if (v74)
          {
            if (v76)
            {
              v77 = a2->identifier;
              if (!v77)
                v77 = (nw_protocol_identifier *)"invalid";
              *(_DWORD *)buf = 136446978;
              v108 = "__nw_protocol_get_parameters";
              v109 = 2082;
              v110 = (nw_protocol *)v77;
              v111 = 2048;
              *(_QWORD *)v112 = a2;
              *(_WORD *)&v112[8] = 2082;
              v113 = v74;
              _os_log_impl(&dword_182FBE000, log, v60, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v74);
          }
          else if (v76)
          {
            v90 = a2->identifier;
            if (!v90)
              v90 = (nw_protocol_identifier *)"invalid";
            *(_DWORD *)buf = 136446722;
            v108 = "__nw_protocol_get_parameters";
            v109 = 2082;
            v110 = (nw_protocol *)v90;
            v111 = 2048;
            *(_QWORD *)v112 = a2;
            v62 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
            v86 = log;
            goto LABEL_168;
          }
LABEL_169:
          if (v58)
            free(v58);
          v12 = 0;
          if (handle == &nw_protocol_ref_counted_handle)
          {
LABEL_14:
            if (a2->handle == &nw_protocol_ref_counted_handle)
            {
              v33 = a2[1].callbacks;
              if (v33)
              {
                v34 = (nw_protocol_callbacks *)((char *)v33 - 1);
                a2[1].callbacks = v34;
                if (!v34)
                {
                  v35 = *(void (***)(_QWORD))a2[1].flow_id;
                  if (v35)
                  {
                    *(_QWORD *)a2[1].flow_id = 0;
                    v35[2](v35);
                    _Block_release(v35);
                  }
                  if ((a2[1].flow_id[8] & 1) != 0)
                  {
                    v36 = *(const void **)a2[1].flow_id;
                    if (v36)
                      _Block_release(v36);
                  }
                  free(a2);
                }
              }
            }
          }
LABEL_15:
          v13 = nw_parameters_copy_context(v12);
          a1[1].output_handler_context = nw_path_copy_flow_registration(v13, (uint64_t)a1);
          if (output_handler_context)
            os_release(output_handler_context);
          if (v13)
            os_release(v13);
          v14 = a1[1].output_handler_context;
          if (!v14)
            goto LABEL_72;
          v103 = 0;
          *(_DWORD *)type = 0;
          if (!nw_path_flow_registration_get_ctl_command(a1[1].default_input_handler, v14, type, &v103, 0))goto LABEL_72;
          if (gLogDatapath)
          {
            v87 = __nwlog_obj();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
            {
              v88 = LOWORD(a1[2].output_handler_context);
              v89 = WORD1(a1[2].output_handler_context);
              *(_DWORD *)buf = 136447490;
              v108 = "nw_protocol_udp_updated_path";
              v109 = 2082;
              v110 = a1 + 3;
              v111 = 1024;
              *(_DWORD *)v112 = v88;
              *(_WORD *)&v112[4] = 1024;
              *(_DWORD *)&v112[6] = v89;
              LOWORD(v113) = 1024;
              *(_DWORD *)((char *)&v113 + 2) = *(_DWORD *)type;
              HIWORD(v113) = 1024;
              v114 = v103;
              _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s udp[%u,%u] Protocol event %d=%d", buf, 0x2Eu);
            }
          }
          v15 = *(unsigned int *)type;
          output_handler_context_high = HIWORD(a1[2].output_handler_context);
          if ((output_handler_context_high & 4) != 0)
          {
            if (LODWORD(a1[2].identifier))
              goto LABEL_31;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v18 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_72;
            *(_DWORD *)buf = 136446466;
            v108 = "udp_ctlinput";
            v109 = 2082;
            v110 = a1 + 3;
            v19 = "%{public}s %{public}s Protocol event reported for socket with faddr INADDR_ANY";
          }
          else
          {
            if (a1[2].identifier != (nw_protocol_identifier *)*MEMORY[0x1E0C83920]
              || a1[2].callbacks != *(nw_protocol_callbacks **)(MEMORY[0x1E0C83920] + 8))
            {
LABEL_31:
              if (*(_DWORD *)type <= 0x15u
                && (*(_DWORD *)type - 14) >= 4
                && ((0xFC01FuLL >> type[0]) & 1) == 0
                && ((output_handler_context_high & 0x80) == 0 || *(_DWORD *)type != 5 && *(_DWORD *)type != 12))
              {
                v20 = a1->default_input_handler;
                if (v20)
                {
                  v21 = v20->callbacks;
                  if (v21)
                  {
                    if (v21->error)
                    {
                      HIWORD(a1[2].output_handler_context) = output_handler_context_high | 0x200;
                      v22 = udpctlerrmap[v15];
                      v23 = v20->handle;
                      if (v23 == &nw_protocol_ref_counted_handle)
                      {
                        v24 = v20[1].callbacks;
                        if (v24)
                          v20[1].callbacks = (nw_protocol_callbacks *)((char *)&v24->add_input_handler + 1);
                      }
                      v25 = a1->handle;
                      if (v25 == &nw_protocol_ref_counted_handle)
                      {
                        v26 = a1[1].callbacks;
                        if (v26)
                          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v26->add_input_handler + 1);
                      }
                      v27 = v20->callbacks;
                      if (v27)
                      {
                        error = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v27->error;
                        if (error)
                        {
                          error(v20, a1, v22);
LABEL_49:
                          if (v25 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
                          {
                            v53 = a1[1].callbacks;
                            if (v53)
                            {
                              v54 = (nw_protocol_callbacks *)((char *)v53 - 1);
                              a1[1].callbacks = v54;
                              if (!v54)
                              {
                                v55 = *(void (***)(_QWORD))a1[1].flow_id;
                                if (v55)
                                {
                                  *(_QWORD *)a1[1].flow_id = 0;
                                  v55[2](v55);
                                  _Block_release(v55);
                                }
                                if ((a1[1].flow_id[8] & 1) != 0)
                                {
                                  v56 = *(const void **)a1[1].flow_id;
                                  if (v56)
                                    _Block_release(v56);
                                }
                                free(a1);
                              }
                            }
                          }
                          if (v23 == &nw_protocol_ref_counted_handle && v20->handle == &nw_protocol_ref_counted_handle)
                          {
                            v29 = v20[1].callbacks;
                            if (v29)
                            {
                              v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
                              v20[1].callbacks = v30;
                              if (!v30)
                              {
                                v31 = *(void (***)(_QWORD))v20[1].flow_id;
                                if (v31)
                                {
                                  *(_QWORD *)v20[1].flow_id = 0;
                                  v31[2](v31);
                                  _Block_release(v31);
                                }
                                if ((v20[1].flow_id[8] & 1) != 0)
                                {
                                  v32 = *(const void **)v20[1].flow_id;
                                  if (v32)
                                    _Block_release(v32);
                                }
                                free(v20);
                              }
                            }
                          }
                          goto LABEL_72;
                        }
                      }
                      __nwlog_obj();
                      name = v20->identifier->name;
                      *(_DWORD *)buf = 136446722;
                      v108 = "__nw_protocol_error";
                      if (!name)
                        name = "invalid";
                      v109 = 2082;
                      v110 = (nw_protocol *)name;
                      v111 = 2048;
                      *(_QWORD *)v112 = v20;
                      v92 = (char *)_os_log_send_and_compose_impl();
                      v106 = OS_LOG_TYPE_ERROR;
                      v105 = 0;
                      if (__nwlog_fault(v92, &v106, &v105))
                      {
                        if (v106 == OS_LOG_TYPE_FAULT)
                        {
                          v93 = __nwlog_obj();
                          v94 = v106;
                          if (!os_log_type_enabled(v93, v106))
                            goto LABEL_227;
                          v95 = v20->identifier->name;
                          if (!v95)
                            v95 = "invalid";
                          *(_DWORD *)buf = 136446722;
                          v108 = "__nw_protocol_error";
                          v109 = 2082;
                          v110 = (nw_protocol *)v95;
                          v111 = 2048;
                          *(_QWORD *)v112 = v20;
                          v96 = "%{public}s protocol %{public}s (%p) has invalid error callback";
                          goto LABEL_226;
                        }
                        if (!v105)
                        {
                          v93 = __nwlog_obj();
                          v94 = v106;
                          if (!os_log_type_enabled(v93, v106))
                            goto LABEL_227;
                          v100 = v20->identifier->name;
                          if (!v100)
                            v100 = "invalid";
                          *(_DWORD *)buf = 136446722;
                          v108 = "__nw_protocol_error";
                          v109 = 2082;
                          v110 = (nw_protocol *)v100;
                          v111 = 2048;
                          *(_QWORD *)v112 = v20;
                          v96 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
                          goto LABEL_226;
                        }
                        v97 = (char *)__nw_create_backtrace_string();
                        v93 = __nwlog_obj();
                        v94 = v106;
                        v98 = os_log_type_enabled(v93, v106);
                        if (v97)
                        {
                          if (v98)
                          {
                            v99 = v20->identifier->name;
                            if (!v99)
                              v99 = "invalid";
                            *(_DWORD *)buf = 136446978;
                            v108 = "__nw_protocol_error";
                            v109 = 2082;
                            v110 = (nw_protocol *)v99;
                            v111 = 2048;
                            *(_QWORD *)v112 = v20;
                            *(_WORD *)&v112[8] = 2082;
                            v113 = v97;
                            _os_log_impl(&dword_182FBE000, v93, v94, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
                          }
                          free(v97);
                          goto LABEL_227;
                        }
                        if (v98)
                        {
                          v101 = v20->identifier->name;
                          if (!v101)
                            v101 = "invalid";
                          *(_DWORD *)buf = 136446722;
                          v108 = "__nw_protocol_error";
                          v109 = 2082;
                          v110 = (nw_protocol *)v101;
                          v111 = 2048;
                          *(_QWORD *)v112 = v20;
                          v96 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
LABEL_226:
                          _os_log_impl(&dword_182FBE000, v93, v94, v96, buf, 0x20u);
                        }
                      }
LABEL_227:
                      if (v92)
                        free(v92);
                      goto LABEL_49;
                    }
                  }
                }
              }
LABEL_72:
              LODWORD(a1[2].default_input_handler) = nw_path_get_effective_traffic_class(a1[1].default_input_handler);
              output_handler = a1->output_handler;
              if (!output_handler)
                return 1;
              v38 = output_handler->callbacks;
              if (!v38)
                return 1;
              updated_path = (uint64_t (*)(nw_protocol *, nw_protocol *, nw_path *))v38->updated_path;
              if (!updated_path)
                return 1;
              v40 = output_handler->handle;
              if (v40 == &nw_protocol_ref_counted_handle)
              {
                v41 = output_handler[1].callbacks;
                if (v41)
                  output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v41->add_input_handler + 1);
              }
              if (a1->handle == &nw_protocol_ref_counted_handle)
              {
                v43 = a1[1].callbacks;
                if (v43)
                  a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v43->add_input_handler + 1);
                v42 = updated_path(output_handler, a1, object);
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  v45 = a1[1].callbacks;
                  if (v45)
                  {
                    v46 = (nw_protocol_callbacks *)((char *)v45 - 1);
                    a1[1].callbacks = v46;
                    if (!v46)
                    {
                      v47 = *(void (***)(_QWORD))a1[1].flow_id;
                      if (v47)
                      {
                        *(_QWORD *)a1[1].flow_id = 0;
                        v47[2](v47);
                        _Block_release(v47);
                      }
                      if ((a1[1].flow_id[8] & 1) != 0)
                      {
                        v48 = *(const void **)a1[1].flow_id;
                        if (v48)
                          _Block_release(v48);
                      }
                      free(a1);
                    }
                  }
                }
              }
              else
              {
                v42 = updated_path(output_handler, a1, object);
              }
              if (v40 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
              {
                v49 = output_handler[1].callbacks;
                if (v49)
                {
                  v50 = (nw_protocol_callbacks *)((char *)v49 - 1);
                  output_handler[1].callbacks = v50;
                  if (!v50)
                  {
                    v51 = *(void (***)(_QWORD))output_handler[1].flow_id;
                    if (v51)
                    {
                      *(_QWORD *)output_handler[1].flow_id = 0;
                      v51[2](v51);
                      _Block_release(v51);
                    }
                    if ((output_handler[1].flow_id[8] & 1) != 0)
                    {
                      v52 = *(const void **)output_handler[1].flow_id;
                      if (v52)
                        _Block_release(v52);
                    }
                    free(output_handler);
                  }
                }
              }
              return v42;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v18 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_72;
            *(_DWORD *)buf = 136446466;
            v108 = "udp_ctlinput";
            v109 = 2082;
            v110 = a1 + 3;
            v19 = "%{public}s %{public}s Protocol event reported for socket with faddr IN6ADDR_ANY";
          }
          _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0x16u);
          goto LABEL_72;
        }
        v59 = __nwlog_obj();
        v60 = type[0];
        if (!os_log_type_enabled(v59, type[0]))
          goto LABEL_169;
        v85 = a2->identifier;
        if (!v85)
          v85 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v108 = "__nw_protocol_get_parameters";
        v109 = 2082;
        v110 = (nw_protocol *)v85;
        v111 = 2048;
        *(_QWORD *)v112 = a2;
        v62 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
      }
      v86 = v59;
LABEL_168:
      _os_log_impl(&dword_182FBE000, v86, v60, v62, buf, 0x20u);
      goto LABEL_169;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v108 = "__nw_protocol_get_parameters";
    v70 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v103) = 0;
    if (__nwlog_fault(v70, type, &v103))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v71 = __nwlog_obj();
        v72 = type[0];
        if (os_log_type_enabled(v71, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v108 = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol";
LABEL_199:
          _os_log_impl(&dword_182FBE000, v71, v72, v73, buf, 0xCu);
        }
      }
      else if ((_BYTE)v103)
      {
        v83 = (char *)__nw_create_backtrace_string();
        v71 = __nwlog_obj();
        v72 = type[0];
        v84 = os_log_type_enabled(v71, type[0]);
        if (v83)
        {
          if (v84)
          {
            *(_DWORD *)buf = 136446466;
            v108 = "__nw_protocol_get_parameters";
            v109 = 2082;
            v110 = (nw_protocol *)v83;
            _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v83);
          goto LABEL_200;
        }
        if (v84)
        {
          *(_DWORD *)buf = 136446210;
          v108 = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_199;
        }
      }
      else
      {
        v71 = __nwlog_obj();
        v72 = type[0];
        if (os_log_type_enabled(v71, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v108 = "__nw_protocol_get_parameters";
          v73 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_199;
        }
      }
    }
LABEL_200:
    if (v70)
      free(v70);
    v12 = 0;
    goto LABEL_15;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v108 = "nw_protocol_udp_updated_path";
  v63 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v103) = 0;
  if (!__nwlog_fault(v63, type, &v103))
    goto LABEL_194;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!(_BYTE)v103)
    {
      v64 = __nwlog_obj();
      v65 = type[0];
      if (os_log_type_enabled(v64, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_udp_updated_path";
        v66 = "%{public}s called with null path, backtrace limit exceeded";
        goto LABEL_193;
      }
      goto LABEL_194;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v64 = __nwlog_obj();
    v65 = type[0];
    v82 = os_log_type_enabled(v64, type[0]);
    if (!backtrace_string)
    {
      if (v82)
      {
        *(_DWORD *)buf = 136446210;
        v108 = "nw_protocol_udp_updated_path";
        v66 = "%{public}s called with null path, no backtrace";
        goto LABEL_193;
      }
      goto LABEL_194;
    }
    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      v108 = "nw_protocol_udp_updated_path";
      v109 = 2082;
      v110 = (nw_protocol *)backtrace_string;
      v80 = "%{public}s called with null path, dumping backtrace:%{public}s";
      goto LABEL_156;
    }
LABEL_157:
    free(backtrace_string);
    goto LABEL_194;
  }
  v64 = __nwlog_obj();
  v65 = type[0];
  if (os_log_type_enabled(v64, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    v108 = "nw_protocol_udp_updated_path";
    v66 = "%{public}s called with null path";
    goto LABEL_193;
  }
LABEL_194:
  if (v63)
    free(v63);
  return 0;
}

void nw_protocol_udp_get_message_properties(uint64_t a1, uint64_t a2, int *a3)
{
  int v3;
  unsigned int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_udp_get_message_properties";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_udp_get_message_properties";
      v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_udp_get_message_properties";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v5)
          return;
LABEL_37:
        free(v5);
        return;
      }
      if (!v10)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_udp_get_message_properties";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_udp_get_message_properties";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_36;
  }
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      v3 = *(_DWORD *)(a1 + 180);
      if (!v3)
        v3 = 4000;
      v4 = a3[1] & 0xFFFFFFF8 | 1;
      *a3 = v3;
      a3[1] = v4;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_udp_get_message_properties";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_udp_get_message_properties";
    v8 = "%{public}s called with null udp";
    goto LABEL_35;
  }
  if (!v13)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_udp_get_message_properties";
    v8 = "%{public}s called with null udp, backtrace limit exceeded";
    goto LABEL_35;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_udp_get_message_properties";
    v8 = "%{public}s called with null udp, no backtrace";
    goto LABEL_35;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_protocol_udp_get_message_properties";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null udp, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5)
    goto LABEL_37;
}

void nw_protocol_udp_error(nw_protocol *a1, nw_protocol *a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char *v8;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_udp_error";
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_udp_error";
      v5 = "%{public}s called with null protocol";
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_protocol_udp_error";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_33:
        if (!v2)
          return;
        goto LABEL_34;
      }
      if (!v7)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_udp_error";
      v5 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_udp_error";
      v5 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_32:
    _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    goto LABEL_33;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    if (a1->default_input_handler)
      nw_protocol_common_error((uint64_t)a1, (uint64_t)a2);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_protocol_udp_error";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10))
    goto LABEL_33;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_udp_error";
    v5 = "%{public}s called with null udp";
    goto LABEL_32;
  }
  if (!v10)
  {
    v3 = __nwlog_obj();
    v4 = type;
    if (!os_log_type_enabled(v3, type))
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_udp_error";
    v5 = "%{public}s called with null udp, backtrace limit exceeded";
    goto LABEL_32;
  }
  v8 = (char *)__nw_create_backtrace_string();
  v3 = __nwlog_obj();
  v4 = type;
  v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9)
      goto LABEL_33;
    *(_DWORD *)buf = 136446210;
    v13 = "nw_protocol_udp_error";
    v5 = "%{public}s called with null udp, no backtrace";
    goto LABEL_32;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    v13 = "nw_protocol_udp_error";
    v14 = 2082;
    v15 = v8;
    _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null udp, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v8);
  if (v2)
LABEL_34:
    free(v2);
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke()
{
  _BOOL8 result;

  result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

int *nw_protocol_udp_identifier()
{
  if (nw_protocol_udp_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
  return &nw_protocol_udp_identifier::identifier;
}

uint64_t udp_validate_cksum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;

  v4 = *(unsigned __int8 *)(a3 + 1);
  if (v4 == 2)
    v5 = (unsigned __int16 *)(a3 + 4);
  else
    v5 = (unsigned __int16 *)(a3 + 8);
  if (*(_BYTE *)(a4 + 1) == 2)
    v6 = (unsigned __int16 *)(a4 + 4);
  else
    v6 = (unsigned __int16 *)(a4 + 8);
  return udp_validate_cksum_internal(a1, a2, v5, v6, v4 == 30, 0);
}

void nw::zlib_encoder::~zlib_encoder(nw::zlib_encoder *this)
{
  *(_QWORD *)this = &off_1E1492448;
  deflateEnd((z_streamp)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_1E1492448;
  deflateEnd((z_streamp)((char *)this + 8));
  JUMPOUT(0x186DB356CLL);
}

uint64_t nw::zlib_encoder::encode(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  z_stream *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  _BOOL4 v27;
  NSObject *log;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  void *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 8) = a2;
  v9 = (z_stream *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = a3;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, a3);
  if (v10)
  {
    v11 = 0;
    *(_QWORD *)(a1 + 32) = v10;
    if (a4)
      v12 = 4;
    else
      v12 = 0;
    while (1)
    {
      *(_DWORD *)(a1 + 40) = a3;
      v13 = deflate(v9, v12);
      if (v13)
      {
        v14 = v13;
        if (v13 != -5)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v19 = zError(v14);
            *(_DWORD *)buf = 136446466;
            v32 = "encode";
            v33 = 2080;
            v34 = (void *)v19;
            _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s deflate returned %s", buf, 0x16u);
          }
          return -1;
        }
      }
      v15 = *(unsigned int *)(a1 + 40);
      v16 = (void *)(a3 - v15);
      if (gLogDatapath)
      {
        log = __nwlog_obj();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v32 = "encode";
          v33 = 2048;
          v34 = v16;
          _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s writing %zu bytes of compressed data", buf, 0x16u);
        }
        v11 += (uint64_t)v16;
        if (*(_DWORD *)(a1 + 40))
          return v11;
      }
      else
      {
        v11 += (uint64_t)v16;
        if ((_DWORD)v15)
          return v11;
      }
      v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, a3);
      if (!v17)
        break;
      *(_QWORD *)(a1 + 32) = v17;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v32 = "encode";
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v21, &type, &v29))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v32 = "encode";
      v24 = "%{public}s called with null out_bytes";
LABEL_33:
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
      goto LABEL_34;
    }
    if (!v29)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v32 = "encode";
      v24 = "%{public}s called with null out_bytes, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v26 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (!v26)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v32 = "encode";
      v24 = "%{public}s called with null out_bytes, no backtrace";
      goto LABEL_33;
    }
    if (!v26)
      goto LABEL_28;
    *(_DWORD *)buf = 136446466;
    v32 = "encode";
    v33 = 2082;
    v34 = backtrace_string;
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v32 = "encode";
  v21 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v29 = 0;
  if (!__nwlog_fault(v21, &type, &v29))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v32 = "encode";
    v24 = "%{public}s called with null out_bytes";
    goto LABEL_33;
  }
  if (!v29)
  {
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v32 = "encode";
    v24 = "%{public}s called with null out_bytes, backtrace limit exceeded";
    goto LABEL_33;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  v22 = __nwlog_obj();
  v23 = type;
  v27 = os_log_type_enabled(v22, type);
  if (!backtrace_string)
  {
    if (!v27)
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v32 = "encode";
    v24 = "%{public}s called with null out_bytes, no backtrace";
    goto LABEL_33;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136446466;
    v32 = "encode";
    v33 = 2082;
    v34 = backtrace_string;
LABEL_27:
    _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null out_bytes, dumping backtrace:%{public}s", buf, 0x16u);
  }
LABEL_28:
  free(backtrace_string);
LABEL_34:
  if (v21)
    free(v21);
  return 0;
}

void nw::brotli_encoder::~brotli_encoder(nw::brotli_encoder *this)
{
  *(_QWORD *)this = &off_1E1492498;
  compression_stream_destroy((compression_stream *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_1E1492498;
  compression_stream_destroy((compression_stream *)((char *)this + 8));
  JUMPOUT(0x186DB356CLL);
}

uint64_t nw::brotli_encoder::encode(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t i;
  compression_status v10;
  uint64_t v11;
  NSObject *v12;
  int v14;
  const char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 16) = 0x4000;
  v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, 0x4000);
  if (v8)
  {
    for (i = 0; ; i += 0x4000)
    {
      *(_QWORD *)(a1 + 8) = v8;
      v10 = compression_stream_process((compression_stream *)(a1 + 8), a4);
      if (v10)
      {
        if (v10 == COMPRESSION_STATUS_ERROR)
          return -1;
        v11 = *(_QWORD *)(a1 + 16);
        return i - v11 + 0x4000;
      }
      v11 = *(_QWORD *)(a1 + 16);
      if (v11)
        return i - v11 + 0x4000;
      *(_QWORD *)(a1 + 16) = 0x4000;
      v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, 0x4000);
      if (!v8)
        break;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v14 = 136446210;
      v15 = "encode";
      goto LABEL_14;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v14 = 136446210;
      v15 = "encode";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s allocation failed", (uint8_t *)&v14, 0xCu);
    }
  }
  return -1;
}

void nw::zlib_decoder::~zlib_decoder(nw::zlib_decoder *this)
{
  *(_QWORD *)this = &off_1E1492420;
  inflateEnd((z_streamp)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_1E1492420;
  inflateEnd((z_streamp)((char *)this + 8));
  JUMPOUT(0x186DB356CLL);
}

uint64_t nw::zlib_decoder::decode(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _BYTE *a5, uint64_t a6)
{
  z_stream *v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  const char *v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  NSObject *v27;
  NSObject *log;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 8) = a2;
  v10 = (z_stream *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = a3;
  v11 = 0;
  for (*(_QWORD *)(a1 + 32) = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 16))(a6, 0x4000);
        ;
        *(_QWORD *)(a1 + 32) = v14)
  {
    *(_DWORD *)(a1 + 40) = 0x4000;
    v12 = inflate(v10, 0);
    v13 = v12;
    if (v12 != -5 && v12)
    {
      if (v12 != 1)
        goto LABEL_13;
      goto LABEL_16;
    }
    if (*(_DWORD *)(a1 + 40))
      break;
    if (gLogDatapath)
    {
      log = __nwlog_obj();
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v33 = "decode";
        v34 = 2048;
        v35 = 0x4000;
        v36 = 1024;
        v37 = v13;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s delivering %zu bytes of uncompressed data %d", buf, 0x1Cu);
      }
    }
    v14 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 16))(a6, 0x4000);
    if (!v14)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v33 = "decode";
      v21 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v30 = 0;
      if (!__nwlog_fault(v21, &type, &v30))
        goto LABEL_40;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "decode";
          v24 = "%{public}s called with null out_bytes";
          goto LABEL_39;
        }
        goto LABEL_40;
      }
      if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v22 = __nwlog_obj();
        v23 = type;
        v26 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "decode";
            v34 = 2082;
            v35 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null out_bytes, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_40;
        }
        if (!v26)
        {
LABEL_40:
          if (v21)
            free(v21);
          return 0;
        }
        *(_DWORD *)buf = 136446210;
        v33 = "decode";
        v24 = "%{public}s called with null out_bytes, no backtrace";
      }
      else
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (!os_log_type_enabled(v22, type))
          goto LABEL_40;
        *(_DWORD *)buf = 136446210;
        v33 = "decode";
        v24 = "%{public}s called with null out_bytes, backtrace limit exceeded";
      }
LABEL_39:
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
      goto LABEL_40;
    }
    v11 += 0x4000;
  }
  if (*(_DWORD *)(a1 + 16))
  {
LABEL_13:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v16 = zError(v13);
      *(_DWORD *)buf = 136446466;
      v33 = "decode";
      v34 = 2080;
      v35 = (uint64_t)v16;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s inflate returned %s", buf, 0x16u);
    }
    v17 = -1;
LABEL_22:
    if (a4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "decode";
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s truncated data", buf, 0xCu);
      }
    }
    return v17;
  }
LABEL_16:
  if (gLogDatapath)
  {
    v27 = __nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v33 = "decode";
      v34 = 2048;
      v35 = a3;
      _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s finished processing %zu bytes of compressed data", buf, 0x16u);
    }
  }
  v17 = v11 - *(unsigned int *)(a1 + 40) + 0x4000;
  if (v13 != 1)
    goto LABEL_22;
  if (*(_DWORD *)(a1 + 16))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v33 = "decode";
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s extra data", buf, 0xCu);
    }
  }
  *a5 = 1;
  return v17;
}

void nw::brotli_decoder::~brotli_decoder(nw::brotli_decoder *this)
{
  *(_QWORD *)this = &off_1E1492470;
  compression_stream_destroy((compression_stream *)((char *)this + 8));
}

{
  *(_QWORD *)this = &off_1E1492470;
  compression_stream_destroy((compression_stream *)((char *)this + 8));
  JUMPOUT(0x186DB356CLL);
}

uint64_t nw::brotli_decoder::decode(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _BYTE *a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t i;
  compression_status v12;
  NSObject *v13;
  NSObject *v14;
  int v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 16) = 0x4000;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 16))(a6, 0x4000);
  if (v10)
  {
    for (i = 0; ; i += 0x4000)
    {
      *(_QWORD *)(a1 + 8) = v10;
      v12 = compression_stream_process((compression_stream *)(a1 + 8), 0);
      if (v12)
        break;
      if (*(_QWORD *)(a1 + 16))
      {
        if (a4)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v16 = 136446210;
            v17 = "decode";
            _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s truncated data", (uint8_t *)&v16, 0xCu);
          }
        }
        return i - *(_QWORD *)(a1 + 16) + 0x4000;
      }
      *(_QWORD *)(a1 + 16) = 0x4000;
      v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 16))(a6, 0x4000);
      if (!v10)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v16 = 136446210;
          v17 = "decode";
LABEL_18:
          _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s allocation failed", (uint8_t *)&v16, 0xCu);
        }
        return -1;
      }
    }
    if (v12 == COMPRESSION_STATUS_ERROR)
      return -1;
    if (v12 == COMPRESSION_STATUS_END)
      *a5 = 1;
    return i - *(_QWORD *)(a1 + 16) + 0x4000;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    v16 = 136446210;
    v17 = "decode";
    goto LABEL_18;
  }
  return -1;
}

BOOL nw_decoder_create_gzip()
{
  char *v0;
  _BOOL8 result;
  NSObject *v2;
  void *v3;

  v0 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xEAFB8F1AuLL);
  if (v0)
    goto LABEL_2;
  v2 = __nwlog_obj();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  v3 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
LABEL_2:
    *(_QWORD *)v0 = &off_1E1492420;
    *((_DWORD *)v0 + 30) = 31;
    inflateInit2_((z_streamp)(v0 + 8), 31, "1.2.12", 112);
    return (BOOL)v0;
  }
  __break(1u);
  return result;
}

BOOL nw_decoder_create_deflate()
{
  char *v0;
  _BOOL8 result;
  NSObject *v2;
  void *v3;

  v0 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xEAFB8F1AuLL);
  if (v0)
    goto LABEL_2;
  v2 = __nwlog_obj();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  v3 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
LABEL_2:
    *(_QWORD *)v0 = &off_1E1492420;
    *((_DWORD *)v0 + 30) = 15;
    inflateInit2_((z_streamp)(v0 + 8), 15, "1.2.12", 112);
    return (BOOL)v0;
  }
  __break(1u);
  return result;
}

BOOL nw_decoder_create_raw_deflate()
{
  char *v0;
  _BOOL8 result;
  NSObject *v2;
  void *v3;

  v0 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xEAFB8F1AuLL);
  if (v0)
    goto LABEL_2;
  v2 = __nwlog_obj();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  v3 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
LABEL_2:
    *(_QWORD *)v0 = &off_1E1492420;
    *((_DWORD *)v0 + 30) = -15;
    inflateInit2_((z_streamp)(v0 + 8), -15, "1.2.12", 112);
    return (BOOL)v0;
  }
  __break(1u);
  return result;
}

BOOL nw_decoder_create_brotli()
{
  char *v0;
  NSObject *v1;
  _BOOL8 result;
  NSObject *v3;
  void *v4;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v0 = (char *)malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL);
  if (!v0)
  {
    v3 = __nwlog_obj();
    os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v6 = "strict_calloc";
    v7 = 2048;
    v8 = 1;
    v9 = 2048;
    v10 = 48;
    v4 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v4);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v4);
  }
  *(_QWORD *)v0 = &off_1E1492470;
  if (compression_stream_init((compression_stream *)(v0 + 8), COMPRESSION_STREAM_DECODE, COMPRESSION_BROTLI))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v6 = "brotli_decoder";
      _os_log_impl(&dword_182FBE000, v1, OS_LOG_TYPE_ERROR, "%{public}s init failed", buf, 0xCu);
    }
  }
  return (BOOL)v0;
}

const char *nw_browse_result_get_description(void *a1, int a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  const char **v5;
  _BOOL8 interfaces_description_locked;
  id v7;
  const char *logging_description;
  const char *v9;
  const char *description;

  v3 = a1;
  v4 = v3;
  if (v3)
  {
    os_unfair_lock_lock(v3 + 12);
    if (a2)
    {
      v5 = (const char **)&v4[10];
      if (!*(_QWORD *)&v4[10]._os_unfair_lock_opaque)
      {
        interfaces_description_locked = nw_browse_result_get_interfaces_description_locked((NWConcrete_nw_browse_result *)v4);
        v7 = *(id *)&v4[2]._os_unfair_lock_opaque;
        logging_description = nw_endpoint_get_logging_description(v7);
        asprintf((char **)&v4[10], "%s@%s", logging_description, (const char *)interfaces_description_locked);
LABEL_8:
        if (interfaces_description_locked)
          free((void *)interfaces_description_locked);

      }
    }
    else
    {
      v5 = (const char **)&v4[8];
      if (!*(_QWORD *)&v4[8]._os_unfair_lock_opaque)
      {
        interfaces_description_locked = nw_browse_result_get_interfaces_description_locked((NWConcrete_nw_browse_result *)v4);
        v7 = *(id *)&v4[2]._os_unfair_lock_opaque;
        description = nw_endpoint_get_description(v7);
        asprintf((char **)&v4[8], "%s@%s", description, (const char *)interfaces_description_locked);
        goto LABEL_8;
      }
    }
    os_unfair_lock_unlock(v4 + 12);
    v9 = *v5;
    goto LABEL_12;
  }
  v9 = "<NULL>";
LABEL_12:

  return v9;
}

void sub_183323134(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_browse_result_get_interfaces_description_locked(NWConcrete_nw_browse_result *a1)
{
  NWConcrete_nw_browse_result *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  size_t v5;
  _WORD *v6;
  unsigned __int8 *v7;
  uint64_t *v8;
  _BOOL8 result;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  void *v13;
  _QWORD v14[7];
  _QWORD v15[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const char *v21;
  __int16 v22;
  size_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 3;
  v2 = *((_QWORD *)v1 + 2);
  if (v2)
    v3 = (uint64_t)(*(_QWORD *)(v2 + 24) - *(_QWORD *)(v2 + 16)) >> 3;
  else
    v3 = 0;
  v4 = MEMORY[0x1E0C809B0];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = ___ZL50nw_browse_result_get_interfaces_description_lockedP27NWConcrete_nw_browse_result_block_invoke;
  v15[3] = &unk_1E14A8F50;
  v15[4] = &v16;
  v15[5] = v3;
  nw_array_apply((unsigned __int8 *)v2, (uint64_t)v15);
  v5 = v17[3];
  if (!v5)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    v20 = 136446210;
    v21 = "strict_malloc";
    v11 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v11);
    if (result)
      goto LABEL_11;
    free(v11);
  }
  v6 = malloc_type_malloc(v5, 0xF2B69DE5uLL);
  if (v6)
  {
LABEL_6:
    *v6 = 91;
    v7 = (unsigned __int8 *)*((_QWORD *)v1 + 2);
    v14[0] = v4;
    v14[1] = 3221225472;
    v14[2] = ___ZL50nw_browse_result_get_interfaces_description_lockedP27NWConcrete_nw_browse_result_block_invoke_2;
    v14[3] = &unk_1E149D218;
    v14[4] = &v16;
    v14[5] = v6;
    v14[6] = v3;
    nw_array_apply(v7, (uint64_t)v14);
    v8 = v17;
    *((_BYTE *)v6 + v17[3] - 2) = 93;
    *((_BYTE *)v6 + v8[3] - 1) = 0;
    _Block_object_dispose(&v16, 8);

    return (BOOL)v6;
  }
  __nwlog_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  v20 = 136446466;
  v21 = "strict_malloc";
  v22 = 2048;
  v23 = v5;
  v13 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    goto LABEL_6;
  }
LABEL_11:
  __break(1u);
  return result;
}

void sub_183323404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  void *v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL50nw_browse_result_get_interfaces_description_lockedP27NWConcrete_nw_browse_result_block_invoke(uint64_t a1, unint64_t a2, uint64_t a3)
{
  const char *v5;

  if (a3)
    v5 = (const char *)(a3 + 104);
  else
    v5 = 0;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += strlen(v5);
  if (*(_QWORD *)(a1 + 40) - 1 > a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 2;
  return 1;
}

BOOL ___ZL50nw_browse_result_get_interfaces_description_lockedP27NWConcrete_nw_browse_result_block_invoke_2(_QWORD *a1, unint64_t a2, void *a3)
{
  char *v5;
  char *v6;
  char *v7;
  _BYTE *v8;
  unint64_t v9;
  _BYTE *v10;
  NSObject *v11;
  void *v12;
  _BOOL8 result;
  uint64_t v14;
  int v15;
  _BYTE *v16;
  unint64_t v17;
  _BYTE *v18;
  NSObject *v19;
  void *v20;
  NSObject *v21;
  void *v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  void *v30;

  v5 = a3;
  v6 = v5;
  if (v5)
    v7 = v5 + 104;
  else
    v7 = 0;
  v8 = (_BYTE *)a1[5];
  v9 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v8)
  {
    if (v5)
      goto LABEL_6;
  }
  else
  {
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    v22 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v22);
    if (result)
      goto LABEL_52;
    free(v22);
    if (v6)
    {
LABEL_6:
      if (v9)
        goto LABEL_7;
      goto LABEL_11;
    }
  }
  __nwlog_obj();
  v23 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  v24 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v24);
  if (result)
    goto LABEL_52;
  free(v24);
  if (v9)
  {
LABEL_7:
    v10 = &v8[v9];
    while (*v8)
    {
      ++v8;
      if (!--v9)
      {
        v8 = v10;
        goto LABEL_11;
      }
    }
    if (v6)
    {
      if (v9 >= 2)
      {
LABEL_17:
        v14 = 0;
        while (1)
        {
          v15 = v7[v14];
          v8[v14] = v15;
          if (!v15)
            goto LABEL_22;
          --v9;
          ++v14;
          if (v9 <= 1)
          {
            v8 += v14;
            break;
          }
        }
      }
    }
    else
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
      v30 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v30);
      if (result)
        goto LABEL_52;
      free(v30);
      if (v9 >= 2)
        goto LABEL_17;
    }
    *v8 = 0;
    goto LABEL_22;
  }
LABEL_11:
  if (v8)
  {
    if (v6)
      goto LABEL_22;
  }
  else
  {
    __nwlog_obj();
    v25 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    v26 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v26);
    if (result)
      goto LABEL_52;
    free(v26);
    if (v6)
      goto LABEL_22;
  }
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  v12 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v12);
  if (result)
    goto LABEL_52;
  free(v12);
LABEL_22:
  if (a1[6] - 1 <= a2)
    goto LABEL_37;
  v16 = (_BYTE *)a1[5];
  v17 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v16)
  {
    if (v17)
      goto LABEL_25;
  }
  else
  {
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    v28 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v28);
    if (result)
      goto LABEL_52;
    free(v28);
    if (v17)
    {
LABEL_25:
      v18 = &v16[v17];
      while (*v16)
      {
        ++v16;
        if (!--v17)
        {
          v16 = v18;
          goto LABEL_29;
        }
      }
      if (v17 >= 2)
      {
        *v16 = 44;
        if (&asc_183C9E877[v17 - 2] == ", ")
        {
          ++v16;
        }
        else
        {
          v16[1] = 32;
          v16 += 2;
        }
      }
      *v16 = 0;
      goto LABEL_37;
    }
  }
LABEL_29:
  if (v16)
  {
LABEL_37:

    return 1;
  }
  __nwlog_obj();
  v19 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
  v20 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v20);
  if (!result)
  {
    free(v20);
    goto LABEL_37;
  }
LABEL_52:
  __break(1u);
  return result;
}

NWConcrete_nw_browse_result *nw_browse_result_create(void *a1)
{
  id v2;
  NWConcrete_nw_browse_result *v3;
  id v4;
  id v5;
  uint64_t *v6;
  _BOOL8 v7;
  void *v8;
  void *v9;
  id v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t receiver;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  objc_super v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v2 = a1;
  if (v2)
  {
    v3 = [NWConcrete_nw_browse_result alloc];
    v4 = v2;
    if (!v3)
    {
LABEL_7:

      goto LABEL_8;
    }
    v30.receiver = v3;
    v30.super_class = (Class)NWConcrete_nw_browse_result;
    v5 = objc_msgSendSuper2(&v30, sel_init);
    v6 = (uint64_t *)v5;
    if (v5)
    {
      objc_storeStrong((id *)v5 + 1, a1);
      v7 = nw_array_create();
      v8 = (void *)v6[2];
      v6[2] = v7;

      v9 = (void *)v6[3];
      v6[3] = 0;

      v10 = nw_endpoint_copy_interface(v4);
      if (v10)
      {
        nw_array_append(v6[2], v10);
        nw_endpoint_set_interface(v4, 0);
      }
      v3 = v6;

      goto LABEL_7;
    }
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "-[NWConcrete_nw_browse_result initWithEndpoint:]";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if ((__nwlog_fault(v17, &type, &v28) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "-[NWConcrete_nw_browse_result initWithEndpoint:]";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        v25 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v32 = "-[NWConcrete_nw_browse_result initWithEndpoint:]";
            v33 = 2082;
            v34 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v32 = "-[NWConcrete_nw_browse_result initWithEndpoint:]";
          _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "-[NWConcrete_nw_browse_result initWithEndpoint:]";
          _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_44:
    if (v17)
      free(v17);
    v3 = 0;
    goto LABEL_7;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v32 = "nw_browse_result_create";
  v13 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v30.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v13, &v30, &type))
  {
    if (LOBYTE(v30.receiver) == 17)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)v30.receiver;
      if (os_log_type_enabled(v14, (os_log_type_t)v30.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_browse_result_create";
        _os_log_impl(&dword_182FBE000, v14, receiver, "%{public}s called with null _endpoint", buf, 0xCu);
      }
    }
    else if (type)
    {
      v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v21 = (os_log_type_t)v30.receiver;
      v22 = os_log_type_enabled(v14, (os_log_type_t)v30.receiver);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v32 = "nw_browse_result_create";
          v33 = 2082;
          v34 = v20;
          _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null _endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
        goto LABEL_38;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_browse_result_create";
        _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null _endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v26 = (os_log_type_t)v30.receiver;
      if (os_log_type_enabled(v14, (os_log_type_t)v30.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_browse_result_create";
        _os_log_impl(&dword_182FBE000, v14, v26, "%{public}s called with null _endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_38:
  if (v13)
    free(v13);
  v3 = 0;
LABEL_8:

  return v3;
}

void sub_183323F6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id nw_browse_result_get_endpoint(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[1];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_result_get_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_get_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_result_get_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_get_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_get_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

nw_endpoint_t nw_browse_result_copy_endpoint(nw_browse_result_t result)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  char *backtrace_string;
  os_log_type_t v7;
  _BOOL4 v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (result)
    return (nw_endpoint_t)nw_endpoint_copy(result[1].isa);
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_browse_result_copy_endpoint";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_browse_result_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_browse_result_copy_endpoint";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_browse_result_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_browse_result_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v4, v9, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v3)
    free(v3);
  return 0;
}

NWConcrete_nw_browse_result *nw_browse_result_create_mutable_copy(void *a1)
{
  id v1;
  _QWORD *v2;
  void *v3;
  NWConcrete_nw_browse_result *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  nw_txt_record_t v10;
  void *v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_endpoint_copy(*((void **)v1 + 1));
    v4 = nw_browse_result_create(v3);

    v5 = v2[2];
    if (!v5 || *(_QWORD *)(v5 + 16) == *(_QWORD *)(v5 + 24))
    {
      v5 = nw_array_create();
    }
    else
    {
      v6 = nw_array_create();
      if (v6 != v5)
      {
        v7 = v6;
        std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v6 + 16, *(void ***)(v5 + 16), *(void ***)(v5 + 24), (uint64_t)(*(_QWORD *)(v5 + 24) - *(_QWORD *)(v5 + 16)) >> 3);
        v5 = v7;
      }
    }
    v8 = (void *)*((_QWORD *)v4 + 2);
    *((_QWORD *)v4 + 2) = v5;

    v9 = v2[3];
    if (v9)
      v10 = nw_txt_record_create_with_bytes(*(const uint8_t **)(v9 + 8), *(_QWORD *)(v9 + 16));
    else
      v10 = 0;
    v11 = (void *)*((_QWORD *)v4 + 3);
    *((_QWORD *)v4 + 3) = v10;

    *((_BYTE *)v4 + 52) &= ~1u;
    goto LABEL_11;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_browse_result_create_mutable_copy";
  v14 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v14, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_browse_result_create_mutable_copy";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_browse_result_create_mutable_copy";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_browse_result_create_mutable_copy";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_browse_result_create_mutable_copy";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_28:
  if (v14)
    free(v14);
  v4 = 0;
LABEL_11:

  return v4;
}

void sub_18332480C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_browse_result_set_txt_record_object(void *a1, void *a2)
{
  id *v3;
  id v4;
  NSObject *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    if ((*((_BYTE *)v3 + 52) & 1) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_result_set_txt_record_object";
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s browse_result was marked immutable", buf, 0xCu);
      }

    }
    else
    {
      objc_storeStrong(v3 + 3, a2);
    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_browse_result_set_txt_record_object";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_result_set_txt_record_object";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_browse_result_set_txt_record_object";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_result_set_txt_record_object";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_result_set_txt_record_object";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v7)
    free(v7);
LABEL_7:

}

nw_txt_record_t nw_browse_result_copy_txt_record_object(nw_browse_result_t result)
{
  nw_browse_result_t v1;
  nw_browse_result_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = result;
  v2 = v1;
  if (v1)
  {
    v3 = v1[3].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_result_copy_txt_record_object";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_copy_txt_record_object";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_result_copy_txt_record_object";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_copy_txt_record_object";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_copy_txt_record_object";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

size_t nw_browse_result_get_interfaces_count(nw_browse_result_t result)
{
  Class isa;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!result)
  {
    __nwlog_obj();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_browse_result_get_interfaces_count";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (__nwlog_fault(v4, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_browse_result_get_interfaces_count";
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null result", buf, 0xCu);
        }
      }
      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            v14 = "nw_browse_result_get_interfaces_count";
            v15 = 2082;
            v16 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v9)
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_browse_result_get_interfaces_count";
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null result, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v14 = "nw_browse_result_get_interfaces_count";
          _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v4)
      free(v4);
    return 0;
  }
  isa = result[2].isa;
  if (isa)
    return (uint64_t)(*((_QWORD *)isa + 3) - *((_QWORD *)isa + 2)) >> 3;
  return 0;
}

BOOL nw_browse_result_remove_interface(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  unsigned __int8 *v8;
  void *v9;
  _BOOL8 v10;
  uint64_t v11;
  _BOOL8 v12;
  void **v13;
  void **v14;
  id v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  void *v22;
  os_log_type_t v23;
  void *v25;
  os_log_type_t v26;
  void *v27;
  os_log_type_t v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  os_log_type_t v34;
  _QWORD v35[4];
  id v36;
  _BYTE *v37;
  char v38;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v41)(uint64_t, uint64_t);
  void (*v42)(uint64_t);
  id v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v16, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
          _os_log_impl(&dword_182FBE000, v17, v26, "%{public}s called with null result", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v38)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
          _os_log_impl(&dword_182FBE000, v17, v33, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      v30 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
          _os_log_impl(&dword_182FBE000, v17, v29, "%{public}s called with null result, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v17, v29, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    goto LABEL_36;
  }
  if (!v4)
  {
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v16, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
          _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s called with null interface", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v38)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v34 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
          _os_log_impl(&dword_182FBE000, v17, v34, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      v32 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
          _os_log_impl(&dword_182FBE000, v17, v31, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v17, v31, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
LABEL_36:
    if (!v16)
    {
LABEL_38:
      v10 = 0;
      goto LABEL_39;
    }
LABEL_37:
    free(v16);
    goto LABEL_38;
  }
  if ((*((_BYTE *)v3 + 52) & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v16, &type, &v38))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s browse_result was marked immutable", buf, 0xCu);
      }
LABEL_35:

      goto LABEL_36;
    }
    if (!v38)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v23 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
        _os_log_impl(&dword_182FBE000, v17, v23, "%{public}s browse_result was marked immutable, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_35;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    v20 = type;
    v21 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
        _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s browse_result was marked immutable, no backtrace", buf, 0xCu);
      }
      goto LABEL_35;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_browse_result_remove_interface";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s browse_result was marked immutable, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_25:

    free(backtrace_string);
    if (!v16)
      goto LABEL_38;
    goto LABEL_37;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 12);
  v6 = (void *)*((_QWORD *)v3 + 4);
  if (v6)
  {
    free(v6);
    *((_QWORD *)v3 + 4) = 0;
  }
  v7 = (void *)*((_QWORD *)v3 + 5);
  if (v7)
  {
    free(v7);
    *((_QWORD *)v3 + 5) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 12);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3032000000;
  v41 = __Block_byref_object_copy_;
  v42 = __Block_byref_object_dispose_;
  v43 = 0;
  v8 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 3221225472;
  v35[2] = __nw_browse_result_remove_interface_block_invoke;
  v35[3] = &unk_1E14AB5F0;
  v36 = v5;
  v37 = buf;
  nw_array_apply(v8, (uint64_t)v35);
  v9 = *(void **)(*(_QWORD *)&buf[8] + 40);
  v10 = v9 != 0;
  if (v9)
  {
    v11 = *((_QWORD *)v3 + 2);
    if (!v11 || *(_QWORD *)(v11 + 16) == *(_QWORD *)(v11 + 24))
    {
      v12 = nw_array_create();
    }
    else
    {
      v12 = nw_array_create();
      std::vector<nw_object_wrapper_t>::reserve(v12 + 16, ((uint64_t)(*(_QWORD *)(v11 + 24) - *(_QWORD *)(v11 + 16)) >> 3) - 1);
      v14 = *(void ***)(v11 + 16);
      v13 = *(void ***)(v11 + 24);
      while (v14 != v13)
      {
        if (*v14 != v9)
          nw_array_append(v12, *v14);
        ++v14;
      }
    }
    v22 = (void *)*((_QWORD *)v3 + 2);
    *((_QWORD *)v3 + 2) = v12;

  }
  _Block_object_dispose(buf, 8);

LABEL_39:
  return v10;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

BOOL __nw_browse_result_remove_interface_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  _BOOL4 v6;

  v5 = a3;
  v6 = nw_interface_shallow_compare(v5, *(void **)(a1 + 32));
  if (v6)
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);

  return !v6;
}

BOOL nw_browse_result_insert_interface(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  unsigned __int8 *v8;
  id v9;
  _BOOL8 v10;
  NSObject *v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  os_log_type_t v25;
  _QWORD v26[4];
  id v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_browse_result_insert_interface";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v14, &type, &v28))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_browse_result_insert_interface";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null result", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (!v28)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_browse_result_insert_interface";
        _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_browse_result_insert_interface";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_browse_result_insert_interface";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v4)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_browse_result_insert_interface";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v14, &type, &v28))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_browse_result_insert_interface";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null interface", buf, 0xCu);
      }
LABEL_47:

LABEL_48:
      if (v14)
        free(v14);
      goto LABEL_14;
    }
    if (!v28)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_browse_result_insert_interface";
        _os_log_impl(&dword_182FBE000, v15, v25, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_browse_result_insert_interface";
        _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_browse_result_insert_interface";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(backtrace_string);
    goto LABEL_48;
  }
  if ((*((_BYTE *)v3 + 52) & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_browse_result_insert_interface";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s browse_result was marked immutable", buf, 0xCu);
    }

LABEL_14:
    v10 = 0;
    goto LABEL_15;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 12);
  v6 = (void *)*((_QWORD *)v3 + 4);
  if (v6)
  {
    free(v6);
    *((_QWORD *)v3 + 4) = 0;
  }
  v7 = (void *)*((_QWORD *)v3 + 5);
  if (v7)
  {
    free(v7);
    *((_QWORD *)v3 + 5) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v3 + 12);
  v8 = (unsigned __int8 *)*((_QWORD *)v3 + 2);
  v26[0] = MEMORY[0x1E0C809B0];
  v26[1] = 3221225472;
  v26[2] = __nw_browse_result_insert_interface_block_invoke;
  v26[3] = &unk_1E14AC200;
  v9 = v5;
  v27 = v9;
  v10 = nw_array_apply(v8, (uint64_t)v26);
  if (v10)
    nw_array_append(*((_QWORD *)v3 + 2), v9);

LABEL_15:
  return v10;
}

BOOL __nw_browse_result_insert_interface_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return !nw_interface_shallow_compare(a3, *(void **)(a1 + 32));
}

nw_browse_result_change_t nw_browse_result_get_changes(nw_browse_result_t old_result, nw_browse_result_t new_result)
{
  unint64_t v3;
  unint64_t v4;
  void *v5;
  nw_browse_result_change_t v6;
  NSObject *v7;
  NSObject *v8;
  size_t interfaces_count;
  size_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  _BOOL4 v13;
  NSObject *v14;
  NSObject *v15;
  _BOOL4 is_equal;
  NSObject *endpoint;
  nw_endpoint_type_t type;
  unint64_t v19;
  _QWORD v21[4];
  NSObject *v22;

  v3 = old_result;
  v4 = new_result;
  v5 = (void *)v4;
  if (v3 | v4)
  {
    if (v3 || !v4)
    {
      if (!v3 || v4)
      {
        v7 = (id)v3;
        v8 = v5;
        interfaces_count = nw_browse_result_get_interfaces_count(v7);
        v10 = nw_browse_result_get_interfaces_count(v8);
        if (interfaces_count >= v10)
        {
          if (interfaces_count <= v10)
          {
            if (interfaces_count == v10)
            {
              nw_browse_result_copy_interfaces((NWConcrete_nw_browse_result *)v7);
              v12 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue();
              v21[0] = MEMORY[0x1E0C809B0];
              v21[1] = 3221225472;
              v21[2] = __nw_browse_result_get_changes_block_invoke;
              v21[3] = &unk_1E14AC200;
              v22 = v8;
              v13 = nw_array_apply(v12, (uint64_t)v21);

              if (v13)
                v11 = 0;
              else
                v11 = 24;

            }
            else
            {
              v11 = 0;
            }
          }
          else
          {
            v11 = 16;
          }
        }
        else
        {
          v11 = 8;
        }
        v14 = nw_browse_result_copy_txt_record_object(v7);
        v15 = nw_browse_result_copy_txt_record_object(v8);
        is_equal = nw_txt_record_is_equal(v14, v15);
        endpoint = nw_browse_result_get_endpoint(v7);
        type = nw_endpoint_get_type(endpoint);
        v19 = v11 | 0x20;
        if (is_equal)
          v19 = v11;
        if (type == (nw_endpoint_type_url|nw_endpoint_type_host))
          v19 |= 0x22uLL;
        if (v19 <= 1)
          v6 = 1;
        else
          v6 = v19;

      }
      else
      {
        v6 = 4;
      }
    }
    else
    {
      v6 = 2;
    }
  }
  else
  {
    v6 = 1;
  }

  return v6;
}

void sub_1833260D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

id nw_browse_result_copy_interfaces(NWConcrete_nw_browse_result *a1)
{
  NWConcrete_nw_browse_result *v1;
  NWConcrete_nw_browse_result *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((id *)v1 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_result_copy_interfaces";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_copy_interfaces";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_result_copy_interfaces";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_copy_interfaces";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_copy_interfaces";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL __nw_browse_result_get_changes_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  unsigned __int8 *v5;
  id v6;
  _BOOL8 v7;
  _QWORD v9[4];
  id v10;

  v4 = a3;
  nw_browse_result_copy_interfaces(*(NWConcrete_nw_browse_result **)(a1 + 32));
  v5 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue();
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __nw_browse_result_get_changes_block_invoke_2;
  v9[3] = &unk_1E14AC200;
  v6 = v4;
  v10 = v6;
  v7 = !nw_array_apply(v5, (uint64_t)v9);

  return v7;
}

BOOL __nw_browse_result_get_changes_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  return !nw_interface_shallow_compare(*(void **)(a1 + 32), a3);
}

void nw_browse_result_enumerate_interfaces(nw_browse_result_t result, nw_browse_result_enumerate_interface_t enumerator)
{
  nw_browse_result_t v3;
  nw_browse_result_enumerate_interface_t v4;
  void *v5;
  Class isa;
  unsigned __int8 *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  _QWORD v22[4];
  id v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = result;
  v4 = enumerator;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_browse_result_enumerate_interfaces";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v9, &type, &v24))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_browse_result_enumerate_interfaces";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_browse_result_enumerate_interfaces";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v9)
          goto LABEL_4;
LABEL_39:
        free(v9);
        goto LABEL_4;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_browse_result_enumerate_interfaces";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_browse_result_enumerate_interfaces";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    isa = v3[2].isa;
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = __nw_browse_result_enumerate_interfaces_block_invoke;
    v22[3] = &unk_1E14AC278;
    v23 = v4;
    v7 = isa;
    nw_array_apply(v7, (uint64_t)v22);

    goto LABEL_4;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_browse_result_enumerate_interfaces";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v9, &type, &v24))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_browse_result_enumerate_interfaces";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null enumerator", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_browse_result_enumerate_interfaces";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null enumerator, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_browse_result_enumerate_interfaces";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_browse_result_enumerate_interfaces";
    v28 = 2082;
    v29 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null enumerator, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_39;
LABEL_4:

}

uint64_t __nw_browse_result_enumerate_interfaces_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t nw_browse_result_mark_immutable(uint64_t result)
{
  if (result)
    *(_BYTE *)(result + 52) |= 1u;
  return result;
}

void nw_browse_result_set_discovered_from_path(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 2;
    else
      v5 = 0;
    *((_BYTE *)v3 + 52) = *((_BYTE *)v3 + 52) & 0xFD | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_browse_result_set_discovered_from_path";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_result_set_discovered_from_path";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_browse_result_set_discovered_from_path";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_result_set_discovered_from_path";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_browse_result_set_discovered_from_path";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

uint64_t nw_browse_result_get_discovered_from_path(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[52] >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browse_result_get_discovered_from_path";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_get_discovered_from_path";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null result", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browse_result_get_discovered_from_path";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_get_discovered_from_path";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null result, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browse_result_get_discovered_from_path";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_browse_result_get_change_description(uint64_t a1)
{
  char *v2;
  char v3;
  NSObject *v4;
  void *v5;
  _BOOL8 result;
  NSObject *v7;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  size_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  size_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  size_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  size_t v82;
  uint64_t v83;
  unint64_t v84;
  char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  char *v91;
  unint64_t v92;
  uint64_t v93;
  size_t v94;
  NSObject *v95;
  void *v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  NSObject *v102;
  void *v103;
  uint64_t v104;
  unint64_t v105;
  char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  NSObject *v110;
  NSObject *v111;
  void *v112;
  NSObject *v113;
  void *v114;
  NSObject *v115;
  void *v116;
  NSObject *v117;
  void *v118;
  NSObject *v119;
  void *v120;
  NSObject *v121;
  void *v122;
  NSObject *v123;
  void *v124;
  NSObject *v125;
  void *v126;
  NSObject *v127;
  void *v128;
  NSObject *v129;
  void *v130;
  NSObject *v131;
  void *v132;
  NSObject *v133;
  void *v134;
  NSObject *v135;
  void *v136;
  NSObject *v137;
  void *v138;
  uint8_t buf[4];
  const char *v140;
  __int16 v141;
  uint64_t v142;
  __int16 v143;
  uint64_t v144;
  uint64_t v145;

  v145 = *MEMORY[0x1E0C80C00];
  v2 = (char *)malloc_type_calloc(0x6BuLL, 1uLL, 0xEAFB8F1AuLL);
  if (v2)
  {
    if (a1)
    {
      if ((a1 & 1) == 0)
      {
        if ((a1 & 2) == 0)
          goto LABEL_5;
        goto LABEL_16;
      }
LABEL_224:
      v104 = 0;
      v105 = 107;
      while (1)
      {
        v106 = &v2[v104];
        if (!v2[v104])
          break;
        ++v104;
        if (!--v105)
          goto LABEL_235;
      }
      if (v105 < 2)
      {
LABEL_234:
        *v106 = 0;
      }
      else
      {
        v107 = v105 - 2;
        v108 = 106 - v104;
        v109 = 105 - v104;
        if (v109 >= 0xB)
          v109 = 11;
        memcpy(v106, "<identical>", v109 + 1);
        v106 = v2 + 106;
        while (v107 <= 0xA)
        {
          if (!--v108)
            goto LABEL_234;
        }
      }
LABEL_235:
      if (a1 != 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v110 = (id)gLogObj;
        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v140 = "nw_browse_result_get_change_description";
          v141 = 2048;
          v142 = a1;
          _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_ERROR, "%{public}s unexpected value for change %llu", buf, 0x16u);
        }

      }
      return (BOOL)v2;
    }
LABEL_211:
    v97 = 0;
    v98 = 107;
    while (1)
    {
      v91 = &v2[v97];
      if (!v2[v97])
        break;
      ++v97;
      if (!--v98)
        return (BOOL)v2;
    }
    if (v98 >= 2)
    {
      v99 = v98 - 2;
      v100 = 106 - v97;
      v101 = 105 - v97;
      if (v101 >= 9)
        v101 = 9;
      memcpy(v91, "<invalid>", v101 + 1);
      v91 = v2 + 106;
      while (v99 <= 8)
      {
        if (!--v100)
          goto LABEL_221;
      }
      return (BOOL)v2;
    }
    goto LABEL_221;
  }
  __nwlog_obj();
  v4 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v140 = "strict_calloc";
  v141 = 2048;
  v142 = 107;
  v143 = 2048;
  v144 = 1;
  v5 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v5);
  if (result)
    goto LABEL_268;
  free(v5);
  if (!a1)
  {
    __nwlog_obj();
    v95 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v95, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v96 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v96);
    if (result)
      goto LABEL_268;
    free(v96);
    goto LABEL_211;
  }
  if ((a1 & 1) != 0)
  {
    __nwlog_obj();
    v102 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v103 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v103);
    if (result)
      goto LABEL_268;
    free(v103);
    goto LABEL_224;
  }
  if ((a1 & 2) == 0)
  {
LABEL_5:
    v3 = 0;
    if ((a1 & 4) == 0)
      goto LABEL_6;
    goto LABEL_41;
  }
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v140 = "_strict_strlcat";
  v8 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v8);
  if (result)
    goto LABEL_268;
  free(v8);
LABEL_16:
  v9 = 0;
  v10 = 107;
  while (1)
  {
    v11 = &v2[v9];
    if (!v2[v9])
      break;
    ++v9;
    if (!--v10)
      goto LABEL_28;
  }
  if (v10 < 2)
  {
LABEL_27:
    *v11 = 0;
  }
  else
  {
    v12 = v10 - 2;
    v13 = 106 - v9;
    if (v9 == 105)
      v14 = 1;
    else
      v14 = 2;
    memcpy(v11, "<", v14);
    v11 = v2 + 106;
    while (!v12)
    {
      if (!--v13)
        goto LABEL_27;
    }
  }
LABEL_28:
  if (!v2)
  {
    __nwlog_obj();
    v113 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v114 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v114);
    if (result)
      goto LABEL_268;
    free(v114);
  }
  v15 = 0;
  v16 = 107;
  while (1)
  {
    v17 = &v2[v15];
    if (!v2[v15])
      break;
    ++v15;
    if (!--v16)
      goto LABEL_40;
  }
  if (v16 < 2)
  {
LABEL_39:
    *v17 = 0;
  }
  else
  {
    v18 = v16 - 2;
    v19 = 106 - v15;
    v20 = 105 - v15;
    if (v20 >= 0xC)
      v20 = 12;
    memcpy(v17, "result_added", v20 + 1);
    v17 = v2 + 106;
    while (v18 <= 0xB)
    {
      if (!--v19)
        goto LABEL_39;
    }
  }
LABEL_40:
  v3 = 1;
  if ((a1 & 4) == 0)
  {
LABEL_6:
    if ((a1 & 8) == 0)
      goto LABEL_7;
    goto LABEL_80;
  }
LABEL_41:
  if ((v3 & 1) != 0)
  {
    if (!v2)
    {
      __nwlog_obj();
      v123 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v123, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v140 = "_strict_strlcat";
      v124 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v124);
      if (result)
        goto LABEL_268;
      free(v124);
    }
    v21 = 0;
    v22 = 107;
    while (1)
    {
      v23 = &v2[v21];
      if (!v2[v21])
        break;
      ++v21;
      if (!--v22)
        goto LABEL_67;
    }
    if (v22 >= 2)
    {
      v26 = v22 - 2;
      v27 = 106 - v21;
      v28 = 105 - v21;
      if (v28 >= 2)
        v28 = 2;
      memcpy(v23, ", ", v28 + 1);
      v23 = v2 + 106;
      while (v26 <= 1)
      {
        if (!--v27)
          goto LABEL_66;
      }
      goto LABEL_67;
    }
LABEL_66:
    *v23 = 0;
    goto LABEL_67;
  }
  if (!v2)
  {
    __nwlog_obj();
    v125 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v125, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v126 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v126);
    if (result)
      goto LABEL_268;
    free(v126);
  }
  v24 = 0;
  v25 = 107;
  while (1)
  {
    v23 = &v2[v24];
    if (!v2[v24])
      break;
    ++v24;
    if (!--v25)
      goto LABEL_67;
  }
  if (v25 < 2)
    goto LABEL_66;
  v29 = v25 - 2;
  v30 = 106 - v24;
  if (v24 == 105)
    v31 = 1;
  else
    v31 = 2;
  memcpy(v23, "<", v31);
  v23 = v2 + 106;
  while (!v29)
  {
    if (!--v30)
      goto LABEL_66;
  }
LABEL_67:
  if (!v2)
  {
    __nwlog_obj();
    v115 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v115, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v116 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v116);
    if (result)
      goto LABEL_268;
    free(v116);
  }
  v32 = 0;
  v33 = 107;
  while (1)
  {
    v34 = &v2[v32];
    if (!v2[v32])
      break;
    ++v32;
    if (!--v33)
      goto LABEL_79;
  }
  if (v33 < 2)
  {
LABEL_78:
    *v34 = 0;
  }
  else
  {
    v35 = v33 - 2;
    v36 = 106 - v32;
    v37 = 105 - v32;
    if (v37 >= 0xE)
      v37 = 14;
    memcpy(v34, "result_removed", v37 + 1);
    v34 = v2 + 106;
    while (v35 <= 0xD)
    {
      if (!--v36)
        goto LABEL_78;
    }
  }
LABEL_79:
  v3 = 1;
  if ((a1 & 8) == 0)
  {
LABEL_7:
    if ((a1 & 0x10) == 0)
      goto LABEL_8;
LABEL_119:
    if ((v3 & 1) != 0)
    {
      if (!v2)
      {
        __nwlog_obj();
        v131 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v131, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v140 = "_strict_strlcat";
        v132 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v132);
        if (result)
          goto LABEL_268;
        free(v132);
      }
      v55 = 0;
      v56 = 107;
      while (1)
      {
        v57 = &v2[v55];
        if (!v2[v55])
          break;
        ++v55;
        if (!--v56)
          goto LABEL_145;
      }
      if (v56 >= 2)
      {
        v60 = v56 - 2;
        v61 = 106 - v55;
        v62 = 105 - v55;
        if (v62 >= 2)
          v62 = 2;
        memcpy(v57, ", ", v62 + 1);
        v57 = v2 + 106;
        while (v60 <= 1)
        {
          if (!--v61)
            goto LABEL_144;
        }
        goto LABEL_145;
      }
    }
    else
    {
      if (!v2)
      {
        __nwlog_obj();
        v133 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v133, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v140 = "_strict_strlcat";
        v134 = (void *)_os_log_send_and_compose_impl();

        result = __nwlog_abort((uint64_t)v134);
        if (result)
          goto LABEL_268;
        free(v134);
      }
      v58 = 0;
      v59 = 107;
      while (1)
      {
        v57 = &v2[v58];
        if (!v2[v58])
          break;
        ++v58;
        if (!--v59)
          goto LABEL_145;
      }
      if (v59 >= 2)
      {
        v63 = v59 - 2;
        v64 = 106 - v58;
        if (v58 == 105)
          v65 = 1;
        else
          v65 = 2;
        memcpy(v57, "<", v65);
        v57 = v2 + 106;
        while (!v63)
        {
          if (!--v64)
            goto LABEL_144;
        }
LABEL_145:
        if (!v2)
        {
          __nwlog_obj();
          v119 = objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v119, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          v140 = "_strict_strlcat";
          v120 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v120);
          if (result)
            goto LABEL_268;
          free(v120);
        }
        v66 = 0;
        v67 = 107;
        while (1)
        {
          v68 = &v2[v66];
          if (!v2[v66])
            break;
          ++v66;
          if (!--v67)
            goto LABEL_157;
        }
        if (v67 < 2)
        {
LABEL_156:
          *v68 = 0;
        }
        else
        {
          v69 = v67 - 2;
          v70 = 106 - v66;
          v71 = 105 - v66;
          if (v71 >= 0x11)
            v71 = 17;
          memcpy(v68, "interface_removed", v71 + 1);
          v68 = v2 + 106;
          while (v69 <= 0x10)
          {
            if (!--v70)
              goto LABEL_156;
          }
        }
LABEL_157:
        v3 = 1;
        if ((a1 & 0x20) == 0)
          goto LABEL_196;
LABEL_158:
        if ((v3 & 1) != 0)
        {
          if (!v2)
          {
            __nwlog_obj();
            v135 = objc_claimAutoreleasedReturnValue();
            os_log_type_enabled(v135, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446210;
            v140 = "_strict_strlcat";
            v136 = (void *)_os_log_send_and_compose_impl();

            result = __nwlog_abort((uint64_t)v136);
            if (result)
              goto LABEL_268;
            free(v136);
          }
          v72 = 0;
          v73 = 107;
          while (1)
          {
            v74 = &v2[v72];
            if (!v2[v72])
              break;
            ++v72;
            if (!--v73)
              goto LABEL_184;
          }
          if (v73 >= 2)
          {
            v77 = v73 - 2;
            v78 = 106 - v72;
            v79 = 105 - v72;
            if (v79 >= 2)
              v79 = 2;
            memcpy(v74, ", ", v79 + 1);
            v74 = v2 + 106;
            while (v77 <= 1)
            {
              if (!--v78)
                goto LABEL_183;
            }
            goto LABEL_184;
          }
        }
        else
        {
          if (!v2)
          {
            __nwlog_obj();
            v137 = objc_claimAutoreleasedReturnValue();
            os_log_type_enabled(v137, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446210;
            v140 = "_strict_strlcat";
            v138 = (void *)_os_log_send_and_compose_impl();

            result = __nwlog_abort((uint64_t)v138);
            if (result)
              goto LABEL_268;
            free(v138);
          }
          v75 = 0;
          v76 = 107;
          while (1)
          {
            v74 = &v2[v75];
            if (!v2[v75])
              break;
            ++v75;
            if (!--v76)
              goto LABEL_184;
          }
          if (v76 >= 2)
          {
            v80 = v76 - 2;
            v81 = 106 - v75;
            if (v75 == 105)
              v82 = 1;
            else
              v82 = 2;
            memcpy(v74, "<", v82);
            v74 = v2 + 106;
            while (!v80)
            {
              if (!--v81)
                goto LABEL_183;
            }
            goto LABEL_184;
          }
        }
LABEL_183:
        *v74 = 0;
LABEL_184:
        if (!v2)
        {
          __nwlog_obj();
          v121 = objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v121, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446210;
          v140 = "_strict_strlcat";
          v122 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v122);
          if (result)
            goto LABEL_268;
          free(v122);
        }
        v83 = 0;
        v84 = 107;
        while (1)
        {
          v85 = &v2[v83];
          if (!v2[v83])
            break;
          ++v83;
          if (!--v84)
            goto LABEL_196;
        }
        if (v84 < 2)
        {
LABEL_195:
          *v85 = 0;
        }
        else
        {
          v86 = v84 - 2;
          v87 = 106 - v83;
          v88 = 105 - v83;
          if (v88 >= 0x12)
            v88 = 18;
          memcpy(v85, "txt_record_changed", v88 + 1);
          v85 = v2 + 106;
          while (v86 <= 0x11)
          {
            if (!--v87)
              goto LABEL_195;
          }
        }
        goto LABEL_196;
      }
    }
LABEL_144:
    *v57 = 0;
    goto LABEL_145;
  }
LABEL_80:
  if ((v3 & 1) != 0)
  {
    if (!v2)
    {
      __nwlog_obj();
      v127 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v127, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v140 = "_strict_strlcat";
      v128 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v128);
      if (result)
        goto LABEL_268;
      free(v128);
    }
    v38 = 0;
    v39 = 107;
    while (1)
    {
      v40 = &v2[v38];
      if (!v2[v38])
        break;
      ++v38;
      if (!--v39)
        goto LABEL_106;
    }
    if (v39 >= 2)
    {
      v43 = v39 - 2;
      v44 = 106 - v38;
      v45 = 105 - v38;
      if (v45 >= 2)
        v45 = 2;
      memcpy(v40, ", ", v45 + 1);
      v40 = v2 + 106;
      while (v43 <= 1)
      {
        if (!--v44)
          goto LABEL_105;
      }
      goto LABEL_106;
    }
LABEL_105:
    *v40 = 0;
    goto LABEL_106;
  }
  if (!v2)
  {
    __nwlog_obj();
    v129 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v129, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v130 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v130);
    if (result)
      goto LABEL_268;
    free(v130);
  }
  v41 = 0;
  v42 = 107;
  while (1)
  {
    v40 = &v2[v41];
    if (!v2[v41])
      break;
    ++v41;
    if (!--v42)
      goto LABEL_106;
  }
  if (v42 < 2)
    goto LABEL_105;
  v46 = v42 - 2;
  v47 = 106 - v41;
  if (v41 == 105)
    v48 = 1;
  else
    v48 = 2;
  memcpy(v40, "<", v48);
  v40 = v2 + 106;
  while (!v46)
  {
    if (!--v47)
      goto LABEL_105;
  }
LABEL_106:
  if (!v2)
  {
    __nwlog_obj();
    v117 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v117, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v140 = "_strict_strlcat";
    v118 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v118);
    if (result)
      goto LABEL_268;
    free(v118);
  }
  v49 = 0;
  v50 = 107;
  while (1)
  {
    v51 = &v2[v49];
    if (!v2[v49])
      break;
    ++v49;
    if (!--v50)
      goto LABEL_118;
  }
  if (v50 < 2)
  {
LABEL_117:
    *v51 = 0;
  }
  else
  {
    v52 = v50 - 2;
    v53 = 106 - v49;
    v54 = 105 - v49;
    if (v54 >= 0xF)
      v54 = 15;
    memcpy(v51, "interface_added", v54 + 1);
    v51 = v2 + 106;
    while (v52 <= 0xE)
    {
      if (!--v53)
        goto LABEL_117;
    }
  }
LABEL_118:
  v3 = 1;
  if ((a1 & 0x10) != 0)
    goto LABEL_119;
LABEL_8:
  if ((a1 & 0x20) != 0)
    goto LABEL_158;
LABEL_196:
  if (v2)
  {
LABEL_197:
    v89 = 0;
    v90 = 107;
    while (1)
    {
      v91 = &v2[v89];
      if (!v2[v89])
        break;
      ++v89;
      if (!--v90)
        return (BOOL)v2;
    }
    if (v90 >= 2)
    {
      v92 = v90 - 2;
      v93 = 106 - v89;
      if (v89 == 105)
        v94 = 1;
      else
        v94 = 2;
      memcpy(v91, ">", v94);
      v91 = v2 + 106;
      while (!v92)
      {
        if (!--v93)
          goto LABEL_221;
      }
      return (BOOL)v2;
    }
LABEL_221:
    *v91 = 0;
    return (BOOL)v2;
  }
  __nwlog_obj();
  v111 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v111, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v140 = "_strict_strlcat";
  v112 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v112);
  if (!result)
  {
    free(v112);
    goto LABEL_197;
  }
LABEL_268:
  __break(1u);
  return result;
}

void sub_183329014(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_ws_ping_request *nw_ws_ping_request_create(void *a1, void *a2, void *a3)
{
  id v6;
  id v7;
  id v8;
  NWConcrete_nw_ws_ping_request *v9;
  id v10;
  id v11;
  id v12;
  NWConcrete_nw_ws_ping_request *v13;
  void *v14;
  id pong_handler;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t receiver;
  void *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  objc_super v35;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v6 = a1;
  v7 = a2;
  v8 = a3;
  if (v6)
  {
    v9 = [NWConcrete_nw_ws_ping_request alloc];
    v10 = v6;
    v11 = v7;
    v12 = v8;
    if (!v9)
    {
LABEL_5:

      goto LABEL_6;
    }
    v35.receiver = v9;
    v35.super_class = (Class)NWConcrete_nw_ws_ping_request;
    v13 = (NWConcrete_nw_ws_ping_request *)objc_msgSendSuper2(&v35, sel_init);
    v9 = v13;
    if (v13)
    {
      objc_storeStrong((id *)&v13->contents, a1);
      objc_storeStrong((id *)&v9->client_queue, a2);
      v14 = _Block_copy(v12);
      pong_handler = v9->pong_handler;
      v9->pong_handler = v14;

      goto LABEL_5;
    }
    __nwlog_obj();
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "-[NWConcrete_nw_ws_ping_request initWithContents:queue:handler:]";
    v22 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if ((__nwlog_fault(v22, &type, &v33) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "-[NWConcrete_nw_ws_ping_request initWithContents:queue:handler:]";
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        v30 = os_log_type_enabled(v23, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v37 = "-[NWConcrete_nw_ws_ping_request initWithContents:queue:handler:]";
            v38 = 2082;
            v39 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v23, v29, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "-[NWConcrete_nw_ws_ping_request initWithContents:queue:handler:]";
          _os_log_impl(&dword_182FBE000, v23, v29, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "-[NWConcrete_nw_ws_ping_request initWithContents:queue:handler:]";
          _os_log_impl(&dword_182FBE000, v23, v32, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_42:
    if (v22)
      free(v22);
    v9 = 0;
    goto LABEL_5;
  }
  __nwlog_obj();
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_ws_ping_request_create";
  v18 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v35.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v18, &v35, &type))
  {
    if (LOBYTE(v35.receiver) == 17)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)v35.receiver;
      if (os_log_type_enabled(v19, (os_log_type_t)v35.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_ws_ping_request_create";
        _os_log_impl(&dword_182FBE000, v19, receiver, "%{public}s called with null contents", buf, 0xCu);
      }
    }
    else if (type)
    {
      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v26 = (os_log_type_t)v35.receiver;
      v27 = os_log_type_enabled(v19, (os_log_type_t)v35.receiver);
      if (v25)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_ws_ping_request_create";
          v38 = 2082;
          v39 = v25;
          _os_log_impl(&dword_182FBE000, v19, v26, "%{public}s called with null contents, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v25);
        goto LABEL_36;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_ws_ping_request_create";
        _os_log_impl(&dword_182FBE000, v19, v26, "%{public}s called with null contents, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v31 = (os_log_type_t)v35.receiver;
      if (os_log_type_enabled(v19, (os_log_type_t)v35.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_ws_ping_request_create";
        _os_log_impl(&dword_182FBE000, v19, v31, "%{public}s called with null contents, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_36:
  if (v18)
    free(v18);
  v9 = 0;
LABEL_6:

  return v9;
}

void sub_183329968(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

id nw_ws_ping_request_copy_client_queue(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_ws_ping_request_copy_client_queue";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_ws_ping_request_copy_client_queue";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null ping_request", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_ws_ping_request_copy_client_queue";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null ping_request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_ws_ping_request_copy_client_queue";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null ping_request, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_ws_ping_request_copy_client_queue";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null ping_request, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void *nw_ws_ping_request_copy_pong_handler(void *a1)
{
  const void **v1;
  const void **v2;
  void *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = _Block_copy(v1[3]);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_ws_ping_request_copy_pong_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_ws_ping_request_copy_pong_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null ping_request", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_ws_ping_request_copy_pong_handler";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null ping_request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_ws_ping_request_copy_pong_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null ping_request, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_ws_ping_request_copy_pong_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null ping_request, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_shoes_metadata_copy_remote_endpoint(void *a1)
{
  id v1;
  id v2;
  void **v3;
  uint64_t v4;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  _QWORD v14[5];
  char v15;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = a1;
    v2 = *((id *)v1 + 1);

    if (nw_protocol_shoes_get_definition(void)::onceToken != -1)
      dispatch_once(&nw_protocol_shoes_get_definition(void)::onceToken, &__block_literal_global_30);
    if (nw_protocol_definition_is_equal_unsafe((uint64_t)v2, nw_protocol_shoes_get_definition(void)::proxy_definition))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2000000000;
      v18 = 0;
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 0x40000000;
      v14[2] = __nw_shoes_metadata_copy_remote_endpoint_block_invoke;
      v14[3] = &unk_1E1499CD0;
      v14[4] = buf;
      v3 = (void **)*((_QWORD *)v1 + 4);
      if (v3)
      {
        __nw_shoes_metadata_copy_remote_endpoint_block_invoke((uint64_t)v14, v3);
        v4 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
      }
      else
      {
        v4 = 0;
      }
      _Block_object_dispose(buf, 8);
      return v4;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
        v9 = "%{public}s metadata must be shoes";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
        v9 = "%{public}s metadata must be shoes, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
        v9 = "%{public}s metadata must be shoes, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v12 = "%{public}s metadata must be shoes, dumping backtrace:%{public}s";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v6, &type, &v15))
    goto LABEL_37;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
        v9 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
        v9 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v12 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_37;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_shoes_metadata_copy_remote_endpoint";
    v9 = "%{public}s called with null metadata";
LABEL_36:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
  }
LABEL_37:
  if (v6)
    free(v6);
  return 0;
}

uint64_t __nw_shoes_metadata_copy_remote_endpoint_block_invoke(uint64_t a1, void **a2)
{
  if (*a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = os_retain(*a2);
  return 1;
}

BOOL ___ZL32nw_protocol_shoes_get_definitionv_block_invoke()
{
  if (nw_protocol_shoes_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_shoes_identifier::onceToken, &__block_literal_global_345);
  nw_protocol_shoes_get_definition(void)::proxy_definition = (uint64_t)nw_protocol_definition_create_with_identifier((__int128 *)&g_shoes_protocol_identifier);
  nw_protocol_definition_set_metadata_allocator((void *)nw_protocol_shoes_get_definition(void)::proxy_definition, (uint64_t)nw_shoes_allocate_metadata, (uint64_t)nw_shoes_deallocate_metadata);
  nw_protocol_definition_set_metadata_comparator((void *)nw_protocol_shoes_get_definition(void)::proxy_definition, (uint64_t)nw_shoes_compare_metadata);
  nw_protocol_definition_set_is_proxy((void *)nw_protocol_shoes_get_definition(void)::proxy_definition);
  return nw_protocol_register_handle((uint64_t)&g_shoes_protocol_identifier, (void *)nw_protocol_shoes_get_definition(void)::proxy_definition, (uint64_t)nw_protocol_shoes_create, 0);
}

BOOL nw_shoes_allocate_metadata(nw_protocol_definition *a1)
{
  void *v1;
  _BOOL8 result;
  NSObject *v3;
  void *v4;

  v1 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (v1)
    return (BOOL)v1;
  v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  v4 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }
  __break(1u);
  return result;
}

void nw_shoes_deallocate_metadata(nw_protocol_definition *a1, void **a2)
{
  void *v3;

  if (*a2)
  {
    os_release(*a2);
    *a2 = 0;
  }
  v3 = a2[1];
  if (v3)
    os_release(v3);
  free(a2);
}

uint64_t nw_shoes_compare_metadata(uint64_t a1, void **a2, void **a3)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *v8;
  _BOOL4 v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (a3)
      return nw_endpoint_is_equal(*a2, *a3, 31);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_shoes_compare_metadata";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (__nwlog_fault(v4, &type, &v12))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "nw_shoes_compare_metadata";
        v7 = "%{public}s called with null handle2";
        goto LABEL_31;
      }
      if (!v12)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "nw_shoes_compare_metadata";
        v7 = "%{public}s called with null handle2, backtrace limit exceeded";
        goto LABEL_31;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_shoes_compare_metadata";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null handle2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v4)
          return 0;
        goto LABEL_33;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_shoes_compare_metadata";
        v7 = "%{public}s called with null handle2, no backtrace";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_shoes_compare_metadata";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_shoes_compare_metadata";
      v7 = "%{public}s called with null handle1";
      goto LABEL_31;
    }
    if (!v12)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_shoes_compare_metadata";
      v7 = "%{public}s called with null handle1, backtrace limit exceeded";
      goto LABEL_31;
    }
    v8 = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!v8)
    {
      if (!v9)
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_shoes_compare_metadata";
      v7 = "%{public}s called with null handle1, no backtrace";
      goto LABEL_31;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "nw_shoes_compare_metadata";
      v16 = 2082;
      v17 = v8;
      _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null handle1, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v8);
  }
LABEL_32:
  if (v4)
LABEL_33:
    free(v4);
  return 0;
}

BOOL nw_protocol_shoes_create(const nw_protocol_identifier *a1, nw_object *a2, nw_endpoint *a3, nw_parameters *a4)
{
  _QWORD *v5;
  void *v6;
  _BOOL8 result;
  NSObject *v8;
  void *v9;

  v5 = malloc_type_calloc(1uLL, 0xF0uLL, 0xEAFB8F1AuLL);
  if (!v5)
  {
    v8 = __nwlog_obj();
    os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    v9 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v9);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v9);
  }
  v5[2] = &g_shoes_protocol_identifier;
  v5[3] = &g_shoes_protocol_callbacks;
  v5[5] = v5;
  if (a3)
    v6 = os_retain(a3);
  else
    v6 = 0;
  v5[13] = v6;
  return (BOOL)v5;
}

double __nw_protocol_shoes_identifier_block_invoke()
{
  double result;

  unk_1EDCF0D56 = 0;
  unk_1EDCF0D4E = 0;
  word_1EDCF0D66 = 0;
  unk_1EDCF0D5E = 0;
  strcpy((char *)&g_shoes_protocol_identifier, "shoes");
  *(_QWORD *)&result = 0x100000005;
  qword_1EDCF0D68 = 0x100000005;
  qword_1EDCF0E30 = (uint64_t)nw_protocol_default_output_finished;
  unk_1EDCF0E38 = nw_protocol_default_get_output_local;
  qword_1EDCF0E70 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCF0E78 = nw_protocol_default_input_flush;
  qword_1EDCF0E20 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1EDCF0E28 = nw_protocol_default_input_finished;
  qword_1EDCF0E00 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCF0E08 = nw_protocol_default_unregister_notification;
  qword_1EDCF0E10 = (uint64_t)nw_protocol_default_notify;
  unk_1EDCF0E18 = nw_protocol_default_updated_path;
  qword_1EDCF0E60 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_1EDCF0E68 = nw_protocol_default_get_message_properties;
  g_shoes_protocol_callbacks = (uint64_t)nw_protocol_shoes_add_input_handler;
  *(_QWORD *)algn_1EDCF0D78 = nw_protocol_shoes_remove_input_handler;
  qword_1EDCF0DB0 = (uint64_t)nw_protocol_shoes_input_available;
  unk_1EDCF0DB8 = nw_protocol_default_output_available;
  qword_1EDCF0DC0 = (uint64_t)nw_protocol_shoes_get_input_frames;
  unk_1EDCF0DC8 = nw_protocol_shoes_get_output_frames;
  qword_1EDCF0DD0 = (uint64_t)nw_protocol_shoes_finalize_output_frames;
  unk_1EDCF0DD8 = nw_protocol_default_link_state;
  qword_1EDCF0E40 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCF0E48 = nw_protocol_shoes_waiting_for_output;
  qword_1EDCF0D80 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1EDCF0D88 = nw_protocol_shoes_connect;
  qword_1EDCF0D90 = (uint64_t)nw_protocol_default_disconnect;
  unk_1EDCF0D98 = nw_protocol_shoes_connected;
  qword_1EDCF0DA0 = (uint64_t)nw_protocol_default_disconnected;
  unk_1EDCF0DA8 = nw_protocol_shoes_error;
  qword_1EDCF0DE0 = (uint64_t)nw_protocol_shoes_get_parameters;
  unk_1EDCF0DE8 = nw_protocol_shoes_get_path;
  qword_1EDCF0E50 = (uint64_t)nw_protocol_shoes_copy_info;
  unk_1EDCF0E58 = nw_protocol_default_add_listen_handler;
  qword_1EDCF0DF0 = (uint64_t)nw_protocol_shoes_get_local_endpoint;
  unk_1EDCF0DF8 = nw_protocol_shoes_get_remote_endpoint;
  return result;
}

BOOL nw_protocol_shoes_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  NSObject *v5;
  nw_endpoint_type_t v6;
  void *v7;
  nw_endpoint_type_t v8;
  NSObject *v9;
  _BOOL8 result;
  char tls;
  void *v12;
  id v13;
  void *v14;
  _BOOL4 value;
  char v16;
  id v17;
  void *v18;
  _BOOL4 v19;
  char v20;
  id v21;
  void *v22;
  const char *string_ptr;
  unsigned __int8 *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  const char *v31;
  _BOOL4 v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  char *v38;
  __int16 v39;
  nw_endpoint_type_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_shoes_add_input_handler";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v25, &type, &v33))
      goto LABEL_57;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_shoes_add_input_handler";
        v28 = "%{public}s called with null protocol";
LABEL_56:
        _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
      }
LABEL_57:
      if (v25)
        free(v25);
      return 0;
    }
    if (!v33)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_shoes_add_input_handler";
        v28 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_56;
      }
      goto LABEL_57;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v30 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_shoes_add_input_handler";
        v28 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_56;
      }
      goto LABEL_57;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_shoes_add_input_handler";
      v37 = 2082;
      v38 = backtrace_string;
      v31 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_46:
      _os_log_impl(&dword_182FBE000, v26, v27, v31, buf, 0x16u);
    }
LABEL_47:
    free(backtrace_string);
    goto LABEL_57;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_shoes_add_input_handler";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v25, &type, &v33))
      goto LABEL_57;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_shoes_add_input_handler";
        v28 = "%{public}s called with null shoes";
        goto LABEL_56;
      }
      goto LABEL_57;
    }
    if (!v33)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_shoes_add_input_handler";
        v28 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_56;
      }
      goto LABEL_57;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v32 = os_log_type_enabled(v26, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_shoes_add_input_handler";
        v28 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_56;
      }
      goto LABEL_57;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_shoes_add_input_handler";
      v37 = 2082;
      v38 = backtrace_string;
      v31 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
    goto LABEL_47;
  }
  v5 = ((uint64_t (*)(nw_protocol *))a2->callbacks->get_remote_endpoint)(a2);
  v6 = nw_endpoint_get_type(v5);
  if (v6 - 1 < 2)
  {
    nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
    *(_OWORD *)handle = *(_OWORD *)a2->flow_id;
    if (a2->output_handler)
    {
      if (v5)
      {
LABEL_6:
        v7 = os_retain(v5);
LABEL_11:
        handle[15] = 0;
        handle[12] = v7;
        tls = 1;
        *((_BYTE *)handle + 150) = 1;
        handle[16] = handle + 15;
        v12 = (void *)((uint64_t (*)(void))a1->default_input_handler->callbacks->get_parameters)();
        if (!nw_parameters_get_tfo(v12))
          tls = nw_parameters_get_tls(v12);
        *((_BYTE *)handle + 235) = *((_BYTE *)handle + 235) & 0xFE | tls;
        v13 = nw_parameters_copy_protocol_value(v12, (uint64_t)a1, "UDP");
        if (v13)
        {
          v14 = v13;
          value = xpc_BOOL_get_value(v13);
          xpc_release(v14);
          if (value)
            v16 = 2;
          else
            v16 = 0;
        }
        else
        {
          v16 = 0;
        }
        *((_BYTE *)handle + 235) = *((_BYTE *)handle + 235) & 0xFD | v16;
        v17 = nw_parameters_copy_protocol_value(v12, (uint64_t)a1, "UDPAssociateSupported");
        if (v17)
        {
          v18 = v17;
          v19 = xpc_BOOL_get_value(v17);
          xpc_release(v18);
          if (v19)
            v20 = 4;
          else
            v20 = 0;
        }
        else
        {
          v20 = 0;
        }
        *((_BYTE *)handle + 235) = *((_BYTE *)handle + 235) & 0xFB | v20;
        v21 = nw_parameters_copy_protocol_value(v12, (uint64_t)a1, "FixedBundleID");
        if (v21)
        {
          v22 = v21;
          string_ptr = xpc_string_get_string_ptr(v21);
          xpc_release(v22);
          if (string_ptr)
            handle[14] = xpc_string_create(string_ptr);
        }
        v24 = nw_parameters_copy_protocol_options_legacy(v12, a1);
        nw_protocol_options_get_log_id_str(v24, (_BYTE *)handle + 151, 84);
        if (v24)
          os_release(v24);
        return 1;
      }
    }
    else
    {
      nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)handle);
      if (v5)
        goto LABEL_6;
    }
    v7 = 0;
    goto LABEL_11;
  }
  v8 = v6;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = gLogObj;
  result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136446722;
    v36 = "nw_protocol_shoes_add_input_handler";
    v37 = 2082;
    v38 = (char *)handle + 151;
    v39 = 1024;
    v40 = v8;
    _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s protocol_shoes does not support endpoint type %u", buf, 0x1Cu);
    return 0;
  }
  return result;
}

uint64_t nw_protocol_shoes_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  _QWORD *handle;
  nw_protocol *output_handler;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_shoes_remove_input_handler";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v16, &type, &v24))
      goto LABEL_53;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v24)
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (!os_log_type_enabled(v17, type))
          goto LABEL_53;
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_shoes_remove_input_handler";
        v19 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v21 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (!v21)
          goto LABEL_53;
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_shoes_remove_input_handler";
        v19 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        v27 = "nw_protocol_shoes_remove_input_handler";
        v28 = 2082;
        v29 = backtrace_string;
        v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_42:
        _os_log_impl(&dword_182FBE000, v17, v18, v22, buf, 0x16u);
      }
LABEL_43:
      free(backtrace_string);
      goto LABEL_53;
    }
    v17 = __nwlog_obj();
    v18 = type;
    if (!os_log_type_enabled(v17, type))
      goto LABEL_53;
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_shoes_remove_input_handler";
    v19 = "%{public}s called with null protocol";
LABEL_52:
    _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
LABEL_53:
    if (v16)
      free(v16);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_shoes_remove_input_handler";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v16, &type, &v24))
      goto LABEL_53;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_shoes_remove_input_handler";
      v19 = "%{public}s called with null shoes";
      goto LABEL_52;
    }
    if (!v24)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v27 = "nw_protocol_shoes_remove_input_handler";
      v19 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v23 = os_log_type_enabled(v17, type);
    if (backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v27 = "nw_protocol_shoes_remove_input_handler";
        v28 = 2082;
        v29 = backtrace_string;
        v22 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    if (!v23)
      goto LABEL_53;
    *(_DWORD *)buf = 136446210;
    v27 = "nw_protocol_shoes_remove_input_handler";
    v19 = "%{public}s called with null shoes, no backtrace";
    goto LABEL_52;
  }
  if (a2->output_handler == a1)
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  if (a1->default_input_handler != a2)
    return 0;
  output_handler = a1->output_handler;
  if (output_handler)
    ((void (*)(void))output_handler->callbacks->remove_input_handler)();
  v9 = handle[8];
  if (v9)
  {
    (*(void (**)(void))(*(_QWORD *)(v9 + 24) + 8))();
    handle[8] = 0;
  }
  v10 = (void *)handle[10];
  if (v10)
  {
    nw_path_flow_registration_close(v10);
    v11 = (void *)handle[10];
    if (v11)
    {
      os_release(v11);
      handle[10] = 0;
    }
  }
  v12 = (void *)handle[9];
  if (v12)
  {
    os_release(v12);
    handle[9] = 0;
  }
  v13 = (void *)handle[11];
  if (v13)
  {
    os_release(v13);
    handle[11] = 0;
  }
  v14 = (void *)handle[13];
  if (v14)
  {
    os_release(v14);
    handle[13] = 0;
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0);
  if (a3)
  {
    a1->handle = 0;
    v15 = (void *)handle[14];
    if (v15)
      xpc_release(v15);
    free(handle);
  }
  return 1;
}

void nw_protocol_shoes_input_available(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol *default_input_handler;
  uint64_t v5;
  const char *v6;
  NSObject *v7;
  nw_protocol *output_handler;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  _QWORD *v19;
  char *v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  unsigned __int16 v25;
  _BOOL8 v26;
  NSObject *v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  uint32_t v41;
  uint64_t v42;
  const char *v43;
  NSObject *v44;
  os_log_type_t v45;
  NSObject *v46;
  os_log_type_t v47;
  const char *v48;
  char *v49;
  NSObject *v50;
  _BOOL4 v51;
  NSObject *v52;
  os_log_type_t v53;
  uint64_t v54;
  os_log_type_t v55;
  uint32_t v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  NSObject *v60;
  NSObject *v61;
  int v62;
  NSObject *v63;
  int v64;
  int v65;
  NSObject *v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  char *backtrace_string;
  _BOOL4 v72;
  char *v73;
  _BOOL4 v74;
  NSObject *v75;
  NSObject *v76;
  os_log_type_t v77;
  char *v78;
  os_log_type_t v79[8];
  os_log_type_t *v80;
  char v81;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v84;
  __int16 v85;
  char *v86;
  __int16 v87;
  int v88;
  __int16 v89;
  _BYTE v90[10];
  uint64_t v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v84 = "nw_protocol_shoes_input_available";
    v67 = (char *)_os_log_send_and_compose_impl();
    v79[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v67, v79, &type))
      goto LABEL_153;
    if (v79[0] == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = v79[0];
      if (!os_log_type_enabled(v68, v79[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v84 = "nw_protocol_shoes_input_available";
      v70 = "%{public}s called with null protocol";
      goto LABEL_152;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v68 = __nwlog_obj();
      v69 = v79[0];
      if (!os_log_type_enabled(v68, v79[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v84 = "nw_protocol_shoes_input_available";
      v70 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_152;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v68 = __nwlog_obj();
    v69 = v79[0];
    v72 = os_log_type_enabled(v68, v79[0]);
    if (!backtrace_string)
    {
      if (!v72)
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v84 = "nw_protocol_shoes_input_available";
      v70 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_152;
    }
    if (v72)
    {
      *(_DWORD *)buf = 136446466;
      v84 = "nw_protocol_shoes_input_available";
      v85 = 2082;
      v86 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_153:
    if (!v67)
      return;
    goto LABEL_154;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v84 = "nw_protocol_shoes_input_available";
    v67 = (char *)_os_log_send_and_compose_impl();
    v79[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v67, v79, &type))
      goto LABEL_153;
    if (v79[0] == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = v79[0];
      if (!os_log_type_enabled(v68, v79[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v84 = "nw_protocol_shoes_input_available";
      v70 = "%{public}s called with null shoes";
      goto LABEL_152;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v68 = __nwlog_obj();
      v69 = v79[0];
      if (!os_log_type_enabled(v68, v79[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      v84 = "nw_protocol_shoes_input_available";
      v70 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_152;
    }
    v73 = (char *)__nw_create_backtrace_string();
    v68 = __nwlog_obj();
    v69 = v79[0];
    v74 = os_log_type_enabled(v68, v79[0]);
    if (v73)
    {
      if (v74)
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_protocol_shoes_input_available";
        v85 = 2082;
        v86 = v73;
        _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v73);
      if (!v67)
        return;
LABEL_154:
      free(v67);
      return;
    }
    if (v74)
    {
      *(_DWORD *)buf = 136446210;
      v84 = "nw_protocol_shoes_input_available";
      v70 = "%{public}s called with null shoes, no backtrace";
LABEL_152:
      _os_log_impl(&dword_182FBE000, v68, v69, v70, buf, 0xCu);
      goto LABEL_153;
    }
    goto LABEL_153;
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v84 = "nw_protocol_shoes_input_available";
      v85 = 2082;
      v86 = handle + 151;
      v6 = "%{public}s %{public}s No input handler";
      v7 = v5;
LABEL_91:
      v55 = OS_LOG_TYPE_ERROR;
LABEL_92:
      v56 = 22;
LABEL_93:
      _os_log_impl(&dword_182FBE000, v7, v55, v6, buf, v56);
    }
    return;
  }
  if (handle[150] == 6)
  {
    ((void (*)(void))default_input_handler->callbacks->input_available)();
    return;
  }
  output_handler = a1->output_handler;
  *(_QWORD *)v79 = 0;
  v80 = v79;
  if (((unsigned int (*)(void))output_handler->callbacks->get_input_frames)())
  {
    v9 = *(_QWORD *)v79;
    if (*(_QWORD *)v79)
    {
      do
      {
        v11 = (_QWORD *)(v9 + 32);
        v12 = *(_QWORD *)(v9 + 32);
        if (v12 || *(_QWORD *)(v9 + 40))
        {
          if (!*(_QWORD *)(v9 + 112))
            goto LABEL_24;
        }
        else
        {
          v12 = 0;
          if (!*(_QWORD *)(v9 + 112))
            goto LABEL_24;
        }
        if ((*(_WORD *)(v9 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(v9, *(_QWORD *)(v9 + 88)))
        {
          v14 = *(_DWORD *)(v9 + 52);
          v13 = *(unsigned int *)(v9 + 56);
          if (v14)
            v15 = v14 - (v13 + *(_DWORD *)(v9 + 60));
          else
            v15 = 0;
          v16 = *(_QWORD *)(v9 + 112) + v13;
          goto LABEL_25;
        }
LABEL_24:
        v15 = 0;
        v16 = 0;
LABEL_25:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          v84 = "nw_protocol_shoes_input_available";
          v85 = 2082;
          v86 = handle + 151;
          v87 = 1024;
          v88 = v15;
          v89 = 2048;
          *(_QWORD *)v90 = v16;
          _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Read frame has %u bytes (%p)", buf, 0x26u);
        }
        v18 = *(_QWORD *)(v9 + 32);
        v19 = *(_QWORD **)(v9 + 40);
        if (v18)
        {
          *(_QWORD *)(v18 + 40) = v19;
          v19 = *(_QWORD **)(v9 + 40);
        }
        else
        {
          v80 = *(os_log_type_t **)(v9 + 40);
        }
        *v19 = v18;
        *v11 = 0;
        *(_QWORD *)(v9 + 40) = 0;
        v10 = (_QWORD *)*((_QWORD *)handle + 16);
        *(_QWORD *)(v9 + 40) = v10;
        *v10 = v9;
        *((_QWORD *)handle + 16) = v11;
        v9 = v12;
      }
      while (v12);
    }
  }
  else if (gLogDatapath)
  {
    v75 = __nwlog_obj();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v84 = "nw_protocol_shoes_input_available";
      v85 = 2082;
      v86 = handle + 151;
      _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got 0 input frames", buf, 0x16u);
    }
  }
  v20 = handle + 151;
  while (1)
  {
    if (!*((_QWORD *)handle + 15))
      return;
    if (handle[150] != 5)
    {
      switch(handle[150])
      {
        case 1:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in initial state";
            goto LABEL_90;
          }
          break;
        case 2:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in waiting for TFO state";
            goto LABEL_90;
          }
          break;
        case 3:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in waiting for UDP associate state";
            goto LABEL_90;
          }
          break;
        case 6:
          (*(void (**)(_QWORD, char *))(*(_QWORD *)(*((_QWORD *)handle + 6) + 24) + 64))(*((_QWORD *)handle + 6), handle);
          break;
        case 7:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Tried to read packets in failed state";
LABEL_90:
            v7 = v54;
            goto LABEL_91;
          }
          break;
        default:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v58 = handle[150];
            *(_DWORD *)buf = 136446722;
            v84 = "nw_shoes_service_reads";
            v85 = 2082;
            v86 = handle + 151;
            v87 = 1024;
            v88 = v58;
            v6 = "%{public}s %{public}s Tried to read packets in unknown state %u";
            v7 = v57;
            v55 = OS_LOG_TYPE_ERROR;
            v56 = 28;
            goto LABEL_93;
          }
          break;
      }
      return;
    }
    v21 = *((_DWORD *)handle + 34);
    if (v21 <= 1 && !nw_shoes_read_into_buffer((uint64_t)handle, (uint64_t)(handle + 146), 2 - v21, v21))
      break;
    v22 = bswap32(*((unsigned __int16 *)handle + 73)) >> 16;
    if (!(_DWORD)v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_read_reply";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_INFO, "%{public}s %{public}s Received successful empty shoes reply from server", buf, 0x16u);
      }
      goto LABEL_54;
    }
    if ((_DWORD)v22 == 1)
    {
      v60 = __nwlog_obj();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_read_reply";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received invalid shoes reply length one", buf, 0x16u);
      }
      nw_protocol_shoes_error((nw_protocol *)handle, (nw_protocol *)handle, 422052353);
      handle[235] |= 0x10u;
      v61 = __nwlog_obj();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_internal_disconnect";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
      }
      handle[150] = 7;
      (*(void (**)(char *, _QWORD))(*((_QWORD *)handle + 3) + 48))(handle, 0);
      return;
    }
    v23 = *((_DWORD *)handle + 34);
    if (v23 <= 3)
    {
      if (!nw_shoes_read_into_buffer((uint64_t)handle, (uint64_t)(handle + 146), 4 - v23, v23))
      {
        if (gLogDatapath)
        {
          v59 = __nwlog_obj();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_shoes_read_reply";
            v85 = 2082;
            v86 = v20;
            v6 = "%{public}s %{public}s Failed to read shoes reply domain and error code";
            goto LABEL_110;
          }
        }
        return;
      }
      v23 = *((_DWORD *)handle + 34);
    }
    v24 = v22 + 2;
    v25 = v22 + 2 - v23;
    if (v25)
    {
      v26 = nw_calloc_type<unsigned char>((unsigned __int16)(v22 + 2 - v23));
      if (v24 > *((unsigned int *)handle + 34))
        goto LABEL_48;
    }
    else
    {
      v26 = 0;
      if (v24 > v23)
      {
LABEL_48:
        if (!nw_shoes_read_into_buffer((uint64_t)handle, v26, v25, 0))
        {
          if (gLogDatapath)
          {
            v76 = __nwlog_obj();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              v84 = "nw_shoes_read_reply";
              v85 = 2082;
              v86 = v20;
              _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Failed to read shoes rest of reply", buf, 0x16u);
            }
          }
          if (!v26)
            return;
LABEL_122:
          free((void *)v26);
          return;
        }
      }
    }
    if (handle[148])
    {
      v62 = handle[149];
      switch(handle[148])
      {
        case 1:
          v62 |= 0x19280100u;
          break;
        case 2:
          break;
        case 3:
          v62 |= 0xFFFEFF00;
          break;
        case 4:
          v62 -= 10055;
          break;
        default:
          v62 = 422052352;
          break;
      }
      v63 = __nwlog_obj();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        v64 = handle[148];
        v65 = handle[149];
        *(_DWORD *)buf = 136447490;
        v84 = "nw_shoes_read_reply";
        v85 = 2082;
        v86 = handle + 151;
        v87 = 1024;
        v88 = v62;
        v89 = 1024;
        *(_DWORD *)v90 = v64;
        *(_WORD *)&v90[4] = 1024;
        *(_DWORD *)&v90[6] = v65;
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v22;
        _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received shoes error %d domain %u code %u inner length %u", buf, 0x2Eu);
      }
      nw_shoes_read_reply_tlvs((uint64_t)handle, (unsigned __int8 *)v26, v25, 0);
      nw_protocol_shoes_error((nw_protocol *)handle, (nw_protocol *)handle, v62);
      handle[235] |= 0x10u;
      v66 = __nwlog_obj();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v84 = "nw_shoes_internal_disconnect";
        v85 = 2082;
        v86 = handle + 151;
        _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
      }
      handle[150] = 7;
      (*(void (**)(char *, _QWORD))(*((_QWORD *)handle + 3) + 48))(handle, 0);
      if (!v26)
        return;
      goto LABEL_122;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v29 = handle[149];
      *(_DWORD *)buf = 136446978;
      v84 = "nw_shoes_read_reply";
      v85 = 2082;
      v86 = handle + 151;
      v87 = 1024;
      v88 = v22;
      v89 = 1024;
      *(_DWORD *)v90 = v29;
      _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_INFO, "%{public}s %{public}s Received successful shoes reply from server with inner length %u code %u", buf, 0x22u);
    }
    nw_shoes_read_reply_tlvs((uint64_t)handle, (unsigned __int8 *)v26, v25, 1);
    if (v26)
      free((void *)v26);
LABEL_54:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v84 = "nw_shoes_internal_connect";
      v85 = 2082;
      v86 = handle + 151;
      _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_INFO, "%{public}s %{public}s ", buf, 0x16u);
    }
    handle[150] = 6;
    v31 = *((_QWORD *)handle + 6);
    if ((handle[235] & 2) != 0)
    {
      v32 = *((_QWORD *)handle + 5);
      if (!v32)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v84 = "nw_protocol_shoes_process_udp_associate_completion";
        v43 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v81 = 0;
        v78 = (char *)v43;
        if (!__nwlog_fault(v43, &type, &v81))
          goto LABEL_78;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v44 = __nwlog_obj();
          v45 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            v84 = "nw_protocol_shoes_process_udp_associate_completion";
            v46 = v44;
            v47 = v45;
            v48 = "%{public}s called with null shoes";
            goto LABEL_77;
          }
          goto LABEL_78;
        }
        if (v81)
        {
          v49 = (char *)__nw_create_backtrace_string();
          v50 = __nwlog_obj();
          v77 = type;
          v51 = os_log_type_enabled(v50, type);
          if (v49)
          {
            if (v51)
            {
              *(_DWORD *)buf = 136446466;
              v84 = "nw_protocol_shoes_process_udp_associate_completion";
              v85 = 2082;
              v86 = v49;
              _os_log_impl(&dword_182FBE000, v50, v77, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v49);
            goto LABEL_78;
          }
          if (!v51)
          {
LABEL_78:
            if (v78)
              free(v78);
            goto LABEL_32;
          }
          *(_DWORD *)buf = 136446210;
          v84 = "nw_protocol_shoes_process_udp_associate_completion";
          v46 = v50;
          v47 = v77;
          v48 = "%{public}s called with null shoes, no backtrace";
        }
        else
        {
          v52 = __nwlog_obj();
          v53 = type;
          if (!os_log_type_enabled(v52, type))
            goto LABEL_78;
          *(_DWORD *)buf = 136446210;
          v84 = "nw_protocol_shoes_process_udp_associate_completion";
          v46 = v52;
          v47 = v53;
          v48 = "%{public}s called with null shoes, backtrace limit exceeded";
        }
LABEL_77:
        _os_log_impl(&dword_182FBE000, v46, v47, v48, buf, 0xCu);
        goto LABEL_78;
      }
      if ((*(_BYTE *)(v32 + 235) & 0xE) == 6)
      {
        v33 = *(_QWORD *)(v32 + 64);
        if (v33)
        {
          *(_QWORD *)(v32 + 64) = *(_QWORD *)(v32 + 32);
          nw_protocol_set_output_handler((uint64_t)handle, v33);
          nw_protocol_set_output_handler(v32, v33);
          *(_BYTE *)(v32 + 235) |= 8u;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v34 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
          {
            v35 = *(unsigned __int16 *)(v32 + 144);
            v37 = *(_QWORD *)(v32 + 96);
            v36 = *(_QWORD *)(v32 + 104);
            *(_DWORD *)buf = 136447234;
            v84 = "nw_protocol_shoes_process_udp_associate_completion";
            v85 = 2082;
            v86 = (char *)(v32 + 151);
            v87 = 1024;
            v88 = v35;
            v89 = 2112;
            *(_QWORD *)v90 = v36;
            *(_WORD *)&v90[8] = 2112;
            v91 = v37;
            v38 = v34;
            v39 = OS_LOG_TYPE_DEFAULT;
            v40 = "%{public}s %{public}s udp-associate completed with port %d to %@ and remote %@";
            v41 = 48;
LABEL_31:
            _os_log_impl(&dword_182FBE000, v38, v39, v40, buf, v41);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v42 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "nw_protocol_shoes_process_udp_associate_completion";
            v85 = 2082;
            v86 = (char *)(v32 + 151);
            v38 = v42;
            v39 = OS_LOG_TYPE_ERROR;
            v40 = "%{public}s %{public}s udp-associate no output handler";
            v41 = 22;
            goto LABEL_31;
          }
        }
      }
    }
LABEL_32:
    (*(void (**)(uint64_t, char *))(*(_QWORD *)(v31 + 24) + 40))(v31, handle);
  }
  if (gLogDatapath)
  {
    v59 = __nwlog_obj();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v84 = "nw_shoes_read_reply";
      v85 = 2082;
      v86 = v20;
      v6 = "%{public}s %{public}s Failed to read shoes reply length";
LABEL_110:
      v7 = v59;
      v55 = OS_LOG_TYPE_DEBUG;
      goto LABEL_92;
    }
  }
}

uint64_t nw_protocol_shoes_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, uint64_t a5, nw_frame_array_s *a6)
{
  _BYTE *handle;
  uint64_t v7;
  int v8;
  nw_frame **v9;
  uint64_t v10;
  _QWORD *v11;
  nw_frame **tqh_last;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  char *backtrace_string;
  _BOOL4 v19;
  const char *v20;
  _BOOL4 v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_shoes_get_input_frames";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v14, &type, &v22))
      goto LABEL_41;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (!os_log_type_enabled(v15, type))
          goto LABEL_41;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_shoes_get_input_frames";
        v17 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_40;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v19 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (!v19)
          goto LABEL_41;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_shoes_get_input_frames";
        v17 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_40;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_protocol_shoes_get_input_frames";
        v26 = 2082;
        v27 = backtrace_string;
        v20 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_30:
        _os_log_impl(&dword_182FBE000, v15, v16, v20, buf, 0x16u);
      }
LABEL_31:
      free(backtrace_string);
      goto LABEL_41;
    }
    v15 = __nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_shoes_get_input_frames";
    v17 = "%{public}s called with null protocol";
LABEL_40:
    _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
LABEL_41:
    if (v14)
      free(v14);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_shoes_get_input_frames";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v14, &type, &v22))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_shoes_get_input_frames";
      v17 = "%{public}s called with null shoes";
      goto LABEL_40;
    }
    if (!v22)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_shoes_get_input_frames";
      v17 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = type;
    v21 = os_log_type_enabled(v15, type);
    if (backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_protocol_shoes_get_input_frames";
        v26 = 2082;
        v27 = backtrace_string;
        v20 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
        goto LABEL_30;
      }
      goto LABEL_31;
    }
    if (!v21)
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_shoes_get_input_frames";
    v17 = "%{public}s called with null shoes, no backtrace";
    goto LABEL_40;
  }
  if (handle[150] != 6)
    return 0;
  v7 = *((_QWORD *)handle + 15);
  if (!v7)
    return (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)handle + 4) + 24) + 80))();
  if ((_DWORD)a5)
  {
    v8 = 1;
    while (1)
    {
      v10 = *(_QWORD *)(v7 + 32);
      v11 = *(_QWORD **)(v7 + 40);
      v9 = (nw_frame **)(v7 + 32);
      if (v10)
      {
        *(_QWORD *)(v10 + 40) = v11;
        v11 = *(_QWORD **)(v7 + 40);
      }
      else
      {
        *((_QWORD *)handle + 16) = v11;
      }
      *v11 = v10;
      *v9 = 0;
      *(_QWORD *)(v7 + 40) = 0;
      tqh_last = a6->tqh_last;
      *(_QWORD *)(v7 + 40) = tqh_last;
      *tqh_last = (nw_frame *)v7;
      a6->tqh_last = v9;
      if ((_DWORD)a5 == v8)
        break;
      v7 = *((_QWORD *)handle + 15);
      ++v8;
      if (!v7)
        return (v8 - 1);
    }
  }
  return a5;
}

uint64_t nw_protocol_shoes_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  int v9;
  unsigned __int8 *request;
  unsigned __int8 *v11;
  unsigned int v12;
  _DWORD *v13;
  unsigned int v14;
  int v15;
  int v16;
  nw_frame *tqh_first;
  unsigned __int8 *v18;
  nw_frame *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  size_t v23;
  uint64_t v24;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  NSObject *v31;
  nw_protocol *output_handler;
  uint64_t (*get_output_local_endpoint)(void);
  nw_protocol *default_input_handler;
  uint64_t (*get_local_endpoint)(void);
  int v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  char *backtrace_string;
  _BOOL4 v42;
  const char *v43;
  _BOOL4 v44;
  char *v45;
  NSObject *v46;
  os_log_type_t v47;
  const char *v48;
  char *v49;
  _BOOL4 v50;
  unsigned int v51;
  char v52;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  char *v57;
  __int16 v58;
  _BYTE v59[10];
  int v60;
  __int16 v61;
  unsigned int v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_shoes_get_output_frames";
    v37 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v37, &type, &v52))
      goto LABEL_82;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v52)
      {
        v38 = __nwlog_obj();
        v39 = type;
        if (!os_log_type_enabled(v38, type))
          goto LABEL_82;
        *(_DWORD *)buf = 136446210;
        v55 = "nw_protocol_shoes_get_output_frames";
        v40 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_81;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = __nwlog_obj();
      v39 = type;
      v42 = os_log_type_enabled(v38, type);
      if (!backtrace_string)
      {
        if (!v42)
          goto LABEL_82;
        *(_DWORD *)buf = 136446210;
        v55 = "nw_protocol_shoes_get_output_frames";
        v40 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_81;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v55 = "nw_protocol_shoes_get_output_frames";
        v56 = 2082;
        v57 = backtrace_string;
        v43 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_67:
        _os_log_impl(&dword_182FBE000, v38, v39, v43, buf, 0x16u);
      }
LABEL_68:
      free(backtrace_string);
      goto LABEL_82;
    }
    v38 = __nwlog_obj();
    v39 = type;
    if (!os_log_type_enabled(v38, type))
      goto LABEL_82;
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_shoes_get_output_frames";
    v40 = "%{public}s called with null protocol";
LABEL_81:
    _os_log_impl(&dword_182FBE000, v38, v39, v40, buf, 0xCu);
LABEL_82:
    if (v37)
      free(v37);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_shoes_get_output_frames";
    v37 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v37, &type, &v52))
      goto LABEL_82;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type))
        goto LABEL_82;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_shoes_get_output_frames";
      v40 = "%{public}s called with null shoes";
      goto LABEL_81;
    }
    if (!v52)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type))
        goto LABEL_82;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_shoes_get_output_frames";
      v40 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_81;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = __nwlog_obj();
    v39 = type;
    v44 = os_log_type_enabled(v38, type);
    if (backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        v55 = "nw_protocol_shoes_get_output_frames";
        v56 = 2082;
        v57 = backtrace_string;
        v43 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
        goto LABEL_67;
      }
      goto LABEL_68;
    }
    if (!v44)
      goto LABEL_82;
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_shoes_get_output_frames";
    v40 = "%{public}s called with null shoes, no backtrace";
    goto LABEL_81;
  }
  v9 = *((unsigned __int8 *)handle + 150);
  if (v9 == 6)
    return (*(uint64_t (**)(void))(*(_QWORD *)(handle[4] + 24) + 88))();
  if (v9 != 2)
    return 0;
  request = (unsigned __int8 *)nw_shoes_create_request((uint64_t)a1->handle);
  if (!request)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v55 = "nw_shoes_internal_disconnect";
      v56 = 2082;
      v57 = (char *)handle + 151;
      _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
    }
    *((_BYTE *)handle + 150) = 7;
    (*(void (**)(_QWORD *, _QWORD))(handle[3] + 48))(handle, 0);
    return 0;
  }
  v11 = request;
  v12 = bswap32(*(unsigned __int16 *)request) >> 16;
  v13 = a1->handle;
  if (!v13)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_add_buffer_to_output_frames";
    v45 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v45, &type, &v52))
      goto LABEL_95;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v46 = __nwlog_obj();
      v47 = type;
      if (!os_log_type_enabled(v46, type))
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_add_buffer_to_output_frames";
      v48 = "%{public}s called with null shoes";
    }
    else if (v52)
    {
      v49 = (char *)__nw_create_backtrace_string();
      v46 = __nwlog_obj();
      v47 = type;
      v50 = os_log_type_enabled(v46, type);
      if (v49)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_add_buffer_to_output_frames";
          v56 = 2082;
          v57 = v49;
          _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v49);
        goto LABEL_95;
      }
      if (!v50)
      {
LABEL_95:
        if (v45)
          free(v45);
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_add_buffer_to_output_frames";
      v48 = "%{public}s called with null shoes, no backtrace";
    }
    else
    {
      v46 = __nwlog_obj();
      v47 = type;
      if (!os_log_type_enabled(v46, type))
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_add_buffer_to_output_frames";
      v48 = "%{public}s called with null shoes, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v46, v47, v48, buf, 0xCu);
    goto LABEL_95;
  }
  v14 = v12 + 2;
  v15 = ((uint64_t (*)(void))a1->output_handler->callbacks->get_output_frames)();
  v16 = v15;
  tqh_first = a6->tqh_first;
  if (!a6->tqh_first || !v15)
  {
    if (v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_protocol_add_buffer_to_output_frames";
        v56 = 2082;
        v57 = (char *)v13 + 151;
        v58 = 1024;
        *(_DWORD *)v59 = v16;
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Output handler reported %u frames to write, but array is empty", buf, 0x1Cu);
      }
    }
LABEL_36:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v29 = v11[2];
      *(_DWORD *)buf = 136446978;
      v55 = "nw_protocol_shoes_add_request_to_output_frames";
      v56 = 2082;
      v57 = (char *)handle + 151;
      v58 = 1024;
      *(_DWORD *)v59 = v29;
      *(_WORD *)&v59[4] = 1024;
      *(_DWORD *)&v59[6] = v12;
      _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Failed to send shoes request (type %u inner length %u)", buf, 0x22u);
    }
    free(v11);
    return 0;
  }
  v51 = v12;
  v18 = v11;
  while (1)
  {
    v19 = (nw_frame *)*((_QWORD *)tqh_first + 4);
    if (v19 || *((_QWORD *)tqh_first + 5))
    {
      v20 = *((_QWORD *)tqh_first + 14);
      if (!v20)
        goto LABEL_20;
    }
    else
    {
      v19 = 0;
      v20 = *((_QWORD *)tqh_first + 14);
      if (!v20)
        goto LABEL_20;
    }
    if ((*((_WORD *)tqh_first + 102) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(tqh_first, *((_QWORD *)tqh_first + 11)))
    {
      LODWORD(v20) = 0;
LABEL_20:
      v22 = 0;
      goto LABEL_21;
    }
    LODWORD(v20) = *((_DWORD *)tqh_first + 13);
    v21 = *((unsigned int *)tqh_first + 14);
    if ((_DWORD)v20)
      LODWORD(v20) = v20 - (v21 + *((_DWORD *)tqh_first + 15));
    v22 = (void *)(*((_QWORD *)tqh_first + 14) + v21);
LABEL_21:
    v23 = v20 >= v14 ? v14 : v20;
    memcpy(v22, v18, v23);
    if (!nw_frame_claim((uint64_t)tqh_first, v24, v23, 0))
      break;
    v13[35] += v23;
    if (v19)
    {
      v18 += v23;
      tqh_first = v19;
      v14 -= v23;
      if (v14)
        continue;
    }
    goto LABEL_41;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v30 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v55 = "nw_protocol_add_buffer_to_output_frames";
    v56 = 2082;
    v57 = (char *)v13 + 151;
    v58 = 1024;
    *(_DWORD *)v59 = v23;
    _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Claiming frame with %u bytes failed", buf, 0x1Cu);
  }
LABEL_41:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v31 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    output_handler = a1->output_handler;
    if (!output_handler
      || (get_output_local_endpoint = (uint64_t (*)(void))output_handler->callbacks->get_output_local_endpoint) == 0
      || (default_input_handler = (nw_protocol *)get_output_local_endpoint()) == 0)
    {
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        get_local_endpoint = (uint64_t (*)(void))default_input_handler->callbacks->get_local_endpoint;
        if (get_local_endpoint)
          default_input_handler = (nw_protocol *)get_local_endpoint();
        else
          default_input_handler = 0;
      }
    }
    v36 = v11[2];
    *(_DWORD *)buf = 136447234;
    v55 = "nw_protocol_shoes_add_request_to_output_frames";
    v56 = 2082;
    v57 = (char *)handle + 151;
    v58 = 2114;
    *(_QWORD *)v59 = default_input_handler;
    *(_WORD *)&v59[8] = 1024;
    v60 = v36;
    v61 = 1024;
    v62 = v51;
    _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Sent shoes request: local address %{public}@ type %u inner length %u with TFO", buf, 0x2Cu);
  }
  free(v11);
  *((_BYTE *)handle + 150) = 4;
  return 1;
}

uint64_t nw_protocol_shoes_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _QWORD *handle;
  int v3;
  nw_frame *tqh_first;
  unsigned int v5;
  unsigned int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char *v18;
  _BOOL4 v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_shoes_finalize_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v12, &type, &v20))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_shoes_finalize_output_frames";
      v15 = "%{public}s called with null protocol";
      goto LABEL_51;
    }
    if (!v20)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_shoes_finalize_output_frames";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v17 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (!v17)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_shoes_finalize_output_frames";
      v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_51;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_shoes_finalize_output_frames";
      v24 = 2082;
      v25 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_52:
    if (!v12)
      return 0;
LABEL_53:
    free(v12);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_shoes_finalize_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v12, &type, &v20))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_shoes_finalize_output_frames";
      v15 = "%{public}s called with null shoes";
      goto LABEL_51;
    }
    if (!v20)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_shoes_finalize_output_frames";
      v15 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_51;
    }
    v18 = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v19 = os_log_type_enabled(v13, type);
    if (v18)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_protocol_shoes_finalize_output_frames";
        v24 = 2082;
        v25 = v18;
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v18);
      if (!v12)
        return 0;
      goto LABEL_53;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_shoes_finalize_output_frames";
      v15 = "%{public}s called with null shoes, no backtrace";
LABEL_51:
      _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
      goto LABEL_52;
    }
    goto LABEL_52;
  }
  v3 = *((unsigned __int8 *)handle + 150);
  if (v3 == 6)
    return (*(uint64_t (**)(void))(*(_QWORD *)(handle[4] + 24) + 96))();
  if (v3 == 4)
  {
    tqh_first = a2->tqh_first;
    v5 = *((_DWORD *)handle + 35);
    if (a2->tqh_first)
    {
      while (v5)
      {
        v8 = (uint64_t)tqh_first;
        tqh_first = (nw_frame *)*((_QWORD *)tqh_first + 4);
        if (!tqh_first && !*(_QWORD *)(v8 + 40))
          tqh_first = 0;
        v9 = *(_DWORD *)(v8 + 52);
        if (v9)
        {
          v10 = v9 - (*(_DWORD *)(v8 + 56) + *(_DWORD *)(v8 + 60));
          if (v10 < v5)
            v7 = 0;
          else
            v7 = v5;
          if (v10 < v5 && v9 != 0)
            v7 = v9 - (*(_DWORD *)(v8 + 56) + *(_DWORD *)(v8 + 60));
        }
        else
        {
          v7 = 0;
        }
        nw_frame_unclaim(v8, (uint64_t)a2, v7, 0);
        v5 = *((_DWORD *)handle + 35) - v7;
        *((_DWORD *)handle + 35) = v5;
        if (!tqh_first)
          goto LABEL_6;
      }
      goto LABEL_7;
    }
LABEL_6:
    if (!v5)
LABEL_7:
      *((_BYTE *)handle + 150) = 5;
    return (*(uint64_t (**)(void))(*(_QWORD *)(handle[4] + 24) + 96))();
  }
  return 0;
}

BOOL nw_protocol_shoes_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  _BYTE *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  const char *v10;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
      return handle[150] == 2;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_shoes_waiting_for_output";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_shoes_waiting_for_output";
        v7 = "%{public}s called with null shoes";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v12)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_shoes_waiting_for_output";
        v7 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_shoes_waiting_for_output";
        v7 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "nw_protocol_shoes_waiting_for_output";
      v16 = 2082;
      v17 = backtrace_string;
      v10 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_shoes_waiting_for_output";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_shoes_waiting_for_output";
        v7 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_shoes_waiting_for_output";
        v7 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "nw_protocol_shoes_waiting_for_output";
      v16 = 2082;
      v17 = backtrace_string;
      v10 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v5, v6, v10, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v5 = __nwlog_obj();
  v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)buf = 136446210;
    v15 = "nw_protocol_shoes_waiting_for_output";
    v7 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
  }
LABEL_32:
  if (v4)
    free(v4);
  return 0;
}

uint64_t nw_protocol_shoes_connect(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  uint64_t (*connect)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_shoes_connect";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_shoes_connect";
      v9 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v14)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_36;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_shoes_connect";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_shoes_connect";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v6)
          return 0;
        goto LABEL_37;
      }
      if (!v11)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_shoes_connect";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_36;
  }
  if (!a1->handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_shoes_connect";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_shoes_connect";
      v9 = "%{public}s called with null shoes";
      goto LABEL_35;
    }
    if (!v14)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_shoes_connect";
      v9 = "%{public}s called with null shoes, backtrace limit exceeded";
      goto LABEL_35;
    }
    v12 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v13)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_shoes_connect";
      v9 = "%{public}s called with null shoes, no backtrace";
      goto LABEL_35;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_shoes_connect";
      v18 = 2082;
      v19 = v12;
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v12);
LABEL_36:
    if (!v6)
      return 0;
LABEL_37:
    free(v6);
    return 0;
  }
  output_handler = a1->output_handler;
  if (!output_handler)
    return 1;
  callbacks = output_handler->callbacks;
  if (callbacks)
  {
    connect = (uint64_t (*)(void))callbacks->connect;
    if (connect)
      return connect();
  }
  return 0;
}

void nw_protocol_shoes_connected(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_output_local_endpoint)(void);
  void *v8;
  NSObject *v9;
  id v10;
  unsigned int v11;
  nw_protocol *v12;
  nw_protocol *v13;
  nw_protocol_callbacks *v14;
  void *v15;
  nw_protocol_identifier *v16;
  int v17;
  NSObject *v18;
  nw_protocol *v19;
  void *v20;
  nw_protocol *v21;
  NSObject *v22;
  nw_protocol_identifier *identifier;
  nw_protocol *v24;
  nw_protocol_identifier *v25;
  nw_protocol *v26;
  uint64_t (*v27)(void);
  nw_protocol *default_input_handler;
  uint64_t (*get_local_endpoint)(void);
  NSObject *v30;
  NSObject *v31;
  const char *v32;
  char v33;
  int v34;
  char v35;
  NSObject *v36;
  _BOOL4 v37;
  char *v38;
  id v39;
  _BOOL8 v40;
  NSObject *v41;
  NWConcrete_nw_protocol_options *options;
  id v43;
  id v44;
  int ip_protocol;
  NWConcrete_nw_path_flow_registration *new_flow;
  _BOOL8 v47;
  uint64_t internal;
  uint64_t v49;
  void (*v50)(uint64_t, nw_protocol *);
  void *v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  char *backtrace_string;
  _BOOL4 v57;
  char *v58;
  _BOOL4 v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  uint64_t v64;
  const char *v65;
  const char *v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  uint64_t v70;
  const char *v71;
  const char *v72;
  const char *v73;
  NSObject *v74;
  char *v75;
  _BOOL4 v76;
  char *v77;
  _BOOL4 v78;
  uint64_t v79;
  const char *v80;
  const char *v81;
  uint64_t v82;
  const char *v83;
  const char *v84;
  uint64_t v85;
  const char *v86;
  const char *v87;
  char v88;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v91;
  __int16 v92;
  char *v93;
  __int16 v94;
  nw_protocol *v95;
  __int16 v96;
  nw_protocol_identifier *v97;
  __int16 v98;
  nw_protocol *v99;
  __int16 v100;
  nw_protocol_identifier *v101;
  __int128 v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v91 = "nw_protocol_shoes_connected";
    v52 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v102) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v52, &v102, &type))
      goto LABEL_106;
    if (v102 == 17)
    {
      v53 = __nwlog_obj();
      v54 = v102;
      if (!os_log_type_enabled(v53, (os_log_type_t)v102))
        goto LABEL_106;
      *(_DWORD *)buf = 136446210;
      v91 = "nw_protocol_shoes_connected";
      v55 = "%{public}s called with null protocol";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v53 = __nwlog_obj();
      v54 = v102;
      v57 = os_log_type_enabled(v53, (os_log_type_t)v102);
      if (backtrace_string)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446466;
          v91 = "nw_protocol_shoes_connected";
          v92 = 2082;
          v93 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_106:
        if (!v52)
          return;
LABEL_107:
        free(v52);
        return;
      }
      if (!v57)
        goto LABEL_106;
      *(_DWORD *)buf = 136446210;
      v91 = "nw_protocol_shoes_connected";
      v55 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v53 = __nwlog_obj();
      v54 = v102;
      if (!os_log_type_enabled(v53, (os_log_type_t)v102))
        goto LABEL_106;
      *(_DWORD *)buf = 136446210;
      v91 = "nw_protocol_shoes_connected";
      v55 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_105:
    _os_log_impl(&dword_182FBE000, v53, v54, v55, buf, 0xCu);
    goto LABEL_106;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if ((handle[235] & 0xE) == 6 && handle[150] == 3)
    {
      if (*((nw_protocol **)handle + 8) != a2)
        return;
      output_handler = a1->output_handler;
      if (!output_handler)
        return;
      callbacks = output_handler->callbacks;
      if (!callbacks)
        return;
      get_output_local_endpoint = (uint64_t (*)(void))callbacks->get_output_local_endpoint;
      if (!get_output_local_endpoint)
        return;
      v8 = (void *)get_output_local_endpoint();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      if (v8)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          v91 = "nw_protocol_shoes_connected";
          v92 = 2082;
          v93 = handle + 151;
          _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s udp-associate tcp connected", buf, 0x16u);
        }
        v10 = v8;
        v11 = objc_msgSend(v10, "port");

        *((_WORD *)handle + 72) = __rev16(v11);
        v12 = a1->output_handler;
        nw_protocol_set_output_handler((uint64_t)a1, *((_QWORD *)handle + 8));
        nw_protocol_set_output_handler((uint64_t)handle, *((_QWORD *)handle + 8));
        *((_QWORD *)handle + 8) = v12;
        nw_protocol_shoes_send_request_inner(a1);
        return;
      }
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v91 = "nw_protocol_shoes_connected";
        v92 = 2082;
        v93 = handle + 151;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp-associate no local endpoint for udp", buf, 0x16u);
      }
      nw_protocol_shoes_error((nw_protocol *)handle, (nw_protocol *)handle, 57);
      handle[235] |= 0x10u;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = gLogObj;
      v31 = gLogObj;
      goto LABEL_74;
    }
    v13 = a1->output_handler;
    if (v13)
    {
      v14 = v13->callbacks;
      if (v14)
      {
        if (v14->get_output_local_endpoint)
        {
          v15 = (void *)((uint64_t (*)(void))v14->get_remote_endpoint)();
          if (v15)
          {
            v16 = v15;
            v17 = -[nw_protocol_identifier type](v16, "type");

            if (v17 == 1 && nw_endpoint_get_type(*((nw_endpoint_t *)handle + 13)) != nw_endpoint_type_address)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v18 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
              {
                v19 = (nw_protocol *)*((_QWORD *)handle + 13);
                *(_DWORD *)buf = 136446978;
                v91 = "nw_protocol_shoes_connected";
                v92 = 2082;
                v93 = handle + 151;
                v94 = 2112;
                v95 = v19;
                v96 = 2112;
                v97 = v16;
                _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Updating peer endpoint from %@ to %@", buf, 0x2Au);
              }
              v20 = (void *)*((_QWORD *)handle + 13);
              *((_QWORD *)handle + 13) = os_retain(v16);
              if (v20)
                os_release(v20);
            }
          }
        }
      }
    }
    ((void (*)(void))a1->default_input_handler->callbacks->connected)();
    v21 = a1->output_handler;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = gLogObj;
    if (v21 != a2)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        identifier = a2->identifier;
        v24 = a1->output_handler;
        v25 = a1->identifier;
        *(_DWORD *)buf = 136447490;
        v91 = "nw_protocol_shoes_connected";
        v92 = 2082;
        v93 = handle + 151;
        v94 = 2048;
        v95 = a2;
        v96 = 2080;
        v97 = identifier;
        v98 = 2048;
        v99 = v24;
        v100 = 2080;
        v101 = v25;
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s connected protocol %p (%s) is not our output_handler %p (%s), ignoring", buf, 0x3Eu);
      }
      return;
    }
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v26 = a1->output_handler;
      if (!v26
        || (v27 = (uint64_t (*)(void))v26->callbacks->get_output_local_endpoint) == 0
        || (default_input_handler = (nw_protocol *)v27()) == 0)
      {
        default_input_handler = a1->default_input_handler;
        if (default_input_handler)
        {
          get_local_endpoint = (uint64_t (*)(void))default_input_handler->callbacks->get_local_endpoint;
          if (get_local_endpoint)
            default_input_handler = (nw_protocol *)get_local_endpoint();
          else
            default_input_handler = 0;
        }
      }
      v32 = "with";
      v91 = "nw_protocol_shoes_connected";
      v33 = handle[235];
      *(_DWORD *)buf = 136446978;
      v92 = 2082;
      if ((v33 & 1) == 0)
        v32 = "no";
      v93 = handle + 151;
      v94 = 2114;
      v95 = default_input_handler;
      v96 = 2082;
      v97 = (nw_protocol_identifier *)v32;
      _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s local address %{public}@ %{public}s TFO", buf, 0x2Au);
    }
    v34 = handle[150];
    if (v34 != 6)
    {
      if (v34 != 1)
        return;
      *((_DWORD *)handle + 34) = 0;
      v35 = handle[235];
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = gLogObj;
      v37 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
      if ((v35 & 1) == 0)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v91 = "nw_protocol_shoes_connected";
          v92 = 2082;
          v93 = handle + 151;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s send request without TFO data from above", buf, 0x16u);
        }
        v38 = (char *)a1->handle;
        if (v38)
        {
          if ((~v38[235] & 6) == 0)
          {
            if (gLogDatapath)
            {
              v74 = __nwlog_obj();
              if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446466;
                v91 = "nw_protocol_shoes_send_request";
                v92 = 2082;
                v93 = v38 + 151;
                _os_log_impl(&dword_182FBE000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s udp-associate creating output handler for udp", buf, 0x16u);
              }
            }
            v39 = (id)(*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)v38 + 6) + 24) + 112))();
            v40 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v39, 0, 0);

            v41 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v40);
            if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
              dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
            options = nw_protocol_create_options((void *)g_tcp_definition);
            nw_tcp_options_set_reset_local_port(options, 1);
            nw_protocol_options_set_log_id(options, "C", v38 + 151, 101);
            nw_protocol_stack_set_transport_protocol(v41, &options->super);
            if (v41)
              os_release(v41);
            if (options)
              os_release(options);
            v43 = nw_parameters_copy_context(v39);
            v44 = nw_path_copy_flow_registration(v43, (uint64_t)v38);
            if (v43)
              os_release(v43);
            ip_protocol = nw_parameters_get_ip_protocol((void *)v40);
            new_flow = nw_path_flow_registration_create_new_flow(v44, 1, 0, 0, 0, 0, 0, ip_protocol);
            *((_QWORD *)v38 + 10) = new_flow;
            nw_path_flow_registration_set_specific_use_only(new_flow, 1);
            if (v44)
              os_release(v44);
            v102 = *(_OWORD *)v38;
            nw_path_flow_registration_get_id(*((void **)v38 + 10), v38);
            v47 = nw_endpoint_copy_original_endpoint(*((void **)v38 + 12), 1);
            if (nw_socket_protocol_identifier::onceToken != -1)
              dispatch_once(&nw_socket_protocol_identifier::onceToken, &__block_literal_global_63760);
            internal = nw_protocol_create_internal((uint64_t)&nw_socket_protocol_identifier::identifier, (void *)v47, (const char *)v40, 1);
            if (v47)
              os_release((void *)v47);
            *((_QWORD *)v38 + 9) = v40;
            (**(void (***)(uint64_t, nw_protocol *))(internal + 24))(internal, a1);
            *((_QWORD *)v38 + 8) = internal;
            v38[150] = 3;
            v49 = *(_QWORD *)(internal + 24);
            if (v49)
            {
              v50 = *(void (**)(uint64_t, nw_protocol *))(v49 + 24);
              if (v50)
              {
                v50(internal, a1);
LABEL_65:
                v51 = (void *)*((_QWORD *)v38 + 9);
                if (v51)
                {
                  os_release(v51);
                  *((_QWORD *)v38 + 9) = 0;
                }
                *(_OWORD *)v38 = v102;
                return;
              }
            }
            __nwlog_obj();
            v64 = *((_QWORD *)v38 + 8);
            v65 = "invalid";
            if (v64)
            {
              v66 = *(const char **)(v64 + 16);
              if (v66)
                v65 = v66;
            }
            *(_DWORD *)buf = 136446466;
            v91 = "nw_protocol_shoes_send_request";
            v92 = 2082;
            v93 = (char *)v65;
            v67 = (char *)_os_log_send_and_compose_impl();
            type = OS_LOG_TYPE_ERROR;
            v88 = 0;
            if (__nwlog_fault(v67, &type, &v88))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                v68 = __nwlog_obj();
                v69 = type;
                if (!os_log_type_enabled(v68, type))
                  goto LABEL_155;
                v70 = *((_QWORD *)v38 + 8);
                v71 = "invalid";
                if (v70)
                {
                  v72 = *(const char **)(v70 + 16);
                  if (v72)
                    v71 = v72;
                }
                *(_DWORD *)buf = 136446466;
                v91 = "nw_protocol_shoes_send_request";
                v92 = 2082;
                v93 = (char *)v71;
                v73 = "%{public}s protocol %{public}s has invalid connect callback";
                goto LABEL_154;
              }
              if (!v88)
              {
                v68 = __nwlog_obj();
                v69 = type;
                if (!os_log_type_enabled(v68, type))
                  goto LABEL_155;
                v82 = *((_QWORD *)v38 + 8);
                v83 = "invalid";
                if (v82)
                {
                  v84 = *(const char **)(v82 + 16);
                  if (v84)
                    v83 = v84;
                }
                *(_DWORD *)buf = 136446466;
                v91 = "nw_protocol_shoes_send_request";
                v92 = 2082;
                v93 = (char *)v83;
                v73 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
                goto LABEL_154;
              }
              v77 = (char *)__nw_create_backtrace_string();
              v68 = __nwlog_obj();
              v69 = type;
              v78 = os_log_type_enabled(v68, type);
              if (v77)
              {
                if (v78)
                {
                  v79 = *((_QWORD *)v38 + 8);
                  v80 = "invalid";
                  if (v79)
                  {
                    v81 = *(const char **)(v79 + 16);
                    if (v81)
                      v80 = v81;
                  }
                  *(_DWORD *)buf = 136446722;
                  v91 = "nw_protocol_shoes_send_request";
                  v92 = 2082;
                  v93 = (char *)v80;
                  v94 = 2082;
                  v95 = (nw_protocol *)v77;
                  _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
                }
                free(v77);
                goto LABEL_155;
              }
              if (v78)
              {
                v85 = *((_QWORD *)v38 + 8);
                v86 = "invalid";
                if (v85)
                {
                  v87 = *(const char **)(v85 + 16);
                  if (v87)
                    v86 = v87;
                }
                *(_DWORD *)buf = 136446466;
                v91 = "nw_protocol_shoes_send_request";
                v92 = 2082;
                v93 = (char *)v86;
                v73 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
LABEL_154:
                _os_log_impl(&dword_182FBE000, v68, v69, v73, buf, 0x16u);
              }
            }
LABEL_155:
            if (v67)
              free(v67);
            goto LABEL_65;
          }
          if ((nw_protocol_shoes_send_request_inner(a1) & 1) != 0)
            return;
LABEL_73:
          v31 = __nwlog_obj();
          v30 = v31;
LABEL_74:
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            v91 = "nw_shoes_internal_disconnect";
            v92 = 2082;
            v93 = handle + 151;
            _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ", buf, 0x16u);
          }
          handle[150] = 7;
          (*(void (**)(char *, _QWORD))(*((_QWORD *)handle + 3) + 48))(handle, 0);
          return;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v91 = "nw_protocol_shoes_send_request";
        v60 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v102) = 16;
        type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v60, &v102, &type))
        {
          if (v102 == 17)
          {
            v61 = __nwlog_obj();
            v62 = v102;
            if (!os_log_type_enabled(v61, (os_log_type_t)v102))
              goto LABEL_147;
            *(_DWORD *)buf = 136446210;
            v91 = "nw_protocol_shoes_send_request";
            v63 = "%{public}s called with null shoes";
            goto LABEL_146;
          }
          if (type == OS_LOG_TYPE_DEFAULT)
          {
            v61 = __nwlog_obj();
            v62 = v102;
            if (!os_log_type_enabled(v61, (os_log_type_t)v102))
              goto LABEL_147;
            *(_DWORD *)buf = 136446210;
            v91 = "nw_protocol_shoes_send_request";
            v63 = "%{public}s called with null shoes, backtrace limit exceeded";
            goto LABEL_146;
          }
          v75 = (char *)__nw_create_backtrace_string();
          v61 = __nwlog_obj();
          v62 = v102;
          v76 = os_log_type_enabled(v61, (os_log_type_t)v102);
          if (v75)
          {
            if (v76)
            {
              *(_DWORD *)buf = 136446466;
              v91 = "nw_protocol_shoes_send_request";
              v92 = 2082;
              v93 = v75;
              _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v75);
            goto LABEL_147;
          }
          if (v76)
          {
            *(_DWORD *)buf = 136446210;
            v91 = "nw_protocol_shoes_send_request";
            v63 = "%{public}s called with null shoes, no backtrace";
LABEL_146:
            _os_log_impl(&dword_182FBE000, v61, v62, v63, buf, 0xCu);
          }
        }
LABEL_147:
        if (v60)
          free(v60);
        goto LABEL_73;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        v91 = "nw_protocol_shoes_connected";
        v92 = 2082;
        v93 = handle + 151;
        _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s start waiting for TFO", buf, 0x16u);
      }
      handle[150] = 2;
    }
    ((void (*)(nw_protocol *, nw_protocol *))a1->default_input_handler->callbacks->connected)(a1->default_input_handler, a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v91 = "nw_protocol_shoes_connected";
  v52 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v102) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v52, &v102, &type))
    goto LABEL_106;
  if (v102 == 17)
  {
    v53 = __nwlog_obj();
    v54 = v102;
    if (!os_log_type_enabled(v53, (os_log_type_t)v102))
      goto LABEL_106;
    *(_DWORD *)buf = 136446210;
    v91 = "nw_protocol_shoes_connected";
    v55 = "%{public}s called with null shoes";
    goto LABEL_105;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    v53 = __nwlog_obj();
    v54 = v102;
    if (!os_log_type_enabled(v53, (os_log_type_t)v102))
      goto LABEL_106;
    *(_DWORD *)buf = 136446210;
    v91 = "nw_protocol_shoes_connected";
    v55 = "%{public}s called with null shoes, backtrace limit exceeded";
    goto LABEL_105;
  }
  v58 = (char *)__nw_create_backtrace_string();
  v53 = __nwlog_obj();
  v54 = v102;
  v59 = os_log_type_enabled(v53, (os_log_type_t)v102);
  if (!v58)
  {
    if (!v59)
      goto LABEL_106;
    *(_DWORD *)buf = 136446210;
    v91 = "nw_protocol_shoes_connected";
    v55 = "%{public}s called with null shoes, no backtrace";
    goto LABEL_105;
  }
  if (v59)
  {
    *(_DWORD *)buf = 136446466;
    v91 = "nw_protocol_shoes_connected";
    v92 = 2082;
    v93 = v58;
    _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v58);
  if (v52)
    goto LABEL_107;
}

void sub_18332FAAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18332FAD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_shoes_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  _BYTE *handle;
  char v6;
  NSObject *v7;
  _BOOL4 v8;
  nw_protocol *default_input_handler;
  void (*error)(void);
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  char *v17;
  _BOOL4 v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_shoes_error";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v11, &type, &v19))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_shoes_error";
      v14 = "%{public}s called with null protocol";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_shoes_error";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_40:
        if (!v11)
          return;
LABEL_41:
        free(v11);
        return;
      }
      if (!v16)
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_shoes_error";
      v14 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_shoes_error";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_39:
    _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
    goto LABEL_40;
  }
  handle = a1->handle;
  if (handle)
  {
    v6 = handle[235];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    if ((v6 & 0x10) != 0)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446722;
        v22 = "nw_protocol_shoes_error";
        v23 = 2082;
        v24 = handle + 151;
        v25 = 1024;
        v26 = a3;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_INFO, "%{public}s %{public}s not sending error %d", buf, 0x1Cu);
      }
    }
    else
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446722;
        v22 = "nw_protocol_shoes_error";
        v23 = 2082;
        v24 = handle + 151;
        v25 = 1024;
        v26 = a3;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_INFO, "%{public}s %{public}s sending error %d", buf, 0x1Cu);
      }
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        error = (void (*)(void))default_input_handler->callbacks->error;
        if (error)
          error();
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_shoes_error";
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v11, &type, &v19))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_shoes_error";
    v14 = "%{public}s called with null shoes";
    goto LABEL_39;
  }
  if (!v19)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_shoes_error";
    v14 = "%{public}s called with null shoes, backtrace limit exceeded";
    goto LABEL_39;
  }
  v17 = (char *)__nw_create_backtrace_string();
  v12 = __nwlog_obj();
  v13 = type;
  v18 = os_log_type_enabled(v12, type);
  if (!v17)
  {
    if (!v18)
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_shoes_error";
    v14 = "%{public}s called with null shoes, no backtrace";
    goto LABEL_39;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_shoes_error";
    v23 = 2082;
    v24 = v17;
    _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v17);
  if (v11)
    goto LABEL_41;
}

void *nw_protocol_shoes_get_parameters(nw_protocol *a1)
{
  _QWORD *handle;
  nw_protocol *default_input_handler;
  void *v3;
  void *v4;
  NSObject *v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  const char *v13;
  _BOOL4 v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_shoes_get_parameters";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &type, &v16))
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_51;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_shoes_get_parameters";
      v10 = "%{public}s called with null protocol";
LABEL_50:
      _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
      goto LABEL_51;
    }
    if (!v16)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_parameters";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_parameters";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (!v12)
      goto LABEL_37;
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_shoes_get_parameters";
    v20 = 2082;
    v21 = backtrace_string;
    v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_36:
    _os_log_impl(&dword_182FBE000, v8, v9, v13, buf, 0x16u);
    goto LABEL_37;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_shoes_get_parameters";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &type, &v16))
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_51;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_shoes_get_parameters";
      v10 = "%{public}s called with null shoes";
      goto LABEL_50;
    }
    if (!v16)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_parameters";
        v10 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_parameters";
        v10 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (!v14)
      goto LABEL_37;
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_shoes_get_parameters";
    v20 = 2082;
    v21 = backtrace_string;
    v13 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
    goto LABEL_36;
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    v3 = (void *)handle[9];
    if (!v3)
    {
      v4 = (void *)((uint64_t (*)(void))default_input_handler->callbacks->get_parameters)();
      v3 = v4;
      if ((*((_BYTE *)handle + 235) & 1) != 0)
      {
        if (!nw_parameters_get_tfo(v4))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v5 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_protocol_shoes_get_parameters";
            v20 = 2082;
            v21 = (char *)handle + 151;
            _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s SHOES enabling TFO on parameters since we are using TLS", buf, 0x16u);
          }
          nw_parameters_set_tfo(v3, 1);
        }
        nw_parameters_set_fast_open_force_enable(v3, 1);
      }
    }
    return v3;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_shoes_get_parameters";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v7, &type, &v16))
    goto LABEL_51;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_parameters";
        v10 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v15 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_parameters";
        v10 = "%{public}s called with null protocol->default_input_handler, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_shoes_get_parameters";
      v20 = 2082;
      v21 = backtrace_string;
      v13 = "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
LABEL_37:
    free(backtrace_string);
    goto LABEL_51;
  }
  v8 = __nwlog_obj();
  v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_shoes_get_parameters";
    v10 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_50;
  }
LABEL_51:
  if (v7)
    free(v7);
  return 0;
}

void *nw_protocol_shoes_get_path(nw_protocol *a1)
{
  _BYTE *handle;
  nw_protocol *default_input_handler;
  void *v3;
  id v4;
  void *v5;
  NSObject *v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_shoes_get_path";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v8, &type, &v17))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_shoes_get_path";
      v11 = "%{public}s called with null protocol";
LABEL_51:
      _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
      goto LABEL_52;
    }
    if (!v17)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_get_path";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_get_path";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v13)
      goto LABEL_38;
    *(_DWORD *)buf = 136446466;
    v20 = "nw_protocol_shoes_get_path";
    v21 = 2082;
    v22 = backtrace_string;
    v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_37:
    _os_log_impl(&dword_182FBE000, v9, v10, v14, buf, 0x16u);
    goto LABEL_38;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_shoes_get_path";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v8, &type, &v17))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_shoes_get_path";
      v11 = "%{public}s called with null shoes";
      goto LABEL_51;
    }
    if (!v17)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_get_path";
        v11 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_get_path";
        v11 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v15)
      goto LABEL_38;
    *(_DWORD *)buf = 136446466;
    v20 = "nw_protocol_shoes_get_path";
    v21 = 2082;
    v22 = backtrace_string;
    v14 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
    goto LABEL_37;
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    v3 = (void *)((uint64_t (*)(void))default_input_handler->callbacks->get_path)();
    v4 = nw_path_copy_parameters(v3);
    v5 = v4;
    if ((handle[235] & 1) != 0)
    {
      if (!nw_parameters_get_tfo(v4))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_protocol_shoes_get_path";
          v21 = 2082;
          v22 = handle + 151;
          _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s SHOES enabling TFO on path parameters since we are using TLS", buf, 0x16u);
        }
        nw_parameters_set_tfo(v5, 1);
      }
      nw_parameters_set_fast_open_force_enable(v5, 1);
    }
    if (v5)
      os_release(v5);
    return v3;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_shoes_get_path";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v8, &type, &v17))
    goto LABEL_52;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_get_path";
        v11 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v16 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_get_path";
        v11 = "%{public}s called with null protocol->default_input_handler, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_shoes_get_path";
      v21 = 2082;
      v22 = backtrace_string;
      v14 = "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s";
      goto LABEL_37;
    }
LABEL_38:
    free(backtrace_string);
    goto LABEL_52;
  }
  v9 = __nwlog_obj();
  v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_shoes_get_path";
    v11 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_51;
  }
LABEL_52:
  if (v8)
    free(v8);
  return 0;
}

uint64_t nw_protocol_shoes_copy_info(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *backtrace_string;
  _BOOL4 v14;
  const char *v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_shoes_copy_info";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_copy_info";
        v12 = "%{public}s called with null protocol";
LABEL_40:
        _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
      }
LABEL_41:
      if (v9)
        free(v9);
      return 0;
    }
    if (!v17)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_copy_info";
        v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v14 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_copy_info";
        v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_shoes_copy_info";
      v21 = 2082;
      v22 = backtrace_string;
      v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_30:
      _os_log_impl(&dword_182FBE000, v10, v11, v15, buf, 0x16u);
    }
LABEL_31:
    free(backtrace_string);
    goto LABEL_41;
  }
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_shoes_copy_info";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_copy_info";
        v12 = "%{public}s called with null shoes";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    if (!v17)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_copy_info";
        v12 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_shoes_copy_info";
        v12 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_shoes_copy_info";
      v21 = 2082;
      v22 = backtrace_string;
      v15 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
    goto LABEL_31;
  }
  v4 = *(_QWORD *)(a1 + 32);
  if (v4 && (v5 = *(_QWORD *)(v4 + 24)) != 0 && *(_QWORD *)(v5 + 224))
  {
    v6 = nw_protocol_copy_info(v4, a2);
    if (a2 != 255)
      return v6;
  }
  else
  {
    v6 = 0;
    if (a2 != 255)
      return v6;
  }
  v7 = *(void **)(v2 + 88);
  if (v7)
  {
    if (v6 || (v6 = nw_array_create(), (v7 = *(void **)(v2 + 88)) != 0))
      nw_array_append(v6, v7);
  }
  return v6;
}

uint64_t nw_protocol_shoes_get_remote_endpoint(nw_protocol *a1)
{
  _QWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
      return handle[13];
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_shoes_get_remote_endpoint";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_shoes_get_remote_endpoint";
        v6 = "%{public}s called with null shoes";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_shoes_get_remote_endpoint";
        v6 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_shoes_get_remote_endpoint";
        v6 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_shoes_get_remote_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_shoes_get_remote_endpoint";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_shoes_get_remote_endpoint";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_shoes_get_remote_endpoint";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_shoes_get_remote_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_shoes_get_remote_endpoint";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_protocol_shoes_get_local_endpoint(nw_protocol *a1)
{
  _BYTE *handle;
  char v3;
  nw_protocol *output_handler;
  uint64_t (*get_output_local_endpoint)(void);
  uint64_t result;
  uint64_t (*v7)(void);
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_shoes_get_local_endpoint";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_local_endpoint";
        v11 = "%{public}s called with null protocol";
LABEL_46:
        _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
      }
LABEL_47:
      if (v8)
        free(v8);
      return 0;
    }
    if (!v16)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_local_endpoint";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_local_endpoint";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_shoes_get_local_endpoint";
      v20 = 2082;
      v21 = backtrace_string;
      v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_36:
      _os_log_impl(&dword_182FBE000, v9, v10, v14, buf, 0x16u);
    }
LABEL_37:
    free(backtrace_string);
    goto LABEL_47;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_shoes_get_local_endpoint";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_local_endpoint";
        v11 = "%{public}s called with null shoes";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    if (!v16)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_local_endpoint";
        v11 = "%{public}s called with null shoes, backtrace limit exceeded";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_shoes_get_local_endpoint";
        v11 = "%{public}s called with null shoes, no backtrace";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_shoes_get_local_endpoint";
      v20 = 2082;
      v21 = backtrace_string;
      v14 = "%{public}s called with null shoes, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  v3 = handle[235];
  if ((v3 & 0x20) == 0)
  {
    handle[235] = v3 | 0x20;
    if (*((_QWORD *)handle + 9))
    {
      output_handler = a1->output_handler;
      if (!output_handler
        || (get_output_local_endpoint = (uint64_t (*)(void))output_handler->callbacks->get_output_local_endpoint) == 0
        || (result = get_output_local_endpoint()) == 0)
      {
        result = (uint64_t)a1->default_input_handler;
        if (result)
        {
          v7 = *(uint64_t (**)(void))(*(_QWORD *)(result + 24) + 128);
          if (v7)
            result = v7();
          else
            result = 0;
        }
      }
      goto LABEL_15;
    }
  }
  result = (uint64_t)a1->default_input_handler;
  if (!result)
  {
LABEL_14:
    if ((v3 & 0x20) != 0)
      return result;
    goto LABEL_15;
  }
  if (*(_QWORD *)(*(_QWORD *)(result + 24) + 128))
  {
    result = nw_protocol_get_local_endpoint(result);
    goto LABEL_14;
  }
  result = 0;
  if ((v3 & 0x20) == 0)
LABEL_15:
    handle[235] &= ~0x20u;
  return result;
}

uint64_t nw_protocol_shoes_send_request_inner(nw_protocol *a1)
{
  _BYTE *handle;
  uint64_t result;
  unsigned __int8 *v4;
  unsigned int v5;
  char *v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t *v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  NSObject *v29;
  int v30;
  NSObject *v31;
  nw_protocol *output_handler;
  uint64_t (*get_output_local_endpoint)(void);
  nw_protocol *default_input_handler;
  uint64_t (*get_local_endpoint)(void);
  int v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  char *backtrace_string;
  _BOOL4 v46;
  char *v47;
  _BOOL4 v48;
  char *v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t *v54;
  _BYTE v55[24];
  __int128 v56;
  unsigned int v57;
  uint8_t v58[4];
  const char *v59;
  __int16 v60;
  char *v61;
  __int16 v62;
  int v63;
  _BYTE buf[24];
  int v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)v55 = 136446210;
    *(_QWORD *)&v55[4] = "nw_protocol_shoes_send_request_inner";
    v37 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    v58[0] = 0;
    if (__nwlog_fault(v37, buf, v58))
    {
      if (buf[0] == 17)
      {
        v38 = __nwlog_obj();
        v39 = buf[0];
        if (os_log_type_enabled(v38, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v55 = 136446210;
          *(_QWORD *)&v55[4] = "nw_protocol_shoes_send_request_inner";
          v40 = "%{public}s called with null shoes";
LABEL_76:
          _os_log_impl(&dword_182FBE000, v38, v39, v40, v55, 0xCu);
        }
      }
      else if (v58[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v38 = __nwlog_obj();
        v39 = buf[0];
        v46 = os_log_type_enabled(v38, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v46)
          {
            *(_DWORD *)v55 = 136446466;
            *(_QWORD *)&v55[4] = "nw_protocol_shoes_send_request_inner";
            *(_WORD *)&v55[12] = 2082;
            *(_QWORD *)&v55[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s called with null shoes, dumping backtrace:%{public}s", v55, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_77;
        }
        if (v46)
        {
          *(_DWORD *)v55 = 136446210;
          *(_QWORD *)&v55[4] = "nw_protocol_shoes_send_request_inner";
          v40 = "%{public}s called with null shoes, no backtrace";
          goto LABEL_76;
        }
      }
      else
      {
        v38 = __nwlog_obj();
        v39 = buf[0];
        if (os_log_type_enabled(v38, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v55 = 136446210;
          *(_QWORD *)&v55[4] = "nw_protocol_shoes_send_request_inner";
          v40 = "%{public}s called with null shoes, backtrace limit exceeded";
          goto LABEL_76;
        }
      }
    }
LABEL_77:
    if (v37)
      free(v37);
    return 0;
  }
  result = nw_shoes_create_request((uint64_t)a1->handle);
  if (!result)
    return result;
  v4 = (unsigned __int8 *)result;
  v5 = bswap32(*(unsigned __int16 *)result) >> 16;
  v6 = (char *)a1->handle;
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_shoes_send";
    v41 = (char *)_os_log_send_and_compose_impl();
    v58[0] = 16;
    LOBYTE(v53) = 0;
    if (!__nwlog_fault(v41, v58, &v53))
      goto LABEL_85;
    if (v58[0] == 17)
    {
      v42 = __nwlog_obj();
      v43 = v58[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v58[0]))
        goto LABEL_85;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_shoes_send";
      v44 = "%{public}s called with null shoes";
    }
    else if ((_BYTE)v53)
    {
      v47 = (char *)__nw_create_backtrace_string();
      v42 = __nwlog_obj();
      v43 = v58[0];
      v48 = os_log_type_enabled(v42, (os_log_type_t)v58[0]);
      if (v47)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_shoes_send";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v47;
          _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s called with null shoes, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v47);
        goto LABEL_85;
      }
      if (!v48)
      {
LABEL_85:
        if (v41)
          free(v41);
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_shoes_send";
      v44 = "%{public}s called with null shoes, no backtrace";
    }
    else
    {
      v42 = __nwlog_obj();
      v43 = v58[0];
      if (!os_log_type_enabled(v42, (os_log_type_t)v58[0]))
        goto LABEL_85;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_shoes_send";
      v44 = "%{public}s called with null shoes, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v42, v43, v44, buf, 0xCu);
    goto LABEL_85;
  }
  v7 = v5 + 2;
  v53 = 0;
  v54 = &v53;
  v51 = 0;
  v52 = &v51;
  v8 = ((uint64_t (*)(void))a1->output_handler->callbacks->get_output_frames)();
  v9 = v8;
  v10 = v53;
  if (!v53 || !v8)
  {
    if (v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_shoes_send";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v6 + 151;
        *(_WORD *)&buf[22] = 1024;
        v65 = v9;
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Output handler reported %u frames to write, but array is empty", buf, 0x1Cu);
      }
    }
LABEL_32:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      v24 = v4[2];
      *(_DWORD *)v55 = 136446978;
      *(_QWORD *)&v55[4] = "nw_protocol_shoes_send_request_inner";
      *(_WORD *)&v55[12] = 2082;
      *(_QWORD *)&v55[14] = handle + 151;
      *(_WORD *)&v55[22] = 1024;
      LODWORD(v56) = v24;
      WORD2(v56) = 1024;
      *(_DWORD *)((char *)&v56 + 6) = v5;
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Failed to send shoes request (type %u inner length %u)", v55, 0x22u);
      return 0;
    }
    return result;
  }
  v49 = v6;
  v50 = v5;
  v11 = v4;
  while (1)
  {
    v12 = *(_QWORD *)(v10 + 32);
    if (v12 || *(_QWORD *)(v10 + 40))
    {
      v13 = *(_QWORD *)(v10 + 112);
      if (!v13)
        goto LABEL_17;
    }
    else
    {
      v12 = 0;
      v13 = *(_QWORD *)(v10 + 112);
      if (!v13)
        goto LABEL_17;
    }
    if ((*(_WORD *)(v10 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v10, *(_QWORD *)(v10 + 88)))
    {
      LODWORD(v13) = 0;
LABEL_17:
      v15 = 0;
      goto LABEL_18;
    }
    LODWORD(v13) = *(_DWORD *)(v10 + 52);
    v14 = *(unsigned int *)(v10 + 56);
    if ((_DWORD)v13)
      LODWORD(v13) = v13 - (v14 + *(_DWORD *)(v10 + 60));
    v15 = (void *)(*(_QWORD *)(v10 + 112) + v14);
LABEL_18:
    v16 = v13 >= v7 ? v7 : v13;
    memcpy(v15, v11, v16);
    if (!nw_frame_claim(v10, v17, v16, 0))
      break;
    nw_frame_collapse(v10);
    nw_frame_unclaim(v10, v18, v16, 0);
    v19 = *(_QWORD *)(v10 + 32);
    v20 = *(_QWORD **)(v10 + 40);
    if (v19)
    {
      *(_QWORD *)(v19 + 40) = v20;
      v20 = *(_QWORD **)(v10 + 40);
    }
    else
    {
      v54 = *(uint64_t **)(v10 + 40);
    }
    *v20 = v19;
    v21 = v52;
    *(_QWORD *)(v10 + 32) = 0;
    *(_QWORD *)(v10 + 40) = v21;
    *v21 = v10;
    v52 = (uint64_t *)(v10 + 32);
    if (v12)
    {
      v11 += v16;
      v10 = v12;
      v7 -= v16;
      if (v7)
        continue;
    }
    goto LABEL_36;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_shoes_send";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v49 + 151;
    *(_WORD *)&buf[22] = 1024;
    v65 = v16;
    _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Claiming frame with %u bytes failed", buf, 0x1Cu);
  }
LABEL_36:
  ((void (*)(void))a1->output_handler->callbacks->finalize_output_frames)();
  v26 = v53;
  if (v53)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v65 = 0;
    *(_QWORD *)&buf[16] = 0x2000000000;
    *(_QWORD *)v55 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v55[8] = 0x40000000;
    *(_QWORD *)&v55[16] = ___ZL22nw_protocol_shoes_sendP11nw_protocolPhj_block_invoke;
    *(_QWORD *)&v56 = &unk_1E1499E90;
    *((_QWORD *)&v56 + 1) = buf;
    do
    {
      if (!v26)
        break;
      v27 = *(_QWORD *)(v26 + 32);
      v28 = (*(uint64_t (**)(_BYTE *))&v55[16])(v55);
      v26 = v27;
    }
    while ((v28 & 1) != 0);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v30 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
      *(_DWORD *)v58 = 136446722;
      v59 = "nw_protocol_shoes_send";
      v60 = 2082;
      v61 = v49 + 151;
      v62 = 1024;
      v63 = v30;
      _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Failed to use %u frames, marking as failed", v58, 0x1Cu);
    }
    _Block_object_dispose(buf, 8);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v31 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    output_handler = a1->output_handler;
    if (!output_handler
      || (get_output_local_endpoint = (uint64_t (*)(void))output_handler->callbacks->get_output_local_endpoint) == 0
      || (default_input_handler = (nw_protocol *)get_output_local_endpoint()) == 0)
    {
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        get_local_endpoint = (uint64_t (*)(void))default_input_handler->callbacks->get_local_endpoint;
        if (get_local_endpoint)
          default_input_handler = (nw_protocol *)get_local_endpoint();
        else
          default_input_handler = 0;
      }
    }
    v36 = v4[2];
    *(_DWORD *)v55 = 136447234;
    *(_QWORD *)&v55[4] = "nw_protocol_shoes_send_request_inner";
    *(_WORD *)&v55[12] = 2082;
    *(_QWORD *)&v55[14] = handle + 151;
    *(_WORD *)&v55[22] = 2114;
    *(_QWORD *)&v56 = default_input_handler;
    WORD4(v56) = 1024;
    *(_DWORD *)((char *)&v56 + 10) = v36;
    HIWORD(v56) = 1024;
    v57 = v50;
    _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Sent shoes request: local address %{public}@ type %u inner length %u no TFO", v55, 0x2Cu);
  }
  handle[150] = 5;
  free(v4);
  return 1;
}

BOOL nw_shoes_create_request(uint64_t a1)
{
  nw_endpoint_t v2;
  void *v3;
  NSObject *v4;
  nw_endpoint_type_t type;
  void *v6;
  _QWORD *v7;
  unsigned int v8;
  int v9;
  _QWORD *v10;
  _BOOL4 v11;
  _QWORD *v12;
  BOOL v13;
  NSObject *v14;
  BOOL v15;
  unsigned int v16;
  unsigned int v17;
  NSObject *v18;
  int v19;
  int next_hop_required_interface_type;
  int v21;
  unsigned int v22;
  void *v23;
  char v24;
  int v25;
  unsigned int v26;
  unsigned int alternate_port;
  const char *string_ptr;
  int v29;
  _QWORD *v30;
  BOOL v31;
  void *v32;
  _QWORD *v33;
  const char *v34;
  _WORD *v35;
  int v36;
  char v37;
  const char *hostname;
  const char *v39;
  size_t v40;
  size_t v41;
  NSObject *v42;
  const char *v43;
  NSObject *v44;
  char v45;
  const char *bonjour_service_name;
  const char *bonjour_service_type;
  const char *bonjour_service_domain;
  size_t v49;
  size_t v50;
  size_t v51;
  NSObject *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t bonjour_fullname;
  uint32_t v56;
  unsigned int v57;
  NSObject *v58;
  _BOOL8 result;
  NSObject *v60;
  void *v61;
  NSObject *v62;
  void *v63;
  const sockaddr *address;
  char v65;
  char v66;
  NSObject *v67;
  NSObject *v68;
  int v69;
  int v70;
  NSObject *v71;
  NSObject *v72;
  unsigned __int16 v73;
  NSObject *v74;
  NSObject *v75;
  __int16 v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  char *__s;
  int v86;
  nw_endpoint_t endpoint;
  char v88;
  char v89;
  nw_endpoint_type_t v90;
  unsigned int __src;
  _QWORD iterate_block[5];
  __int16 v93;
  int v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  char v98;
  uint8_t buf[4];
  const char *v100;
  __int16 v101;
  uint64_t v102;
  __int16 v103;
  const char *v104;
  __int16 v105;
  _BYTE v106[10];
  uint64_t v107;
  uint64_t v108;

  v108 = *MEMORY[0x1E0C80C00];
  v2 = (nw_endpoint_t)nw_endpoint_copy_proxy_original_endpoint(*(void **)(a1 + 96));
  if (!v2)
    v2 = *(nw_endpoint_t *)(a1 + 96);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = &unk_1ECD84000;
  v4 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446722;
    v100 = "nw_shoes_create_request";
    v101 = 2082;
    v102 = a1 + 151;
    v103 = 2112;
    v104 = (const char *)v2;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Sending request for endpoint %@", buf, 0x20u);
  }
  type = nw_endpoint_get_type(v2);
  v95 = 0;
  v96 = &v95;
  v97 = 0x2000000000;
  v98 = 0;
  v94 = 0;
  v93 = 0;
  v6 = (void *)(*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24) + 112))();
  v90 = type;
  if (!v6)
  {
    v22 = 0;
    v23 = *(void **)(a1 + 112);
    v24 = 1;
    v25 = 261;
    if (!v23)
    {
      __s = 0;
      v26 = 0;
      v86 = 0;
      alternate_port = 0;
      v88 = 1;
      v21 = 0;
      goto LABEL_53;
    }
    v21 = 0;
    v26 = 0;
    v86 = 0;
    alternate_port = 0;
    string_ptr = xpc_string_get_string_ptr(v23);
    if (string_ptr)
      goto LABEL_51;
    goto LABEL_43;
  }
  v7 = v6;
  v8 = *(_DWORD *)(v7[13] + 72);

  if (v8)
    v9 = 268;
  else
    v9 = 261;
  v10 = v7;
  v11 = (*(_WORD *)(v7[13] + 108) & 0x200) == 0;

  if (!v11)
  {
    v17 = 0;
    goto LABEL_25;
  }
  v12 = v10;
  v13 = (*(_WORD *)(v7[13] + 100) & 1) == 0;

  if (!v13)
    *((_BYTE *)v96 + 24) |= 0x80u;
  v14 = v12;
  v15 = (*(_WORD *)(v7[13] + 100) & 2) == 0;

  if (!v15)
    *((_BYTE *)v96 + 24) |= 0x10u;
  iterate_block[0] = MEMORY[0x1E0C809B0];
  iterate_block[1] = 0x40000000;
  iterate_block[2] = ___ZL23nw_shoes_create_requestP18_nw_protocol_shoes_block_invoke;
  iterate_block[3] = &unk_1E1499E48;
  iterate_block[4] = &v95;
  nw_parameters_iterate_prohibited_interface_types(v14, iterate_block);
  v16 = *(unsigned __int16 *)(a1 + 144);
  v17 = __rev16(v16);
  v93 = v17;
  if (v16)
    *((_BYTE *)v96 + 24) |= 6u;
  v18 = v14;
  v19 = *(_DWORD *)(v7[13] + 92);

  if (!v19)
    goto LABEL_25;
  next_hop_required_interface_type = nw_parameters_get_next_hop_required_interface_type(v18);
  if (next_hop_required_interface_type == 3)
  {
    v21 = 4;
    goto LABEL_31;
  }
  if (next_hop_required_interface_type == 2)
  {
    v21 = 2;
    goto LABEL_31;
  }
  if (next_hop_required_interface_type != 1)
  {
LABEL_25:
    v21 = 0;
    if (*((_BYTE *)v96 + 24))
      v25 = v9 + 4;
    else
      v25 = v9;
    goto LABEL_35;
  }
  v21 = 1;
LABEL_31:
  v94 = v21;
  if (*((_BYTE *)v96 + 24))
    v29 = v9 + 4;
  else
    v29 = v9;
  v25 = v29 + 7;
LABEL_35:
  v30 = v10;
  v31 = *(_DWORD *)(v7[13] + 103) == 0;

  if (v31)
  {
    alternate_port = 0;
    v86 = 0;
    v24 = 1;
    v26 = v8;
    v32 = *(void **)(a1 + 112);
    if (!v32)
      goto LABEL_46;
    goto LABEL_42;
  }
  if (nw_shoes_is_multipath_allowed(void)::onceToken[0] != -1)
    dispatch_once(nw_shoes_is_multipath_allowed(void)::onceToken, &__block_literal_global_44);
  v26 = v8;
  if (nw_shoes_is_multipath_allowed(void)::isAllowed != 1)
  {
    alternate_port = 0;
    v86 = 0;
    v24 = 1;
    v32 = *(void **)(a1 + 112);
    if (!v32)
      goto LABEL_46;
LABEL_42:
    v22 = v17;
    v3 = &unk_1ECD84000;
    type = v90;
    string_ptr = xpc_string_get_string_ptr(v32);
    if (string_ptr)
      goto LABEL_51;
    goto LABEL_43;
  }
  alternate_port = nw_endpoint_get_alternate_port(v2);
  v24 = 0;
  v25 += 6;
  v86 = 2;
  v32 = *(void **)(a1 + 112);
  if (v32)
    goto LABEL_42;
LABEL_46:
  v33 = v30;
  v34 = (const char *)v33[14];

  if (v34)
  {
    string_ptr = v34;
    v22 = v17;
    v3 = &unk_1ECD84000;
    v26 = v8;
    type = v90;
    goto LABEL_51;
  }
  v26 = v8;
  if (nw_utilities_get_self_bundle_id::onceToken != -1)
    dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_7);
  v22 = v17;
  type = v90;
  string_ptr = (const char *)nw_utilities_get_self_bundle_id::bundle_identifier_string;
  v3 = &unk_1ECD84000;
  if (nw_utilities_get_self_bundle_id::bundle_identifier_string)
  {
LABEL_51:
    __s = (char *)string_ptr;
    v88 = 0;
    v25 += strlen(string_ptr) + 3;
    if (!v22)
      goto LABEL_53;
    goto LABEL_52;
  }
LABEL_43:
  __s = 0;
  v88 = 1;
  if (v22)
LABEL_52:
    LOWORD(v25) = v25 + 5;
LABEL_53:
  if (!(_WORD)v25)
  {
    v81 = v21;
    v60 = __nwlog_obj();
    os_log_type_enabled(v60, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v100 = "strict_calloc";
    v61 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v61);
    if (result)
      goto LABEL_151;
    free(v61);
    v21 = v81;
  }
  v89 = v24;
  v35 = malloc_type_calloc(1uLL, (unsigned __int16)v25, 0xEAFB8F1AuLL);
  if (v35)
  {
    if (type != nw_endpoint_type_address)
      goto LABEL_56;
    goto LABEL_107;
  }
  v82 = v21;
  v62 = __nwlog_obj();
  os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v100 = "strict_calloc";
  v101 = 2048;
  v102 = 1;
  v103 = 2048;
  v104 = (const char *)(unsigned __int16)v25;
  v63 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v63);
  if (!result)
  {
    free(v63);
    v21 = v82;
    if (type != nw_endpoint_type_address)
    {
LABEL_56:
      if (type != nw_endpoint_type_bonjour_service)
      {
        if (type != nw_endpoint_type_host)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v52 = *((_QWORD *)v3 + 463);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v100 = "nw_shoes_create_request";
            v101 = 2082;
            v102 = a1 + 151;
            v103 = 1024;
            LODWORD(v104) = type;
            _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Invalid endpoint type %u", buf, 0x1Cu);
          }
          if (!v35)
          {
LABEL_98:
            if (!v2)
            {
LABEL_100:
              _Block_object_dispose(&v95, 8);
              return (BOOL)v35;
            }
LABEL_99:
            os_release(v2);
            goto LABEL_100;
          }
          goto LABEL_97;
        }
        v36 = v21;
        if ((*(_BYTE *)(a1 + 235) & 2) != 0)
          v37 = 4;
        else
          v37 = 1;
        *((_BYTE *)v35 + 2) = v37;
        hostname = nw_endpoint_get_hostname(v2);
        if (!hostname)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v58 = *((_QWORD *)v3 + 463);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v100 = "nw_shoes_create_request";
            v101 = 2082;
            v102 = a1 + 151;
            v43 = "%{public}s %{public}s hostname is NULL";
            v44 = v58;
            v56 = 22;
            goto LABEL_96;
          }
          goto LABEL_97;
        }
        v39 = hostname;
        v79 = alternate_port;
        v40 = strlen(hostname);
        v41 = v40;
        if (v40 >= 0x100)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v42 = *((_QWORD *)v3 + 463);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447234;
            v100 = "nw_shoes_create_request";
            v101 = 2082;
            v102 = a1 + 151;
            v103 = 2082;
            v104 = v39;
            v105 = 2048;
            *(_QWORD *)v106 = v41;
            *(_WORD *)&v106[8] = 2048;
            v107 = 255;
            v43 = "%{public}s %{public}s Hostname too long: \"%{public}s\" %zu > %zu";
            v44 = v42;
LABEL_82:
            v56 = 52;
LABEL_96:
            _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, v43, buf, v56);
            goto LABEL_97;
          }
          goto LABEL_97;
        }
        *((_BYTE *)v35 + 5) = v40;
        memcpy(v35 + 3, v39, v40);
        v57 = v41 + 4;
        v21 = v36;
        type = nw_endpoint_type_host;
        if (!v26)
          goto LABEL_121;
        goto LABEL_117;
      }
      v79 = alternate_port;
      if ((*(_BYTE *)(a1 + 235) & 2) != 0)
        v45 = 8;
      else
        v45 = 7;
      *((_BYTE *)v35 + 2) = v45;
      bonjour_service_name = nw_endpoint_get_bonjour_service_name(v2);
      bonjour_service_type = nw_endpoint_get_bonjour_service_type(v2);
      endpoint = v2;
      bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(v2);
      if (bonjour_service_name)
      {
        v49 = strlen(bonjour_service_name) + 1;
        v80 = v21;
        if (bonjour_service_type)
          goto LABEL_70;
      }
      else
      {
        v49 = 1;
        v80 = v21;
        if (bonjour_service_type)
        {
LABEL_70:
          v50 = strlen(bonjour_service_type) + 1;
          v77 = v26;
          v78 = v22;
          if (bonjour_service_domain)
          {
LABEL_71:
            v51 = strlen(bonjour_service_domain) + 1;
            goto LABEL_79;
          }
LABEL_78:
          v51 = 1;
LABEL_79:
          v53 = v50 + v49 + v51;
          if (v53 >= 0x100)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v54 = gLogObj;
            v2 = endpoint;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              bonjour_fullname = nw_endpoint_get_bonjour_fullname(endpoint);
              *(_DWORD *)buf = 136447234;
              v100 = "nw_shoes_create_request";
              v101 = 2082;
              v102 = a1 + 151;
              v103 = 2082;
              v104 = (const char *)bonjour_fullname;
              v105 = 2048;
              *(_QWORD *)v106 = v53;
              *(_WORD *)&v106[8] = 2048;
              v107 = 255;
              v43 = "%{public}s %{public}s Bonjour service too long: \"%{public}s\" %zu > %zu";
              v44 = v54;
              goto LABEL_82;
            }
LABEL_97:
            free(v35);
            v35 = 0;
            goto LABEL_98;
          }
          *((_BYTE *)v35 + 5) = v53;
          if (bonjour_service_name && v49)
            memcpy(v35 + 3, bonjour_service_name, v49);
          if (bonjour_service_type && v50)
            memcpy((char *)v35 + v49 + 6, bonjour_service_type, v50);
          if (bonjour_service_domain && v51)
            memcpy((char *)v35 + v49 + v50 + 6, bonjour_service_domain, v51);
          v57 = v53 + 4;
          v2 = endpoint;
          type = v90;
          v3 = &unk_1ECD84000;
          v26 = v77;
          v22 = v78;
          v21 = v80;
          if (!v77)
          {
LABEL_121:
            if (*((_BYTE *)v96 + 24) && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              v84 = v21;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v68 = *((_QWORD *)v3 + 463);
              if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
              {
                v69 = *((unsigned __int8 *)v96 + 24);
                *(_DWORD *)buf = 136446978;
                v100 = "nw_shoes_create_request";
                v101 = 2082;
                v102 = a1 + 151;
                v103 = 2082;
                v104 = "flags";
                v105 = 1024;
                *(_DWORD *)v106 = v69;
                _os_log_impl(&dword_182FBE000, v68, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s sending tlv: %{public}s(%#x)", buf, 0x26u);
              }
              v57 += nw_shoes_add_tlv((uint64_t)v35 + (unsigned __int16)(v57 + 2), (unsigned __int16)(v25 - (v57 + 2)), 2u, 1uLL, v96 + 3);
              v21 = v84;
            }
            if (v21 && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              v70 = v21;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v71 = *((_QWORD *)v3 + 463);
              if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                v100 = "nw_shoes_create_request";
                v101 = 2082;
                v102 = a1 + 151;
                v103 = 2082;
                v104 = "extended_flags";
                v105 = 1024;
                *(_DWORD *)v106 = v70;
                _os_log_impl(&dword_182FBE000, v71, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s sending tlv: %{public}s(%#x)", buf, 0x26u);
              }
              v57 += nw_shoes_add_tlv((uint64_t)v35 + (unsigned __int16)(v57 + 2), (unsigned __int16)(v25 - (v57 + 2)), 9u, 4uLL, &v94);
              type = v90;
            }
            if ((v88 & 1) == 0 && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v72 = *((_QWORD *)v3 + 463);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                v100 = "nw_shoes_create_request";
                v101 = 2082;
                v102 = a1 + 151;
                v103 = 2082;
                v104 = "bundle_id";
                v105 = 2080;
                *(_QWORD *)v106 = __s;
                _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s sending tlv: %{public}s(%s)", buf, 0x2Au);
              }
              v73 = strlen(__s);
              v57 += nw_shoes_add_tlv((uint64_t)v35 + (unsigned __int16)(v57 + 2), (unsigned __int16)(v25 - (v57 + 2)), 3u, v73, __s);
            }
            if ((v89 & 1) == 0)
            {
              LOBYTE(__src) = v86;
              *(_WORD *)((char *)&__src + 1) = v79;
              if ((unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v74 = *((_QWORD *)v3 + 463);
                if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136447234;
                  v100 = "nw_shoes_create_request";
                  v101 = 2082;
                  v102 = a1 + 151;
                  v103 = 2082;
                  v104 = "multipath";
                  v105 = 1024;
                  *(_DWORD *)v106 = v86;
                  *(_WORD *)&v106[4] = 1024;
                  *(_DWORD *)&v106[6] = __rev16(v79);
                  _os_log_impl(&dword_182FBE000, v74, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s sending tlv: %{public}s(%u/%u)", buf, 0x2Cu);
                }
                v57 += nw_shoes_add_tlv((uint64_t)v35 + (unsigned __int16)(v57 + 2), (unsigned __int16)(v25 - (v57 + 2)), 5u, 3uLL, &__src);
              }
            }
            if (v22 && (unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v75 = *((_QWORD *)v3 + 463);
              if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                v100 = "nw_shoes_create_request";
                v101 = 2082;
                v102 = a1 + 151;
                v103 = 2082;
                v104 = "udp_associate";
                v105 = 1024;
                *(_DWORD *)v106 = __rev16(v22);
                _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s sending tlv: %{public}s(%u)", buf, 0x26u);
              }
              v57 += nw_shoes_add_tlv((uint64_t)v35 + (unsigned __int16)(v57 + 2), (unsigned __int16)(v25 - (v57 + 2)), 6u, 2uLL, &v93);
            }
            *v35 = bswap32(v57) >> 16;
            if (type == nw_endpoint_type_bonjour_service)
              v76 = 0;
            else
              v76 = __rev16(nw_endpoint_get_port(v2));
            *(_WORD *)((char *)v35 + 3) = v76;
            if (!v2)
              goto LABEL_100;
            goto LABEL_99;
          }
LABEL_117:
          __src = bswap32(v26);
          if ((unsigned __int16)v25 > (unsigned __int16)(v57 + 2))
          {
            v83 = v21;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v67 = *((_QWORD *)v3 + 463);
            if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446978;
              v100 = "nw_shoes_create_request";
              v101 = 2082;
              v102 = a1 + 151;
              v103 = 2082;
              v104 = "traffic_class";
              v105 = 1024;
              *(_DWORD *)v106 = v26;
              _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s sending tlv: %{public}s(%u)", buf, 0x26u);
            }
            v57 += nw_shoes_add_tlv((uint64_t)v35 + (unsigned __int16)(v57 + 2), (unsigned __int16)(v25 - (v57 + 2)), 1u, 4uLL, &__src);
            v21 = v83;
          }
          goto LABEL_121;
        }
      }
      v50 = 1;
      v77 = v26;
      v78 = v22;
      if (bonjour_service_domain)
        goto LABEL_71;
      goto LABEL_78;
    }
LABEL_107:
    v79 = alternate_port;
    address = nw_endpoint_get_address(v2);
    if (address->sa_family == 30)
    {
      if ((*(_BYTE *)(a1 + 235) & 2) != 0)
        v65 = 5;
      else
        v65 = 2;
      *((_BYTE *)v35 + 2) = v65;
      *(sockaddr *)((char *)v35 + 5) = *(sockaddr *)&address->sa_data[6];
      v57 = 19;
      if (!v26)
        goto LABEL_121;
    }
    else
    {
      if ((*(_BYTE *)(a1 + 235) & 2) != 0)
        v66 = 6;
      else
        v66 = 3;
      *((_BYTE *)v35 + 2) = v66;
      *(_DWORD *)((char *)v35 + 5) = *(_DWORD *)&address->sa_data[2];
      v57 = 7;
      if (!v26)
        goto LABEL_121;
    }
    goto LABEL_117;
  }
LABEL_151:
  __break(1u);
  return result;
}

uint64_t ___ZL22nw_protocol_shoes_sendP11nw_protocolPhj_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_frame_finalize(a2);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return 1;
}

uint64_t ___ZL23nw_shoes_create_requestP18_nw_protocol_shoes_block_invoke(uint64_t a1, int a2)
{
  char v2;

  if (a2 == 1)
  {
    v2 = 32;
    goto LABEL_5;
  }
  if (a2 == 2)
  {
    v2 = 64;
LABEL_5:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) |= v2;
  }
  return 1;
}

void ___ZL29nw_shoes_is_multipath_allowedv_block_invoke()
{
  void *v0;
  void *v1;

  v0 = (void *)nw_utilities_copy_local_entitlement_value("com.apple.developer.networking.multipath_extended");
  if (v0)
  {
    v1 = v0;
    if (object_getClass(v0) == (Class)MEMORY[0x1E0C812D0] && xpc_BOOL_get_value(v1))
      nw_shoes_is_multipath_allowed(void)::isAllowed = 1;
    xpc_release(v1);
  }
}

BOOL nw_shoes_read_into_buffer(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  size_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t i;
  uint64_t v22;
  _QWORD *v23;
  _BOOL8 result;
  NSObject *v25;
  NSObject *log;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 120);
  if (!v4)
    return 0;
  v7 = 0;
  if (a2)
  {
    v8 = a2 + a4;
    while (1)
    {
      if (!v4)
        goto LABEL_44;
      v9 = *(_QWORD *)(v4 + 32);
      if (v9 || *(_QWORD *)(v4 + 40))
      {
        if (*(_QWORD *)(v4 + 112))
          goto LABEL_10;
      }
      else
      {
        v9 = 0;
        if (*(_QWORD *)(v4 + 112))
        {
LABEL_10:
          if ((*(_WORD *)(v4 + 204) & 0x100) == 0
            || !g_channel_check_validity
            || g_channel_check_validity(v4, *(_QWORD *)(v4 + 88)))
          {
            v10 = *(_DWORD *)(v4 + 52);
            if (v10)
            {
              v11 = *(unsigned int *)(v4 + 56);
              v12 = v10 - (v11 + *(_DWORD *)(v4 + 60));
              if (v12)
              {
                if (v12 >= a3 - v7)
                  v13 = a3 - v7;
                else
                  v13 = v12;
                memcpy((void *)(v8 + v7), (const void *)(*(_QWORD *)(v4 + 112) + v11), v13);
                *(_DWORD *)(a1 + 136) += v13;
                v7 += v13;
                nw_frame_claim(v4, v14, v13, 0);
              }
            }
          }
        }
      }
      v15 = *(_DWORD *)(v4 + 52);
      if (!v15 || v15 == *(_DWORD *)(v4 + 56) + *(_DWORD *)(v4 + 60))
        v4 = v9;
      if (v7 == a3)
        goto LABEL_43;
    }
  }
  while (v4)
  {
    v16 = *(_QWORD *)(v4 + 32);
    if (v16 || *(_QWORD *)(v4 + 40))
    {
      if (*(_QWORD *)(v4 + 112))
        goto LABEL_30;
    }
    else
    {
      v16 = 0;
      if (*(_QWORD *)(v4 + 112))
      {
LABEL_30:
        if ((*(_WORD *)(v4 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(v4, *(_QWORD *)(v4 + 88)))
        {
          v17 = *(_DWORD *)(v4 + 52);
          if (v17)
          {
            v18 = v17 - (*(_DWORD *)(v4 + 56) + *(_DWORD *)(v4 + 60));
            if (v18)
            {
              if (v18 >= a3 - v7)
                v19 = a3 - v7;
              else
                v19 = v18;
              *(_DWORD *)(a1 + 136) += v19;
              v7 += v19;
              nw_frame_claim(v4, a2, v19, 0);
            }
          }
        }
      }
    }
    v20 = *(_DWORD *)(v4 + 52);
    if (!v20 || v20 == *(_DWORD *)(v4 + 56) + *(_DWORD *)(v4 + 60))
      v4 = v16;
    if (v7 == a3)
    {
LABEL_43:
      v7 = a3;
      break;
    }
  }
LABEL_44:
  for (i = *(_QWORD *)(a1 + 120); v4 != i; i = *(_QWORD *)(a1 + 120))
  {
    if (gLogDatapath)
    {
      log = __nwlog_obj();
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v28 = "nw_shoes_read_into_buffer";
        v29 = 2082;
        v30 = a1 + 151;
        v31 = 2048;
        v32[0] = i;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Finished reading from frame %p", buf, 0x20u);
      }
    }
    v22 = *(_QWORD *)(i + 32);
    v23 = *(_QWORD **)(i + 40);
    if (v22)
    {
      *(_QWORD *)(v22 + 40) = v23;
      v23 = *(_QWORD **)(i + 40);
    }
    else
    {
      *(_QWORD *)(a1 + 128) = v23;
    }
    *v23 = v22;
    *(_QWORD *)(i + 32) = 0;
    *(_QWORD *)(i + 40) = 0;
    nw_frame_finalize(i);
  }
  if (v7 >= a3)
    return 1;
  if (!gLogDatapath)
    return 0;
  v25 = __nwlog_obj();
  result = os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_DWORD *)buf = 136446978;
    v28 = "nw_shoes_read_into_buffer";
    v29 = 2082;
    v30 = a1 + 151;
    v31 = 1024;
    LODWORD(v32[0]) = v7;
    WORD2(v32[0]) = 1024;
    *(_DWORD *)((char *)v32 + 6) = a3;
    _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Read incomplete (%u < %u)", buf, 0x22u);
    return 0;
  }
  return result;
}

void nw_shoes_read_reply_tlvs(uint64_t a1, unsigned __int8 *a2, unsigned int a3, char a4)
{
  NSObject *v8;
  _QWORD v9[5];
  char v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  unsigned int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2 && a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      v12 = "nw_shoes_read_reply_tlvs";
      v13 = 2082;
      v14 = a1 + 151;
      v15 = 1024;
      v16 = a3;
      _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s received shoes tlv(s) with total tlv buffer length %u", buf, 0x1Cu);
    }
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = ___ZL24nw_shoes_read_reply_tlvsP18_nw_protocol_shoesPhtb_block_invoke;
    v9[3] = &__block_descriptor_tmp_33;
    v9[4] = a1;
    v10 = a4;
    nw_shoes_tlv_parser(a2, a3, v9);
  }
}

void ___ZL24nw_shoes_read_reply_tlvsP18_nw_protocol_shoesPhtb_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  unint64_t v7;
  const char *v8;
  int v9;
  unsigned int v10;
  void *v11;
  _QWORD *v12;
  id v13;
  id v14;
  NSObject *v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  uint64_t v25;
  const char *v26;
  unsigned int v27;
  NSObject *v28;
  uint64_t v29;
  const char *v30;
  const char *effective_bundle_id;
  double v32;
  char v33;
  NSObject *v34;
  nw_endpoint_t v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  const char *v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  const char *v53;
  nw_endpoint_t address;
  NSObject *v55;
  uint64_t v56;
  const char *v57;
  const char *description;
  void *v59;
  id v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  const char *v65;
  void *v66;
  id *v67;
  id v68;
  _QWORD *v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  char *v73;
  NSObject *v74;
  os_log_type_t v75;
  const char *v76;
  char *backtrace_string;
  _BOOL4 v78;
  const char *v79;
  _BOOL4 v80;
  _BOOL4 v81;
  char *v82;
  _BOOL4 v83;
  char v84;
  os_log_type_t type;
  _BYTE buf[24];
  __int128 v87;
  uint8_t v88[4];
  const char *v89;
  __int16 v90;
  char *v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (v5)
      v6 = (const char *)(v5 + 151);
    else
      v6 = "";
    v7 = *a2;
    if (v7 > 9)
      v8 = "unknown";
    else
      v8 = off_1E1499EB0[v7];
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2082;
    *(_QWORD *)&v87 = v8;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s processing shoes tlv: %{public}s", buf, 0x20u);
  }
  v9 = *a2;
  if (v9 == 8)
  {
    v36 = *(unsigned __int16 *)(a2 + 1);
    v37 = __rev16(v36);
    v38 = a2[4];
    if (v38 == 2 && v36 != 4096)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        return;
      v40 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
      if (v40)
        v41 = (const char *)(v40 + 151);
      else
        v41 = "";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v41;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v87) = v37;
      WORD2(v87) = 2048;
      *(_QWORD *)((char *)&v87 + 6) = 16;
      v42 = "%{public}s %{public}s Invalid TLV length (%u != %zu)";
      goto LABEL_86;
    }
    if (v38 == 30 && v36 != 7168)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        return;
      v48 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
      if (v48)
        v49 = (const char *)(v48 + 151);
      else
        v49 = "";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v49;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v87) = v37;
      WORD2(v87) = 2048;
      *(_QWORD *)((char *)&v87 + 6) = 28;
      v42 = "%{public}s %{public}s Invalid TLV length (%u != %zu)";
      goto LABEL_86;
    }
    address = nw_endpoint_create_address((const sockaddr *)(a2 + 3));
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v55 = gLogObj;
    if (address)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        v56 = *(_QWORD *)(a1 + 32);
        if (v56)
          v57 = (const char *)(v56 + 151);
        else
          v57 = "";
        description = nw_endpoint_get_description(address);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v57;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&v87 = description;
        _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s detected resolved_endpoint endpoint for outer connection: %s", buf, 0x20u);
      }
      v59 = *(void **)(*(_QWORD *)(a1 + 32) + 88);
      if (!v59)
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) = nw_shoes_create_metadata();
        v59 = *(void **)(*(_QWORD *)(a1 + 32) + 88);
        if (!v59)
        {
          __nwlog_obj();
          *(_DWORD *)v88 = 136446210;
          v89 = "nw_shoes_metadata_add_resolved_endpoint";
          v73 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v84 = 0;
          if (!__nwlog_fault(v73, &type, &v84))
            goto LABEL_178;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v74 = __nwlog_obj();
            v75 = type;
            if (!os_log_type_enabled(v74, type))
              goto LABEL_178;
            *(_DWORD *)v88 = 136446210;
            v89 = "nw_shoes_metadata_add_resolved_endpoint";
            v76 = "%{public}s called with null metadata";
            goto LABEL_177;
          }
          if (!v84)
          {
            v74 = __nwlog_obj();
            v75 = type;
            if (!os_log_type_enabled(v74, type))
              goto LABEL_178;
            *(_DWORD *)v88 = 136446210;
            v89 = "nw_shoes_metadata_add_resolved_endpoint";
            v76 = "%{public}s called with null metadata, backtrace limit exceeded";
            goto LABEL_177;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          v74 = __nwlog_obj();
          v75 = type;
          v81 = os_log_type_enabled(v74, type);
          if (!backtrace_string)
          {
            if (!v81)
              goto LABEL_178;
            *(_DWORD *)v88 = 136446210;
            v89 = "nw_shoes_metadata_add_resolved_endpoint";
            v76 = "%{public}s called with null metadata, no backtrace";
            goto LABEL_177;
          }
          if (v81)
          {
            *(_DWORD *)v88 = 136446466;
            v89 = "nw_shoes_metadata_add_resolved_endpoint";
            v90 = 2082;
            v91 = backtrace_string;
            v79 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
            goto LABEL_153;
          }
          goto LABEL_154;
        }
      }
      v60 = v59;
      v61 = *((id *)v60 + 1);

      if (nw_protocol_shoes_get_definition(void)::onceToken != -1)
        dispatch_once(&nw_protocol_shoes_get_definition(void)::onceToken, &__block_literal_global_30);
      if (nw_protocol_definition_is_equal_unsafe((uint64_t)v61, nw_protocol_shoes_get_definition(void)::proxy_definition))
      {
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL39nw_shoes_metadata_add_resolved_endpointP20nw_protocol_metadataP11nw_endpoint_block_invoke;
        *(_QWORD *)&v87 = &__block_descriptor_tmp_40;
        *((_QWORD *)&v87 + 1) = address;
        v62 = *((_QWORD *)v60 + 4);
        if (v62)
          ___ZL39nw_shoes_metadata_add_resolved_endpointP20nw_protocol_metadataP11nw_endpoint_block_invoke((uint64_t)buf, v62);
        goto LABEL_113;
      }
      __nwlog_obj();
      *(_DWORD *)v88 = 136446210;
      v89 = "nw_shoes_metadata_add_resolved_endpoint";
      v73 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v84 = 0;
      if (__nwlog_fault(v73, &type, &v84))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v74 = __nwlog_obj();
          v75 = type;
          if (!os_log_type_enabled(v74, type))
            goto LABEL_178;
          *(_DWORD *)v88 = 136446210;
          v89 = "nw_shoes_metadata_add_resolved_endpoint";
          v76 = "%{public}s metadata must be shoes";
LABEL_177:
          _os_log_impl(&dword_182FBE000, v74, v75, v76, v88, 0xCu);
          goto LABEL_178;
        }
        if (!v84)
        {
          v74 = __nwlog_obj();
          v75 = type;
          if (!os_log_type_enabled(v74, type))
            goto LABEL_178;
          *(_DWORD *)v88 = 136446210;
          v89 = "nw_shoes_metadata_add_resolved_endpoint";
          v76 = "%{public}s metadata must be shoes, backtrace limit exceeded";
          goto LABEL_177;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v74 = __nwlog_obj();
        v75 = type;
        v78 = os_log_type_enabled(v74, type);
        if (!backtrace_string)
        {
          if (!v78)
            goto LABEL_178;
          *(_DWORD *)v88 = 136446210;
          v89 = "nw_shoes_metadata_add_resolved_endpoint";
          v76 = "%{public}s metadata must be shoes, no backtrace";
          goto LABEL_177;
        }
        if (v78)
        {
          *(_DWORD *)v88 = 136446466;
          v89 = "nw_shoes_metadata_add_resolved_endpoint";
          v90 = 2082;
          v91 = backtrace_string;
          v79 = "%{public}s metadata must be shoes, dumping backtrace:%{public}s";
LABEL_153:
          _os_log_impl(&dword_182FBE000, v74, v75, v79, v88, 0x16u);
        }
LABEL_154:
        free(backtrace_string);
        if (!v73)
          goto LABEL_113;
        goto LABEL_179;
      }
LABEL_178:
      if (!v73)
      {
LABEL_113:
        v35 = address;
LABEL_114:
        os_release(v35);
        return;
      }
LABEL_179:
      free(v73);
      goto LABEL_113;
    }
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return;
    v70 = *(_QWORD *)(a1 + 32);
    if (v70)
      v71 = (const char *)(v70 + 151);
    else
      v71 = "";
LABEL_124:
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v71;
    _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_ERROR, "%{public}s %{public}s failed to create endpoint", buf, 0x16u);
    return;
  }
  if (v9 == 7)
  {
    v43 = *(unsigned __int16 *)(a2 + 1);
    v44 = __rev16(v43);
    v45 = a2[4];
    if (v45 == 2 && v43 != 4096)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        return;
      v46 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
      if (v46)
        v47 = (const char *)(v46 + 151);
      else
        v47 = "";
LABEL_67:
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v47;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v87) = v44;
      WORD2(v87) = 2048;
      *(_QWORD *)((char *)&v87 + 6) = 8;
      v42 = "%{public}s %{public}s Invalid TLV length (%u != %zu)";
      goto LABEL_86;
    }
    if (v45 == 30 && v43 != 7168)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        return;
      v50 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
      if (v50)
        v47 = (const char *)(v50 + 151);
      else
        v47 = "";
      goto LABEL_67;
    }
    address = nw_endpoint_create_address((const sockaddr *)(a2 + 3));
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v55 = gLogObj;
    if (address)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        v63 = *(_QWORD *)(a1 + 32);
        if (v63)
          v64 = (const char *)(v63 + 151);
        else
          v64 = "";
        v65 = nw_endpoint_get_description(address);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v64;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&v87 = v65;
        _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s detected remote endpoint from outer connection: %s", buf, 0x20u);
      }
      v66 = *(void **)(*(_QWORD *)(a1 + 32) + 88);
      if (v66
        || (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) = nw_shoes_create_metadata(),
            (v66 = *(void **)(*(_QWORD *)(a1 + 32) + 88)) != 0))
      {
        v67 = v66;
        v68 = v67[1];

        if (nw_protocol_shoes_get_definition(void)::onceToken != -1)
          dispatch_once(&nw_protocol_shoes_get_definition(void)::onceToken, &__block_literal_global_30);
        if (nw_protocol_definition_is_equal_unsafe((uint64_t)v68, nw_protocol_shoes_get_definition(void)::proxy_definition))
        {
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL37nw_shoes_metadata_set_remote_endpointP20nw_protocol_metadataP11nw_endpoint_block_invoke;
          *(_QWORD *)&v87 = &__block_descriptor_tmp_39;
          *((_QWORD *)&v87 + 1) = address;
          v69 = v67[4];
          if (v69)
            ___ZL37nw_shoes_metadata_set_remote_endpointP20nw_protocol_metadataP11nw_endpoint_block_invoke((uint64_t)buf, v69);
          goto LABEL_113;
        }
        __nwlog_obj();
        *(_DWORD *)v88 = 136446210;
        v89 = "nw_shoes_metadata_set_remote_endpoint";
        v73 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v84 = 0;
        if (__nwlog_fault(v73, &type, &v84))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v74 = __nwlog_obj();
            v75 = type;
            if (!os_log_type_enabled(v74, type))
              goto LABEL_178;
            *(_DWORD *)v88 = 136446210;
            v89 = "nw_shoes_metadata_set_remote_endpoint";
            v76 = "%{public}s metadata must be shoes";
            goto LABEL_177;
          }
          if (!v84)
          {
            v74 = __nwlog_obj();
            v75 = type;
            if (!os_log_type_enabled(v74, type))
              goto LABEL_178;
            *(_DWORD *)v88 = 136446210;
            v89 = "nw_shoes_metadata_set_remote_endpoint";
            v76 = "%{public}s metadata must be shoes, backtrace limit exceeded";
            goto LABEL_177;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          v74 = __nwlog_obj();
          v75 = type;
          v80 = os_log_type_enabled(v74, type);
          if (!backtrace_string)
          {
            if (!v80)
              goto LABEL_178;
            *(_DWORD *)v88 = 136446210;
            v89 = "nw_shoes_metadata_set_remote_endpoint";
            v76 = "%{public}s metadata must be shoes, no backtrace";
            goto LABEL_177;
          }
          if (v80)
          {
            *(_DWORD *)v88 = 136446466;
            v89 = "nw_shoes_metadata_set_remote_endpoint";
            v90 = 2082;
            v91 = backtrace_string;
            v79 = "%{public}s metadata must be shoes, dumping backtrace:%{public}s";
            goto LABEL_153;
          }
          goto LABEL_154;
        }
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)v88 = 136446210;
        v89 = "nw_shoes_metadata_set_remote_endpoint";
        v73 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v84 = 0;
        if (!__nwlog_fault(v73, &type, &v84))
          goto LABEL_178;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v74 = __nwlog_obj();
          v75 = type;
          if (!os_log_type_enabled(v74, type))
            goto LABEL_178;
          *(_DWORD *)v88 = 136446210;
          v89 = "nw_shoes_metadata_set_remote_endpoint";
          v76 = "%{public}s called with null metadata";
          goto LABEL_177;
        }
        if (!v84)
        {
          v74 = __nwlog_obj();
          v75 = type;
          if (!os_log_type_enabled(v74, type))
            goto LABEL_178;
          *(_DWORD *)v88 = 136446210;
          v89 = "nw_shoes_metadata_set_remote_endpoint";
          v76 = "%{public}s called with null metadata, backtrace limit exceeded";
          goto LABEL_177;
        }
        v82 = (char *)__nw_create_backtrace_string();
        v74 = __nwlog_obj();
        v75 = type;
        v83 = os_log_type_enabled(v74, type);
        if (!v82)
        {
          if (!v83)
            goto LABEL_178;
          *(_DWORD *)v88 = 136446210;
          v89 = "nw_shoes_metadata_set_remote_endpoint";
          v76 = "%{public}s called with null metadata, no backtrace";
          goto LABEL_177;
        }
        if (v83)
        {
          *(_DWORD *)v88 = 136446466;
          v89 = "nw_shoes_metadata_set_remote_endpoint";
          v90 = 2082;
          v91 = v82;
          _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s called with null metadata, dumping backtrace:%{public}s", v88, 0x16u);
        }
        free(v82);
      }
      goto LABEL_178;
    }
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return;
    v72 = *(_QWORD *)(a1 + 32);
    if (v72)
      v71 = (const char *)(v72 + 151);
    else
      v71 = "";
    goto LABEL_124;
  }
  if (v9 != 4)
    return;
  v10 = *(unsigned __int16 *)(a2 + 1);
  if (!*(_WORD *)(a2 + 1))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return;
    v51 = __rev16(v10);
    v52 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
    *(_DWORD *)buf = 136446978;
    *(_WORD *)&buf[12] = 2082;
    if (v52)
      v53 = (const char *)(v52 + 151);
    else
      v53 = "";
    *(_QWORD *)&buf[14] = v53;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v87) = v51;
    WORD2(v87) = 2048;
    *(_QWORD *)((char *)&v87 + 6) = 1;
    v42 = "%{public}s %{public}s Invalid TLV length (%u < %zu)";
LABEL_86:
    _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_ERROR, v42, buf, 0x26u);
    return;
  }
  if (a2[3])
  {
    v11 = (void *)(*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) + 24) + 112))();
    if (v11)
    {
      v12 = v11;
      v13 = *(id *)(v12[13] + 136);

      v14 = nw_path_copy_flow_registration(v13, *(_QWORD *)(a1 + 32));
      if (v13)
        os_release(v13);
      if (v14)
      {
        if ((char)a2[3] < 0)
        {
          v15 = __nwlog_obj();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            v16 = *(_QWORD *)(a1 + 32);
            if (v16)
              v17 = (const char *)(v16 + 151);
            else
              v17 = "";
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v17;
            _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s detected expensive network from outer connection", buf, 0x16u);
          }
        }
        if ((a2[3] & 0x20) != 0)
        {
          v18 = __nwlog_obj();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            v19 = *(_QWORD *)(a1 + 32);
            if (v19)
              v20 = (const char *)(v19 + 151);
            else
              v20 = "";
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v20;
            _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s detected wifi network from outer connection", buf, 0x16u);
          }
        }
        if ((a2[3] & 0x40) != 0)
        {
          v21 = __nwlog_obj();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            v22 = *(_QWORD *)(a1 + 32);
            if (v22)
              v23 = (const char *)(v22 + 151);
            else
              v23 = "";
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v23;
            _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s detected cellular network from outer connection", buf, 0x16u);
          }
        }
        if ((a2[3] & 0x10) != 0)
        {
          v24 = __nwlog_obj();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            v25 = *(_QWORD *)(a1 + 32);
            if (v25)
              v26 = (const char *)(v25 + 151);
            else
              v26 = "";
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v26;
            _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s detected constrained network from outer connection", buf, 0x16u);
          }
        }
        v27 = a2[3];
        if ((v27 & 8) != 0)
        {
          v28 = __nwlog_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v29 = *(_QWORD *)(a1 + 32);
            if (v29)
              v30 = (const char *)(v29 + 151);
            else
              v30 = "";
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_shoes_read_reply_tlvs_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30;
            _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s detected denied interface from outer connection", buf, 0x16u);
          }
          effective_bundle_id = (const char *)nw_parameters_get_effective_bundle_id(v12);
          if (!effective_bundle_id)
          {
            if (nw_utilities_get_self_bundle_id::onceToken != -1)
              dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_7);
            effective_bundle_id = (const char *)nw_utilities_get_self_bundle_id::bundle_identifier_string;
          }
          nw_shoes_notify_interface_denied(effective_bundle_id, v32);
          v27 = a2[3];
        }
        v33 = *(_BYTE *)(a1 + 40) == 0;
        v34 = v14;
        BYTE4(v34[18].isa) = v27 & 0x70 | (v27 >> 4) & 8 | (v33 << 7) | BYTE4(v34[18].isa) & 7;

        v35 = v34;
        goto LABEL_114;
      }
    }
  }
}

void nw_shoes_notify_interface_denied(const char *a1, double a2)
{
  double client;
  uint64_t v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *v8;
  _BOOL4 v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  client = gotLoadHelper_x8__network_usage_policy_create_client(a2);
  if (!*(_QWORD *)(v3 + 1520))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "nw_shoes_notify_interface_denied";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_shoes_notify_interface_denied";
      v7 = "%{public}s called with null is_network_usage_policy_available()";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_shoes_notify_interface_denied";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null is_network_usage_policy_available(), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (!v11)
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_shoes_notify_interface_denied";
      v7 = "%{public}s called with null is_network_usage_policy_available(), no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_shoes_notify_interface_denied";
      v7 = "%{public}s called with null is_network_usage_policy_available(), backtrace limit exceeded";
    }
LABEL_20:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_21;
  }
  if (nw_shoes_get_network_usage_policy_client(void)::onceToken != -1)
    dispatch_once(&nw_shoes_get_network_usage_policy_client(void)::onceToken, &__block_literal_global_38);
  if (nw_shoes_get_network_usage_policy_client(void)::shared_policy_client)
  {
    perform_first_network_use_flow_delayInitStub(client);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_shoes_notify_interface_denied";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
  {
LABEL_21:
    if (!v4)
      return;
    goto LABEL_22;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type))
      goto LABEL_21;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_shoes_notify_interface_denied";
    v7 = "%{public}s network_usage_policy_create_client failed";
    goto LABEL_20;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    v6 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type))
      goto LABEL_21;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_shoes_notify_interface_denied";
    v7 = "%{public}s network_usage_policy_create_client failed, backtrace limit exceeded";
    goto LABEL_20;
  }
  v8 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  v6 = type;
  v9 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v8)
  {
    if (!v9)
      goto LABEL_21;
    *(_DWORD *)buf = 136446210;
    v15 = "nw_shoes_notify_interface_denied";
    v7 = "%{public}s network_usage_policy_create_client failed, no backtrace";
    goto LABEL_20;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    v15 = "nw_shoes_notify_interface_denied";
    v16 = 2082;
    v17 = v8;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s network_usage_policy_create_client failed, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v8);
  if (v4)
LABEL_22:
    free(v4);
}

id *nw_shoes_create_metadata(void)
{
  if (nw_protocol_shoes_get_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_shoes_get_definition(void)::onceToken, &__block_literal_global_30);
  return nw_protocol_metadata_create_singleton((void *)nw_protocol_shoes_get_definition(void)::proxy_definition);
}

uint64_t ___ZL37nw_shoes_metadata_set_remote_endpointP20nw_protocol_metadataP11nw_endpoint_block_invoke(uint64_t a1, _QWORD *a2)
{
  void *v3;

  v3 = *(void **)(a1 + 32);
  if (v3)
    v3 = os_retain(v3);
  *a2 = v3;
  return 1;
}

uint64_t ___ZL39nw_shoes_metadata_add_resolved_endpointP20nw_protocol_metadataP11nw_endpoint_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (!v3)
  {
    v3 = nw_array_create();
    *(_QWORD *)(a2 + 8) = v3;
  }
  nw_array_append(v3, *(void **)(a1 + 32));
  return 1;
}

uint64_t ___ZL40nw_shoes_get_network_usage_policy_clientv_block_invoke(double a1)
{
  uint64_t result;

  result = network_usage_policy_create_client_delayInitStub(a1);
  nw_shoes_get_network_usage_policy_client(void)::shared_policy_client = result;
  return result;
}

void nw_shoes_metadata_enumerate_resolved_endpoints(void *a1, uint64_t a2)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  _QWORD v16[5];
  _QWORD v17[5];
  char v18;
  os_log_type_t v19;
  _BYTE buf[24];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
    v8 = (char *)_os_log_send_and_compose_impl();
    v19 = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v8, &v19, &v18))
      goto LABEL_38;
    if (v19 == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = v19;
      if (!os_log_type_enabled(v9, v19))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
      v11 = "%{public}s called with null metadata";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = v19;
      v13 = os_log_type_enabled(v9, v19);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_38:
        if (!v8)
          return;
LABEL_39:
        free(v8);
        return;
      }
      if (!v13)
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
      v11 = "%{public}s called with null metadata, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = v19;
      if (!os_log_type_enabled(v9, v19))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
      v11 = "%{public}s called with null metadata, backtrace limit exceeded";
    }
LABEL_37:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_38;
  }
  v3 = a1;
  v4 = *((id *)v3 + 1);

  if (nw_protocol_shoes_get_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_shoes_get_definition(void)::onceToken, &__block_literal_global_30);
  if (nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_shoes_get_definition(void)::proxy_definition))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v21 = 0;
    v5 = MEMORY[0x1E0C809B0];
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 0x40000000;
    v17[2] = __nw_shoes_metadata_enumerate_resolved_endpoints_block_invoke;
    v17[3] = &unk_1E1499CF8;
    v17[4] = buf;
    v6 = *((_QWORD *)v3 + 4);
    if (v6)
    {
      __nw_shoes_metadata_enumerate_resolved_endpoints_block_invoke((uint64_t)v17, v6);
      v7 = *(unsigned __int8 **)(*(_QWORD *)&buf[8] + 24);
      if (v7)
      {
        v16[0] = v5;
        v16[1] = 0x40000000;
        v16[2] = __nw_shoes_metadata_enumerate_resolved_endpoints_block_invoke_2;
        v16[3] = &unk_1E1499D20;
        v16[4] = a2;
        nw_array_apply(v7, (uint64_t)v16);
      }
    }
    _Block_object_dispose(buf, 8);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
  v8 = (char *)_os_log_send_and_compose_impl();
  v19 = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v8, &v19, &v18))
    goto LABEL_38;
  if (v19 == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v10 = v19;
    if (!os_log_type_enabled(v9, v19))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
    v11 = "%{public}s metadata must be shoes";
    goto LABEL_37;
  }
  if (!v18)
  {
    v9 = __nwlog_obj();
    v10 = v19;
    if (!os_log_type_enabled(v9, v19))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
    v11 = "%{public}s metadata must be shoes, backtrace limit exceeded";
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v10 = v19;
  v15 = os_log_type_enabled(v9, v19);
  if (!v14)
  {
    if (!v15)
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
    v11 = "%{public}s metadata must be shoes, no backtrace";
    goto LABEL_37;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_shoes_metadata_enumerate_resolved_endpoints";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v14;
    _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s metadata must be shoes, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v14);
  if (v8)
    goto LABEL_39;
}

uint64_t __nw_shoes_metadata_enumerate_resolved_endpoints_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = *(void **)(a2 + 8);
  if (v3)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = os_retain(v3);
  return 1;
}

uint64_t __nw_shoes_metadata_enumerate_resolved_endpoints_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void nw_protocol_shoes_parameters_set_udp(void *a1)
{
  xpc_object_t v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = xpc_BOOL_create(1);
    nw_parameters_set_protocol_value(a1, "UDP", v2);
    if (v2)
      xpc_release(v2);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_protocol_shoes_parameters_set_udp";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_shoes_parameters_set_udp";
      v6 = "%{public}s called with null protocol_parameters";
      goto LABEL_17;
    }
    if (!v9)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_shoes_parameters_set_udp";
      v6 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446466;
        v12 = "nw_protocol_shoes_parameters_set_udp";
        v13 = 2082;
        v14 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_shoes_parameters_set_udp";
      v6 = "%{public}s called with null protocol_parameters, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    }
  }
LABEL_18:
  if (v3)
    free(v3);
}

void nw_protocol_shoes_parameters_set_udp_associate_supported(void *a1)
{
  xpc_object_t v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = xpc_BOOL_create(1);
    nw_parameters_set_protocol_value(a1, "UDPAssociateSupported", v2);
    if (v2)
      xpc_release(v2);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_protocol_shoes_parameters_set_udp_associate_supported";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_shoes_parameters_set_udp_associate_supported";
      v6 = "%{public}s called with null protocol_parameters";
      goto LABEL_17;
    }
    if (!v9)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_shoes_parameters_set_udp_associate_supported";
      v6 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446466;
        v12 = "nw_protocol_shoes_parameters_set_udp_associate_supported";
        v13 = 2082;
        v14 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      v12 = "nw_protocol_shoes_parameters_set_udp_associate_supported";
      v6 = "%{public}s called with null protocol_parameters, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    }
  }
LABEL_18:
  if (v3)
    free(v3);
}

void nw_protocol_shoes_parameters_set_fixed_bundle_id(void *a1, char *string)
{
  xpc_object_t v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = xpc_string_create(string);
    nw_parameters_set_protocol_value(a1, "FixedBundleID", v3);
    if (v3)
      xpc_release(v3);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_protocol_shoes_parameters_set_fixed_bundle_id";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_shoes_parameters_set_fixed_bundle_id";
      v7 = "%{public}s called with null protocol_parameters";
      goto LABEL_17;
    }
    if (!v10)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_shoes_parameters_set_fixed_bundle_id";
      v7 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v13 = "nw_protocol_shoes_parameters_set_fixed_bundle_id";
        v14 = 2082;
        v15 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_shoes_parameters_set_fixed_bundle_id";
      v7 = "%{public}s called with null protocol_parameters, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_18:
  if (v4)
    free(v4);
}

void *nw_protocol_shoes_copy_definition()
{
  void *result;

  if (nw_protocol_shoes_get_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_shoes_get_definition(void)::onceToken, &__block_literal_global_30);
  result = (void *)nw_protocol_shoes_get_definition(void)::proxy_definition;
  if (nw_protocol_shoes_get_definition(void)::proxy_definition)
    return os_retain((void *)nw_protocol_shoes_get_definition(void)::proxy_definition);
  return result;
}

BOOL nw_protocol_http_sniffing_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  char *v6;
  char v7;
  void *v8;
  void *v9;
  char v10;
  void *v11;
  id v12;
  unsigned __int8 *v13;
  _BOOL8 result;
  NSObject *v15;
  void *v16;
  NSObject *v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = (char *)malloc_type_calloc(1uLL, 0x228uLL, 0xEAFB8F1AuLL);
  if (!v6)
  {
    v15 = __nwlog_obj();
    os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v19 = "strict_calloc";
    v20 = 2048;
    v21 = 1;
    v22 = 2048;
    v23 = 552;
    v16 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v16);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v16);
  }
  bzero(v6, 0x228uLL);
  if (gLogDatapath)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v19 = "nw_protocol_http_sniffing_create";
      v20 = 2082;
      v21 = (uint64_t)(v6 + 114);
      v22 = 2080;
      v23 = (uint64_t)" ";
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
    }
  }
  if (nw_protocol_http_sniffing_identifier::onceToken[0] != -1)
    dispatch_once(nw_protocol_http_sniffing_identifier::onceToken, &__block_literal_global_488);
  *((_QWORD *)v6 + 2) = nw_protocol_http_sniffing_identifier::protocol_identifier;
  if (nw_protocol_http_sniffing_get_callbacks(void)::onceToken != -1)
    dispatch_once(&nw_protocol_http_sniffing_get_callbacks(void)::onceToken, &__block_literal_global_13_489);
  *((_QWORD *)v6 + 3) = &nw_protocol_http_sniffing_get_callbacks(void)::protocol_callbacks;
  *((_QWORD *)v6 + 5) = v6;
  if (a3)
    a3 = os_retain(a3);
  v7 = v6[472];
  if ((v7 & 1) != 0)
  {
    v8 = (void *)*((_QWORD *)v6 + 58);
    if (v8)
    {
      os_release(v8);
      v7 = v6[472];
    }
  }
  *((_QWORD *)v6 + 58) = a3;
  v6[472] = v7 | 1;
  if (a4)
  {
    v9 = os_retain(a4);
    v10 = v6[488];
    if ((v10 & 1) == 0)
      goto LABEL_18;
LABEL_16:
    v11 = (void *)*((_QWORD *)v6 + 60);
    if (v11)
    {
      os_release(v11);
      v10 = v6[488];
    }
    goto LABEL_18;
  }
  v9 = 0;
  v10 = v6[488];
  if ((v10 & 1) != 0)
    goto LABEL_16;
LABEL_18:
  *((_QWORD *)v6 + 60) = v9;
  v6[488] = v10 | 1;
  v6[548] |= 1u;
  *((_QWORD *)v6 + 54) = 0;
  *((_QWORD *)v6 + 55) = v6 + 432;
  if (nw_protocol_copy_http_sniffing_definition_onceToken != -1)
    dispatch_once(&nw_protocol_copy_http_sniffing_definition_onceToken, &__block_literal_global_35_73498);
  v12 = (id)nw_protocol_copy_http_sniffing_definition_http_sniffing_definition;
  v13 = nw_parameters_copy_protocol_options_for_definition(a4, v12);
  *((_QWORD *)v6 + 8) = v6 + 104;
  nw_protocol_plugin_name_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_sniffing_create::$_0::__invoke);
  *((_QWORD *)v6 + 10) = v6 + 200;
  nw_protocol_plugin_reset_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_sniffing_create::$_1::__invoke);
  *((_QWORD *)v6 + 11) = v6 + 216;
  nw_protocol_plugin_retry_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_sniffing_create::$_2::__invoke, (uint64_t)nw_protocol_http_sniffing_create::$_3::__invoke, (uint64_t)nw_protocol_http_sniffing_create::$_4::__invoke, (uint64_t)nw_protocol_http_sniffing_create::$_5::__invoke);
  if (v13)
    os_release(v13);
  if (v12)
    os_release(v12);
  return (BOOL)v6;
}

uint64_t nw_protocol_http_sniffing_create::$_0::__invoke(nw_protocol_http_sniffing_create::$_0 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

void nw_protocol_http_sniffing_create::$_1::__invoke(nw_protocol_http_sniffing_create::$_1 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v3;
  char v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "operator()";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "operator()";
      v9 = "%{public}s called with null protocol";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "operator()";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v6)
          return;
LABEL_37:
        free(v6);
        return;
      }
      if (!v11)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "operator()";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "operator()";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_36;
  }
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v4 = *(_BYTE *)(v3 + 456);
    if ((v4 & 1) != 0)
    {
      v5 = *(void **)(v3 + 448);
      if (v5)
      {
        os_release(v5);
        v4 = *(_BYTE *)(v3 + 456);
      }
    }
    *(_QWORD *)(v3 + 448) = 0;
    *(_BYTE *)(v3 + 456) = v4 | 1;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "operator()";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v17 = "operator()";
    v9 = "%{public}s called with null http_sniffing";
    goto LABEL_35;
  }
  if (!v14)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v17 = "operator()";
    v9 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
    goto LABEL_35;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v17 = "operator()";
    v9 = "%{public}s called with null http_sniffing, no backtrace";
    goto LABEL_35;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v17 = "operator()";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null http_sniffing, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v6)
    goto LABEL_37;
}

uint64_t nw_protocol_http_sniffing_create::$_2::__invoke(nw_protocol_http_sniffing_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v3;
  uint64_t result;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  const char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    v3 = *((_QWORD *)this + 5);
    if (v3)
    {
      result = 0;
      *(_BYTE *)(v3 + 548) |= 2u;
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "operator()";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_sniffing";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v12 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_sniffing, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "operator()";
      v17 = 2082;
      v18 = backtrace_string;
      v11 = "%{public}s called with null http_sniffing, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "operator()";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "operator()";
      v17 = 2082;
      v18 = backtrace_string;
      v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v6, v7, v11, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v6 = __nwlog_obj();
  v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    v16 = "operator()";
    v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
  }
LABEL_32:
  if (v5)
    free(v5);
  return 1;
}

uint64_t nw_protocol_http_sniffing_create::$_3::__invoke(nw_protocol_http_sniffing_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_sniffing_create::$_4::__invoke(nw_protocol_http_sniffing_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_sniffing_create::$_5::__invoke(nw_protocol_http_sniffing_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

void ___ZL39nw_protocol_http_sniffing_get_callbacksv_block_invoke()
{
  qword_1EDCE3A10 = (uint64_t)nw_protocol_common_get_parameters;
  unk_1EDCE3A18 = nw_protocol_common_get_path;
  qword_1EDCE3A20 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_1EDCE3A28 = nw_protocol_common_get_remote_endpoint;
  qword_1EDCE39B0 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_1EDCE39B8 = nw_protocol_common_connect;
  qword_1EDCE39C0 = (uint64_t)nw_protocol_common_disconnect;
  unk_1EDCE39C8 = nw_protocol_common_connected;
  qword_1EDCE39E0 = (uint64_t)nw_protocol_common_input_available;
  unk_1EDCE39E8 = nw_protocol_common_output_available;
  qword_1EDCE3A60 = (uint64_t)nw_protocol_common_output_finished;
  unk_1EDCE3A68 = nw_protocol_common_get_output_local_endpoint;
  qword_1EDCE3AA8 = (uint64_t)nw_protocol_common_input_flush;
  qword_1EDCE39D0 = (uint64_t)nw_protocol_common_disconnected;
  unk_1EDCE39D8 = nw_protocol_common_error;
  qword_1EDCE3A98 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_1EDCE3AA0 = nw_protocol_common_reset;
  qword_1EDCE3A80 = (uint64_t)nw_protocol_common_copy_info;
  qword_1EDCE3A50 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_1EDCE3A58 = nw_protocol_common_input_finished;
  qword_1EDCE3A70 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_1EDCE3A78 = nw_protocol_common_waiting_for_output;
  qword_1EDCE3A30 = (uint64_t)nw_protocol_common_register_notification;
  unk_1EDCE3A38 = nw_protocol_common_unregister_notification;
  qword_1EDCE3A40 = (uint64_t)nw_protocol_common_notify;
  unk_1EDCE3A48 = nw_protocol_common_updated_path;
  qword_1EDCE3A00 = (uint64_t)nw_protocol_common_finalize_output_frames;
  unk_1EDCE3A08 = nw_protocol_common_link_state;
  qword_1EDCE39F0 = (uint64_t)nw_protocol_http_sniffing_get_input_frames;
  unk_1EDCE39F8 = nw_protocol_common_get_output_frames;
  nw_protocol_http_sniffing_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  *(_QWORD *)algn_1EDCE39A8 = nw_protocol_http_sniffing_remove_input_handler;
}

uint64_t nw_protocol_http_sniffing_get_input_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  char *handle;
  char v12;
  unsigned int v13;
  uint64_t v14;
  BOOL v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t input_frames;
  unsigned int v20;
  _BYTE *v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  int v33;
  int v34;
  unint64_t v35;
  unsigned __int8 v36;
  void *client_metadata_in_parameters;
  void *v38;
  void **v39;
  NSObject *v40;
  void **v41;
  unsigned int v42;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  const char *v47;
  NSObject *v48;
  char *backtrace_string;
  _BOOL4 v50;
  const char *v51;
  _BOOL4 v52;
  NSObject *v53;
  uint64_t v54;
  _QWORD v55[2];
  uint64_t (*v56)(_QWORD *);
  void *v57;
  _BYTE *v58;
  _BYTE *v59;
  char *v60;
  void *__p[2];
  unsigned __int8 v62;
  _BYTE v63[24];
  uint64_t (*v64)(uint64_t, uint64_t);
  __int128 v65;
  char v66;
  _BYTE buf[24];
  __n128 (*v68)(uint64_t, uint64_t);
  _BYTE v69[24];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
    v44 = (char *)_os_log_send_and_compose_impl();
    v63[0] = 16;
    LOBYTE(__p[0]) = 0;
    if (!__nwlog_fault(v44, v63, __p))
      goto LABEL_105;
    if (v63[0] != 17)
    {
      if (!LOBYTE(__p[0]))
      {
        v45 = __nwlog_obj();
        v46 = v63[0];
        if (!os_log_type_enabled(v45, (os_log_type_t)v63[0]))
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        v47 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_104;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = v63[0];
      v50 = os_log_type_enabled(v45, (os_log_type_t)v63[0]);
      if (!backtrace_string)
      {
        if (!v50)
          goto LABEL_105;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        v47 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_104;
      }
      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v51 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_92:
        _os_log_impl(&dword_182FBE000, v45, v46, v51, buf, 0x16u);
      }
LABEL_93:
      free(backtrace_string);
      goto LABEL_105;
    }
    v45 = __nwlog_obj();
    v46 = v63[0];
    if (!os_log_type_enabled(v45, (os_log_type_t)v63[0]))
      goto LABEL_105;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
    v47 = "%{public}s called with null protocol";
LABEL_104:
    _os_log_impl(&dword_182FBE000, v45, v46, v47, buf, 0xCu);
LABEL_105:
    if (v44)
      free(v44);
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
    v44 = (char *)_os_log_send_and_compose_impl();
    v63[0] = 16;
    LOBYTE(__p[0]) = 0;
    if (!__nwlog_fault(v44, v63, __p))
      goto LABEL_105;
    if (v63[0] == 17)
    {
      v45 = __nwlog_obj();
      v46 = v63[0];
      if (!os_log_type_enabled(v45, (os_log_type_t)v63[0]))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      v47 = "%{public}s called with null http_sniffing";
      goto LABEL_104;
    }
    if (!LOBYTE(__p[0]))
    {
      v45 = __nwlog_obj();
      v46 = v63[0];
      if (!os_log_type_enabled(v45, (os_log_type_t)v63[0]))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      v47 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
      goto LABEL_104;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = v63[0];
    v52 = os_log_type_enabled(v45, (os_log_type_t)v63[0]);
    if (backtrace_string)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v51 = "%{public}s called with null http_sniffing, dumping backtrace:%{public}s";
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    if (!v52)
      goto LABEL_105;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
    v47 = "%{public}s called with null http_sniffing, no backtrace";
    goto LABEL_104;
  }
  if ((handle[198] & 1) == 0)
  {
    if (gLogDatapath)
    {
      v48 = __nwlog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 114;
        *(_WORD *)&buf[22] = 2080;
        v68 = (__n128 (*)(uint64_t, uint64_t))" ";
        *(_WORD *)v69 = 1024;
        *(_DWORD *)&v69[2] = a3;
        *(_WORD *)&v69[6] = 1024;
        *(_DWORD *)&v69[8] = a4;
        *(_WORD *)&v69[12] = 1024;
        *(_DWORD *)&v69[14] = a5;
        _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sminimum bytes %u, maximum bytes %u, maximum frame count %u", buf, 0x32u);
      }
    }
  }
  if ((handle[428] & 1) != 0)
  {
    input_frames = 0;
    if ((handle[198] & 1) != 0 || !gLogDatapath)
      return input_frames;
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 114;
      *(_WORD *)&buf[22] = 2080;
      v68 = (__n128 (*)(uint64_t, uint64_t))" ";
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%salready getting input frames, returning 0", buf, 0x20u);
      return 0;
    }
    return 0;
  }
  handle[428] |= 1u;
  v12 = handle[548];
  if ((v12 & 1) != 0)
  {
    do
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3802000000;
      v68 = __Block_byref_object_copy__509;
      *(_QWORD *)v69 = __Block_byref_object_dispose__510;
      *(_QWORD *)&v69[8] = 0;
      *(_QWORD *)&v69[16] = &v69[8];
      v24 = a3;
      v25 = a4;
      v26 = a5;
      if (*((_QWORD *)handle + 56))
      {
        v27 = *((_DWORD *)handle + 136);
        if (a3 <= v27)
          v24 = 1;
        else
          v24 = a3 - v27;
        v15 = a4 >= v27;
        v28 = a4 - v27;
        if (v28 != 0 && v15)
        {
          v29 = *((_DWORD *)handle + 130) - *((_DWORD *)handle + 132) + 512;
          if (v28 <= v29)
            v25 = v29;
          else
            v25 = v28;
        }
        else
        {
          v25 = (*((_DWORD *)handle + 130) - *((_DWORD *)handle + 132) + 512);
        }
        v26 = 0xFFFFFFFFLL;
      }
      if (nw_protocol_get_input_frames((uint64_t)a1->output_handler, (uint64_t)a1, v24, v25, v26, (uint64_t)&v69[8])&& *(_QWORD *)(*(_QWORD *)&buf[8] + 40))
      {
        *(_QWORD *)v63 = 0;
        *(_QWORD *)&v63[8] = v63;
        *(_QWORD *)&v63[16] = 0x3802000000;
        v64 = __Block_byref_object_copy__14;
        *(_QWORD *)&v65 = __Block_byref_object_dispose__15;
        if (nw_protocol_copy_http_definition_onceToken != -1)
          dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72660);
        *((_QWORD *)&v65 + 1) = (id)nw_protocol_copy_http_definition_http_definition;
        v66 |= 1u;
        v55[0] = MEMORY[0x1E0C809B0];
        v55[1] = 0x40000000;
        v56 = (uint64_t (*)(_QWORD *))___ZL42nw_protocol_http_sniffing_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
        v57 = &unk_1E1499F88;
        v59 = buf;
        v60 = handle;
        v58 = v63;
        v30 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
        do
        {
          if (!v30)
            break;
          v31 = *(_QWORD *)(v30 + 32);
          v32 = v56(v55);
          v30 = v31;
        }
        while ((v32 & 1) != 0);
        _Block_object_dispose(v63, 8);
        if ((v66 & 1) != 0 && *((_QWORD *)&v65 + 1))
          os_release(*((void **)&v65 + 1));
        v33 = 1;
      }
      else
      {
        v34 = handle[548];
        if ((~v34 & 3) == 0)
        {
          handle[548] = v34 & 0xFE;
          nw_http_sniffing_guess_media_type((uint64_t)__p, (uint64_t)handle);
          v35 = v62;
          v36 = v62;
          if ((v62 & 0x80u) != 0)
            v35 = (unint64_t)__p[1];
          if (v35)
          {
            if ((handle[198] & 1) == 0)
            {
              if (gLogDatapath)
              {
                v40 = __nwlog_obj();
                if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
                {
                  v41 = __p;
                  if ((v62 & 0x80u) != 0)
                    v41 = (void **)__p[0];
                  *(_DWORD *)v63 = 136446978;
                  *(_QWORD *)&v63[4] = "nw_http_sniffing_stop";
                  *(_WORD *)&v63[12] = 2082;
                  *(_QWORD *)&v63[14] = handle + 114;
                  *(_WORD *)&v63[22] = 2080;
                  v64 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  LOWORD(v65) = 2080;
                  *(_QWORD *)((char *)&v65 + 2) = v41;
                  _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%smedia type %s", v63, 0x2Au);
                }
              }
            }
            client_metadata_in_parameters = nw_http_messaging_options_find_or_create_client_metadata_in_parameters(*((void **)handle + 60), (uint64_t)handle);
            v36 = v62;
            if (client_metadata_in_parameters)
            {
              v38 = client_metadata_in_parameters;
              if ((v62 & 0x80u) == 0)
                v39 = __p;
              else
                v39 = (void **)__p[0];
              nw_http_client_metadata_set_sniffed_media_type(client_metadata_in_parameters, (uint64_t)v39);
              os_release(v38);
              v36 = v62;
            }
          }
          if ((v36 & 0x80) != 0)
            operator delete(__p[0]);
        }
        v33 = 0;
      }
      _Block_object_dispose(buf, 8);
      v12 = handle[548];
    }
    while (v33 && (handle[548] & 1) != 0);
  }
  if ((v12 & 1) != 0)
  {
    if (*((_QWORD *)handle + 56))
    {
      input_frames = 0;
      v21 = (_BYTE *)&unk_1ECD84000;
    }
    else
    {
      *(_DWORD *)v63 = 0;
      LOBYTE(__p[0]) = 0;
      input_frames = nw_protocol_fulfill_frame_request((_QWORD *)handle + 54, (uint64_t)a6, a3, a4, a5, (unsigned int *)v63, __p);
      v42 = *((_DWORD *)handle + 136);
      v15 = v42 >= *(_DWORD *)v63;
      *((_DWORD *)handle + 136) = v42 - *(_DWORD *)v63;
      v21 = &unk_1ECD84000;
      if (!v15)
      {
        if (!gLogDatapath)
          goto LABEL_70;
        v22 = __nwlog_obj();
        if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          goto LABEL_70;
        goto LABEL_109;
      }
    }
  }
  else
  {
    if (*((_QWORD *)handle + 54))
    {
      v13 = *((_DWORD *)handle + 136);
      v14 = a4 - v13;
      if (a4 > v13)
      {
        v15 = a3 >= v13;
        v16 = a3 - v13;
        v17 = v15 ? v16 : 1;
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        nw_protocol_get_input_frames((uint64_t)a1->output_handler, (uint64_t)a1, v17, v14, a5, (uint64_t)buf);
        if (*(_QWORD *)buf)
        {
          **((_QWORD **)handle + 55) = *(_QWORD *)buf;
          v18 = *(_QWORD *)&buf[8];
          *(_QWORD *)(*(_QWORD *)buf + 40) = *((_QWORD *)handle + 55);
          *((_QWORD *)handle + 55) = v18;
        }
      }
      *(_DWORD *)v63 = 0;
      LOBYTE(__p[0]) = 0;
      input_frames = nw_protocol_fulfill_frame_request((_QWORD *)handle + 54, (uint64_t)a6, a3, a4, a5, (unsigned int *)v63, __p);
      v20 = *((_DWORD *)handle + 136);
      v15 = v20 >= *(_DWORD *)v63;
      *((_DWORD *)handle + 136) = v20 - *(_DWORD *)v63;
      v21 = &unk_1ECD84000;
      if (v15)
        goto LABEL_71;
      if (!gLogDatapath)
        goto LABEL_70;
      v22 = __nwlog_obj();
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        goto LABEL_70;
LABEL_109:
      v54 = *((unsigned int *)handle + 136);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = "http_sniffing->pending_input_frames_byte_count";
      *(_WORD *)&buf[22] = 2048;
      v68 = (__n128 (*)(uint64_t, uint64_t))*(unsigned int *)v63;
      *(_WORD *)v69 = 2048;
      *(_QWORD *)&v69[2] = v54;
      _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
LABEL_70:
      *((_DWORD *)handle + 136) = 0;
      goto LABEL_71;
    }
    input_frames = nw_protocol_get_input_frames((uint64_t)a1->output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
    v21 = (_BYTE *)&unk_1ECD84000;
  }
LABEL_71:
  nw_protocol_plugin_retry_set_getting_input_frames((uint64_t)(handle + 216), (uint64_t)a1, 0);
  if ((handle[198] & 1) == 0)
  {
    if (v21[1345])
    {
      v53 = __nwlog_obj();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 114;
        *(_WORD *)&buf[22] = 2080;
        v68 = (__n128 (*)(uint64_t, uint64_t))" ";
        *(_WORD *)v69 = 1024;
        *(_DWORD *)&v69[2] = input_frames;
        _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sreturning %u frames", buf, 0x26u);
      }
    }
  }
  return input_frames;
}

uint64_t nw_protocol_http_sniffing_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  void *handle;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  const char *v11;
  _BOOL4 v12;
  _QWORD v13[5];
  char v14;
  _QWORD v15[5];
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 0x40000000;
      v15[2] = ___ZL46nw_protocol_http_sniffing_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v15[3] = &__block_descriptor_tmp_147;
      v15[4] = handle;
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 0x40000000;
      v13[2] = ___ZL46nw_protocol_http_sniffing_remove_input_handlerP11nw_protocolS0_b_block_invoke_148;
      v13[3] = &__block_descriptor_tmp_149;
      v14 = a3;
      v13[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v15, (uint64_t)v13);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http_sniffing_remove_input_handler";
    v5 = (char *)_os_log_send_and_compose_impl();
    v17 = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v5, &v17, &v16))
      goto LABEL_32;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_sniffing_remove_input_handler";
        v8 = "%{public}s called with null http_sniffing";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v16)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_sniffing_remove_input_handler";
        v8 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = v17;
    v12 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_sniffing_remove_input_handler";
        v8 = "%{public}s called with null http_sniffing, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_http_sniffing_remove_input_handler";
      v20 = 2082;
      v21 = backtrace_string;
      v11 = "%{public}s called with null http_sniffing, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_http_sniffing_remove_input_handler";
  v5 = (char *)_os_log_send_and_compose_impl();
  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v5, &v17, &v16))
    goto LABEL_32;
  if (v17 != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_sniffing_remove_input_handler";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = v17;
    v10 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_sniffing_remove_input_handler";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_http_sniffing_remove_input_handler";
      v20 = 2082;
      v21 = backtrace_string;
      v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v6, v7, v11, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v6 = __nwlog_obj();
  v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http_sniffing_remove_input_handler";
    v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
  }
LABEL_32:
  if (v5)
    free(v5);
  return 0;
}

void ___ZL46nw_protocol_http_sniffing_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v2;
  char v3;
  const void *v4;
  char v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  NSObject *v11;
  _BOOL4 v12;
  NSObject *v13;
  _BYTE v14[24];
  const char *v15;
  uint64_t v16;
  char v17;
  uint8_t buf[4];
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_BYTE *)(v2 + 336);
  if ((v3 & 1) != 0)
  {
    v4 = *(const void **)(v2 + 328);
    if (v4)
    {
      _Block_release(v4);
      v3 = *(_BYTE *)(v2 + 336);
    }
  }
  *(_QWORD *)(v2 + 328) = 0;
  *(_BYTE *)(v2 + 336) = v3 | 1;
  v5 = *(_BYTE *)(v2 + 384);
  if ((v5 & 1) != 0)
  {
    v6 = *(const void **)(v2 + 376);
    if (v6)
    {
      _Block_release(v6);
      v5 = *(_BYTE *)(v2 + 384);
    }
  }
  *(_QWORD *)(v2 + 376) = 0;
  *(_BYTE *)(v2 + 384) = v5 | 1;
  v7 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v7 + 198) & 1) == 0)
  {
    if (!gLogDatapath)
      goto LABEL_9;
    v11 = __nwlog_obj();
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
    v7 = *(_QWORD *)(a1 + 32);
    if (v12)
    {
      *(_DWORD *)v14 = 136446722;
      *(_QWORD *)&v14[4] = "nw_protocol_http_sniffing_remove_input_handler_block_invoke";
      *(_WORD *)&v14[12] = 2082;
      *(_QWORD *)&v14[14] = v7 + 114;
      *(_WORD *)&v14[22] = 2080;
      v15 = " ";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sfinalizing pending input frames", v14, 0x20u);
      v7 = *(_QWORD *)(a1 + 32);
    }
  }
  if (gLogDatapath)
  {
    v13 = __nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
LABEL_9:
  *(_QWORD *)v14 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v14[8] = 0x40000000;
  *(_QWORD *)&v14[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke;
  v15 = (const char *)&__block_descriptor_tmp_150;
  v16 = v7 + 432;
  v17 = 0;
  v8 = *(_QWORD *)(v7 + 432);
  do
  {
    if (!v8)
      break;
    v9 = *(_QWORD *)(v8 + 32);
    v10 = (*(uint64_t (**)(_BYTE *))&v14[16])(v14);
    v8 = v9;
  }
  while ((v10 & 1) != 0);
}

void ___ZL46nw_protocol_http_sniffing_remove_input_handlerP11nw_protocolS0_b_block_invoke_148(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  NSObject *v6;
  int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 40))
    return;
  v1 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v1 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v6 = __nwlog_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        v7 = 136446722;
        v8 = "nw_http_sniffing_destroy";
        v9 = 2082;
        v10 = v1 + 114;
        v11 = 2080;
        v12 = " ";
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", (uint8_t *)&v7, 0x20u);
      }
    }
  }
  v2 = *(void **)(v1 + 520);
  if (v2)
  {
    *(_QWORD *)(v1 + 528) = v2;
    operator delete(v2);
  }
  if (*(char *)(v1 + 519) < 0)
  {
    operator delete(*(void **)(v1 + 496));
    if ((*(_BYTE *)(v1 + 488) & 1) == 0)
      goto LABEL_12;
LABEL_10:
    v3 = *(void **)(v1 + 480);
    if (v3)
      os_release(v3);
    goto LABEL_12;
  }
  if ((*(_BYTE *)(v1 + 488) & 1) != 0)
    goto LABEL_10;
LABEL_12:
  *(_QWORD *)(v1 + 480) = 0;
  if ((*(_BYTE *)(v1 + 472) & 1) != 0)
  {
    v4 = *(void **)(v1 + 464);
    if (v4)
      os_release(v4);
  }
  *(_QWORD *)(v1 + 464) = 0;
  if ((*(_BYTE *)(v1 + 456) & 1) != 0)
  {
    v5 = *(void **)(v1 + 448);
    if (v5)
      os_release(v5);
  }
  *(_QWORD *)(v1 + 448) = 0;
  nw_protocol_plugin_retry::~nw_protocol_plugin_retry((nw_protocol_plugin_retry *)(v1 + 216));
  free((void *)v1);
}

void nw_protocol_plugin_retry::~nw_protocol_plugin_retry(nw_protocol_plugin_retry *this)
{
  const void *v2;
  const void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  if ((*((_BYTE *)this + 168) & 1) != 0)
  {
    v2 = (const void *)*((_QWORD *)this + 20);
    if (v2)
      _Block_release(v2);
  }
  *((_QWORD *)this + 20) = 0;
  if ((*((_BYTE *)this + 120) & 1) != 0)
  {
    v3 = (const void *)*((_QWORD *)this + 14);
    if (v3)
      _Block_release(v3);
  }
  *((_QWORD *)this + 14) = 0;
  if ((*((_BYTE *)this + 104) & 1) != 0)
  {
    v4 = (void *)*((_QWORD *)this + 12);
    if (v4)
      os_release(v4);
  }
  *((_QWORD *)this + 12) = 0;
  if ((*((_BYTE *)this + 88) & 1) != 0)
  {
    v5 = (void *)*((_QWORD *)this + 10);
    if (v5)
      os_release(v5);
  }
  *((_QWORD *)this + 10) = 0;
  if ((*((_BYTE *)this + 72) & 1) != 0)
  {
    v6 = (void *)*((_QWORD *)this + 8);
    if (v6)
      os_release(v6);
  }
  *((_QWORD *)this + 8) = 0;
  if ((*((_BYTE *)this + 56) & 1) != 0)
  {
    v7 = (void *)*((_QWORD *)this + 6);
    if (v7)
      os_release(v7);
  }
  *((_QWORD *)this + 6) = 0;
  if ((*((_BYTE *)this + 40) & 1) != 0)
  {
    v8 = (void *)*((_QWORD *)this + 4);
    if (v8)
      os_release(v8);
  }
  *((_QWORD *)this + 4) = 0;
  if ((*((_BYTE *)this + 24) & 1) != 0)
  {
    v9 = (void *)*((_QWORD *)this + 2);
    if (v9)
      os_release(v9);
  }
  *((_QWORD *)this + 2) = 0;
  if ((*((_BYTE *)this + 8) & 1) != 0 && *(_QWORD *)this)
    os_release(*(void **)this);
  *(_QWORD *)this = 0;
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

__n128 __Block_byref_object_copy__509(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t __Block_byref_object_copy__14(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__15(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

BOOL ___ZL42nw_protocol_http_sniffing_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  char v7;
  void *v8;
  uint64_t v9;
  void *client_metadata_in_parameters;
  void *v11;
  void *v12;
  uint64_t v13;
  id v14;
  id v15;
  _QWORD *v16;
  uint64_t v17;
  _OWORD *v18;
  char v19;
  void *v20;
  size_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t *v26;
  id v27;
  id v28;
  os_log_type_t *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  std::string::size_type size;
  uint64_t v35;
  void **v36;
  std::string *v37;
  size_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  _QWORD *v46;
  char *v47;
  char *v48;
  unsigned int v49;
  int64_t v50;
  const void *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  size_t v56;
  size_t v57;
  size_t v58;
  char *v59;
  size_t v60;
  size_t v61;
  uint64_t v62;
  _QWORD *v63;
  _BYTE *v64;
  char *v65;
  _OWORD *v66;
  unint64_t v67;
  __int128 v68;
  char v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  char v77;
  void *v78;
  void *v79;
  os_log_type_t *v80;
  void *v81;
  id *v82;
  id v83;
  BOOL is_equal_unsafe;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  int v88;
  int v89;
  _QWORD *v90;
  uint64_t v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t *v94;
  char *v96;
  NSObject *v97;
  os_log_type_t v98;
  const char *v99;
  char *v100;
  _BOOL4 v101;
  NSObject *v102;
  int v103;
  __n128 (*v104)(uint64_t, uint64_t);
  char *v105;
  NSObject *v106;
  os_log_type_t v107;
  const char *v108;
  char *v109;
  NSObject *v110;
  os_log_type_t v111;
  const char *v112;
  char *backtrace_string;
  _BOOL4 v114;
  char *v115;
  NSObject *v116;
  _BOOL4 v117;
  char *v118;
  _BOOL4 v119;
  const char *v120;
  char *v121;
  _BOOL4 v122;
  _BOOL4 v123;
  char *v124;
  NSObject *v125;
  os_log_type_t v126;
  const char *v127;
  void *v128;
  char *v129;
  NSObject *v130;
  os_log_type_t v131;
  NSObject *v132;
  os_log_type_t *v133;
  uint64_t v134;
  _BOOL4 v135;
  char *v136;
  _BOOL4 v137;
  NSObject *v138;
  os_log_type_t v139;
  char *v140;
  os_log_type_t v141;
  _BOOL4 v142;
  os_log_type_t v143;
  _QWORD *v144;
  os_log_type_t v145[8];
  os_log_type_t v146;
  size_t __src;
  std::string v148;
  std::string v149;
  _QWORD v150[5];
  _QWORD v151[5];
  os_log_type_t type[8];
  uint64_t v153;
  char *(*v154)(char *, char *);
  void *v155;
  uint64_t *v156;
  uint64_t v157;
  uint64_t *v158;
  uint64_t v159;
  char v160;
  _BYTE buf[24];
  __n128 (*v162)(uint64_t, uint64_t);
  __int128 v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;

  v166 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = nw_frame_copy_metadata_for_protocol(a2, *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 40));
    v5 = v4;
    if (*(void **)(a1[6] + 448) == v4 || nw_http_metadata_get_type(v4) == 3)
      goto LABEL_64;
    v6 = a1[6];
    v7 = *(_BYTE *)(v6 + 456);
    if ((v7 & 1) != 0)
    {
      v8 = *(void **)(v6 + 448);
      if (v8)
      {
        os_release(v8);
        v7 = *(_BYTE *)(v6 + 456);
      }
    }
    *(_QWORD *)(v6 + 448) = v5;
    *(_BYTE *)(v6 + 456) = v7 | 1;
    v9 = a1[6];
    if (v9)
    {
      client_metadata_in_parameters = nw_http_messaging_options_find_or_create_client_metadata_in_parameters(*(void **)(v9 + 480), v9);
      if (client_metadata_in_parameters)
      {
        v11 = client_metadata_in_parameters;
        nw_http_client_metadata_set_sniffed_media_type(client_metadata_in_parameters, 0);
        os_release(v11);
      }
      goto LABEL_10;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_sniffing_reset_sniffed_media_type";
    v105 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v151[0]) = 0;
    if (__nwlog_fault(v105, type, v151))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v106 = __nwlog_obj();
        v107 = type[0];
        if (!os_log_type_enabled(v106, type[0]))
          goto LABEL_260;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_sniffing_reset_sniffed_media_type";
        v108 = "%{public}s called with null http_sniffing";
        goto LABEL_259;
      }
      if (!LOBYTE(v151[0]))
      {
        v106 = __nwlog_obj();
        v107 = type[0];
        if (!os_log_type_enabled(v106, type[0]))
          goto LABEL_260;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_sniffing_reset_sniffed_media_type";
        v108 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
        goto LABEL_259;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v106 = __nwlog_obj();
      v107 = type[0];
      v114 = os_log_type_enabled(v106, type[0]);
      if (backtrace_string)
      {
        if (v114)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_sniffing_reset_sniffed_media_type";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v106, v107, "%{public}s called with null http_sniffing, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_260;
      }
      if (v114)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_sniffing_reset_sniffed_media_type";
        v108 = "%{public}s called with null http_sniffing, no backtrace";
LABEL_259:
        _os_log_impl(&dword_182FBE000, v106, v107, v108, buf, 0xCu);
      }
    }
LABEL_260:
    if (v105)
      free(v105);
LABEL_10:
    v12 = *(void **)(a1[6] + 448);
    v13 = MEMORY[0x1E0C809B0];
    if (v12)
    {
      v14 = nw_http_metadata_copy_header_fields(v12);
      if (v14)
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x4002000000;
        v162 = __Block_byref_object_copy__19;
        *(_QWORD *)&v163 = __Block_byref_object_dispose__20;
        v164 = 0;
        v165 = 0;
        *((_QWORD *)&v163 + 1) = 0;
        v150[0] = v13;
        v150[1] = 0x40000000;
        v150[2] = ___ZL31nw_http_sniffing_get_media_typeP25nw_protocol_http_sniffingP20nw_protocol_metadata_block_invoke;
        v150[3] = &unk_1E1499FB0;
        v150[4] = buf;
        v15 = v14;
        v16 = v150;
        _nw_http_fields_enumerate_by_name((uint64_t)v15, (unint64_t)"Content-Type", v16);

        v17 = *(_QWORD *)&buf[8];
        v18 = (_OWORD *)(*(_QWORD *)&buf[8] + 40);
        v19 = *(_BYTE *)(*(_QWORD *)&buf[8] + 63);
        if (v19 < 0)
        {
          v20 = *(void **)(*(_QWORD *)&buf[8] + 40);
          v21 = *(_QWORD *)(*(_QWORD *)&buf[8] + 48);
          if (!v21)
            goto LABEL_20;
        }
        else
        {
          v20 = (void *)(*(_QWORD *)&buf[8] + 40);
          v21 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 63);
          if (!*(_BYTE *)(*(_QWORD *)&buf[8] + 63))
            goto LABEL_20;
        }
        v22 = memchr(v20, 47, v21);
        if (v22 && v22 - (_BYTE *)v20 != -1)
        {
          if (v19 < 0)
          {
            std::string::__init_copy_ctor_external(&v149, *(const std::string::value_type **)(v17 + 40), *(_QWORD *)(v17 + 48));
          }
          else
          {
            *(_OWORD *)&v149.__r_.__value_.__l.__data_ = *v18;
            v149.__r_.__value_.__r.__words[2] = *(_QWORD *)(v17 + 56);
          }
LABEL_21:
          _Block_object_dispose(buf, 8);
          if (SHIBYTE(v165) < 0)
            operator delete(*((void **)&v163 + 1));
          os_release(v15);
          v23 = a1[6];
          if (SHIBYTE(v149.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::__init_copy_ctor_external(&v148, v149.__r_.__value_.__l.__data_, v149.__r_.__value_.__l.__size_);
            v24 = a1[6];
            if (v23)
              goto LABEL_25;
            goto LABEL_32;
          }
LABEL_24:
          v148 = v149;
          v24 = v23;
          if (v23)
          {
LABEL_25:
            v25 = *(void **)(v24 + 448);
            if (v25)
            {
              if (nw_http_metadata_get_type(*(void **)(v24 + 448)) == 3)
              {
                LOBYTE(v26) = 0;
                goto LABEL_47;
              }
              v27 = nw_http_metadata_copy_header_fields(v25);
              if (v27)
              {
                v157 = 0;
                v158 = &v157;
                v159 = 0x2000000000;
                v160 = 0;
                *(_QWORD *)type = v13;
                v153 = 0x40000000;
                v154 = ___ZL29nw_http_sniffing_should_sniffP25nw_protocol_http_sniffingNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP20nw_protocol_metadata_block_invoke;
                v155 = &unk_1E1499FD8;
                v156 = &v157;
                v28 = v27;
                v29 = type;
                _nw_http_fields_access_value_by_name((uint64_t)v28, (unint64_t)"X-Content-Type-Options", v29);

                if (*((_BYTE *)v158 + 24))
                {
                  LOBYTE(v26) = 0;
LABEL_46:
                  _Block_object_dispose(&v157, 8);
                  os_release(v28);
                  goto LABEL_47;
                }
                size = HIBYTE(v148.__r_.__value_.__r.__words[2]);
                if ((v148.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  size = v148.__r_.__value_.__l.__size_;
                if (!size)
                  goto LABEL_45;
                mime_type_to_class();
                v26 = std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::find<std::string>((uint64_t)&v148);
                mime_type_to_class();
                if (!v26)
                  goto LABEL_46;
                if (*((_DWORD *)v26 + 10) != 1)
                {
LABEL_45:
                  LOBYTE(v26) = 1;
                  goto LABEL_46;
                }
                *(_QWORD *)buf = 0;
                *(_QWORD *)&buf[8] = buf;
                *(_QWORD *)&buf[16] = 0x4002000000;
                v162 = __Block_byref_object_copy__19;
                *(_QWORD *)&v163 = __Block_byref_object_dispose__20;
                v164 = 0;
                v165 = 0;
                *((_QWORD *)&v163 + 1) = 0;
                v151[0] = v13;
                v151[1] = 0x40000000;
                v151[2] = ___ZL29nw_http_sniffing_should_sniffP25nw_protocol_http_sniffingNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP20nw_protocol_metadata_block_invoke_2;
                v151[3] = &unk_1E149A000;
                v151[4] = buf;
                nw_http_fields_enumerate_by_name(v28, (unint64_t)"Content-Type", v151);
                v26 = (uint64_t *)(*(_QWORD *)&buf[8] + 40);
                if (*(char *)(*(_QWORD *)&buf[8] + 63) < 0)
                {
                  if (!*(_QWORD *)(*(_QWORD *)&buf[8] + 48))
                    goto LABEL_107;
                  v26 = (uint64_t *)*v26;
                }
                else if (!*(_BYTE *)(*(_QWORD *)&buf[8] + 63))
                {
                  goto LABEL_107;
                }
                if (strcasecmp((const char *)v26, "utf-8"))
                {
                  LOBYTE(v26) = strcasecmp((const char *)v26, "iso-8859-1") == 0;
                  goto LABEL_108;
                }
LABEL_107:
                LOBYTE(v26) = 1;
LABEL_108:
                _Block_object_dispose(buf, 8);
                if (SHIBYTE(v165) < 0)
                  operator delete(*((void **)&v163 + 1));
                goto LABEL_46;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
              v30 = (char *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v151[0]) = 0;
              if (!__nwlog_fault(v30, type, v151))
                goto LABEL_279;
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                v31 = __nwlog_obj();
                v32 = type[0];
                if (os_log_type_enabled(v31, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
                  v33 = "%{public}s called with null header_fields";
                  goto LABEL_278;
                }
LABEL_279:
                if (v30)
                  free(v30);
                LOBYTE(v26) = 0;
LABEL_47:
                *(_BYTE *)(a1[6] + 548) = *(_BYTE *)(a1[6] + 548) & 0xFE | v26;
                if (SHIBYTE(v148.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v148.__r_.__value_.__l.__data_);
                v35 = a1[6];
                if ((*(_BYTE *)(v35 + 548) & 1) != 0)
                {
                  v36 = (void **)(v35 + 496);
                  if (*(char *)(v35 + 519) < 0)
                  {
                    if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v37 = &v149;
                    else
                      v37 = (std::string *)v149.__r_.__value_.__r.__words[0];
                    if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v38 = HIBYTE(v149.__r_.__value_.__r.__words[2]);
                    else
                      v38 = v149.__r_.__value_.__l.__size_;
                    std::string::__assign_no_alias<false>(v36, v37, v38);
                  }
                  else
                  {
                    if ((*((_BYTE *)&v149.__r_.__value_.__s + 23) & 0x80) == 0)
                    {
                      *(_OWORD *)v36 = *(_OWORD *)&v149.__r_.__value_.__l.__data_;
                      *(_QWORD *)(v35 + 512) = *((_QWORD *)&v149.__r_.__value_.__l + 2);
                      *(_QWORD *)(a1[6] + 528) = *(_QWORD *)(a1[6] + 520);
LABEL_63:
                      v5 = 0;
LABEL_64:
                      v40 = *(_QWORD *)(a2 + 64);
                      if (v40)
                        v41 = (*(unsigned __int8 *)(v40 + 66) >> 6) & 1;
                      else
                        v41 = 0;
                      v42 = a1[6];
                      if (!*(_QWORD *)(v42 + 448) || (*(_BYTE *)(v42 + 548) & 1) == 0)
                        goto LABEL_136;
                      if (!*(_QWORD *)(a2 + 112)
                        || (*(_WORD *)(a2 + 204) & 0x100) != 0
                        && g_channel_check_validity
                        && !g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
                      {
                        goto LABEL_110;
                      }
                      v43 = *(_DWORD *)(a2 + 52);
                      if (!v43)
                        goto LABEL_110;
                      v44 = *(unsigned int *)(a2 + 56);
                      v45 = v43 - (v44 + *(_DWORD *)(a2 + 60));
                      if (!v45)
                        goto LABEL_110;
                      v46 = (_QWORD *)a1[6];
                      v47 = (char *)v46[66];
                      v48 = (char *)v46[65];
                      v49 = (_DWORD)v48 - (_DWORD)v47 + 512;
                      v50 = v49 >= v45 ? v45 : v49;
                      if (!(_DWORD)v50)
                      {
LABEL_110:
                        v74 = a1[6];
                        if (*(_QWORD *)(v74 + 528) - *(_QWORD *)(v74 + 520) > 0x1FFuLL)
                          v75 = 1;
                        else
                          v75 = v41;
                        if (v75 == 1)
                        {
                          if ((*(_BYTE *)(v74 + 548) & 1) != 0)
                          {
                            *(_BYTE *)(v74 + 548) &= ~1u;
                            nw_http_sniffing_guess_media_type((uint64_t)type, v74);
                            v76 = HIBYTE(v154);
                            v77 = HIBYTE(v154);
                            if (SHIBYTE(v154) < 0)
                              v76 = v153;
                            if (v76)
                            {
                              if ((*(_BYTE *)(v74 + 198) & 1) == 0)
                              {
                                if (gLogDatapath)
                                {
                                  v132 = __nwlog_obj();
                                  if (os_log_type_enabled(v132, OS_LOG_TYPE_DEBUG))
                                  {
                                    v133 = type;
                                    if (SHIBYTE(v154) < 0)
                                      v133 = *(os_log_type_t **)type;
                                    *(_DWORD *)buf = 136446978;
                                    *(_QWORD *)&buf[4] = "nw_http_sniffing_stop";
                                    *(_WORD *)&buf[12] = 2082;
                                    *(_QWORD *)&buf[14] = v74 + 114;
                                    *(_WORD *)&buf[22] = 2080;
                                    v162 = (__n128 (*)(uint64_t, uint64_t))" ";
                                    LOWORD(v163) = 2080;
                                    *(_QWORD *)((char *)&v163 + 2) = v133;
                                    _os_log_impl(&dword_182FBE000, v132, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%smedia type %s", buf, 0x2Au);
                                  }
                                }
                              }
                              v78 = nw_http_messaging_options_find_or_create_client_metadata_in_parameters(*(void **)(v74 + 480), v74);
                              v77 = HIBYTE(v154);
                              if (v78)
                              {
                                v79 = v78;
                                if (SHIBYTE(v154) >= 0)
                                  v80 = type;
                                else
                                  v80 = *(os_log_type_t **)type;
                                nw_http_client_metadata_set_sniffed_media_type(v78, (uint64_t)v80);
                                os_release(v79);
                                v77 = HIBYTE(v154);
                              }
                            }
                            if (v77 < 0)
                              operator delete(*(void **)type);
                            goto LABEL_135;
                          }
                          __nwlog_obj();
                          *(_DWORD *)buf = 136446210;
                          *(_QWORD *)&buf[4] = "nw_http_sniffing_stop";
                          v124 = (char *)_os_log_send_and_compose_impl();
                          type[0] = OS_LOG_TYPE_ERROR;
                          LOBYTE(v151[0]) = 0;
                          if (__nwlog_fault(v124, type, v151))
                          {
                            if (type[0] == OS_LOG_TYPE_FAULT)
                            {
                              v125 = __nwlog_obj();
                              v126 = type[0];
                              if (!os_log_type_enabled(v125, type[0]))
                                goto LABEL_285;
                              *(_DWORD *)buf = 136446210;
                              *(_QWORD *)&buf[4] = "nw_http_sniffing_stop";
                              v127 = "%{public}s called with null http_sniffing->active";
                              goto LABEL_284;
                            }
                            if (!LOBYTE(v151[0]))
                            {
                              v125 = __nwlog_obj();
                              v126 = type[0];
                              if (!os_log_type_enabled(v125, type[0]))
                                goto LABEL_285;
                              *(_DWORD *)buf = 136446210;
                              *(_QWORD *)&buf[4] = "nw_http_sniffing_stop";
                              v127 = "%{public}s called with null http_sniffing->active, backtrace limit exceeded";
                              goto LABEL_284;
                            }
                            v136 = (char *)__nw_create_backtrace_string();
                            v125 = __nwlog_obj();
                            v126 = type[0];
                            v137 = os_log_type_enabled(v125, type[0]);
                            if (v136)
                            {
                              if (v137)
                              {
                                *(_DWORD *)buf = 136446466;
                                *(_QWORD *)&buf[4] = "nw_http_sniffing_stop";
                                *(_WORD *)&buf[12] = 2082;
                                *(_QWORD *)&buf[14] = v136;
                                _os_log_impl(&dword_182FBE000, v125, v126, "%{public}s called with null http_sniffing->active, dumping backtrace:%{public}s", buf, 0x16u);
                              }
                              free(v136);
                              goto LABEL_285;
                            }
                            if (v137)
                            {
                              *(_DWORD *)buf = 136446210;
                              *(_QWORD *)&buf[4] = "nw_http_sniffing_stop";
                              v127 = "%{public}s called with null http_sniffing->active, no backtrace";
LABEL_284:
                              _os_log_impl(&dword_182FBE000, v125, v126, v127, buf, 0xCu);
                            }
                          }
LABEL_285:
                          if (v124)
                            free(v124);
                          goto LABEL_135;
                        }
                        v81 = nw_http_messaging_options_find_or_create_client_metadata_in_parameters(*(void **)(v74 + 480), a1[6]);
                        if (!v81)
                        {
LABEL_135:
                          v42 = a1[6];
LABEL_136:
                          v88 = *(_DWORD *)(v42 + 544);
                          v89 = *(_DWORD *)(a2 + 52);
                          if (v89)
                            v89 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
                          *(_DWORD *)(v42 + 544) = v88 + v89;
                          if (__CFADD__(v88, v89))
                          {
                            if (gLogDatapath)
                            {
                              v102 = __nwlog_obj();
                              if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                              {
                                v103 = *(_DWORD *)(a2 + 52);
                                if (v103)
                                  v104 = (__n128 (*)(uint64_t, uint64_t))(v103
                                                                                               - (*(_DWORD *)(a2 + 56)
                                                                                                + *(_DWORD *)(a2 + 60)));
                                else
                                  v104 = 0;
                                v134 = *(unsigned int *)(a1[6] + 544);
                                *(_DWORD *)buf = 136446978;
                                *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames_block_invoke";
                                *(_WORD *)&buf[12] = 2082;
                                *(_QWORD *)&buf[14] = "http_sniffing->pending_input_frames_byte_count";
                                *(_WORD *)&buf[22] = 2048;
                                v162 = v104;
                                LOWORD(v163) = 2048;
                                *(_QWORD *)((char *)&v163 + 2) = v134;
                                _os_log_impl(&dword_182FBE000, v102, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
                              }
                            }
                            *(_DWORD *)(a1[6] + 544) = -1;
                          }
                          v91 = *(_QWORD *)(a2 + 32);
                          v92 = *(_QWORD **)(a2 + 40);
                          v90 = (_QWORD *)(a2 + 32);
                          if (v91)
                          {
                            *(_QWORD *)(v91 + 40) = v92;
                            v92 = *(_QWORD **)(a2 + 40);
                          }
                          else
                          {
                            *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 48) = v92;
                          }
                          *v92 = v91;
                          *v90 = 0;
                          *(_QWORD *)(a2 + 40) = 0;
                          v93 = a1[6];
                          v94 = *(uint64_t **)(v93 + 440);
                          *(_QWORD *)(a2 + 40) = v94;
                          *v94 = a2;
                          *(_QWORD *)(v93 + 440) = v90;
                          if (v5)
                            os_release(v5);
                          return a2 != 0;
                        }
                        v82 = v81;
                        v83 = v82[1];

                        if (nw_protocol_copy_http_client_definition_onceToken != -1)
                          dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_52_74156);
                        is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v83, nw_protocol_copy_http_client_definition_definition);

                        if (is_equal_unsafe)
                        {
                          v86 = v82[4];
                          if (v86)
                          {
                            v87 = v86[6];
                            if (v87)
                              (*(void (**)(uint64_t, uint64_t))(v87 + 16))(v87, v85);
                          }
LABEL_134:

                          os_release(v82);
                          goto LABEL_135;
                        }
                        __nwlog_obj();
                        v128 = (void *)objc_claimAutoreleasedReturnValue();
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_http_client_metadata_call_prevent_timeout_callback";
                        v129 = (char *)_os_log_send_and_compose_impl();

                        type[0] = OS_LOG_TYPE_ERROR;
                        LOBYTE(v151[0]) = 0;
                        if (__nwlog_fault(v129, type, v151))
                        {
                          if (type[0] == OS_LOG_TYPE_FAULT)
                          {
                            __nwlog_obj();
                            v130 = objc_claimAutoreleasedReturnValue();
                            v131 = type[0];
                            if (os_log_type_enabled(v130, type[0]))
                            {
                              *(_DWORD *)buf = 136446210;
                              *(_QWORD *)&buf[4] = "nw_http_client_metadata_call_prevent_timeout_callback";
                              _os_log_impl(&dword_182FBE000, v130, v131, "%{public}s metadata must be http_client", buf, 0xCu);
                            }
                          }
                          else if (LOBYTE(v151[0]))
                          {
                            v140 = (char *)__nw_create_backtrace_string();
                            __nwlog_obj();
                            v130 = objc_claimAutoreleasedReturnValue();
                            v141 = type[0];
                            v142 = os_log_type_enabled(v130, type[0]);
                            if (v140)
                            {
                              if (v142)
                              {
                                *(_DWORD *)buf = 136446466;
                                *(_QWORD *)&buf[4] = "nw_http_client_metadata_call_prevent_timeout_callback";
                                *(_WORD *)&buf[12] = 2082;
                                *(_QWORD *)&buf[14] = v140;
                                _os_log_impl(&dword_182FBE000, v130, v141, "%{public}s metadata must be http_client, dumping backtrace:%{public}s", buf, 0x16u);
                              }

                              free(v140);
                              goto LABEL_293;
                            }
                            if (v142)
                            {
                              *(_DWORD *)buf = 136446210;
                              *(_QWORD *)&buf[4] = "nw_http_client_metadata_call_prevent_timeout_callback";
                              _os_log_impl(&dword_182FBE000, v130, v141, "%{public}s metadata must be http_client, no backtrace", buf, 0xCu);
                            }
                          }
                          else
                          {
                            __nwlog_obj();
                            v130 = objc_claimAutoreleasedReturnValue();
                            v143 = type[0];
                            if (os_log_type_enabled(v130, type[0]))
                            {
                              *(_DWORD *)buf = 136446210;
                              *(_QWORD *)&buf[4] = "nw_http_client_metadata_call_prevent_timeout_callback";
                              _os_log_impl(&dword_182FBE000, v130, v143, "%{public}s metadata must be http_client, backtrace limit exceeded", buf, 0xCu);
                            }
                          }

                        }
LABEL_293:
                        if (v129)
                          free(v129);
                        goto LABEL_134;
                      }
                      v51 = (const void *)(*(_QWORD *)(a2 + 112) + v44);
                      v52 = v46[67];
                      if (v52 - (uint64_t)v47 >= v50)
                      {
                        memmove(v47, v51, v50);
                        v46[66] = &v47[v50];
                        goto LABEL_110;
                      }
                      v53 = v47 - v48;
                      v54 = v47 - v48 + v50;
                      if (v54 < 0)
                        abort();
                      v55 = v52 - (_QWORD)v48;
                      if (2 * v55 > v54)
                        v54 = 2 * v55;
                      if (v55 >= 0x3FFFFFFFFFFFFFFFLL)
                        v56 = 0x7FFFFFFFFFFFFFFFLL;
                      else
                        v56 = v54;
                      __src = v56;
                      v144 = (_QWORD *)a1[6];
                      if (v56)
                        v56 = (size_t)operator new(v56);
                      *(_QWORD *)v145 = v56;
                      v57 = v56 + v53;
                      memcpy((void *)(v56 + v53), v51, v50);
                      if (v48 == v47)
                      {
                        v64 = v47;
                        v61 = v57;
                        v62 = *(_QWORD *)v145;
                        v58 = __src;
                        v60 = v57;
                        v63 = v144;
LABEL_99:
                        v70 = (char *)(v60 + v50);
                        v71 = v62 + v58;
                        v72 = v64 - v47;
                        if (v64 != v47)
                          memmove(v70, v47, v64 - v47);
                        v73 = (void *)v63[65];
                        v63[65] = v61;
                        v63[66] = &v70[v72];
                        v63[67] = v71;
                        if (v73)
                          operator delete(v73);
                        goto LABEL_110;
                      }
                      v58 = __src;
                      if (v53 >= 0x20)
                      {
                        v62 = *(_QWORD *)v145;
                        v59 = v47;
                        v60 = v57;
                        v61 = v57;
                        v63 = v144;
                        if ((unint64_t)&v48[-*(_QWORD *)v145] >= 0x20)
                        {
                          v59 = &v47[-(v53 & 0xFFFFFFFFFFFFFFE0)];
                          v65 = v47 - 16;
                          v66 = (_OWORD *)(*(_QWORD *)v145 + v47 - 16 - v48);
                          v67 = v53 & 0xFFFFFFFFFFFFFFE0;
                          do
                          {
                            v68 = *(_OWORD *)v65;
                            *(v66 - 1) = *((_OWORD *)v65 - 1);
                            *v66 = v68;
                            v65 -= 32;
                            v66 -= 2;
                            v67 -= 32;
                          }
                          while (v67);
                          v61 = v60 - (v53 & 0xFFFFFFFFFFFFFFE0);
                          if (v53 == (v53 & 0xFFFFFFFFFFFFFFE0))
                            goto LABEL_98;
                        }
                      }
                      else
                      {
                        v59 = v47;
                        v60 = v57;
                        v61 = v57;
                        v63 = v144;
                        v62 = *(_QWORD *)v145;
                      }
                      do
                      {
                        v69 = *--v59;
                        *(_BYTE *)--v61 = v69;
                      }
                      while (v59 != v48);
LABEL_98:
                      v64 = (_BYTE *)v63[66];
                      goto LABEL_99;
                    }
                    std::string::__assign_no_alias<true>(v36, v149.__r_.__value_.__l.__data_, v149.__r_.__value_.__l.__size_);
                  }
                }
                v39 = SHIBYTE(v149.__r_.__value_.__r.__words[2]);
                *(_QWORD *)(a1[6] + 528) = *(_QWORD *)(a1[6] + 520);
                if (v39 < 0)
                  operator delete(v149.__r_.__value_.__l.__data_);
                goto LABEL_63;
              }
              if (!LOBYTE(v151[0]))
              {
                v31 = __nwlog_obj();
                v32 = type[0];
                if (os_log_type_enabled(v31, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
                  v33 = "%{public}s called with null header_fields, backtrace limit exceeded";
                  goto LABEL_278;
                }
                goto LABEL_279;
              }
              v118 = (char *)__nw_create_backtrace_string();
              v31 = __nwlog_obj();
              v32 = type[0];
              v135 = os_log_type_enabled(v31, type[0]);
              if (!v118)
              {
                if (v135)
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
                  v33 = "%{public}s called with null header_fields, no backtrace";
                  goto LABEL_278;
                }
                goto LABEL_279;
              }
              if (v135)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v118;
                v120 = "%{public}s called with null header_fields, dumping backtrace:%{public}s";
                goto LABEL_230;
              }
LABEL_231:
              free(v118);
              goto LABEL_279;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
            v30 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v151[0]) = 0;
            if (!__nwlog_fault(v30, type, v151))
              goto LABEL_279;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v31 = __nwlog_obj();
              v32 = type[0];
              if (!os_log_type_enabled(v31, type[0]))
                goto LABEL_279;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
              v33 = "%{public}s called with null http_metadata";
              goto LABEL_278;
            }
            if (!LOBYTE(v151[0]))
            {
              v31 = __nwlog_obj();
              v32 = type[0];
              if (os_log_type_enabled(v31, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
                v33 = "%{public}s called with null http_metadata, backtrace limit exceeded";
                goto LABEL_278;
              }
              goto LABEL_279;
            }
            v118 = (char *)__nw_create_backtrace_string();
            v31 = __nwlog_obj();
            v32 = type[0];
            v123 = os_log_type_enabled(v31, type[0]);
            if (!v118)
            {
              if (v123)
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
                v33 = "%{public}s called with null http_metadata, no backtrace";
                goto LABEL_278;
              }
              goto LABEL_279;
            }
            if (!v123)
              goto LABEL_231;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v118;
            v120 = "%{public}s called with null http_metadata, dumping backtrace:%{public}s";
            goto LABEL_230;
          }
LABEL_32:
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
          v30 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v151[0]) = 0;
          if (!__nwlog_fault(v30, type, v151))
            goto LABEL_279;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v31 = __nwlog_obj();
            v32 = type[0];
            if (!os_log_type_enabled(v31, type[0]))
              goto LABEL_279;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
            v33 = "%{public}s called with null http_sniffing";
LABEL_278:
            _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0xCu);
            goto LABEL_279;
          }
          if (!LOBYTE(v151[0]))
          {
            v31 = __nwlog_obj();
            v32 = type[0];
            if (os_log_type_enabled(v31, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
              v33 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
              goto LABEL_278;
            }
            goto LABEL_279;
          }
          v118 = (char *)__nw_create_backtrace_string();
          v31 = __nwlog_obj();
          v32 = type[0];
          v119 = os_log_type_enabled(v31, type[0]);
          if (!v118)
          {
            if (v119)
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
              v33 = "%{public}s called with null http_sniffing, no backtrace";
              goto LABEL_278;
            }
            goto LABEL_279;
          }
          if (!v119)
            goto LABEL_231;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_sniffing_should_sniff";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v118;
          v120 = "%{public}s called with null http_sniffing, dumping backtrace:%{public}s";
LABEL_230:
          _os_log_impl(&dword_182FBE000, v31, v32, v120, buf, 0x16u);
          goto LABEL_231;
        }
LABEL_20:
        *((_BYTE *)&v149.__r_.__value_.__s + 23) = 0;
        v149.__r_.__value_.__s.__data_[0] = 0;
        goto LABEL_21;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
      v109 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v151[0]) = 0;
      if (__nwlog_fault(v109, type, v151))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v110 = __nwlog_obj();
          v111 = type[0];
          if (!os_log_type_enabled(v110, type[0]))
            goto LABEL_247;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
          v112 = "%{public}s called with null header_fields";
          goto LABEL_245;
        }
        if (!LOBYTE(v151[0]))
        {
          v110 = __nwlog_obj();
          v111 = type[0];
          if (!os_log_type_enabled(v110, type[0]))
            goto LABEL_247;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
          v112 = "%{public}s called with null header_fields, backtrace limit exceeded";
          goto LABEL_245;
        }
        v121 = (char *)__nw_create_backtrace_string();
        v116 = __nwlog_obj();
        v146 = type[0];
        v122 = os_log_type_enabled(v116, type[0]);
        if (v121)
        {
          if (v122)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v121;
            _os_log_impl(&dword_182FBE000, v116, v146, "%{public}s called with null header_fields, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v121);
          if (!v109)
            goto LABEL_249;
          goto LABEL_248;
        }
        if (v122)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
          v112 = "%{public}s called with null header_fields, no backtrace";
          goto LABEL_269;
        }
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
      v109 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v151[0]) = 0;
      if (!__nwlog_fault(v109, type, v151))
        goto LABEL_247;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v110 = __nwlog_obj();
        v111 = type[0];
        if (!os_log_type_enabled(v110, type[0]))
          goto LABEL_247;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
        v112 = "%{public}s called with null http_metadata";
LABEL_245:
        v138 = v110;
        v139 = v111;
LABEL_246:
        _os_log_impl(&dword_182FBE000, v138, v139, v112, buf, 0xCu);
        goto LABEL_247;
      }
      if (!LOBYTE(v151[0]))
      {
        v110 = __nwlog_obj();
        v111 = type[0];
        if (!os_log_type_enabled(v110, type[0]))
          goto LABEL_247;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
        v112 = "%{public}s called with null http_metadata, backtrace limit exceeded";
        goto LABEL_245;
      }
      v115 = (char *)__nw_create_backtrace_string();
      v116 = __nwlog_obj();
      v146 = type[0];
      v117 = os_log_type_enabled(v116, type[0]);
      if (v115)
      {
        if (v117)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v115;
          _os_log_impl(&dword_182FBE000, v116, v146, "%{public}s called with null http_metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v115);
      }
      else if (v117)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_sniffing_get_media_type";
        v112 = "%{public}s called with null http_metadata, no backtrace";
LABEL_269:
        v138 = v116;
        v139 = v146;
        goto LABEL_246;
      }
    }
LABEL_247:
    if (!v109)
    {
LABEL_249:
      memset(&v149, 0, sizeof(v149));
      v23 = a1[6];
      goto LABEL_24;
    }
LABEL_248:
    free(v109);
    goto LABEL_249;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames_block_invoke";
  v96 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v151[0]) = 0;
  if (__nwlog_fault(v96, type, v151))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v97 = __nwlog_obj();
      v98 = type[0];
      if (!os_log_type_enabled(v97, type[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames_block_invoke";
      v99 = "%{public}s called with null frame";
      goto LABEL_212;
    }
    if (!LOBYTE(v151[0]))
    {
      v97 = __nwlog_obj();
      v98 = type[0];
      if (!os_log_type_enabled(v97, type[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames_block_invoke";
      v99 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_212;
    }
    v100 = (char *)__nw_create_backtrace_string();
    v97 = __nwlog_obj();
    v98 = type[0];
    v101 = os_log_type_enabled(v97, type[0]);
    if (v100)
    {
      if (v101)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v100;
        _os_log_impl(&dword_182FBE000, v97, v98, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v100);
      goto LABEL_213;
    }
    if (v101)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_sniffing_get_input_frames_block_invoke";
      v99 = "%{public}s called with null frame, no backtrace";
LABEL_212:
      _os_log_impl(&dword_182FBE000, v97, v98, v99, buf, 0xCu);
    }
  }
LABEL_213:
  if (v96)
    free(v96);
  return a2 != 0;
}

void nw_http_sniffing_guess_media_type(uint64_t a1, uint64_t a2)
{
  std::string *v4;
  uint64_t *v5;
  std::string::size_type v6;
  char v7;
  char v8;
  __int16 *v9;
  unsigned __int16 *v10;
  unint64_t v11;
  int v12;
  int v13;
  std::string::size_type v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int v21;
  BOOL v23;
  int v24;
  BOOL v25;
  char v26;
  std::string::size_type v28;
  std::string::size_type v29;
  std::string::size_type v30;
  std::string::size_type v31;
  unsigned __int8 v32;
  std::string::size_type v33;
  unsigned __int8 v34;
  std::string::size_type v35;
  unsigned __int8 v36;
  std::string::size_type v37;
  char v38;
  void *v39;
  size_t v40;
  void *v41;
  size_t v42;
  std::string::size_type size;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  unint64_t v46;
  unint64_t v47;
  const void *v48;
  size_t v49;
  std::string::size_type v50;
  void *p_dst;
  unsigned __int8 *v52;
  unint64_t v54;
  unsigned __int8 *v56;
  int v58;
  int v59;
  int v60;
  unint64_t v61;
  unint64_t v63;
  int v65;
  int v66;
  void *v68;
  size_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  const char *v75;
  char *backtrace_string;
  _BOOL4 v77;
  _BOOL4 v78;
  _BOOL4 v79;
  std::string __dst;
  std::string v81;
  char v82;
  std::string buf;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    if (!*(_QWORD *)(a2 + 448))
      return;
    v4 = (std::string *)(a2 + 496);
    if (*(char *)(a2 + 519) < 0)
    {
      if (!*(_QWORD *)(a2 + 504))
        goto LABEL_11;
    }
    else if (!*(_BYTE *)(a2 + 519))
    {
LABEL_11:
      nw_http_sniffing_copy_mime_type_for_unknown(&buf, a2);
LABEL_12:
      if (*(char *)(a1 + 23) < 0)
        operator delete(*(void **)a1);
      *(_OWORD *)a1 = *(_OWORD *)&buf.__r_.__value_.__l.__data_;
      v6 = buf.__r_.__value_.__r.__words[2];
      goto LABEL_15;
    }
    mime_type_to_class();
    v5 = std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::find<std::string>(a2 + 496);
    mime_type_to_class();
    if (!v5)
    {
      if (v4 != (std::string *)a1)
      {
        v8 = *(_BYTE *)(a2 + 519);
        if (*(char *)(a1 + 23) < 0)
        {
          if (v8 >= 0)
            v39 = (void *)(a2 + 496);
          else
            v39 = *(void **)(a2 + 496);
          if (v8 >= 0)
            v40 = *(unsigned __int8 *)(a2 + 519);
          else
            v40 = *(_QWORD *)(a2 + 504);
          std::string::__assign_no_alias<false>((void **)a1, v39, v40);
        }
        else
        {
          if ((*(_BYTE *)(a2 + 519) & 0x80) == 0)
          {
            *(_OWORD *)a1 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
            v6 = *(_QWORD *)(a2 + 512);
LABEL_15:
            *(_QWORD *)(a1 + 16) = v6;
            goto LABEL_16;
          }
          std::string::__assign_no_alias<true>((_QWORD *)a1, *(void **)(a2 + 496), *(_QWORD *)(a2 + 504));
        }
      }
LABEL_16:
      if (*(char *)(a1 + 23) < 0)
      {
        if (*(_QWORD *)(a1 + 8))
          return;
      }
      else if (*(_BYTE *)(a1 + 23))
      {
        return;
      }
      v7 = *(_BYTE *)(a2 + 519);
      if (v7 < 0)
      {
        if (*(_QWORD *)(a2 + 504))
        {
LABEL_22:
          if (v4 != (std::string *)a1)
          {
            if ((*(_BYTE *)(a1 + 23) & 0x80) != 0)
            {
              if (v7 >= 0)
                v41 = (void *)(a2 + 496);
              else
                v41 = *(void **)(a2 + 496);
              if (v7 >= 0)
                v42 = *(unsigned __int8 *)(a2 + 519);
              else
                v42 = *(_QWORD *)(a2 + 504);
              std::string::__assign_no_alias<false>((void **)a1, v41, v42);
            }
            else if ((*(_BYTE *)(a2 + 519) & 0x80) != 0)
            {
              std::string::__assign_no_alias<true>((_QWORD *)a1, *(void **)(a2 + 496), *(_QWORD *)(a2 + 504));
            }
            else
            {
              *(_OWORD *)a1 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
              *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 512);
            }
          }
          return;
        }
      }
      else if (*(_BYTE *)(a2 + 519))
      {
        goto LABEL_22;
      }
      std::string::__assign_external((std::string *)a1, "application/octet-stream", 0x18uLL);
      return;
    }
    switch(*((_DWORD *)v5 + 10))
    {
      case 0:
        if (*(char *)(a2 + 519) < 0)
        {
          std::string::__init_copy_ctor_external(&v81, *(const std::string::value_type **)(a2 + 496), *(_QWORD *)(a2 + 504));
        }
        else
        {
          *(_OWORD *)&v81.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
          v81.__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 512);
        }
        size = HIBYTE(v81.__r_.__value_.__r.__words[2]);
        if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          size = v81.__r_.__value_.__l.__size_;
        if (!size)
          std::string::__assign_external(&v81, (const std::string::value_type *)kNWMIMETypeTextHTML);
        v44 = *(unsigned __int8 **)(a2 + 520);
        v45 = *(unsigned __int8 **)(a2 + 528);
        if (v44 == v45)
        {
          buf = v81;
          memset(&v81, 0, sizeof(v81));
          goto LABEL_191;
        }
        v46 = 0;
        memset(&buf, 0, sizeof(buf));
        v47 = v45 - v44;
        if (v47 >= 0x200)
          v47 = 512;
        if (v47 >= 3)
        {
          if (*v44 == 239 && v44[1] == 187)
          {
            if (v44[2] == 191)
              v46 = 3;
            else
              v46 = 0;
          }
          else
          {
            v46 = 0;
          }
        }
        if (v46 >= v47)
          goto LABEL_188;
        v52 = v44 + 2;
        while (2)
        {
          while (2)
          {
            if ((char)v44[v46] <= 0x20 && ((1 << v44[v46]) & 0x100002600) != 0)
            {
              v54 = v46 + 1;
              goto LABEL_147;
            }
            if (v44[v46] != 60 || v46 + 3 >= v47)
              goto LABEL_188;
            v54 = v46 + 1;
            v56 = &v44[v46 + 1];
            if (*(_WORD *)v56 == 11553 && v56[2] == 45)
            {
              if (v46 + 6 >= v47)
                goto LABEL_188;
              v61 = v46 + 4;
              while (*(_WORD *)&v44[v61] != 11565 || v44[v61 + 2] != 62)
              {
                v63 = v61 + 3;
                ++v61;
                if (v63 >= v47)
                  goto LABEL_188;
              }
              v46 = v61 + 3;
LABEL_187:
              if (v46 >= v47)
                goto LABEL_188;
              continue;
            }
            break;
          }
          v58 = *v56;
          if (v58 == 33)
          {
            while (v46 + 2 < v47)
            {
              v60 = v52[v46++];
              if (v60 == 62)
              {
                v46 += 2;
                goto LABEL_187;
              }
            }
          }
          else
          {
            if (v58 == 63)
            {
              while (v46 + 3 < v47)
              {
                v59 = *(unsigned __int16 *)&v52[v46++];
                if (v59 == 15935)
                {
                  v46 += 3;
                  goto LABEL_187;
                }
              }
              break;
            }
            if (*(_WORD *)v56 == 29554 && v56[2] == 115)
            {
LABEL_234:
              *((_BYTE *)&buf.__r_.__value_.__s + 23) = 19;
              strcpy((char *)&buf, "application/rss+xml");
              goto LABEL_191;
            }
            if (v46 + 4 < v47)
            {
              if (*(_DWORD *)v56 == 1684366694)
              {
                *((_BYTE *)&buf.__r_.__value_.__s + 23) = 20;
                strcpy((char *)&buf, "application/atom+xml");
                goto LABEL_191;
              }
              if (v46 + 7 < v47)
              {
                v65 = *(_DWORD *)v56;
                v66 = *(_DWORD *)(v56 + 3);
                if (v65 != 979788914 || v66 != 1178882618)
                {
LABEL_147:
                  v46 = v54;
                  if (v54 >= v47)
                    break;
                  continue;
                }
                LOBYTE(v78) = 0;
                LOBYTE(v79) = 0;
                while (1)
                {
                  if (v79)
                  {
                    v79 = 1;
                  }
                  else
                  {
                    if (v54 + 23 >= v47)
                      goto LABEL_188;
                    v79 = (*(_QWORD *)&v44[v54] ^ 0x702F2F3A70747468 | *(_QWORD *)&v44[v54 + 8] ^ 0x2F67726F2E6C7275 | *(_QWORD *)&v44[v54 + 16] ^ 0x2F302E312F737372) == 0;
                    if (!(*(_QWORD *)&v44[v54] ^ 0x702F2F3A70747468 | *(_QWORD *)&v44[v54 + 8] ^ 0x2F67726F2E6C7275 | *(_QWORD *)&v44[v54 + 16] ^ 0x2F302E312F737372))
                      v54 += 23;
                  }
                  if (v78)
                  {
                    v78 = 1;
                  }
                  else
                  {
                    if (v54 + 42 >= v47)
                      goto LABEL_188;
                    v78 = (*(_QWORD *)&v44[v54] ^ 0x772F2F3A70747468 | *(_QWORD *)&v44[v54 + 8] ^ 0x726F2E33772E7777 | *(_QWORD *)&v44[v54 + 16] ^ 0x302F393939312F67 | *(_QWORD *)&v44[v54 + 24] ^ 0x6664722D32322F32 | *(_QWORD *)&v44[v54 + 32] ^ 0x2D7861746E79732DLL | *(_QWORD *)&v44[v54 + 35] ^ 0x23736E2D7861746ELL) == 0;
                    if (!(*(_QWORD *)&v44[v54] ^ 0x772F2F3A70747468 | *(_QWORD *)&v44[v54 + 8] ^ 0x726F2E33772E7777 | *(_QWORD *)&v44[v54 + 16] ^ 0x302F393939312F67 | *(_QWORD *)&v44[v54 + 24] ^ 0x6664722D32322F32 | *(_QWORD *)&v44[v54 + 32] ^ 0x2D7861746E79732DLL | *(_QWORD *)&v44[v54 + 35] ^ 0x23736E2D7861746ELL))
                      v54 += 42;
                  }
                  if (v79 && v78)
                    goto LABEL_234;
                  if (++v54 >= v47)
                    goto LABEL_188;
                }
              }
            }
          }
          break;
        }
LABEL_188:
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
          std::string::__assign_no_alias<true>(&buf, v81.__r_.__value_.__l.__data_, v81.__r_.__value_.__l.__size_);
        else
          buf = v81;
LABEL_191:
        if (*(char *)(a1 + 23) < 0)
          operator delete(*(void **)a1);
        *(std::string *)a1 = buf;
        *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
        buf.__r_.__value_.__s.__data_[0] = 0;
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v81.__r_.__value_.__l.__data_);
        goto LABEL_16;
      case 1:
        v9 = *(__int16 **)(a2 + 520);
        v10 = *(unsigned __int16 **)(a2 + 528);
        if (v9 != (__int16 *)v10)
        {
          memset(&__dst, 0, sizeof(__dst));
          v11 = (char *)v10 - (char *)v9;
          if (v11 >= 0x200)
            v11 = 512;
          if (v11 < 3)
            goto LABEL_46;
          if (*v9 != -2 && *v9 != -257)
          {
            v12 = (unsigned __int16)*v9;
            v13 = *((unsigned __int8 *)v9 + 2);
            if (v12 != 48111 || v13 != 191)
              goto LABEL_46;
          }
          std::string::__assign_external(&__dst, (const std::string::value_type *)kNWMIMETypeTextPlain);
          v15 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v15 = __dst.__r_.__value_.__l.__size_;
          if (!v15)
          {
LABEL_46:
            v16 = *(_QWORD *)(a2 + 520);
            v17 = *(_QWORD *)(a2 + 528);
            if (v16 == v17)
              goto LABEL_67;
            v18 = v17 - v16;
            if (v18 >= 0x200)
              v18 = 512;
            if (!v18)
              goto LABEL_67;
            v19 = v18 + v16 - 1;
            v20 = v16 + 1;
            do
            {
              v21 = *(unsigned __int8 *)(v20 - 1);
              v23 = v21 >= 9 && v21 != 11 && v21 - 14 >= 0xD;
              v24 = v21 & 0xFC;
              v25 = !v23 || v24 == 28;
              v26 = v25;
              if (v25)
                break;
            }
            while (v20++ <= v19);
            if ((v26 & 1) == 0)
LABEL_67:
              std::string::__assign_external(&__dst, (const std::string::value_type *)kNWMIMETypeTextPlain);
          }
          v28 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          LOBYTE(v29) = *((_BYTE *)&__dst.__r_.__value_.__s + 23);
          v30 = __dst.__r_.__value_.__l.__size_;
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v31 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          else
            v31 = __dst.__r_.__value_.__l.__size_;
          if (!v31)
          {
            {
              sNonScriptableTypeRules(void)::rules = 0;
              *(_QWORD *)algn_1EDCF1168 = "%!PS-Adobe-";
              qword_1EDCF1170 = 11;
              unk_1EDCF1178 = "application/postscript";
              qword_1EDCF1180 = (uint64_t)&unk_183BA8B46;
              unk_1EDCF1188 = &unk_183BA8B4B;
              qword_1EDCF1190 = 4;
              unk_1EDCF1198 = kNWMIMETypeTextPlain;
              qword_1EDCF11A0 = (uint64_t)&unk_183BA8B46;
              unk_1EDCF11A8 = &unk_183BA8B50;
              qword_1EDCF11B0 = 4;
              unk_1EDCF11B8 = kNWMIMETypeTextPlain;
              qword_1EDCF11C0 = (uint64_t)&unk_183BA8B55;
              unk_1EDCF11C8 = &unk_183BA8B5A;
              qword_1EDCF11D0 = 4;
              unk_1EDCF11D8 = kNWMIMETypeTextPlain;
              qword_1EDCF11E0 = 0;
              unk_1EDCF11E8 = &unk_183BA7990;
              qword_1EDCF11F0 = 7;
              unk_1EDCF11F8 = "application/x-rar-compressed";
              qword_1EDCF1200 = 0;
              unk_1EDCF1208 = "PK\x03\x04";
              qword_1EDCF1210 = 4;
              unk_1EDCF1218 = "application/zip";
              qword_1EDCF1220 = 0;
              unk_1EDCF1228 = "\x1F\x8B\b";
              qword_1EDCF1230 = 3;
              unk_1EDCF1238 = "application/x-gzip";
              qword_1EDCF1240 = 0;
              unk_1EDCF1248 = 0;
              qword_1EDCF1250 = 0;
              unk_1EDCF1258 = "";
            }
            nw_http_sniffing_get_mime_type_for_rule_array(&buf, *(_QWORD *)(a2 + 520), *(_QWORD *)(a2 + 528), &sNonScriptableTypeRules(void)::rules, 0);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__dst.__r_.__value_.__l.__data_);
            __dst = buf;
            v28 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
            v30 = buf.__r_.__value_.__l.__size_;
            v29 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          if ((v29 & 0x80u) == 0)
            v33 = v28;
          else
            v33 = v30;
          if (!v33)
          {
            {
              sImageTypeRules(void)::rules = 0;
              unk_1EDCE29E0 = "GIF87a";
              qword_1EDCE29E8 = 6;
              unk_1EDCE29F0 = kNWMIMETypeImageGIF;
              qword_1EDCE29F8 = 0;
              unk_1EDCE2A00 = "GIF89a";
              qword_1EDCE2A08 = 6;
              unk_1EDCE2A10 = kNWMIMETypeImageGIF;
              qword_1EDCE2A18 = 0;
              unk_1EDCE2A20 = "\x89PNG\r\n\x1A\n";
              qword_1EDCE2A28 = 8;
              unk_1EDCE2A30 = kNWMIMETypeImagePNG;
              qword_1EDCE2A38 = 0;
              unk_1EDCE2A40 = "\xFF\xD8\xFF";
              qword_1EDCE2A48 = 3;
              unk_1EDCE2A50 = kNWMIMETypeImageJPEG;
              qword_1EDCE2A58 = 0;
              unk_1EDCE2A60 = "BM";
              qword_1EDCE2A68 = 2;
              unk_1EDCE2A70 = kNWMIMETypeImageBMP;
              qword_1EDCE2A78 = 0;
              unk_1EDCE2A80 = &unk_183BA8B5F;
              qword_1EDCE2A88 = 4;
              unk_1EDCE2A90 = kNWMIMETypeImageICO;
              qword_1EDCE2A98 = 0;
              unk_1EDCE2AA0 = 0;
              qword_1EDCE2AA8 = 0;
              unk_1EDCE2AB0 = "";
            }
            nw_http_sniffing_get_mime_type_for_rule_array(&buf, *(_QWORD *)(a2 + 520), *(_QWORD *)(a2 + 528), &sImageTypeRules(void)::rules, 0);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__dst.__r_.__value_.__l.__data_);
            __dst = buf;
            v28 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
            v30 = buf.__r_.__value_.__l.__size_;
            v29 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          if ((v29 & 0x80u) == 0)
            v35 = v28;
          else
            v35 = v30;
          if (!v35)
          {
            nw_http_sniffing_get_mime_type_for_complex_nonscriptable_type_rules((uint64_t)&buf, a2);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__dst.__r_.__value_.__l.__data_);
            __dst = buf;
            v28 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
            v30 = buf.__r_.__value_.__l.__size_;
            v29 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
          }
          if ((v29 & 0x80u) != 0)
            v28 = v30;
          if (!v28)
            std::string::__assign_external(&__dst, "application/octet-stream", 0x18uLL);
LABEL_207:
          if (*(char *)(a1 + 23) < 0)
            operator delete(*(void **)a1);
          *(_OWORD *)a1 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          v6 = __dst.__r_.__value_.__r.__words[2];
          goto LABEL_15;
        }
        v48 = (const void *)kNWMIMETypeTextPlain;
        v49 = strlen((const char *)kNWMIMETypeTextPlain);
        if (v49 >= 0x7FFFFFFFFFFFFFF8)
          abort();
        v50 = v49;
        if (v49 >= 0x17)
        {
          v70 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v49 | 7) != 0x17)
            v70 = v49 | 7;
          v71 = v70 + 1;
          p_dst = operator new(v70 + 1);
          __dst.__r_.__value_.__l.__size_ = v50;
          __dst.__r_.__value_.__r.__words[2] = v71 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v49;
          p_dst = &__dst;
          if (!v49)
            goto LABEL_206;
        }
        memmove(p_dst, v48, v50);
LABEL_206:
        *((_BYTE *)p_dst + v50) = 0;
        goto LABEL_207;
      case 2:
        {
          sImageTypeRules(void)::rules = 0;
          unk_1EDCE29E0 = "GIF87a";
          qword_1EDCE29E8 = 6;
          unk_1EDCE29F0 = kNWMIMETypeImageGIF;
          qword_1EDCE29F8 = 0;
          unk_1EDCE2A00 = "GIF89a";
          qword_1EDCE2A08 = 6;
          unk_1EDCE2A10 = kNWMIMETypeImageGIF;
          qword_1EDCE2A18 = 0;
          unk_1EDCE2A20 = "\x89PNG\r\n\x1A\n";
          qword_1EDCE2A28 = 8;
          unk_1EDCE2A30 = kNWMIMETypeImagePNG;
          qword_1EDCE2A38 = 0;
          unk_1EDCE2A40 = "\xFF\xD8\xFF";
          qword_1EDCE2A48 = 3;
          unk_1EDCE2A50 = kNWMIMETypeImageJPEG;
          qword_1EDCE2A58 = 0;
          unk_1EDCE2A60 = "BM";
          qword_1EDCE2A68 = 2;
          unk_1EDCE2A70 = kNWMIMETypeImageBMP;
          qword_1EDCE2A78 = 0;
          unk_1EDCE2A80 = &unk_183BA8B5F;
          qword_1EDCE2A88 = 4;
          unk_1EDCE2A90 = kNWMIMETypeImageICO;
          qword_1EDCE2A98 = 0;
          unk_1EDCE2AA0 = 0;
          qword_1EDCE2AA8 = 0;
          unk_1EDCE2AB0 = "";
        }
        nw_http_sniffing_get_mime_type_for_rule_array(&buf, *(_QWORD *)(a2 + 520), *(_QWORD *)(a2 + 528), &sImageTypeRules(void)::rules, 0);
        v37 = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v37 = buf.__r_.__value_.__l.__size_;
        if (v4 != &buf && !v37)
        {
          v38 = *(_BYTE *)(a2 + 519);
          if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          {
            if (v38 >= 0)
              v68 = (void *)(a2 + 496);
            else
              v68 = *(void **)(a2 + 496);
            if (v38 >= 0)
              v69 = *(unsigned __int8 *)(a2 + 519);
            else
              v69 = *(_QWORD *)(a2 + 504);
            std::string::__assign_no_alias<false>((void **)&buf.__r_.__value_.__l.__data_, v68, v69);
          }
          else if ((*(_BYTE *)(a2 + 519) & 0x80) != 0)
          {
            std::string::__assign_no_alias<true>(&buf, *(void **)(a2 + 496), *(_QWORD *)(a2 + 504));
          }
          else
          {
            *(_OWORD *)&buf.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
            buf.__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 512);
          }
        }
        goto LABEL_12;
      case 3:
        goto LABEL_11;
      default:
        goto LABEL_16;
    }
  }
  __nwlog_obj();
  LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
  v72 = (char *)_os_log_send_and_compose_impl();
  __dst.__r_.__value_.__s.__data_[0] = 16;
  v82 = 0;
  if (__nwlog_fault(v72, &__dst, &v82))
  {
    if (__dst.__r_.__value_.__s.__data_[0] == 17)
    {
      v73 = __nwlog_obj();
      v74 = __dst.__r_.__value_.__s.__data_[0];
      if (os_log_type_enabled(v73, (os_log_type_t)__dst.__r_.__value_.__s.__data_[0]))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
        v75 = "%{public}s called with null http_sniffing";
LABEL_239:
        _os_log_impl(&dword_182FBE000, v73, v74, v75, (uint8_t *)&buf, 0xCu);
      }
    }
    else if (v82)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v73 = __nwlog_obj();
      v74 = __dst.__r_.__value_.__s.__data_[0];
      v77 = os_log_type_enabled(v73, (os_log_type_t)__dst.__r_.__value_.__s.__data_[0]);
      if (backtrace_string)
      {
        if (v77)
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)backtrace_string;
          _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s called with null http_sniffing, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_240;
      }
      if (v77)
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
        v75 = "%{public}s called with null http_sniffing, no backtrace";
        goto LABEL_239;
      }
    }
    else
    {
      v73 = __nwlog_obj();
      v74 = __dst.__r_.__value_.__s.__data_[0];
      if (os_log_type_enabled(v73, (os_log_type_t)__dst.__r_.__value_.__s.__data_[0]))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"nw_http_sniffing_guess_media_type";
        v75 = "%{public}s called with null http_sniffing, backtrace limit exceeded";
        goto LABEL_239;
      }
    }
  }
LABEL_240:
  if (v72)
    free(v72);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
}

void nw_http_sniffing_copy_mime_type_for_unknown(std::string *a1, uint64_t a2)
{
  unsigned __int8 v4;
  unint64_t v5;
  const void *v6;
  size_t v7;
  size_t v8;
  unsigned __int8 v9;
  unint64_t v10;
  unsigned __int8 v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int v19;
  BOOL v21;
  int v22;
  BOOL v23;
  char v24;
  uint64_t v26;
  uint64_t v27;
  std::string *v28;
  std::string v29;

  if (*(_QWORD *)(a2 + 520) == *(_QWORD *)(a2 + 528))
  {
    v6 = (const void *)kNWMIMETypeTextPlain;
    v7 = strlen((const char *)kNWMIMETypeTextPlain);
    if (v7 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v8 = v7;
    if (v7 >= 0x17)
    {
      v26 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17)
        v26 = v7 | 7;
      v27 = v26 + 1;
      v28 = (std::string *)operator new(v26 + 1);
      a1->__r_.__value_.__l.__size_ = v8;
      a1->__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
      a1->__r_.__value_.__r.__words[0] = (std::string::size_type)v28;
      a1 = v28;
    }
    else
    {
      *((_BYTE *)&a1->__r_.__value_.__s + 23) = v7;
      if (!v7)
        goto LABEL_62;
    }
    memmove(a1, v6, v8);
LABEL_62:
    a1->__r_.__value_.__s.__data_[v8] = 0;
    return;
  }
  {
    sScriptableTypeRules(void)::rules = (uint64_t)"\xFF\xFF\xDF\xDF\xDF\xDF\xDF\xDF\xDF\xFF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF0EC0 = "<!DOCTYPE HTML ";
    qword_1EDCF0EC8 = 15;
    unk_1EDCF0ED0 = kNWMIMETypeTextHTML;
    qword_1EDCF0ED8 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF0EE0 = "<HTML ";
    qword_1EDCF0EE8 = 6;
    unk_1EDCF0EF0 = kNWMIMETypeTextHTML;
    qword_1EDCF0EF8 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF0F00 = "<HEAD ";
    qword_1EDCF0F08 = 6;
    unk_1EDCF0F10 = kNWMIMETypeTextHTML;
    qword_1EDCF0F18 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF0F20 = "<SCRIPT ";
    qword_1EDCF0F28 = 8;
    unk_1EDCF0F30 = kNWMIMETypeTextHTML;
    qword_1EDCF0F38 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF0F40 = "<IFRAME ";
    qword_1EDCF0F48 = 8;
    unk_1EDCF0F50 = kNWMIMETypeTextHTML;
    qword_1EDCF0F58 = (uint64_t)"\xFF\xDF\xDF\xFF";
    unk_1EDCF0F60 = "<H1 ";
    qword_1EDCF0F68 = 4;
    unk_1EDCF0F70 = kNWMIMETypeTextHTML;
    qword_1EDCF0F78 = (uint64_t)"\xFF\xDF\xDF\xDF\xFF";
    unk_1EDCF0F80 = "<DIV ";
    qword_1EDCF0F88 = 5;
    unk_1EDCF0F90 = kNWMIMETypeTextHTML;
    qword_1EDCF0F98 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF0FA0 = "<FONT ";
    qword_1EDCF0FA8 = 6;
    unk_1EDCF0FB0 = kNWMIMETypeTextHTML;
    qword_1EDCF0FB8 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF0FC0 = "<TABLE ";
    qword_1EDCF0FC8 = 7;
    unk_1EDCF0FD0 = kNWMIMETypeTextHTML;
    qword_1EDCF0FD8 = (uint64_t)"\xFF\xDF\xFF";
    unk_1EDCF0FE0 = "<A ";
    qword_1EDCF0FE8 = 3;
    unk_1EDCF0FF0 = kNWMIMETypeTextHTML;
    qword_1EDCF0FF8 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF1000 = "<STYLE ";
    qword_1EDCF1008 = 7;
    unk_1EDCF1010 = kNWMIMETypeTextHTML;
    qword_1EDCF1018 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF1020 = "<TITLE ";
    qword_1EDCF1028 = 7;
    unk_1EDCF1030 = kNWMIMETypeTextHTML;
    qword_1EDCF1038 = (uint64_t)"\xFF\xDF\xFF";
    unk_1EDCF1040 = "<B ";
    qword_1EDCF1048 = 3;
    unk_1EDCF1050 = kNWMIMETypeTextHTML;
    qword_1EDCF1058 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xFF";
    unk_1EDCF1060 = "<BODY ";
    qword_1EDCF1068 = 6;
    unk_1EDCF1070 = kNWMIMETypeTextHTML;
    qword_1EDCF1078 = (uint64_t)"\xFF\xDF\xDF\xFF";
    unk_1EDCF1080 = "<BR ";
    qword_1EDCF1088 = 4;
    unk_1EDCF1090 = kNWMIMETypeTextHTML;
    qword_1EDCF1098 = (uint64_t)"\xFF\xDF\xFF";
    unk_1EDCF10A0 = "<P ";
    qword_1EDCF10A8 = 3;
    unk_1EDCF10B0 = kNWMIMETypeTextHTML;
    qword_1EDCF10B8 = 0;
    qword_1EDCF10C0 = (uint64_t)"<!--";
    qword_1EDCF10C8 = 4;
    qword_1EDCF10D0 = kNWMIMETypeTextHTML;
    qword_1EDCF10D8 = (uint64_t)"\xFF\xDF\xDF\xDF\xDF\xFF";
    qword_1EDCF10E0 = (uint64_t)"<META ";
    qword_1EDCF10E8 = 6;
    qword_1EDCF10F0 = kNWMIMETypeTextHTML;
    qword_1EDCF10F8 = 0;
    qword_1EDCF1100 = (uint64_t)"<?xml";
    qword_1EDCF1108 = 5;
    qword_1EDCF1110 = (uint64_t)"text/xml";
    qword_1EDCF1118 = 0;
    qword_1EDCF1120 = (uint64_t)"%PDF-";
    qword_1EDCF1128 = 5;
    qword_1EDCF1130 = (uint64_t)"application/pdf";
    qword_1EDCF1148 = 0;
    xmmword_1EDCF1138 = 0u;
    qword_1EDCF1150 = (uint64_t)"";
  }
  nw_http_sniffing_get_mime_type_for_rule_array(a1, *(_QWORD *)(a2 + 520), *(_QWORD *)(a2 + 528), &sScriptableTypeRules(void)::rules, 1);
  LODWORD(v5) = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
  if ((v5 & 0x80000000) != 0)
  {
    if (a1->__r_.__value_.__l.__size_)
    {
LABEL_5:
      if ((v5 & 0x80) == 0)
        goto LABEL_6;
      goto LABEL_21;
    }
  }
  else if (*((_BYTE *)&a1->__r_.__value_.__s + 23))
  {
    goto LABEL_5;
  }
  {
    sNonScriptableTypeRules(void)::rules = 0;
    *(_QWORD *)algn_1EDCF1168 = "%!PS-Adobe-";
    qword_1EDCF1170 = 11;
    unk_1EDCF1178 = "application/postscript";
    qword_1EDCF1180 = (uint64_t)&unk_183BA8B46;
    unk_1EDCF1188 = &unk_183BA8B4B;
    qword_1EDCF1190 = 4;
    unk_1EDCF1198 = kNWMIMETypeTextPlain;
    qword_1EDCF11A0 = (uint64_t)&unk_183BA8B46;
    unk_1EDCF11A8 = &unk_183BA8B50;
    qword_1EDCF11B0 = 4;
    unk_1EDCF11B8 = kNWMIMETypeTextPlain;
    qword_1EDCF11C0 = (uint64_t)&unk_183BA8B55;
    unk_1EDCF11C8 = &unk_183BA8B5A;
    qword_1EDCF11D0 = 4;
    unk_1EDCF11D8 = kNWMIMETypeTextPlain;
    qword_1EDCF11E0 = 0;
    unk_1EDCF11E8 = &unk_183BA7990;
    qword_1EDCF11F0 = 7;
    unk_1EDCF11F8 = "application/x-rar-compressed";
    qword_1EDCF1200 = 0;
    unk_1EDCF1208 = "PK\x03\x04";
    qword_1EDCF1210 = 4;
    unk_1EDCF1218 = "application/zip";
    qword_1EDCF1220 = 0;
    unk_1EDCF1228 = "\x1F\x8B\b";
    qword_1EDCF1230 = 3;
    unk_1EDCF1238 = "application/x-gzip";
    qword_1EDCF1240 = 0;
    unk_1EDCF1248 = 0;
    qword_1EDCF1250 = 0;
    unk_1EDCF1258 = "";
  }
  nw_http_sniffing_get_mime_type_for_rule_array(&v29, *(_QWORD *)(a2 + 520), *(_QWORD *)(a2 + 528), &sNonScriptableTypeRules(void)::rules, 1);
  if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
    operator delete(a1->__r_.__value_.__l.__data_);
  *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&v29.__r_.__value_.__l.__data_;
  v10 = v29.__r_.__value_.__r.__words[2];
  a1->__r_.__value_.__r.__words[2] = v29.__r_.__value_.__r.__words[2];
  v5 = HIBYTE(v10);
  if ((v5 & 0x80) == 0)
  {
LABEL_6:
    if ((_BYTE)v5)
      goto LABEL_7;
    goto LABEL_22;
  }
LABEL_21:
  if (a1->__r_.__value_.__l.__size_)
  {
LABEL_7:
    if ((v5 & 0x80) == 0)
      goto LABEL_8;
    goto LABEL_26;
  }
LABEL_22:
  {
    sImageTypeRules(void)::rules = 0;
    unk_1EDCE29E0 = "GIF87a";
    qword_1EDCE29E8 = 6;
    unk_1EDCE29F0 = kNWMIMETypeImageGIF;
    qword_1EDCE29F8 = 0;
    unk_1EDCE2A00 = "GIF89a";
    qword_1EDCE2A08 = 6;
    unk_1EDCE2A10 = kNWMIMETypeImageGIF;
    qword_1EDCE2A18 = 0;
    unk_1EDCE2A20 = "\x89PNG\r\n\x1A\n";
    qword_1EDCE2A28 = 8;
    unk_1EDCE2A30 = kNWMIMETypeImagePNG;
    qword_1EDCE2A38 = 0;
    unk_1EDCE2A40 = "\xFF\xD8\xFF";
    qword_1EDCE2A48 = 3;
    unk_1EDCE2A50 = kNWMIMETypeImageJPEG;
    qword_1EDCE2A58 = 0;
    unk_1EDCE2A60 = "BM";
    qword_1EDCE2A68 = 2;
    unk_1EDCE2A70 = kNWMIMETypeImageBMP;
    qword_1EDCE2A78 = 0;
    unk_1EDCE2A80 = &unk_183BA8B5F;
    qword_1EDCE2A88 = 4;
    unk_1EDCE2A90 = kNWMIMETypeImageICO;
    qword_1EDCE2A98 = 0;
    unk_1EDCE2AA0 = 0;
    qword_1EDCE2AA8 = 0;
    unk_1EDCE2AB0 = "";
  }
  nw_http_sniffing_get_mime_type_for_rule_array(&v29, *(_QWORD *)(a2 + 520), *(_QWORD *)(a2 + 528), &sImageTypeRules(void)::rules, 1);
  if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
    operator delete(a1->__r_.__value_.__l.__data_);
  *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&v29.__r_.__value_.__l.__data_;
  v12 = v29.__r_.__value_.__r.__words[2];
  a1->__r_.__value_.__r.__words[2] = v29.__r_.__value_.__r.__words[2];
  v5 = HIBYTE(v12);
  if ((v5 & 0x80) == 0)
  {
LABEL_8:
    if ((_BYTE)v5)
      goto LABEL_9;
    goto LABEL_27;
  }
LABEL_26:
  if (a1->__r_.__value_.__l.__size_)
  {
LABEL_9:
    if ((v5 & 0x80) == 0)
      goto LABEL_10;
LABEL_30:
    if (a1->__r_.__value_.__l.__size_)
      goto LABEL_53;
    goto LABEL_31;
  }
LABEL_27:
  nw_http_sniffing_get_mime_type_for_complex_nonscriptable_type_rules((uint64_t)&v29, a2);
  if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
    operator delete(a1->__r_.__value_.__l.__data_);
  *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&v29.__r_.__value_.__l.__data_;
  v13 = v29.__r_.__value_.__r.__words[2];
  a1->__r_.__value_.__r.__words[2] = v29.__r_.__value_.__r.__words[2];
  v5 = HIBYTE(v13);
  if ((v5 & 0x80) != 0)
    goto LABEL_30;
LABEL_10:
  if ((_BYTE)v5)
    goto LABEL_53;
LABEL_31:
  v14 = *(_QWORD *)(a2 + 520);
  v15 = *(_QWORD *)(a2 + 528);
  if (v14 == v15)
    goto LABEL_52;
  v16 = v15 - v14;
  if (v16 >= 0x200)
    v16 = 512;
  if (!v16)
    goto LABEL_52;
  v17 = v16 + v14 - 1;
  v18 = v14 + 1;
  do
  {
    v19 = *(unsigned __int8 *)(v18 - 1);
    v21 = v19 >= 9 && v19 != 11 && v19 - 14 >= 0xD;
    v22 = v19 & 0xFC;
    v23 = !v21 || v22 == 28;
    v24 = v23;
    if (v23)
      break;
  }
  while (v18++ <= v17);
  if ((v24 & 1) == 0)
  {
LABEL_52:
    std::string::__assign_external(a1, (const std::string::value_type *)kNWMIMETypeTextPlain);
    LOBYTE(v5) = *((_BYTE *)&a1->__r_.__value_.__s + 23);
  }
LABEL_53:
  if ((v5 & 0x80) != 0)
  {
    if (!a1->__r_.__value_.__l.__size_)
LABEL_57:
      std::string::__assign_external(a1, "application/octet-stream", 0x18uLL);
  }
  else if (!(_BYTE)v5)
  {
    goto LABEL_57;
  }
}

void mime_type_to_class(void)
{
  unsigned __int8 v0;
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  void *v13[2];
  char v14;
  void *v15[2];
  char v16;
  void *v17[2];
  char v18;
  void *v19[2];
  char v20;
  void *v21[2];
  char v22;
  void *v23[2];
  char v24;
  void *v25[2];
  char v26;
  void *v27[2];
  char v28;
  void *v29[2];
  char v30;
  void *v31[2];
  char v32;
  void *v33[2];
  char v34;
  void *__p[2];
  char v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  {
    v12 = 0;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v13, (char *)kNWMIMETypeTextHTML, &v12);
    v11 = 0;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v15, (char *)kNWMIMETypeApplicationXML, &v11);
    v10 = 0;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v17, (char *)kNWMIMETypeApplicationXML, &v10);
    v9 = 1;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v19, (char *)kNWMIMETypeTextPlain, &v9);
    v8 = 2;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v21, (char *)kNWMIMETypeImageJPEG, &v8);
    v7 = 2;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v23, (char *)kNWMIMETypeImageGIF, &v7);
    v6 = 2;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v25, (char *)kNWMIMETypeImagePNG, &v6);
    v5 = 2;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v27, (char *)kNWMIMETypeImageICO, &v5);
    v4 = 2;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v29, (char *)kNWMIMETypeImageBMP, &v4);
    v3 = 3;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v31, (char *)kNWMIMETypeUnknownUnknown, &v3);
    v2 = 3;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(v33, (char *)kNWMIMETypeApplicationUnknown, &v2);
    v1 = 3;
    std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(__p, (char *)kNWMIMETypeAsteriskAsterisk, &v1);
    mime_type_to_class(void)::instance = 0u;
    *(_OWORD *)&qword_1EDCE36E8 = 0u;
    dword_1EDCE36F8 = 1065353216;
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v13, (uint64_t)v13);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v15, (uint64_t)v15);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v17, (uint64_t)v17);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v19, (uint64_t)v19);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v21, (uint64_t)v21);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v23, (uint64_t)v23);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v25, (uint64_t)v25);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v27, (uint64_t)v27);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v29, (uint64_t)v29);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v31, (uint64_t)v31);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)v33, (uint64_t)v33);
    std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>((uint64_t)__p, (uint64_t)__p);
    if (v36 < 0)
    {
      operator delete(__p[0]);
      if ((v34 & 0x80000000) == 0)
      {
LABEL_6:
        if ((v32 & 0x80000000) == 0)
          goto LABEL_7;
        goto LABEL_19;
      }
    }
    else if ((v34 & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(v33[0]);
    if ((v32 & 0x80000000) == 0)
    {
LABEL_7:
      if ((v30 & 0x80000000) == 0)
        goto LABEL_8;
      goto LABEL_20;
    }
LABEL_19:
    operator delete(v31[0]);
    if ((v30 & 0x80000000) == 0)
    {
LABEL_8:
      if ((v28 & 0x80000000) == 0)
        goto LABEL_9;
      goto LABEL_21;
    }
LABEL_20:
    operator delete(v29[0]);
    if ((v28 & 0x80000000) == 0)
    {
LABEL_9:
      if ((v26 & 0x80000000) == 0)
        goto LABEL_10;
      goto LABEL_22;
    }
LABEL_21:
    operator delete(v27[0]);
    if ((v26 & 0x80000000) == 0)
    {
LABEL_10:
      if ((v24 & 0x80000000) == 0)
        goto LABEL_11;
      goto LABEL_23;
    }
LABEL_22:
    operator delete(v25[0]);
    if ((v24 & 0x80000000) == 0)
    {
LABEL_11:
      if ((v22 & 0x80000000) == 0)
        goto LABEL_12;
      goto LABEL_24;
    }
LABEL_23:
    operator delete(v23[0]);
    if ((v22 & 0x80000000) == 0)
    {
LABEL_12:
      if ((v20 & 0x80000000) == 0)
        goto LABEL_13;
      goto LABEL_25;
    }
LABEL_24:
    operator delete(v21[0]);
    if ((v20 & 0x80000000) == 0)
    {
LABEL_13:
      if ((v18 & 0x80000000) == 0)
        goto LABEL_14;
      goto LABEL_26;
    }
LABEL_25:
    operator delete(v19[0]);
    if ((v18 & 0x80000000) == 0)
    {
LABEL_14:
      if ((v16 & 0x80000000) == 0)
        goto LABEL_15;
      goto LABEL_27;
    }
LABEL_26:
    operator delete(v17[0]);
    if ((v16 & 0x80000000) == 0)
    {
LABEL_15:
      if ((v14 & 0x80000000) == 0)
      {
LABEL_16:
        return;
      }
LABEL_28:
      operator delete(v13[0]);
      goto LABEL_16;
    }
LABEL_27:
    operator delete(v15[0]);
    if ((v14 & 0x80000000) == 0)
      goto LABEL_16;
    goto LABEL_28;
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::find<std::string>(uint64_t a1)
{
  int v1;
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *result;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v1 = *(char *)(a1 + 23);
  if (v1 >= 0)
    v2 = (uint64_t *)a1;
  else
    v2 = *(uint64_t **)a1;
  if (v1 >= 0)
    v3 = *(unsigned __int8 *)(a1 + 23);
  else
    v3 = *(_QWORD *)(a1 + 8);
  v4 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v2, v3);
  v5 = *((_QWORD *)&mime_type_to_class(void)::instance + 1);
  if (*((_QWORD *)&mime_type_to_class(void)::instance + 1))
  {
    v6 = v4;
    v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&mime_type_to_class(void)::instance + 8));
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = v4;
      if (v4 >= *((_QWORD *)&mime_type_to_class(void)::instance + 1))
        v8 = v4 % *((_QWORD *)&mime_type_to_class(void)::instance + 1);
    }
    else
    {
      v8 = (*((_QWORD *)&mime_type_to_class(void)::instance + 1) - 1) & v4;
    }
    v9 = *(uint64_t ***)(mime_type_to_class(void)::instance + 8 * v8);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        if (v7.u32[0] < 2uLL)
        {
          v11 = *((_QWORD *)&mime_type_to_class(void)::instance + 1) - 1;
          while (1)
          {
            v17 = v10[1];
            if (v6 == v17)
            {
              v18 = *((unsigned __int8 *)v10 + 39);
              if ((v18 & 0x80u) == 0)
                v19 = *((unsigned __int8 *)v10 + 39);
              else
                v19 = v10[3];
              if (v19 == v3)
              {
                if ((v18 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v10[2], v2, v10[3]))
                    return v10;
                }
                else
                {
                  if (!*((_BYTE *)v10 + 39))
                    return v10;
                  v20 = 0;
                  while (*((unsigned __int8 *)v10 + v20 + 16) == *((unsigned __int8 *)v2 + v20))
                  {
                    if (v18 == ++v20)
                      return v10;
                  }
                }
              }
            }
            else if ((v17 & v11) != v8)
            {
              return 0;
            }
            result = 0;
            v10 = (uint64_t *)*v10;
            if (!v10)
              return result;
          }
        }
        while (1)
        {
          v13 = v10[1];
          if (v6 == v13)
          {
            v14 = *((unsigned __int8 *)v10 + 39);
            if ((v14 & 0x80u) == 0)
              v15 = *((unsigned __int8 *)v10 + 39);
            else
              v15 = v10[3];
            if (v15 == v3)
            {
              if ((v14 & 0x80) != 0)
              {
                if (!memcmp((const void *)v10[2], v2, v10[3]))
                  return v10;
              }
              else
              {
                if (!*((_BYTE *)v10 + 39))
                  return v10;
                v16 = 0;
                while (*((unsigned __int8 *)v10 + v16 + 16) == *((unsigned __int8 *)v2 + v16))
                {
                  if (v14 == ++v16)
                    return v10;
                }
              }
            }
          }
          else
          {
            if (v13 >= v5)
              v13 %= v5;
            if (v13 != v8)
              return 0;
          }
          result = 0;
          v10 = (uint64_t *)*v10;
          if (!v10)
            return result;
        }
      }
    }
  }
  return 0;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

_QWORD *std::string::__assign_no_alias<true>(_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len > 0x16)
  {
    if (__len - 0x7FFFFFFFFFFFFFF7 <= 0x800000000000001ELL)
      abort();
    v7 = 44;
    if (__len > 0x2C)
      v7 = __len;
    v8 = (v7 | 7) + 1;
    v6 = operator new(v8);
    memcpy(v6, __src, __len);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (__len)
    {
      memmove(__dst, __src, __len);
      v6 = __dst;
    }
  }
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

std::string *nw_http_sniffing_get_mime_type_for_rule_array(std::string *result, uint64_t a2, uint64_t a3, uint64_t *a4, char a5)
{
  unint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t *v11;
  char v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  int v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;

  result->__r_.__value_.__r.__words[0] = 0;
  result->__r_.__value_.__l.__size_ = 0;
  result->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    v5 = 512;
    if ((unint64_t)(a3 - a2) < 0x200)
      v5 = a3 - a2;
    v6 = (_BYTE *)a4[1];
    if (v6)
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      if ((a5 & 1) != 0)
      {
        v10 = 0;
        v11 = a4;
        while (1)
        {
          v14 = a4[4 * v7 + 2];
          if (v5 >= v14)
          {
            v15 = *v6;
            if (v15 != 60)
            {
              v16 = a2;
              if (!v14)
                goto LABEL_8;
              goto LABEL_19;
            }
            if ((v10 & 1) != 0)
            {
              if (!v9)
                goto LABEL_37;
            }
            else
            {
              if (!v5)
                goto LABEL_36;
              v20 = 0;
              while (1)
              {
                v9 = a2 + v20;
                if (*(char *)(a2 + v20) > 0x20 || ((1 << *(_BYTE *)(a2 + v20)) & 0x100003600) == 0)
                  break;
                if (v5 == ++v20)
                  goto LABEL_36;
              }
              if (*(_BYTE *)(a2 + v20) != 60)
              {
LABEL_36:
                v9 = 0;
LABEL_37:
                v10 = 1;
                goto LABEL_10;
              }
              v8 = v5 - v20;
            }
            v10 = 1;
            v16 = v9;
            if (v8 >= v14)
            {
              if (!v14)
              {
LABEL_8:
                v13 = 0;
                goto LABEL_9;
              }
LABEL_19:
              v17 = *v11;
              if (*v11)
              {
                if (v15 == 60)
                {
                  v13 = 0;
                  while (1)
                  {
                    v18 = (*(_BYTE *)(v17 + v13) & *(_BYTE *)(v16 + v13));
                    v19 = v6[v13];
                    if (v18 != v19 && (v14 - 1 != v13 || v19 != 32 || v18 != 62 && v18 != 32))
                      break;
                    if (v14 == ++v13)
                      return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                  }
                }
                else
                {
                  v13 = 0;
                  while ((*(_BYTE *)(v17 + v13) & *(_BYTE *)(v16 + v13)) == v6[v13])
                  {
                    if (v14 == ++v13)
                      return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                  }
                }
              }
              else if (v15 == 60)
              {
                v13 = 0;
                while (1)
                {
                  v22 = *(unsigned __int8 *)(v16 + v13);
                  v23 = v6[v13];
                  if (v22 != v23 && (v14 - 1 != v13 || v23 != 32 || v22 != 62 && v22 != 32))
                    break;
                  if (v14 == ++v13)
                    return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                }
              }
              else
              {
                v13 = 0;
                while (*(unsigned __int8 *)(v16 + v13) == v6[v13])
                {
                  if (v14 == ++v13)
                    return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
                }
              }
LABEL_9:
              if (v13 == v14)
                return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
            }
          }
LABEL_10:
          ++v7;
          v11 = &a4[4 * v7];
          v6 = (_BYTE *)v11[1];
          if (!v6)
            return result;
        }
      }
      v12 = 0;
      do
      {
        v24 = a4[4 * v7 + 2];
        if (v5 >= v24)
        {
          if (*v6 == 60)
          {
            if ((v12 & 1) != 0)
            {
              if (!v9 || v8 < v24)
                goto LABEL_86;
            }
            else
            {
              if (!v5)
                goto LABEL_85;
              v28 = 0;
              while (1)
              {
                v9 = a2 + v28;
                if (*(char *)(a2 + v28) > 0x20 || ((1 << *(_BYTE *)(a2 + v28)) & 0x100003600) == 0)
                  break;
                if (v5 == ++v28)
                  goto LABEL_85;
              }
              if (*(_BYTE *)(a2 + v28) != 60)
              {
LABEL_85:
                v9 = 0;
LABEL_86:
                v12 = 1;
                goto LABEL_59;
              }
              v8 = v5 - v28;
              if (v5 - v28 < v24)
                goto LABEL_86;
            }
            v25 = 0;
            if (v24)
            {
              while (1)
              {
                v26 = *(unsigned __int8 *)(v9 + v25);
                v27 = v6[v25];
                if (v26 != v27)
                {
                  v12 = 1;
                  if (v24 - 1 != v25 || v27 != 32 || v26 != 62 && v26 != 32)
                    break;
                }
                if (v24 == ++v25)
                  return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
              }
            }
            else
            {
              v12 = 1;
            }
          }
          else
          {
            v25 = 0;
            if (v24)
            {
              while (*(unsigned __int8 *)(a2 + v25) == v6[v25])
              {
                if (v24 == ++v25)
                  return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
              }
            }
          }
          if (v25 == v24)
            return std::string::__assign_external(result, (const std::string::value_type *)a4[4 * v7 + 3]);
        }
LABEL_59:
        ++v7;
        v6 = (_BYTE *)a4[4 * v7 + 1];
      }
      while (v6);
    }
  }
  return result;
}

uint64_t nw_http_sniffing_get_mime_type_for_complex_nonscriptable_type_rules(uint64_t result, uint64_t a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  unint64_t v4;
  BOOL v5;
  int v6;
  BOOL v7;
  _BOOL4 v8;
  int v9;
  BOOL v10;
  int v11;
  const char *v12;
  char v13;
  const char *v14;
  const char *v15;
  int v19;
  unsigned int v20;

  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  v2 = *(unsigned __int16 **)(a2 + 520);
  v3 = *(unsigned __int16 **)(a2 + 528);
  if (v2 == v3)
    return result;
  v4 = (char *)v3 - (char *)v2;
  if (v4 >= 0x200)
    v4 = 512;
  if (v4 < 4)
  {
    v6 = 0;
    goto LABEL_13;
  }
  v5 = *v2 == 17481 && *((_BYTE *)v2 + 2) == 51;
  if (v5 && *((char *)v2 + 3) <= 31)
  {
    v6 = 10;
    *(_BYTE *)(result + 23) = 10;
    *(_WORD *)(result + 8) = 26469;
    *(_QWORD *)result = *(_QWORD *)"audio/mpeg";
LABEL_13:
    v7 = v4 > 7;
    goto LABEL_14;
  }
  if (v4 < 8)
  {
    v7 = 0;
    v6 = 0;
    goto LABEL_42;
  }
  if (*((_DWORD *)v2 + 1) == 1987014509 || *((_DWORD *)v2 + 1) == 1952539757 || *((_DWORD *)v2 + 1) == 1701079415)
  {
    v6 = 15;
    *(_BYTE *)(result + 23) = 15;
    qmemcpy((void *)result, "video/quicktime", 15);
    goto LABEL_66;
  }
  v6 = 0;
  v7 = 1;
LABEL_14:
  v8 = v4 > 0xB;
  v9 = v6;
  if (v6 || v4 < 0xC)
    goto LABEL_20;
  if (*(_BYTE *)v2 || *((_BYTE *)v2 + 1) || *((_DWORD *)v2 + 1) != 1887007846)
    goto LABEL_19;
  if (v2[4] == 28781 && *((_BYTE *)v2 + 10) == 52)
  {
    if (*((unsigned __int8 *)v2 + 11) - 49 <= 1)
    {
LABEL_107:
      v6 = 9;
      *(_BYTE *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 52;
      v14 = "video/mp4";
      goto LABEL_65;
    }
LABEL_19:
    v9 = 0;
    v8 = 1;
    goto LABEL_20;
  }
  if (v2[4] == 29545 && *((_BYTE *)v2 + 10) == 111)
  {
    v19 = *((unsigned __int8 *)v2 + 11);
    if (v19 == 109 || v19 == 50)
      goto LABEL_107;
    goto LABEL_19;
  }
  if (v2[4] != 13389 || *((_BYTE *)v2 + 10) != 86)
  {
    if (*((_DWORD *)v2 + 2) == 541144141)
    {
      v6 = 9;
      *(_BYTE *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 52;
      v14 = "audio/mp4";
      goto LABEL_65;
    }
    if (v2[4] == 26419)
    {
      if (v2[5] == 24882)
      {
        v6 = 11;
        *(_BYTE *)(result + 23) = 11;
        *(_DWORD *)(result + 7) = 846229607;
        v15 = "video/3gpp2";
        goto LABEL_75;
      }
      if (*((unsigned __int8 *)v2 + 10) - 101 <= 0xE
        && (*((_BYTE *)v2 + 11) & 0xFC) == 0x34
        && (v2[5] == 13925
         || v2[5] == 14181
         || v2[5] == 13927
         || v2[5] == 13424
         || v2[5] == 13680
         || v2[5] == 13936
         || v2[5] == 13938
         || v2[5] == 13939
         || v2[5] == 14195))
      {
        v6 = 10;
        *(_BYTE *)(result + 23) = 10;
        *(_WORD *)(result + 8) = 28784;
        v12 = "video/3gpp";
        goto LABEL_35;
      }
    }
    goto LABEL_19;
  }
  v9 = 0;
  v8 = 1;
  v20 = *((unsigned __int8 *)v2 + 11) - 32;
  if (v20 <= 0x30 && ((1 << v20) & 0x1010000000001) != 0)
  {
    v6 = 9;
    *(_BYTE *)(result + 23) = 9;
    *(_WORD *)(result + 8) = 118;
    v14 = "video/m4v";
    goto LABEL_65;
  }
LABEL_20:
  if (v9 || !v8)
    goto LABEL_24;
  if (*(_DWORD *)v2 == 1179011410)
  {
    if (*((_DWORD *)v2 + 2) == 1163280727)
    {
      v6 = 9;
      *(_BYTE *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 118;
      v14 = "audio/wav";
    }
    else
    {
      if (*((_DWORD *)v2 + 2) != 541677121)
        goto LABEL_23;
      v6 = 9;
      *(_BYTE *)(result + 23) = 9;
      *(_WORD *)(result + 8) = 105;
      v14 = "video/avi";
    }
LABEL_65:
    *(_QWORD *)result = *(_QWORD *)v14;
    goto LABEL_66;
  }
LABEL_23:
  v8 = 1;
LABEL_24:
  if (v6
    || !v8
    || *(_DWORD *)v2 != 1297239878
    || (v2[4] == 18753 ? (v10 = *((_BYTE *)v2 + 10) == 70) : (v10 = 0),
        !v10 || (v11 = *((unsigned __int8 *)v2 + 11), v11 != 70) && v11 != 67))
  {
LABEL_42:
    if (v6 || v4 < 5 || *((_BYTE *)v2 + 3) || *((_BYTE *)v2 + 4))
      goto LABEL_46;
    if (*((_BYTE *)v2 + 1))
    {
      if (*((_BYTE *)v2 + 1) == 1 && (v2[1] & 0xF7) == 1)
        goto LABEL_74;
    }
    else if ((v2[1] & 0xF6) == 2)
    {
LABEL_74:
      v6 = 11;
      *(_BYTE *)(result + 23) = 11;
      *(_DWORD *)(result + 7) = 1634169441;
      v15 = "image/targa";
LABEL_75:
      *(_QWORD *)result = *(_QWORD *)v15;
      *(_BYTE *)(result + 11) = 0;
      goto LABEL_66;
    }
LABEL_46:
    v13 = !v7;
    if (v6)
      v13 = 1;
    if ((v13 & 1) == 0 && (*((_DWORD *)v2 + 1) == 1668506729 || *((_DWORD *)v2 + 1) == 1952539753))
    {
      v6 = 17;
      *(_BYTE *)(result + 23) = 17;
      strcpy((char *)result, "image/x-quicktime");
    }
    else if (!v6 && v4 >= 2 && *v2 == 759)
    {
      v6 = 17;
      *(_BYTE *)(result + 23) = 17;
      strcpy((char *)result, "application/x-dvi");
    }
    goto LABEL_66;
  }
  v6 = 10;
  *(_BYTE *)(result + 23) = 10;
  *(_WORD *)(result + 8) = 26214;
  v12 = "audio/aiff";
LABEL_35:
  *(_QWORD *)result = *(_QWORD *)v12;
  *(_BYTE *)(result + 10) = 0;
LABEL_66:
  if (!v6
    && v4 >= 4
    && *v2 == 55809
    && *((unsigned __int8 *)v2 + 2) <= 1u
    && *((unsigned __int8 *)v2 + 3) - 1 <= 0xE)
  {
    *(_BYTE *)(result + 23) = 9;
    strcpy((char *)result, "image/sgi");
  }
  return result;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  void *v7;
  unint64_t v8;
  std::string *v9;
  unint64_t v10;
  size_t v11;
  std::string::size_type v12;
  uint64_t v13;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v8 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (__n > v8)
    {
      v11 = 0x7FFFFFFFFFFFFFF7;
      if (0x7FFFFFFFFFFFFFF7 - (v10 & 0x7FFFFFFFFFFFFFFFLL) >= __n - v8)
      {
        v9 = (std::string *)this->__r_.__value_.__r.__words[0];
        if (v8 > 0x3FFFFFFFFFFFFFF2)
        {
LABEL_15:
          v7 = operator new(v11);
          memcpy(v7, __s, __n);
          if (v8 != 22)
            operator delete(v9);
          this->__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
          this->__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
LABEL_23:
          this->__r_.__value_.__l.__size_ = __n;
          goto LABEL_24;
        }
LABEL_8:
        v12 = 2 * v8;
        if (__n > 2 * v8)
          v12 = __n;
        v13 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17)
          v13 = v12 | 7;
        if (v12 >= 0x17)
          v11 = v13 + 1;
        else
          v11 = 23;
        goto LABEL_15;
      }
LABEL_25:
      abort();
    }
    v6 = HIBYTE(v10);
    v7 = (void *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      if (__n - 0x7FFFFFFFFFFFFFF7 >= 0x800000000000001FLL)
      {
        v8 = 22;
        v9 = this;
        goto LABEL_8;
      }
      goto LABEL_25;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    goto LABEL_23;
  *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
LABEL_24:
  *((_BYTE *)v7 + __n) = 0;
  return this;
}

void **std::string::__assign_no_alias<false>(void **a1, void *__src, size_t __len)
{
  unint64_t v6;
  uint64_t v7;
  void *v8;
  size_t v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;

  v6 = (unint64_t)a1[2];
  v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  if ((v6 & 0x7FFFFFFFFFFFFFFFLL) <= __len)
  {
    v9 = 0x7FFFFFFFFFFFFFF7;
    if (0x7FFFFFFFFFFFFFF7 - v7 < __len - v7 + 1)
      abort();
    v10 = v7 - 1;
    v11 = a1;
    if ((v6 & 0x8000000000000000) != 0)
      v11 = *a1;
    if (v10 <= 0x3FFFFFFFFFFFFFF2)
    {
      v12 = 2 * v10;
      if (__len > 2 * v10)
        v12 = __len;
      v13 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v12 | 7) != 0x17)
        v13 = v12 | 7;
      if (v12 >= 0x17)
        v9 = v13 + 1;
      else
        v9 = 23;
    }
    v14 = operator new(v9);
    v8 = v14;
    if (__len)
      memcpy(v14, __src, __len);
    if (v10 != 22)
      operator delete(v11);
    a1[1] = (void *)__len;
    a1[2] = (void *)(v9 | 0x8000000000000000);
    *a1 = v8;
  }
  else
  {
    v8 = *a1;
    a1[1] = (void *)__len;
    if (__len)
      memmove(v8, __src, __len);
  }
  *((_BYTE *)v8 + __len) = 0;
  return a1;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;

  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      v8 = a1[2];
      v7 = a1[3];
      v9 = __ROR8__(v6 + v7, 52);
      v10 = v6 + a1[1];
      v11 = __ROR8__(v10, 7);
      v12 = v10 + v8;
      v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      v15 = __ROR8__(v14 + v13, 52);
      v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      v17 = __ROR8__(v13, 37);
      v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      v19 = __ROR8__(v18, 7);
      v20 = v16 + __ROR8__(v12, 31);
      v21 = v18 + v5;
      v22 = v21 + v14;
      v23 = 0x9AE16A3B2F90404FLL;
      v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    v32 = 0x9DDFEA08EB382D69;
    v33 = *(uint64_t *)((char *)a1 + a2 - 48);
    v34 = *(uint64_t *)((char *)a1 + a2 - 40);
    v35 = *(uint64_t *)((char *)a1 + a2 - 24);
    v37 = *(uint64_t *)((char *)a1 + a2 - 64);
    v36 = *(uint64_t *)((char *)a1 + a2 - 56);
    v38 = *(uint64_t *)((char *)a1 + a2 - 16);
    v39 = *(uint64_t *)((char *)a1 + a2 - 8);
    v40 = v36 + v38;
    v41 = 0x9DDFEA08EB382D69
        * (v35 ^ ((0x9DDFEA08EB382D69 * (v35 ^ (v33 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v35 ^ (v33 + a2))));
    v42 = 0x9DDFEA08EB382D69 * (v41 ^ (v41 >> 47));
    v43 = v37 + a2 + v36 + v33;
    v44 = v43 + v34;
    v45 = __ROR8__(v43, 44) + v37 + a2 + __ROR8__(v34 + v37 + a2 - 0x622015F714C7D297 * (v41 ^ (v41 >> 47)), 21);
    v46 = v36 + v38 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    v47 = v46 + v35 + v38;
    v48 = __ROR8__(v47, 44);
    v49 = v47 + v39;
    v50 = v48 + v46 + __ROR8__(v46 + v34 + v39, 21);
    v52 = *a1;
    v51 = a1 + 4;
    v53 = v52 - 0x4B6D499041670D8DLL * v34;
    v54 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      v55 = *(v51 - 3);
      v56 = v53 + v44 + v40 + v55;
      v57 = v51[2];
      v58 = v51[3];
      v59 = v51[1];
      v40 = v59 + v44 - 0x4B6D499041670D8DLL * __ROR8__(v40 + v45 + v57, 42);
      v60 = v42 + v49;
      v61 = *(v51 - 2);
      v62 = *(v51 - 1);
      v63 = *(v51 - 4) - 0x4B6D499041670D8DLL * v45;
      v64 = v63 + v49 + v62;
      v65 = v63 + v55 + v61;
      v44 = v65 + v62;
      v66 = __ROR8__(v65, 44) + v63;
      v67 = (0xB492B66FBE98F273 * __ROR8__(v56, 37)) ^ v50;
      v53 = 0xB492B66FBE98F273 * __ROR8__(v60, 33);
      v45 = v66 + __ROR8__(v64 + v67, 21);
      v68 = v53 + v50 + *v51;
      v49 = v68 + v59 + v57 + v58;
      v50 = __ROR8__(v68 + v59 + v57, 44) + v68 + __ROR8__(v40 + v61 + v68 + v58, 21);
      v51 += 8;
      v42 = v67;
      v54 += 64;
    }
    while (v54);
    v69 = v53
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v50 ^ ((0x9DDFEA08EB382D69 * (v50 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v50 ^ v45)))) ^ ((0x9DDFEA08EB382D69 * (v50 ^ ((0x9DDFEA08EB382D69 * (v50 ^ v45)) >> 47) ^ (0x9DDFEA08EB382D69 * (v50 ^ v45)))) >> 47));
    v70 = 0x9DDFEA08EB382D69
        * (v69 ^ (v67
                - 0x4B6D499041670D8DLL * (v40 ^ (v40 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47))));
    v71 = 0x9DDFEA08EB382D69 * (v69 ^ (v70 >> 47) ^ v70);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    v26 = a1[1];
    v27 = 0xB492B66FBE98F273 * *a1;
    v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    v23 = 0x9DDFEA08EB382D69;
    v30 = 0x9DDFEA08EB382D69 * ((v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)) ^ v29);
    v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 >= 9)
  {
    v2 = *(uint64_t *)((char *)a1 + a2 - 8);
    v3 = __ROR8__(v2 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
  }
  if (a2 >= 4)
  {
    v72 = *(unsigned int *)((char *)a1 + a2 - 4);
    v23 = 0x9DDFEA08EB382D69;
    v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
    v31 = v72 ^ (v73 >> 47) ^ v73;
    goto LABEL_8;
  }
  v32 = 0x9AE16A3B2F90404FLL;
  if (a2)
  {
    v71 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v32 *= v71 ^ (v71 >> 47);
  }
  return v32;
}

_DWORD *std::pair<std::string const,mime_type_class>::pair[abi:nn180100]<char const*&,mime_type_class,0>(_DWORD *a1, char *__s, _DWORD *a3)
{
  size_t v6;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  v6 = strlen(__s);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    v8 = operator new(v9 + 1);
    *((_QWORD *)a1 + 1) = v7;
    *((_QWORD *)a1 + 2) = v10 | 0x8000000000000000;
    *(_QWORD *)a1 = v8;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v6;
    v8 = a1;
    if (!v6)
      goto LABEL_9;
  }
  memmove(v8, __s, v7);
LABEL_9:
  *((_BYTE *)v8 + v7) = 0;
  a1[6] = *a3;
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,mime_type_class>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,mime_type_class>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,mime_type_class>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,mime_type_class>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,mime_type_class> const&>(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  int v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  uint64_t **v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void **v16;
  uint64_t *j;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void **v21;
  uint64_t *i;
  char *v23;
  std::string *v24;
  float v25;
  _BOOL8 v26;
  unint64_t v27;
  unint64_t v28;
  size_t prime;
  void *v30;
  void *v31;
  uint64_t v32;
  _QWORD **v33;
  size_t v34;
  size_t v35;
  size_t v36;
  _QWORD *k;
  size_t v38;
  uint64_t v39;
  unint64_t v40;
  uint8x8_t v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  size_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  void *v50;

  v4 = *(char *)(a1 + 23);
  if (v4 >= 0)
    v5 = (uint64_t *)a1;
  else
    v5 = *(uint64_t **)a1;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a1 + 23);
  else
    v6 = *(_QWORD *)(a1 + 8);
  v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  v8 = v7;
  v9 = *((_QWORD *)&mime_type_to_class(void)::instance + 1);
  if (*((_QWORD *)&mime_type_to_class(void)::instance + 1))
  {
    v10 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&mime_type_to_class(void)::instance + 8));
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v2 = v7;
      if (v7 >= *((_QWORD *)&mime_type_to_class(void)::instance + 1))
        v2 = v7 % *((_QWORD *)&mime_type_to_class(void)::instance + 1);
    }
    else
    {
      v2 = (*((_QWORD *)&mime_type_to_class(void)::instance + 1) - 1) & v7;
    }
    v11 = *(uint64_t ***)(mime_type_to_class(void)::instance + 8 * v2);
    if (v11)
    {
      v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            v18 = v12[1];
            if (v18 == v8)
            {
              v19 = *((unsigned __int8 *)v12 + 39);
              if ((v19 & 0x80u) == 0)
                v20 = *((unsigned __int8 *)v12 + 39);
              else
                v20 = v12[3];
              if (v20 == v6)
              {
                v21 = (const void **)(v12 + 2);
                if ((v19 & 0x80) != 0)
                {
                  if (!memcmp(*v21, v5, v12[3]))
                    return;
                }
                else
                {
                  if (!*((_BYTE *)v12 + 39))
                    return;
                  for (i = v5; *(unsigned __int8 *)v21 == *(unsigned __int8 *)i; i = (uint64_t *)((char *)i + 1))
                  {
                    v21 = (const void **)((char *)v21 + 1);
                    if (!--v19)
                      return;
                  }
                }
              }
            }
            else if ((v18 & (v9 - 1)) != v2)
            {
              goto LABEL_49;
            }
            v12 = (uint64_t *)*v12;
            if (!v12)
              goto LABEL_49;
          }
        }
        do
        {
          v13 = v12[1];
          if (v13 == v8)
          {
            v14 = *((unsigned __int8 *)v12 + 39);
            if ((v14 & 0x80u) == 0)
              v15 = *((unsigned __int8 *)v12 + 39);
            else
              v15 = v12[3];
            if (v15 == v6)
            {
              v16 = (const void **)(v12 + 2);
              if ((v14 & 0x80) != 0)
              {
                if (!memcmp(*v16, v5, v12[3]))
                  return;
              }
              else
              {
                if (!*((_BYTE *)v12 + 39))
                  return;
                for (j = v5; *(unsigned __int8 *)v16 == *(unsigned __int8 *)j; j = (uint64_t *)((char *)j + 1))
                {
                  v16 = (const void **)((char *)v16 + 1);
                  if (!--v14)
                    return;
                }
              }
            }
          }
          else
          {
            if (v13 >= v9)
              v13 %= v9;
            if (v13 != v2)
              break;
          }
          v12 = (uint64_t *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_49:
  v23 = (char *)operator new(0x30uLL);
  *(_QWORD *)v23 = 0;
  *((_QWORD *)v23 + 1) = v8;
  v24 = (std::string *)(v23 + 16);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v24, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v24->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v23 + 4) = *(_QWORD *)(a2 + 16);
  }
  *((_DWORD *)v23 + 10) = *(_DWORD *)(a2 + 24);
  v25 = (float)(unint64_t)(qword_1EDCE36F0 + 1);
  if (!v9 || (float)(*(float *)&dword_1EDCE36F8 * (float)v9) < v25)
  {
    v26 = 1;
    if (v9 >= 3)
      v26 = (v9 & (v9 - 1)) != 0;
    v27 = v26 | (2 * v9);
    v28 = vcvtps_u32_f32(v25 / *(float *)&dword_1EDCE36F8);
    if (v27 <= v28)
      prime = v28;
    else
      prime = v27;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v9 = *((_QWORD *)&mime_type_to_class(void)::instance + 1);
    if (prime <= *((_QWORD *)&mime_type_to_class(void)::instance + 1))
    {
      if (prime >= *((_QWORD *)&mime_type_to_class(void)::instance + 1))
        goto LABEL_89;
      v40 = vcvtps_u32_f32((float)(unint64_t)qword_1EDCE36F0 / *(float *)&dword_1EDCE36F8);
      if (*((_QWORD *)&mime_type_to_class(void)::instance + 1) < 3uLL
        || (v41 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&mime_type_to_class(void)::instance + 8)),
            v41.i16[0] = vaddlv_u8(v41),
            v41.u32[0] > 1uLL))
      {
        v40 = std::__next_prime(v40);
      }
      else
      {
        v42 = 1 << -(char)__clz(v40 - 1);
        if (v40 >= 2)
          v40 = v42;
      }
      if (prime <= v40)
        prime = v40;
      if (prime >= v9)
      {
        v9 = *((_QWORD *)&mime_type_to_class(void)::instance + 1);
LABEL_89:
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9)
            v2 = v8 % v9;
          else
            v2 = v8;
        }
        else
        {
          v2 = (v9 - 1) & v8;
        }
        goto LABEL_102;
      }
      if (!prime)
      {
        v50 = (void *)mime_type_to_class(void)::instance;
        *(_QWORD *)&mime_type_to_class(void)::instance = 0;
        if (v50)
          operator delete(v50);
        v9 = 0;
        *((_QWORD *)&mime_type_to_class(void)::instance + 1) = 0;
        goto LABEL_89;
      }
    }
    if (prime >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v30 = operator new(8 * prime);
    v31 = (void *)mime_type_to_class(void)::instance;
    *(_QWORD *)&mime_type_to_class(void)::instance = v30;
    if (v31)
      operator delete(v31);
    v32 = 0;
    *((_QWORD *)&mime_type_to_class(void)::instance + 1) = prime;
    do
      *(_QWORD *)(mime_type_to_class(void)::instance + 8 * v32++) = 0;
    while (prime != v32);
    v33 = (_QWORD **)qword_1EDCE36E8;
    if (!qword_1EDCE36E8)
    {
LABEL_88:
      v9 = prime;
      goto LABEL_89;
    }
    v34 = *(_QWORD *)(qword_1EDCE36E8 + 8);
    v35 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      v36 = v34 & v35;
      *(_QWORD *)(mime_type_to_class(void)::instance + 8 * v36) = &qword_1EDCE36E8;
      for (k = *v33; *v33; k = *v33)
      {
        v38 = k[1] & v35;
        if (v38 == v36)
        {
          v33 = (_QWORD **)k;
        }
        else if (*(_QWORD *)(mime_type_to_class(void)::instance + 8 * v38))
        {
          *v33 = (_QWORD *)*k;
          v39 = 8 * v38;
          *k = **(_QWORD **)(mime_type_to_class(void)::instance + v39);
          **(_QWORD **)(mime_type_to_class(void)::instance + v39) = k;
        }
        else
        {
          *(_QWORD *)(mime_type_to_class(void)::instance + 8 * v38) = v33;
          v33 = (_QWORD **)k;
          v36 = v38;
        }
      }
      goto LABEL_88;
    }
    if (v34 >= prime)
      v34 %= prime;
    *(_QWORD *)(mime_type_to_class(void)::instance + 8 * v34) = &qword_1EDCE36E8;
    v43 = *v33;
    if (!*v33)
      goto LABEL_88;
    while (1)
    {
      v45 = v43[1];
      if (v45 >= prime)
        v45 %= prime;
      if (v45 != v34)
      {
        if (!*(_QWORD *)(mime_type_to_class(void)::instance + 8 * v45))
        {
          *(_QWORD *)(mime_type_to_class(void)::instance + 8 * v45) = v33;
          goto LABEL_93;
        }
        *v33 = (_QWORD *)*v43;
        v44 = 8 * v45;
        *v43 = **(_QWORD **)(mime_type_to_class(void)::instance + v44);
        **(_QWORD **)(mime_type_to_class(void)::instance + v44) = v43;
        v43 = v33;
      }
      v45 = v34;
LABEL_93:
      v33 = (_QWORD **)v43;
      v43 = (_QWORD *)*v43;
      v34 = v45;
      if (!v43)
        goto LABEL_88;
    }
  }
LABEL_102:
  v46 = mime_type_to_class(void)::instance;
  v47 = *(_QWORD **)(mime_type_to_class(void)::instance + 8 * v2);
  if (v47)
  {
    *(_QWORD *)v23 = *v47;
LABEL_110:
    *v47 = v23;
    goto LABEL_111;
  }
  v48 = qword_1EDCE36E8;
  *(_QWORD *)v23 = qword_1EDCE36E8;
  qword_1EDCE36E8 = (uint64_t)v23;
  *(_QWORD *)(v46 + 8 * v2) = &qword_1EDCE36E8;
  if (v48)
  {
    v49 = *(_QWORD *)(v48 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v49 >= v9)
        v49 %= v9;
    }
    else
    {
      v49 &= v9 - 1;
    }
    v47 = (_QWORD *)(mime_type_to_class(void)::instance + 8 * v49);
    goto LABEL_110;
  }
LABEL_111:
  ++qword_1EDCE36F0;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

__n128 __Block_byref_object_copy__19(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

uint64_t ___ZL31nw_http_sniffing_get_media_typeP25nw_protocol_http_sniffingP20nw_protocol_metadata_block_invoke(uint64_t a1, int a2, int a3, char *__s, uint64_t a5)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  size_t v15;
  __int128 *p_dst;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  int v20;
  uint64_t v21;
  void **v22;
  __int128 *v23;
  __int128 __dst;
  int64_t v26;

  if (a5)
  {
    v8 = strchr(__s, 59);
    v9 = v8 - __s;
    if (!v8)
      v9 = a5;
    v10 = v9 - 1;
    v11 = MEMORY[0x1E0C80978];
    do
    {
      while (1)
      {
        if (v10 == -1)
        {
          v15 = 0;
          HIBYTE(v26) = 0;
          p_dst = &__dst;
          goto LABEL_17;
        }
        v13 = v10;
        v14 = __s[v10];
        if ((v14 & 0x80000000) == 0)
          break;
        v12 = __maskrune(v14, 0x4000uLL);
        v10 = v13 - 1;
        if (!v12)
          goto LABEL_9;
      }
      --v10;
    }
    while ((*(_DWORD *)(v11 + 4 * v14 + 60) & 0x4000) != 0);
LABEL_9:
    v15 = v13 + 1;
    if ((unint64_t)(v13 + 1) >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (v15 >= 0x17)
    {
      v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v17 = v15 | 7;
      v18 = v17 + 1;
      p_dst = (__int128 *)operator new(v17 + 1);
      *((_QWORD *)&__dst + 1) = v15;
      v26 = v18 | 0x8000000000000000;
      *(_QWORD *)&__dst = p_dst;
    }
    else
    {
      HIBYTE(v26) = v13 + 1;
      p_dst = &__dst;
    }
    memcpy(p_dst, __s, v15);
LABEL_17:
    *((_BYTE *)p_dst + v15) = 0;
    v19 = HIBYTE(v26);
    v20 = SHIBYTE(v26);
    if (v26 < 0)
      v19 = *((_QWORD *)&__dst + 1);
    if (v19)
    {
      v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v22 = (void **)(v21 + 40);
      if ((*(char *)(v21 + 63) & 0x80000000) == 0)
      {
        if ((SHIBYTE(v26) & 0x80000000) == 0)
        {
          *(_OWORD *)v22 = __dst;
          *(_QWORD *)(v21 + 56) = v26;
          return 1;
        }
        std::string::__assign_no_alias<true>(v22, (void *)__dst, *((size_t *)&__dst + 1));
LABEL_30:
        operator delete((void *)__dst);
        return 1;
      }
      if (v26 >= 0)
        v23 = &__dst;
      else
        v23 = (__int128 *)__dst;
      std::string::__assign_no_alias<false>(v22, v23, v19);
    }
    if ((v20 & 0x80000000) == 0)
      return 1;
    goto LABEL_30;
  }
  return 1;
}

uint64_t ___ZL29nw_http_sniffing_should_sniffP25nw_protocol_http_sniffingNSt3__112basic_stringIcNS1_11char_traitsIcEENS1_9allocatorIcEEEEP20nw_protocol_metadata_block_invoke_2(uint64_t a1, int a2, int a3, char *__big)
{
  char *v5;
  char *v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  char is_valid_token_char;
  size_t v11;
  __int128 *p_dst;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 __dst;
  unint64_t v19;

  v5 = strcasestr(__big, "charset=");
  if (!v5)
    return 1;
  v6 = v5;
  v7 = v5 + 8;
  v8 = 8;
  do
  {
    v9 = v8;
    is_valid_token_char = nw_http_is_valid_token_char(v6[v8]);
    v8 = v9 + 1;
  }
  while ((is_valid_token_char & 1) != 0);
  v11 = v9 - 8;
  if ((unint64_t)(v9 - 8) >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (v11 >= 0x17)
  {
    v13 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v13 = v11 | 7;
    v14 = v13 + 1;
    p_dst = (__int128 *)operator new(v13 + 1);
    *((_QWORD *)&__dst + 1) = v11;
    v19 = v14 | 0x8000000000000000;
    *(_QWORD *)&__dst = p_dst;
  }
  else
  {
    HIBYTE(v19) = v9 - 8;
    p_dst = &__dst;
    if (!v11)
      goto LABEL_12;
  }
  memmove(p_dst, v7, v11);
LABEL_12:
  *((_BYTE *)p_dst + v11) = 0;
  v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v16 = v15 + 40;
  if (*(char *)(v15 + 63) < 0)
    operator delete(*(void **)v16);
  *(_OWORD *)v16 = __dst;
  *(_QWORD *)(v16 + 16) = v19;
  return 1;
}

double __nw_protocol_http_sniffing_identifier_block_invoke()
{
  double result;

  strcpy((char *)nw_protocol_http_sniffing_identifier::protocol_identifier, "http_sniffing");
  *(_QWORD *)&result = 0x100000005;
  qword_1EDCE3D90 = 0x100000005;
  return result;
}

uint64_t networkd_privileged_get_kernel_socket_internal(uint64_t a1)
{
  xpc_object_t v2;
  void *v3;
  xpc_object_t v4;
  void *v5;
  Class Class;
  char *v7;
  id v8;
  const char *v9;
  NSObject *v10;
  os_log_type_t v11;
  id v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  void *v16;
  id v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  id v24;
  os_log_type_t v25;
  char *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  id v29;
  os_log_type_t v30;
  os_log_type_t v31;
  id v32;
  os_log_type_t v33;
  unint64_t value;
  uint64_t v35;
  void *v36;
  const char *v37;
  NSObject *v38;
  os_log_type_t v39;
  os_log_type_t v40;
  char *v41;
  char *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  _BOOL4 v46;
  NSObject *v47;
  os_log_type_t v48;
  _BOOL4 v49;
  id v50;
  os_log_type_t v51;
  uint64_t v52;
  void *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  char *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  void *v60;
  const char *v61;
  NSObject *v62;
  os_log_type_t v63;
  os_log_type_t v64;
  os_log_type_t v65;
  const char *v66;
  os_log_type_t v67;
  _BOOL4 v68;
  os_log_type_t v69;
  char *v70;
  char *v72;
  os_log_type_t v73;
  _BOOL4 v74;
  char *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  os_log_type_t v78;
  os_log_type_t v79;
  os_log_type_t v80;
  os_log_type_t v81;
  void *v82;
  char *v83;
  NSObject *v84;
  os_log_type_t v85;
  char *v86;
  os_log_type_t v87;
  _BOOL4 v88;
  os_log_type_t v89;
  char *v90;
  os_log_type_t v91;
  _BOOL4 v92;
  os_log_type_t v93;
  char v94;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v97;
  __int16 v98;
  _BYTE v99[18];
  __int16 v100;
  char *v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  v2 = xpc_dictionary_create(0, 0, 0);
  v3 = v2;
  if (v2)
  {
    xpc_dictionary_set_uint64(v2, (const char *)networkd_privileged_key_type, a1);
    v4 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_get_kernel_socket_internal", v3);
    v5 = v4;
    if (!v4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      v7 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (!__nwlog_fault(v7, &type, &v94))
        goto LABEL_68;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s received NULL response", buf, 0xCu);
        }
        goto LABEL_175;
      }
      if (!v94)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v31 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v13, v31, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_175;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v22 = type;
      v23 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s received NULL response, no backtrace", buf, 0xCu);
        }
        goto LABEL_175;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v98 = 2082;
        *(_QWORD *)v99 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
    Class = object_getClass(v4);
    if (Class != (Class)MEMORY[0x1E0C812F8])
    {
      if (Class != (Class)MEMORY[0x1E0C81310])
      {
        v7 = (char *)MEMORY[0x186DB5A08](v5);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v98 = 2082;
        *(_QWORD *)v99 = v7;
        v9 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v94 = 0;
        if (!__nwlog_fault(v9, &type, &v94))
          goto LABEL_65;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            v98 = 2082;
            *(_QWORD *)v99 = v7;
            _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
          }
LABEL_64:

LABEL_65:
          if (!v9)
            goto LABEL_68;
          goto LABEL_66;
        }
        if (!v94)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          v40 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            v98 = 2082;
            *(_QWORD *)v99 = v7;
            _os_log_impl(&dword_182FBE000, v10, v40, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_64;
        }
        v26 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v27 = type;
        v28 = os_log_type_enabled(v10, type);
        if (!v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            v98 = 2082;
            *(_QWORD *)v99 = v7;
            _os_log_impl(&dword_182FBE000, v10, v27, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_64;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446722;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 2082;
          *(_QWORD *)v99 = v7;
          *(_WORD *)&v99[8] = 2082;
          *(_QWORD *)&v99[10] = v26;
          _os_log_impl(&dword_182FBE000, v10, v27, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v26);
        if (!v9)
        {
LABEL_68:
          if (!v7)
          {
LABEL_141:
            v52 = 0xFFFFFFFFLL;
            goto LABEL_142;
          }
LABEL_69:
          free(v7);
          goto LABEL_141;
        }
LABEL_66:
        v41 = (char *)v9;
LABEL_67:
        free(v41);
        goto LABEL_68;
      }
      if (v5 != (void *)MEMORY[0x1E0C81258])
      {
        if (v5 == (void *)MEMORY[0x1E0C81260])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v47 = (id)gLogObj;
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
          }

          goto LABEL_141;
        }
        if (v5 != (void *)MEMORY[0x1E0C81288])
        {
          v7 = (char *)MEMORY[0x186DB5A08](v5);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 2082;
          *(_QWORD *)v99 = v7;
          v9 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v94 = 0;
          if (!__nwlog_fault(v9, &type, &v94))
            goto LABEL_65;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v10 = objc_claimAutoreleasedReturnValue();
            v25 = type;
            if (os_log_type_enabled(v10, type))
            {
              *(_DWORD *)buf = 136446466;
              v97 = "networkd_privileged_get_kernel_socket_internal";
              v98 = 2082;
              *(_QWORD *)v99 = v7;
              _os_log_impl(&dword_182FBE000, v10, v25, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
            }
            goto LABEL_64;
          }
          if (!v94)
          {
            __nwlog_obj();
            v10 = objc_claimAutoreleasedReturnValue();
            v78 = type;
            if (os_log_type_enabled(v10, type))
            {
              *(_DWORD *)buf = 136446466;
              v97 = "networkd_privileged_get_kernel_socket_internal";
              v98 = 2082;
              *(_QWORD *)v99 = v7;
              _os_log_impl(&dword_182FBE000, v10, v78, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_64;
          }
          v57 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v10 = objc_claimAutoreleasedReturnValue();
          v58 = type;
          v59 = os_log_type_enabled(v10, type);
          if (!v57)
          {
            if (v59)
            {
              *(_DWORD *)buf = 136446466;
              v97 = "networkd_privileged_get_kernel_socket_internal";
              v98 = 2082;
              *(_QWORD *)v99 = v7;
              _os_log_impl(&dword_182FBE000, v10, v58, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
            }
            goto LABEL_64;
          }
          if (v59)
          {
            *(_DWORD *)buf = 136446722;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            v98 = 2082;
            *(_QWORD *)v99 = v7;
            *(_WORD *)&v99[8] = 2082;
            *(_QWORD *)&v99[10] = v57;
            _os_log_impl(&dword_182FBE000, v10, v58, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v57);
          if (!v9)
            goto LABEL_68;
          goto LABEL_66;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v50 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v7 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v94 = 0;
        if (!__nwlog_fault(v7, &type, &v94))
          goto LABEL_68;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v13 = objc_claimAutoreleasedReturnValue();
          v51 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446210;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            _os_log_impl(&dword_182FBE000, v13, v51, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
          }
        }
        else if (v94)
        {
          v66 = __nw_create_backtrace_string();
          __nwlog_obj();
          v13 = objc_claimAutoreleasedReturnValue();
          v67 = type;
          v68 = os_log_type_enabled(v13, type);
          if (v66)
          {
            if (v68)
            {
              *(_DWORD *)buf = 136446466;
              v97 = "networkd_privileged_get_kernel_socket_internal";
              v98 = 2082;
              *(_QWORD *)v99 = v66;
              _os_log_impl(&dword_182FBE000, v13, v67, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
            }

            v41 = (char *)v66;
            goto LABEL_67;
          }
          if (v68)
          {
            *(_DWORD *)buf = 136446210;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            _os_log_impl(&dword_182FBE000, v13, v67, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v13 = objc_claimAutoreleasedReturnValue();
          v79 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446210;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            _os_log_impl(&dword_182FBE000, v13, v79, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
          }
        }
LABEL_175:

        goto LABEL_68;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      v7 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (!__nwlog_fault(v7, &type, &v94))
        goto LABEL_68;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v13, v33, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_175;
      }
      if (!v94)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v69 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v13, v69, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_175;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v48 = type;
      v49 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v13, v48, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_175;
      }
      if (v49)
      {
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v98 = 2082;
        *(_QWORD *)v99 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v48, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
      if (!v7)
        goto LABEL_141;
      goto LABEL_69;
    }
    xpc_dictionary_get_value(v5, (const char *)networkd_privileged_key_result);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v16 = v15;
    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v29 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      v18 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (!__nwlog_fault(v18, &type, &v94))
        goto LABEL_137;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v30 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v19, v30, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_136;
      }
      if (!v94)
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v65 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v19, v65, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_136;
      }
      v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      v46 = os_log_type_enabled(v19, type);
      if (!v42)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v19, v45, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_136;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v98 = 2082;
        *(_QWORD *)v99 = v42;
        _os_log_impl(&dword_182FBE000, v19, v45, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_82;
    }
    if (object_getClass(v15) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      v18 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (!__nwlog_fault(v18, &type, &v94))
        goto LABEL_137;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_136:

LABEL_137:
        if (!v18)
        {
LABEL_140:

          goto LABEL_141;
        }
        goto LABEL_138;
      }
      if (!v94)
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v64 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v19, v64, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_136;
      }
      v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      v44 = os_log_type_enabled(v19, type);
      if (!v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          _os_log_impl(&dword_182FBE000, v19, v43, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_136;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v98 = 2082;
        *(_QWORD *)v99 = v42;
        _os_log_impl(&dword_182FBE000, v19, v43, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_82:

      free(v42);
      if (!v18)
        goto LABEL_140;
LABEL_138:
      v70 = (char *)v18;
LABEL_139:
      free(v70);
      goto LABEL_140;
    }
    value = xpc_int64_get_value(v16);
    v35 = value;
    if (value)
    {
      if (!(value >> 31))
      {
        __nwlog_obj();
        v36 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446466;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        v98 = 1024;
        *(_DWORD *)v99 = v35;
        v37 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v94 = 0;
        if (__nwlog_fault(v37, &type, &v94))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v38 = objc_claimAutoreleasedReturnValue();
            v39 = type;
            if (os_log_type_enabled(v38, type))
            {
              *(_DWORD *)buf = 136446466;
              v97 = "networkd_privileged_get_kernel_socket_internal";
              v98 = 1024;
              *(_DWORD *)v99 = v35;
              _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
            }
          }
          else if (v94)
          {
            v72 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v38 = objc_claimAutoreleasedReturnValue();
            v73 = type;
            v74 = os_log_type_enabled(v38, type);
            if (v72)
            {
              if (v74)
              {
                *(_DWORD *)buf = 136446722;
                v97 = "networkd_privileged_get_kernel_socket_internal";
                v98 = 1024;
                *(_DWORD *)v99 = v35;
                *(_WORD *)&v99[4] = 2082;
                *(_QWORD *)&v99[6] = v72;
                _os_log_impl(&dword_182FBE000, v38, v73, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v72);
              if (!v37)
                goto LABEL_140;
LABEL_183:
              v70 = (char *)v37;
              goto LABEL_139;
            }
            if (v74)
            {
              *(_DWORD *)buf = 136446466;
              v97 = "networkd_privileged_get_kernel_socket_internal";
              v98 = 1024;
              *(_DWORD *)v99 = v35;
              _os_log_impl(&dword_182FBE000, v38, v73, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
            }
          }
          else
          {
            __nwlog_obj();
            v38 = objc_claimAutoreleasedReturnValue();
            v80 = type;
            if (os_log_type_enabled(v38, type))
            {
              *(_DWORD *)buf = 136446466;
              v97 = "networkd_privileged_get_kernel_socket_internal";
              v98 = 1024;
              *(_DWORD *)v99 = v35;
              _os_log_impl(&dword_182FBE000, v38, v80, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
            }
          }

        }
LABEL_182:
        if (!v37)
          goto LABEL_140;
        goto LABEL_183;
      }
      __nwlog_obj();
      v60 = (void *)objc_claimAutoreleasedReturnValue();
      v61 = networkd_privileged_result_to_string(v35);
      *(_DWORD *)buf = 136446722;
      v97 = "networkd_privileged_get_kernel_socket_internal";
      v98 = 2048;
      *(_QWORD *)v99 = v35;
      *(_WORD *)&v99[8] = 2082;
      *(_QWORD *)&v99[10] = v61;
      v37 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v94 = 0;
      if (!__nwlog_fault(v37, &type, &v94))
        goto LABEL_182;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v62 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)buf = 136446722;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 2048;
          *(_QWORD *)v99 = v35;
          *(_WORD *)&v99[8] = 2082;
          *(_QWORD *)&v99[10] = v61;
          _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
        }
      }
      else if (v94)
      {
        v75 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v62 = objc_claimAutoreleasedReturnValue();
        v76 = type;
        v77 = os_log_type_enabled(v62, type);
        if (v75)
        {
          if (v77)
          {
            *(_DWORD *)buf = 136446978;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            v98 = 2048;
            *(_QWORD *)v99 = v35;
            *(_WORD *)&v99[8] = 2082;
            *(_QWORD *)&v99[10] = v61;
            v100 = 2082;
            v101 = v75;
            _os_log_impl(&dword_182FBE000, v62, v76, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v75);
          goto LABEL_182;
        }
        if (v77)
        {
          *(_DWORD *)buf = 136446722;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 2048;
          *(_QWORD *)v99 = v35;
          *(_WORD *)&v99[8] = 2082;
          *(_QWORD *)&v99[10] = v61;
          _os_log_impl(&dword_182FBE000, v62, v76, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        __nwlog_obj();
        v62 = objc_claimAutoreleasedReturnValue();
        v81 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)buf = 136446722;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 2048;
          *(_QWORD *)v99 = v35;
          *(_WORD *)&v99[8] = 2082;
          *(_QWORD *)&v99[10] = v61;
          _os_log_impl(&dword_182FBE000, v62, v81, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }

      goto LABEL_182;
    }

    v52 = xpc_dictionary_dup_fd(v5, (const char *)networkd_privileged_key_kernel_socket_fd);
    if ((v52 & 0x80000000) == 0)
    {
LABEL_142:

      goto LABEL_143;
    }
    __nwlog_obj();
    v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    v97 = "networkd_privileged_get_kernel_socket_internal";
    v98 = 1024;
    *(_DWORD *)v99 = v52;
    v54 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v94 = 0;
    if (__nwlog_fault(v54, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446466;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 1024;
          *(_DWORD *)v99 = v52;
          _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s received invalid fd %d", buf, 0x12u);
        }
      }
      else if (v94)
      {
        v90 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v91 = type;
        v92 = os_log_type_enabled(v55, type);
        if (v90)
        {
          if (v92)
          {
            *(_DWORD *)buf = 136446722;
            v97 = "networkd_privileged_get_kernel_socket_internal";
            v98 = 1024;
            *(_DWORD *)v99 = v52;
            *(_WORD *)&v99[4] = 2082;
            *(_QWORD *)&v99[6] = v90;
            _os_log_impl(&dword_182FBE000, v55, v91, "%{public}s received invalid fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v90);
          goto LABEL_214;
        }
        if (v92)
        {
          *(_DWORD *)buf = 136446466;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 1024;
          *(_DWORD *)v99 = v52;
          _os_log_impl(&dword_182FBE000, v55, v91, "%{public}s received invalid fd %d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v93 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446466;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 1024;
          *(_DWORD *)v99 = v52;
          _os_log_impl(&dword_182FBE000, v55, v93, "%{public}s received invalid fd %d, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
LABEL_214:
    if (v54)
      free(v54);
    goto LABEL_142;
  }
  __nwlog_obj();
  v82 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v97 = "networkd_privileged_get_kernel_socket_internal";
  v83 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v94 = 0;
  if (__nwlog_fault(v83, &type, &v94))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v84 = objc_claimAutoreleasedReturnValue();
      v85 = type;
      if (os_log_type_enabled(v84, type))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        _os_log_impl(&dword_182FBE000, v84, v85, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
      }
    }
    else if (v94)
    {
      v86 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v84 = objc_claimAutoreleasedReturnValue();
      v87 = type;
      v88 = os_log_type_enabled(v84, type);
      if (v86)
      {
        if (v88)
        {
          *(_DWORD *)buf = 136446466;
          v97 = "networkd_privileged_get_kernel_socket_internal";
          v98 = 2082;
          *(_QWORD *)v99 = v86;
          _os_log_impl(&dword_182FBE000, v84, v87, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v86);
        goto LABEL_200;
      }
      if (v88)
      {
        *(_DWORD *)buf = 136446210;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        _os_log_impl(&dword_182FBE000, v84, v87, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v84 = objc_claimAutoreleasedReturnValue();
      v89 = type;
      if (os_log_type_enabled(v84, type))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "networkd_privileged_get_kernel_socket_internal";
        _os_log_impl(&dword_182FBE000, v84, v89, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_200:
  if (v83)
    free(v83);
  v52 = 0xFFFFFFFFLL;
LABEL_143:

  return v52;
}

void sub_18333E6B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

xpc_object_t networkd_privileged_send_sync_inner(uint64_t a1, void *a2)
{
  id v3;
  _xpc_connection_s *v4;
  _xpc_connection_s *v5;
  xpc_object_t v6;
  NSObject *v8;
  xpc_object_t v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = (_xpc_connection_s *)networkd_privileged_copy_connection();
  v5 = v4;
  if (v4)
  {
    v6 = xpc_connection_send_message_with_reply_sync(v4, v3);
    if (v6 == (xpc_object_t)MEMORY[0x1E0C81258])
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v14 = 136446722;
        v15 = "networkd_privileged_send_sync_inner";
        v16 = 2082;
        v17 = a1;
        v18 = 1024;
        v19 = 1;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, retrying (%u)", (uint8_t *)&v14, 0x1Cu);
      }

      v9 = (xpc_object_t)MEMORY[0x1E0C81258];
      v6 = xpc_connection_send_message_with_reply_sync(v5, v3);

      if (v6 == v9)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          v14 = 136446722;
          v15 = "networkd_privileged_send_sync_inner";
          v16 = 2082;
          v17 = a1;
          v18 = 1024;
          v19 = 2;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, retrying (%u)", (uint8_t *)&v14, 0x1Cu);
        }

        v6 = xpc_connection_send_message_with_reply_sync(v5, v3);
        if (v6 == v9)
        {
          __nwlog_obj();
          v11 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            v14 = 136446722;
            v15 = "networkd_privileged_send_sync_inner";
            v16 = 2082;
            v17 = a1;
            v18 = 1024;
            v19 = 3;
            _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, retrying (%u)", (uint8_t *)&v14, 0x1Cu);
          }

          v6 = xpc_connection_send_message_with_reply_sync(v5, v3);
          if (v6 == v9)
          {
            __nwlog_obj();
            v12 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              v14 = 136446722;
              v15 = "networkd_privileged_send_sync_inner";
              v16 = 2082;
              v17 = a1;
              v18 = 1024;
              v19 = 4;
              _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, retrying (%u)", (uint8_t *)&v14, 0x1Cu);
            }

            v6 = xpc_connection_send_message_with_reply_sync(v5, v3);
            if (v6 == v9)
            {
              __nwlog_obj();
              v13 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                v14 = 136446722;
                v15 = "networkd_privileged_send_sync_inner";
                v16 = 2082;
                v17 = a1;
                v18 = 1024;
                v19 = 5;
                _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, retrying (%u)", (uint8_t *)&v14, 0x1Cu);
              }

              v6 = (xpc_object_t)MEMORY[0x1E0C81258];
            }
          }
        }
      }
    }
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_18333EA70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

const char *networkd_privileged_result_to_string(uint64_t a1)
{
  const char *result;

  if (a1 != (int)a1)
    return "Unknown";
  switch(a1)
  {
    case 0xFFFFFC12:
      result = "FailureParseAgent";
      break;
    case 0xFFFFFC13:
      result = "FailureCreateXPCFD";
      break;
    case 0xFFFFFC14:
      result = "FailureCreateKernelSocket";
      break;
    case 0xFFFFFC15:
      result = "FailureInvalidType";
      break;
    case 0xFFFFFC16:
      result = "FailureMissingEntitlement";
      break;
    case 0xFFFFFC17:
      result = "FailureUnknown";
      break;
    default:
      if ((_DWORD)a1)
        return "Unknown";
      result = "Success";
      break;
  }
  return result;
}

id networkd_privileged_copy_connection(void)
{
  id v0;
  void *v1;
  id v2;
  id v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD block[4];
  NSObject *v13;
  _BYTE *v14;
  char v15;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  id v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (networkd_privileged_copy_queue(void)::onceToken != -1)
    dispatch_once(&networkd_privileged_copy_queue(void)::onceToken, &__block_literal_global_54);
  v0 = (id)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue;
  v1 = v0;
  if (!v0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "networkd_privileged_copy_connection";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v4, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "networkd_privileged_copy_connection";
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s networkd_privileged_copy_queue failed", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        v9 = type;
        v10 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "networkd_privileged_copy_connection";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v9, "%{public}s networkd_privileged_copy_queue failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v4)
            goto LABEL_12;
          goto LABEL_11;
        }
        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "networkd_privileged_copy_connection";
          _os_log_impl(&dword_182FBE000, v5, v9, "%{public}s networkd_privileged_copy_queue failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "networkd_privileged_copy_connection";
          _os_log_impl(&dword_182FBE000, v5, v11, "%{public}s networkd_privileged_copy_queue failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v4)
    {
LABEL_12:
      v2 = 0;
      goto LABEL_13;
    }
LABEL_11:
    free(v4);
    goto LABEL_12;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3032000000;
  v18 = __Block_byref_object_copy__632;
  v19 = __Block_byref_object_dispose__633;
  v20 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___ZL35networkd_privileged_copy_connectionv_block_invoke;
  block[3] = &unk_1E14ACE40;
  v13 = v0;
  v14 = buf;
  dispatch_sync(v13, block);
  v2 = *(id *)(*(_QWORD *)&buf[8] + 40);

  _Block_object_dispose(buf, 8);
LABEL_13:

  return v2;
}

uint64_t __Block_byref_object_copy__632(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__633(uint64_t a1)
{

}

void ___ZL35networkd_privileged_copy_connectionv_block_invoke(uint64_t a1)
{
  void *v2;
  xpc_connection_t mach_service;
  void *v4;
  Class Class;
  void *v6;
  id v7;
  _xpc_connection_s *v8;
  id v9;
  _QWORD handler[4];
  id v11;

  v2 = (void *)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
  if (_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection)
    goto LABEL_2;
  mach_service = xpc_connection_create_mach_service((const char *)networkd_privileged_service, *(dispatch_queue_t *)(a1 + 32), 2uLL);
  v4 = (void *)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
  _ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection = (uint64_t)mach_service;

  if (_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection)
  {
    Class = object_getClass((id)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection);
    v6 = (void *)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
    if (Class == (Class)MEMORY[0x1E0C812E0])
    {
      v7 = (id)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
      v8 = (_xpc_connection_s *)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3221225472;
      handler[2] = ___ZL35networkd_privileged_copy_connectionv_block_invoke_2;
      handler[3] = &unk_1E149A0D0;
      v9 = v7;
      v11 = v9;
      xpc_connection_set_event_handler(v8, handler);
      xpc_connection_resume((xpc_connection_t)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection);

      v2 = (void *)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
      if (!_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection)
        return;
      goto LABEL_2;
    }
    if (_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection)
    {
      _ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection = 0;

      v2 = (void *)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
      if (_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection)
LABEL_2:
        objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), v2);
    }
  }
}

void sub_18333EFF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void ___ZL35networkd_privileged_copy_connectionv_block_invoke_2(uint64_t a1, void *a2)
{
  id v3;
  Class Class;
  BOOL v5;
  void *v6;
  NSObject *v7;
  void *v8;
  int v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  void *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  Class = object_getClass(v3);
  v5 = Class != (Class)MEMORY[0x1E0C81310]
    || _ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection == 0;
  if (!v5 && *(_QWORD *)(a1 + 32) == _ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection)
  {
    xpc_connection_cancel((xpc_connection_t)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection);
    v8 = (void *)_ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection;
    _ZZZL35networkd_privileged_copy_connectionvEUb7_E29sNetworkdPrivilegedConnection = 0;

  }
  else if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    v6 = (void *)MEMORY[0x186DB5A08](v3);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = 136446722;
      v10 = "networkd_privileged_copy_connection_block_invoke_2";
      v11 = 2082;
      v12 = networkd_privileged_service;
      v13 = 2082;
      v14 = v6;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s unexpected message from %{public}s: %{public}s", (uint8_t *)&v9, 0x20u);
    }

    if (v6)
      free(v6);
  }

}

void sub_18333F174(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL30networkd_privileged_copy_queuev_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  NSObject *v2;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = objc_claimAutoreleasedReturnValue();
  v0 = dispatch_queue_create("com.apple.network.xpc_to_privileged_helper", v2);
  v1 = (void *)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue;
  networkd_privileged_copy_queue(void)::networkdPrivilegedQueue = (uint64_t)v0;

}

BOOL networkd_privileged_set_agent_on_interface_internal(const char *a1, const unsigned __int8 *a2, BOOL a3, int a4)
{
  xpc_object_t v8;
  void *v9;
  uint64_t v10;
  xpc_object_t v11;
  void *v12;
  Class Class;
  void *v14;
  id v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  id v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  void *v24;
  id v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  id v32;
  os_log_type_t v33;
  char *backtrace_string;
  os_log_type_t v35;
  _BOOL4 v36;
  id v37;
  os_log_type_t v38;
  os_log_type_t v39;
  id v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  unint64_t value;
  uint64_t v45;
  NSObject *v46;
  NSObject *v47;
  os_log_type_t v48;
  int v49;
  char *v50;
  os_log_type_t v51;
  _BOOL4 v52;
  _BOOL8 v53;
  os_log_type_t v54;
  _BOOL4 v55;
  NSObject *v56;
  char *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  id v60;
  os_log_type_t v61;
  char *v62;
  os_log_type_t v63;
  _BOOL4 v64;
  void *v65;
  const char *v66;
  const char *v67;
  NSObject *v68;
  os_log_type_t v69;
  os_log_type_t v70;
  os_log_type_t v71;
  char *v72;
  os_log_type_t v73;
  _BOOL4 v74;
  os_log_type_t v75;
  char *v76;
  NSObject *v77;
  os_log_type_t v78;
  char *v79;
  os_log_type_t v80;
  _BOOL4 v81;
  os_log_type_t v82;
  char *v83;
  os_log_type_t v84;
  _BOOL4 v85;
  os_log_type_t v86;
  os_log_type_t v87;
  os_log_type_t v89;
  void *v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  void *v94;
  char *v95;
  NSObject *v96;
  os_log_type_t v97;
  char *v98;
  os_log_type_t v99;
  _BOOL4 v100;
  char *v101;
  os_log_type_t v102;
  _BOOL4 v103;
  os_log_type_t v104;
  os_log_type_t v105;
  char v106;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v109;
  __int16 v110;
  _BYTE v111[18];
  __int16 v112;
  char *v113;
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v8 = xpc_dictionary_create(0, 0, 0);
    v9 = v8;
    if (v8)
    {
      if (a4)
        v10 = 14;
      else
        v10 = 8;
      xpc_dictionary_set_uint64(v8, (const char *)networkd_privileged_key_type, v10);
      xpc_dictionary_set_string(v9, (const char *)networkd_privileged_key_interface_name, a1);
      xpc_dictionary_set_uuid(v9, (const char *)networkd_privileged_key_agent_uuid, a2);
      xpc_dictionary_set_BOOL(v9, (const char *)networkd_privileged_key_remove, a3);
      v11 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_set_agent_on_interface_internal", v9);
      v12 = v11;
      if (v11)
      {
        Class = object_getClass(v11);
        if (Class != (Class)MEMORY[0x1E0C812F8])
        {
          if (Class != (Class)MEMORY[0x1E0C81310])
          {
            v14 = (void *)MEMORY[0x186DB5A08](v12);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v15 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2082;
            *(_QWORD *)v111 = v14;
            v16 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v106 = 0;
            if (!__nwlog_fault(v16, &type, &v106))
              goto LABEL_68;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v17 = (id)gLogObj;
              v18 = type;
              if (os_log_type_enabled(v17, type))
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 2082;
                *(_QWORD *)v111 = v14;
                _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
              }
LABEL_67:

LABEL_68:
              if (!v16)
                goto LABEL_70;
              goto LABEL_69;
            }
            if (!v106)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v17 = (id)gLogObj;
              v48 = type;
              if (os_log_type_enabled(v17, type))
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 2082;
                *(_QWORD *)v111 = v14;
                _os_log_impl(&dword_182FBE000, v17, v48, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
              }
              goto LABEL_67;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v17 = (id)gLogObj;
            v35 = type;
            v36 = os_log_type_enabled(v17, type);
            if (!backtrace_string)
            {
              if (v36)
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 2082;
                *(_QWORD *)v111 = v14;
                _os_log_impl(&dword_182FBE000, v17, v35, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
              }
              goto LABEL_67;
            }
            if (v36)
            {
              *(_DWORD *)buf = 136446722;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              v110 = 2082;
              *(_QWORD *)v111 = v14;
              *(_WORD *)&v111[8] = 2082;
              *(_QWORD *)&v111[10] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v17, v35, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(backtrace_string);
            if (!v16)
            {
LABEL_70:
              if (v14)
              {
                free(v14);
                v49 = 1;
LABEL_180:
                v53 = v49 == 0;
                goto LABEL_181;
              }
LABEL_179:
              v49 = 1;
              goto LABEL_180;
            }
LABEL_69:
            free(v16);
            goto LABEL_70;
          }
          if (v12 == (void *)MEMORY[0x1E0C81258])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v40 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v41 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v106 = 0;
            if (!__nwlog_fault(v41, &type, &v106))
              goto LABEL_177;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v42 = (id)gLogObj;
              v43 = type;
              if (os_log_type_enabled(v42, type))
              {
                *(_DWORD *)buf = 136446210;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
              }
            }
            else if (v106)
            {
              v57 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v42 = objc_claimAutoreleasedReturnValue();
              v58 = type;
              v59 = os_log_type_enabled(v42, type);
              if (v57)
              {
                if (v59)
                {
                  *(_DWORD *)buf = 136446466;
                  v109 = "networkd_privileged_set_agent_on_interface_internal";
                  v110 = 2082;
                  *(_QWORD *)v111 = v57;
                  _os_log_impl(&dword_182FBE000, v42, v58, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v57);
                if (!v41)
                  goto LABEL_179;
                goto LABEL_178;
              }
              if (v59)
              {
                *(_DWORD *)buf = 136446210;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                _os_log_impl(&dword_182FBE000, v42, v58, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              __nwlog_obj();
              v42 = objc_claimAutoreleasedReturnValue();
              v75 = type;
              if (os_log_type_enabled(v42, type))
              {
                *(_DWORD *)buf = 136446210;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                _os_log_impl(&dword_182FBE000, v42, v75, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
          else
          {
            if (v12 == (void *)MEMORY[0x1E0C81260])
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v56 = (id)gLogObj;
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
              }

              goto LABEL_179;
            }
            if (v12 != (void *)MEMORY[0x1E0C81288])
            {
              v14 = (void *)MEMORY[0x186DB5A08](v12);
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v32 = (id)gLogObj;
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              v110 = 2082;
              *(_QWORD *)v111 = v14;
              v16 = (char *)_os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v106 = 0;
              if (!__nwlog_fault(v16, &type, &v106))
                goto LABEL_68;
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v17 = objc_claimAutoreleasedReturnValue();
                v33 = type;
                if (os_log_type_enabled(v17, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v109 = "networkd_privileged_set_agent_on_interface_internal";
                  v110 = 2082;
                  *(_QWORD *)v111 = v14;
                  _os_log_impl(&dword_182FBE000, v17, v33, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
                }
                goto LABEL_67;
              }
              if (!v106)
              {
                __nwlog_obj();
                v17 = objc_claimAutoreleasedReturnValue();
                v82 = type;
                if (os_log_type_enabled(v17, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v109 = "networkd_privileged_set_agent_on_interface_internal";
                  v110 = 2082;
                  *(_QWORD *)v111 = v14;
                  _os_log_impl(&dword_182FBE000, v17, v82, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
                }
                goto LABEL_67;
              }
              v62 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v17 = objc_claimAutoreleasedReturnValue();
              v63 = type;
              v64 = os_log_type_enabled(v17, type);
              if (!v62)
              {
                if (v64)
                {
                  *(_DWORD *)buf = 136446466;
                  v109 = "networkd_privileged_set_agent_on_interface_internal";
                  v110 = 2082;
                  *(_QWORD *)v111 = v14;
                  _os_log_impl(&dword_182FBE000, v17, v63, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
                }
                goto LABEL_67;
              }
              if (v64)
              {
                *(_DWORD *)buf = 136446722;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 2082;
                *(_QWORD *)v111 = v14;
                *(_WORD *)&v111[8] = 2082;
                *(_QWORD *)&v111[10] = v62;
                _os_log_impl(&dword_182FBE000, v17, v63, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v62);
              if (!v16)
                goto LABEL_70;
              goto LABEL_69;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v60 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v41 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v106 = 0;
            if (!__nwlog_fault(v41, &type, &v106))
              goto LABEL_177;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v42 = objc_claimAutoreleasedReturnValue();
              v61 = type;
              if (os_log_type_enabled(v42, type))
              {
                *(_DWORD *)buf = 136446210;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                _os_log_impl(&dword_182FBE000, v42, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
              }
            }
            else if (v106)
            {
              v72 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v42 = objc_claimAutoreleasedReturnValue();
              v73 = type;
              v74 = os_log_type_enabled(v42, type);
              if (v72)
              {
                if (v74)
                {
                  *(_DWORD *)buf = 136446466;
                  v109 = "networkd_privileged_set_agent_on_interface_internal";
                  v110 = 2082;
                  *(_QWORD *)v111 = v72;
                  _os_log_impl(&dword_182FBE000, v42, v73, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v72);
LABEL_177:
                if (!v41)
                  goto LABEL_179;
LABEL_178:
                free(v41);
                goto LABEL_179;
              }
              if (v74)
              {
                *(_DWORD *)buf = 136446210;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                _os_log_impl(&dword_182FBE000, v42, v73, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              __nwlog_obj();
              v42 = objc_claimAutoreleasedReturnValue();
              v86 = type;
              if (os_log_type_enabled(v42, type))
              {
                *(_DWORD *)buf = 136446210;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                _os_log_impl(&dword_182FBE000, v42, v86, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }

          goto LABEL_177;
        }
        xpc_dictionary_get_value(v12, (const char *)networkd_privileged_key_result);
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        v24 = v23;
        if (!v23)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v37 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          v26 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v106 = 0;
          if (!__nwlog_fault(v26, &type, &v106))
            goto LABEL_138;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v27 = (id)gLogObj;
            v38 = type;
            if (os_log_type_enabled(v27, type))
            {
              *(_DWORD *)buf = 136446210;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              _os_log_impl(&dword_182FBE000, v27, v38, "%{public}s received response without result code", buf, 0xCu);
            }
            goto LABEL_137;
          }
          if (!v106)
          {
            __nwlog_obj();
            v27 = objc_claimAutoreleasedReturnValue();
            v71 = type;
            if (os_log_type_enabled(v27, type))
            {
              *(_DWORD *)buf = 136446210;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              _os_log_impl(&dword_182FBE000, v27, v71, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_137;
          }
          v50 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v27 = objc_claimAutoreleasedReturnValue();
          v54 = type;
          v55 = os_log_type_enabled(v27, type);
          if (!v50)
          {
            if (v55)
            {
              *(_DWORD *)buf = 136446210;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              _os_log_impl(&dword_182FBE000, v27, v54, "%{public}s received response without result code, no backtrace", buf, 0xCu);
            }
            goto LABEL_137;
          }
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2082;
            *(_QWORD *)v111 = v50;
            _os_log_impl(&dword_182FBE000, v27, v54, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
          }
          goto LABEL_87;
        }
        if (object_getClass(v23) != (Class)MEMORY[0x1E0C81328])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v25 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          v26 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v106 = 0;
          if (!__nwlog_fault(v26, &type, &v106))
            goto LABEL_138;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v27 = (id)gLogObj;
            v28 = type;
            if (os_log_type_enabled(v27, type))
            {
              *(_DWORD *)buf = 136446210;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s received invalid result type", buf, 0xCu);
            }
LABEL_137:

LABEL_138:
            if (!v26)
            {
LABEL_141:
              v49 = 1;
              goto LABEL_142;
            }
            goto LABEL_139;
          }
          if (!v106)
          {
            __nwlog_obj();
            v27 = objc_claimAutoreleasedReturnValue();
            v70 = type;
            if (os_log_type_enabled(v27, type))
            {
              *(_DWORD *)buf = 136446210;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              _os_log_impl(&dword_182FBE000, v27, v70, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_137;
          }
          v50 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v27 = objc_claimAutoreleasedReturnValue();
          v51 = type;
          v52 = os_log_type_enabled(v27, type);
          if (!v50)
          {
            if (v52)
            {
              *(_DWORD *)buf = 136446210;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              _os_log_impl(&dword_182FBE000, v27, v51, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
            }
            goto LABEL_137;
          }
          if (v52)
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2082;
            *(_QWORD *)v111 = v50;
            _os_log_impl(&dword_182FBE000, v27, v51, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
          }
LABEL_87:

          free(v50);
          if (!v26)
            goto LABEL_141;
LABEL_139:
          v76 = (char *)v26;
LABEL_140:
          free(v76);
          goto LABEL_141;
        }
        value = xpc_int64_get_value(v24);
        v45 = value;
        if (!value)
        {
          v49 = 0;
LABEL_142:

          goto LABEL_180;
        }
        if (!(value >> 31))
        {
          __nwlog_obj();
          v46 = objc_claimAutoreleasedReturnValue();
          v47 = v46;
          if ((_DWORD)v45 == 6)
          {
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              v110 = 1024;
              *(_DWORD *)v111 = 6;
              _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_ERROR, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
            }

            goto LABEL_141;
          }
          *(_DWORD *)buf = 136446466;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          v110 = 1024;
          *(_DWORD *)v111 = v45;
          v67 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v106 = 0;
          if (__nwlog_fault(v67, &type, &v106))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v77 = objc_claimAutoreleasedReturnValue();
              v78 = type;
              if (os_log_type_enabled(v77, type))
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 1024;
                *(_DWORD *)v111 = v45;
                _os_log_impl(&dword_182FBE000, v77, v78, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
              }
            }
            else if (v106)
            {
              v83 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v77 = objc_claimAutoreleasedReturnValue();
              v84 = type;
              v85 = os_log_type_enabled(v77, type);
              if (v83)
              {
                if (v85)
                {
                  *(_DWORD *)buf = 136446722;
                  v109 = "networkd_privileged_set_agent_on_interface_internal";
                  v110 = 1024;
                  *(_DWORD *)v111 = v45;
                  *(_WORD *)&v111[4] = 2082;
                  *(_QWORD *)&v111[6] = v83;
                  _os_log_impl(&dword_182FBE000, v77, v84, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }

                free(v83);
                if (!v67)
                  goto LABEL_141;
LABEL_194:
                v76 = (char *)v67;
                goto LABEL_140;
              }
              if (v85)
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 1024;
                *(_DWORD *)v111 = v45;
                _os_log_impl(&dword_182FBE000, v77, v84, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
              }
            }
            else
            {
              __nwlog_obj();
              v77 = objc_claimAutoreleasedReturnValue();
              v89 = type;
              if (os_log_type_enabled(v77, type))
              {
                *(_DWORD *)buf = 136446466;
                v109 = "networkd_privileged_set_agent_on_interface_internal";
                v110 = 1024;
                *(_DWORD *)v111 = v45;
                _os_log_impl(&dword_182FBE000, v77, v89, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
              }
            }

          }
LABEL_193:
          if (!v67)
            goto LABEL_141;
          goto LABEL_194;
        }
        __nwlog_obj();
        v65 = (void *)objc_claimAutoreleasedReturnValue();
        v66 = networkd_privileged_result_to_string(v45);
        *(_DWORD *)buf = 136446722;
        v109 = "networkd_privileged_set_agent_on_interface_internal";
        v110 = 2048;
        *(_QWORD *)v111 = v45;
        *(_WORD *)&v111[8] = 2082;
        *(_QWORD *)&v111[10] = v66;
        v67 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v106 = 0;
        if (!__nwlog_fault(v67, &type, &v106))
          goto LABEL_193;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v68 = objc_claimAutoreleasedReturnValue();
          v69 = type;
          if (os_log_type_enabled(v68, type))
          {
            *(_DWORD *)buf = 136446722;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2048;
            *(_QWORD *)v111 = v45;
            *(_WORD *)&v111[8] = 2082;
            *(_QWORD *)&v111[10] = v66;
            _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
          }
        }
        else if (v106)
        {
          v79 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v68 = objc_claimAutoreleasedReturnValue();
          v80 = type;
          v81 = os_log_type_enabled(v68, type);
          if (v79)
          {
            if (v81)
            {
              *(_DWORD *)buf = 136446978;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              v110 = 2048;
              *(_QWORD *)v111 = v45;
              *(_WORD *)&v111[8] = 2082;
              *(_QWORD *)&v111[10] = v66;
              v112 = 2082;
              v113 = v79;
              _os_log_impl(&dword_182FBE000, v68, v80, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v79);
            goto LABEL_193;
          }
          if (v81)
          {
            *(_DWORD *)buf = 136446722;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2048;
            *(_QWORD *)v111 = v45;
            *(_WORD *)&v111[8] = 2082;
            *(_QWORD *)&v111[10] = v66;
            _os_log_impl(&dword_182FBE000, v68, v80, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          __nwlog_obj();
          v68 = objc_claimAutoreleasedReturnValue();
          v87 = type;
          if (os_log_type_enabled(v68, type))
          {
            *(_DWORD *)buf = 136446722;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2048;
            *(_QWORD *)v111 = v45;
            *(_WORD *)&v111[8] = 2082;
            *(_QWORD *)&v111[10] = v66;
            _os_log_impl(&dword_182FBE000, v68, v87, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
          }
        }

        goto LABEL_193;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v109 = "networkd_privileged_set_agent_on_interface_internal";
      v20 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v106 = 0;
      if (__nwlog_fault(v20, &type, &v106))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          v22 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s received NULL response", buf, 0xCu);
          }
        }
        else if (v106)
        {
          v29 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          v30 = type;
          v31 = os_log_type_enabled(v21, type);
          if (v29)
          {
            if (v31)
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_set_agent_on_interface_internal";
              v110 = 2082;
              *(_QWORD *)v111 = v29;
              _os_log_impl(&dword_182FBE000, v21, v30, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v29);
            if (!v20)
              goto LABEL_82;
            goto LABEL_81;
          }
          if (v31)
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            _os_log_impl(&dword_182FBE000, v21, v30, "%{public}s received NULL response, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          v39 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            _os_log_impl(&dword_182FBE000, v21, v39, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v20)
      {
LABEL_82:
        v53 = 0;
LABEL_181:

LABEL_182:
        return v53;
      }
LABEL_81:
      free(v20);
      goto LABEL_82;
    }
    __nwlog_obj();
    v94 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v109 = "networkd_privileged_set_agent_on_interface_internal";
    v95 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (__nwlog_fault(v95, &type, &v106))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v97 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          _os_log_impl(&dword_182FBE000, v96, v97, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v106)
      {
        v101 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v102 = type;
        v103 = os_log_type_enabled(v96, type);
        if (v101)
        {
          if (v103)
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_set_agent_on_interface_internal";
            v110 = 2082;
            *(_QWORD *)v111 = v101;
            _os_log_impl(&dword_182FBE000, v96, v102, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v101);
          goto LABEL_230;
        }
        if (v103)
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          _os_log_impl(&dword_182FBE000, v96, v102, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v105 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          _os_log_impl(&dword_182FBE000, v96, v105, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_230:
    if (v95)
      free(v95);
    v53 = 0;
    goto LABEL_182;
  }
  __nwlog_obj();
  v90 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v109 = "networkd_privileged_set_agent_on_interface_internal";
  v91 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v106 = 0;
  if (__nwlog_fault(v91, &type, &v106))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v92 = objc_claimAutoreleasedReturnValue();
      v93 = type;
      if (os_log_type_enabled(v92, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_set_agent_on_interface_internal";
        _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s called with null interface_name", buf, 0xCu);
      }
    }
    else if (v106)
    {
      v98 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v92 = objc_claimAutoreleasedReturnValue();
      v99 = type;
      v100 = os_log_type_enabled(v92, type);
      if (v98)
      {
        if (v100)
        {
          *(_DWORD *)buf = 136446466;
          v109 = "networkd_privileged_set_agent_on_interface_internal";
          v110 = 2082;
          *(_QWORD *)v111 = v98;
          _os_log_impl(&dword_182FBE000, v92, v99, "%{public}s called with null interface_name, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v98);
        goto LABEL_224;
      }
      if (v100)
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_set_agent_on_interface_internal";
        _os_log_impl(&dword_182FBE000, v92, v99, "%{public}s called with null interface_name, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v92 = objc_claimAutoreleasedReturnValue();
      v104 = type;
      if (os_log_type_enabled(v92, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_set_agent_on_interface_internal";
        _os_log_impl(&dword_182FBE000, v92, v104, "%{public}s called with null interface_name, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_224:
  if (v91)
    free(v91);
  return 0;
}

void sub_183340D70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL networkd_privileged_setup_feth_pair(const char *a1, const char *a2)
{
  xpc_object_t v4;
  void *v5;
  xpc_object_t v6;
  void *v7;
  Class Class;
  void *v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  id v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  void *v19;
  id v20;
  const char *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  id v27;
  os_log_type_t v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  id v32;
  os_log_type_t v33;
  os_log_type_t v34;
  id v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  unint64_t value;
  uint64_t v40;
  void *v41;
  const char *v42;
  NSObject *v43;
  os_log_type_t v44;
  os_log_type_t v45;
  int v46;
  char *v47;
  os_log_type_t v48;
  _BOOL4 v49;
  _BOOL8 v50;
  os_log_type_t v51;
  _BOOL4 v52;
  NSObject *v53;
  char *v54;
  os_log_type_t v55;
  _BOOL4 v56;
  id v57;
  os_log_type_t v58;
  char *v59;
  os_log_type_t v60;
  _BOOL4 v61;
  void *v62;
  const char *v63;
  NSObject *v64;
  os_log_type_t v65;
  os_log_type_t v66;
  os_log_type_t v67;
  char *v68;
  os_log_type_t v69;
  _BOOL4 v70;
  os_log_type_t v71;
  char *v72;
  char *v73;
  os_log_type_t v74;
  _BOOL4 v75;
  char *v76;
  os_log_type_t v77;
  _BOOL4 v78;
  os_log_type_t v79;
  os_log_type_t v80;
  os_log_type_t v81;
  os_log_type_t v82;
  void *v84;
  char *v85;
  NSObject *v86;
  os_log_type_t v87;
  void *v88;
  os_log_type_t v89;
  void *v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  char *backtrace_string;
  os_log_type_t v95;
  _BOOL4 v96;
  char *v97;
  os_log_type_t v98;
  _BOOL4 v99;
  char *v100;
  os_log_type_t v101;
  _BOOL4 v102;
  os_log_type_t v103;
  os_log_type_t v104;
  os_log_type_t v105;
  char v106;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v109;
  __int16 v110;
  _BYTE v111[18];
  __int16 v112;
  char *v113;
  uint64_t v114;

  v114 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v84 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v109 = "networkd_privileged_setup_feth_pair";
    v85 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (!__nwlog_fault(v85, &type, &v106))
      goto LABEL_235;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v86 = objc_claimAutoreleasedReturnValue();
      v87 = type;
      if (os_log_type_enabled(v86, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s called with null ifname1", buf, 0xCu);
      }
    }
    else if (v106)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v86 = objc_claimAutoreleasedReturnValue();
      v95 = type;
      v96 = os_log_type_enabled(v86, type);
      if (backtrace_string)
      {
        if (v96)
        {
          *(_DWORD *)buf = 136446466;
          v109 = "networkd_privileged_setup_feth_pair";
          v110 = 2082;
          *(_QWORD *)v111 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v86, v95, "%{public}s called with null ifname1, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v85)
          return 0;
        goto LABEL_236;
      }
      if (v96)
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v86, v95, "%{public}s called with null ifname1, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v86 = objc_claimAutoreleasedReturnValue();
      v103 = type;
      if (os_log_type_enabled(v86, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v86, v103, "%{public}s called with null ifname1, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_234;
  }
  if (!a2)
  {
    __nwlog_obj();
    v88 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v109 = "networkd_privileged_setup_feth_pair";
    v85 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (!__nwlog_fault(v85, &type, &v106))
      goto LABEL_235;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v86 = objc_claimAutoreleasedReturnValue();
      v89 = type;
      if (os_log_type_enabled(v86, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v86, v89, "%{public}s called with null ifname2", buf, 0xCu);
      }
    }
    else if (v106)
    {
      v97 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v86 = objc_claimAutoreleasedReturnValue();
      v98 = type;
      v99 = os_log_type_enabled(v86, type);
      if (v97)
      {
        if (v99)
        {
          *(_DWORD *)buf = 136446466;
          v109 = "networkd_privileged_setup_feth_pair";
          v110 = 2082;
          *(_QWORD *)v111 = v97;
          _os_log_impl(&dword_182FBE000, v86, v98, "%{public}s called with null ifname2, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v97);
LABEL_235:
        if (!v85)
          return 0;
LABEL_236:
        free(v85);
        return 0;
      }
      if (v99)
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v86, v98, "%{public}s called with null ifname2, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v86 = objc_claimAutoreleasedReturnValue();
      v104 = type;
      if (os_log_type_enabled(v86, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v86, v104, "%{public}s called with null ifname2, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_234:

    goto LABEL_235;
  }
  v4 = xpc_dictionary_create(0, 0, 0);
  v5 = v4;
  if (!v4)
  {
    __nwlog_obj();
    v90 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v109 = "networkd_privileged_setup_feth_pair";
    v91 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (__nwlog_fault(v91, &type, &v106))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v92 = objc_claimAutoreleasedReturnValue();
        v93 = type;
        if (os_log_type_enabled(v92, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v106)
      {
        v100 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v92 = objc_claimAutoreleasedReturnValue();
        v101 = type;
        v102 = os_log_type_enabled(v92, type);
        if (v100)
        {
          if (v102)
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 2082;
            *(_QWORD *)v111 = v100;
            _os_log_impl(&dword_182FBE000, v92, v101, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v100);
          goto LABEL_241;
        }
        if (v102)
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v92, v101, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v92 = objc_claimAutoreleasedReturnValue();
        v105 = type;
        if (os_log_type_enabled(v92, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v92, v105, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_241:
    if (v91)
      free(v91);
    v50 = 0;
    goto LABEL_179;
  }
  xpc_dictionary_set_uint64(v4, (const char *)networkd_privileged_key_type, 0x11uLL);
  xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_interface_name, a1);
  xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_second_interface_name, a2);
  v6 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_setup_feth_pair", v5);
  v7 = v6;
  if (v6)
  {
    Class = object_getClass(v6);
    if (Class != (Class)MEMORY[0x1E0C812F8])
    {
      if (Class != (Class)MEMORY[0x1E0C81310])
      {
        v9 = (void *)MEMORY[0x186DB5A08](v7);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v109 = "networkd_privileged_setup_feth_pair";
        v110 = 2082;
        *(_QWORD *)v111 = v9;
        v11 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v106 = 0;
        if (!__nwlog_fault(v11, &type, &v106))
          goto LABEL_67;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = (id)gLogObj;
          v13 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 2082;
            *(_QWORD *)v111 = v9;
            _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
          }
LABEL_66:

LABEL_67:
          if (!v11)
            goto LABEL_69;
          goto LABEL_68;
        }
        if (!v106)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = (id)gLogObj;
          v45 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 2082;
            *(_QWORD *)v111 = v9;
            _os_log_impl(&dword_182FBE000, v12, v45, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_66;
        }
        v29 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v30 = type;
        v31 = os_log_type_enabled(v12, type);
        if (!v29)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 2082;
            *(_QWORD *)v111 = v9;
            _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_66;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446722;
          v109 = "networkd_privileged_setup_feth_pair";
          v110 = 2082;
          *(_QWORD *)v111 = v9;
          *(_WORD *)&v111[8] = 2082;
          *(_QWORD *)&v111[10] = v29;
          _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v29);
        if (!v11)
        {
LABEL_69:
          if (v9)
          {
            free(v9);
            v46 = 1;
LABEL_177:
            v50 = v46 == 0;
            goto LABEL_178;
          }
LABEL_176:
          v46 = 1;
          goto LABEL_177;
        }
LABEL_68:
        free(v11);
        goto LABEL_69;
      }
      if (v7 == (void *)MEMORY[0x1E0C81258])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        v36 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v106 = 0;
        if (!__nwlog_fault(v36, &type, &v106))
          goto LABEL_174;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v37 = (id)gLogObj;
          v38 = type;
          if (os_log_type_enabled(v37, type))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_setup_feth_pair";
            _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
          }
        }
        else if (v106)
        {
          v54 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v55 = type;
          v56 = os_log_type_enabled(v37, type);
          if (v54)
          {
            if (v56)
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_setup_feth_pair";
              v110 = 2082;
              *(_QWORD *)v111 = v54;
              _os_log_impl(&dword_182FBE000, v37, v55, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v54);
            if (!v36)
              goto LABEL_176;
            goto LABEL_175;
          }
          if (v56)
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_setup_feth_pair";
            _os_log_impl(&dword_182FBE000, v37, v55, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v71 = type;
          if (os_log_type_enabled(v37, type))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_setup_feth_pair";
            _os_log_impl(&dword_182FBE000, v37, v71, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      else
      {
        if (v7 == (void *)MEMORY[0x1E0C81260])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v53 = (id)gLogObj;
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_setup_feth_pair";
            _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
          }

          goto LABEL_176;
        }
        if (v7 != (void *)MEMORY[0x1E0C81288])
        {
          v9 = (void *)MEMORY[0x186DB5A08](v7);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          v109 = "networkd_privileged_setup_feth_pair";
          v110 = 2082;
          *(_QWORD *)v111 = v9;
          v11 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v106 = 0;
          if (!__nwlog_fault(v11, &type, &v106))
            goto LABEL_67;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v12 = objc_claimAutoreleasedReturnValue();
            v28 = type;
            if (os_log_type_enabled(v12, type))
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_setup_feth_pair";
              v110 = 2082;
              *(_QWORD *)v111 = v9;
              _os_log_impl(&dword_182FBE000, v12, v28, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
            }
            goto LABEL_66;
          }
          if (!v106)
          {
            __nwlog_obj();
            v12 = objc_claimAutoreleasedReturnValue();
            v79 = type;
            if (os_log_type_enabled(v12, type))
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_setup_feth_pair";
              v110 = 2082;
              *(_QWORD *)v111 = v9;
              _os_log_impl(&dword_182FBE000, v12, v79, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_66;
          }
          v59 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v12 = objc_claimAutoreleasedReturnValue();
          v60 = type;
          v61 = os_log_type_enabled(v12, type);
          if (!v59)
          {
            if (v61)
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_setup_feth_pair";
              v110 = 2082;
              *(_QWORD *)v111 = v9;
              _os_log_impl(&dword_182FBE000, v12, v60, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
            }
            goto LABEL_66;
          }
          if (v61)
          {
            *(_DWORD *)buf = 136446722;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 2082;
            *(_QWORD *)v111 = v9;
            *(_WORD *)&v111[8] = 2082;
            *(_QWORD *)&v111[10] = v59;
            _os_log_impl(&dword_182FBE000, v12, v60, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v59);
          if (!v11)
            goto LABEL_69;
          goto LABEL_68;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v57 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        v36 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v106 = 0;
        if (!__nwlog_fault(v36, &type, &v106))
          goto LABEL_174;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v58 = type;
          if (os_log_type_enabled(v37, type))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_setup_feth_pair";
            _os_log_impl(&dword_182FBE000, v37, v58, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
          }
        }
        else if (v106)
        {
          v68 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v69 = type;
          v70 = os_log_type_enabled(v37, type);
          if (v68)
          {
            if (v70)
            {
              *(_DWORD *)buf = 136446466;
              v109 = "networkd_privileged_setup_feth_pair";
              v110 = 2082;
              *(_QWORD *)v111 = v68;
              _os_log_impl(&dword_182FBE000, v37, v69, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v68);
LABEL_174:
            if (!v36)
              goto LABEL_176;
LABEL_175:
            free(v36);
            goto LABEL_176;
          }
          if (v70)
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_setup_feth_pair";
            _os_log_impl(&dword_182FBE000, v37, v69, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v37 = objc_claimAutoreleasedReturnValue();
          v80 = type;
          if (os_log_type_enabled(v37, type))
          {
            *(_DWORD *)buf = 136446210;
            v109 = "networkd_privileged_setup_feth_pair";
            _os_log_impl(&dword_182FBE000, v37, v80, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }

      goto LABEL_174;
    }
    xpc_dictionary_get_value(v7, (const char *)networkd_privileged_key_result);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v19 = v18;
    if (!v18)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v109 = "networkd_privileged_setup_feth_pair";
      v21 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v106 = 0;
      if (!__nwlog_fault(v21, &type, &v106))
        goto LABEL_137;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v22, v33, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_136;
      }
      if (!v106)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v67 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v22, v67, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_136;
      }
      v47 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v51 = type;
      v52 = os_log_type_enabled(v22, type);
      if (!v47)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v22, v51, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_136;
      }
      if (v52)
      {
        *(_DWORD *)buf = 136446466;
        v109 = "networkd_privileged_setup_feth_pair";
        v110 = 2082;
        *(_QWORD *)v111 = v47;
        _os_log_impl(&dword_182FBE000, v22, v51, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_86;
    }
    if (object_getClass(v18) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v109 = "networkd_privileged_setup_feth_pair";
      v21 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v106 = 0;
      if (!__nwlog_fault(v21, &type, &v106))
        goto LABEL_137;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (id)gLogObj;
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_136:

LABEL_137:
        if (!v21)
        {
LABEL_140:
          v46 = 1;
          goto LABEL_141;
        }
        goto LABEL_138;
      }
      if (!v106)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v66 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v22, v66, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_136;
      }
      v47 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v48 = type;
      v49 = os_log_type_enabled(v22, type);
      if (!v47)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446210;
          v109 = "networkd_privileged_setup_feth_pair";
          _os_log_impl(&dword_182FBE000, v22, v48, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_136;
      }
      if (v49)
      {
        *(_DWORD *)buf = 136446466;
        v109 = "networkd_privileged_setup_feth_pair";
        v110 = 2082;
        *(_QWORD *)v111 = v47;
        _os_log_impl(&dword_182FBE000, v22, v48, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_86:

      free(v47);
      if (!v21)
        goto LABEL_140;
LABEL_138:
      v72 = (char *)v21;
LABEL_139:
      free(v72);
      goto LABEL_140;
    }
    value = xpc_int64_get_value(v19);
    v40 = value;
    if (!value)
    {
      v46 = 0;
LABEL_141:

      goto LABEL_177;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v41 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v109 = "networkd_privileged_setup_feth_pair";
      v110 = 1024;
      *(_DWORD *)v111 = v40;
      v42 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v106 = 0;
      if (__nwlog_fault(v42, &type, &v106))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v43 = objc_claimAutoreleasedReturnValue();
          v44 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 1024;
            *(_DWORD *)v111 = v40;
            _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v106)
        {
          v73 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v43 = objc_claimAutoreleasedReturnValue();
          v74 = type;
          v75 = os_log_type_enabled(v43, type);
          if (v73)
          {
            if (v75)
            {
              *(_DWORD *)buf = 136446722;
              v109 = "networkd_privileged_setup_feth_pair";
              v110 = 1024;
              *(_DWORD *)v111 = v40;
              *(_WORD *)&v111[4] = 2082;
              *(_QWORD *)&v111[6] = v73;
              _os_log_impl(&dword_182FBE000, v43, v74, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v73);
            if (!v42)
              goto LABEL_140;
LABEL_188:
            v72 = (char *)v42;
            goto LABEL_139;
          }
          if (v75)
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 1024;
            *(_DWORD *)v111 = v40;
            _os_log_impl(&dword_182FBE000, v43, v74, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v43 = objc_claimAutoreleasedReturnValue();
          v81 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)buf = 136446466;
            v109 = "networkd_privileged_setup_feth_pair";
            v110 = 1024;
            *(_DWORD *)v111 = v40;
            _os_log_impl(&dword_182FBE000, v43, v81, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_187:
      if (!v42)
        goto LABEL_140;
      goto LABEL_188;
    }
    __nwlog_obj();
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    v63 = networkd_privileged_result_to_string(v40);
    *(_DWORD *)buf = 136446722;
    v109 = "networkd_privileged_setup_feth_pair";
    v110 = 2048;
    *(_QWORD *)v111 = v40;
    *(_WORD *)&v111[8] = 2082;
    *(_QWORD *)&v111[10] = v63;
    v42 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v106 = 0;
    if (!__nwlog_fault(v42, &type, &v106))
      goto LABEL_187;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v64 = objc_claimAutoreleasedReturnValue();
      v65 = type;
      if (os_log_type_enabled(v64, type))
      {
        *(_DWORD *)buf = 136446722;
        v109 = "networkd_privileged_setup_feth_pair";
        v110 = 2048;
        *(_QWORD *)v111 = v40;
        *(_WORD *)&v111[8] = 2082;
        *(_QWORD *)&v111[10] = v63;
        _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v106)
    {
      v76 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v64 = objc_claimAutoreleasedReturnValue();
      v77 = type;
      v78 = os_log_type_enabled(v64, type);
      if (v76)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446978;
          v109 = "networkd_privileged_setup_feth_pair";
          v110 = 2048;
          *(_QWORD *)v111 = v40;
          *(_WORD *)&v111[8] = 2082;
          *(_QWORD *)&v111[10] = v63;
          v112 = 2082;
          v113 = v76;
          _os_log_impl(&dword_182FBE000, v64, v77, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v76);
        goto LABEL_187;
      }
      if (v78)
      {
        *(_DWORD *)buf = 136446722;
        v109 = "networkd_privileged_setup_feth_pair";
        v110 = 2048;
        *(_QWORD *)v111 = v40;
        *(_WORD *)&v111[8] = 2082;
        *(_QWORD *)&v111[10] = v63;
        _os_log_impl(&dword_182FBE000, v64, v77, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v64 = objc_claimAutoreleasedReturnValue();
      v82 = type;
      if (os_log_type_enabled(v64, type))
      {
        *(_DWORD *)buf = 136446722;
        v109 = "networkd_privileged_setup_feth_pair";
        v110 = 2048;
        *(_QWORD *)v111 = v40;
        *(_WORD *)&v111[8] = 2082;
        *(_QWORD *)&v111[10] = v63;
        _os_log_impl(&dword_182FBE000, v64, v82, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_187;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v109 = "networkd_privileged_setup_feth_pair";
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v106 = 0;
  if (__nwlog_fault(v15, &type, &v106))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s received NULL response", buf, 0xCu);
      }
    }
    else if (v106)
    {
      v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      v25 = type;
      v26 = os_log_type_enabled(v16, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v109 = "networkd_privileged_setup_feth_pair";
          v110 = 2082;
          *(_QWORD *)v111 = v24;
          _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        if (!v15)
          goto LABEL_81;
        goto LABEL_80;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      v34 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v109 = "networkd_privileged_setup_feth_pair";
        _os_log_impl(&dword_182FBE000, v16, v34, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
  if (v15)
LABEL_80:
    free(v15);
LABEL_81:
  v50 = 0;
LABEL_178:

LABEL_179:
  return v50;
}

void sub_183342ABC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void networkd_privileged_teardown_feth_pair(const char *a1, const char *a2)
{
  xpc_object_t v4;
  void *v5;
  xpc_object_t v6;
  void *v7;
  Class Class;
  char *v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  id v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  void *v18;
  id v19;
  const char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  id v26;
  os_log_type_t v27;
  char *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  id v31;
  os_log_type_t v32;
  os_log_type_t v33;
  id v34;
  os_log_type_t v35;
  unint64_t value;
  uint64_t v37;
  void *v38;
  const char *v39;
  NSObject *v40;
  os_log_type_t v41;
  os_log_type_t v42;
  char *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  os_log_type_t v46;
  _BOOL4 v47;
  NSObject *v48;
  os_log_type_t v49;
  _BOOL4 v50;
  id v51;
  os_log_type_t v52;
  char *v53;
  os_log_type_t v54;
  _BOOL4 v55;
  void *v56;
  const char *v57;
  NSObject *v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  os_log_type_t v62;
  _BOOL4 v63;
  os_log_type_t v64;
  char *v65;
  char *v66;
  os_log_type_t v67;
  _BOOL4 v68;
  char *v69;
  os_log_type_t v70;
  _BOOL4 v71;
  os_log_type_t v72;
  os_log_type_t v73;
  os_log_type_t v74;
  os_log_type_t v75;
  void *v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  void *v80;
  os_log_type_t v81;
  void *v82;
  char *v83;
  NSObject *v84;
  os_log_type_t v85;
  char *backtrace_string;
  os_log_type_t v87;
  _BOOL4 v88;
  char *v89;
  os_log_type_t v90;
  _BOOL4 v91;
  char *v92;
  os_log_type_t v93;
  _BOOL4 v94;
  os_log_type_t v95;
  os_log_type_t v96;
  os_log_type_t v97;
  char v98;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v101;
  __int16 v102;
  _BYTE v103[18];
  __int16 v104;
  char *v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v76 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v101 = "networkd_privileged_teardown_feth_pair";
    v77 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (!__nwlog_fault(v77, &type, &v98))
      goto LABEL_225;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v79 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null ifname1", buf, 0xCu);
      }
    }
    else if (v98)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v87 = type;
      v88 = os_log_type_enabled(v78, type);
      if (backtrace_string)
      {
        if (v88)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(_QWORD *)v103 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v78, v87, "%{public}s called with null ifname1, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_225;
      }
      if (v88)
      {
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_182FBE000, v78, v87, "%{public}s called with null ifname1, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v95 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_182FBE000, v78, v95, "%{public}s called with null ifname1, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_224:

    goto LABEL_225;
  }
  if (a2)
  {
    v4 = xpc_dictionary_create(0, 0, 0);
    v5 = v4;
    if (v4)
    {
      xpc_dictionary_set_uint64(v4, (const char *)networkd_privileged_key_type, 0x12uLL);
      xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_interface_name, a1);
      xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_second_interface_name, a2);
      v6 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_teardown_feth_pair", v5);
      v7 = v6;
      if (!v6)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        v9 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v98 = 0;
        if (!__nwlog_fault(v9, &type, &v98))
          goto LABEL_77;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = (id)gLogObj;
          v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s received NULL response", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (!v98)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = (id)gLogObj;
          v33 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v15, v33, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_76;
        }
        v23 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = (id)gLogObj;
        v24 = type;
        v25 = os_log_type_enabled(v15, type);
        if (!v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s received NULL response, no backtrace", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(_QWORD *)v103 = v23;
          _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_28;
      }
      Class = object_getClass(v6);
      if (Class != (Class)MEMORY[0x1E0C812F8])
      {
        if (Class != (Class)MEMORY[0x1E0C81310])
        {
          v9 = (char *)MEMORY[0x186DB5A08](v7);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(_QWORD *)v103 = v9;
          v11 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v98 = 0;
          if (!__nwlog_fault(v11, &type, &v98))
            goto LABEL_67;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v12 = (id)gLogObj;
            v13 = type;
            if (os_log_type_enabled(v12, type))
            {
              *(_DWORD *)buf = 136446466;
              v101 = "networkd_privileged_teardown_feth_pair";
              v102 = 2082;
              *(_QWORD *)v103 = v9;
              _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
            }
LABEL_66:

LABEL_67:
            if (!v11)
              goto LABEL_77;
            goto LABEL_68;
          }
          if (!v98)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v12 = (id)gLogObj;
            v42 = type;
            if (os_log_type_enabled(v12, type))
            {
              *(_DWORD *)buf = 136446466;
              v101 = "networkd_privileged_teardown_feth_pair";
              v102 = 2082;
              *(_QWORD *)v103 = v9;
              _os_log_impl(&dword_182FBE000, v12, v42, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_66;
          }
          v28 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = (id)gLogObj;
          v29 = type;
          v30 = os_log_type_enabled(v12, type);
          if (!v28)
          {
            if (v30)
            {
              *(_DWORD *)buf = 136446466;
              v101 = "networkd_privileged_teardown_feth_pair";
              v102 = 2082;
              *(_QWORD *)v103 = v9;
              _os_log_impl(&dword_182FBE000, v12, v29, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
            }
            goto LABEL_66;
          }
          if (v30)
          {
            *(_DWORD *)buf = 136446722;
            v101 = "networkd_privileged_teardown_feth_pair";
            v102 = 2082;
            *(_QWORD *)v103 = v9;
            *(_WORD *)&v103[8] = 2082;
            *(_QWORD *)&v103[10] = v28;
            _os_log_impl(&dword_182FBE000, v12, v29, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v28);
          if (!v11)
          {
LABEL_77:
            if (!v9)
            {
LABEL_136:

LABEL_137:
              return;
            }
LABEL_78:
            free(v9);
            goto LABEL_136;
          }
LABEL_68:
          free(v11);
          goto LABEL_77;
        }
        if (v7 == (void *)MEMORY[0x1E0C81258])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v34 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v101 = "networkd_privileged_teardown_feth_pair";
          v9 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v98 = 0;
          if (!__nwlog_fault(v9, &type, &v98))
            goto LABEL_77;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v15 = (id)gLogObj;
            v35 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_182FBE000, v15, v35, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
            }
            goto LABEL_76;
          }
          if (!v98)
          {
            __nwlog_obj();
            v15 = objc_claimAutoreleasedReturnValue();
            v64 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_182FBE000, v15, v64, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_76;
          }
          v23 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v15 = objc_claimAutoreleasedReturnValue();
          v49 = type;
          v50 = os_log_type_enabled(v15, type);
          if (!v23)
          {
            if (v50)
            {
              *(_DWORD *)buf = 136446210;
              v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_182FBE000, v15, v49, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
            }
            goto LABEL_76;
          }
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            v101 = "networkd_privileged_teardown_feth_pair";
            v102 = 2082;
            *(_QWORD *)v103 = v23;
            _os_log_impl(&dword_182FBE000, v15, v49, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
        else
        {
          if (v7 == (void *)MEMORY[0x1E0C81260])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = (id)gLogObj;
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
            }

            goto LABEL_136;
          }
          if (v7 != (void *)MEMORY[0x1E0C81288])
          {
            v9 = (char *)MEMORY[0x186DB5A08](v7);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v26 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            v101 = "networkd_privileged_teardown_feth_pair";
            v102 = 2082;
            *(_QWORD *)v103 = v9;
            v11 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v98 = 0;
            if (!__nwlog_fault(v11, &type, &v98))
              goto LABEL_67;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v12 = objc_claimAutoreleasedReturnValue();
              v27 = type;
              if (os_log_type_enabled(v12, type))
              {
                *(_DWORD *)buf = 136446466;
                v101 = "networkd_privileged_teardown_feth_pair";
                v102 = 2082;
                *(_QWORD *)v103 = v9;
                _os_log_impl(&dword_182FBE000, v12, v27, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
              }
              goto LABEL_66;
            }
            if (!v98)
            {
              __nwlog_obj();
              v12 = objc_claimAutoreleasedReturnValue();
              v72 = type;
              if (os_log_type_enabled(v12, type))
              {
                *(_DWORD *)buf = 136446466;
                v101 = "networkd_privileged_teardown_feth_pair";
                v102 = 2082;
                *(_QWORD *)v103 = v9;
                _os_log_impl(&dword_182FBE000, v12, v72, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
              }
              goto LABEL_66;
            }
            v53 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v12 = objc_claimAutoreleasedReturnValue();
            v54 = type;
            v55 = os_log_type_enabled(v12, type);
            if (!v53)
            {
              if (v55)
              {
                *(_DWORD *)buf = 136446466;
                v101 = "networkd_privileged_teardown_feth_pair";
                v102 = 2082;
                *(_QWORD *)v103 = v9;
                _os_log_impl(&dword_182FBE000, v12, v54, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
              }
              goto LABEL_66;
            }
            if (v55)
            {
              *(_DWORD *)buf = 136446722;
              v101 = "networkd_privileged_teardown_feth_pair";
              v102 = 2082;
              *(_QWORD *)v103 = v9;
              *(_WORD *)&v103[8] = 2082;
              *(_QWORD *)&v103[10] = v53;
              _os_log_impl(&dword_182FBE000, v12, v54, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v53);
            if (!v11)
              goto LABEL_77;
            goto LABEL_68;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v51 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v101 = "networkd_privileged_teardown_feth_pair";
          v9 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v98 = 0;
          if (!__nwlog_fault(v9, &type, &v98))
            goto LABEL_77;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v15 = objc_claimAutoreleasedReturnValue();
            v52 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_182FBE000, v15, v52, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
            }
LABEL_76:

            goto LABEL_77;
          }
          if (!v98)
          {
            __nwlog_obj();
            v15 = objc_claimAutoreleasedReturnValue();
            v73 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_182FBE000, v15, v73, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_76;
          }
          v23 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v15 = objc_claimAutoreleasedReturnValue();
          v62 = type;
          v63 = os_log_type_enabled(v15, type);
          if (!v23)
          {
            if (v63)
            {
              *(_DWORD *)buf = 136446210;
              v101 = "networkd_privileged_teardown_feth_pair";
              _os_log_impl(&dword_182FBE000, v15, v62, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
            }
            goto LABEL_76;
          }
          if (v63)
          {
            *(_DWORD *)buf = 136446466;
            v101 = "networkd_privileged_teardown_feth_pair";
            v102 = 2082;
            *(_QWORD *)v103 = v23;
            _os_log_impl(&dword_182FBE000, v15, v62, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
LABEL_28:

        free(v23);
        if (!v9)
          goto LABEL_136;
        goto LABEL_78;
      }
      xpc_dictionary_get_value(v7, (const char *)networkd_privileged_key_result);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = v17;
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v31 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        v20 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v98 = 0;
        if (!__nwlog_fault(v20, &type, &v98))
          goto LABEL_132;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          v32 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v21, v32, "%{public}s received response without result code", buf, 0xCu);
          }
          goto LABEL_131;
        }
        if (!v98)
        {
          __nwlog_obj();
          v21 = objc_claimAutoreleasedReturnValue();
          v61 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v21, v61, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_131;
        }
        v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        v47 = os_log_type_enabled(v21, type);
        if (!v43)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v21, v46, "%{public}s received response without result code, no backtrace", buf, 0xCu);
          }
          goto LABEL_131;
        }
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(_QWORD *)v103 = v43;
          _os_log_impl(&dword_182FBE000, v21, v46, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_83;
      }
      if (object_getClass(v17) != (Class)MEMORY[0x1E0C81328])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        v20 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v98 = 0;
        if (!__nwlog_fault(v20, &type, &v98))
          goto LABEL_132;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          v22 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s received invalid result type", buf, 0xCu);
          }
LABEL_131:

LABEL_132:
          if (v20)
          {
LABEL_133:
            v65 = (char *)v20;
LABEL_134:
            free(v65);
          }
LABEL_135:

          goto LABEL_136;
        }
        if (!v98)
        {
          __nwlog_obj();
          v21 = objc_claimAutoreleasedReturnValue();
          v60 = type;
          if (os_log_type_enabled(v21, type))
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v21, v60, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_131;
        }
        v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        v45 = os_log_type_enabled(v21, type);
        if (!v43)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            v101 = "networkd_privileged_teardown_feth_pair";
            _os_log_impl(&dword_182FBE000, v21, v44, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
          }
          goto LABEL_131;
        }
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(_QWORD *)v103 = v43;
          _os_log_impl(&dword_182FBE000, v21, v44, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_83:

        free(v43);
        if (!v20)
          goto LABEL_135;
        goto LABEL_133;
      }
      value = xpc_int64_get_value(v18);
      v37 = value;
      if (!value)
        goto LABEL_135;
      if (!(value >> 31))
      {
        __nwlog_obj();
        v38 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446466;
        v101 = "networkd_privileged_teardown_feth_pair";
        v102 = 1024;
        *(_DWORD *)v103 = v37;
        v39 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v98 = 0;
        if (__nwlog_fault(v39, &type, &v98))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v40 = objc_claimAutoreleasedReturnValue();
            v41 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)buf = 136446466;
              v101 = "networkd_privileged_teardown_feth_pair";
              v102 = 1024;
              *(_DWORD *)v103 = v37;
              _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
            }
          }
          else if (v98)
          {
            v66 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v40 = objc_claimAutoreleasedReturnValue();
            v67 = type;
            v68 = os_log_type_enabled(v40, type);
            if (v66)
            {
              if (v68)
              {
                *(_DWORD *)buf = 136446722;
                v101 = "networkd_privileged_teardown_feth_pair";
                v102 = 1024;
                *(_DWORD *)v103 = v37;
                *(_WORD *)&v103[4] = 2082;
                *(_QWORD *)&v103[6] = v66;
                _os_log_impl(&dword_182FBE000, v40, v67, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v66);
              if (!v39)
                goto LABEL_135;
LABEL_178:
              v65 = (char *)v39;
              goto LABEL_134;
            }
            if (v68)
            {
              *(_DWORD *)buf = 136446466;
              v101 = "networkd_privileged_teardown_feth_pair";
              v102 = 1024;
              *(_DWORD *)v103 = v37;
              _os_log_impl(&dword_182FBE000, v40, v67, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
            }
          }
          else
          {
            __nwlog_obj();
            v40 = objc_claimAutoreleasedReturnValue();
            v74 = type;
            if (os_log_type_enabled(v40, type))
            {
              *(_DWORD *)buf = 136446466;
              v101 = "networkd_privileged_teardown_feth_pair";
              v102 = 1024;
              *(_DWORD *)v103 = v37;
              _os_log_impl(&dword_182FBE000, v40, v74, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
            }
          }

        }
LABEL_177:
        if (!v39)
          goto LABEL_135;
        goto LABEL_178;
      }
      __nwlog_obj();
      v56 = (void *)objc_claimAutoreleasedReturnValue();
      v57 = networkd_privileged_result_to_string(v37);
      *(_DWORD *)buf = 136446722;
      v101 = "networkd_privileged_teardown_feth_pair";
      v102 = 2048;
      *(_QWORD *)v103 = v37;
      *(_WORD *)&v103[8] = 2082;
      *(_QWORD *)&v103[10] = v57;
      v39 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v98 = 0;
      if (!__nwlog_fault(v39, &type, &v98))
        goto LABEL_177;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446722;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2048;
          *(_QWORD *)v103 = v37;
          *(_WORD *)&v103[8] = 2082;
          *(_QWORD *)&v103[10] = v57;
          _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
        }
      }
      else if (v98)
      {
        v69 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        v70 = type;
        v71 = os_log_type_enabled(v58, type);
        if (v69)
        {
          if (v71)
          {
            *(_DWORD *)buf = 136446978;
            v101 = "networkd_privileged_teardown_feth_pair";
            v102 = 2048;
            *(_QWORD *)v103 = v37;
            *(_WORD *)&v103[8] = 2082;
            *(_QWORD *)&v103[10] = v57;
            v104 = 2082;
            v105 = v69;
            _os_log_impl(&dword_182FBE000, v58, v70, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v69);
          goto LABEL_177;
        }
        if (v71)
        {
          *(_DWORD *)buf = 136446722;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2048;
          *(_QWORD *)v103 = v37;
          *(_WORD *)&v103[8] = 2082;
          *(_QWORD *)&v103[10] = v57;
          _os_log_impl(&dword_182FBE000, v58, v70, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        __nwlog_obj();
        v58 = objc_claimAutoreleasedReturnValue();
        v75 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446722;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2048;
          *(_QWORD *)v103 = v37;
          *(_WORD *)&v103[8] = 2082;
          *(_QWORD *)&v103[10] = v57;
          _os_log_impl(&dword_182FBE000, v58, v75, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }

      goto LABEL_177;
    }
    __nwlog_obj();
    v82 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v101 = "networkd_privileged_teardown_feth_pair";
    v83 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (__nwlog_fault(v83, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v84 = objc_claimAutoreleasedReturnValue();
        v85 = type;
        if (os_log_type_enabled(v84, type))
        {
          *(_DWORD *)buf = 136446210;
          v101 = "networkd_privileged_teardown_feth_pair";
          _os_log_impl(&dword_182FBE000, v84, v85, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v98)
      {
        v92 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v84 = objc_claimAutoreleasedReturnValue();
        v93 = type;
        v94 = os_log_type_enabled(v84, type);
        if (v92)
        {
          if (v94)
          {
            *(_DWORD *)buf = 136446466;
            v101 = "networkd_privileged_teardown_feth_pair";
            v102 = 2082;
            *(_QWORD *)v103 = v92;
            _os_log_impl(&dword_182FBE000, v84, v93, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v92);
          goto LABEL_230;
        }
        if (v94)
        {
          *(_DWORD *)buf = 136446210;
          v101 = "networkd_privileged_teardown_feth_pair";
          _os_log_impl(&dword_182FBE000, v84, v93, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v84 = objc_claimAutoreleasedReturnValue();
        v97 = type;
        if (os_log_type_enabled(v84, type))
        {
          *(_DWORD *)buf = 136446210;
          v101 = "networkd_privileged_teardown_feth_pair";
          _os_log_impl(&dword_182FBE000, v84, v97, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_230:
    if (v83)
      free(v83);
    goto LABEL_137;
  }
  __nwlog_obj();
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v101 = "networkd_privileged_teardown_feth_pair";
  v77 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v98 = 0;
  if (__nwlog_fault(v77, &type, &v98))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v81 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_182FBE000, v78, v81, "%{public}s called with null ifname2", buf, 0xCu);
      }
    }
    else if (v98)
    {
      v89 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v90 = type;
      v91 = os_log_type_enabled(v78, type);
      if (v89)
      {
        if (v91)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "networkd_privileged_teardown_feth_pair";
          v102 = 2082;
          *(_QWORD *)v103 = v89;
          _os_log_impl(&dword_182FBE000, v78, v90, "%{public}s called with null ifname2, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v89);
        if (v77)
          goto LABEL_226;
        return;
      }
      if (v91)
      {
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_182FBE000, v78, v90, "%{public}s called with null ifname2, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v96 = type;
      if (os_log_type_enabled(v78, type))
      {
        *(_DWORD *)buf = 136446210;
        v101 = "networkd_privileged_teardown_feth_pair";
        _os_log_impl(&dword_182FBE000, v78, v96, "%{public}s called with null ifname2, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_224;
  }
LABEL_225:
  if (v77)
LABEL_226:
    free(v77);
}

void sub_1833447B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

const char *networkd_privileged_type_to_string(int a1)
{
  if ((a1 - 2) > 0x14)
    return "unknown";
  else
    return off_1E149A140[a1 - 2];
}

void networkd_privileged_send_async_inner(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  id v10;

  v10 = a2;
  v7 = a3;
  v8 = a4;
  v9 = networkd_privileged_copy_connection();
  if (v9)
    networkd_privileged_send_async_inner_rec(a1, v9, v10, v7, v8, 1u);

}

void sub_18334489C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void networkd_privileged_send_async_inner_rec(uint64_t a1, void *a2, void *a3, void *a4, void *a5, unsigned int a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  void *v15;
  _QWORD v16[4];
  _xpc_connection_s *v17;
  id v18;
  NSObject *v19;
  id v20;
  uint64_t v21;
  unsigned int v22;

  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v15 = v14;
  if (a6 >= 6)
  {
    (*((void (**)(id, _QWORD))v14 + 2))(v14, MEMORY[0x1E0C81258]);
  }
  else
  {
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = ___ZL40networkd_privileged_send_async_inner_recPKcPU24objcproto13OS_xpc_object8NSObjectS3_PU28objcproto17OS_dispatch_queueS1_U13block_pointerFvS3_Ej_block_invoke;
    v16[3] = &unk_1E149A120;
    v20 = v14;
    v21 = a1;
    v22 = a6;
    v17 = (_xpc_connection_s *)v11;
    v18 = v12;
    v19 = v13;
    xpc_connection_send_message_with_reply(v17, v18, v19, v16);

  }
}

void sub_1833449E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void ___ZL40networkd_privileged_send_async_inner_recPKcPU24objcproto13OS_xpc_object8NSObjectS3_PU28objcproto17OS_dispatch_queueS1_U13block_pointerFvS3_Ej_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (v3 == (id)MEMORY[0x1E0C81258])
  {
    __nwlog_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *(_QWORD *)(a1 + 64);
      v6 = *(_DWORD *)(a1 + 72);
      v7 = 136446722;
      v8 = "networkd_privileged_send_async_inner_rec_block_invoke";
      v9 = 2082;
      v10 = v5;
      v11 = 1024;
      v12 = v6;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, retrying (%u)", (uint8_t *)&v7, 0x1Cu);
    }

    networkd_privileged_send_async_inner_rec(*(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), (*(_DWORD *)(a1 + 72) + 1));
  }
  else
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 56) + 16))();
  }

}

void sub_183344B40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __networkd_privileged_check_mobile_asset_block_invoke(uint64_t a1, void *a2)
{
  id v2;
  void *v3;
  Class Class;
  char *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  id v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  void *v14;
  id v15;
  const char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  id v22;
  os_log_type_t v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  id v27;
  os_log_type_t v28;
  os_log_type_t v29;
  id v30;
  os_log_type_t v31;
  unint64_t value;
  uint64_t v33;
  void *v34;
  const char *v35;
  NSObject *v36;
  os_log_type_t v37;
  os_log_type_t v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  _BOOL4 v43;
  NSObject *v44;
  os_log_type_t v45;
  _BOOL4 v46;
  id v47;
  os_log_type_t v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  void *v52;
  const char *v53;
  NSObject *v54;
  os_log_type_t v55;
  os_log_type_t v56;
  os_log_type_t v57;
  os_log_type_t v58;
  _BOOL4 v59;
  os_log_type_t v60;
  char *v61;
  char *v62;
  os_log_type_t v63;
  _BOOL4 v64;
  char *v65;
  os_log_type_t v66;
  _BOOL4 v67;
  os_log_type_t v68;
  os_log_type_t v69;
  os_log_type_t v70;
  os_log_type_t v71;
  char v72;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v75;
  __int16 v76;
  _BYTE v77[18];
  __int16 v78;
  char *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  v3 = v2;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v75 = "networkd_privileged_check_mobile_asset_block_invoke";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v72 = 0;
    if (!__nwlog_fault(v5, &type, &v72))
      goto LABEL_74;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s received NULL response", buf, 0xCu);
      }
      goto LABEL_73;
    }
    if (!v72)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        _os_log_impl(&dword_182FBE000, v11, v29, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    v20 = type;
    v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
      goto LABEL_73;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  Class = object_getClass(v2);
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    xpc_dictionary_get_value(v3, (const char *)networkd_privileged_key_result);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = v13;
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v16 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v16, &type, &v72))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        v28 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (!v72)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v57 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v57, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v42 = type;
      v43 = os_log_type_enabled(v17, type);
      if (!v39)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v42, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = v39;
        _os_log_impl(&dword_182FBE000, v17, v42, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_80;
    }
    if (object_getClass(v13) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v16 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v16, &type, &v72))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_131:

LABEL_132:
        if (!v16)
        {
LABEL_135:

          goto LABEL_136;
        }
        goto LABEL_133;
      }
      if (!v72)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v56, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v40 = type;
      v41 = os_log_type_enabled(v17, type);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v40, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = v39;
        _os_log_impl(&dword_182FBE000, v17, v40, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_80:

      free(v39);
      if (!v16)
        goto LABEL_135;
LABEL_133:
      v61 = (char *)v16;
LABEL_134:
      free(v61);
      goto LABEL_135;
    }
    value = xpc_int64_get_value(v14);
    v33 = value;
    if (!value)
    {

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v44 = (id)gLogObj;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Successfully checked mobile asset", buf, 0xCu);
      }
      goto LABEL_84;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v76 = 1024;
      *(_DWORD *)v77 = v33;
      v35 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (__nwlog_fault(v35, &type, &v72))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v37 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            v76 = 1024;
            *(_DWORD *)v77 = v33;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v72)
        {
          v62 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v63 = type;
          v64 = os_log_type_enabled(v36, type);
          if (v62)
          {
            if (v64)
            {
              *(_DWORD *)buf = 136446722;
              v75 = "networkd_privileged_check_mobile_asset_block_invoke";
              v76 = 1024;
              *(_DWORD *)v77 = v33;
              *(_WORD *)&v77[4] = 2082;
              *(_QWORD *)&v77[6] = v62;
              _os_log_impl(&dword_182FBE000, v36, v63, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v62);
            if (!v35)
              goto LABEL_135;
LABEL_176:
            v61 = (char *)v35;
            goto LABEL_134;
          }
          if (v64)
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            v76 = 1024;
            *(_DWORD *)v77 = v33;
            _os_log_impl(&dword_182FBE000, v36, v63, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            v76 = 1024;
            *(_DWORD *)v77 = v33;
            _os_log_impl(&dword_182FBE000, v36, v70, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_175:
      if (!v35)
        goto LABEL_135;
      goto LABEL_176;
    }
    __nwlog_obj();
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    v53 = networkd_privileged_result_to_string(v33);
    *(_DWORD *)buf = 136446722;
    v75 = "networkd_privileged_check_mobile_asset_block_invoke";
    v76 = 2048;
    *(_QWORD *)v77 = v33;
    *(_WORD *)&v77[8] = 2082;
    *(_QWORD *)&v77[10] = v53;
    v35 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v72 = 0;
    if (!__nwlog_fault(v35, &type, &v72))
      goto LABEL_175;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2048;
        *(_QWORD *)v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(_QWORD *)&v77[10] = v53;
        _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v72)
    {
      v65 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v66 = type;
      v67 = os_log_type_enabled(v54, type);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446978;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          v76 = 2048;
          *(_QWORD *)v77 = v33;
          *(_WORD *)&v77[8] = 2082;
          *(_QWORD *)&v77[10] = v53;
          v78 = 2082;
          v79 = v65;
          _os_log_impl(&dword_182FBE000, v54, v66, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v65);
        goto LABEL_175;
      }
      if (v67)
      {
        *(_DWORD *)buf = 136446722;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2048;
        *(_QWORD *)v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(_QWORD *)&v77[10] = v53;
        _os_log_impl(&dword_182FBE000, v54, v66, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v71 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2048;
        *(_QWORD *)v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(_QWORD *)&v77[10] = v53;
        _os_log_impl(&dword_182FBE000, v54, v71, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_175;
  }
  if (Class == (Class)MEMORY[0x1E0C81310])
  {
    if (v3 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v5 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v5, &type, &v72))
        goto LABEL_74;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v31 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v31, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (!v72)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v60, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_73;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      v46 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v45, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v45, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    if (v3 != (void *)MEMORY[0x1E0C81260])
    {
      if (v3 != (void *)MEMORY[0x1E0C81288])
      {
        v5 = (char *)MEMORY[0x186DB5A08](v3);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = v5;
        v7 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v72 = 0;
        if (!__nwlog_fault(v7, &type, &v72))
          goto LABEL_64;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v8 = objc_claimAutoreleasedReturnValue();
          v23 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            v76 = 2082;
            *(_QWORD *)v77 = v5;
            _os_log_impl(&dword_182FBE000, v8, v23, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_63;
        }
        if (!v72)
        {
          __nwlog_obj();
          v8 = objc_claimAutoreleasedReturnValue();
          v68 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            v76 = 2082;
            *(_QWORD *)v77 = v5;
            _os_log_impl(&dword_182FBE000, v8, v68, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_63;
        }
        v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v50 = type;
        v51 = os_log_type_enabled(v8, type);
        if (!v49)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_check_mobile_asset_block_invoke";
            v76 = 2082;
            *(_QWORD *)v77 = v5;
            _os_log_impl(&dword_182FBE000, v8, v50, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_63;
        }
        if (v51)
        {
          *(_DWORD *)buf = 136446722;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          v76 = 2082;
          *(_QWORD *)v77 = v5;
          *(_WORD *)&v77[8] = 2082;
          *(_QWORD *)&v77[10] = v49;
          _os_log_impl(&dword_182FBE000, v8, v50, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v49);
        if (!v7)
          goto LABEL_74;
LABEL_65:
        free(v7);
        goto LABEL_74;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v47 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v5 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v5, &type, &v72))
        goto LABEL_74;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v48, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_73:

        goto LABEL_74;
      }
      if (!v72)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v69 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v69, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_73;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      v59 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_check_mobile_asset_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v58, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (v59)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_check_mobile_asset_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v58, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_25:

      free(backtrace_string);
      if (!v5)
        goto LABEL_136;
      goto LABEL_75;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = (id)gLogObj;
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
    }
LABEL_84:

    goto LABEL_136;
  }
  v5 = (char *)MEMORY[0x186DB5A08](v3);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v75 = "networkd_privileged_check_mobile_asset_block_invoke";
  v76 = 2082;
  *(_QWORD *)v77 = v5;
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v72 = 0;
  if (!__nwlog_fault(v7, &type, &v72))
    goto LABEL_64;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = v5;
      _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }
LABEL_63:

LABEL_64:
    if (!v7)
      goto LABEL_74;
    goto LABEL_65;
  }
  if (!v72)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    v38 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = v5;
      _os_log_impl(&dword_182FBE000, v8, v38, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_63;
  }
  v24 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  v25 = type;
  v26 = os_log_type_enabled(v8, type);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_check_mobile_asset_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = v5;
      _os_log_impl(&dword_182FBE000, v8, v25, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_63;
  }
  if (v26)
  {
    *(_DWORD *)buf = 136446722;
    v75 = "networkd_privileged_check_mobile_asset_block_invoke";
    v76 = 2082;
    *(_QWORD *)v77 = v5;
    *(_WORD *)&v77[8] = 2082;
    *(_QWORD *)&v77[10] = v24;
    _os_log_impl(&dword_182FBE000, v8, v25, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v24);
  if (v7)
    goto LABEL_65;
LABEL_74:
  if (v5)
LABEL_75:
    free(v5);
LABEL_136:

}

void sub_183346250(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __networkd_privileged_run_probes_block_invoke(uint64_t a1, void *a2)
{
  id v2;
  void *v3;
  Class Class;
  char *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  id v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  void *v14;
  id v15;
  const char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  id v22;
  os_log_type_t v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  id v27;
  os_log_type_t v28;
  os_log_type_t v29;
  id v30;
  os_log_type_t v31;
  unint64_t value;
  uint64_t v33;
  void *v34;
  const char *v35;
  NSObject *v36;
  os_log_type_t v37;
  os_log_type_t v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  _BOOL4 v43;
  NSObject *v44;
  os_log_type_t v45;
  _BOOL4 v46;
  id v47;
  os_log_type_t v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  void *v52;
  const char *v53;
  NSObject *v54;
  os_log_type_t v55;
  os_log_type_t v56;
  os_log_type_t v57;
  os_log_type_t v58;
  _BOOL4 v59;
  os_log_type_t v60;
  char *v61;
  char *v62;
  os_log_type_t v63;
  _BOOL4 v64;
  char *v65;
  os_log_type_t v66;
  _BOOL4 v67;
  os_log_type_t v68;
  os_log_type_t v69;
  os_log_type_t v70;
  os_log_type_t v71;
  char v72;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v75;
  __int16 v76;
  _BYTE v77[18];
  __int16 v78;
  char *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  v3 = v2;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v75 = "networkd_privileged_run_probes_block_invoke";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v72 = 0;
    if (!__nwlog_fault(v5, &type, &v72))
      goto LABEL_74;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_run_probes_block_invoke";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s received NULL response", buf, 0xCu);
      }
      goto LABEL_73;
    }
    if (!v72)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_run_probes_block_invoke";
        _os_log_impl(&dword_182FBE000, v11, v29, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    v20 = type;
    v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_run_probes_block_invoke";
        _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
      goto LABEL_73;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  Class = object_getClass(v2);
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    xpc_dictionary_get_value(v3, (const char *)networkd_privileged_key_result);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = v13;
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v16 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v16, &type, &v72))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        v28 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (!v72)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v57 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v57, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v42 = type;
      v43 = os_log_type_enabled(v17, type);
      if (!v39)
      {
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v42, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = v39;
        _os_log_impl(&dword_182FBE000, v17, v42, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_80;
    }
    if (object_getClass(v13) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v16 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v16, &type, &v72))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = (id)gLogObj;
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_131:

LABEL_132:
        if (!v16)
        {
LABEL_135:

          goto LABEL_136;
        }
        goto LABEL_133;
      }
      if (!v72)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v56, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v40 = type;
      v41 = os_log_type_enabled(v17, type);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v17, v40, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = v39;
        _os_log_impl(&dword_182FBE000, v17, v40, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_80:

      free(v39);
      if (!v16)
        goto LABEL_135;
LABEL_133:
      v61 = (char *)v16;
LABEL_134:
      free(v61);
      goto LABEL_135;
    }
    value = xpc_int64_get_value(v14);
    v33 = value;
    if (!value)
    {

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v44 = (id)gLogObj;
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v75 = "networkd_privileged_run_probes_block_invoke";
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Successfully ran network probes", buf, 0xCu);
      }
      goto LABEL_84;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v76 = 1024;
      *(_DWORD *)v77 = v33;
      v35 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (__nwlog_fault(v35, &type, &v72))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v37 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_run_probes_block_invoke";
            v76 = 1024;
            *(_DWORD *)v77 = v33;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v72)
        {
          v62 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v63 = type;
          v64 = os_log_type_enabled(v36, type);
          if (v62)
          {
            if (v64)
            {
              *(_DWORD *)buf = 136446722;
              v75 = "networkd_privileged_run_probes_block_invoke";
              v76 = 1024;
              *(_DWORD *)v77 = v33;
              *(_WORD *)&v77[4] = 2082;
              *(_QWORD *)&v77[6] = v62;
              _os_log_impl(&dword_182FBE000, v36, v63, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v62);
            if (!v35)
              goto LABEL_135;
LABEL_176:
            v61 = (char *)v35;
            goto LABEL_134;
          }
          if (v64)
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_run_probes_block_invoke";
            v76 = 1024;
            *(_DWORD *)v77 = v33;
            _os_log_impl(&dword_182FBE000, v36, v63, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_run_probes_block_invoke";
            v76 = 1024;
            *(_DWORD *)v77 = v33;
            _os_log_impl(&dword_182FBE000, v36, v70, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_175:
      if (!v35)
        goto LABEL_135;
      goto LABEL_176;
    }
    __nwlog_obj();
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    v53 = networkd_privileged_result_to_string(v33);
    *(_DWORD *)buf = 136446722;
    v75 = "networkd_privileged_run_probes_block_invoke";
    v76 = 2048;
    *(_QWORD *)v77 = v33;
    *(_WORD *)&v77[8] = 2082;
    *(_QWORD *)&v77[10] = v53;
    v35 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v72 = 0;
    if (!__nwlog_fault(v35, &type, &v72))
      goto LABEL_175;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v55 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2048;
        *(_QWORD *)v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(_QWORD *)&v77[10] = v53;
        _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v72)
    {
      v65 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v66 = type;
      v67 = os_log_type_enabled(v54, type);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446978;
          v75 = "networkd_privileged_run_probes_block_invoke";
          v76 = 2048;
          *(_QWORD *)v77 = v33;
          *(_WORD *)&v77[8] = 2082;
          *(_QWORD *)&v77[10] = v53;
          v78 = 2082;
          v79 = v65;
          _os_log_impl(&dword_182FBE000, v54, v66, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v65);
        goto LABEL_175;
      }
      if (v67)
      {
        *(_DWORD *)buf = 136446722;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2048;
        *(_QWORD *)v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(_QWORD *)&v77[10] = v53;
        _os_log_impl(&dword_182FBE000, v54, v66, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v71 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446722;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2048;
        *(_QWORD *)v77 = v33;
        *(_WORD *)&v77[8] = 2082;
        *(_QWORD *)&v77[10] = v53;
        _os_log_impl(&dword_182FBE000, v54, v71, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_175;
  }
  if (Class == (Class)MEMORY[0x1E0C81310])
  {
    if (v3 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v5 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v5, &type, &v72))
        goto LABEL_74;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v31 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v31, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (!v72)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v60, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_73;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      v46 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v45, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v45, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    if (v3 != (void *)MEMORY[0x1E0C81260])
    {
      if (v3 != (void *)MEMORY[0x1E0C81288])
      {
        v5 = (char *)MEMORY[0x186DB5A08](v3);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = v5;
        v7 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v72 = 0;
        if (!__nwlog_fault(v7, &type, &v72))
          goto LABEL_64;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v8 = objc_claimAutoreleasedReturnValue();
          v23 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_run_probes_block_invoke";
            v76 = 2082;
            *(_QWORD *)v77 = v5;
            _os_log_impl(&dword_182FBE000, v8, v23, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_63;
        }
        if (!v72)
        {
          __nwlog_obj();
          v8 = objc_claimAutoreleasedReturnValue();
          v68 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_run_probes_block_invoke";
            v76 = 2082;
            *(_QWORD *)v77 = v5;
            _os_log_impl(&dword_182FBE000, v8, v68, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_63;
        }
        v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v50 = type;
        v51 = os_log_type_enabled(v8, type);
        if (!v49)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            v75 = "networkd_privileged_run_probes_block_invoke";
            v76 = 2082;
            *(_QWORD *)v77 = v5;
            _os_log_impl(&dword_182FBE000, v8, v50, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_63;
        }
        if (v51)
        {
          *(_DWORD *)buf = 136446722;
          v75 = "networkd_privileged_run_probes_block_invoke";
          v76 = 2082;
          *(_QWORD *)v77 = v5;
          *(_WORD *)&v77[8] = 2082;
          *(_QWORD *)&v77[10] = v49;
          _os_log_impl(&dword_182FBE000, v8, v50, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v49);
        if (!v7)
          goto LABEL_74;
LABEL_65:
        free(v7);
        goto LABEL_74;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v47 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v5 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v72 = 0;
      if (!__nwlog_fault(v5, &type, &v72))
        goto LABEL_74;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v48, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_73:

        goto LABEL_74;
      }
      if (!v72)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v69 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v69, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_73;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      v59 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "networkd_privileged_run_probes_block_invoke";
          _os_log_impl(&dword_182FBE000, v11, v58, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_73;
      }
      if (v59)
      {
        *(_DWORD *)buf = 136446466;
        v75 = "networkd_privileged_run_probes_block_invoke";
        v76 = 2082;
        *(_QWORD *)v77 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v58, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_25:

      free(backtrace_string);
      if (!v5)
        goto LABEL_136;
      goto LABEL_75;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = (id)gLogObj;
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v75 = "networkd_privileged_run_probes_block_invoke";
      _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
    }
LABEL_84:

    goto LABEL_136;
  }
  v5 = (char *)MEMORY[0x186DB5A08](v3);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v75 = "networkd_privileged_run_probes_block_invoke";
  v76 = 2082;
  *(_QWORD *)v77 = v5;
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v72 = 0;
  if (!__nwlog_fault(v7, &type, &v72))
    goto LABEL_64;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = v5;
      _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }
LABEL_63:

LABEL_64:
    if (!v7)
      goto LABEL_74;
    goto LABEL_65;
  }
  if (!v72)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    v38 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = v5;
      _os_log_impl(&dword_182FBE000, v8, v38, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_63;
  }
  v24 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  v25 = type;
  v26 = os_log_type_enabled(v8, type);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v75 = "networkd_privileged_run_probes_block_invoke";
      v76 = 2082;
      *(_QWORD *)v77 = v5;
      _os_log_impl(&dword_182FBE000, v8, v25, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_63;
  }
  if (v26)
  {
    *(_DWORD *)buf = 136446722;
    v75 = "networkd_privileged_run_probes_block_invoke";
    v76 = 2082;
    *(_QWORD *)v77 = v5;
    *(_WORD *)&v77[8] = 2082;
    *(_QWORD *)&v77[10] = v24;
    _os_log_impl(&dword_182FBE000, v8, v25, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v24);
  if (v7)
    goto LABEL_65;
LABEL_74:
  if (v5)
LABEL_75:
    free(v5);
LABEL_136:

}

void sub_183347978(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __networkd_privileged_set_opportunistic_async_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __networkd_privileged_set_opportunistic_async_block_invoke_41(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  Class Class;
  void *v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  id v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  void *v16;
  id v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  id v24;
  os_log_type_t v25;
  char *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  id v29;
  os_log_type_t v30;
  os_log_type_t v31;
  id v32;
  NSObject *v33;
  os_log_type_t v34;
  unint64_t value;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  os_log_type_t v39;
  char *v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  _BOOL4 v44;
  NSObject *v45;
  char *v46;
  os_log_type_t v47;
  _BOOL4 v48;
  id v49;
  os_log_type_t v50;
  uint64_t uint64;
  char *v52;
  os_log_type_t v53;
  _BOOL4 v54;
  void *v55;
  const char *v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  os_log_type_t v62;
  _BOOL4 v63;
  os_log_type_t v64;
  NSObject *v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  NSObject *v70;
  int v71;
  const char *string_ptr;
  const char *v73;
  os_log_type_t v74;
  char *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  os_log_type_t v78;
  os_log_type_t v79;
  os_log_type_t v80;
  char v81;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v84;
  __int16 v85;
  _BYTE v86[18];
  __int16 v87;
  uint64_t v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v81 = 0;
    if (__nwlog_fault(v12, &type, &v81))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s received NULL response", buf, 0xCu);
        }
      }
      else if (v81)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v22 = type;
        v23 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
            v85 = 2082;
            *(_QWORD *)v86 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v12)
            goto LABEL_78;
          goto LABEL_77;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s received NULL response, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v31 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v13, v31, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v12)
      goto LABEL_78;
LABEL_77:
    free(v12);
    goto LABEL_78;
  }
  Class = object_getClass(v3);
  if (Class != (Class)MEMORY[0x1E0C812F8])
  {
    if (Class != (Class)MEMORY[0x1E0C81310])
    {
      v6 = (void *)MEMORY[0x186DB5A08](v4);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
      v85 = 2082;
      *(_QWORD *)v86 = v6;
      v8 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v81 = 0;
      if (!__nwlog_fault(v8, &type, &v81))
        goto LABEL_63;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446466;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          v85 = 2082;
          *(_QWORD *)v86 = v6;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
        }
LABEL_62:

LABEL_63:
        if (!v8)
          goto LABEL_65;
        goto LABEL_64;
      }
      if (!v81)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v39 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446466;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          v85 = 2082;
          *(_QWORD *)v86 = v6;
          _os_log_impl(&dword_182FBE000, v9, v39, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
        }
        goto LABEL_62;
      }
      v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v27 = type;
      v28 = os_log_type_enabled(v9, type);
      if (!v26)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          v85 = 2082;
          *(_QWORD *)v86 = v6;
          _os_log_impl(&dword_182FBE000, v9, v27, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
        }
        goto LABEL_62;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446722;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2082;
        *(_QWORD *)v86 = v6;
        *(_WORD *)&v86[8] = 2082;
        *(_QWORD *)&v86[10] = v26;
        _os_log_impl(&dword_182FBE000, v9, v27, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(v26);
      if (!v8)
      {
LABEL_65:
        if (v6)
LABEL_66:
          free(v6);
LABEL_78:
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), 0);
        goto LABEL_138;
      }
LABEL_64:
      free(v8);
      goto LABEL_65;
    }
    if (v4 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
      v6 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v81 = 0;
      if (!__nwlog_fault((const char *)v6, &type, &v81))
        goto LABEL_65;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = (id)gLogObj;
        v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_178;
      }
      if (!v81)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v64 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v33, v64, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_178;
      }
      v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      v48 = os_log_type_enabled(v33, type);
      if (!v46)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v33, v47, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_178;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446466;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2082;
        *(_QWORD *)v86 = v46;
        _os_log_impl(&dword_182FBE000, v33, v47, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
    else
    {
      if (v4 == (void *)MEMORY[0x1E0C81260])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v45 = (id)gLogObj;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
        }

        goto LABEL_78;
      }
      if (v4 != (void *)MEMORY[0x1E0C81288])
      {
        v6 = (void *)MEMORY[0x186DB5A08](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2082;
        *(_QWORD *)v86 = v6;
        v8 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v81 = 0;
        if (!__nwlog_fault(v8, &type, &v81))
          goto LABEL_63;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v25 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
            v85 = 2082;
            *(_QWORD *)v86 = v6;
            _os_log_impl(&dword_182FBE000, v9, v25, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (!v81)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v74 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
            v85 = 2082;
            *(_QWORD *)v86 = v6;
            _os_log_impl(&dword_182FBE000, v9, v74, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_62;
        }
        v52 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v53 = type;
        v54 = os_log_type_enabled(v9, type);
        if (!v52)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
            v85 = 2082;
            *(_QWORD *)v86 = v6;
            _os_log_impl(&dword_182FBE000, v9, v53, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (v54)
        {
          *(_DWORD *)buf = 136446722;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          v85 = 2082;
          *(_QWORD *)v86 = v6;
          *(_WORD *)&v86[8] = 2082;
          *(_QWORD *)&v86[10] = v52;
          _os_log_impl(&dword_182FBE000, v9, v53, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v52);
        if (!v8)
          goto LABEL_65;
        goto LABEL_64;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v49 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
      v6 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v81 = 0;
      if (!__nwlog_fault((const char *)v6, &type, &v81))
        goto LABEL_65;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v50 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v33, v50, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_178:

        goto LABEL_65;
      }
      if (!v81)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v33, v78, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_178;
      }
      v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v62 = type;
      v63 = os_log_type_enabled(v33, type);
      if (!v46)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446210;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          _os_log_impl(&dword_182FBE000, v33, v62, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_178;
      }
      if (v63)
      {
        *(_DWORD *)buf = 136446466;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2082;
        *(_QWORD *)v86 = v46;
        _os_log_impl(&dword_182FBE000, v33, v62, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v46);
    if (!v6)
      goto LABEL_78;
    goto LABEL_66;
  }
  xpc_dictionary_get_value(v4, (const char *)networkd_privileged_key_result);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = v15;
  if (!v15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v81 = 0;
    if (!__nwlog_fault(v18, &type, &v81))
      goto LABEL_135;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_182FBE000, v19, v30, "%{public}s received response without result code", buf, 0xCu);
      }
      goto LABEL_134;
    }
    if (!v81)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_182FBE000, v19, v61, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_134;
    }
    v40 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v43 = type;
    v44 = os_log_type_enabled(v19, type);
    if (!v40)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_182FBE000, v19, v43, "%{public}s received response without result code, no backtrace", buf, 0xCu);
      }
      goto LABEL_134;
    }
    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
      v85 = 2082;
      *(_QWORD *)v86 = v40;
      _os_log_impl(&dword_182FBE000, v19, v43, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_83;
  }
  if (object_getClass(v15) != (Class)MEMORY[0x1E0C81328])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v81 = 0;
    if (!__nwlog_fault(v18, &type, &v81))
      goto LABEL_135;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s received invalid result type", buf, 0xCu);
      }
LABEL_134:

LABEL_135:
      if (!v18)
      {
LABEL_137:
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), 0);

        goto LABEL_138;
      }
LABEL_136:
      free(v18);
      goto LABEL_137;
    }
    if (!v81)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v60 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_182FBE000, v19, v60, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_134;
    }
    v40 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v41 = type;
    v42 = os_log_type_enabled(v19, type);
    if (!v40)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        _os_log_impl(&dword_182FBE000, v19, v41, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
      }
      goto LABEL_134;
    }
    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
      v85 = 2082;
      *(_QWORD *)v86 = v40;
      _os_log_impl(&dword_182FBE000, v19, v41, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_83:

    free(v40);
    if (!v18)
      goto LABEL_137;
    goto LABEL_136;
  }
  value = xpc_int64_get_value(v16);
  v36 = value;
  if (value)
  {
    if (!(value >> 31))
    {
      __nwlog_obj();
      v37 = objc_claimAutoreleasedReturnValue();
      v38 = v37;
      if ((_DWORD)v36 == 6)
      {
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          v85 = 1024;
          *(_DWORD *)v86 = 6;
          _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_ERROR, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
        }

        goto LABEL_137;
      }
      *(_DWORD *)buf = 136446466;
      v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
      v85 = 1024;
      *(_DWORD *)v86 = v36;
      v57 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v81 = 0;
      if (__nwlog_fault(v57, &type, &v81))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
            v85 = 1024;
            *(_DWORD *)v86 = v36;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v81)
        {
          v75 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v76 = type;
          v77 = os_log_type_enabled(v65, type);
          if (v75)
          {
            if (v77)
            {
              *(_DWORD *)buf = 136446722;
              v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
              v85 = 1024;
              *(_DWORD *)v86 = v36;
              *(_WORD *)&v86[4] = 2082;
              *(_QWORD *)&v86[6] = v75;
              _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v75);
            if (!v57)
              goto LABEL_137;
            goto LABEL_189;
          }
          if (v77)
          {
            *(_DWORD *)buf = 136446466;
            v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
            v85 = 1024;
            *(_DWORD *)v86 = v36;
            _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v80 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
            v85 = 1024;
            *(_DWORD *)v86 = v36;
            _os_log_impl(&dword_182FBE000, v65, v80, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_188:
      if (!v57)
        goto LABEL_137;
LABEL_189:
      free(v57);
      goto LABEL_137;
    }
    __nwlog_obj();
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    v56 = networkd_privileged_result_to_string(v36);
    *(_DWORD *)buf = 136446722;
    v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    v85 = 2048;
    *(_QWORD *)v86 = v36;
    *(_WORD *)&v86[8] = 2082;
    *(_QWORD *)&v86[10] = v56;
    v57 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v81 = 0;
    if (!__nwlog_fault(v57, &type, &v81))
      goto LABEL_188;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v58 = objc_claimAutoreleasedReturnValue();
      v59 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446722;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2048;
        *(_QWORD *)v86 = v36;
        *(_WORD *)&v86[8] = 2082;
        *(_QWORD *)&v86[10] = v56;
        _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v81)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v58 = objc_claimAutoreleasedReturnValue();
      v68 = type;
      v69 = os_log_type_enabled(v58, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
          v85 = 2048;
          *(_QWORD *)v86 = v36;
          *(_WORD *)&v86[8] = 2082;
          *(_QWORD *)&v86[10] = v56;
          v87 = 2082;
          v88 = (uint64_t)v67;
          _os_log_impl(&dword_182FBE000, v58, v68, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v67);
        goto LABEL_188;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2048;
        *(_QWORD *)v86 = v36;
        *(_WORD *)&v86[8] = 2082;
        *(_QWORD *)&v86[10] = v56;
        _os_log_impl(&dword_182FBE000, v58, v68, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v58 = objc_claimAutoreleasedReturnValue();
      v79 = type;
      if (os_log_type_enabled(v58, type))
      {
        *(_DWORD *)buf = 136446722;
        v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
        v85 = 2048;
        *(_QWORD *)v86 = v36;
        *(_WORD *)&v86[8] = 2082;
        *(_QWORD *)&v86[10] = v56;
        _os_log_impl(&dword_182FBE000, v58, v79, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_188;
  }

  if (*(_BYTE *)(a1 + 48))
    uint64 = xpc_dictionary_get_uint64(v4, (const char *)networkd_privileged_key_opportunistic_inuse);
  else
    uint64 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v70 = (id)gLogObj;
  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
  {
    v71 = *(unsigned __int8 *)(a1 + 48);
    string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 32));
    v73 = "";
    *(_DWORD *)buf = 136446978;
    v84 = "networkd_privileged_set_opportunistic_async_block_invoke";
    v85 = 2082;
    if (!v71)
      v73 = "un";
    *(_QWORD *)v86 = v73;
    *(_WORD *)&v86[8] = 2082;
    *(_QWORD *)&v86[10] = string_ptr;
    v87 = 2048;
    v88 = uint64;
    _os_log_impl(&dword_182FBE000, v70, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully %{public}sblocked opportunistic traffic on \"%{public}s\" count=%llu", buf, 0x2Au);
  }

  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
LABEL_138:

}

void sub_18334920C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL networkd_privileged_set_settings(const char *a1, void *a2, const char *a3)
{
  id v5;
  xpc_object_t v6;
  void *v7;
  xpc_object_t v8;
  void *v9;
  Class Class;
  void *v11;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  id v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  void *v20;
  void *v21;
  id v22;
  const char *v23;
  NSObject *v24;
  os_log_type_t v25;
  char *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  id v29;
  os_log_type_t v30;
  char *backtrace_string;
  os_log_type_t v32;
  _BOOL4 v33;
  id v34;
  os_log_type_t v35;
  os_log_type_t v36;
  id v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  unint64_t value;
  uint64_t v42;
  void *v43;
  const char *v44;
  NSObject *v45;
  os_log_type_t v46;
  os_log_type_t v47;
  int v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  _BOOL8 v52;
  os_log_type_t v53;
  _BOOL4 v54;
  NSObject *v55;
  char *v56;
  os_log_type_t v57;
  _BOOL4 v58;
  id v59;
  os_log_type_t v60;
  char *v61;
  os_log_type_t v62;
  _BOOL4 v63;
  void *v64;
  const char *v65;
  NSObject *v66;
  os_log_type_t v67;
  os_log_type_t v68;
  os_log_type_t v69;
  char *v70;
  os_log_type_t v71;
  _BOOL4 v72;
  os_log_type_t v73;
  char *v74;
  char *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  char *v78;
  _BOOL4 v79;
  os_log_type_t v80;
  os_log_type_t v81;
  os_log_type_t v82;
  os_log_type_t v83;
  void *v85;
  char *v86;
  NSObject *v87;
  os_log_type_t v88;
  void *v89;
  char *v90;
  NSObject *v91;
  os_log_type_t v92;
  char *v93;
  os_log_type_t v94;
  _BOOL4 v95;
  char *v96;
  os_log_type_t v97;
  _BOOL4 v98;
  os_log_type_t v99;
  os_log_type_t v100;
  os_log_type_t v101;
  char v102;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v105;
  __int16 v106;
  _BYTE v107[18];
  __int16 v108;
  char *v109;
  uint64_t v110;

  v110 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  if (a1)
  {
    v6 = xpc_dictionary_create(0, 0, 0);
    v7 = v6;
    if (v6)
    {
      xpc_dictionary_set_uint64(v6, (const char *)networkd_privileged_key_type, 0xAuLL);
      xpc_dictionary_set_string(v7, (const char *)networkd_privileged_key_settings_key, a1);
      xpc_dictionary_set_value(v7, (const char *)networkd_privileged_key_settings_value, v5);
      if (a3 && *a3)
        xpc_dictionary_set_string(v7, (const char *)networkd_privileged_key_settings_file_prefix, a3);
      v8 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_set_settings", v7);
      v9 = v8;
      if (v8)
      {
        Class = object_getClass(v8);
        if (Class != (Class)MEMORY[0x1E0C812F8])
        {
          if (Class != (Class)MEMORY[0x1E0C81310])
          {
            v11 = (void *)MEMORY[0x186DB5A08](v9);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v12 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            v105 = "networkd_privileged_set_settings";
            v106 = 2082;
            *(_QWORD *)v107 = v11;
            v13 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v102 = 0;
            if (!__nwlog_fault(v13, &type, &v102))
              goto LABEL_69;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v14 = (id)gLogObj;
              v15 = type;
              if (os_log_type_enabled(v14, type))
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 2082;
                *(_QWORD *)v107 = v11;
                _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
              }
LABEL_68:

LABEL_69:
              if (!v13)
                goto LABEL_71;
              goto LABEL_70;
            }
            if (!v102)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v14 = (id)gLogObj;
              v47 = type;
              if (os_log_type_enabled(v14, type))
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 2082;
                *(_QWORD *)v107 = v11;
                _os_log_impl(&dword_182FBE000, v14, v47, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
              }
              goto LABEL_68;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = (id)gLogObj;
            v32 = type;
            v33 = os_log_type_enabled(v14, type);
            if (!backtrace_string)
            {
              if (v33)
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 2082;
                *(_QWORD *)v107 = v11;
                _os_log_impl(&dword_182FBE000, v14, v32, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
              }
              goto LABEL_68;
            }
            if (v33)
            {
              *(_DWORD *)buf = 136446722;
              v105 = "networkd_privileged_set_settings";
              v106 = 2082;
              *(_QWORD *)v107 = v11;
              *(_WORD *)&v107[8] = 2082;
              *(_QWORD *)&v107[10] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v14, v32, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(backtrace_string);
            if (!v13)
            {
LABEL_71:
              if (v11)
              {
                free(v11);
                v48 = 1;
LABEL_179:
                v52 = v48 == 0;
                goto LABEL_180;
              }
LABEL_178:
              v48 = 1;
              goto LABEL_179;
            }
LABEL_70:
            free(v13);
            goto LABEL_71;
          }
          if (v9 == (void *)MEMORY[0x1E0C81258])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v37 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            v38 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v102 = 0;
            if (!__nwlog_fault(v38, &type, &v102))
              goto LABEL_176;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v39 = (id)gLogObj;
              v40 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
              }
            }
            else if (v102)
            {
              v56 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v39 = objc_claimAutoreleasedReturnValue();
              v57 = type;
              v58 = os_log_type_enabled(v39, type);
              if (v56)
              {
                if (v58)
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(_QWORD *)v107 = v56;
                  _os_log_impl(&dword_182FBE000, v39, v57, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v56);
                if (!v38)
                  goto LABEL_178;
                goto LABEL_177;
              }
              if (v58)
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl(&dword_182FBE000, v39, v57, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              __nwlog_obj();
              v39 = objc_claimAutoreleasedReturnValue();
              v73 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl(&dword_182FBE000, v39, v73, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
          else
          {
            if (v9 == (void *)MEMORY[0x1E0C81260])
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v55 = (id)gLogObj;
              if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
              }

              goto LABEL_178;
            }
            if (v9 != (void *)MEMORY[0x1E0C81288])
            {
              v11 = (void *)MEMORY[0x186DB5A08](v9);
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v29 = (id)gLogObj;
              *(_DWORD *)buf = 136446466;
              v105 = "networkd_privileged_set_settings";
              v106 = 2082;
              *(_QWORD *)v107 = v11;
              v13 = (char *)_os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v102 = 0;
              if (!__nwlog_fault(v13, &type, &v102))
                goto LABEL_69;
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v14 = objc_claimAutoreleasedReturnValue();
                v30 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(_QWORD *)v107 = v11;
                  _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
                }
                goto LABEL_68;
              }
              if (!v102)
              {
                __nwlog_obj();
                v14 = objc_claimAutoreleasedReturnValue();
                v80 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(_QWORD *)v107 = v11;
                  _os_log_impl(&dword_182FBE000, v14, v80, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
                }
                goto LABEL_68;
              }
              v61 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v14 = objc_claimAutoreleasedReturnValue();
              v62 = type;
              v63 = os_log_type_enabled(v14, type);
              if (!v61)
              {
                if (v63)
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(_QWORD *)v107 = v11;
                  _os_log_impl(&dword_182FBE000, v14, v62, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
                }
                goto LABEL_68;
              }
              if (v63)
              {
                *(_DWORD *)buf = 136446722;
                v105 = "networkd_privileged_set_settings";
                v106 = 2082;
                *(_QWORD *)v107 = v11;
                *(_WORD *)&v107[8] = 2082;
                *(_QWORD *)&v107[10] = v61;
                _os_log_impl(&dword_182FBE000, v14, v62, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v61);
              if (!v13)
                goto LABEL_71;
              goto LABEL_70;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v59 = (id)gLogObj;
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            v38 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v102 = 0;
            if (!__nwlog_fault(v38, &type, &v102))
              goto LABEL_176;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v39 = objc_claimAutoreleasedReturnValue();
              v60 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl(&dword_182FBE000, v39, v60, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
              }
            }
            else if (v102)
            {
              v70 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v39 = objc_claimAutoreleasedReturnValue();
              v71 = type;
              v72 = os_log_type_enabled(v39, type);
              if (v70)
              {
                if (v72)
                {
                  *(_DWORD *)buf = 136446466;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 2082;
                  *(_QWORD *)v107 = v70;
                  _os_log_impl(&dword_182FBE000, v39, v71, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v70);
LABEL_176:
                if (!v38)
                  goto LABEL_178;
LABEL_177:
                free(v38);
                goto LABEL_178;
              }
              if (v72)
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl(&dword_182FBE000, v39, v71, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              __nwlog_obj();
              v39 = objc_claimAutoreleasedReturnValue();
              v81 = type;
              if (os_log_type_enabled(v39, type))
              {
                *(_DWORD *)buf = 136446210;
                v105 = "networkd_privileged_set_settings";
                _os_log_impl(&dword_182FBE000, v39, v81, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }

          goto LABEL_176;
        }
        xpc_dictionary_get_value(v9, (const char *)networkd_privileged_key_result);
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = v20;
        if (!v20)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v34 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v105 = "networkd_privileged_set_settings";
          v23 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v102 = 0;
          if (!__nwlog_fault(v23, &type, &v102))
            goto LABEL_139;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v35 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s received response without result code", buf, 0xCu);
            }
            goto LABEL_138;
          }
          if (!v102)
          {
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            v69 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_182FBE000, v24, v69, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_138;
          }
          v49 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v53 = type;
          v54 = os_log_type_enabled(v24, type);
          if (!v49)
          {
            if (v54)
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_182FBE000, v24, v53, "%{public}s received response without result code, no backtrace", buf, 0xCu);
            }
            goto LABEL_138;
          }
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            v105 = "networkd_privileged_set_settings";
            v106 = 2082;
            *(_QWORD *)v107 = v49;
            _os_log_impl(&dword_182FBE000, v24, v53, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
          }
          goto LABEL_88;
        }
        if (object_getClass(v20) != (Class)MEMORY[0x1E0C81328])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v105 = "networkd_privileged_set_settings";
          v23 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v102 = 0;
          if (!__nwlog_fault(v23, &type, &v102))
            goto LABEL_139;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s received invalid result type", buf, 0xCu);
            }
LABEL_138:

LABEL_139:
            if (!v23)
            {
LABEL_142:
              v48 = 1;
              goto LABEL_143;
            }
            goto LABEL_140;
          }
          if (!v102)
          {
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            v68 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_182FBE000, v24, v68, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_138;
          }
          v49 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v50 = type;
          v51 = os_log_type_enabled(v24, type);
          if (!v49)
          {
            if (v51)
            {
              *(_DWORD *)buf = 136446210;
              v105 = "networkd_privileged_set_settings";
              _os_log_impl(&dword_182FBE000, v24, v50, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
            }
            goto LABEL_138;
          }
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            v105 = "networkd_privileged_set_settings";
            v106 = 2082;
            *(_QWORD *)v107 = v49;
            _os_log_impl(&dword_182FBE000, v24, v50, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
          }
LABEL_88:

          free(v49);
          if (!v23)
            goto LABEL_142;
LABEL_140:
          v74 = (char *)v23;
LABEL_141:
          free(v74);
          goto LABEL_142;
        }
        value = xpc_int64_get_value(v21);
        v42 = value;
        if (!value)
        {
          v48 = 0;
LABEL_143:

          goto LABEL_179;
        }
        if (!(value >> 31))
        {
          __nwlog_obj();
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446466;
          v105 = "networkd_privileged_set_settings";
          v106 = 1024;
          *(_DWORD *)v107 = v42;
          v44 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v102 = 0;
          if (__nwlog_fault(v44, &type, &v102))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v45 = objc_claimAutoreleasedReturnValue();
              v46 = type;
              if (os_log_type_enabled(v45, type))
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 1024;
                *(_DWORD *)v107 = v42;
                _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
              }
            }
            else if (v102)
            {
              v75 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v45 = objc_claimAutoreleasedReturnValue();
              v76 = type;
              v77 = os_log_type_enabled(v45, type);
              if (v75)
              {
                if (v77)
                {
                  *(_DWORD *)buf = 136446722;
                  v105 = "networkd_privileged_set_settings";
                  v106 = 1024;
                  *(_DWORD *)v107 = v42;
                  *(_WORD *)&v107[4] = 2082;
                  *(_QWORD *)&v107[6] = v75;
                  _os_log_impl(&dword_182FBE000, v45, v76, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }

                free(v75);
                if (!v44)
                  goto LABEL_142;
LABEL_190:
                v74 = (char *)v44;
                goto LABEL_141;
              }
              if (v77)
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 1024;
                *(_DWORD *)v107 = v42;
                _os_log_impl(&dword_182FBE000, v45, v76, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
              }
            }
            else
            {
              __nwlog_obj();
              v45 = objc_claimAutoreleasedReturnValue();
              v82 = type;
              if (os_log_type_enabled(v45, type))
              {
                *(_DWORD *)buf = 136446466;
                v105 = "networkd_privileged_set_settings";
                v106 = 1024;
                *(_DWORD *)v107 = v42;
                _os_log_impl(&dword_182FBE000, v45, v82, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
              }
            }

          }
LABEL_189:
          if (!v44)
            goto LABEL_142;
          goto LABEL_190;
        }
        __nwlog_obj();
        v64 = (void *)objc_claimAutoreleasedReturnValue();
        v65 = networkd_privileged_result_to_string(v42);
        *(_DWORD *)buf = 136446722;
        v105 = "networkd_privileged_set_settings";
        v106 = 2048;
        *(_QWORD *)v107 = v42;
        *(_WORD *)&v107[8] = 2082;
        *(_QWORD *)&v107[10] = v65;
        v44 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v102 = 0;
        if (!__nwlog_fault(v44, &type, &v102))
          goto LABEL_189;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v66 = objc_claimAutoreleasedReturnValue();
          v67 = type;
          if (os_log_type_enabled(v66, type))
          {
            *(_DWORD *)buf = 136446722;
            v105 = "networkd_privileged_set_settings";
            v106 = 2048;
            *(_QWORD *)v107 = v42;
            *(_WORD *)&v107[8] = 2082;
            *(_QWORD *)&v107[10] = v65;
            _os_log_impl(&dword_182FBE000, v66, v67, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
          }
        }
        else if (v102)
        {
          v78 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v66 = objc_claimAutoreleasedReturnValue();
          v101 = type;
          v79 = os_log_type_enabled(v66, type);
          if (v78)
          {
            if (v79)
            {
              *(_DWORD *)buf = 136446978;
              v105 = "networkd_privileged_set_settings";
              v106 = 2048;
              *(_QWORD *)v107 = v42;
              *(_WORD *)&v107[8] = 2082;
              *(_QWORD *)&v107[10] = v65;
              v108 = 2082;
              v109 = v78;
              _os_log_impl(&dword_182FBE000, v66, v101, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v78);
            goto LABEL_189;
          }
          if (v79)
          {
            *(_DWORD *)buf = 136446722;
            v105 = "networkd_privileged_set_settings";
            v106 = 2048;
            *(_QWORD *)v107 = v42;
            *(_WORD *)&v107[8] = 2082;
            *(_QWORD *)&v107[10] = v65;
            _os_log_impl(&dword_182FBE000, v66, v101, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          __nwlog_obj();
          v66 = objc_claimAutoreleasedReturnValue();
          v83 = type;
          if (os_log_type_enabled(v66, type))
          {
            *(_DWORD *)buf = 136446722;
            v105 = "networkd_privileged_set_settings";
            v106 = 2048;
            *(_QWORD *)v107 = v42;
            *(_WORD *)&v107[8] = 2082;
            *(_QWORD *)&v107[10] = v65;
            _os_log_impl(&dword_182FBE000, v66, v83, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
          }
        }

        goto LABEL_189;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v105 = "networkd_privileged_set_settings";
      v17 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v102 = 0;
      if (__nwlog_fault(v17, &type, &v102))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = (id)gLogObj;
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s received NULL response", buf, 0xCu);
          }
        }
        else if (v102)
        {
          v26 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = (id)gLogObj;
          v27 = type;
          v28 = os_log_type_enabled(v18, type);
          if (v26)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              v105 = "networkd_privileged_set_settings";
              v106 = 2082;
              *(_QWORD *)v107 = v26;
              _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v26);
            if (!v17)
              goto LABEL_83;
            goto LABEL_82;
          }
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s received NULL response, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = (id)gLogObj;
          v36 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v105 = "networkd_privileged_set_settings";
            _os_log_impl(&dword_182FBE000, v18, v36, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v17)
      {
LABEL_83:
        v52 = 0;
LABEL_180:

LABEL_181:
        goto LABEL_182;
      }
LABEL_82:
      free(v17);
      goto LABEL_83;
    }
    __nwlog_obj();
    v89 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v105 = "networkd_privileged_set_settings";
    v90 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v102 = 0;
    if (__nwlog_fault(v90, &type, &v102))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v91 = objc_claimAutoreleasedReturnValue();
        v92 = type;
        if (os_log_type_enabled(v91, type))
        {
          *(_DWORD *)buf = 136446210;
          v105 = "networkd_privileged_set_settings";
          _os_log_impl(&dword_182FBE000, v91, v92, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v102)
      {
        v96 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v91 = objc_claimAutoreleasedReturnValue();
        v97 = type;
        v98 = os_log_type_enabled(v91, type);
        if (v96)
        {
          if (v98)
          {
            *(_DWORD *)buf = 136446466;
            v105 = "networkd_privileged_set_settings";
            v106 = 2082;
            *(_QWORD *)v107 = v96;
            _os_log_impl(&dword_182FBE000, v91, v97, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v96);
          goto LABEL_226;
        }
        if (v98)
        {
          *(_DWORD *)buf = 136446210;
          v105 = "networkd_privileged_set_settings";
          _os_log_impl(&dword_182FBE000, v91, v97, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v91 = objc_claimAutoreleasedReturnValue();
        v100 = type;
        if (os_log_type_enabled(v91, type))
        {
          *(_DWORD *)buf = 136446210;
          v105 = "networkd_privileged_set_settings";
          _os_log_impl(&dword_182FBE000, v91, v100, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_226:
    if (v90)
      free(v90);
    v52 = 0;
    goto LABEL_181;
  }
  __nwlog_obj();
  v85 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v105 = "networkd_privileged_set_settings";
  v86 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v102 = 0;
  if (__nwlog_fault(v86, &type, &v102))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v87 = objc_claimAutoreleasedReturnValue();
      v88 = type;
      if (os_log_type_enabled(v87, type))
      {
        *(_DWORD *)buf = 136446210;
        v105 = "networkd_privileged_set_settings";
        _os_log_impl(&dword_182FBE000, v87, v88, "%{public}s called with null key", buf, 0xCu);
      }
    }
    else if (v102)
    {
      v93 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v87 = objc_claimAutoreleasedReturnValue();
      v94 = type;
      v95 = os_log_type_enabled(v87, type);
      if (v93)
      {
        if (v95)
        {
          *(_DWORD *)buf = 136446466;
          v105 = "networkd_privileged_set_settings";
          v106 = 2082;
          *(_QWORD *)v107 = v93;
          _os_log_impl(&dword_182FBE000, v87, v94, "%{public}s called with null key, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v93);
        goto LABEL_220;
      }
      if (v95)
      {
        *(_DWORD *)buf = 136446210;
        v105 = "networkd_privileged_set_settings";
        _os_log_impl(&dword_182FBE000, v87, v94, "%{public}s called with null key, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v87 = objc_claimAutoreleasedReturnValue();
      v99 = type;
      if (os_log_type_enabled(v87, type))
      {
        *(_DWORD *)buf = 136446210;
        v105 = "networkd_privileged_set_settings";
        _os_log_impl(&dword_182FBE000, v87, v99, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_220:
  if (v86)
    free(v86);
  v52 = 0;
LABEL_182:

  return v52;
}

void sub_18334AD88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

BOOL networkd_privileged_reload_managed_network_settings()
{
  xpc_object_t v0;
  void *v1;
  xpc_object_t v2;
  void *v3;
  Class Class;
  void *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  void *v15;
  id v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  id v23;
  os_log_type_t v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  id v28;
  os_log_type_t v29;
  os_log_type_t v30;
  id v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  unint64_t value;
  uint64_t v36;
  void *v37;
  const char *v38;
  NSObject *v39;
  os_log_type_t v40;
  os_log_type_t v41;
  int v42;
  char *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  _BOOL8 v46;
  os_log_type_t v47;
  _BOOL4 v48;
  NSObject *v49;
  char *v50;
  os_log_type_t v51;
  _BOOL4 v52;
  id v53;
  os_log_type_t v54;
  char *v55;
  os_log_type_t v56;
  _BOOL4 v57;
  void *v58;
  const char *v59;
  NSObject *v60;
  os_log_type_t v61;
  os_log_type_t v62;
  os_log_type_t v63;
  char *v64;
  os_log_type_t v65;
  _BOOL4 v66;
  os_log_type_t v67;
  char *v68;
  char *v69;
  os_log_type_t v70;
  _BOOL4 v71;
  char *v72;
  os_log_type_t v73;
  _BOOL4 v74;
  os_log_type_t v75;
  os_log_type_t v76;
  os_log_type_t v77;
  os_log_type_t v78;
  void *v80;
  char *v81;
  NSObject *v82;
  os_log_type_t v83;
  char *v84;
  os_log_type_t v85;
  _BOOL4 v86;
  os_log_type_t v87;
  char v88;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v91;
  __int16 v92;
  _BYTE v93[18];
  __int16 v94;
  char *v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  v0 = xpc_dictionary_create(0, 0, 0);
  v1 = v0;
  if (v0)
  {
    xpc_dictionary_set_uint64(v0, (const char *)networkd_privileged_key_type, 9uLL);
    v2 = networkd_privileged_send_sync_inner((uint64_t)"networkd_privileged_reload_managed_network_settings", v1);
    v3 = v2;
    if (v2)
    {
      Class = object_getClass(v2);
      if (Class != (Class)MEMORY[0x1E0C812F8])
      {
        if (Class != (Class)MEMORY[0x1E0C81310])
        {
          v5 = (void *)MEMORY[0x186DB5A08](v3);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v6 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2082;
          *(_QWORD *)v93 = v5;
          v7 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v88 = 0;
          if (!__nwlog_fault(v7, &type, &v88))
            goto LABEL_65;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v8 = (id)gLogObj;
            v9 = type;
            if (os_log_type_enabled(v8, type))
            {
              *(_DWORD *)buf = 136446466;
              v91 = "networkd_privileged_reload_managed_network_settings";
              v92 = 2082;
              *(_QWORD *)v93 = v5;
              _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
            }
LABEL_64:

LABEL_65:
            if (!v7)
              goto LABEL_67;
            goto LABEL_66;
          }
          if (!v88)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v8 = (id)gLogObj;
            v41 = type;
            if (os_log_type_enabled(v8, type))
            {
              *(_DWORD *)buf = 136446466;
              v91 = "networkd_privileged_reload_managed_network_settings";
              v92 = 2082;
              *(_QWORD *)v93 = v5;
              _os_log_impl(&dword_182FBE000, v8, v41, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_64;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = (id)gLogObj;
          v26 = type;
          v27 = os_log_type_enabled(v8, type);
          if (!backtrace_string)
          {
            if (v27)
            {
              *(_DWORD *)buf = 136446466;
              v91 = "networkd_privileged_reload_managed_network_settings";
              v92 = 2082;
              *(_QWORD *)v93 = v5;
              _os_log_impl(&dword_182FBE000, v8, v26, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
            }
            goto LABEL_64;
          }
          if (v27)
          {
            *(_DWORD *)buf = 136446722;
            v91 = "networkd_privileged_reload_managed_network_settings";
            v92 = 2082;
            *(_QWORD *)v93 = v5;
            *(_WORD *)&v93[8] = 2082;
            *(_QWORD *)&v93[10] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v26, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          if (!v7)
          {
LABEL_67:
            if (v5)
            {
              free(v5);
              v42 = 1;
LABEL_175:
              v46 = v42 == 0;
              goto LABEL_176;
            }
LABEL_174:
            v42 = 1;
            goto LABEL_175;
          }
LABEL_66:
          free(v7);
          goto LABEL_67;
        }
        if (v3 == (void *)MEMORY[0x1E0C81258])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v32 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v88 = 0;
          if (!__nwlog_fault(v32, &type, &v88))
            goto LABEL_172;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v33 = (id)gLogObj;
            v34 = type;
            if (os_log_type_enabled(v33, type))
            {
              *(_DWORD *)buf = 136446210;
              v91 = "networkd_privileged_reload_managed_network_settings";
              _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
            }
          }
          else if (v88)
          {
            v50 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v33 = objc_claimAutoreleasedReturnValue();
            v51 = type;
            v52 = os_log_type_enabled(v33, type);
            if (v50)
            {
              if (v52)
              {
                *(_DWORD *)buf = 136446466;
                v91 = "networkd_privileged_reload_managed_network_settings";
                v92 = 2082;
                *(_QWORD *)v93 = v50;
                _os_log_impl(&dword_182FBE000, v33, v51, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v50);
              if (!v32)
                goto LABEL_174;
              goto LABEL_173;
            }
            if (v52)
            {
              *(_DWORD *)buf = 136446210;
              v91 = "networkd_privileged_reload_managed_network_settings";
              _os_log_impl(&dword_182FBE000, v33, v51, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v33 = objc_claimAutoreleasedReturnValue();
            v67 = type;
            if (os_log_type_enabled(v33, type))
            {
              *(_DWORD *)buf = 136446210;
              v91 = "networkd_privileged_reload_managed_network_settings";
              _os_log_impl(&dword_182FBE000, v33, v67, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        else
        {
          if (v3 == (void *)MEMORY[0x1E0C81260])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v49 = (id)gLogObj;
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v91 = "networkd_privileged_reload_managed_network_settings";
              _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
            }

            goto LABEL_174;
          }
          if (v3 != (void *)MEMORY[0x1E0C81288])
          {
            v5 = (void *)MEMORY[0x186DB5A08](v3);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v23 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            v91 = "networkd_privileged_reload_managed_network_settings";
            v92 = 2082;
            *(_QWORD *)v93 = v5;
            v7 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v88 = 0;
            if (!__nwlog_fault(v7, &type, &v88))
              goto LABEL_65;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v8 = objc_claimAutoreleasedReturnValue();
              v24 = type;
              if (os_log_type_enabled(v8, type))
              {
                *(_DWORD *)buf = 136446466;
                v91 = "networkd_privileged_reload_managed_network_settings";
                v92 = 2082;
                *(_QWORD *)v93 = v5;
                _os_log_impl(&dword_182FBE000, v8, v24, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
              }
              goto LABEL_64;
            }
            if (!v88)
            {
              __nwlog_obj();
              v8 = objc_claimAutoreleasedReturnValue();
              v75 = type;
              if (os_log_type_enabled(v8, type))
              {
                *(_DWORD *)buf = 136446466;
                v91 = "networkd_privileged_reload_managed_network_settings";
                v92 = 2082;
                *(_QWORD *)v93 = v5;
                _os_log_impl(&dword_182FBE000, v8, v75, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
              }
              goto LABEL_64;
            }
            v55 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v8 = objc_claimAutoreleasedReturnValue();
            v56 = type;
            v57 = os_log_type_enabled(v8, type);
            if (!v55)
            {
              if (v57)
              {
                *(_DWORD *)buf = 136446466;
                v91 = "networkd_privileged_reload_managed_network_settings";
                v92 = 2082;
                *(_QWORD *)v93 = v5;
                _os_log_impl(&dword_182FBE000, v8, v56, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
              }
              goto LABEL_64;
            }
            if (v57)
            {
              *(_DWORD *)buf = 136446722;
              v91 = "networkd_privileged_reload_managed_network_settings";
              v92 = 2082;
              *(_QWORD *)v93 = v5;
              *(_WORD *)&v93[8] = 2082;
              *(_QWORD *)&v93[10] = v55;
              _os_log_impl(&dword_182FBE000, v8, v56, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v55);
            if (!v7)
              goto LABEL_67;
            goto LABEL_66;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v53 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v32 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v88 = 0;
          if (!__nwlog_fault(v32, &type, &v88))
            goto LABEL_172;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v33 = objc_claimAutoreleasedReturnValue();
            v54 = type;
            if (os_log_type_enabled(v33, type))
            {
              *(_DWORD *)buf = 136446210;
              v91 = "networkd_privileged_reload_managed_network_settings";
              _os_log_impl(&dword_182FBE000, v33, v54, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
            }
          }
          else if (v88)
          {
            v64 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v33 = objc_claimAutoreleasedReturnValue();
            v65 = type;
            v66 = os_log_type_enabled(v33, type);
            if (v64)
            {
              if (v66)
              {
                *(_DWORD *)buf = 136446466;
                v91 = "networkd_privileged_reload_managed_network_settings";
                v92 = 2082;
                *(_QWORD *)v93 = v64;
                _os_log_impl(&dword_182FBE000, v33, v65, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v64);
LABEL_172:
              if (!v32)
                goto LABEL_174;
LABEL_173:
              free(v32);
              goto LABEL_174;
            }
            if (v66)
            {
              *(_DWORD *)buf = 136446210;
              v91 = "networkd_privileged_reload_managed_network_settings";
              _os_log_impl(&dword_182FBE000, v33, v65, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v33 = objc_claimAutoreleasedReturnValue();
            v76 = type;
            if (os_log_type_enabled(v33, type))
            {
              *(_DWORD *)buf = 136446210;
              v91 = "networkd_privileged_reload_managed_network_settings";
              _os_log_impl(&dword_182FBE000, v33, v76, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }

        goto LABEL_172;
      }
      xpc_dictionary_get_value(v3, (const char *)networkd_privileged_key_result);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      v15 = v14;
      if (!v14)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        v17 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v88 = 0;
        if (!__nwlog_fault(v17, &type, &v88))
          goto LABEL_135;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = (id)gLogObj;
          v29 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v91 = "networkd_privileged_reload_managed_network_settings";
            _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s received response without result code", buf, 0xCu);
          }
          goto LABEL_134;
        }
        if (!v88)
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v63 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v91 = "networkd_privileged_reload_managed_network_settings";
            _os_log_impl(&dword_182FBE000, v18, v63, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_134;
        }
        v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        v48 = os_log_type_enabled(v18, type);
        if (!v43)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446210;
            v91 = "networkd_privileged_reload_managed_network_settings";
            _os_log_impl(&dword_182FBE000, v18, v47, "%{public}s received response without result code, no backtrace", buf, 0xCu);
          }
          goto LABEL_134;
        }
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2082;
          *(_QWORD *)v93 = v43;
          _os_log_impl(&dword_182FBE000, v18, v47, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_84;
      }
      if (object_getClass(v14) != (Class)MEMORY[0x1E0C81328])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        v17 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v88 = 0;
        if (!__nwlog_fault(v17, &type, &v88))
          goto LABEL_135;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = (id)gLogObj;
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v91 = "networkd_privileged_reload_managed_network_settings";
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s received invalid result type", buf, 0xCu);
          }
LABEL_134:

LABEL_135:
          if (!v17)
          {
LABEL_138:
            v42 = 1;
            goto LABEL_139;
          }
          goto LABEL_136;
        }
        if (!v88)
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v62 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v91 = "networkd_privileged_reload_managed_network_settings";
            _os_log_impl(&dword_182FBE000, v18, v62, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_134;
        }
        v43 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        v45 = os_log_type_enabled(v18, type);
        if (!v43)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            v91 = "networkd_privileged_reload_managed_network_settings";
            _os_log_impl(&dword_182FBE000, v18, v44, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
          }
          goto LABEL_134;
        }
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2082;
          *(_QWORD *)v93 = v43;
          _os_log_impl(&dword_182FBE000, v18, v44, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_84:

        free(v43);
        if (!v17)
          goto LABEL_138;
LABEL_136:
        v68 = (char *)v17;
LABEL_137:
        free(v68);
        goto LABEL_138;
      }
      value = xpc_int64_get_value(v15);
      v36 = value;
      if (!value)
      {
        v42 = 0;
LABEL_139:

        goto LABEL_175;
      }
      if (!(value >> 31))
      {
        __nwlog_obj();
        v37 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446466;
        v91 = "networkd_privileged_reload_managed_network_settings";
        v92 = 1024;
        *(_DWORD *)v93 = v36;
        v38 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v88 = 0;
        if (__nwlog_fault(v38, &type, &v88))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v39 = objc_claimAutoreleasedReturnValue();
            v40 = type;
            if (os_log_type_enabled(v39, type))
            {
              *(_DWORD *)buf = 136446466;
              v91 = "networkd_privileged_reload_managed_network_settings";
              v92 = 1024;
              *(_DWORD *)v93 = v36;
              _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
            }
          }
          else if (v88)
          {
            v69 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v39 = objc_claimAutoreleasedReturnValue();
            v70 = type;
            v71 = os_log_type_enabled(v39, type);
            if (v69)
            {
              if (v71)
              {
                *(_DWORD *)buf = 136446722;
                v91 = "networkd_privileged_reload_managed_network_settings";
                v92 = 1024;
                *(_DWORD *)v93 = v36;
                *(_WORD *)&v93[4] = 2082;
                *(_QWORD *)&v93[6] = v69;
                _os_log_impl(&dword_182FBE000, v39, v70, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }

              free(v69);
              if (!v38)
                goto LABEL_138;
LABEL_185:
              v68 = (char *)v38;
              goto LABEL_137;
            }
            if (v71)
            {
              *(_DWORD *)buf = 136446466;
              v91 = "networkd_privileged_reload_managed_network_settings";
              v92 = 1024;
              *(_DWORD *)v93 = v36;
              _os_log_impl(&dword_182FBE000, v39, v70, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
            }
          }
          else
          {
            __nwlog_obj();
            v39 = objc_claimAutoreleasedReturnValue();
            v77 = type;
            if (os_log_type_enabled(v39, type))
            {
              *(_DWORD *)buf = 136446466;
              v91 = "networkd_privileged_reload_managed_network_settings";
              v92 = 1024;
              *(_DWORD *)v93 = v36;
              _os_log_impl(&dword_182FBE000, v39, v77, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
            }
          }

        }
LABEL_184:
        if (!v38)
          goto LABEL_138;
        goto LABEL_185;
      }
      __nwlog_obj();
      v58 = (void *)objc_claimAutoreleasedReturnValue();
      v59 = networkd_privileged_result_to_string(v36);
      *(_DWORD *)buf = 136446722;
      v91 = "networkd_privileged_reload_managed_network_settings";
      v92 = 2048;
      *(_QWORD *)v93 = v36;
      *(_WORD *)&v93[8] = 2082;
      *(_QWORD *)&v93[10] = v59;
      v38 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v88 = 0;
      if (!__nwlog_fault(v38, &type, &v88))
        goto LABEL_184;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446722;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2048;
          *(_QWORD *)v93 = v36;
          *(_WORD *)&v93[8] = 2082;
          *(_QWORD *)&v93[10] = v59;
          _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
        }
      }
      else if (v88)
      {
        v72 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v73 = type;
        v74 = os_log_type_enabled(v60, type);
        if (v72)
        {
          if (v74)
          {
            *(_DWORD *)buf = 136446978;
            v91 = "networkd_privileged_reload_managed_network_settings";
            v92 = 2048;
            *(_QWORD *)v93 = v36;
            *(_WORD *)&v93[8] = 2082;
            *(_QWORD *)&v93[10] = v59;
            v94 = 2082;
            v95 = v72;
            _os_log_impl(&dword_182FBE000, v60, v73, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v72);
          goto LABEL_184;
        }
        if (v74)
        {
          *(_DWORD *)buf = 136446722;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2048;
          *(_QWORD *)v93 = v36;
          *(_WORD *)&v93[8] = 2082;
          *(_QWORD *)&v93[10] = v59;
          _os_log_impl(&dword_182FBE000, v60, v73, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        __nwlog_obj();
        v60 = objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446722;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2048;
          *(_QWORD *)v93 = v36;
          *(_WORD *)&v93[8] = 2082;
          *(_QWORD *)&v93[10] = v59;
          _os_log_impl(&dword_182FBE000, v60, v78, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }

      goto LABEL_184;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v91 = "networkd_privileged_reload_managed_network_settings";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v88 = 0;
    if (__nwlog_fault(v11, &type, &v88))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v91 = "networkd_privileged_reload_managed_network_settings";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received NULL response", buf, 0xCu);
        }
      }
      else if (v88)
      {
        v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v21 = type;
        v22 = os_log_type_enabled(v12, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            v91 = "networkd_privileged_reload_managed_network_settings";
            v92 = 2082;
            *(_QWORD *)v93 = v20;
            _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v20);
          if (!v11)
            goto LABEL_79;
          goto LABEL_78;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v91 = "networkd_privileged_reload_managed_network_settings";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v30 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v91 = "networkd_privileged_reload_managed_network_settings";
          _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v11)
    {
LABEL_79:
      v46 = 0;
LABEL_176:

      goto LABEL_177;
    }
LABEL_78:
    free(v11);
    goto LABEL_79;
  }
  __nwlog_obj();
  v80 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v91 = "networkd_privileged_reload_managed_network_settings";
  v81 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v88 = 0;
  if (__nwlog_fault(v81, &type, &v88))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v82 = objc_claimAutoreleasedReturnValue();
      v83 = type;
      if (os_log_type_enabled(v82, type))
      {
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        _os_log_impl(&dword_182FBE000, v82, v83, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
      }
    }
    else if (v88)
    {
      v84 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v82 = objc_claimAutoreleasedReturnValue();
      v85 = type;
      v86 = os_log_type_enabled(v82, type);
      if (v84)
      {
        if (v86)
        {
          *(_DWORD *)buf = 136446466;
          v91 = "networkd_privileged_reload_managed_network_settings";
          v92 = 2082;
          *(_QWORD *)v93 = v84;
          _os_log_impl(&dword_182FBE000, v82, v85, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v84);
        goto LABEL_202;
      }
      if (v86)
      {
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        _os_log_impl(&dword_182FBE000, v82, v85, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v82 = objc_claimAutoreleasedReturnValue();
      v87 = type;
      if (os_log_type_enabled(v82, type))
      {
        *(_DWORD *)buf = 136446210;
        v91 = "networkd_privileged_reload_managed_network_settings";
        _os_log_impl(&dword_182FBE000, v82, v87, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_202:
  if (v81)
    free(v81);
  v46 = 0;
LABEL_177:

  return v46;
}

void sub_18334C69C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void networkd_privileged_set_constrained(const char *a1, BOOL a2)
{
  xpc_object_t v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  os_log_type_t v31;
  _QWORD v32[4];
  id v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = xpc_dictionary_create(0, 0, 0);
    v5 = v4;
    if (v4)
    {
      xpc_dictionary_set_uint64(v4, (const char *)networkd_privileged_key_type, 0xFuLL);
      xpc_dictionary_set_BOOL(v5, (const char *)networkd_privileged_key_constrained, a2);
      xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_interface_name, a1);
      v6 = networkd_privileged_copy_connection();
      if (v6)
      {
        if (networkd_privileged_copy_queue(void)::onceToken != -1)
          dispatch_once(&networkd_privileged_copy_queue(void)::onceToken, &__block_literal_global_54);
        v7 = (id)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue;
        v32[0] = MEMORY[0x1E0C809B0];
        v32[1] = 3221225472;
        v32[2] = __networkd_privileged_set_constrained_block_invoke;
        v32[3] = &unk_1E149A0D0;
        v33 = v5;
        networkd_privileged_send_async_inner((uint64_t)"networkd_privileged_set_constrained", v33, v7, v32);

LABEL_7:
LABEL_8:

        return;
      }
      __nwlog_obj();
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v37 = "networkd_privileged_set_constrained";
      v17 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (__nwlog_fault(v17, &type, &v34))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_constrained";
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s Unable to connect to networkd privileged", buf, 0xCu);
          }
        }
        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v27 = type;
          v28 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              v37 = "networkd_privileged_set_constrained";
              v38 = 2082;
              v39 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s Unable to connect to networkd privileged, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_62;
          }
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_constrained";
            _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s Unable to connect to networkd privileged, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v31 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_constrained";
            _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s Unable to connect to networkd privileged, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_62:
      if (v17)
        free(v17);
      goto LABEL_7;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "networkd_privileged_set_constrained";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (__nwlog_fault(v13, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_constrained";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v34)
      {
        v23 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        v25 = os_log_type_enabled(v14, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v37 = "networkd_privileged_set_constrained";
            v38 = 2082;
            v39 = v23;
            _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v23);
          goto LABEL_57;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_constrained";
          _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_constrained";
          _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_57:
    if (v13)
      free(v13);
    goto LABEL_8;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "networkd_privileged_set_constrained";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (__nwlog_fault(v9, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_constrained";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null ifname", buf, 0xCu);
      }
    }
    else if (v34)
    {
      v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v10, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "networkd_privileged_set_constrained";
          v38 = 2082;
          v39 = v20;
          _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null ifname, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
        goto LABEL_52;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_constrained";
        _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null ifname, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_constrained";
        _os_log_impl(&dword_182FBE000, v10, v29, "%{public}s called with null ifname, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_52:
  if (v9)
    free(v9);
}

void sub_18334CE64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __networkd_privileged_set_constrained_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  Class Class;
  char *v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  id v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  void *v15;
  id v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  id v23;
  os_log_type_t v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  id v28;
  os_log_type_t v29;
  os_log_type_t v30;
  id v31;
  os_log_type_t v32;
  unint64_t value;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  os_log_type_t v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  NSObject *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  id v46;
  os_log_type_t v47;
  _BOOL4 v48;
  const char *string;
  const char *v50;
  char *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  void *v54;
  const char *v55;
  const char *v56;
  NSObject *v57;
  os_log_type_t v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  char *v71;
  os_log_type_t v72;
  _BOOL4 v73;
  os_log_type_t v74;
  os_log_type_t v75;
  os_log_type_t v76;
  char v77;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE v82[18];
  __int16 v83;
  char *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v80 = "networkd_privileged_set_constrained_block_invoke";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v6, &type, &v77))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received NULL response", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (!v77)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v21 = type;
    v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  Class = object_getClass(v3);
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    xpc_dictionary_get_value(v4, (const char *)networkd_privileged_key_result);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v14;
    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_134;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v60, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_133;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v41 = type;
      v42 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_79;
    }
    if (object_getClass(v14) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_134;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_133:

LABEL_134:
        if (!v17)
        {
LABEL_137:

          goto LABEL_138;
        }
        goto LABEL_135;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v59, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_133;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_79:

      free(v38);
      if (!v17)
        goto LABEL_137;
LABEL_135:
      v64 = (char *)v17;
LABEL_136:
      free(v64);
      goto LABEL_137;
    }
    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      if (xpc_dictionary_get_int64(v4, (const char *)networkd_privileged_key_result))
        goto LABEL_138;
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_constrained);
        string = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_interface_name);
        v50 = "Cleared";
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2082;
        if (v48)
          v50 = "Set";
        *(_QWORD *)v82 = v50;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = string;
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s constrained on %{public}s", buf, 0x20u);
      }
      goto LABEL_83;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
        }

        goto LABEL_137;
      }
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_constrained_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(_QWORD *)&v82[6] = v71;
              _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v71);
            if (!v56)
              goto LABEL_137;
LABEL_183:
            v64 = (char *)v56;
            goto LABEL_136;
          }
          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_182:
      if (!v56)
        goto LABEL_137;
      goto LABEL_183;
    }
    __nwlog_obj();
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    v55 = networkd_privileged_result_to_string(v34);
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_constrained_block_invoke";
    v81 = 2048;
    *(_QWORD *)v82 = v34;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v55;
    v56 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v56, &type, &v77))
      goto LABEL_182;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v77)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v68 = type;
      v69 = os_log_type_enabled(v57, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          v81 = 2048;
          *(_QWORD *)v82 = v34;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v55;
          v83 = 2082;
          v84 = v67;
          _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v67);
        goto LABEL_182;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v75, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_182;
  }
  if (Class == (Class)MEMORY[0x1E0C81310])
  {
    if (v4 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v32, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v63, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    if (v4 != (void *)MEMORY[0x1E0C81260])
    {
      if (v4 != (void *)MEMORY[0x1E0C81288])
      {
        v6 = (char *)MEMORY[0x186DB5A08](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v6;
        v8 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v77 = 0;
        if (!__nwlog_fault(v8, &type, &v77))
          goto LABEL_63;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v24 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (!v77)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v70, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_62;
        }
        v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v52 = type;
        v53 = os_log_type_enabled(v9, type);
        if (!v51)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_constrained_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          v81 = 2082;
          *(_QWORD *)v82 = v6;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v51;
          _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v51);
        if (!v8)
          goto LABEL_73;
LABEL_64:
        free(v8);
        goto LABEL_73;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v46 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v47, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_72:

        goto LABEL_73;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v74, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_25:

      free(backtrace_string);
      if (!v6)
        goto LABEL_138;
      goto LABEL_74;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
    }
LABEL_83:

    goto LABEL_138;
  }
  v6 = (char *)MEMORY[0x186DB5A08](v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v80 = "networkd_privileged_set_constrained_block_invoke";
  v81 = 2082;
  *(_QWORD *)v82 = v6;
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v77 = 0;
  if (!__nwlog_fault(v8, &type, &v77))
    goto LABEL_63;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }
LABEL_62:

LABEL_63:
    if (!v8)
      goto LABEL_73;
    goto LABEL_64;
  }
  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v37, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_62;
  }
  v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_62;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_constrained_block_invoke";
    v81 = 2082;
    *(_QWORD *)v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v25;
    _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v25);
  if (v8)
    goto LABEL_64;
LABEL_73:
  if (v6)
LABEL_74:
    free(v6);
LABEL_138:

}

void sub_18334E644(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void networkd_privileged_set_ultra_constrained(const char *a1, BOOL a2)
{
  xpc_object_t v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  os_log_type_t v31;
  _QWORD v32[4];
  id v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = xpc_dictionary_create(0, 0, 0);
    v5 = v4;
    if (v4)
    {
      xpc_dictionary_set_uint64(v4, (const char *)networkd_privileged_key_type, 0x16uLL);
      xpc_dictionary_set_BOOL(v5, (const char *)networkd_privileged_key_constrained, a2);
      xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_interface_name, a1);
      v6 = networkd_privileged_copy_connection();
      if (v6)
      {
        if (networkd_privileged_copy_queue(void)::onceToken != -1)
          dispatch_once(&networkd_privileged_copy_queue(void)::onceToken, &__block_literal_global_54);
        v7 = (id)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue;
        v32[0] = MEMORY[0x1E0C809B0];
        v32[1] = 3221225472;
        v32[2] = __networkd_privileged_set_ultra_constrained_block_invoke;
        v32[3] = &unk_1E149A0D0;
        v33 = v5;
        networkd_privileged_send_async_inner((uint64_t)"networkd_privileged_set_ultra_constrained", v33, v7, v32);

LABEL_7:
LABEL_8:

        return;
      }
      __nwlog_obj();
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v37 = "networkd_privileged_set_ultra_constrained";
      v17 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (__nwlog_fault(v17, &type, &v34))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_ultra_constrained";
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s Unable to connect to networkd privileged", buf, 0xCu);
          }
        }
        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v27 = type;
          v28 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              v37 = "networkd_privileged_set_ultra_constrained";
              v38 = 2082;
              v39 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s Unable to connect to networkd privileged, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_62;
          }
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_ultra_constrained";
            _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s Unable to connect to networkd privileged, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v31 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_ultra_constrained";
            _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s Unable to connect to networkd privileged, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_62:
      if (v17)
        free(v17);
      goto LABEL_7;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "networkd_privileged_set_ultra_constrained";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (__nwlog_fault(v13, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_ultra_constrained";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v34)
      {
        v23 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        v25 = os_log_type_enabled(v14, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v37 = "networkd_privileged_set_ultra_constrained";
            v38 = 2082;
            v39 = v23;
            _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v23);
          goto LABEL_57;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_ultra_constrained";
          _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_ultra_constrained";
          _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_57:
    if (v13)
      free(v13);
    goto LABEL_8;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "networkd_privileged_set_ultra_constrained";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (__nwlog_fault(v9, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_ultra_constrained";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null ifname", buf, 0xCu);
      }
    }
    else if (v34)
    {
      v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v10, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "networkd_privileged_set_ultra_constrained";
          v38 = 2082;
          v39 = v20;
          _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null ifname, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
        goto LABEL_52;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_ultra_constrained";
        _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null ifname, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_ultra_constrained";
        _os_log_impl(&dword_182FBE000, v10, v29, "%{public}s called with null ifname, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_52:
  if (v9)
    free(v9);
}

void sub_18334EE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __networkd_privileged_set_ultra_constrained_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  Class Class;
  char *v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  id v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  void *v15;
  id v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  id v23;
  os_log_type_t v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  id v28;
  os_log_type_t v29;
  os_log_type_t v30;
  id v31;
  os_log_type_t v32;
  unint64_t value;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  os_log_type_t v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  NSObject *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  id v46;
  os_log_type_t v47;
  _BOOL4 v48;
  const char *string;
  const char *v50;
  char *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  void *v54;
  const char *v55;
  const char *v56;
  NSObject *v57;
  os_log_type_t v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  char *v71;
  os_log_type_t v72;
  _BOOL4 v73;
  os_log_type_t v74;
  os_log_type_t v75;
  os_log_type_t v76;
  char v77;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE v82[18];
  __int16 v83;
  char *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v6, &type, &v77))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received NULL response", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (!v77)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v21 = type;
    v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  Class = object_getClass(v3);
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    xpc_dictionary_get_value(v4, (const char *)networkd_privileged_key_result);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v14;
    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_134;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v60, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_133;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v41 = type;
      v42 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_79;
    }
    if (object_getClass(v14) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_134;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_133:

LABEL_134:
        if (!v17)
        {
LABEL_137:

          goto LABEL_138;
        }
        goto LABEL_135;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v59, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_133;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_79:

      free(v38);
      if (!v17)
        goto LABEL_137;
LABEL_135:
      v64 = (char *)v17;
LABEL_136:
      free(v64);
      goto LABEL_137;
    }
    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      if (xpc_dictionary_get_int64(v4, (const char *)networkd_privileged_key_result))
        goto LABEL_138;
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_constrained);
        string = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_interface_name);
        v50 = "Cleared";
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2082;
        if (v48)
          v50 = "Set";
        *(_QWORD *)v82 = v50;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = string;
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s ultra constrained on %{public}s", buf, 0x20u);
      }
      goto LABEL_83;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
        }

        goto LABEL_137;
      }
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(_QWORD *)&v82[6] = v71;
              _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v71);
            if (!v56)
              goto LABEL_137;
LABEL_183:
            v64 = (char *)v56;
            goto LABEL_136;
          }
          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_182:
      if (!v56)
        goto LABEL_137;
      goto LABEL_183;
    }
    __nwlog_obj();
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    v55 = networkd_privileged_result_to_string(v34);
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
    v81 = 2048;
    *(_QWORD *)v82 = v34;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v55;
    v56 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v56, &type, &v77))
      goto LABEL_182;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v77)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v68 = type;
      v69 = os_log_type_enabled(v57, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          v81 = 2048;
          *(_QWORD *)v82 = v34;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v55;
          v83 = 2082;
          v84 = v67;
          _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v67);
        goto LABEL_182;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v75, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_182;
  }
  if (Class == (Class)MEMORY[0x1E0C81310])
  {
    if (v4 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v32, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v63, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    if (v4 != (void *)MEMORY[0x1E0C81260])
    {
      if (v4 != (void *)MEMORY[0x1E0C81288])
      {
        v6 = (char *)MEMORY[0x186DB5A08](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v6;
        v8 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v77 = 0;
        if (!__nwlog_fault(v8, &type, &v77))
          goto LABEL_63;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v24 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (!v77)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v70, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_62;
        }
        v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v52 = type;
        v53 = os_log_type_enabled(v9, type);
        if (!v51)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          v81 = 2082;
          *(_QWORD *)v82 = v6;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v51;
          _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v51);
        if (!v8)
          goto LABEL_73;
LABEL_64:
        free(v8);
        goto LABEL_73;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v46 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v47, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_72:

        goto LABEL_73;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v74, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_25:

      free(backtrace_string);
      if (!v6)
        goto LABEL_138;
      goto LABEL_74;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
    }
LABEL_83:

    goto LABEL_138;
  }
  v6 = (char *)MEMORY[0x186DB5A08](v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
  v81 = 2082;
  *(_QWORD *)v82 = v6;
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v77 = 0;
  if (!__nwlog_fault(v8, &type, &v77))
    goto LABEL_63;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }
LABEL_62:

LABEL_63:
    if (!v8)
      goto LABEL_73;
    goto LABEL_64;
  }
  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v37, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_62;
  }
  v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_62;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_ultra_constrained_block_invoke";
    v81 = 2082;
    *(_QWORD *)v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v25;
    _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v25);
  if (v8)
    goto LABEL_64;
LABEL_73:
  if (v6)
LABEL_74:
    free(v6);
LABEL_138:

}

void sub_1833505E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void networkd_privileged_set_expensive(const char *a1, BOOL a2)
{
  xpc_object_t v4;
  void *v5;
  id v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  os_log_type_t v31;
  _QWORD v32[4];
  id v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = xpc_dictionary_create(0, 0, 0);
    v5 = v4;
    if (v4)
    {
      xpc_dictionary_set_uint64(v4, (const char *)networkd_privileged_key_type, 0x10uLL);
      xpc_dictionary_set_BOOL(v5, (const char *)networkd_privileged_key_expensive, a2);
      xpc_dictionary_set_string(v5, (const char *)networkd_privileged_key_interface_name, a1);
      v6 = networkd_privileged_copy_connection();
      if (v6)
      {
        if (networkd_privileged_copy_queue(void)::onceToken != -1)
          dispatch_once(&networkd_privileged_copy_queue(void)::onceToken, &__block_literal_global_54);
        v7 = (id)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue;
        v32[0] = MEMORY[0x1E0C809B0];
        v32[1] = 3221225472;
        v32[2] = __networkd_privileged_set_expensive_block_invoke;
        v32[3] = &unk_1E149A0D0;
        v33 = v5;
        networkd_privileged_send_async_inner((uint64_t)"networkd_privileged_set_expensive", v33, v7, v32);

LABEL_7:
LABEL_8:

        return;
      }
      __nwlog_obj();
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v37 = "networkd_privileged_set_expensive";
      v17 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (__nwlog_fault(v17, &type, &v34))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_expensive";
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s Unable to connect to networkd privileged", buf, 0xCu);
          }
        }
        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v27 = type;
          v28 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              v37 = "networkd_privileged_set_expensive";
              v38 = 2082;
              v39 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s Unable to connect to networkd privileged, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_62;
          }
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_expensive";
            _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s Unable to connect to networkd privileged, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v31 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "networkd_privileged_set_expensive";
            _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s Unable to connect to networkd privileged, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_62:
      if (v17)
        free(v17);
      goto LABEL_7;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "networkd_privileged_set_expensive";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (__nwlog_fault(v13, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_expensive";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v34)
      {
        v23 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        v25 = os_log_type_enabled(v14, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v37 = "networkd_privileged_set_expensive";
            v38 = 2082;
            v39 = v23;
            _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v23);
          goto LABEL_57;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_expensive";
          _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "networkd_privileged_set_expensive";
          _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_57:
    if (v13)
      free(v13);
    goto LABEL_8;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "networkd_privileged_set_expensive";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (__nwlog_fault(v9, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_expensive";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null ifname", buf, 0xCu);
      }
    }
    else if (v34)
    {
      v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v10, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "networkd_privileged_set_expensive";
          v38 = 2082;
          v39 = v20;
          _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null ifname, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
        goto LABEL_52;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_expensive";
        _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null ifname, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "networkd_privileged_set_expensive";
        _os_log_impl(&dword_182FBE000, v10, v29, "%{public}s called with null ifname, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_52:
  if (v9)
    free(v9);
}

void sub_183350DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __networkd_privileged_set_expensive_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  Class Class;
  char *v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  id v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  void *v15;
  id v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  id v23;
  os_log_type_t v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  id v28;
  os_log_type_t v29;
  os_log_type_t v30;
  id v31;
  os_log_type_t v32;
  unint64_t value;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  os_log_type_t v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  NSObject *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  id v46;
  os_log_type_t v47;
  _BOOL4 v48;
  const char *string;
  const char *v50;
  char *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  void *v54;
  const char *v55;
  const char *v56;
  NSObject *v57;
  os_log_type_t v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  char *v71;
  os_log_type_t v72;
  _BOOL4 v73;
  os_log_type_t v74;
  os_log_type_t v75;
  os_log_type_t v76;
  char v77;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE v82[18];
  __int16 v83;
  char *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v80 = "networkd_privileged_set_expensive_block_invoke";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v6, &type, &v77))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received NULL response", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (!v77)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v21 = type;
    v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  Class = object_getClass(v3);
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    xpc_dictionary_get_value(v4, (const char *)networkd_privileged_key_result);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v14;
    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_134;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v60, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_133;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v41 = type;
      v42 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_79;
    }
    if (object_getClass(v14) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_134;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_133:

LABEL_134:
        if (!v17)
        {
LABEL_137:

          goto LABEL_138;
        }
        goto LABEL_135;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v59, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_133;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_133;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_79:

      free(v38);
      if (!v17)
        goto LABEL_137;
LABEL_135:
      v64 = (char *)v17;
LABEL_136:
      free(v64);
      goto LABEL_137;
    }
    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      if (xpc_dictionary_get_int64(v4, (const char *)networkd_privileged_key_result))
        goto LABEL_138;
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_expensive);
        string = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_interface_name);
        v50 = "Cleared";
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2082;
        if (v48)
          v50 = "Set";
        *(_QWORD *)v82 = v50;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = string;
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s expensive on %{public}s", buf, 0x20u);
      }
      goto LABEL_83;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
        }

        goto LABEL_137;
      }
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_expensive_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(_QWORD *)&v82[6] = v71;
              _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v71);
            if (!v56)
              goto LABEL_137;
LABEL_183:
            v64 = (char *)v56;
            goto LABEL_136;
          }
          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_182:
      if (!v56)
        goto LABEL_137;
      goto LABEL_183;
    }
    __nwlog_obj();
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    v55 = networkd_privileged_result_to_string(v34);
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_expensive_block_invoke";
    v81 = 2048;
    *(_QWORD *)v82 = v34;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v55;
    v56 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v56, &type, &v77))
      goto LABEL_182;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v77)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v68 = type;
      v69 = os_log_type_enabled(v57, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          v81 = 2048;
          *(_QWORD *)v82 = v34;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v55;
          v83 = 2082;
          v84 = v67;
          _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v67);
        goto LABEL_182;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v75, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_182;
  }
  if (Class == (Class)MEMORY[0x1E0C81310])
  {
    if (v4 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v32, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v63, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    if (v4 != (void *)MEMORY[0x1E0C81260])
    {
      if (v4 != (void *)MEMORY[0x1E0C81288])
      {
        v6 = (char *)MEMORY[0x186DB5A08](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v6;
        v8 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v77 = 0;
        if (!__nwlog_fault(v8, &type, &v77))
          goto LABEL_63;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v24 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (!v77)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v70, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_62;
        }
        v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v52 = type;
        v53 = os_log_type_enabled(v9, type);
        if (!v51)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_expensive_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          v81 = 2082;
          *(_QWORD *)v82 = v6;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v51;
          _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v51);
        if (!v8)
          goto LABEL_73;
LABEL_64:
        free(v8);
        goto LABEL_73;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v46 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v47, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_72:

        goto LABEL_73;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v74, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_expensive_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_expensive_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_25:

      free(backtrace_string);
      if (!v6)
        goto LABEL_138;
      goto LABEL_74;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
    }
LABEL_83:

    goto LABEL_138;
  }
  v6 = (char *)MEMORY[0x186DB5A08](v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v80 = "networkd_privileged_set_expensive_block_invoke";
  v81 = 2082;
  *(_QWORD *)v82 = v6;
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v77 = 0;
  if (!__nwlog_fault(v8, &type, &v77))
    goto LABEL_63;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }
LABEL_62:

LABEL_63:
    if (!v8)
      goto LABEL_73;
    goto LABEL_64;
  }
  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v37, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_62;
  }
  v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_expensive_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_62;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_expensive_block_invoke";
    v81 = 2082;
    *(_QWORD *)v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v25;
    _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v25);
  if (v8)
    goto LABEL_64;
LABEL_73:
  if (v6)
LABEL_74:
    free(v6);
LABEL_138:

}

void sub_183352584(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void networkd_privileged_set_throughput_estimates(const char *a1, unsigned int a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;
  id v8;
  id v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  os_log_type_t v33;
  _QWORD v34[4];
  id v35;
  char v36;
  char v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v6 = xpc_dictionary_create(0, 0, 0);
    v7 = v6;
    if (v6)
    {
      xpc_dictionary_set_uint64(v6, (const char *)networkd_privileged_key_type, 0x13uLL);
      xpc_dictionary_set_uint64(v7, (const char *)networkd_privileged_key_upload, a2);
      xpc_dictionary_set_uint64(v7, (const char *)networkd_privileged_key_download, a3);
      xpc_dictionary_set_string(v7, (const char *)networkd_privileged_key_interface_name, a1);
      v8 = networkd_privileged_copy_connection();
      if (v8)
      {
        if (networkd_privileged_copy_queue(void)::onceToken != -1)
          dispatch_once(&networkd_privileged_copy_queue(void)::onceToken, &__block_literal_global_54);
        v9 = (id)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue;
        v34[0] = MEMORY[0x1E0C809B0];
        v34[1] = 3221225472;
        v34[2] = __networkd_privileged_set_throughput_estimates_block_invoke;
        v34[3] = &unk_1E149A0F8;
        v36 = a2;
        v37 = a3;
        v35 = v7;
        networkd_privileged_send_async_inner((uint64_t)"networkd_privileged_set_throughput_estimates", v35, v9, v34);

LABEL_7:
LABEL_8:

        return;
      }
      __nwlog_obj();
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v41 = "networkd_privileged_set_throughput_estimates";
      v19 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v38 = 0;
      if (__nwlog_fault(v19, &type, &v38))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)buf = 136446210;
            v41 = "networkd_privileged_set_throughput_estimates";
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s Unable to connect to networkd privileged", buf, 0xCu);
          }
        }
        else if (v38)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v20 = objc_claimAutoreleasedReturnValue();
          v29 = type;
          v30 = os_log_type_enabled(v20, type);
          if (backtrace_string)
          {
            if (v30)
            {
              *(_DWORD *)buf = 136446466;
              v41 = "networkd_privileged_set_throughput_estimates";
              v42 = 2082;
              v43 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v20, v29, "%{public}s Unable to connect to networkd privileged, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_62;
          }
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            v41 = "networkd_privileged_set_throughput_estimates";
            _os_log_impl(&dword_182FBE000, v20, v29, "%{public}s Unable to connect to networkd privileged, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v20 = objc_claimAutoreleasedReturnValue();
          v33 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)buf = 136446210;
            v41 = "networkd_privileged_set_throughput_estimates";
            _os_log_impl(&dword_182FBE000, v20, v33, "%{public}s Unable to connect to networkd privileged, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_62:
      if (v19)
        free(v19);
      goto LABEL_7;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "networkd_privileged_set_throughput_estimates";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v15, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "networkd_privileged_set_throughput_estimates";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v38)
      {
        v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        v27 = os_log_type_enabled(v16, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            v41 = "networkd_privileged_set_throughput_estimates";
            v42 = 2082;
            v43 = v25;
            _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v25);
          goto LABEL_57;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v41 = "networkd_privileged_set_throughput_estimates";
          _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "networkd_privileged_set_throughput_estimates";
          _os_log_impl(&dword_182FBE000, v16, v32, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_57:
    if (v15)
      free(v15);
    goto LABEL_8;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v41 = "networkd_privileged_set_throughput_estimates";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v38 = 0;
  if (__nwlog_fault(v11, &type, &v38))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "networkd_privileged_set_throughput_estimates";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null ifname", buf, 0xCu);
      }
    }
    else if (v38)
    {
      v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v12, type);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v41 = "networkd_privileged_set_throughput_estimates";
          v42 = 2082;
          v43 = v22;
          _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null ifname, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        goto LABEL_52;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v41 = "networkd_privileged_set_throughput_estimates";
        _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null ifname, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "networkd_privileged_set_throughput_estimates";
        _os_log_impl(&dword_182FBE000, v12, v31, "%{public}s called with null ifname, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_52:
  if (v11)
    free(v11);
}

void sub_183352D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __networkd_privileged_set_throughput_estimates_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  Class Class;
  char *v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  id v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  void *v15;
  id v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  id v23;
  os_log_type_t v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  id v28;
  os_log_type_t v29;
  os_log_type_t v30;
  id v31;
  os_log_type_t v32;
  unint64_t value;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  os_log_type_t v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  NSObject *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  id v46;
  os_log_type_t v47;
  int v48;
  int v49;
  const char *string;
  char *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  void *v54;
  const char *v55;
  const char *v56;
  NSObject *v57;
  os_log_type_t v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  char *v71;
  os_log_type_t v72;
  _BOOL4 v73;
  os_log_type_t v74;
  os_log_type_t v75;
  os_log_type_t v76;
  char v77;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE v82[20];
  char *v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v6, &type, &v77))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received NULL response", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (!v77)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v21 = type;
    v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  Class = object_getClass(v3);
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    xpc_dictionary_get_value(v4, (const char *)networkd_privileged_key_result);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v14;
    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v60, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v41 = type;
      v42 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_79;
    }
    if (object_getClass(v14) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_131:

LABEL_132:
        if (!v17)
        {
LABEL_135:

          goto LABEL_136;
        }
        goto LABEL_133;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v59, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_79:

      free(v38);
      if (!v17)
        goto LABEL_135;
LABEL_133:
      v64 = (char *)v17;
LABEL_134:
      free(v64);
      goto LABEL_135;
    }
    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      if (xpc_dictionary_get_int64(v4, (const char *)networkd_privileged_key_result))
        goto LABEL_136;
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_INFO))
      {
        v48 = *(unsigned __int8 *)(a1 + 40);
        v49 = *(unsigned __int8 *)(a1 + 41);
        string = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_interface_name);
        *(_DWORD *)buf = 136446978;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 1024;
        *(_DWORD *)v82 = v48;
        *(_WORD *)&v82[4] = 1024;
        *(_DWORD *)&v82[6] = v49;
        *(_WORD *)&v82[10] = 2082;
        *(_QWORD *)&v82[12] = string;
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_INFO, "%{public}s Set estimated throughput buckets up: %u, down: %u on %{public}s", buf, 0x22u);
      }
      goto LABEL_83;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
        }

        goto LABEL_135;
      }
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(_QWORD *)&v82[6] = v71;
              _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v71);
            if (!v56)
              goto LABEL_135;
LABEL_181:
            v64 = (char *)v56;
            goto LABEL_134;
          }
          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_180:
      if (!v56)
        goto LABEL_135;
      goto LABEL_181;
    }
    __nwlog_obj();
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    v55 = networkd_privileged_result_to_string(v34);
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
    v81 = 2048;
    *(_QWORD *)v82 = v34;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v55;
    v56 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v56, &type, &v77))
      goto LABEL_180;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v77)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v68 = type;
      v69 = os_log_type_enabled(v57, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          v81 = 2048;
          *(_QWORD *)v82 = v34;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v55;
          *(_WORD *)&v82[18] = 2082;
          v83 = v67;
          _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v67);
        goto LABEL_180;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v75, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_180;
  }
  if (Class == (Class)MEMORY[0x1E0C81310])
  {
    if (v4 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v32, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v63, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    if (v4 != (void *)MEMORY[0x1E0C81260])
    {
      if (v4 != (void *)MEMORY[0x1E0C81288])
      {
        v6 = (char *)MEMORY[0x186DB5A08](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v6;
        v8 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v77 = 0;
        if (!__nwlog_fault(v8, &type, &v77))
          goto LABEL_63;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v24 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (!v77)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v70, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_62;
        }
        v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v52 = type;
        v53 = os_log_type_enabled(v9, type);
        if (!v51)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          v81 = 2082;
          *(_QWORD *)v82 = v6;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v51;
          _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v51);
        if (!v8)
          goto LABEL_73;
LABEL_64:
        free(v8);
        goto LABEL_73;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v46 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v47, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_72:

        goto LABEL_73;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v74, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_25:

      free(backtrace_string);
      if (!v6)
        goto LABEL_136;
      goto LABEL_74;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
    }
LABEL_83:

    goto LABEL_136;
  }
  v6 = (char *)MEMORY[0x186DB5A08](v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
  v81 = 2082;
  *(_QWORD *)v82 = v6;
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v77 = 0;
  if (!__nwlog_fault(v8, &type, &v77))
    goto LABEL_63;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }
LABEL_62:

LABEL_63:
    if (!v8)
      goto LABEL_73;
    goto LABEL_64;
  }
  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v37, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_62;
  }
  v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_62;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_throughput_estimates_block_invoke";
    v81 = 2082;
    *(_QWORD *)v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v25;
    _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v25);
  if (v8)
    goto LABEL_64;
LABEL_73:
  if (v6)
LABEL_74:
    free(v6);
LABEL_136:

}

void sub_18335452C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void networkd_privileged_set_radio_type(const char *a1, unsigned int a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;
  id v8;
  id v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  os_log_type_t v33;
  _QWORD v34[4];
  id v35;
  char v36;
  char v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v6 = xpc_dictionary_create(0, 0, 0);
    v7 = v6;
    if (v6)
    {
      xpc_dictionary_set_uint64(v6, (const char *)networkd_privileged_key_type, 0x14uLL);
      xpc_dictionary_set_uint64(v7, (const char *)networkd_privileged_key_radio_type, a2);
      xpc_dictionary_set_uint64(v7, (const char *)networkd_privileged_key_radio_channel, a3);
      xpc_dictionary_set_string(v7, (const char *)networkd_privileged_key_interface_name, a1);
      v8 = networkd_privileged_copy_connection();
      if (v8)
      {
        if (networkd_privileged_copy_queue(void)::onceToken != -1)
          dispatch_once(&networkd_privileged_copy_queue(void)::onceToken, &__block_literal_global_54);
        v9 = (id)networkd_privileged_copy_queue(void)::networkdPrivilegedQueue;
        v34[0] = MEMORY[0x1E0C809B0];
        v34[1] = 3221225472;
        v34[2] = __networkd_privileged_set_radio_type_block_invoke;
        v34[3] = &unk_1E149A0F8;
        v36 = a2;
        v37 = a3;
        v35 = v7;
        networkd_privileged_send_async_inner((uint64_t)"networkd_privileged_set_radio_type", v35, v9, v34);

LABEL_7:
LABEL_8:

        return;
      }
      __nwlog_obj();
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v41 = "networkd_privileged_set_radio_type";
      v19 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v38 = 0;
      if (__nwlog_fault(v19, &type, &v38))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v20 = objc_claimAutoreleasedReturnValue();
          v21 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)buf = 136446210;
            v41 = "networkd_privileged_set_radio_type";
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s Unable to connect to networkd privileged", buf, 0xCu);
          }
        }
        else if (v38)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v20 = objc_claimAutoreleasedReturnValue();
          v29 = type;
          v30 = os_log_type_enabled(v20, type);
          if (backtrace_string)
          {
            if (v30)
            {
              *(_DWORD *)buf = 136446466;
              v41 = "networkd_privileged_set_radio_type";
              v42 = 2082;
              v43 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v20, v29, "%{public}s Unable to connect to networkd privileged, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_62;
          }
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            v41 = "networkd_privileged_set_radio_type";
            _os_log_impl(&dword_182FBE000, v20, v29, "%{public}s Unable to connect to networkd privileged, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v20 = objc_claimAutoreleasedReturnValue();
          v33 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)buf = 136446210;
            v41 = "networkd_privileged_set_radio_type";
            _os_log_impl(&dword_182FBE000, v20, v33, "%{public}s Unable to connect to networkd privileged, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_62:
      if (v19)
        free(v19);
      goto LABEL_7;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v41 = "networkd_privileged_set_radio_type";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v15, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "networkd_privileged_set_radio_type";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v38)
      {
        v25 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        v27 = os_log_type_enabled(v16, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            v41 = "networkd_privileged_set_radio_type";
            v42 = 2082;
            v43 = v25;
            _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v25);
          goto LABEL_57;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v41 = "networkd_privileged_set_radio_type";
          _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v41 = "networkd_privileged_set_radio_type";
          _os_log_impl(&dword_182FBE000, v16, v32, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_57:
    if (v15)
      free(v15);
    goto LABEL_8;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v41 = "networkd_privileged_set_radio_type";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v38 = 0;
  if (__nwlog_fault(v11, &type, &v38))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "networkd_privileged_set_radio_type";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null ifname", buf, 0xCu);
      }
    }
    else if (v38)
    {
      v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v12, type);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          v41 = "networkd_privileged_set_radio_type";
          v42 = 2082;
          v43 = v22;
          _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null ifname, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        goto LABEL_52;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v41 = "networkd_privileged_set_radio_type";
        _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null ifname, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v41 = "networkd_privileged_set_radio_type";
        _os_log_impl(&dword_182FBE000, v12, v31, "%{public}s called with null ifname, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_52:
  if (v11)
    free(v11);
}

void sub_183354D0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __networkd_privileged_set_radio_type_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  Class Class;
  char *v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  id v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  void *v15;
  id v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  id v23;
  os_log_type_t v24;
  char *v25;
  os_log_type_t v26;
  _BOOL4 v27;
  id v28;
  os_log_type_t v29;
  os_log_type_t v30;
  id v31;
  os_log_type_t v32;
  unint64_t value;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  os_log_type_t v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  NSObject *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  id v46;
  os_log_type_t v47;
  int v48;
  int v49;
  const char *string;
  char *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  void *v54;
  const char *v55;
  const char *v56;
  NSObject *v57;
  os_log_type_t v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  char *v71;
  os_log_type_t v72;
  _BOOL4 v73;
  os_log_type_t v74;
  os_log_type_t v75;
  os_log_type_t v76;
  char v77;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  _BYTE v82[20];
  _WORD v83[15];

  *(_QWORD *)&v83[11] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v80 = "networkd_privileged_set_radio_type_block_invoke";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v6, &type, &v77))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s received NULL response", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (!v77)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v30 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v30, "%{public}s received NULL response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v21 = type;
    v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, no backtrace", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s received NULL response, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_25;
  }
  Class = object_getClass(v3);
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    xpc_dictionary_get_value(v4, (const char *)networkd_privileged_key_result);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v14;
    if (!v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s received response without result code", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v60 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v60, "%{public}s received response without result code, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v41 = type;
      v42 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s received response without result code, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_79;
    }
    if (object_getClass(v14) != (Class)MEMORY[0x1E0C81328])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v17 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v17, &type, &v77))
        goto LABEL_132;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s received invalid result type", buf, 0xCu);
        }
LABEL_131:

LABEL_132:
        if (!v17)
        {
LABEL_135:

          goto LABEL_136;
        }
        goto LABEL_133;
      }
      if (!v77)
      {
        __nwlog_obj();
        v18 = objc_claimAutoreleasedReturnValue();
        v59 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v59, "%{public}s received invalid result type, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_131;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v18, type);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, no backtrace", buf, 0xCu);
        }
        goto LABEL_131;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v38;
        _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s received invalid result type, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_79:

      free(v38);
      if (!v17)
        goto LABEL_135;
LABEL_133:
      v64 = (char *)v17;
LABEL_134:
      free(v64);
      goto LABEL_135;
    }
    value = xpc_int64_get_value(v15);
    v34 = value;
    if (!value)
    {

      if (xpc_dictionary_get_int64(v4, (const char *)networkd_privileged_key_result))
        goto LABEL_136;
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        v48 = *(unsigned __int8 *)(a1 + 40);
        v49 = *(unsigned __int8 *)(a1 + 41);
        string = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 32), (const char *)networkd_privileged_key_interface_name);
        *(_DWORD *)buf = 136447234;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = nw_interface_radio_type_to_string(v48);
        *(_WORD *)&v82[8] = 1024;
        *(_DWORD *)&v82[10] = v48;
        *(_WORD *)&v82[14] = 1024;
        *(_DWORD *)&v82[16] = v49;
        v83[0] = 2082;
        *(_QWORD *)&v83[1] = string;
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEFAULT, "%{public}s Set radio type to: %{public}s (%u), channel: %u on %{public}s", buf, 0x2Cu);
      }
      goto LABEL_83;
    }
    if (!(value >> 31))
    {
      __nwlog_obj();
      v35 = objc_claimAutoreleasedReturnValue();
      v36 = v35;
      if ((_DWORD)v34 == 6)
      {
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          v81 = 1024;
          *(_DWORD *)v82 = 6;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
        }

        goto LABEL_135;
      }
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v81 = 1024;
      *(_DWORD *)v82 = v34;
      v56 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (__nwlog_fault(v56, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s received failure result code %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v77)
        {
          v71 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v72 = type;
          v73 = os_log_type_enabled(v65, type);
          if (v71)
          {
            if (v73)
            {
              *(_DWORD *)buf = 136446722;
              v80 = "networkd_privileged_set_radio_type_block_invoke";
              v81 = 1024;
              *(_DWORD *)v82 = v34;
              *(_WORD *)&v82[4] = 2082;
              *(_QWORD *)&v82[6] = v71;
              _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v71);
            if (!v56)
              goto LABEL_135;
LABEL_181:
            v64 = (char *)v56;
            goto LABEL_134;
          }
          if (v73)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v72, "%{public}s received failure result code %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v76 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 1024;
            *(_DWORD *)v82 = v34;
            _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s received failure result code %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_180:
      if (!v56)
        goto LABEL_135;
      goto LABEL_181;
    }
    __nwlog_obj();
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    v55 = networkd_privileged_result_to_string(v34);
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_radio_type_block_invoke";
    v81 = 2048;
    *(_QWORD *)v82 = v34;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v55;
    v56 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v77 = 0;
    if (!__nwlog_fault(v56, &type, &v77))
      goto LABEL_180;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s received internal failure result code: [%lld] %{public}s", buf, 0x20u);
      }
    }
    else if (v77)
    {
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v68 = type;
      v69 = os_log_type_enabled(v57, type);
      if (v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446978;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          v81 = 2048;
          *(_QWORD *)v82 = v34;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v55;
          *(_WORD *)&v82[18] = 2082;
          *(_QWORD *)v83 = v67;
          _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v67);
        goto LABEL_180;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v68, "%{public}s received internal failure result code: [%lld] %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v57 = objc_claimAutoreleasedReturnValue();
      v75 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)buf = 136446722;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2048;
        *(_QWORD *)v82 = v34;
        *(_WORD *)&v82[8] = 2082;
        *(_QWORD *)&v82[10] = v55;
        _os_log_impl(&dword_182FBE000, v57, v75, "%{public}s received internal failure result code: [%lld] %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }

    goto LABEL_180;
  }
  if (Class == (Class)MEMORY[0x1E0C81310])
  {
    if (v4 == (void *)MEMORY[0x1E0C81258])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v31 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v32, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v63, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      v45 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v44, "%{public}s received XPC_ERROR_CONNECTION_INTERRUPTED, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_25;
    }
    if (v4 != (void *)MEMORY[0x1E0C81260])
    {
      if (v4 != (void *)MEMORY[0x1E0C81288])
      {
        v6 = (char *)MEMORY[0x186DB5A08](v4);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = v6;
        v8 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v77 = 0;
        if (!__nwlog_fault(v8, &type, &v77))
          goto LABEL_63;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v24 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s received returned unknown XPC error %{public}s", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (!v77)
        {
          __nwlog_obj();
          v9 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v70, "%{public}s received returned unknown XPC error %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_62;
        }
        v51 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v52 = type;
        v53 = os_log_type_enabled(v9, type);
        if (!v51)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "networkd_privileged_set_radio_type_block_invoke";
            v81 = 2082;
            *(_QWORD *)v82 = v6;
            _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_62;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          v81 = 2082;
          *(_QWORD *)v82 = v6;
          *(_WORD *)&v82[8] = 2082;
          *(_QWORD *)&v82[10] = v51;
          _os_log_impl(&dword_182FBE000, v9, v52, "%{public}s received returned unknown XPC error %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v51);
        if (!v8)
          goto LABEL_73;
LABEL_64:
        free(v8);
        goto LABEL_73;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v46 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v77 = 0;
      if (!__nwlog_fault(v6, &type, &v77))
        goto LABEL_73;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v47, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT", buf, 0xCu);
        }
LABEL_72:

        goto LABEL_73;
      }
      if (!v77)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v74, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v61 = type;
      v62 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "networkd_privileged_set_radio_type_block_invoke";
          _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, no backtrace", buf, 0xCu);
        }
        goto LABEL_72;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        v80 = "networkd_privileged_set_radio_type_block_invoke";
        v81 = 2082;
        *(_QWORD *)v82 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v61, "%{public}s received XPC_ERROR_TERMINATION_IMMINENT, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_25:

      free(backtrace_string);
      if (!v6)
        goto LABEL_136;
      goto LABEL_74;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (id)gLogObj;
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s received XPC_ERROR_CONNECTION_INVALID", buf, 0xCu);
    }
LABEL_83:

    goto LABEL_136;
  }
  v6 = (char *)MEMORY[0x186DB5A08](v4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v80 = "networkd_privileged_set_radio_type_block_invoke";
  v81 = 2082;
  *(_QWORD *)v82 = v6;
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v77 = 0;
  if (!__nwlog_fault(v8, &type, &v77))
    goto LABEL_63;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s received unknown type XPC %{public}s", buf, 0x16u);
    }
LABEL_62:

LABEL_63:
    if (!v8)
      goto LABEL_73;
    goto LABEL_64;
  }
  if (!v77)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    v37 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v37, "%{public}s received unknown type XPC %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_62;
  }
  v25 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v9, type);
  if (!v25)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      v80 = "networkd_privileged_set_radio_type_block_invoke";
      v81 = 2082;
      *(_QWORD *)v82 = v6;
      _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_62;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136446722;
    v80 = "networkd_privileged_set_radio_type_block_invoke";
    v81 = 2082;
    *(_QWORD *)v82 = v6;
    *(_WORD *)&v82[8] = 2082;
    *(_QWORD *)&v82[10] = v25;
    _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s received unknown type XPC %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v25);
  if (v8)
    goto LABEL_64;
LABEL_73:
  if (v6)
LABEL_74:
    free(v6);
LABEL_136:

}

void sub_1833564E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_http_redirect_create(uint64_t a1, uint64_t a2, NSObject *a3, void *a4)
{
  NSObject **v6;
  char v7;
  NSObject *v8;
  NSObject *v9;
  char v10;
  NSObject *v11;
  NSObject *v12;
  char v13;
  NSObject *v14;
  id v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  NSObject *v19;
  BOOL is_equal;
  NSObject *v21;
  char v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  BOOL v27;
  NSObject *v28;
  char v29;
  NSObject *v30;
  int limit;
  id v32;
  _BOOL8 result;
  NSObject *v34;
  void *v35;
  NSObject *v36;
  void *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  void *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  void *v45;
  os_log_type_t v46;
  void *v47;
  os_log_type_t v48;
  char *backtrace_string;
  _BOOL4 v50;
  char *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  _BOOL4 v54;
  os_log_type_t v55;
  _BOOL4 v56;
  os_log_type_t v57;
  os_log_type_t v58;
  os_log_type_t v59;
  os_log_type_t v60;
  os_log_type_t v61;
  os_log_type_t v62;
  const char *v63;
  os_log_type_t type[8];
  uint64_t v65;
  void *v66;
  void *v67;
  _BYTE *v68;
  char v69;
  _BYTE buf[24];
  uint64_t v71;
  void (*v72)(uint64_t);
  id v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v6 = (NSObject **)malloc_type_calloc(1uLL, 0x2B8uLL, 0xEAFB8F1AuLL);
  if (!v6)
  {
    v34 = __nwlog_obj();
    os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = 1;
    *(_WORD *)&buf[22] = 2048;
    v71 = 696;
    v35 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v35);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v35);
  }
  bzero(v6, 0x2B8uLL);
  if (gLogDatapath)
  {
    v36 = __nwlog_obj();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_redirect_create";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)v6 + 114;
      *(_WORD *)&buf[22] = 2080;
      v71 = (uint64_t)" ";
      _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
    }
  }
  if (nw_protocol_http_redirect_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_http_redirect_identifier::onceToken, &__block_literal_global_916);
  v6[2] = nw_protocol_http_redirect_identifier::protocol_identifier;
  if (nw_protocol_http_redirect_get_callbacks(void)::onceToken[0] != -1)
    dispatch_once(nw_protocol_http_redirect_get_callbacks(void)::onceToken, &__block_literal_global_50);
  v6[3] = &nw_protocol_http_redirect_get_callbacks(void)::protocol_callbacks;
  v6[5] = v6;
  if (a3)
    a3 = os_retain(a3);
  v7 = *((_BYTE *)v6 + 648);
  if ((v7 & 1) != 0)
  {
    v8 = v6[80];
    if (v8)
    {
      os_release(v8);
      v7 = *((_BYTE *)v6 + 648);
    }
  }
  v6[80] = a3;
  *((_BYTE *)v6 + 648) = v7 | 1;
  if (a4)
  {
    v9 = os_retain(a4);
    v10 = *((_BYTE *)v6 + 664);
    if ((v10 & 1) == 0)
      goto LABEL_18;
  }
  else
  {
    v9 = 0;
    v10 = *((_BYTE *)v6 + 664);
    if ((v10 & 1) == 0)
      goto LABEL_18;
  }
  v11 = v6[82];
  if (v11)
  {
    os_release(v11);
    v10 = *((_BYTE *)v6 + 664);
  }
LABEL_18:
  v6[82] = v9;
  *((_BYTE *)v6 + 664) = v10 | 1;
  v12 = nw_parameters_copy_context(a4);
  v13 = *((_BYTE *)v6 + 680);
  if ((v13 & 1) != 0)
  {
    v14 = v6[84];
    if (v14)
    {
      os_release(v14);
      v13 = *((_BYTE *)v6 + 680);
    }
  }
  v6[84] = v12;
  *((_BYTE *)v6 + 680) = v13 | 1;
  *((_BYTE *)v6 + 692) = *((_BYTE *)v6 + 692) & 0xFE | nw_parameters_get_server_mode(a4) | 0x10;
  if (nw_protocol_copy_http_redirect_definition_onceToken != -1)
    dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_31_72984);
  v15 = (id)nw_protocol_copy_http_redirect_definition_http_redirect_definition;
  v16 = nw_parameters_copy_protocol_options_for_definition(a4, v15);
  v17 = v16;
  v18 = MEMORY[0x1E0C809B0];
  if (v16)
  {
    v19 = nw_protocol_options_copy_definition((nw_protocol_options_t)v16);
    if (nw_protocol_copy_http_redirect_definition_onceToken != -1)
      dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_31_72984);
    is_equal = nw_protocol_definition_is_equal(v19, (nw_protocol_definition_t)nw_protocol_copy_http_redirect_definition_http_redirect_definition);

    if (is_equal)
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v71 = (uint64_t)__Block_byref_object_copy__72473;
      v72 = __Block_byref_object_dispose__72474;
      v73 = 0;
      *(_QWORD *)type = v18;
      v65 = 3221225472;
      v66 = __nw_http_redirect_options_copy_handler_block_invoke;
      v67 = &unk_1E14A9D68;
      v68 = buf;
      nw_protocol_options_access_handle(v17, type);
      v21 = _Block_copy(*(const void **)(*(_QWORD *)&buf[8] + 40));
      _Block_object_dispose(buf, 8);

      goto LABEL_28;
    }
    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
    v63 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69 = 0;
    v38 = (char *)v63;
    if (__nwlog_fault(v63, type, &v69))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v46 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl(&dword_182FBE000, v39, v46, "%{public}s protocol options are not http redirect", buf, 0xCu);
        }
LABEL_112:

        goto LABEL_113;
      }
      if (!v69)
      {
        __nwlog_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v59 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl(&dword_182FBE000, v39, v59, "%{public}s protocol options are not http redirect, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      v54 = os_log_type_enabled(v39, type[0]);
      if (!backtrace_string)
      {
        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl(&dword_182FBE000, v39, v62, "%{public}s protocol options are not http redirect, no backtrace", buf, 0xCu);
        }
        goto LABEL_112;
      }
      if (v54)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v39, v62, "%{public}s protocol options are not http redirect, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_86:

      free(backtrace_string);
LABEL_113:
      v38 = (char *)v63;
    }
  }
  else
  {
    __nwlog_obj();
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
    v63 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69 = 0;
    v38 = (char *)v63;
    if (__nwlog_fault(v63, type, &v69))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v40 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s called with null options", buf, 0xCu);
        }
        goto LABEL_112;
      }
      if (!v69)
      {
        __nwlog_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v57 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl(&dword_182FBE000, v39, v57, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      v61 = type[0];
      v50 = os_log_type_enabled(v39, type[0]);
      if (!backtrace_string)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
          _os_log_impl(&dword_182FBE000, v39, v61, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
        goto LABEL_112;
      }
      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v39, v61, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_86;
    }
  }
  if (v38)
    free(v38);
  v21 = 0;
LABEL_28:

  v22 = *((_BYTE *)v6 + 600);
  if ((v22 & 1) != 0)
  {
    v23 = v6[74];
    if (v23)
    {
      _Block_release(v23);
      v22 = *((_BYTE *)v6 + 600);
    }
  }
  v6[74] = v21;
  *((_BYTE *)v6 + 600) = v22 | 1;
  v24 = v17;
  v25 = v24;
  if (!v17)
  {
    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
    v42 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v42, type, &v69))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v44 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
          _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s called with null options", buf, 0xCu);
        }
        goto LABEL_119;
      }
      if (!v69)
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v58 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
          _os_log_impl(&dword_182FBE000, v43, v58, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_119;
      }
      v51 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v52 = type[0];
      v53 = os_log_type_enabled(v43, type[0]);
      if (!v51)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
          _os_log_impl(&dword_182FBE000, v43, v52, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
        goto LABEL_119;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v51;
        _os_log_impl(&dword_182FBE000, v43, v52, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_91:

      free(v51);
    }
LABEL_120:
    if (v42)
      free(v42);
    v28 = 0;
    goto LABEL_36;
  }
  v26 = nw_protocol_options_copy_definition(v24);
  if (nw_protocol_copy_http_redirect_definition_onceToken != -1)
    dispatch_once(&nw_protocol_copy_http_redirect_definition_onceToken, &__block_literal_global_31_72984);
  v27 = nw_protocol_definition_is_equal(v26, (nw_protocol_definition_t)nw_protocol_copy_http_redirect_definition_http_redirect_definition);

  if (!v27)
  {
    __nwlog_obj();
    v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
    v42 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69 = 0;
    if (__nwlog_fault(v42, type, &v69))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v48 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
          _os_log_impl(&dword_182FBE000, v43, v48, "%{public}s protocol options are not http redirect", buf, 0xCu);
        }
LABEL_119:

        goto LABEL_120;
      }
      if (!v69)
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v60 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
          _os_log_impl(&dword_182FBE000, v43, v60, "%{public}s protocol options are not http redirect, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_119;
      }
      v51 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v55 = type[0];
      v56 = os_log_type_enabled(v43, type[0]);
      if (!v51)
      {
        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
          _os_log_impl(&dword_182FBE000, v43, v55, "%{public}s protocol options are not http redirect, no backtrace", buf, 0xCu);
        }
        goto LABEL_119;
      }
      if (v56)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http_redirect_options_copy_handler_queue";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v51;
        _os_log_impl(&dword_182FBE000, v43, v55, "%{public}s protocol options are not http redirect, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_91;
    }
    goto LABEL_120;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3032000000;
  v71 = (uint64_t)__Block_byref_object_copy__4;
  v72 = __Block_byref_object_dispose__5;
  v73 = 0;
  *(_QWORD *)type = v18;
  v65 = 3221225472;
  v66 = __nw_http_redirect_options_copy_handler_queue_block_invoke;
  v67 = &unk_1E14A9D68;
  v68 = buf;
  nw_protocol_options_access_handle(v25, type);
  v28 = *(id *)(*(_QWORD *)&buf[8] + 40);
  _Block_object_dispose(buf, 8);

LABEL_36:
  v29 = *((_BYTE *)v6 + 616);
  if ((v29 & 1) != 0)
  {
    v30 = v6[76];
    if (v30)
    {
      dispatch_release(v30);
      v29 = *((_BYTE *)v6 + 616);
    }
  }
  v6[76] = v28;
  *((_BYTE *)v6 + 616) = v29 | 1;
  limit = nw_http_redirect_options_get_limit(v25);
  v6[25] = 0;
  *((_DWORD *)v6 + 172) = limit;
  v6[9] = (v6 + 25);
  v6[26] = (v6 + 25);
  v6[27] = 0;
  v6[28] = (v6 + 27);
  v6[29] = 0;
  v6[30] = (v6 + 29);
  *((_BYTE *)v6 + 340) = 2;
  if (nw_protocol_copy_http_definition_onceToken != -1)
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72660);
  v32 = (id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_plugin_metadata_set_callbacks((uint64_t)v6, v32, (uint64_t)nw_protocol_http_redirect_create::$_0::__invoke, (uint64_t)nw_protocol_http_redirect_create::$_1::__invoke);
  if (v32)
    os_release(v32);
  v6[11] = (v6 + 43);
  nw_protocol_plugin_retry_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_redirect_create::$_2::__invoke, (uint64_t)nw_protocol_http_redirect_create::$_3::__invoke, (uint64_t)nw_protocol_http_redirect_create::$_4::__invoke, (uint64_t)nw_protocol_http_redirect_create::$_5::__invoke);
  v6[8] = (v6 + 13);
  nw_protocol_plugin_name_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_redirect_create::$_6::__invoke);
  if (v17)
    os_release(v25);
  if (v15)
    os_release(v15);
  return (BOOL)v6;
}

void sub_1833573A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_http_redirect_create::$_0::__invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  id v8;
  void *v9;
  char v10;
  void *v11;
  id v12;
  int status_code;
  unsigned int v14;
  id v15;
  uint64_t v16;
  void *v17;
  const char *url_scheme;
  const char *hostname;
  NSObject *v20;
  void *v21;
  void *v22;
  id v23;
  void *v24;
  id v25;
  char v26;
  int v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  os_log_type_t v31;
  NSObject *v32;
  _BOOL4 v33;
  id v34;
  char has_method;
  id v36;
  char v37;
  NSObject *v38;
  void *v39;
  id v40;
  void *v41;
  const char *url;
  uint64_t v43;
  os_log_type_t *v44;
  char v45;
  void *v46;
  id *metadata_for_request;
  uint64_t v48;
  void *v49;
  char v50;
  void *v51;
  NSObject *v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  char *v57;
  _BOOL4 v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  const char *v62;
  char *v63;
  NSObject *v64;
  os_log_type_t v65;
  const char *v66;
  char *backtrace_string;
  _BOOL4 v68;
  char *v69;
  _BOOL4 v70;
  const char *v71;
  _BOOL4 v72;
  _BOOL4 v73;
  _BOOL4 v74;
  char *v75;
  _BOOL4 v76;
  NSObject *v77;
  NSObject *v78;
  int v79;
  char *v80;
  NSObject *v81;
  os_log_type_t v82;
  const char *v83;
  char *v84;
  NSObject *v85;
  os_log_type_t v86;
  const char *v87;
  char *v88;
  _BOOL4 v89;
  char *v90;
  NSObject *v91;
  _BOOL4 v92;
  const char *v93;
  NSObject *v94;
  _BOOL4 v95;
  NSObject *v96;
  NSObject *log;
  _QWORD block[7];
  uint64_t v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t (*v102)(uint64_t, uint64_t);
  void (*v103)(uint64_t);
  void *v104;
  char v105;
  _QWORD v106[6];
  _QWORD v107[3];
  char v108;
  _QWORD v109[6];
  os_log_type_t type[8];
  os_log_type_t *v111;
  uint64_t v112;
  uint64_t (*v113)(uint64_t, uint64_t);
  void (*v114)(uint64_t);
  void *object;
  char v116;
  _BYTE buf[24];
  uint64_t (*v118)(uint64_t, uint64_t);
  void (*v119)(uint64_t);
  void *v120;
  char v121;
  _BYTE v122[24];
  const char *v123;
  os_log_type_t *v124;
  os_log_type_t *v125;
  uint64_t v126;
  char v127;
  uint64_t v128;

  v128 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v59 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v99) = 0;
    if (!__nwlog_fault(v59, type, &v99))
      goto LABEL_180;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v99)
      {
        v60 = __nwlog_obj();
        v61 = type[0];
        if (!os_log_type_enabled(v60, type[0]))
          goto LABEL_180;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "operator()";
        v62 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_179;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v60 = __nwlog_obj();
      v61 = type[0];
      v68 = os_log_type_enabled(v60, type[0]);
      if (!backtrace_string)
      {
        if (!v68)
          goto LABEL_180;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "operator()";
        v62 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_179;
      }
      if (v68)
      {
        *(_DWORD *)v122 = 136446466;
        *(_QWORD *)&v122[4] = "operator()";
        *(_WORD *)&v122[12] = 2082;
        *(_QWORD *)&v122[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s called with null protocol, dumping backtrace:%{public}s", v122, 0x16u);
      }
      free(backtrace_string);
LABEL_180:
      if (v59)
        goto LABEL_181;
      return;
    }
    v60 = __nwlog_obj();
    v61 = type[0];
    if (!os_log_type_enabled(v60, type[0]))
      goto LABEL_180;
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v62 = "%{public}s called with null protocol";
    goto LABEL_179;
  }
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v59 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v99) = 0;
    if (!__nwlog_fault(v59, type, &v99))
      goto LABEL_180;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v99)
      {
        v60 = __nwlog_obj();
        v61 = type[0];
        if (!os_log_type_enabled(v60, type[0]))
          goto LABEL_180;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "operator()";
        v62 = "%{public}s called with null http_redirect, backtrace limit exceeded";
        goto LABEL_179;
      }
      v69 = (char *)__nw_create_backtrace_string();
      v60 = __nwlog_obj();
      v61 = type[0];
      v70 = os_log_type_enabled(v60, type[0]);
      if (!v69)
      {
        if (!v70)
          goto LABEL_180;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "operator()";
        v62 = "%{public}s called with null http_redirect, no backtrace";
        goto LABEL_179;
      }
      if (!v70)
        goto LABEL_134;
      *(_DWORD *)v122 = 136446466;
      *(_QWORD *)&v122[4] = "operator()";
      *(_WORD *)&v122[12] = 2082;
      *(_QWORD *)&v122[14] = v69;
      v71 = "%{public}s called with null http_redirect, dumping backtrace:%{public}s";
      goto LABEL_133;
    }
    v60 = __nwlog_obj();
    v61 = type[0];
    if (!os_log_type_enabled(v60, type[0]))
      goto LABEL_180;
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v62 = "%{public}s called with null http_redirect";
LABEL_179:
    _os_log_impl(&dword_182FBE000, v60, v61, v62, v122, 0xCu);
    goto LABEL_180;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v59 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v99) = 0;
    if (!__nwlog_fault(v59, type, &v99))
      goto LABEL_180;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v99)
      {
        v60 = __nwlog_obj();
        v61 = type[0];
        if (!os_log_type_enabled(v60, type[0]))
          goto LABEL_180;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "operator()";
        v62 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_179;
      }
      v69 = (char *)__nw_create_backtrace_string();
      v60 = __nwlog_obj();
      v61 = type[0];
      v72 = os_log_type_enabled(v60, type[0]);
      if (!v69)
      {
        if (!v72)
          goto LABEL_180;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "operator()";
        v62 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_179;
      }
      if (!v72)
        goto LABEL_134;
      *(_DWORD *)v122 = 136446466;
      *(_QWORD *)&v122[4] = "operator()";
      *(_WORD *)&v122[12] = 2082;
      *(_QWORD *)&v122[14] = v69;
      v71 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_133;
    }
    v60 = __nwlog_obj();
    v61 = type[0];
    if (!os_log_type_enabled(v60, type[0]))
      goto LABEL_180;
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v62 = "%{public}s called with null other_protocol";
    goto LABEL_179;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v59 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v99) = 0;
    if (!__nwlog_fault(v59, type, &v99))
      goto LABEL_180;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v60 = __nwlog_obj();
      v61 = type[0];
      if (!os_log_type_enabled(v60, type[0]))
        goto LABEL_180;
      *(_DWORD *)v122 = 136446210;
      *(_QWORD *)&v122[4] = "operator()";
      v62 = "%{public}s called with null metadata";
      goto LABEL_179;
    }
    if (!(_BYTE)v99)
    {
      v60 = __nwlog_obj();
      v61 = type[0];
      if (!os_log_type_enabled(v60, type[0]))
        goto LABEL_180;
      *(_DWORD *)v122 = 136446210;
      *(_QWORD *)&v122[4] = "operator()";
      v62 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_179;
    }
    v69 = (char *)__nw_create_backtrace_string();
    v60 = __nwlog_obj();
    v61 = type[0];
    v73 = os_log_type_enabled(v60, type[0]);
    if (!v69)
    {
      if (!v73)
        goto LABEL_180;
      *(_DWORD *)v122 = 136446210;
      *(_QWORD *)&v122[4] = "operator()";
      v62 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_179;
    }
    if (!v73)
      goto LABEL_134;
    *(_DWORD *)v122 = 136446466;
    *(_QWORD *)&v122[4] = "operator()";
    *(_WORD *)&v122[12] = 2082;
    *(_QWORD *)&v122[14] = v69;
    v71 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_133:
    _os_log_impl(&dword_182FBE000, v60, v61, v71, v122, 0x16u);
    goto LABEL_134;
  }
  if (a5)
  {
    v8 = nw_http_metadata_copy_response(a3);
    if (v8)
    {
      v9 = v8;
      v10 = *(_BYTE *)(v5 + 584);
      if ((v10 & 1) != 0)
      {
        v11 = *(void **)(v5 + 576);
        if (v11)
        {
          os_release(v11);
          v10 = *(_BYTE *)(v5 + 584);
        }
      }
      *(_QWORD *)(v5 + 576) = 0;
      *(_BYTE *)(v5 + 584) = v10 | 1;
      v12 = v9;
      status_code = _nw_http_response_get_status_code();

      v14 = status_code - 301;
      if ((status_code - 301) > 7 || ((1 << v14) & 0xC7) == 0)
        goto LABEL_14;
      if ((*(_BYTE *)(v5 + 692) & 0x10) == 0)
      {
        if (*(_BYTE *)(v5 + 198) & 1 | (gLogDatapath == 0))
          goto LABEL_14;
        v77 = __nwlog_obj();
        if (!os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
          goto LABEL_14;
        *(_DWORD *)v122 = 136446722;
        *(_QWORD *)&v122[4] = "nw_http_redirect_process";
        *(_WORD *)&v122[12] = 2082;
        *(_QWORD *)&v122[14] = v5 + 114;
        *(_WORD *)&v122[22] = 2080;
        v123 = " ";
        v29 = "%{public}s %{public}s%sNot redirecting because no longer handling inbound reply";
        v30 = v77;
        v31 = OS_LOG_TYPE_DEBUG;
LABEL_39:
        _os_log_impl(&dword_182FBE000, v30, v31, v29, v122, 0x20u);
LABEL_14:
        os_release(v12);
LABEL_15:
        (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1, a3);
        return;
      }
      if (!(*(_BYTE *)(v5 + 198) & 1 | (gLogDatapath == 0)))
      {
        v78 = __nwlog_obj();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
        {
          v79 = *(_DWORD *)(v5 + 688);
          *(_DWORD *)v122 = 136446978;
          *(_QWORD *)&v122[4] = "nw_http_redirect_process";
          *(_WORD *)&v122[12] = 2082;
          *(_QWORD *)&v122[14] = v5 + 114;
          *(_WORD *)&v122[22] = 2080;
          v123 = " ";
          LOWORD(v124) = 1024;
          *(_DWORD *)((char *)&v124 + 2) = v79;
          _os_log_impl(&dword_182FBE000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled with redirect_limit %u", v122, 0x26u);
        }
      }
      if (!*(_DWORD *)(v5 + 688))
      {
        if ((*(_BYTE *)(v5 + 198) & 1) != 0)
          goto LABEL_14;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          goto LABEL_14;
        *(_DWORD *)v122 = 136446722;
        *(_QWORD *)&v122[4] = "nw_http_redirect_process";
        *(_WORD *)&v122[12] = 2082;
        *(_QWORD *)&v122[14] = v5 + 114;
        *(_WORD *)&v122[22] = 2080;
        v123 = " ";
        v29 = "%{public}s %{public}s%sNot redirecting because we reached the limit";
        v30 = v28;
        v31 = OS_LOG_TYPE_INFO;
        goto LABEL_39;
      }
      v99 = 0;
      v100 = &v99;
      v101 = 0x3802000000;
      v102 = __Block_byref_object_copy__927;
      v103 = __Block_byref_object_dispose__928;
      v15 = nw_http_metadata_copy_response(a3);
      *(_QWORD *)type = 0;
      v111 = type;
      v112 = 0x2000000000;
      v113 = 0;
      v16 = MEMORY[0x1E0C809B0];
      *(_QWORD *)v122 = MEMORY[0x1E0C809B0];
      *(_QWORD *)&v122[8] = 0x40000000;
      *(_QWORD *)&v122[16] = ___ZL30nw_http_redirect_copy_endpointP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke;
      v123 = (const char *)&unk_1E149A2C8;
      v124 = type;
      v125 = (os_log_type_t *)v5;
      nw_http_fields_access_value_by_name(v15, (unint64_t)"Location", v122);
      v17 = (void *)*((_QWORD *)v111 + 3);
      if (v17)
      {
        url_scheme = (const char *)nw_endpoint_get_url_scheme(v17);
        if (!strcasecmp(url_scheme, "https") || !strcasecmp(url_scheme, "http"))
        {
          hostname = nw_endpoint_get_hostname(*((nw_endpoint_t *)v111 + 3));
          if (!hostname || !*hostname)
          {
            if ((*(_BYTE *)(v5 + 198) & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v20 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_http_redirect_copy_endpoint";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v5 + 114;
                *(_WORD *)&buf[22] = 2080;
                v118 = (uint64_t (*)(uint64_t, uint64_t))" ";
                _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sinvalid http URL without hostname", buf, 0x20u);
              }
            }
            v21 = (void *)*((_QWORD *)v111 + 3);
            if (v21)
            {
              os_release(v21);
              *((_QWORD *)v111 + 3) = 0;
            }
          }
        }
      }
      v22 = (void *)*((_QWORD *)v111 + 3);
      _Block_object_dispose(type, 8);
      if (v15)
        os_release(v15);
      v104 = v22;
      v105 |= 1u;
      if (!v100[5])
      {
        if ((*(_BYTE *)(v5 + 198) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v32 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v122 = 136446722;
            *(_QWORD *)&v122[4] = "nw_http_redirect_process";
            *(_WORD *)&v122[12] = 2082;
            *(_QWORD *)&v122[14] = v5 + 114;
            *(_WORD *)&v122[22] = 2080;
            v123 = " ";
            _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sUnable to create endpoint from redirect headers", v122, 0x20u);
            v33 = 0;
            goto LABEL_219;
          }
        }
LABEL_218:
        v33 = 0;
        goto LABEL_219;
      }
      v23 = nw_http_metadata_copy_request(*(void **)(v5 + 560));
      if (v23)
      {
        v24 = v23;
        if (v14 > 1)
        {
          if (status_code == 303)
          {
            v34 = v23;
            has_method = _nw_http_request_has_method((uint64_t)v34);

            if ((has_method & 1) == 0)
            {
              v36 = v34;
              v37 = _nw_http_request_has_method((uint64_t)v36);

              if ((v37 & 1) == 0)
                goto LABEL_35;
            }
          }
        }
        else
        {
          v25 = v23;
          v26 = _nw_http_request_has_method((uint64_t)v25);

          if ((v26 & 1) != 0)
          {
LABEL_35:
            *(_BYTE *)(v5 + 692) &= ~8u;
            v27 = 1;
            goto LABEL_47;
          }
        }
        v27 = 0;
LABEL_47:
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x3802000000;
        v118 = __Block_byref_object_copy__12;
        v119 = __Block_byref_object_dispose__13;
        v38 = v100[5];
        if (v38)
        {
          v39 = *(void **)(v5 + 560);
          if (v39)
          {
            *(_QWORD *)type = 0;
            v111 = type;
            v112 = 0x3802000000;
            v113 = __Block_byref_object_copy__32;
            v114 = __Block_byref_object_dispose__33;
            object = 0;
            v116 = -1;
            v40 = nw_http_metadata_copy_request(v39);
            v41 = v40;
            if (v27)
            {
              url = nw_endpoint_get_url(v38);
              v43 = nw_http_request_create_from_url((uint64_t)"GET", (uint64_t)url);
              v44 = v111;
              v45 = *((_BYTE *)v111 + 48);
              if ((v45 & 1) != 0)
              {
                v46 = (void *)*((_QWORD *)v111 + 5);
                if (v46)
                {
                  os_release(v46);
                  v45 = *((_BYTE *)v44 + 48);
                }
              }
              *((_QWORD *)v44 + 5) = v43;
              *((_BYTE *)v44 + 48) = v45 | 1;
            }
            else
            {
              v109[0] = v16;
              v109[1] = 0x40000000;
              v109[2] = ___ZL30nw_http_redirect_copy_metadataP25nw_protocol_http_redirectP11nw_endpointP20nw_protocol_metadatab_block_invoke;
              v109[3] = &unk_1E149A2F0;
              v109[4] = type;
              v109[5] = v38;
              nw_http_request_access_method(v40, v109);
            }
            v107[0] = 0;
            v107[1] = v107;
            v107[2] = 0x2000000000;
            v108 = 0;
            v106[0] = v16;
            v106[1] = 0x40000000;
            v106[2] = ___ZL30nw_http_redirect_copy_metadataP25nw_protocol_http_redirectP11nw_endpointP20nw_protocol_metadatab_block_invoke_2;
            v106[3] = &unk_1E149A340;
            v106[4] = type;
            v106[5] = v107;
            nw_http_request_access_authority(v41, v106);
            *(_QWORD *)v122 = v16;
            *(_QWORD *)&v122[8] = 0x40000000;
            *(_QWORD *)&v122[16] = ___ZL30nw_http_redirect_copy_metadataP25nw_protocol_http_redirectP11nw_endpointP20nw_protocol_metadatab_block_invoke_4;
            v123 = (const char *)&unk_1E149A368;
            v127 = v27;
            v125 = type;
            v126 = v5;
            v124 = (os_log_type_t *)v107;
            nw_http_fields_enumerate(v41, v122);
            metadata_for_request = nw_http_create_metadata_for_request(*((void **)v111 + 5));
            _Block_object_dispose(v107, 8);
            if (v41)
              os_release(v41);
            _Block_object_dispose(type, 8);
            if ((v116 & 1) != 0 && object)
              os_release(object);
            goto LABEL_60;
          }
          __nwlog_obj();
          *(_DWORD *)v122 = 136446210;
          *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
          v84 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v109[0]) = 0;
          if (!__nwlog_fault(v84, type, v109))
            goto LABEL_210;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v85 = __nwlog_obj();
            v86 = type[0];
            if (os_log_type_enabled(v85, type[0]))
            {
              *(_DWORD *)v122 = 136446210;
              *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
              v87 = "%{public}s called with null orig_request_metadata";
              goto LABEL_208;
            }
            goto LABEL_210;
          }
          if (!LOBYTE(v109[0]))
          {
            v85 = __nwlog_obj();
            v86 = type[0];
            if (os_log_type_enabled(v85, type[0]))
            {
              *(_DWORD *)v122 = 136446210;
              *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
              v87 = "%{public}s called with null orig_request_metadata, backtrace limit exceeded";
              goto LABEL_208;
            }
            goto LABEL_210;
          }
          v90 = (char *)__nw_create_backtrace_string();
          v94 = __nwlog_obj();
          v86 = type[0];
          log = v94;
          v95 = os_log_type_enabled(v94, type[0]);
          if (v90)
          {
            if (v95)
            {
              *(_DWORD *)v122 = 136446466;
              *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
              *(_WORD *)&v122[12] = 2082;
              *(_QWORD *)&v122[14] = v90;
              v93 = "%{public}s called with null orig_request_metadata, dumping backtrace:%{public}s";
              goto LABEL_200;
            }
            goto LABEL_201;
          }
          if (!v95)
            goto LABEL_210;
          *(_DWORD *)v122 = 136446210;
          *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
          v87 = "%{public}s called with null orig_request_metadata, no backtrace";
        }
        else
        {
          __nwlog_obj();
          *(_DWORD *)v122 = 136446210;
          *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
          v84 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v109[0]) = 0;
          if (!__nwlog_fault(v84, type, v109))
            goto LABEL_210;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v85 = __nwlog_obj();
            v86 = type[0];
            if (os_log_type_enabled(v85, type[0]))
            {
              *(_DWORD *)v122 = 136446210;
              *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
              v87 = "%{public}s called with null endpoint";
LABEL_208:
              v96 = v85;
LABEL_209:
              _os_log_impl(&dword_182FBE000, v96, v86, v87, v122, 0xCu);
            }
LABEL_210:
            if (v84)
              free(v84);
            metadata_for_request = 0;
LABEL_60:
            v120 = metadata_for_request;
            v121 |= 1u;
            v48 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
            v33 = v48 != 0;
            if (v48)
            {
              v49 = os_retain(a3);
              v50 = *(_BYTE *)(v5 + 584);
              if ((v50 & 1) != 0)
              {
                v51 = *(void **)(v5 + 576);
                if (v51)
                {
                  os_release(v51);
                  v50 = *(_BYTE *)(v5 + 584);
                }
              }
              *(_QWORD *)(v5 + 576) = v49;
              *(_BYTE *)(v5 + 584) = v50 | 1;
              if (*(_QWORD *)(v5 + 592) && *(_QWORD *)(v5 + 608))
              {
                nw_protocol_plugin_retry_begin_async(v5 + 344);
                v52 = *(NSObject **)(v5 + 608);
                block[0] = v16;
                block[1] = 0x40000000;
                block[2] = ___ZL24nw_http_redirect_processP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke;
                block[3] = &unk_1E149A278;
                block[4] = &v99;
                block[5] = buf;
                block[6] = v5;
                dispatch_async(v52, block);
              }
              else
              {
                nw_protocol_plugin_metadata_resume_input(v5 + 200, 3);
                nw_http_redirect_reissue(v5, (void *)v100[5], 0, *(_QWORD *)(v5 + 560), *(void **)(*(_QWORD *)&buf[8] + 40));
              }
LABEL_84:
              _Block_object_dispose(buf, 8);
              if ((v121 & 1) != 0 && v120)
                os_release(v120);
              os_release(v24);
LABEL_219:
              _Block_object_dispose(&v99, 8);
              if ((v105 & 1) != 0 && v104)
                os_release(v104);
              os_release(v12);
              if (v33)
              {
                (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 2, a3);
                return;
              }
              goto LABEL_15;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)v122 = 136446210;
            *(_QWORD *)&v122[4] = "nw_http_redirect_process";
            v53 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v109[0]) = 0;
            if (__nwlog_fault(v53, type, v109))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v54 = gLogObj;
                v55 = type[0];
                if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                  goto LABEL_82;
                *(_DWORD *)v122 = 136446210;
                *(_QWORD *)&v122[4] = "nw_http_redirect_process";
                v56 = "%{public}s Unable to create new request metadata";
                goto LABEL_81;
              }
              if (!LOBYTE(v109[0]))
              {
                v54 = __nwlog_obj();
                v55 = type[0];
                if (!os_log_type_enabled(v54, type[0]))
                  goto LABEL_82;
                *(_DWORD *)v122 = 136446210;
                *(_QWORD *)&v122[4] = "nw_http_redirect_process";
                v56 = "%{public}s Unable to create new request metadata, backtrace limit exceeded";
                goto LABEL_81;
              }
              v57 = (char *)__nw_create_backtrace_string();
              v54 = __nwlog_obj();
              v55 = type[0];
              v58 = os_log_type_enabled(v54, type[0]);
              if (v57)
              {
                if (v58)
                {
                  *(_DWORD *)v122 = 136446466;
                  *(_QWORD *)&v122[4] = "nw_http_redirect_process";
                  *(_WORD *)&v122[12] = 2082;
                  *(_QWORD *)&v122[14] = v57;
                  _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s Unable to create new request metadata, dumping backtrace:%{public}s", v122, 0x16u);
                }
                free(v57);
                goto LABEL_82;
              }
              if (v58)
              {
                *(_DWORD *)v122 = 136446210;
                *(_QWORD *)&v122[4] = "nw_http_redirect_process";
                v56 = "%{public}s Unable to create new request metadata, no backtrace";
LABEL_81:
                _os_log_impl(&dword_182FBE000, v54, v55, v56, v122, 0xCu);
              }
            }
LABEL_82:
            if (v53)
              free(v53);
            goto LABEL_84;
          }
          if (!LOBYTE(v109[0]))
          {
            v85 = __nwlog_obj();
            v86 = type[0];
            if (os_log_type_enabled(v85, type[0]))
            {
              *(_DWORD *)v122 = 136446210;
              *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
              v87 = "%{public}s called with null endpoint, backtrace limit exceeded";
              goto LABEL_208;
            }
            goto LABEL_210;
          }
          v90 = (char *)__nw_create_backtrace_string();
          v91 = __nwlog_obj();
          v86 = type[0];
          log = v91;
          v92 = os_log_type_enabled(v91, type[0]);
          if (v90)
          {
            if (v92)
            {
              *(_DWORD *)v122 = 136446466;
              *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
              *(_WORD *)&v122[12] = 2082;
              *(_QWORD *)&v122[14] = v90;
              v93 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
LABEL_200:
              _os_log_impl(&dword_182FBE000, log, v86, v93, v122, 0x16u);
            }
LABEL_201:
            free(v90);
            goto LABEL_210;
          }
          if (!v92)
            goto LABEL_210;
          *(_DWORD *)v122 = 136446210;
          *(_QWORD *)&v122[4] = "nw_http_redirect_copy_metadata";
          v87 = "%{public}s called with null endpoint, no backtrace";
        }
        v96 = log;
        goto LABEL_209;
      }
      __nwlog_obj();
      *(_DWORD *)v122 = 136446210;
      *(_QWORD *)&v122[4] = "nw_http_redirect_process";
      v80 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      buf[0] = 0;
      if (__nwlog_fault(v80, type, buf))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v81 = __nwlog_obj();
          v82 = type[0];
          if (!os_log_type_enabled(v81, type[0]))
            goto LABEL_216;
          *(_DWORD *)v122 = 136446210;
          *(_QWORD *)&v122[4] = "nw_http_redirect_process";
          v83 = "%{public}s called with null request";
          goto LABEL_215;
        }
        if (!buf[0])
        {
          v81 = __nwlog_obj();
          v82 = type[0];
          if (!os_log_type_enabled(v81, type[0]))
            goto LABEL_216;
          *(_DWORD *)v122 = 136446210;
          *(_QWORD *)&v122[4] = "nw_http_redirect_process";
          v83 = "%{public}s called with null request, backtrace limit exceeded";
          goto LABEL_215;
        }
        v88 = (char *)__nw_create_backtrace_string();
        v81 = __nwlog_obj();
        v82 = type[0];
        v89 = os_log_type_enabled(v81, type[0]);
        if (v88)
        {
          if (v89)
          {
            *(_DWORD *)v122 = 136446466;
            *(_QWORD *)&v122[4] = "nw_http_redirect_process";
            *(_WORD *)&v122[12] = 2082;
            *(_QWORD *)&v122[14] = v88;
            _os_log_impl(&dword_182FBE000, v81, v82, "%{public}s called with null request, dumping backtrace:%{public}s", v122, 0x16u);
          }
          free(v88);
          goto LABEL_216;
        }
        if (v89)
        {
          *(_DWORD *)v122 = 136446210;
          *(_QWORD *)&v122[4] = "nw_http_redirect_process";
          v83 = "%{public}s called with null request, no backtrace";
LABEL_215:
          _os_log_impl(&dword_182FBE000, v81, v82, v83, v122, 0xCu);
        }
      }
LABEL_216:
      if (v80)
        free(v80);
      goto LABEL_218;
    }
    __nwlog_obj();
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "nw_http_redirect_process";
    v63 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v99) = 0;
    if (__nwlog_fault(v63, type, &v99))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v64 = __nwlog_obj();
        v65 = type[0];
        if (!os_log_type_enabled(v64, type[0]))
          goto LABEL_185;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "nw_http_redirect_process";
        v66 = "%{public}s called with null response";
        goto LABEL_184;
      }
      if (!(_BYTE)v99)
      {
        v64 = __nwlog_obj();
        v65 = type[0];
        if (!os_log_type_enabled(v64, type[0]))
          goto LABEL_185;
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "nw_http_redirect_process";
        v66 = "%{public}s called with null response, backtrace limit exceeded";
        goto LABEL_184;
      }
      v75 = (char *)__nw_create_backtrace_string();
      v64 = __nwlog_obj();
      v65 = type[0];
      v76 = os_log_type_enabled(v64, type[0]);
      if (v75)
      {
        if (v76)
        {
          *(_DWORD *)v122 = 136446466;
          *(_QWORD *)&v122[4] = "nw_http_redirect_process";
          *(_WORD *)&v122[12] = 2082;
          *(_QWORD *)&v122[14] = v75;
          _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s called with null response, dumping backtrace:%{public}s", v122, 0x16u);
        }
        free(v75);
        goto LABEL_185;
      }
      if (v76)
      {
        *(_DWORD *)v122 = 136446210;
        *(_QWORD *)&v122[4] = "nw_http_redirect_process";
        v66 = "%{public}s called with null response, no backtrace";
LABEL_184:
        _os_log_impl(&dword_182FBE000, v64, v65, v66, v122, 0xCu);
      }
    }
LABEL_185:
    if (v63)
      free(v63);
    goto LABEL_15;
  }
  __nwlog_obj();
  *(_DWORD *)v122 = 136446210;
  *(_QWORD *)&v122[4] = "operator()";
  v59 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v99) = 0;
  if (!__nwlog_fault(v59, type, &v99))
    goto LABEL_180;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v60 = __nwlog_obj();
    v61 = type[0];
    if (!os_log_type_enabled(v60, type[0]))
      goto LABEL_180;
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v62 = "%{public}s called with null completion";
    goto LABEL_179;
  }
  if (!(_BYTE)v99)
  {
    v60 = __nwlog_obj();
    v61 = type[0];
    if (!os_log_type_enabled(v60, type[0]))
      goto LABEL_180;
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v62 = "%{public}s called with null completion, backtrace limit exceeded";
    goto LABEL_179;
  }
  v69 = (char *)__nw_create_backtrace_string();
  v60 = __nwlog_obj();
  v61 = type[0];
  v74 = os_log_type_enabled(v60, type[0]);
  if (!v69)
  {
    if (!v74)
      goto LABEL_180;
    *(_DWORD *)v122 = 136446210;
    *(_QWORD *)&v122[4] = "operator()";
    v62 = "%{public}s called with null completion, no backtrace";
    goto LABEL_179;
  }
  if (v74)
  {
    *(_DWORD *)v122 = 136446466;
    *(_QWORD *)&v122[4] = "operator()";
    *(_WORD *)&v122[12] = 2082;
    *(_QWORD *)&v122[14] = v69;
    v71 = "%{public}s called with null completion, dumping backtrace:%{public}s";
    goto LABEL_133;
  }
LABEL_134:
  free(v69);
  if (v59)
LABEL_181:
    free(v59);
}

void nw_protocol_http_redirect_create::$_1::__invoke(uint64_t a1, int a2, void *object, int a4, uint64_t a5)
{
  uint64_t v5;
  void *v9;
  char v10;
  void *v11;
  id v12;
  char v13;
  char v14;
  char v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  char *v22;
  _BOOL4 v23;
  const char *v24;
  _BOOL4 v25;
  _BOOL4 v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "operator()";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v16, &type, &v27))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null protocol";
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "operator()";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_72:
        if (!v16)
          return;
        goto LABEL_73;
      }
      if (!v21)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_71;
  }
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "operator()";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v16, &type, &v27))
      goto LABEL_72;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v27)
      {
        v17 = __nwlog_obj();
        v18 = type;
        if (!os_log_type_enabled(v17, type))
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        v30 = "operator()";
        v19 = "%{public}s called with null http_redirect, backtrace limit exceeded";
        goto LABEL_71;
      }
      v22 = (char *)__nw_create_backtrace_string();
      v17 = __nwlog_obj();
      v18 = type;
      v23 = os_log_type_enabled(v17, type);
      if (!v22)
      {
        if (!v23)
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        v30 = "operator()";
        v19 = "%{public}s called with null http_redirect, no backtrace";
        goto LABEL_71;
      }
      if (!v23)
        goto LABEL_53;
      *(_DWORD *)buf = 136446466;
      v30 = "operator()";
      v31 = 2082;
      v32 = v22;
      v24 = "%{public}s called with null http_redirect, dumping backtrace:%{public}s";
      goto LABEL_52;
    }
    v17 = __nwlog_obj();
    v18 = type;
    if (!os_log_type_enabled(v17, type))
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    v30 = "operator()";
    v19 = "%{public}s called with null http_redirect";
LABEL_71:
    _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
    goto LABEL_72;
  }
  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "operator()";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v16, &type, &v27))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null metadata";
      goto LABEL_71;
    }
    if (!v27)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v25 = os_log_type_enabled(v17, type);
    if (!v22)
    {
      if (!v25)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_71;
    }
    if (!v25)
      goto LABEL_53;
    *(_DWORD *)buf = 136446466;
    v30 = "operator()";
    v31 = 2082;
    v32 = v22;
    v24 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_52:
    _os_log_impl(&dword_182FBE000, v17, v18, v24, buf, 0x16u);
    goto LABEL_53;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "operator()";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v16, &type, &v27))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null completion";
      goto LABEL_71;
    }
    if (!v27)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v26 = os_log_type_enabled(v17, type);
    if (!v22)
    {
      if (!v26)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v30 = "operator()";
      v19 = "%{public}s called with null completion, no backtrace";
      goto LABEL_71;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "operator()";
      v31 = 2082;
      v32 = v22;
      v24 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_52;
    }
LABEL_53:
    free(v22);
    if (!v16)
      return;
LABEL_73:
    free(v16);
    return;
  }
  v9 = os_retain(object);
  v10 = *(_BYTE *)(v5 + 568);
  if ((v10 & 1) != 0)
  {
    v11 = *(void **)(v5 + 560);
    if (v11)
    {
      os_release(v11);
      v10 = *(_BYTE *)(v5 + 568);
    }
  }
  *(_QWORD *)(v5 + 560) = v9;
  *(_BYTE *)(v5 + 568) = v10 | 1;
  v12 = nw_http_metadata_copy_request(object);
  if (nw_http_fields_have_field_with_name(v12, (unint64_t)"Cookie"))
    v13 = 2;
  else
    v13 = 0;
  *(_BYTE *)(v5 + 692) = *(_BYTE *)(v5 + 692) & 0xFD | v13;
  if (nw_http_fields_have_field_with_name(v12, (unint64_t)"Accept-Encoding"))
    v14 = 4;
  else
    v14 = 0;
  if (a4)
    v15 = 0;
  else
    v15 = 8;
  *(_BYTE *)(v5 + 692) = v14 | v15 | *(_BYTE *)(v5 + 692) & 0xF3;
  (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1, object);
  if (v12)
    os_release(v12);
}

uint64_t nw_protocol_http_redirect_create::$_2::__invoke(nw_protocol_http_redirect_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 0;
}

uint64_t nw_protocol_http_redirect_create::$_3::__invoke(nw_protocol_http_redirect_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_redirect_create::$_4::__invoke(nw_protocol_http_redirect_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_redirect_create::$_5::__invoke(nw_protocol_http_redirect_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_redirect_create::$_6::__invoke(nw_protocol_http_redirect_create::$_6 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t __Block_byref_object_copy__927(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__928(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZL30nw_http_redirect_copy_endpointP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke(uint64_t a1, _BYTE *a2)
{
  void *parameters;
  NSObject *v5;
  NSObject *v6;
  CFMutableStringRef Mutable;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  CFIndex length;
  CFIndex v14;
  CFIndex v15;
  _BOOL8 v16;
  const char *url;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  CFRange v26;
  CFRange rangeIncludingSeparators;
  _QWORD v28[6];
  uint8_t v29[4];
  const char *v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  const char *v34;
  _BYTE buf[24];
  uint64_t (*v36)(uint64_t, uint64_t);
  void (*v37)(uint64_t);
  CFTypeRef cf;
  char v39;
  _BYTE chars[24];
  uint64_t (*v41)(uint64_t, uint64_t);
  void (*v42)(uint64_t);
  CFTypeRef v43;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return;
  parameters = (void *)nw_protocol_get_parameters(*(_QWORD *)(a1 + 40));
  v5 = nw_parameters_copy_url_endpoint(parameters);
  if (v5)
  {
    v6 = v5;
    Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v8 = *a2;
    if (*a2)
    {
      v9 = a2 + 1;
      do
      {
        while (!memchr("!#$%&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~",
                   v8,
                   0x56uLL))
        {
          CFStringAppendFormat(Mutable, 0, CFSTR("%%%02X"), v8);
          v10 = *v9++;
          v8 = v10;
          if (!v10)
            goto LABEL_8;
        }
        *(_WORD *)chars = v8;
        CFStringAppendCharacters(Mutable, (const UniChar *)chars, 1);
        v11 = *v9++;
        v8 = v11;
      }
      while (v11);
    }
LABEL_8:
    *(_QWORD *)chars = 0;
    *(_QWORD *)&chars[8] = chars;
    *(_QWORD *)&chars[16] = 0x3802000000;
    v41 = __Block_byref_object_copy__23;
    v42 = __Block_byref_object_dispose__24;
    v43 = nw_endpoint_copy_cfurl(v6);
    v44 |= 1u;
    if (!*(_QWORD *)(*(_QWORD *)&chars[8] + 40))
    {
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 40) + 198) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v21 = *(_QWORD *)(a1 + 40) + 114;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_redirect_copy_endpoint_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v21;
          *(_WORD *)&buf[22] = 2080;
          v36 = (uint64_t (*)(uint64_t, uint64_t))" ";
          _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sfailed to get base URL", buf, 0x20u);
        }
      }
      goto LABEL_37;
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3802000000;
    v36 = __Block_byref_object_copy__23;
    v37 = __Block_byref_object_dispose__24;
    cf = 0;
    v39 = -1;
    v28[0] = MEMORY[0x1E0C809B0];
    v28[1] = 0x40000000;
    v28[2] = ___ZL30nw_http_redirect_copy_endpointP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke_25;
    v28[3] = &unk_1E149A2A0;
    v28[4] = buf;
    v28[5] = chars;
    nw_utilities_get_c_string_from_cfstring(Mutable, 0x600u, v28);
    if (*(_QWORD *)(*(_QWORD *)&buf[8] + 40))
    {
      rangeIncludingSeparators.location = 0;
      rangeIncludingSeparators.length = 0;
      v26.location = 0;
      v26.length = 0;
      CFURLGetByteRangeForComponent(*(CFURLRef *)(*(_QWORD *)&chars[8] + 40), kCFURLComponentFragment, &rangeIncludingSeparators);
      CFURLGetByteRangeForComponent(*(CFURLRef *)(*(_QWORD *)&buf[8] + 40), kCFURLComponentFragment, &v26);
      if (v26.length)
        v12 = 1;
      else
        v12 = rangeIncludingSeparators.length == 0;
      if (v12)
        length = 0;
      else
        length = rangeIncludingSeparators.length;
      v14 = CFURLGetBytes(*(CFURLRef *)(*(_QWORD *)&buf[8] + 40), 0, 0);
      if (v14 > 0)
      {
        v15 = v14;
        v16 = nw_calloc_type<unsigned char>(length + v14 + 1);
        CFURLGetBytes(*(CFURLRef *)(*(_QWORD *)&buf[8] + 40), (UInt8 *)v16, v15);
        if (length >= 1)
        {
          url = nw_endpoint_get_url(v6);
          memcpy((void *)(v16 + v15), &url[rangeIncludingSeparators.location], length);
        }
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = nw_endpoint_create_url((const char *)v16);
        if (v16)
          free((void *)v16);
        goto LABEL_34;
      }
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 40) + 198) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v25 = *(_QWORD *)(a1 + 40) + 114;
          *(_DWORD *)v29 = 136446722;
          v30 = "nw_http_redirect_copy_endpoint_block_invoke";
          v31 = 2082;
          v32 = v25;
          v33 = 2080;
          v34 = " ";
          v24 = "%{public}s %{public}s%sfailed to get string bytes";
          goto LABEL_33;
        }
      }
    }
    else if ((*(_BYTE *)(*(_QWORD *)(a1 + 40) + 198) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v23 = *(_QWORD *)(a1 + 40) + 114;
        *(_DWORD *)v29 = 136446722;
        v30 = "nw_http_redirect_copy_endpoint_block_invoke_2";
        v31 = 2082;
        v32 = v23;
        v33 = 2080;
        v34 = " ";
        v24 = "%{public}s %{public}s%sfailed to get target URL";
LABEL_33:
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, v24, v29, 0x20u);
      }
    }
LABEL_34:
    _Block_object_dispose(buf, 8);
    if ((v39 & 1) != 0 && cf)
      CFRelease(cf);
LABEL_37:
    _Block_object_dispose(chars, 8);
    if ((v44 & 1) != 0 && v43)
      CFRelease(v43);
    if (Mutable)
      os_release(Mutable);
    os_release(v6);
    return;
  }
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 40) + 198) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v19 = *(_QWORD *)(a1 + 40) + 114;
      *(_DWORD *)chars = 136446722;
      *(_QWORD *)&chars[4] = "nw_http_redirect_copy_endpoint_block_invoke";
      *(_WORD *)&chars[12] = 2082;
      *(_QWORD *)&chars[14] = v19;
      *(_WORD *)&chars[22] = 2080;
      v41 = (uint64_t (*)(uint64_t, uint64_t))" ";
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sfailed to get URL endpoint from parameters", chars, 0x20u);
    }
  }
}

uint64_t __Block_byref_object_copy__12(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__13(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

uint64_t __Block_byref_object_copy__32(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__33(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZL30nw_http_redirect_copy_metadataP25nw_protocol_http_redirectP11nw_endpointP20nw_protocol_metadatab_block_invoke(uint64_t a1, uint64_t a2)
{
  const char *url;
  uint64_t v5;
  uint64_t v6;
  char v7;
  void *v8;

  url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 40));
  v5 = nw_http_request_create_from_url(a2, (uint64_t)url);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v7 = *(_BYTE *)(v6 + 48);
  if ((v7 & 1) != 0)
  {
    v8 = *(void **)(v6 + 40);
    if (v8)
    {
      os_release(v8);
      v7 = *(_BYTE *)(v6 + 48);
    }
  }
  *(_QWORD *)(v6 + 40) = v5;
  *(_BYTE *)(v6 + 48) = v7 | 1;
}

void ___ZL30nw_http_redirect_copy_metadataP25nw_protocol_http_redirectP11nw_endpointP20nw_protocol_metadatab_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  _QWORD v4[6];

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZL30nw_http_redirect_copy_metadataP25nw_protocol_http_redirectP11nw_endpointP20nw_protocol_metadatab_block_invoke_3;
  v4[3] = &unk_1E149A318;
  v4[4] = v2;
  v4[5] = a2;
  nw_http_request_access_authority(v3, v4);
}

uint64_t ___ZL30nw_http_redirect_copy_metadataP25nw_protocol_http_redirectP11nw_endpointP20nw_protocol_metadatab_block_invoke_4(uint64_t a1, char *a2, unint64_t a3, uint64_t a4)
{
  char v7;

  if (!*(_BYTE *)(a1 + 56)
    || (a3 < 9 || strncasecmp(a2, "content-", 8uLL)) && strcasecmp(a2, "digest") && strcasecmp(a2, "Last-Modified"))
  {
    if ((v7 = *(_BYTE *)(*(_QWORD *)(a1 + 48) + 692), (v7 & 2) != 0)
      && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
      || strcasecmp(a2, "Cookie"))
    {
      if (strcasecmp(a2, "Authorization")
        && strcasecmp(a2, "Proxy-Authorization")
        && ((v7 & 4) != 0 || strcasecmp(a2, "Accept-Encoding"))
        && (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) || strcasecmp(a2, "Origin")))
      {
        nw_http_fields_append(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), (uint64_t)a2, a4);
      }
    }
  }
  return 1;
}

uint64_t ___ZL24nw_http_redirect_processP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  void (*v5)(uint64_t, void *, void *, void *);
  void *v6;
  uint64_t v7;

  v1 = *(_QWORD *)(a1 + 48);
  v3 = MEMORY[0x1E0C809B0];
  v4 = 0x40000000;
  v5 = ___ZL24nw_http_redirect_processP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke_2;
  v6 = &__block_descriptor_tmp_19;
  v7 = v1;
  return (*(uint64_t (**)(void))(*(_QWORD *)(v1 + 592) + 16))();
}

void nw_http_redirect_reissue(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  NSObject *v9;
  int v10;
  void *parameters;
  void *v12;
  int v13;
  uint64_t v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  const char *v19;
  char *v20;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  char *v31;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  char v36;
  os_log_type_t type;
  _QWORD v38[5];
  _QWORD v39[7];
  _QWORD v40[6];
  _QWORD v41[5];
  void *v42;
  char v43;
  int v44;
  const char *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  char *v53;
  _BYTE buf[24];
  uint64_t (*v55)(uint64_t, uint64_t);
  void (*v56)(uint64_t);
  void *v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
    v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v41[0]) = 16;
    LOBYTE(v44) = 0;
    if (!__nwlog_fault(v25, v41, &v44))
      goto LABEL_88;
    if (LOBYTE(v41[0]) == 17)
    {
      v26 = __nwlog_obj();
      v27 = v41[0];
      if (!os_log_type_enabled(v26, v41[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null http_redirect";
    }
    else if ((_BYTE)v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = v41[0];
      v30 = os_log_type_enabled(v26, v41[0]);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null http_redirect, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_88:
        if (!v25)
          return;
        goto LABEL_89;
      }
      if (!v30)
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null http_redirect, no backtrace";
    }
    else
    {
      v26 = __nwlog_obj();
      v27 = v41[0];
      if (!os_log_type_enabled(v26, v41[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null http_redirect, backtrace limit exceeded";
    }
    goto LABEL_87;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
    v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v41[0]) = 16;
    LOBYTE(v44) = 0;
    if (!__nwlog_fault(v25, v41, &v44))
      goto LABEL_88;
    if (LOBYTE(v41[0]) != 17)
    {
      if (!(_BYTE)v44)
      {
        v26 = __nwlog_obj();
        v27 = v41[0];
        if (!os_log_type_enabled(v26, v41[0]))
          goto LABEL_88;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
        v28 = "%{public}s called with null endpoint, backtrace limit exceeded";
        goto LABEL_87;
      }
      v31 = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = v41[0];
      v32 = os_log_type_enabled(v26, v41[0]);
      if (!v31)
      {
        if (!v32)
          goto LABEL_88;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
        v28 = "%{public}s called with null endpoint, no backtrace";
        goto LABEL_87;
      }
      if (!v32)
        goto LABEL_69;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v31;
      v33 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
      goto LABEL_68;
    }
    v26 = __nwlog_obj();
    v27 = v41[0];
    if (!os_log_type_enabled(v26, v41[0]))
      goto LABEL_88;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
    v28 = "%{public}s called with null endpoint";
LABEL_87:
    _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
    goto LABEL_88;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
    v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v41[0]) = 16;
    LOBYTE(v44) = 0;
    if (!__nwlog_fault(v25, v41, &v44))
      goto LABEL_88;
    if (LOBYTE(v41[0]) == 17)
    {
      v26 = __nwlog_obj();
      v27 = v41[0];
      if (!os_log_type_enabled(v26, v41[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null orig_request_metadata";
      goto LABEL_87;
    }
    if (!(_BYTE)v44)
    {
      v26 = __nwlog_obj();
      v27 = v41[0];
      if (!os_log_type_enabled(v26, v41[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null orig_request_metadata, backtrace limit exceeded";
      goto LABEL_87;
    }
    v31 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = v41[0];
    v34 = os_log_type_enabled(v26, v41[0]);
    if (!v31)
    {
      if (!v34)
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null orig_request_metadata, no backtrace";
      goto LABEL_87;
    }
    if (!v34)
      goto LABEL_69;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v31;
    v33 = "%{public}s called with null orig_request_metadata, dumping backtrace:%{public}s";
LABEL_68:
    _os_log_impl(&dword_182FBE000, v26, v27, v33, buf, 0x16u);
    goto LABEL_69;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
    v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v41[0]) = 16;
    LOBYTE(v44) = 0;
    if (!__nwlog_fault(v25, v41, &v44))
      goto LABEL_88;
    if (LOBYTE(v41[0]) == 17)
    {
      v26 = __nwlog_obj();
      v27 = v41[0];
      if (!os_log_type_enabled(v26, v41[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null _request_metadata";
      goto LABEL_87;
    }
    if (!(_BYTE)v44)
    {
      v26 = __nwlog_obj();
      v27 = v41[0];
      if (!os_log_type_enabled(v26, v41[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null _request_metadata, backtrace limit exceeded";
      goto LABEL_87;
    }
    v31 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = v41[0];
    v35 = os_log_type_enabled(v26, v41[0]);
    if (!v31)
    {
      if (!v35)
        goto LABEL_88;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      v28 = "%{public}s called with null _request_metadata, no backtrace";
      goto LABEL_87;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v31;
      v33 = "%{public}s called with null _request_metadata, dumping backtrace:%{public}s";
      goto LABEL_68;
    }
LABEL_69:
    free(v31);
    if (!v25)
      return;
LABEL_89:
    free(v25);
    return;
  }
  if ((*(_BYTE *)(a1 + 198) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)(a1 + 688);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http_redirect_reissue";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 114;
      *(_WORD *)&buf[22] = 2080;
      v55 = (uint64_t (*)(uint64_t, uint64_t))" ";
      LOWORD(v56) = 1024;
      *(_DWORD *)((char *)&v56 + 2) = v10;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%staking redirect, remaining limit %u", buf, 0x26u);
    }
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3802000000;
  v55 = __Block_byref_object_copy__14_933;
  v56 = __Block_byref_object_dispose__15_934;
  parameters = (void *)nw_protocol_get_parameters(a1);
  if (parameters)
    parameters = os_retain(parameters);
  v57 = parameters;
  v58 |= 1u;
  nw_http_messaging_options_create_transaction_in_parameters(*(void **)(*(_QWORD *)&buf[8] + 40), a1, 1);
  nw_protocol_plugin_metadata_prepare_for_reissue(a1 + 200);
  v41[0] = 0;
  v41[1] = v41;
  v41[2] = 0x3802000000;
  v41[3] = __Block_byref_object_copy__12;
  v41[4] = __Block_byref_object_dispose__13;
  v42 = os_retain(a5);
  v43 |= 1u;
  v12 = *(void **)(a1 + 672);
  v39[6] = a1;
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke;
  v40[3] = &unk_1E149A390;
  v40[4] = v41;
  v40[5] = a1;
  v38[4] = a1;
  v39[0] = MEMORY[0x1E0C809B0];
  v39[1] = 0x40000000;
  v39[2] = ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke_2;
  v39[3] = &unk_1E149A3E0;
  v39[4] = buf;
  v39[5] = v41;
  v38[0] = MEMORY[0x1E0C809B0];
  v38[1] = 0x40000000;
  v38[2] = ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke_4;
  v38[3] = &__block_descriptor_tmp_47;
  nw_protocol_plugin_retry_reissue_output_frames(a1 + 344, a1, v12, a2, a3, 2, 1, v40, v39, (uint64_t)v38);
  v13 = *(_DWORD *)(a1 + 688);
  *(_DWORD *)(a1 + 688) = v13 - 1;
  if (v13)
    goto LABEL_28;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = *(unsigned int *)(a1 + 688);
  v44 = 136446978;
  v45 = "nw_http_redirect_reissue";
  v46 = 2082;
  v47 = "http_redirect->limit";
  v48 = 2048;
  v49 = 1;
  v50 = 2048;
  v51 = v14;
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v36 = 0;
  if (__nwlog_fault(v15, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v18 = *(unsigned int *)(a1 + 688);
        v44 = 136446978;
        v45 = "nw_http_redirect_reissue";
        v46 = 2082;
        v47 = "http_redirect->limit";
        v48 = 2048;
        v49 = 1;
        v50 = 2048;
        v51 = v18;
        v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_24:
        _os_log_impl(&dword_182FBE000, v16, v17, v19, (uint8_t *)&v44, 0x2Au);
      }
    }
    else if (v36)
    {
      v20 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v20)
      {
        if (v21)
        {
          v22 = *(unsigned int *)(a1 + 688);
          v44 = 136447234;
          v45 = "nw_http_redirect_reissue";
          v46 = 2082;
          v47 = "http_redirect->limit";
          v48 = 2048;
          v49 = 1;
          v50 = 2048;
          v51 = v22;
          v52 = 2082;
          v53 = v20;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", (uint8_t *)&v44, 0x34u);
        }
        free(v20);
        goto LABEL_25;
      }
      if (v21)
      {
        v24 = *(unsigned int *)(a1 + 688);
        v44 = 136446978;
        v45 = "nw_http_redirect_reissue";
        v46 = 2082;
        v47 = "http_redirect->limit";
        v48 = 2048;
        v49 = 1;
        v50 = 2048;
        v51 = v24;
        v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
        goto LABEL_24;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v23 = *(unsigned int *)(a1 + 688);
        v44 = 136446978;
        v45 = "nw_http_redirect_reissue";
        v46 = 2082;
        v47 = "http_redirect->limit";
        v48 = 2048;
        v49 = 1;
        v50 = 2048;
        v51 = v23;
        v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
LABEL_25:
  if (v15)
    free(v15);
  *(_DWORD *)(a1 + 688) = 0;
LABEL_28:
  _Block_object_dispose(v41, 8);
  if ((v43 & 1) != 0 && v42)
    os_release(v42);
  _Block_object_dispose(buf, 8);
  if ((v58 & 1) != 0)
  {
    if (v57)
      os_release(v57);
  }
}

uint64_t __Block_byref_object_copy__14_933(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__15_934(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

uint64_t ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke(uint64_t a1, uint64_t *a2)
{
  nw_frame_set_metadata(*a2, *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), 0, (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 692) & 8) == 0);
  return 1;
}

uint64_t ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke_2(_QWORD *a1)
{
  id v2;
  char *identifier;
  uint64_t v4;
  unsigned __int8 *v5;
  void *v6;
  _BOOL8 v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[5];

  if (nw_protocol_copy_http_client_definition_onceToken != -1)
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_52_74156);
  v2 = (id)nw_protocol_copy_http_client_definition_definition;
  identifier = nw_protocol_definition_get_identifier(v2);
  if (v2)
    os_release(v2);
  v4 = a1[6];
  do
  {
    v4 = *(_QWORD *)(v4 + 48);
    if (!v4)
      return 1;
  }
  while (!nw_protocols_are_equal(*(_QWORD **)(v4 + 16), identifier));
  v5 = nw_parameters_copy_protocol_options_legacy(*(void **)(*(_QWORD *)(a1[4] + 8) + 40), (nw_protocol *)v4);
  v6 = nw_http_client_options_copy_resend_handler(v5);
  v7 = v6 == 0;
  if (v6)
  {
    v8 = v6;
    v9 = a1[5];
    v10 = *(_QWORD *)(a1[4] + 8);
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke_3;
    v12[3] = &unk_1E149A3B8;
    v12[4] = v9;
    (*((void (**)(void *, _QWORD, _QWORD *))v6 + 2))(v6, *(_QWORD *)(v10 + 40), v12);
    _Block_release(v8);
  }
  if (v5)
    os_release(v5);
  return v7;
}

void ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke_4(uint64_t a1)
{
  nw_http_redirect_destroy(*(_QWORD *)(a1 + 32));
}

void nw_http_redirect_destroy(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  const void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  NSObject *v14;
  int v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v15 = 136446722;
        v16 = "nw_http_redirect_destroy";
        v17 = 2082;
        v18 = a1 + 114;
        v19 = 2080;
        v20 = " ";
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", (uint8_t *)&v15, 0x20u);
      }
    }
  }
  if (*(_DWORD *)(a1 + 552))
  {
    *(_BYTE *)(a1 + 556) |= 0x40u;
    if ((*(_BYTE *)(a1 + 198) & 1) == 0 && gLogDatapath)
    {
      v2 = __nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        v15 = 136446722;
        v16 = "nw_http_redirect_destroy";
        v17 = 2082;
        v18 = a1 + 114;
        v19 = 2080;
        v20 = " ";
        _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sdeferring destroy because the request is being reissued", (uint8_t *)&v15, 0x20u);
      }
    }
  }
  else
  {
    if ((*(_BYTE *)(a1 + 680) & 1) != 0)
    {
      v3 = *(void **)(a1 + 672);
      if (v3)
        os_release(v3);
    }
    *(_QWORD *)(a1 + 672) = 0;
    if ((*(_BYTE *)(a1 + 664) & 1) != 0)
    {
      v4 = *(void **)(a1 + 656);
      if (v4)
        os_release(v4);
    }
    *(_QWORD *)(a1 + 656) = 0;
    if ((*(_BYTE *)(a1 + 648) & 1) != 0)
    {
      v5 = *(void **)(a1 + 640);
      if (v5)
        os_release(v5);
    }
    *(_QWORD *)(a1 + 640) = 0;
    if ((*(_BYTE *)(a1 + 632) & 1) != 0)
    {
      v6 = *(void **)(a1 + 624);
      if (v6)
        os_release(v6);
    }
    *(_QWORD *)(a1 + 624) = 0;
    if ((*(_BYTE *)(a1 + 616) & 1) != 0)
    {
      v7 = *(NSObject **)(a1 + 608);
      if (v7)
        dispatch_release(v7);
    }
    *(_QWORD *)(a1 + 608) = 0;
    if ((*(_BYTE *)(a1 + 600) & 1) != 0)
    {
      v8 = *(const void **)(a1 + 592);
      if (v8)
        _Block_release(v8);
    }
    *(_QWORD *)(a1 + 592) = 0;
    if ((*(_BYTE *)(a1 + 584) & 1) != 0)
    {
      v9 = *(void **)(a1 + 576);
      if (v9)
        os_release(v9);
    }
    *(_QWORD *)(a1 + 576) = 0;
    if ((*(_BYTE *)(a1 + 568) & 1) != 0)
    {
      v10 = *(void **)(a1 + 560);
      if (v10)
        os_release(v10);
    }
    *(_QWORD *)(a1 + 560) = 0;
    nw_protocol_plugin_retry::~nw_protocol_plugin_retry((nw_protocol_plugin_retry *)(a1 + 344));
    if ((*(_BYTE *)(a1 + 288) & 1) != 0)
    {
      v11 = *(void **)(a1 + 280);
      if (v11)
        os_release(v11);
    }
    *(_QWORD *)(a1 + 280) = 0;
    if ((*(_BYTE *)(a1 + 272) & 1) != 0)
    {
      v12 = *(void **)(a1 + 264);
      if (v12)
        os_release(v12);
    }
    *(_QWORD *)(a1 + 264) = 0;
    if ((*(_BYTE *)(a1 + 256) & 1) != 0)
    {
      v13 = *(void **)(a1 + 248);
      if (v13)
        os_release(v13);
    }
    free((void *)a1);
  }
}

void ___ZL24nw_http_redirect_reissueP25nw_protocol_http_redirectP11nw_endpointP13nw_parametersP20nw_protocol_metadataS6__block_invoke_3(uint64_t a1, nw_content_context_t context)
{
  nw_content_context_set_metadata_for_protocol(context, *(nw_protocol_metadata_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
}

void ___ZL24nw_http_redirect_processP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke_2(uint64_t a1, void *object, void *a3, void *a4)
{
  void *v7;
  char v8;
  void *v9;
  char v10;
  void *v11;
  char v12;
  uint64_t v13;
  void *v14;
  _QWORD v15[8];
  _QWORD v16[5];
  void *objecta;
  char v18;
  _QWORD v19[5];
  void *v20;
  char v21;
  _QWORD v22[5];
  void *v23;
  char v24;

  v22[0] = 0;
  v22[1] = v22;
  v22[2] = 0x3802000000;
  v22[3] = __Block_byref_object_copy__927;
  v22[4] = __Block_byref_object_dispose__928;
  if (object)
  {
    v7 = os_retain(object);
    v8 = v24 | 1;
  }
  else
  {
    v7 = 0;
    v8 = -1;
  }
  v23 = v7;
  v24 = v8;
  v19[0] = 0;
  v19[1] = v19;
  v19[2] = 0x3802000000;
  v19[3] = __Block_byref_object_copy__14_933;
  v19[4] = __Block_byref_object_dispose__15_934;
  if (a3)
  {
    v9 = os_retain(a3);
    v10 = v21 | 1;
  }
  else
  {
    v9 = 0;
    v10 = -1;
  }
  v20 = v9;
  v21 = v10;
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x3802000000;
  v16[3] = __Block_byref_object_copy__12;
  v16[4] = __Block_byref_object_dispose__13;
  if (a4)
  {
    v11 = os_retain(a4);
    v12 = v18 | 1;
  }
  else
  {
    v11 = 0;
    v12 = -1;
  }
  objecta = v11;
  v18 = v12;
  v13 = *(_QWORD *)(a1 + 32);
  v14 = *(void **)(v13 + 672);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = ___ZL24nw_http_redirect_processP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke_16;
  v15[3] = &unk_1E149A230;
  v15[4] = v16;
  v15[5] = v22;
  v15[6] = v19;
  v15[7] = v13;
  nw_queue_context_async_if_needed(v14, v15);
  _Block_object_dispose(v16, 8);
  if ((v18 & 1) != 0 && objecta)
    os_release(objecta);
  _Block_object_dispose(v19, 8);
  if ((v21 & 1) != 0 && v20)
    os_release(v20);
  _Block_object_dispose(v22, 8);
  if ((v24 & 1) != 0)
  {
    if (v23)
      os_release(v23);
  }
}

void ___ZL24nw_http_redirect_processP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke_16(_QWORD *a1)
{
  uint64_t v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  NSObject *v9;
  _BOOL4 v10;
  NSObject *v11;
  _BOOL4 v12;
  int v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (nw_protocol_plugin_retry_end_async(a1[7] + 344))
  {
    v2 = a1[7];
    if (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 40))
    {
      if ((*(_BYTE *)(v2 + 198) & 1) == 0)
      {
        if (gLogDatapath)
        {
          v9 = __nwlog_obj();
          v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
          v2 = a1[7];
          if (v10)
          {
            v13 = 136446722;
            v14 = "nw_http_redirect_process_block_invoke";
            v15 = 2082;
            v16 = v2 + 114;
            v17 = 2080;
            v18 = " ";
            _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sReceived new request metadata from redirect handler", (uint8_t *)&v13, 0x20u);
            v2 = a1[7];
          }
        }
      }
      nw_protocol_plugin_metadata_resume_input(v2 + 200, 3);
      v3 = nw_context_copy_registered_endpoint(*(void **)(a1[7] + 672), *(void **)(*(_QWORD *)(a1[5] + 8) + 40));
      nw_http_redirect_reissue(a1[7], v3, *(void **)(*(_QWORD *)(a1[6] + 8) + 40), *(_QWORD *)(a1[7] + 560), *(void **)(*(_QWORD *)(a1[4] + 8) + 40));
      if (v3)
        os_release(v3);
    }
    else
    {
      v5 = *(_QWORD *)(v2 + 48);
      if (v5)
      {
        v6 = *(_QWORD *)(v5 + 24);
        if (v6)
        {
          if (*(_QWORD *)(v6 + 64))
          {
            if ((*(_BYTE *)(v2 + 198) & 1) == 0)
            {
              if (gLogDatapath)
              {
                v11 = __nwlog_obj();
                v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
                v2 = a1[7];
                if (v12)
                {
                  v13 = 136446722;
                  v14 = "nw_http_redirect_process_block_invoke";
                  v15 = 2082;
                  v16 = v2 + 114;
                  v17 = 2080;
                  v18 = " ";
                  _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sReceived no request metadata from redirect handler", (uint8_t *)&v13, 0x20u);
                  v2 = a1[7];
                }
              }
            }
            nw_protocol_plugin_metadata_resume_input(v2 + 200, 1);
            *(_BYTE *)(a1[7] + 692) &= ~0x10u;
            nw_protocol_input_available(*(_QWORD **)(a1[7] + 48), a1[7]);
          }
        }
      }
    }
  }
  else
  {
    v4 = a1[7];
    if ((*(_BYTE *)(v4 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v7 = __nwlog_obj();
        v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
        v4 = a1[7];
        if (v8)
        {
          v13 = 136446722;
          v14 = "nw_http_redirect_process_block_invoke";
          v15 = 2082;
          v16 = v4 + 114;
          v17 = 2080;
          v18 = " ";
          _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDeferred destroy when coming back from callout", (uint8_t *)&v13, 0x20u);
          v4 = a1[7];
        }
      }
    }
    nw_http_redirect_destroy(v4);
  }
}

uint64_t __Block_byref_object_copy__23(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__24(uint64_t a1)
{
  const void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(const void **)(a1 + 40);
    if (v2)
      CFRelease(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZL30nw_http_redirect_copy_endpointP25nw_protocol_http_redirectP20nw_protocol_metadata_block_invoke_25(uint64_t a1, char *__s)
{
  CFIndex v4;
  CFURLRef v5;
  uint64_t v6;
  char v7;
  const void *v8;

  v4 = strlen(__s);
  v5 = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)__s, v4, 0x600u, *(CFURLRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), 0);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v7 = *(_BYTE *)(v6 + 48);
  if ((v7 & 1) != 0)
  {
    v8 = *(const void **)(v6 + 40);
    if (v8)
    {
      CFRelease(v8);
      v7 = *(_BYTE *)(v6 + 48);
    }
  }
  *(_QWORD *)(v6 + 40) = v5;
  *(_BYTE *)(v6 + 48) = v7 | 1;
}

void ___ZL39nw_protocol_http_redirect_get_callbacksv_block_invoke()
{
  qword_1EDCE4468 = (uint64_t)nw_protocol_common_get_input_frames;
  unk_1EDCE4470 = nw_protocol_common_get_output_frames;
  qword_1EDCE4488 = (uint64_t)nw_protocol_common_get_parameters;
  unk_1EDCE4490 = nw_protocol_common_get_path;
  qword_1EDCE4498 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_1EDCE44A0 = nw_protocol_common_get_remote_endpoint;
  qword_1EDCE4428 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_1EDCE4430 = nw_protocol_common_connect;
  qword_1EDCE4438 = (uint64_t)nw_protocol_common_disconnect;
  unk_1EDCE4440 = nw_protocol_common_connected;
  qword_1EDCE4458 = (uint64_t)nw_protocol_common_input_available;
  unk_1EDCE4460 = nw_protocol_common_output_available;
  qword_1EDCE44D8 = (uint64_t)nw_protocol_common_output_finished;
  unk_1EDCE44E0 = nw_protocol_common_get_output_local_endpoint;
  qword_1EDCE4520 = (uint64_t)nw_protocol_common_input_flush;
  qword_1EDCE4448 = (uint64_t)nw_protocol_common_disconnected;
  unk_1EDCE4450 = nw_protocol_common_error;
  qword_1EDCE4510 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_1EDCE4518 = nw_protocol_common_reset;
  qword_1EDCE44F8 = (uint64_t)nw_protocol_common_copy_info;
  qword_1EDCE44C8 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_1EDCE44D0 = nw_protocol_common_input_finished;
  qword_1EDCE44E8 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_1EDCE44F0 = nw_protocol_common_waiting_for_output;
  qword_1EDCE44A8 = (uint64_t)nw_protocol_common_register_notification;
  unk_1EDCE44B0 = nw_protocol_common_unregister_notification;
  qword_1EDCE44B8 = (uint64_t)nw_protocol_common_notify;
  unk_1EDCE44C0 = nw_protocol_common_updated_path;
  qword_1EDCE4478 = (uint64_t)nw_protocol_common_finalize_output_frames;
  unk_1EDCE4480 = nw_protocol_common_link_state;
  nw_protocol_http_redirect_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  unk_1EDCE4420 = nw_protocol_http_redirect_remove_input_handler;
}

uint64_t nw_protocol_http_redirect_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  void *handle;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  const char *v11;
  _BOOL4 v12;
  _QWORD v13[5];
  char v14;
  _QWORD v15[5];
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 0x40000000;
      v15[2] = ___ZL46nw_protocol_http_redirect_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v15[3] = &__block_descriptor_tmp_51;
      v15[4] = handle;
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 0x40000000;
      v13[2] = ___ZL46nw_protocol_http_redirect_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
      v13[3] = &__block_descriptor_tmp_52;
      v14 = a3;
      v13[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v15, (uint64_t)v13);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http_redirect_remove_input_handler";
    v5 = (char *)_os_log_send_and_compose_impl();
    v17 = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v5, &v17, &v16))
      goto LABEL_32;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_redirect_remove_input_handler";
        v8 = "%{public}s called with null http_redirect";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v16)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_redirect_remove_input_handler";
        v8 = "%{public}s called with null http_redirect, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = v17;
    v12 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_redirect_remove_input_handler";
        v8 = "%{public}s called with null http_redirect, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_http_redirect_remove_input_handler";
      v20 = 2082;
      v21 = backtrace_string;
      v11 = "%{public}s called with null http_redirect, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_http_redirect_remove_input_handler";
  v5 = (char *)_os_log_send_and_compose_impl();
  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v5, &v17, &v16))
    goto LABEL_32;
  if (v17 != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_redirect_remove_input_handler";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = v17;
    v10 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_redirect_remove_input_handler";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_http_redirect_remove_input_handler";
      v20 = 2082;
      v21 = backtrace_string;
      v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v6, v7, v11, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v6 = __nwlog_obj();
  v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http_redirect_remove_input_handler";
    v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
  }
LABEL_32:
  if (v5)
    free(v5);
  return 0;
}

void ___ZL46nw_protocol_http_redirect_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  const void *v5;
  char v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (gLogDatapath)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      v9 = 136446210;
      v10 = "nw_protocol_plugin_metadata_teardown";
      _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v9, 0xCu);
    }
  }
  nw_protocol_plugin_metadata_reset((uint64_t *)(v2 + 200));
  *(_QWORD *)(v2 + 328) = 0;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_BYTE *)(v3 + 464);
  if ((v4 & 1) != 0)
  {
    v5 = *(const void **)(v3 + 456);
    if (v5)
    {
      _Block_release(v5);
      v4 = *(_BYTE *)(v3 + 464);
    }
  }
  *(_QWORD *)(v3 + 456) = 0;
  *(_BYTE *)(v3 + 464) = v4 | 1;
  v6 = *(_BYTE *)(v3 + 512);
  if ((v6 & 1) != 0)
  {
    v7 = *(const void **)(v3 + 504);
    if (v7)
    {
      _Block_release(v7);
      v6 = *(_BYTE *)(v3 + 512);
    }
  }
  *(_QWORD *)(v3 + 504) = 0;
  *(_BYTE *)(v3 + 512) = v6 | 1;
}

void ___ZL46nw_protocol_http_redirect_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
    nw_http_redirect_destroy(*(_QWORD *)(a1 + 32));
}

double __nw_protocol_http_redirect_identifier_block_invoke()
{
  double result;

  strcpy((char *)nw_protocol_http_redirect_identifier::protocol_identifier, "http_redirect");
  *(_QWORD *)&result = 0x100000005;
  qword_1EDCE3928 = 0x100000005;
  return result;
}

void nw_context_dealloc(NWConcrete_nw_context *a1, int a2)
{
  NWConcrete_nw_context *v3;
  NWConcrete_nw_context *v4;
  NSObject *v5;
  void *v6;
  _BYTE *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  NWConcrete_nw_context *v18;
  uint64_t v19;
  NWConcrete_nw_context *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  char *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  os_unfair_lock_s *v32;
  char *v33;
  uint64_t v34;
  os_unfair_lock_s *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  unint64_t *v46;
  __uint64_t v47;
  unint64_t v48;
  char v49;
  __uint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  char v53;
  void *v54;
  char *v55;
  NSObject *v56;
  os_log_type_t v57;
  void *v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  char *backtrace_string;
  os_log_type_t v63;
  _BOOL4 v64;
  char *v65;
  os_log_type_t v66;
  _BOOL4 v67;
  os_log_type_t v68;
  os_log_type_t v69;
  unint64_t v70;
  _QWORD v71[4];
  _BYTE *v72;
  char v73;
  os_log_type_t type;
  __uint64_t v75;
  uint8_t buf[4];
  const char *v77;
  __int16 v78;
  __uint64_t v79;
  __int16 v80;
  unint64_t v81;
  __int16 v82;
  char *v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3 || *((_DWORD *)v3 + 31) != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      v77 = "nw_context_dealloc";
      v78 = 2114;
      v79 = (__uint64_t)v4;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s Deallocating context %{public}@", buf, 0x16u);
    }

  }
  v75 = 0;
  pthread_threadid_np(0, &v75);
  if (*((_DWORD *)v4 + 30) == 4)
  {
    v46 = (unint64_t *)((char *)v4 + 112);
    v47 = v75;
    while (1)
    {
      v48 = __ldaxr(v46);
      if (v48)
        break;
      if (!__stlxr(v47, v46))
      {
        v49 = 1;
        goto LABEL_77;
      }
    }
    v49 = 0;
    __clrex();
LABEL_77:
    if ((v49 & 1) == 0)
    {
      __nwlog_obj();
      v54 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446722;
      v77 = "nw_context_dealloc";
      v78 = 2048;
      v79 = v75;
      v80 = 2048;
      v70 = v48;
      v81 = v48;
      v55 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v73 = 0;
      if (__nwlog_fault(v55, &type, &v73))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v56 = objc_claimAutoreleasedReturnValue();
          v57 = type;
          if (os_log_type_enabled(v56, type))
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v70;
            _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu", buf, 0x20u);
          }
        }
        else if (v73)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v56 = objc_claimAutoreleasedReturnValue();
          v63 = type;
          v64 = os_log_type_enabled(v56, type);
          if (backtrace_string)
          {
            if (v64)
            {
              *(_DWORD *)buf = 136446978;
              v77 = "nw_context_dealloc";
              v78 = 2048;
              v79 = v75;
              v80 = 2048;
              v81 = v70;
              v82 = 2082;
              v83 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v56, v63, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(backtrace_string);
            goto LABEL_109;
          }
          if (v64)
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v70;
            _os_log_impl(&dword_182FBE000, v56, v63, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          __nwlog_obj();
          v56 = objc_claimAutoreleasedReturnValue();
          v68 = type;
          if (os_log_type_enabled(v56, type))
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v70;
            _os_log_impl(&dword_182FBE000, v56, v68, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, backtrace limit exceeded", buf, 0x20u);
          }
        }

      }
LABEL_109:
      if (v55)
        free(v55);
    }
  }
  v6 = (void *)*((_QWORD *)v4 + 5);
  if (v6)
  {
    v7 = v6;
    v8 = v7;
    if ((v7[136] & 8) != 0)
    {
      nw_context_purge_all_endpoints(v7);
    }
    else
    {
      v71[0] = MEMORY[0x1E0C809B0];
      v71[1] = 3221225472;
      v71[2] = ___ZL18nw_context_deallocP21NWConcrete_nw_contextb_block_invoke;
      v71[3] = &unk_1E14ACFD0;
      v72 = v7;
      nw_queue_context_async(v72, v71);

    }
    if (a2)
    {
      v9 = v8[4];
      if (v9)
      {
        v10 = *(_QWORD *)(v9 + 68);
        if (v10)
        {
          nw_path_release_globals(v10, 0);
          v9 = v8[4];
          v11 = *(void **)(v9 + 68);
          if (v11)
          {
            free(v11);
            *(_QWORD *)(v8[4] + 68) = 0;
            v9 = v8[4];
          }
        }
        v12 = *(_QWORD **)(v9 + 180);
        if (v12)
        {
          nw_mem_buffer_manager_close(v12);
          *(_QWORD *)(v8[4] + 180) = 0;
          v9 = v8[4];
        }
        v13 = *(_QWORD **)(v9 + 172);
        if (v13)
        {
          nw_mem_buffer_manager_close(v13);
          *(_QWORD *)(v8[4] + 172) = 0;
          v9 = v8[4];
        }
        v14 = *(_QWORD **)(v9 + 164);
        if (v14)
        {
          nw_mem_buffer_manager_close(v14);
          *(_QWORD *)(v8[4] + 164) = 0;
          v9 = v8[4];
        }
        v15 = *(_QWORD **)(v9 + 156);
        if (v15)
        {
          nw_mem_buffer_manager_close(v15);
          *(_QWORD *)(v8[4] + 156) = 0;
          v9 = v8[4];
        }
        v16 = *(_QWORD **)(v9 + 148);
        if (v16)
        {
          nw_mem_buffer_manager_close(v16);
          *(_QWORD *)(v8[4] + 148) = 0;
        }
      }
    }

  }
  v18 = v4;
  v19 = *((_QWORD *)v18 + 3);
  if (v19)
  {
    if (*(_QWORD *)(v19 + 56))
    {
      nw_queue_cancel_source(*(_QWORD *)(v19 + 56), v17);
      *(_QWORD *)(*((_QWORD *)v18 + 3) + 56) = 0;
      v19 = *((_QWORD *)v18 + 3);
    }
    if (*(_QWORD *)(v19 + 32))
    {
      _nw_hash_table_release(*(os_unfair_lock_s **)(v19 + 32), v17);
      *(_QWORD *)(*((_QWORD *)v18 + 3) + 32) = 0;
      v19 = *((_QWORD *)v18 + 3);
    }
    if (*(_QWORD *)(v19 + 40))
    {
      _nw_hash_table_release(*(os_unfair_lock_s **)(v19 + 40), v17);
      *(_QWORD *)(*((_QWORD *)v18 + 3) + 40) = 0;
      v19 = *((_QWORD *)v18 + 3);
    }
    if (!*(_QWORD *)(v19 + 48)
      || (_nw_hash_table_release(*(os_unfair_lock_s **)(v19 + 48), v17),
          *(_QWORD *)(*((_QWORD *)v18 + 3) + 48) = 0,
          (v19 = *((_QWORD *)v18 + 3)) != 0))
    {
      free((void *)v19);
      *((_QWORD *)v18 + 3) = 0;
    }
  }

  v20 = v18;
  v21 = *((_QWORD *)v20 + 4);
  if (v21)
  {
    v22 = *(void **)(v21 + 84);
    *(_QWORD *)(v21 + 84) = 0;

    v24 = (char *)v20 + 32;
    v23 = *((_QWORD *)v20 + 4);
    v25 = *(void **)(v23 + 92);
    *(_QWORD *)(v23 + 92) = 0;

    v26 = *(void **)(*((_QWORD *)v20 + 4) + 100);
    *(_QWORD *)(*(_QWORD *)v24 + 100) = 0;

    v27 = *(void **)(*((_QWORD *)v20 + 4) + 108);
    *(_QWORD *)(*(_QWORD *)v24 + 108) = 0;

    v28 = *(void **)(*((_QWORD *)v20 + 4) + 116);
    *(_QWORD *)(*(_QWORD *)v24 + 116) = 0;

    v29 = *(void **)(*((_QWORD *)v20 + 4) + 124);
    *(_QWORD *)(*(_QWORD *)v24 + 124) = 0;

    v31 = *((_QWORD *)v20 + 4);
    if (*(_QWORD *)v31)
    {
      nw_queue_cancel_source(*(_QWORD *)v31, v30);
      **((_QWORD **)v20 + 4) = 0;
      v31 = *((_QWORD *)v20 + 4);
    }
    v32 = *(os_unfair_lock_s **)(v31 + 24);
    if (v32)
    {
      _nw_hash_table_release(v32, v30);
      *(_QWORD *)(*((_QWORD *)v20 + 4) + 24) = 0;
      v31 = *((_QWORD *)v20 + 4);
    }
    v33 = *(char **)(v31 + 52);
    if (v33)
    {
      nw_hash_table_apply(v33, (uint64_t)&__block_literal_global_116);
      v31 = *((_QWORD *)v20 + 4);
      v35 = *(os_unfair_lock_s **)(v31 + 52);
      if (v35)
      {
        _nw_hash_table_release(v35, v34);
        *(_QWORD *)(*((_QWORD *)v20 + 4) + 52) = 0;
        v31 = *((_QWORD *)v20 + 4);
      }
    }
    v36 = *(_QWORD *)(v31 + 60);
    if (v36)
    {
      if (*(_QWORD *)v36)
      {
        os_release(*(void **)v36);
        *(_QWORD *)v36 = 0;
      }
      v37 = *(void **)(v36 + 8);
      if (v37)
      {
        os_release(v37);
        *(_QWORD *)(v36 + 8) = 0;
      }
      v31 = *((_QWORD *)v20 + 4);
      v38 = *(void **)(v31 + 60);
      if (v38)
      {
        free(v38);
        *(_QWORD *)(*((_QWORD *)v20 + 4) + 60) = 0;
        v31 = *((_QWORD *)v20 + 4);
      }
    }
    v39 = *(_QWORD *)(v31 + 68);
    if (v39)
    {
      nw_path_release_globals(v39, 0);
      v31 = *((_QWORD *)v20 + 4);
      v40 = *(void **)(v31 + 68);
      if (v40)
      {
        free(v40);
        *(_QWORD *)(*((_QWORD *)v20 + 4) + 68) = 0;
        v31 = *((_QWORD *)v20 + 4);
      }
    }
    v41 = *(_QWORD **)(v31 + 180);
    if (v41)
    {
      nw_mem_buffer_manager_close(v41);
      *(_QWORD *)(*((_QWORD *)v20 + 4) + 180) = 0;
      v31 = *((_QWORD *)v20 + 4);
    }
    v42 = *(_QWORD **)(v31 + 172);
    if (v42)
    {
      nw_mem_buffer_manager_close(v42);
      *(_QWORD *)(*((_QWORD *)v20 + 4) + 172) = 0;
      v31 = *((_QWORD *)v20 + 4);
    }
    v43 = *(_QWORD **)(v31 + 164);
    if (v43)
    {
      nw_mem_buffer_manager_close(v43);
      *(_QWORD *)(*((_QWORD *)v20 + 4) + 164) = 0;
      v31 = *((_QWORD *)v20 + 4);
    }
    v44 = *(_QWORD **)(v31 + 156);
    if (v44)
    {
      nw_mem_buffer_manager_close(v44);
      *(_QWORD *)(*((_QWORD *)v20 + 4) + 156) = 0;
      v31 = *((_QWORD *)v20 + 4);
    }
    v45 = *(_QWORD **)(v31 + 148);
    if (!v45
      || (nw_mem_buffer_manager_close(v45),
          *(_QWORD *)(*((_QWORD *)v20 + 4) + 148) = 0,
          (v31 = *((_QWORD *)v20 + 4)) != 0))
    {

      free((void *)v31);
      *((_QWORD *)v20 + 4) = 0;
    }
  }

  if ((*((_BYTE *)v20 + 136) & 8) != 0)
  {
    v50 = v75;
    v51 = (unint64_t *)((char *)v20 + 112);
    while (1)
    {
      v52 = __ldaxr(v51);
      if (v52 != v50)
        break;
      if (!__stlxr(0, v51))
      {
        v53 = 1;
        goto LABEL_84;
      }
    }
    v53 = 0;
    __clrex();
LABEL_84:
    if ((v53 & 1) == 0)
    {
      __nwlog_obj();
      v58 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446722;
      v77 = "nw_context_dealloc";
      v78 = 2048;
      v79 = v75;
      v80 = 2048;
      v81 = v52;
      v59 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v73 = 0;
      if (__nwlog_fault(v59, &type, &v73))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v60 = objc_claimAutoreleasedReturnValue();
          v61 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v52;
            _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s Exiting call, expected inline TID to be %llu but got %llu", buf, 0x20u);
          }
        }
        else if (v73)
        {
          v65 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v60 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          v67 = os_log_type_enabled(v60, type);
          if (v65)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446978;
              v77 = "nw_context_dealloc";
              v78 = 2048;
              v79 = v75;
              v80 = 2048;
              v81 = v52;
              v82 = 2082;
              v83 = v65;
              _os_log_impl(&dword_182FBE000, v60, v66, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v65);
            goto LABEL_114;
          }
          if (v67)
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v52;
            _os_log_impl(&dword_182FBE000, v60, v66, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          __nwlog_obj();
          v60 = objc_claimAutoreleasedReturnValue();
          v69 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)buf = 136446722;
            v77 = "nw_context_dealloc";
            v78 = 2048;
            v79 = v75;
            v80 = 2048;
            v81 = v52;
            _os_log_impl(&dword_182FBE000, v60, v69, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, backtrace limit exceeded", buf, 0x20u);
          }
        }

      }
LABEL_114:
      if (v59)
        free(v59);
    }
  }

}

void sub_18335C514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void ___ZL18nw_context_deallocP21NWConcrete_nw_contextb_block_invoke(uint64_t a1)
{
  nw_context_purge_all_endpoints(*(void **)(a1 + 32));
}

uint64_t ___ZL26nw_context_dealloc_globalsP21NWConcrete_nw_context_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t *extra;
  uint64_t v5;
  id v6;
  void *v7;
  uint64_t v8;
  void (*v9)(id, uint64_t);
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  os_log_type_t v28;
  os_log_type_t v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  nw_hash_node_get_object(a2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  extra = (uint64_t *)nw_hash_node_get_extra(a2);
  v5 = *extra;
  v6 = v3;
  v7 = v6;
  if (!v6)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_definition_deallocate_globals";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v12, &type, &v30))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v33 = "nw_protocol_definition_deallocate_globals";
          v34 = 2082;
          v35 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v12)
          goto LABEL_5;
LABEL_56:
        free(v12);
        goto LABEL_5;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v27, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  v8 = *((_QWORD *)v6 + 9);
  if (!v8)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_definition_deallocate_globals";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v12, &type, &v30))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null definition->common_state", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v30)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v28, "%{public}s called with null definition->common_state, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null definition->common_state, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_protocol_definition_deallocate_globals";
      v34 = 2082;
      v35 = v22;
      _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null definition->common_state, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  v9 = *(void (**)(id, uint64_t))(v8 + 16);
  if (!v9)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_definition_deallocate_globals";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v12, &type, &v30))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null definition->common_state->deallocate_globals", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v30)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v29, "%{public}s called with null definition->common_state->deallocate_globals, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_definition_deallocate_globals";
        _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null definition->common_state->deallocate_globals, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_protocol_definition_deallocate_globals";
      v34 = 2082;
      v35 = v22;
      _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null definition->common_state->deallocate_globals, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v22);
    if (!v12)
      goto LABEL_5;
    goto LABEL_56;
  }
  v9(v6, v5);
LABEL_5:

  *extra = 0;
  return 1;
}

void sub_18335CC5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_purge_endpoints(NWConcrete_nw_context *a1, int a2)
{
  NWConcrete_nw_context *v3;
  NWConcrete_nw_context *v4;
  NWConcrete_nw_context *v5;
  NWConcrete_nw_context *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  BOOL v16;
  unsigned int v17;
  unsigned int v18;
  NSObject *v19;
  int v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  char *v24;
  NWConcrete_nw_context *v25;
  NWConcrete_nw_context *v26;
  uint64_t v27;
  char *v28;
  NWConcrete_nw_context *v29;
  NWConcrete_nw_context *v30;
  char *v31;
  const void **v32;
  const void **v33;
  uint64_t v34;
  char *v35;
  const void **v36;
  const void **v37;
  char *v38;
  const void **v39;
  const void **v40;
  uint64_t v41;
  char *v42;
  NSObject **v43;
  NSObject **v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  NSObject *v48;
  uint64_t v49;
  NWConcrete_nw_context *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  char *v55;
  NSObject *v56;
  os_log_type_t v57;
  char *v58;
  os_log_type_t v59;
  _BOOL4 v60;
  void *v61;
  NSObject *v62;
  os_log_type_t v63;
  void *v64;
  os_log_type_t v65;
  void *v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  void *v70;
  char *v71;
  NSObject *v72;
  os_log_type_t v73;
  void *v74;
  char *v75;
  NSObject *v76;
  os_log_type_t v77;
  void *v78;
  char *v79;
  NSObject *v80;
  os_log_type_t v81;
  void *v82;
  char *v83;
  NSObject *v84;
  os_log_type_t v85;
  void *v86;
  char *v87;
  NSObject *v88;
  os_log_type_t v89;
  os_log_type_t v90;
  char *backtrace_string;
  os_log_type_t v92;
  _BOOL4 v93;
  os_log_type_t v94;
  _BOOL4 v95;
  char *v96;
  os_log_type_t v97;
  _BOOL4 v98;
  char *v99;
  os_log_type_t v100;
  _BOOL4 v101;
  char *v102;
  os_log_type_t v103;
  _BOOL4 v104;
  char *v105;
  _BOOL4 v106;
  char *v107;
  _BOOL4 v108;
  char *v109;
  _BOOL4 v110;
  os_log_type_t v111;
  os_log_type_t v112;
  os_log_type_t v113;
  os_log_type_t v114;
  os_log_type_t v115;
  NSObject *v116;
  os_log_type_t v117;
  os_log_type_t v118;
  os_log_type_t v119;
  os_log_type_t v120;
  os_log_type_t v121;
  os_log_type_t v122;
  const char *v123;
  uint64_t v124;
  const char *v125;
  NWConcrete_nw_context *v126;
  _QWORD block[5];
  BOOL v128;
  os_log_type_t type[8];
  os_log_type_t *v130;
  uint64_t v131;
  uint64_t v132;
  char v133;
  _BYTE buf[24];
  __int128 v135;
  os_log_type_t *v136;
  const char *v137;
  uint64_t v138;

  v138 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
    v55 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v133 = 0;
    if (!__nwlog_fault(v55, type, &v133))
      goto LABEL_176;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v62 = objc_claimAutoreleasedReturnValue();
      v63 = type[0];
      if (os_log_type_enabled(v62, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v133)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v62 = objc_claimAutoreleasedReturnValue();
      v92 = type[0];
      v93 = os_log_type_enabled(v62, type[0]);
      if (backtrace_string)
      {
        if (v93)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v62, v92, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_176:
        v50 = 0;
        if (!v55)
          goto LABEL_60;
        goto LABEL_182;
      }
      if (v93)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v62, v92, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v62 = objc_claimAutoreleasedReturnValue();
      v111 = type[0];
      if (os_log_type_enabled(v62, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v62, v111, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_176;
  }
  v5 = v3;
  v6 = v5;
  if ((*((_BYTE *)v5 + 136) & 8) == 0)
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v5 + 1));

  if ((*((_BYTE *)v6 + 136) & 0x24) == 0)
  {
    v50 = v4;
    __nwlog_obj();
    v64 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
    v55 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v133 = 0;
    if (!__nwlog_fault(v55, type, &v133))
      goto LABEL_181;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v56 = objc_claimAutoreleasedReturnValue();
      v65 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v56, v65, "%{public}s called with null (context->is_implicit || context->is_isolated_context)", buf, 0xCu);
      }
      goto LABEL_180;
    }
    if (!v133)
    {
      __nwlog_obj();
      v56 = objc_claimAutoreleasedReturnValue();
      v112 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v56, v112, "%{public}s called with null (context->is_implicit || context->is_isolated_context), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_180;
    }
    v58 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v56 = objc_claimAutoreleasedReturnValue();
    v94 = type[0];
    v95 = os_log_type_enabled(v56, type[0]);
    if (!v58)
    {
      if (v95)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v56, v94, "%{public}s called with null (context->is_implicit || context->is_isolated_context), no backtrace", buf, 0xCu);
      }
      goto LABEL_180;
    }
    if (v95)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v58;
      _os_log_impl(&dword_182FBE000, v56, v94, "%{public}s called with null (context->is_implicit || context->is_isolated_context), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_123;
  }
  v7 = *((_QWORD *)v6 + 3);
  if (!*(_QWORD *)(v7 + 32) || !*(_QWORD *)(v7 + 40) || !*(_QWORD *)(v7 + 48))
  {
    v50 = v4;
    __nwlog_obj();
    v54 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
    v55 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v133 = 0;
    if (!__nwlog_fault(v55, type, &v133))
      goto LABEL_181;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v56 = objc_claimAutoreleasedReturnValue();
      v57 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s called with null (context->cache->address_endpoints != NULL && context->cache->host_endpoints != NULL && context->cache->other_endpoints != NULL)", buf, 0xCu);
      }
LABEL_180:

LABEL_181:
      if (!v55)
        goto LABEL_60;
LABEL_182:
      free(v55);
      goto LABEL_60;
    }
    if (!v133)
    {
      __nwlog_obj();
      v56 = objc_claimAutoreleasedReturnValue();
      v90 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v56, v90, "%{public}s called with null (context->cache->address_endpoints != NULL && context->cache->host_endpoints != NULL && context->cache->other_endpoints != NULL), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_180;
    }
    v58 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v56 = objc_claimAutoreleasedReturnValue();
    v59 = type[0];
    v60 = os_log_type_enabled(v56, type[0]);
    if (!v58)
    {
      if (v60)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        _os_log_impl(&dword_182FBE000, v56, v59, "%{public}s called with null (context->cache->address_endpoints != NULL && context->cache->host_endpoints != NULL && context->cache->other_endpoints != NULL), no backtrace", buf, 0xCu);
      }
      goto LABEL_180;
    }
    if (v60)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v58;
      _os_log_impl(&dword_182FBE000, v56, v59, "%{public}s called with null (context->cache->address_endpoints != NULL && context->cache->host_endpoints != NULL && context->cache->other_endpoints != NULL), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_123:

    free(v58);
    if (!v55)
      goto LABEL_60;
    goto LABEL_182;
  }
  v126 = v4;
  if (a2)
  {
    v8 = *(_DWORD *)(v7 + 68);
    if (v8)
    {
      v9 = 0;
      v10 = 0;
LABEL_13:
      if (v10 >= v9)
        v11 = v9;
      else
        v11 = v10;
      if (*((_DWORD *)v6 + 31) != 4)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
        {
          v13 = *(_DWORD *)(*((_QWORD *)v6 + 3) + 68);
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
          *(_WORD *)&buf[12] = 2114;
          *(_QWORD *)&buf[14] = v6;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v135) = v9;
          WORD2(v135) = 1024;
          *(_DWORD *)((char *)&v135 + 6) = v8 - v11;
          WORD5(v135) = 1024;
          HIDWORD(v135) = v13;
          LOWORD(v136) = 1024;
          *(_DWORD *)((char *)&v136 + 2) = v10;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_INFO, "%{public}s Context %{public}@ has more than %u cache entries, purging %u from %u down to %u", buf, 0x2Eu);
        }

        v7 = *((_QWORD *)v6 + 3);
      }
      v14 = **(_QWORD **)(*(_QWORD *)(v7 + 8) + 8);
      if (v14)
      {
        v15 = ~v8 + v11;
        do
        {
          *(_QWORD *)(v14 + 32) = 0;
          v16 = __CFADD__(v15++, 1);
          if (v16)
            break;
          v14 = **(_QWORD **)(*(_QWORD *)(v14 + 8) + 8);
        }
        while (v14);
      }
      goto LABEL_34;
    }
  }
  else
  {
    v9 = *((_DWORD *)v6 + 21);
    v8 = *(_DWORD *)(v7 + 68);
    if (v8 > v9)
    {
      v10 = *((_DWORD *)v6 + 22);
      goto LABEL_13;
    }
  }
  v17 = *(_DWORD *)(v7 + 64);
  v18 = *((_DWORD *)v6 + 23);
  if (v17 > v18)
  {
    if (*((_DWORD *)v6 + 31) != 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
      {
        v20 = *((_DWORD *)v6 + 23);
        v21 = *(_DWORD *)(*((_QWORD *)v6 + 3) + 64);
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoints";
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v6;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v135) = v20;
        WORD2(v135) = 1024;
        *(_DWORD *)((char *)&v135 + 6) = v17 - v18;
        WORD5(v135) = 1024;
        HIDWORD(v135) = v21;
        LOWORD(v136) = 1024;
        *(_DWORD *)((char *)&v136 + 2) = v20;
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_INFO, "%{public}s Context %{public}@ has more than %u idle cache entries, purging %u from %u down to %u", buf, 0x2Eu);
      }

      v7 = *((_QWORD *)v6 + 3);
    }
    v22 = **(_QWORD **)(*(_QWORD *)(v7 + 24) + 8);
    if (v22)
    {
      v23 = ~v17 + v18;
      do
      {
        *(_QWORD *)(v22 + 32) = 0;
        v16 = __CFADD__(v23++, 1);
        if (v16)
          break;
        v22 = **(_QWORD **)(*(_QWORD *)(v22 + 24) + 8);
      }
      while (v22);
    }
  }
LABEL_34:
  v24 = *(char **)(v7 + 32);
  v25 = v6;
  v26 = v25;
  if (v24)
  {
    v27 = MEMORY[0x1E0C809B0];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke;
    *(_QWORD *)&v135 = &unk_1E149A4F8;
    *((_QWORD *)&v135 + 1) = v25;
    v136 = (os_log_type_t *)v24;
    v137 = "address";
    nw_hash_table_apply(v24, (uint64_t)buf);

    goto LABEL_36;
  }
  v27 = MEMORY[0x1E0C809B0];
  __nwlog_obj();
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
  v67 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v133 = 0;
  if (__nwlog_fault(v67, type, &v133))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v68 = objc_claimAutoreleasedReturnValue();
      v69 = type[0];
      if (os_log_type_enabled(v68, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s called with null hash_table", buf, 0xCu);
      }
    }
    else if (v133)
    {
      v96 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v68 = objc_claimAutoreleasedReturnValue();
      v97 = type[0];
      v98 = os_log_type_enabled(v68, type[0]);
      if (v96)
      {
        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v96;
          _os_log_impl(&dword_182FBE000, v68, v97, "%{public}s called with null hash_table, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v96);
        goto LABEL_186;
      }
      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v68, v97, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v68 = objc_claimAutoreleasedReturnValue();
      v113 = type[0];
      if (os_log_type_enabled(v68, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v68, v113, "%{public}s called with null hash_table, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_186:
  if (v67)
    free(v67);
LABEL_36:

  v28 = *(char **)(*((_QWORD *)v6 + 3) + 40);
  v29 = v26;
  v30 = v29;
  if (v28)
  {
    *(_QWORD *)buf = v27;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke;
    *(_QWORD *)&v135 = &unk_1E149A4F8;
    *((_QWORD *)&v135 + 1) = v29;
    v136 = (os_log_type_t *)v28;
    v137 = "host";
    nw_hash_table_apply(v28, (uint64_t)buf);

    goto LABEL_38;
  }
  __nwlog_obj();
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
  v71 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v133 = 0;
  if (__nwlog_fault(v71, type, &v133))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v72 = objc_claimAutoreleasedReturnValue();
      v73 = type[0];
      if (os_log_type_enabled(v72, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v72, v73, "%{public}s called with null hash_table", buf, 0xCu);
      }
    }
    else if (v133)
    {
      v99 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v72 = objc_claimAutoreleasedReturnValue();
      v100 = type[0];
      v101 = os_log_type_enabled(v72, type[0]);
      if (v99)
      {
        if (v101)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v99;
          _os_log_impl(&dword_182FBE000, v72, v100, "%{public}s called with null hash_table, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v99);
        goto LABEL_191;
      }
      if (v101)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v72, v100, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v72 = objc_claimAutoreleasedReturnValue();
      v114 = type[0];
      if (os_log_type_enabled(v72, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v72, v114, "%{public}s called with null hash_table, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_191:
  if (v71)
    free(v71);
LABEL_38:

  v31 = *(char **)(*((_QWORD *)v6 + 3) + 48);
  v32 = v30;
  v33 = v32;
  if (v31)
  {
    *(_QWORD *)buf = v27;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke;
    *(_QWORD *)&v135 = &unk_1E149A4F8;
    *((_QWORD *)&v135 + 1) = v32;
    v136 = (os_log_type_t *)v31;
    v137 = "other";
    nw_hash_table_apply(v31, (uint64_t)buf);

    goto LABEL_40;
  }
  __nwlog_obj();
  v74 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
  v75 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v133 = 0;
  if (__nwlog_fault(v75, type, &v133))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v76 = objc_claimAutoreleasedReturnValue();
      v77 = type[0];
      if (os_log_type_enabled(v76, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v76, v77, "%{public}s called with null hash_table", buf, 0xCu);
      }
    }
    else if (v133)
    {
      v102 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v76 = objc_claimAutoreleasedReturnValue();
      v103 = type[0];
      v104 = os_log_type_enabled(v76, type[0]);
      if (v102)
      {
        if (v104)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v102;
          _os_log_impl(&dword_182FBE000, v76, v103, "%{public}s called with null hash_table, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v102);
        goto LABEL_196;
      }
      if (v104)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v76, v103, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v76 = objc_claimAutoreleasedReturnValue();
      v115 = type[0];
      if (os_log_type_enabled(v76, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_purge_endpoint_hash_table";
        _os_log_impl(&dword_182FBE000, v76, v115, "%{public}s called with null hash_table, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_196:
  if (v75)
    free(v75);
LABEL_40:

  if (v33[9])
  {
    v35 = *(char **)(*((_QWORD *)v6 + 3) + 32);
    v36 = v33;
    v37 = v36;
    if (v35)
    {
      *(_QWORD *)type = 0;
      v130 = type;
      v131 = 0x2020000000;
      v132 = 0;
      *(_QWORD *)buf = v27;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = ___ZL51nw_context_get_active_instance_count_for_hash_tableP21NWConcrete_nw_contextP13nw_hash_table_block_invoke;
      *(_QWORD *)&v135 = &unk_1E14AC2A0;
      v136 = type;
      *((_QWORD *)&v135 + 1) = v36;
      nw_hash_table_apply(v35, (uint64_t)buf);
      v124 = *((_QWORD *)v130 + 3);

      _Block_object_dispose(type, 8);
      goto LABEL_43;
    }
    __nwlog_obj();
    v78 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
    v125 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v133 = 0;
    v79 = (char *)v125;
    if (!__nwlog_fault(v125, type, &v133))
    {
LABEL_211:
      if (v79)
        free(v79);
      v124 = 0;
LABEL_43:

      v38 = *(char **)(*((_QWORD *)v6 + 3) + 40);
      v39 = v37;
      v40 = v39;
      if (v38)
      {
        *(_QWORD *)type = 0;
        v130 = type;
        v131 = 0x2020000000;
        v132 = 0;
        *(_QWORD *)buf = v27;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZL51nw_context_get_active_instance_count_for_hash_tableP21NWConcrete_nw_contextP13nw_hash_table_block_invoke;
        *(_QWORD *)&v135 = &unk_1E14AC2A0;
        v136 = type;
        *((_QWORD *)&v135 + 1) = v39;
        nw_hash_table_apply(v38, (uint64_t)buf);
        v41 = *((_QWORD *)v130 + 3);

        _Block_object_dispose(type, 8);
        goto LABEL_45;
      }
      __nwlog_obj();
      v82 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
      v123 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v133 = 0;
      v83 = (char *)v123;
      if (!__nwlog_fault(v123, type, &v133))
      {
LABEL_218:
        if (v83)
          free(v83);
        v41 = 0;
LABEL_45:

        v42 = *(char **)(*((_QWORD *)v6 + 3) + 48);
        v43 = v40;
        v44 = v43;
        if (v42)
        {
          *(_QWORD *)type = 0;
          v130 = type;
          v131 = 0x2020000000;
          v132 = 0;
          *(_QWORD *)buf = v27;
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___ZL51nw_context_get_active_instance_count_for_hash_tableP21NWConcrete_nw_contextP13nw_hash_table_block_invoke;
          *(_QWORD *)&v135 = &unk_1E14AC2A0;
          v136 = type;
          *((_QWORD *)&v135 + 1) = v43;
          nw_hash_table_apply(v42, (uint64_t)buf);
          v45 = *((_QWORD *)v130 + 3);

          _Block_object_dispose(type, 8);
LABEL_47:

          v46 = v41 + v124 + v45;
          if ((*((_BYTE *)v44 + 137) & 2) != 0 && !v46 || (*((_BYTE *)v44 + 137) & 2) == 0 && v46)
          {
            if (v44[8])
            {
              v47 = _Block_copy(v33[9]);
              v48 = v44[8];
              block[0] = v27;
              block[1] = 3221225472;
              block[2] = ___ZL26nw_context_purge_endpointsP21NWConcrete_nw_contextb_block_invoke;
              block[3] = &unk_1E14AAE50;
              block[4] = v47;
              v128 = v46 == 0;
              dispatch_async(v48, block);

            }
            else
            {
              (*((void (**)(const void *, BOOL))v33[9] + 2))(v33[9], v46 == 0);
            }
          }
          *((_BYTE *)v44 + 137) = *((_BYTE *)v44 + 137) & 0xFD | (2 * (v46 != 0));
          goto LABEL_55;
        }
        __nwlog_obj();
        v86 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
        v87 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v133 = 0;
        if (__nwlog_fault(v87, type, &v133))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v88 = objc_claimAutoreleasedReturnValue();
            v89 = type[0];
            if (os_log_type_enabled(v88, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
              _os_log_impl(&dword_182FBE000, v88, v89, "%{public}s called with null hash_table", buf, 0xCu);
            }
          }
          else if (v133)
          {
            v109 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v88 = objc_claimAutoreleasedReturnValue();
            v122 = type[0];
            v110 = os_log_type_enabled(v88, type[0]);
            if (v109)
            {
              if (v110)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v109;
                _os_log_impl(&dword_182FBE000, v88, v122, "%{public}s called with null hash_table, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v109);
              goto LABEL_224;
            }
            if (v110)
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
              _os_log_impl(&dword_182FBE000, v88, v122, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v88 = objc_claimAutoreleasedReturnValue();
            v119 = type[0];
            if (os_log_type_enabled(v88, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
              _os_log_impl(&dword_182FBE000, v88, v119, "%{public}s called with null hash_table, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
LABEL_224:
        if (v87)
          free(v87);
        v45 = 0;
        goto LABEL_47;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v84 = objc_claimAutoreleasedReturnValue();
        v85 = type[0];
        if (os_log_type_enabled(v84, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
          _os_log_impl(&dword_182FBE000, v84, v85, "%{public}s called with null hash_table", buf, 0xCu);
        }
      }
      else if (v133)
      {
        v107 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v84 = objc_claimAutoreleasedReturnValue();
        v120 = type[0];
        v108 = os_log_type_enabled(v84, type[0]);
        if (v107)
        {
          if (v108)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v107;
            _os_log_impl(&dword_182FBE000, v84, v120, "%{public}s called with null hash_table, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v107);
          goto LABEL_217;
        }
        if (v108)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
          _os_log_impl(&dword_182FBE000, v84, v120, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v84 = objc_claimAutoreleasedReturnValue();
        v118 = type[0];
        if (os_log_type_enabled(v84, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
          _os_log_impl(&dword_182FBE000, v84, v118, "%{public}s called with null hash_table, backtrace limit exceeded", buf, 0xCu);
        }
      }

LABEL_217:
      v83 = (char *)v123;
      goto LABEL_218;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v80 = objc_claimAutoreleasedReturnValue();
      v81 = type[0];
      if (os_log_type_enabled(v80, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
        _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s called with null hash_table", buf, 0xCu);
      }
    }
    else
    {
      if (!v133)
      {
        __nwlog_obj();
        v116 = objc_claimAutoreleasedReturnValue();
        v117 = type[0];
        if (os_log_type_enabled(v116, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
          _os_log_impl(&dword_182FBE000, v116, v117, "%{public}s called with null hash_table, backtrace limit exceeded", buf, 0xCu);
        }

        goto LABEL_210;
      }
      v105 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v80 = objc_claimAutoreleasedReturnValue();
      v121 = type[0];
      v106 = os_log_type_enabled(v80, type[0]);
      if (v105)
      {
        if (v106)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v105;
          _os_log_impl(&dword_182FBE000, v80, v121, "%{public}s called with null hash_table, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v105);
        goto LABEL_210;
      }
      if (v106)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_context_get_active_instance_count_for_hash_table";
        _os_log_impl(&dword_182FBE000, v80, v121, "%{public}s called with null hash_table, no backtrace", buf, 0xCu);
      }
    }

LABEL_210:
    v79 = (char *)v125;
    goto LABEL_211;
  }
LABEL_55:
  v50 = v126;
  if (!nw_hash_table_count(*(_QWORD *)(*((_QWORD *)v6 + 3) + 32), v34)
    && !nw_hash_table_count(*(_QWORD *)(*((_QWORD *)v6 + 3) + 40), v49)
    && !nw_hash_table_count(*(_QWORD *)(*((_QWORD *)v6 + 3) + 48), v51))
  {
    v53 = *(_QWORD *)(*((_QWORD *)v6 + 3) + 56);
    if (v53)
    {
      nw_queue_cancel_source(v53, v52);
      *(_QWORD *)(*((_QWORD *)v6 + 3) + 56) = 0;
    }
  }
LABEL_60:

}

void sub_18335E5C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke(uint64_t a1, uint64_t a2)
{
  char *object;
  uint64_t v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  uint64_t v13;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  os_log_type_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  os_log_type_t type;
  _QWORD v27[4];
  id v28;
  char *v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  object = (char *)nw_hash_node_get_object(a2);
  v27[0] = MEMORY[0x1E0C809B0];
  v27[1] = 3221225472;
  v27[2] = ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke_2;
  v27[3] = &unk_1E149C860;
  v29 = object;
  v28 = *(id *)(a1 + 32);
  nw_hash_table_apply(object, (uint64_t)v27);
  if (nw_hash_table_count((uint64_t)object, v5) || nw_hash_table_remove_node(*(_QWORD *)(a1 + 40), a2))
    goto LABEL_10;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(a1 + 48);
  *(_DWORD *)buf = 136446978;
  v31 = "nw_context_purge_endpoint_hash_table_block_invoke";
  v32 = 2114;
  v33 = v7;
  v34 = 2080;
  v35 = v8;
  v36 = 2048;
  v37 = a2;
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v9, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        v12 = *(_QWORD *)(a1 + 32);
        v13 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        v31 = "nw_context_purge_endpoint_hash_table_block_invoke";
        v32 = 2114;
        v33 = v12;
        v34 = 2080;
        v35 = v13;
        v36 = 2048;
        v37 = a2;
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s %{public}@ failed to remove %s hash table for node %p", buf, 0x2Au);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v17)
        {
          v18 = *(_QWORD *)(a1 + 32);
          v19 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 136447234;
          v31 = "nw_context_purge_endpoint_hash_table_block_invoke";
          v32 = 2114;
          v33 = v18;
          v34 = 2080;
          v35 = v19;
          v36 = 2048;
          v37 = a2;
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s %{public}@ failed to remove %s hash table for node %p, dumping backtrace:%{public}s", buf, 0x34u);
        }

        free(backtrace_string);
        if (v9)
          goto LABEL_9;
        goto LABEL_10;
      }
      if (v17)
      {
        v23 = *(_QWORD *)(a1 + 32);
        v24 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        v31 = "nw_context_purge_endpoint_hash_table_block_invoke";
        v32 = 2114;
        v33 = v23;
        v34 = 2080;
        v35 = v24;
        v36 = 2048;
        v37 = a2;
        _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s %{public}@ failed to remove %s hash table for node %p, no backtrace", buf, 0x2Au);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        v21 = *(_QWORD *)(a1 + 32);
        v22 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        v31 = "nw_context_purge_endpoint_hash_table_block_invoke";
        v32 = 2114;
        v33 = v21;
        v34 = 2080;
        v35 = v22;
        v36 = 2048;
        v37 = a2;
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s %{public}@ failed to remove %s hash table for node %p, backtrace limit exceeded", buf, 0x2Au);
      }
    }

  }
  if (v9)
LABEL_9:
    free(v9);
LABEL_10:

  return 1;
}

uint64_t ___ZL51nw_context_get_active_instance_count_for_hash_tableP21NWConcrete_nw_contextP13nw_hash_table_block_invoke(uint64_t a1, uint64_t a2)
{
  char *object;
  id v4;
  __int128 v6;
  _QWORD v7[4];
  __int128 v8;

  object = (char *)nw_hash_node_get_object(a2);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___ZL51nw_context_get_active_instance_count_for_hash_tableP21NWConcrete_nw_contextP13nw_hash_table_block_invoke_2;
  v7[3] = &unk_1E14AC2A0;
  v6 = *(_OWORD *)(a1 + 32);
  v4 = (id)v6;
  v8 = v6;
  nw_hash_table_apply(object, (uint64_t)v7);

  return 1;
}

uint64_t ___ZL26nw_context_purge_endpointsP21NWConcrete_nw_contextb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t ___ZL51nw_context_get_active_instance_count_for_hash_tableP21NWConcrete_nw_contextP13nw_hash_table_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id v3;

  v3 = (id)nw_hash_node_get_object(a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += nw_context_endpoint_get_active_instance_count(*(void **)(a1 + 32), v3);

  return 1;
}

void sub_18335EB18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_context_copy_globals_context(NWConcrete_nw_context *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  NWConcrete_nw_context *v3;
  NWConcrete_nw_context *v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  _BOOL8 result;

  v1 = a1;
  v2 = v1;
  if ((*((_BYTE *)v1 + 136) & 5) != 0)
  {
    v3 = (NWConcrete_nw_context *)*((_QWORD *)v1 + 5);
    if (!v3)
      v3 = v1;
  }
  else
  {
    if (nw_context_copy_implicit_context::onceToken[0] != -1)
      dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
    v3 = (NWConcrete_nw_context *)nw_context_copy_implicit_context::implicit_context;
  }
  v4 = v3;
  if (*((_QWORD *)v4 + 4))
    goto LABEL_11;
  v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v5);
  v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  v7 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
LABEL_11:

    return (BOOL)v4;
  }
  __break(1u);
  return result;
}

BOOL nw_context_get_isolate_protocol_cache(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*((_BYTE *)v1 + 136) & 3) != 0;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_context_get_isolate_protocol_cache";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_isolate_protocol_cache";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_context_get_isolate_protocol_cache";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_isolate_protocol_cache";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_isolate_protocol_cache";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void *nw_context_endpoint_table_get_key(os_unfair_lock_s *a1, unsigned int *a2)
{
  _BOOL8 some_node;
  void *v3;

  some_node = nw_hash_table_get_some_node(a1);
  nw_hash_node_get_object(some_node);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

uint64_t nw_context_endpoint_key_hash(void *a1)
{
  return objc_msgSend(a1, "getHash");
}

uint64_t nw_context_endpoint_table_matches_key(os_unfair_lock_s *a1, void *a2)
{
  void *v3;
  _BOOL8 some_node;
  void *v5;
  uint64_t is_equal;

  v3 = a2;
  some_node = nw_hash_table_get_some_node(a1);
  nw_hash_node_get_object(some_node);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  is_equal = nw_endpoint_is_equal(v3, v5, 0);

  return is_equal;
}

void sub_18335EFEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_context_endpoint_table_release(os_unfair_lock_s *a1, uint64_t a2)
{
  if (a1)
    _nw_hash_table_release(a1, a2);
}

BOOL nw_context_object_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

uint64_t nw_context_timer_object_get_key(_QWORD *a1, unsigned int *a2)
{
  return a1[3];
}

BOOL nw_context_timer_object_matches_key(_QWORD *a1, const void *a2)
{
  return a1[3] == (_QWORD)a2;
}

uint64_t ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke_2(uint64_t a1, uint64_t a2)
{
  id v4;
  id v5;
  uint64_t v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  uint64_t v10;
  const char *v11;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  uint64_t v16;
  const char *v17;
  os_log_type_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  const char *logging_description;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v4 = (id)nw_hash_node_get_object(a2);
  if ((nw_endpoint_is_active(v4, 1) & 1) != 0 || nw_hash_table_remove_node(*(_QWORD *)(a1 + 40), a2))
    goto LABEL_10;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  v6 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)buf = 136446978;
  v26 = "nw_context_purge_endpoint_hash_table_block_invoke_2";
  v27 = 2114;
  v28 = v6;
  v29 = 2082;
  logging_description = nw_endpoint_get_logging_description(v4);
  v31 = 2048;
  v32 = a2;
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v7, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        v10 = *(_QWORD *)(a1 + 32);
        v11 = nw_endpoint_get_logging_description(v4);
        *(_DWORD *)buf = 136446978;
        v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
        v27 = 2114;
        v28 = v10;
        v29 = 2082;
        logging_description = v11;
        v31 = 2048;
        v32 = a2;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p", buf, 0x2Au);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v15)
        {
          v16 = *(_QWORD *)(a1 + 32);
          v17 = nw_endpoint_get_logging_description(v4);
          *(_DWORD *)buf = 136447234;
          v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
          v27 = 2114;
          v28 = v16;
          v29 = 2082;
          logging_description = v17;
          v31 = 2048;
          v32 = a2;
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p, dumping backtrace:%{public}s", buf, 0x34u);
        }

        free(backtrace_string);
        if (v7)
          goto LABEL_9;
        goto LABEL_10;
      }
      if (v15)
      {
        v21 = *(_QWORD *)(a1 + 32);
        v22 = nw_endpoint_get_logging_description(v4);
        *(_DWORD *)buf = 136446978;
        v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
        v27 = 2114;
        v28 = v21;
        v29 = 2082;
        logging_description = v22;
        v31 = 2048;
        v32 = a2;
        _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p, no backtrace", buf, 0x2Au);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        v19 = *(_QWORD *)(a1 + 32);
        v20 = nw_endpoint_get_logging_description(v4);
        *(_DWORD *)buf = 136446978;
        v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
        v27 = 2114;
        v28 = v19;
        v29 = 2082;
        logging_description = v20;
        v31 = 2048;
        v32 = a2;
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p, backtrace limit exceeded", buf, 0x2Au);
      }
    }

  }
  if (v7)
LABEL_9:
    free(v7);
LABEL_10:

  return 1;
}

void sub_18335F45C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_context_cancel(void *a1)
{
  char *v1;
  NSObject *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  unint64_t *v20;
  __uint64_t v21;
  unint64_t v22;
  char v23;
  void *v24;
  os_log_type_t v25;
  void *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  char *v33;
  os_log_type_t v34;
  _BOOL4 v35;
  __uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  char v39;
  void *v40;
  unint64_t v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  os_log_type_t v45;
  os_log_type_t v46;
  char *v47;
  os_log_type_t v48;
  _BOOL4 v49;
  char *v50;
  os_log_type_t v51;
  _BOOL4 v52;
  os_log_type_t v53;
  os_log_type_t v54;
  char v55;
  __uint64_t v56;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  __uint64_t v61;
  __int16 v62;
  unint64_t v63;
  __int16 v64;
  char *v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v56 = 0;
    pthread_threadid_np(0, &v56);
    if (*((_DWORD *)v1 + 30) != 4)
      goto LABEL_3;
    v20 = (unint64_t *)(v1 + 112);
    v21 = v56;
    while (1)
    {
      v22 = __ldaxr(v20);
      if (v22)
        break;
      if (!__stlxr(v21, v20))
      {
        v23 = 1;
        goto LABEL_50;
      }
    }
    v23 = 0;
    __clrex();
LABEL_50:
    if ((v23 & 1) != 0)
    {
LABEL_3:
      if (*((_DWORD *)v1 + 31) != 4)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v2 = (id)gLogObj;
        if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_context_cancel";
          v60 = 2114;
          v61 = (__uint64_t)v1;
          _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_INFO, "%{public}s Cancelling context %{public}@", buf, 0x16u);
        }

      }
      v3 = nw_context_copy_globals_context((NWConcrete_nw_context *)v1);
      v4 = (void *)v3;
      if ((*(_BYTE *)(v3 + 136) & 8) != 0)
      {
        v5 = *(_QWORD *)(v3 + 32);
        v6 = *(_QWORD *)(v5 + 100);
        if (v6 && *(_QWORD *)(v6 + 24) != *(_QWORD *)(v6 + 16)
          || (v7 = *(_QWORD *)(v5 + 116)) != 0 && *(_QWORD *)(v7 + 24) != *(_QWORD *)(v7 + 16))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v59 = "nw_context_cancel";
          v9 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v55 = 0;
          if (!__nwlog_fault(v9, &type, &v55))
            goto LABEL_31;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v10 = (id)gLogObj;
            v11 = type;
            if (os_log_type_enabled(v10, type))
            {
              *(_DWORD *)buf = 136446210;
              v59 = "nw_context_cancel";
              _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s Calling cancel context while blocks remain on the inline queues", buf, 0xCu);
            }
          }
          else if (v55)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v10 = (id)gLogObj;
            v13 = type;
            v14 = os_log_type_enabled(v10, type);
            if (backtrace_string)
            {
              if (v14)
              {
                *(_DWORD *)buf = 136446466;
                v59 = "nw_context_cancel";
                v60 = 2082;
                v61 = (__uint64_t)backtrace_string;
                _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s Calling cancel context while blocks remain on the inline queues, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(backtrace_string);
              if (!v9)
                goto LABEL_33;
              goto LABEL_32;
            }
            if (v14)
            {
              *(_DWORD *)buf = 136446210;
              v59 = "nw_context_cancel";
              _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s Calling cancel context while blocks remain on the inline queues, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v10 = (id)gLogObj;
            v15 = type;
            if (os_log_type_enabled(v10, type))
            {
              *(_DWORD *)buf = 136446210;
              v59 = "nw_context_cancel";
              _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s Calling cancel context while blocks remain on the inline queues, backtrace limit exceeded", buf, 0xCu);
            }
          }
          goto LABEL_30;
        }
        *(_BYTE *)(v3 + 136) |= 0x10u;
        if ((v1[136] & 8) == 0)
          goto LABEL_18;
        v36 = v56;
        v37 = (unint64_t *)(v1 + 112);
        while (1)
        {
          v38 = __ldaxr(v37);
          if (v38 != v36)
            break;
          if (!__stlxr(0, v37))
          {
            v39 = 1;
            goto LABEL_71;
          }
        }
        v39 = 0;
        __clrex();
LABEL_71:
        if ((v39 & 1) != 0)
        {
LABEL_18:
          nw_context_dealloc((NWConcrete_nw_context *)v1, 1);
          goto LABEL_33;
        }
        __nwlog_obj();
        v40 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446722;
        v59 = "nw_context_cancel";
        v60 = 2048;
        v61 = v56;
        v62 = 2048;
        v41 = v38;
        v63 = v38;
        v42 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v55 = 0;
        if (__nwlog_fault(v42, &type, &v55))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v43 = objc_claimAutoreleasedReturnValue();
            v44 = type;
            if (os_log_type_enabled(v43, type))
            {
              *(_DWORD *)buf = 136446722;
              v59 = "nw_context_cancel";
              v60 = 2048;
              v61 = v56;
              v62 = 2048;
              v63 = v41;
              _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s Exiting call, expected inline TID to be %llu but got %llu", buf, 0x20u);
            }
          }
          else if (v55)
          {
            v50 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v43 = objc_claimAutoreleasedReturnValue();
            v51 = type;
            v52 = os_log_type_enabled(v43, type);
            if (v50)
            {
              if (v52)
              {
                *(_DWORD *)buf = 136446978;
                v59 = "nw_context_cancel";
                v60 = 2048;
                v61 = v56;
                v62 = 2048;
                v63 = v41;
                v64 = 2082;
                v65 = v50;
                _os_log_impl(&dword_182FBE000, v43, v51, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, dumping backtrace:%{public}s", buf, 0x2Au);
              }

              free(v50);
              goto LABEL_115;
            }
            if (v52)
            {
              *(_DWORD *)buf = 136446722;
              v59 = "nw_context_cancel";
              v60 = 2048;
              v61 = v56;
              v62 = 2048;
              v63 = v41;
              _os_log_impl(&dword_182FBE000, v43, v51, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, no backtrace", buf, 0x20u);
            }
          }
          else
          {
            __nwlog_obj();
            v43 = objc_claimAutoreleasedReturnValue();
            v54 = type;
            if (os_log_type_enabled(v43, type))
            {
              *(_DWORD *)buf = 136446722;
              v59 = "nw_context_cancel";
              v60 = 2048;
              v61 = v56;
              v62 = 2048;
              v63 = v41;
              _os_log_impl(&dword_182FBE000, v43, v54, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, backtrace limit exceeded", buf, 0x20u);
            }
          }

        }
LABEL_115:
        if (v42)
          free(v42);
        goto LABEL_18;
      }
      __nwlog_obj();
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v59 = "nw_context_cancel";
      v9 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (__nwlog_fault(v9, &type, &v55))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v10 = objc_claimAutoreleasedReturnValue();
          v25 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446210;
            v59 = "nw_context_cancel";
            _os_log_impl(&dword_182FBE000, v10, v25, "%{public}s called with null globals_context->is_inline", buf, 0xCu);
          }
LABEL_30:

          goto LABEL_31;
        }
        if (!v55)
        {
          __nwlog_obj();
          v10 = objc_claimAutoreleasedReturnValue();
          v46 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446210;
            v59 = "nw_context_cancel";
            _os_log_impl(&dword_182FBE000, v10, v46, "%{public}s called with null globals_context->is_inline, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_30;
        }
        v33 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v34 = type;
        v35 = os_log_type_enabled(v10, type);
        if (!v33)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446210;
            v59 = "nw_context_cancel";
            _os_log_impl(&dword_182FBE000, v10, v34, "%{public}s called with null globals_context->is_inline, no backtrace", buf, 0xCu);
          }
          goto LABEL_30;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_context_cancel";
          v60 = 2082;
          v61 = (__uint64_t)v33;
          _os_log_impl(&dword_182FBE000, v10, v34, "%{public}s called with null globals_context->is_inline, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v33);
      }
LABEL_31:
      if (v9)
LABEL_32:
        free(v9);
LABEL_33:

      goto LABEL_34;
    }
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v59 = "nw_context_cancel";
    v60 = 2048;
    v61 = v56;
    v62 = 2048;
    v63 = v22;
    v27 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (__nwlog_fault(v27, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          v59 = "nw_context_cancel";
          v60 = 2048;
          v61 = v56;
          v62 = 2048;
          v63 = v22;
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu", buf, 0x20u);
        }
      }
      else if (v55)
      {
        v47 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        v49 = os_log_type_enabled(v28, type);
        if (v47)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446978;
            v59 = "nw_context_cancel";
            v60 = 2048;
            v61 = v56;
            v62 = 2048;
            v63 = v22;
            v64 = 2082;
            v65 = v47;
            _os_log_impl(&dword_182FBE000, v28, v48, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v47);
          goto LABEL_107;
        }
        if (v49)
        {
          *(_DWORD *)buf = 136446722;
          v59 = "nw_context_cancel";
          v60 = 2048;
          v61 = v56;
          v62 = 2048;
          v63 = v22;
          _os_log_impl(&dword_182FBE000, v28, v48, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v53 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446722;
          v59 = "nw_context_cancel";
          v60 = 2048;
          v61 = v56;
          v62 = 2048;
          v63 = v22;
          _os_log_impl(&dword_182FBE000, v28, v53, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
LABEL_107:
    if (v27)
      free(v27);
    goto LABEL_3;
  }
  __nwlog_obj();
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v59 = "nw_context_cancel";
  v17 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v56) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v17, &v56, &type))
  {
    if (v56 == 17)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v19 = v56;
      if (os_log_type_enabled(v18, (os_log_type_t)v56))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_context_cancel";
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (type)
    {
      v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v31 = v56;
      v32 = os_log_type_enabled(v18, (os_log_type_t)v56);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_context_cancel";
          v60 = 2082;
          v61 = (__uint64_t)v30;
          _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v30);
        goto LABEL_86;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_context_cancel";
        _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v45 = v56;
      if (os_log_type_enabled(v18, (os_log_type_t)v56))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_context_cancel";
        _os_log_impl(&dword_182FBE000, v18, v45, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_86:
  if (v17)
    free(v17);
LABEL_34:

}

void sub_1833601E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_context_queue_block(void *a1, void *a2)
{
  NWConcrete_nw_context *v3;
  void (**v4)(_QWORD);
  uint64_t v5;
  void (**v6)(_QWORD);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  os_log_type_t v23;
  void *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  os_log_type_t v29;
  char *v30;
  uint64_t v31;
  os_log_type_t v32;
  _BOOL4 v33;
  char *v34;
  uint64_t v35;
  os_log_type_t v36;
  _BOOL4 v37;
  char *backtrace_string;
  uint64_t v39;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  os_log_type_t v43;
  os_log_type_t v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  char *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v6 = v4;
  if (v3)
  {
    if (v4)
    {
      v7 = nw_context_copy_globals_context(v3);

      if ((*(_BYTE *)(v7 + 136) & 8) != 0)
      {
        if ((*(_BYTE *)(v7 + 136) & 0x10) != 0)
        {
          v3 = (NWConcrete_nw_context *)v7;
          v6[2](v6);
          goto LABEL_7;
        }
        v10 = *(_QWORD *)(*(_QWORD *)(v7 + 32) + 100);
        v11 = _Block_copy(v6);
        nw_array_append(v10, v11);

        goto LABEL_6;
      }
      __nwlog_obj(v8, v9);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v48 = "nw_context_queue_block";
      v25 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v45 = 0;
      v26 = __nwlog_fault(v25, &type, &v45);
      if ((_DWORD)v26)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj(v26, v27);
          v28 = objc_claimAutoreleasedReturnValue();
          v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446210;
            v48 = "nw_context_queue_block";
            _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null context->is_inline", buf, 0xCu);
          }
        }
        else if (v45)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj(backtrace_string, v39);
          v28 = objc_claimAutoreleasedReturnValue();
          v40 = type;
          v41 = os_log_type_enabled(v28, type);
          if (backtrace_string)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              v48 = "nw_context_queue_block";
              v49 = 2082;
              v50 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v28, v40, "%{public}s called with null context->is_inline, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_62;
          }
          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            v48 = "nw_context_queue_block";
            _os_log_impl(&dword_182FBE000, v28, v40, "%{public}s called with null context->is_inline, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj(v26, v27);
          v28 = objc_claimAutoreleasedReturnValue();
          v44 = type;
          if (os_log_type_enabled(v28, type))
          {
            *(_DWORD *)buf = 136446210;
            v48 = "nw_context_queue_block";
            _os_log_impl(&dword_182FBE000, v28, v44, "%{public}s called with null context->is_inline, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_62:
      if (v25)
        free(v25);
LABEL_6:
      v3 = (NWConcrete_nw_context *)v7;
      goto LABEL_7;
    }
    __nwlog_obj(0, v5);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_context_queue_block";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    v20 = __nwlog_fault(v19, &type, &v45);
    if (!(_DWORD)v20)
      goto LABEL_57;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v20, v21);
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_context_queue_block";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null block", buf, 0xCu);
      }
    }
    else if (v45)
    {
      v34 = (char *)__nw_create_backtrace_string();
      __nwlog_obj(v34, v35);
      v22 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      v37 = os_log_type_enabled(v22, type);
      if (v34)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_context_queue_block";
          v49 = 2082;
          v50 = v34;
          _os_log_impl(&dword_182FBE000, v22, v36, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v34);
        goto LABEL_57;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_context_queue_block";
        _os_log_impl(&dword_182FBE000, v22, v36, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v20, v21);
      v22 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_context_queue_block";
        _os_log_impl(&dword_182FBE000, v22, v43, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_57:
    if (v19)
      free(v19);
    goto LABEL_7;
  }
  __nwlog_obj(v4, v5);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v48 = "nw_context_queue_block";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  v14 = __nwlog_fault(v13, &type, &v45);
  if ((_DWORD)v14)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_context_queue_block";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v45)
    {
      v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj(v30, v31);
      v16 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      v33 = os_log_type_enabled(v16, type);
      if (v30)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_context_queue_block";
          v49 = 2082;
          v50 = v30;
          _os_log_impl(&dword_182FBE000, v16, v32, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v30);
        goto LABEL_51;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_context_queue_block";
        _os_log_impl(&dword_182FBE000, v16, v32, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v42 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_context_queue_block";
        _os_log_impl(&dword_182FBE000, v16, v42, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_51:
  if (v13)
    free(v13);
  v3 = 0;
LABEL_7:

}

void sub_183360920(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_context_queue_source_block(void *a1, void *a2)
{
  NWConcrete_nw_context *v3;
  id v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  uint64_t v25;
  os_log_type_t v26;
  _BOOL4 v27;
  char *backtrace_string;
  uint64_t v29;
  os_log_type_t v30;
  _BOOL4 v31;
  os_log_type_t v32;
  os_log_type_t v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v6 = v4;
  if (v3)
  {
    v7 = nw_context_copy_globals_context(v3);

    if ((*(_BYTE *)(v7 + 136) & 8) != 0)
    {
      v10 = *(_QWORD *)(*(_QWORD *)(v7 + 32) + 116);
      v11 = _Block_copy(v6);
      nw_array_append(v10, v11);

      goto LABEL_4;
    }
    __nwlog_obj(v8, v9);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_context_queue_source_block";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    v20 = __nwlog_fault(v19, &type, &v34);
    if (!(_DWORD)v20)
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v20, v21);
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_queue_source_block";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null context->is_inline", buf, 0xCu);
      }
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj(backtrace_string, v29);
      v22 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      v31 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_context_queue_source_block";
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v30, "%{public}s called with null context->is_inline, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_39;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_queue_source_block";
        _os_log_impl(&dword_182FBE000, v22, v30, "%{public}s called with null context->is_inline, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v20, v21);
      v22 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_queue_source_block";
        _os_log_impl(&dword_182FBE000, v22, v33, "%{public}s called with null context->is_inline, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:
    if (v19)
      free(v19);

    goto LABEL_4;
  }
  __nwlog_obj(v4, v5);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_context_queue_source_block";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  v14 = __nwlog_fault(v13, &type, &v34);
  if ((_DWORD)v14)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_queue_source_block";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v34)
    {
      v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj(v24, v25);
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      v27 = os_log_type_enabled(v16, type);
      if (v24)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_context_queue_source_block";
          v38 = 2082;
          v39 = v24;
          _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        goto LABEL_34;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_queue_source_block";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_queue_source_block";
        _os_log_impl(&dword_182FBE000, v16, v32, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_34:
  if (v13)
    free(v13);
LABEL_4:

}

void sub_183360E14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_context_dequeue_source_block(void *a1, void *a2)
{
  NWConcrete_nw_context *v3;
  id v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  uint64_t v25;
  os_log_type_t v26;
  _BOOL4 v27;
  char *backtrace_string;
  uint64_t v29;
  os_log_type_t v30;
  _BOOL4 v31;
  os_log_type_t v32;
  os_log_type_t v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v6 = v4;
  if (v3)
  {
    v7 = nw_context_copy_globals_context(v3);

    if ((*(_BYTE *)(v7 + 136) & 8) != 0)
    {
      v10 = *(_QWORD *)(*(_QWORD *)(v7 + 32) + 116);
      v11 = _Block_copy(v6);
      nw_array_remove_object(v10, (uint64_t)v11);

      goto LABEL_4;
    }
    __nwlog_obj(v8, v9);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_context_dequeue_source_block";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    v20 = __nwlog_fault(v19, &type, &v34);
    if (!(_DWORD)v20)
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v20, v21);
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_dequeue_source_block";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null context->is_inline", buf, 0xCu);
      }
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj(backtrace_string, v29);
      v22 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      v31 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_context_dequeue_source_block";
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v30, "%{public}s called with null context->is_inline, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_39;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_dequeue_source_block";
        _os_log_impl(&dword_182FBE000, v22, v30, "%{public}s called with null context->is_inline, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v20, v21);
      v22 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_dequeue_source_block";
        _os_log_impl(&dword_182FBE000, v22, v33, "%{public}s called with null context->is_inline, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_39:
    if (v19)
      free(v19);

    goto LABEL_4;
  }
  __nwlog_obj(v4, v5);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_context_dequeue_source_block";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  v14 = __nwlog_fault(v13, &type, &v34);
  if ((_DWORD)v14)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_dequeue_source_block";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v34)
    {
      v24 = (char *)__nw_create_backtrace_string();
      __nwlog_obj(v24, v25);
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      v27 = os_log_type_enabled(v16, type);
      if (v24)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_context_dequeue_source_block";
          v38 = 2082;
          v39 = v24;
          _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        goto LABEL_34;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_dequeue_source_block";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_context_dequeue_source_block";
        _os_log_impl(&dword_182FBE000, v16, v32, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_34:
  if (v13)
    free(v13);
LABEL_4:

}

void sub_183361308(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_context_run_queued_blocks_inline(void *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  void ***v16;
  uint64_t v17;
  void *v18;
  _BOOL8 v19;
  void ***v20;
  void ***v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL8 v25;
  uint64_t v26;
  void *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  unint64_t *v36;
  __uint64_t v37;
  unint64_t v38;
  char v39;
  __uint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  char v43;
  void *v44;
  char *v45;
  NSObject *v46;
  os_log_type_t v47;
  void *v48;
  char *v49;
  NSObject *v50;
  os_log_type_t v51;
  char *backtrace_string;
  os_log_type_t v53;
  _BOOL4 v54;
  char *v55;
  os_log_type_t v56;
  _BOOL4 v57;
  os_log_type_t v58;
  os_log_type_t v59;
  char *v60;
  os_log_type_t v61;
  _BOOL4 v62;
  char *v63;
  os_log_type_t v64;
  _BOOL4 v65;
  os_log_type_t v66;
  os_log_type_t v67;
  unint64_t v68;
  char v69;
  __uint64_t v70;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v73;
  __int16 v74;
  __uint64_t v75;
  __int16 v76;
  unint64_t v77;
  __int16 v78;
  char *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (!v1)
  {
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v73 = "nw_context_run_queued_blocks_inline";
    v29 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v70) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v29, &v70, &type))
    {
      if (v70 == 17)
      {
        __nwlog_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        v31 = v70;
        if (os_log_type_enabled(v30, (os_log_type_t)v70))
        {
          *(_DWORD *)buf = 136446210;
          v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        v53 = v70;
        v54 = os_log_type_enabled(v30, (os_log_type_t)v70);
        if (backtrace_string)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            v73 = "nw_context_run_queued_blocks_inline";
            v74 = 2082;
            v75 = (__uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v30, v53, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_77;
        }
        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl(&dword_182FBE000, v30, v53, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        v58 = v70;
        if (os_log_type_enabled(v30, (os_log_type_t)v70))
        {
          *(_DWORD *)buf = 136446210;
          v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl(&dword_182FBE000, v30, v58, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_77:
    if (v29)
      free(v29);
    return 0;
  }
  v2 = v1;
  v3 = nw_context_copy_globals_context(v1);

  if ((*(_BYTE *)(v3 + 136) & 8) == 0)
  {
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v73 = "nw_context_run_queued_blocks_inline";
    v33 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v70) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v33, &v70, &type))
    {
      if (v70 == 17)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v35 = v70;
        if (os_log_type_enabled(v34, (os_log_type_t)v70))
        {
          *(_DWORD *)buf = 136446210;
          v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null context->is_inline", buf, 0xCu);
        }
      }
      else if (type)
      {
        v55 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v56 = v70;
        v57 = os_log_type_enabled(v34, (os_log_type_t)v70);
        if (v55)
        {
          if (v57)
          {
            *(_DWORD *)buf = 136446466;
            v73 = "nw_context_run_queued_blocks_inline";
            v74 = 2082;
            v75 = (__uint64_t)v55;
            _os_log_impl(&dword_182FBE000, v34, v56, "%{public}s called with null context->is_inline, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v55);
          goto LABEL_82;
        }
        if (v57)
        {
          *(_DWORD *)buf = 136446210;
          v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl(&dword_182FBE000, v34, v56, "%{public}s called with null context->is_inline, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v59 = v70;
        if (os_log_type_enabled(v34, (os_log_type_t)v70))
        {
          *(_DWORD *)buf = 136446210;
          v73 = "nw_context_run_queued_blocks_inline";
          _os_log_impl(&dword_182FBE000, v34, v59, "%{public}s called with null context->is_inline, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_82:
    if (v33)
      free(v33);

    return 0;
  }
  v70 = 0;
  pthread_threadid_np(0, &v70);
  if (*(_DWORD *)(v3 + 120) == 4)
  {
    v36 = (unint64_t *)(v3 + 112);
    v37 = v70;
    while (1)
    {
      v38 = __ldaxr(v36);
      if (v38)
        break;
      if (!__stlxr(v37, v36))
      {
        v39 = 1;
        goto LABEL_45;
      }
    }
    v39 = 0;
    __clrex();
LABEL_45:
    if ((v39 & 1) == 0)
    {
      __nwlog_obj();
      v44 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446722;
      v73 = "nw_context_run_queued_blocks_inline";
      v74 = 2048;
      v75 = v70;
      v76 = 2048;
      v77 = v38;
      v45 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v69 = 0;
      if (__nwlog_fault(v45, &type, &v69))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v46 = objc_claimAutoreleasedReturnValue();
          v47 = type;
          if (os_log_type_enabled(v46, type))
          {
            *(_DWORD *)buf = 136446722;
            v73 = "nw_context_run_queued_blocks_inline";
            v74 = 2048;
            v75 = v70;
            v76 = 2048;
            v77 = v38;
            _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu", buf, 0x20u);
          }
        }
        else if (v69)
        {
          v60 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v46 = objc_claimAutoreleasedReturnValue();
          v61 = type;
          v62 = os_log_type_enabled(v46, type);
          if (v60)
          {
            if (v62)
            {
              *(_DWORD *)buf = 136446978;
              v73 = "nw_context_run_queued_blocks_inline";
              v74 = 2048;
              v75 = v70;
              v76 = 2048;
              v77 = v38;
              v78 = 2082;
              v79 = v60;
              _os_log_impl(&dword_182FBE000, v46, v61, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v60);
            goto LABEL_105;
          }
          if (v62)
          {
            *(_DWORD *)buf = 136446722;
            v73 = "nw_context_run_queued_blocks_inline";
            v74 = 2048;
            v75 = v70;
            v76 = 2048;
            v77 = v38;
            _os_log_impl(&dword_182FBE000, v46, v61, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          __nwlog_obj();
          v46 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v46, type))
          {
            *(_DWORD *)buf = 136446722;
            v73 = "nw_context_run_queued_blocks_inline";
            v74 = 2048;
            v75 = v70;
            v76 = 2048;
            v77 = v38;
            _os_log_impl(&dword_182FBE000, v46, v66, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, backtrace limit exceeded", buf, 0x20u);
          }
        }

      }
LABEL_105:
      if (v45)
        free(v45);
    }
  }
  while (1)
  {
    v4 = *(_QWORD *)(v3 + 32);
    v5 = *(_QWORD **)(v4 + 100);
    if (!v5 || v5[3] == v5[2])
      break;
    v6 = v5;
    v7 = *(_QWORD *)(v3 + 32);
    v8 = *(void **)(v7 + 108);
    if (v8)
    {
      objc_storeStrong((id *)(v7 + 100), v8);
      v9 = *(_QWORD *)(v3 + 32);
      v10 = *(void **)(v9 + 108);
      *(_QWORD *)(v9 + 108) = 0;
    }
    else
    {
      v11 = nw_array_create();
      v12 = *(_QWORD *)(v3 + 32);
      v10 = *(void **)(v12 + 100);
      *(_QWORD *)(v12 + 100) = v11;
    }

    nw_array_apply(v6, (uint64_t)&__block_literal_global_1249);
    nw_array_remove_all_objects((uint64_t)v6);
    v13 = *(_QWORD *)(v3 + 32);
    v14 = *(void **)(v13 + 108);
    *(_QWORD *)(v13 + 108) = v6;

  }
  v15 = *(void **)(v4 + 116);
  v16 = v15;
  v17 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 124);
  if (!v17)
  {
    v19 = nw_array_create();
    v20 = (void ***)v19;
    if (v16)
    {
      v21 = v16;
      if ((void ***)v19 == v16)
      {
LABEL_16:
        v22 = *(_QWORD *)(v3 + 32);
        v18 = *(void **)(v22 + 116);
        *(_QWORD *)(v22 + 116) = v21;
        goto LABEL_17;
      }
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v19 + 16, v16[2], v16[3], v16[3] - v16[2]);
    }
    v21 = v20;
    goto LABEL_16;
  }
  nw_array_assign(v17, (uint64_t)v16);
  objc_storeStrong((id *)(*(_QWORD *)(v3 + 32) + 116), *(id *)(*(_QWORD *)(v3 + 32) + 124));
  v18 = *(void **)(*(_QWORD *)(v3 + 32) + 124);
  *(_QWORD *)(*(_QWORD *)(v3 + 32) + 124) = 0;
LABEL_17:

  nw_array_apply((unsigned __int8 *)v16, (uint64_t)&__block_literal_global_12);
  nw_array_remove_all_objects((uint64_t)v16);
  objc_storeStrong((id *)(*(_QWORD *)(v3 + 32) + 124), v15);
  if ((*(_BYTE *)(v3 + 136) & 8) == 0)
    goto LABEL_18;
  v40 = v70;
  v41 = (unint64_t *)(v3 + 112);
  while (1)
  {
    v42 = __ldaxr(v41);
    if (v42 != v40)
      break;
    if (!__stlxr(0, v41))
    {
      v43 = 1;
      goto LABEL_52;
    }
  }
  v43 = 0;
  __clrex();
LABEL_52:
  if ((v43 & 1) != 0)
    goto LABEL_18;
  __nwlog_obj();
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446722;
  v73 = "nw_context_run_queued_blocks_inline";
  v74 = 2048;
  v75 = v70;
  v76 = 2048;
  v68 = v42;
  v77 = v42;
  v49 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v69 = 0;
  if (__nwlog_fault(v49, &type, &v69))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v50 = objc_claimAutoreleasedReturnValue();
      v51 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446722;
        v73 = "nw_context_run_queued_blocks_inline";
        v74 = 2048;
        v75 = v70;
        v76 = 2048;
        v77 = v68;
        _os_log_impl(&dword_182FBE000, v50, v51, "%{public}s Exiting call, expected inline TID to be %llu but got %llu", buf, 0x20u);
      }
    }
    else if (v69)
    {
      v63 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v50 = objc_claimAutoreleasedReturnValue();
      v64 = type;
      v65 = os_log_type_enabled(v50, type);
      if (v63)
      {
        if (v65)
        {
          *(_DWORD *)buf = 136446978;
          v73 = "nw_context_run_queued_blocks_inline";
          v74 = 2048;
          v75 = v70;
          v76 = 2048;
          v77 = v68;
          v78 = 2082;
          v79 = v63;
          _os_log_impl(&dword_182FBE000, v50, v64, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v63);
        goto LABEL_110;
      }
      if (v65)
      {
        *(_DWORD *)buf = 136446722;
        v73 = "nw_context_run_queued_blocks_inline";
        v74 = 2048;
        v75 = v70;
        v76 = 2048;
        v77 = v68;
        _os_log_impl(&dword_182FBE000, v50, v64, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v50 = objc_claimAutoreleasedReturnValue();
      v67 = type;
      if (os_log_type_enabled(v50, type))
      {
        *(_DWORD *)buf = 136446722;
        v73 = "nw_context_run_queued_blocks_inline";
        v74 = 2048;
        v75 = v70;
        v76 = 2048;
        v77 = v68;
        _os_log_impl(&dword_182FBE000, v50, v67, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, backtrace limit exceeded", buf, 0x20u);
      }
    }

  }
LABEL_110:
  if (v49)
    free(v49);
LABEL_18:
  v23 = *(_QWORD *)(v3 + 32);
  v24 = *(_QWORD *)(v23 + 100);
  if (!v24 || *(_QWORD *)(v24 + 24) == *(_QWORD *)(v24 + 16))
  {
    v26 = *(_QWORD *)(v23 + 116);
    if (v26)
      v25 = *(_QWORD *)(v26 + 24) != *(_QWORD *)(v26 + 16);
    else
      v25 = 0;
  }
  else
  {
    v25 = 1;
  }

  return v25;
}

void sub_183361ECC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_context_run_queued_blocks_inline_block_invoke_2(int a1, int a2, void *aBlock)
{
  void (**v3)(void);

  v3 = (void (**)(void))_Block_copy(aBlock);
  v3[2]();

  return 1;
}

void sub_183361F28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_context_run_queued_blocks_inline_block_invoke(int a1, int a2, void *aBlock)
{
  void (**v3)(void);

  v3 = (void (**)(void))_Block_copy(aBlock);
  v3[2]();

  return 1;
}

void sub_183361F6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_context_set_privacy_level_internal_block_invoke(uint64_t a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 80));
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 124) = *(_DWORD *)(a1 + 40);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 137) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + 137) & 0xFE | *(_BYTE *)(a1 + 44);
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(os_unfair_lock_s **)(v2 + 40);
  if (v3)
  {
    os_unfair_lock_lock(v3 + 20);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 124) = *(_DWORD *)(a1 + 40);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 137) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40)
                                                                            + 137) & 0xFE | *(_BYTE *)(a1 + 44);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 80));
    v2 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 80));
}

void nw_context_set_idle_handler(void *a1, void *a2, void *a3)
{
  id *v5;
  id v6;
  id v7;
  void *v8;
  id v9;
  id *v10;
  void *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _QWORD v22[4];
  id *v23;
  id v24;
  id v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (v5)
  {
    if (((_BYTE)v5[17] & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 3221225472;
      v22[2] = __nw_context_set_idle_handler_block_invoke;
      v22[3] = &unk_1E14A8D98;
      v23 = v5;
      v24 = v6;
      v25 = v7;
      nw_queue_context_async(v23, v22);

    }
    else
    {
      objc_storeStrong(v5 + 8, a2);
      v8 = _Block_copy(v7);
      v9 = v5[9];
      v5[9] = v8;

      v10 = (id *)v5[5];
      if (v10)
      {
        objc_storeStrong(v10 + 8, a2);
        v11 = _Block_copy(v7);
        v12 = v5[5];
        v13 = (void *)v12[9];
        v12[9] = v11;

      }
    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v29 = "nw_context_set_idle_handler";
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v15, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_context_set_idle_handler";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_context_set_idle_handler";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_context_set_idle_handler";
        _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_context_set_idle_handler";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v15)
    free(v15);
LABEL_7:

}

void sub_1833623B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void __nw_context_set_idle_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  void *v7;
  uint64_t v8;
  void *v9;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 80));
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 64), *(id *)(a1 + 40));
  v2 = _Block_copy(*(const void **)(a1 + 48));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 72);
  *(_QWORD *)(v3 + 72) = v2;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(os_unfair_lock_s **)(v5 + 40);
  if (v6)
  {
    os_unfair_lock_lock(v6 + 20);
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 64), *(id *)(a1 + 40));
    v7 = _Block_copy(*(const void **)(a1 + 48));
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
    v9 = *(void **)(v8 + 72);
    *(_QWORD *)(v8 + 72) = v7;

    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 80));
    v5 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 80));
}

void nw_context_require_encrypted_name_resolution(void *a1, uint64_t a2, void *a3)
{
  id v5;
  id v6;
  char v7;
  char v8;
  uint64_t v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _QWORD v18[4];
  id v19;
  id v20;
  char v21;
  char v22;
  os_log_type_t v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  if (!v5)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_context_require_encrypted_name_resolution";
    v11 = (char *)_os_log_send_and_compose_impl();

    v23 = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (__nwlog_fault(v11, &v23, &v22))
    {
      if (v23 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = v23;
        if (os_log_type_enabled(v12, v23))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_context_require_encrypted_name_resolution";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = v23;
        v16 = os_log_type_enabled(v12, v23);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v25 = "nw_context_require_encrypted_name_resolution";
            v26 = 2082;
            v27 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_context_require_encrypted_name_resolution";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v17 = v23;
        if (os_log_type_enabled(v12, v23))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_context_require_encrypted_name_resolution";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_30:
    if (v11)
      free(v11);
    goto LABEL_13;
  }
  v7 = *((_BYTE *)v5 + 136);
  if ((v7 & 0x48) == 0x40)
  {
    if (!dispatch_workloop_is_current())
    {
      v18[0] = MEMORY[0x1E0C809B0];
      v18[1] = 3221225472;
      v18[2] = __nw_context_require_encrypted_name_resolution_block_invoke;
      v18[3] = &unk_1E149A4D0;
      v19 = v5;
      v21 = a2;
      v20 = v6;
      nw_queue_context_async(v19, v18);

      goto LABEL_13;
    }
    v7 = *((_BYTE *)v5 + 136);
  }
  if ((_DWORD)a2)
    v8 = 0x80;
  else
    v8 = 0;
  *((_BYTE *)v5 + 136) = v8 & 0x80 | v7 & 0x7F;
  objc_storeStrong((id *)v5 + 6, a3);
  if ((*((_BYTE *)v5 + 136) & 4) != 0)
    nw_context_update_default_required_encrypted_name_resolution(a2, v6);
  v9 = *((_QWORD *)v5 + 5);
  if (v9)
  {
    *(_BYTE *)(v9 + 136) = *(_BYTE *)(v9 + 136) & 0x7F | v8;
    objc_storeStrong((id *)(*((_QWORD *)v5 + 5) + 48), a3);
  }
LABEL_13:

}

void sub_183362810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void nw_context_update_default_required_encrypted_name_resolution(uint64_t a1, void *a2)
{
  id v2;
  NSObject *v3;
  const char *v4;
  const __CFData *v5;
  const __CFData *v6;
  char v7;
  int v8;
  NSObject *v9;
  const char *string_for_dns_service_error;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = "";
    if (!v2)
      v4 = "out";
    v11 = 136446466;
    v12 = "nw_context_update_default_required_encrypted_name_resolution";
    v13 = 2080;
    v14 = v4;
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s Requiring default encrypted resolution with%s fallback config", (uint8_t *)&v11, 0x16u);
  }

  if (v2)
  {
    v5 = nw_resolver_config_copy_plist_data_ref(v2);
    v6 = v5;
    if (v5)
    {
      CFDataGetBytePtr(v5);
      CFDataGetLength(v6);
      v7 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    v6 = 0;
  }
  v7 = 1;
LABEL_10:
  v8 = DNSServiceSetResolverDefaults();
  if (v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      string_for_dns_service_error = nwlog_get_string_for_dns_service_error(v8);
      v11 = 136446466;
      v12 = "nw_context_update_default_required_encrypted_name_resolution";
      v13 = 2082;
      v14 = string_for_dns_service_error;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s DNSServiceSetResolverDefaults failed: %{public}s", (uint8_t *)&v11, 0x16u);
    }

  }
  if ((v7 & 1) == 0)
    CFRelease(v6);

}

void sub_183362A30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_context_require_encrypted_name_resolution_block_invoke(uint64_t a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 80));
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 136) = *(_BYTE *)(*(_QWORD *)(a1 + 32) + 136) & 0x7F | (*(_BYTE *)(a1 + 48) << 7);
  objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 48), *(id *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 136) & 4) != 0)
  {
    nw_context_update_default_required_encrypted_name_resolution(*(unsigned __int8 *)(a1 + 48), *(void **)(a1 + 40));
    v2 = *(_QWORD *)(a1 + 32);
  }
  v3 = *(os_unfair_lock_s **)(v2 + 40);
  if (v3)
  {
    os_unfair_lock_lock(v3 + 20);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 136) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40)
                                                                            + 136) & 0x7F | (*(_BYTE *)(a1 + 48) << 7);
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 48), *(id *)(a1 + 40));
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 80));
    v2 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 80));
}

id nw_context_copy_fallback_resolver_config(void *a1)
{
  _BYTE *v1;
  _BYTE *v2;
  char v3;
  _BOOL8 v4;
  id v5;
  _BOOL8 v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_context_copy_fallback_resolver_config";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_context_copy_fallback_resolver_config";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_context_copy_fallback_resolver_config";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_context_copy_fallback_resolver_config";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_context_copy_fallback_resolver_config";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_30:
    if (v9)
      free(v9);
    v5 = 0;
    goto LABEL_13;
  }
  v3 = v1[136];
  if ((v3 & 0x48) != 0x40)
    goto LABEL_5;
  if (dispatch_workloop_is_current())
  {
    v3 = v2[136];
LABEL_5:
    if (v3 < 0)
    {
      v5 = *((id *)v2 + 6);
    }
    else
    {
      v4 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
      v5 = *(id *)(v4 + 48);

    }
    goto LABEL_13;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v2 + 20);
  v5 = *((id *)v2 + 6);
  if (!v5)
  {
    if ((char)v2[136] < 0)
    {
      v5 = 0;
    }
    else
    {
      v6 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
      v5 = *(id *)(v6 + 48);

    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v2 + 20);
LABEL_13:

  return v5;
}

void sub_183362E38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_add_proxy(void *a1, void *a2)
{
  uint64_t *v3;
  id v4;
  void *v5;
  uint64_t v6;
  _BOOL8 v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  void *v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  _QWORD v28[4];
  uint64_t *v29;
  id v30;
  char v31;
  os_log_type_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_context_add_proxy";
    v15 = (char *)_os_log_send_and_compose_impl();

    v32 = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v15, &v32, &v31))
      goto LABEL_46;
    if (v32 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = v32;
      if (os_log_type_enabled(v16, v32))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_add_proxy";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = v32;
      v22 = os_log_type_enabled(v16, v32);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_context_add_proxy";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_46:
        if (!v15)
          goto LABEL_12;
LABEL_47:
        free(v15);
        goto LABEL_12;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_add_proxy";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = v32;
      if (os_log_type_enabled(v16, v32))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_add_proxy";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_45:

    goto LABEL_46;
  }
  if (v4)
  {
    if ((v3[17] & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      v28[0] = MEMORY[0x1E0C809B0];
      v28[1] = 3221225472;
      v28[2] = __nw_context_add_proxy_block_invoke;
      v28[3] = &unk_1E14ACE68;
      v29 = v3;
      v30 = v5;
      nw_queue_context_async(v29, v28);

    }
    else
    {
      v6 = v3[7];
      if (!v6)
      {
        v7 = nw_array_create();
        v8 = (void *)v3[7];
        v3[7] = v7;

        v6 = v3[7];
      }
      nw_array_append(v6, v5);
      v9 = v3[5];
      if (v9)
      {
        v10 = *(_QWORD *)(v9 + 56);
        if (!v10)
        {
          v11 = nw_array_create();
          v12 = v3[5];
          v13 = *(void **)(v12 + 56);
          *(_QWORD *)(v12 + 56) = v11;

          v10 = *(_QWORD *)(v3[5] + 56);
        }
        nw_array_append(v10, v5);
      }
    }
    goto LABEL_12;
  }
  __nwlog_obj();
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v34 = "nw_context_add_proxy";
  v15 = (char *)_os_log_send_and_compose_impl();

  v32 = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v15, &v32, &v31))
    goto LABEL_46;
  if (v32 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v19 = v32;
    if (os_log_type_enabled(v16, v32))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_context_add_proxy";
      _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null proxy_config", buf, 0xCu);
    }
    goto LABEL_45;
  }
  if (!v31)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v27 = v32;
    if (os_log_type_enabled(v16, v32))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_context_add_proxy";
      _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null proxy_config, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_45;
  }
  v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  v24 = v32;
  v25 = os_log_type_enabled(v16, v32);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_context_add_proxy";
      _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null proxy_config, no backtrace", buf, 0xCu);
    }
    goto LABEL_45;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    v34 = "nw_context_add_proxy";
    v35 = 2082;
    v36 = v23;
    _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null proxy_config, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v15)
    goto LABEL_47;
LABEL_12:

}

void sub_1833633D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void __nw_context_add_proxy_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _BOOL8 v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  _BOOL8 v9;
  uint64_t v10;
  void *v11;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 80));
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
  if (!v2)
  {
    v3 = nw_array_create();
    v4 = *(_QWORD *)(a1 + 32);
    v5 = *(void **)(v4 + 56);
    *(_QWORD *)(v4 + 56) = v3;

    v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
  }
  nw_array_append(v2, *(void **)(a1 + 40));
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(os_unfair_lock_s **)(v6 + 40);
  if (v7)
  {
    os_unfair_lock_lock(v7 + 20);
    v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 56);
    if (!v8)
    {
      v9 = nw_array_create();
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
      v11 = *(void **)(v10 + 56);
      *(_QWORD *)(v10 + 56) = v9;

      v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 56);
    }
    nw_array_append(v8, *(void **)(a1 + 40));
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 80));
    v6 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 80));
}

void nw_context_clear_proxies(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[4];
  _QWORD *v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[17] & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      v14[0] = MEMORY[0x1E0C809B0];
      v14[1] = 3221225472;
      v14[2] = __nw_context_clear_proxies_block_invoke;
      v14[3] = &unk_1E14ACFD0;
      v15 = v2;
      nw_queue_context_async(v15, v14);

    }
    else
    {
      v3 = (void *)v2[7];
      v2[7] = 0;

      v4 = v2[5];
      if (v4)
      {
        v5 = *(void **)(v4 + 56);
        *(_QWORD *)(v4 + 56) = 0;

      }
    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_context_clear_proxies";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_context_clear_proxies";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_context_clear_proxies";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_context_clear_proxies";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_context_clear_proxies";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v7)
    free(v7);
LABEL_7:

}

void sub_1833637D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

void __nw_context_clear_proxies_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  void *v7;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 80));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void **)(v2 + 56);
  *(_QWORD *)(v2 + 56) = 0;

  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(os_unfair_lock_s **)(v4 + 40);
  if (v5)
  {
    os_unfair_lock_lock(v5 + 20);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
    v7 = *(void **)(v6 + 56);
    *(_QWORD *)(v6 + 56) = 0;

    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 80));
    v4 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 80));
}

_QWORD *nw_context_copy_proxy_configs(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _QWORD *v3;
  _QWORD *v4;
  _BOOL8 v5;
  _QWORD *v6;
  _BOOL8 v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[34]._os_unfair_lock_opaque & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      os_unfair_lock_lock(v2 + 20);
      v6 = *(_QWORD **)&v2[14]._os_unfair_lock_opaque;
      if (!v6 || v6[2] == v6[3])
      {
        v7 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
        v4 = *(id *)(v7 + 56);

      }
      else
      {
        v4 = v6;
      }
      os_unfair_lock_unlock(v2 + 20);
    }
    else
    {
      v3 = *(_QWORD **)&v2[14]._os_unfair_lock_opaque;
      if (!v3 || v3[2] == v3[3])
      {
        v5 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
        v4 = *(id *)(v5 + 56);

      }
      else
      {
        v4 = v3;
      }
    }
    goto LABEL_13;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_context_copy_proxy_configs";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_context_copy_proxy_configs";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_context_copy_proxy_configs";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_context_copy_proxy_configs";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_context_copy_proxy_configs";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_30:
  if (v10)
    free(v10);
  v4 = 0;
LABEL_13:

  return v4;
}

void sub_183363BA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_enumerate_proxy_configs(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  unsigned __int8 *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD v21[4];
  id v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_context_enumerate_proxy_configs";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_context_enumerate_proxy_configs";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_context_enumerate_proxy_configs";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_context_enumerate_proxy_configs";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_context_enumerate_proxy_configs";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v6 = (unsigned __int8 *)nw_context_copy_proxy_configs(v3);
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = __nw_context_enumerate_proxy_configs_block_invoke;
    v21[3] = &unk_1E14AC278;
    v22 = v5;
    nw_array_apply(v6, (uint64_t)v21);

    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_context_enumerate_proxy_configs";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_context_enumerate_proxy_configs";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null enumerator", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_context_enumerate_proxy_configs";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null enumerator, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_context_enumerate_proxy_configs";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerator, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_context_enumerate_proxy_configs";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerator, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

void sub_1833640BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_context_enumerate_proxy_configs_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void nw_context_set_isolate_protocol_stack(void *a1, char a2)
{
  _BYTE *v3;
  _BYTE *v4;
  char v5;
  NSObject *v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_context_set_isolate_protocol_stack";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_context_set_isolate_protocol_stack";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_context_set_isolate_protocol_stack";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_context_set_isolate_protocol_stack";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_context_set_isolate_protocol_stack";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_23:
    if (v9)
      free(v9);
    goto LABEL_6;
  }
  v5 = v3[136];
  if ((v5 & 0x40) == 0)
  {
LABEL_5:
    v4[136] = v5 & 0xFE | a2;
LABEL_6:

    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v19 = "nw_context_set_isolate_protocol_stack";
  v7 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v7))
  {
    free(v7);
    v5 = v4[136];
    goto LABEL_5;
  }
  __break(1u);
}

void nw_context_set_scheduling_mode(void *a1, int a2)
{
  _DWORD *v3;
  _DWORD *v4;
  NSObject *v5;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_context_set_scheduling_mode";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_context_set_scheduling_mode";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_context_set_scheduling_mode";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_context_set_scheduling_mode";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_context_set_scheduling_mode";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_23:
    if (v8)
      free(v8);
    goto LABEL_6;
  }
  if ((v3[34] & 0x40) == 0)
  {
LABEL_5:
    v4[30] = a2;
LABEL_6:

    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v18 = "nw_context_set_scheduling_mode";
  v6 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    goto LABEL_5;
  }
  __break(1u);
}

void nw_context_set_protocol_cache_limits(void *a1, int a2, int a3, int a4)
{
  _DWORD *v7;
  _DWORD *v8;
  NSObject *v9;
  void *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_context_set_protocol_cache_limits";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_context_set_protocol_cache_limits";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_context_set_protocol_cache_limits";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_context_set_protocol_cache_limits";
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_context_set_protocol_cache_limits";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_23:
    if (v12)
      free(v12);
    goto LABEL_6;
  }
  if ((v7[34] & 0x40) == 0)
  {
LABEL_5:
    v8[21] = a2;
    v8[22] = a3;
    v8[23] = a4;
LABEL_6:

    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v22 = "nw_context_set_protocol_cache_limits";
  v10 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v10))
  {
    free(v10);
    goto LABEL_5;
  }
  __break(1u);
}

uint64_t nw_context_get_scheduling_mode(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[30];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_context_get_scheduling_mode";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_scheduling_mode";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_context_get_scheduling_mode";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_scheduling_mode";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_scheduling_mode";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_context_get_isolate_protocol_stack(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 136) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_context_get_isolate_protocol_stack";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_isolate_protocol_stack";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_context_get_isolate_protocol_stack";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_isolate_protocol_stack";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_isolate_protocol_stack";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_context_get_sensitive_redacted(void *a1)
{
  id v1;
  void *v2;
  int v3;
  _BOOL8 v4;

  v1 = a1;
  v2 = v1;
  if (v1 && (v3 = *((_DWORD *)v1 + 31), (v3 - 2) >= 2))
  {
    v4 = v3 != 1;
  }
  else
  {
    if (nwlog_get_sensitive_redacted::onceToken != -1)
      dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
    v4 = nwlog_get_sensitive_redacted::sensitiveRedacted != 0;
  }

  return v4;
}

void nw_context_set_tracker_lookup_callback(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    v6 = _Block_copy(v4);
    v7 = (void *)v3[16];
    v3[16] = v6;

    if (v3[5])
    {
      v8 = _Block_copy(v5);
      v9 = v3[5];
      v10 = *(void **)(v9 + 128);
      *(_QWORD *)(v9 + 128) = v8;

    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_context_set_tracker_lookup_callback";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_context_set_tracker_lookup_callback";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_context_set_tracker_lookup_callback";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_context_set_tracker_lookup_callback";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_context_set_tracker_lookup_callback";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v12)
    free(v12);
LABEL_4:

}

void ___ZL28nw_context_start_purge_timerP21NWConcrete_nw_context_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t globals_for_channel;
  os_unfair_lock_s *v4;
  uint64_t v5;
  unsigned __int8 *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  os_log_type_t type[8];
  os_log_type_t *v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  _BYTE buf[24];
  void *v20;
  os_log_type_t *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    globals_for_channel = nw_context_get_globals_for_channel(v2);
    v4 = (os_unfair_lock_s *)(globals_for_channel + 16);
    os_unfair_lock_lock((os_unfair_lock_t)(globals_for_channel + 16));
    v5 = *(_QWORD *)globals_for_channel;
    if (*(_QWORD *)globals_for_channel)
    {
      *(_QWORD *)type = 0;
      v15 = type;
      v16 = 0x2000000000;
      v17 = 0;
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __nw_channel_purge_idle_block_invoke;
      v20 = &unk_1E14AC950;
      v21 = type;
      nw_dictionary_apply(v5, (uint64_t)buf);
      os_unfair_lock_unlock(v4);
      v6 = (unsigned __int8 *)*((_QWORD *)v15 + 3);
      if (v6)
      {
        nw_array_apply(v6, (uint64_t)&__block_literal_global_86304);
        v7 = (void *)*((_QWORD *)v15 + 3);
        if (v7)
        {
          os_release(v7);
          *((_QWORD *)v15 + 3) = 0;
        }
      }
      _Block_object_dispose(type, 8);
    }
    else
    {
      os_unfair_lock_unlock(v4);
    }
    goto LABEL_8;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_channel_purge_idle";
  v8 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v8, type, &v18))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_23;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_purge_idle";
      v11 = "%{public}s called with null context";
      goto LABEL_22;
    }
    if (!v18)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_23;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_purge_idle";
      v11 = "%{public}s called with null context, backtrace limit exceeded";
      goto LABEL_22;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type[0];
    v13 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_channel_purge_idle";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_23;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_purge_idle";
      v11 = "%{public}s called with null context, no backtrace";
LABEL_22:
      _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    }
  }
LABEL_23:
  if (v8)
    free(v8);
LABEL_8:
  nw_context_purge_endpoints(*(NWConcrete_nw_context **)(a1 + 32), 0);
}

uint64_t nw_context_endpoint_matches_key(void *a1, void *a2)
{
  return nw_endpoint_is_equal(a1, a2, 31);
}

uint64_t nw_context_get_cache_count(void *a1)
{
  dispatch_queue_t *v1;
  dispatch_queue_t *v2;
  _BOOL8 v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = v1;
    if (((_BYTE)v1[17] & 8) == 0)
      dispatch_assert_queue_V2(v1[1]);
    v3 = nw_context_copy_cache_context(v2);

    v4 = *(unsigned int *)(*(_QWORD *)(v3 + 24) + 68);
    return v4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_context_get_cache_count";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_get_cache_count";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_context_get_cache_count";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_get_cache_count";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_get_cache_count";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v7)
    free(v7);
  return 0;
}

void sub_183365940(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_set_association_dormant_delay(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_context_set_association_dormant_delay";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_context_set_association_dormant_delay";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_context_set_association_dormant_delay";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_context_set_association_dormant_delay";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_context_set_association_dormant_delay";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  v5 = *((_QWORD *)v3 + 5);
  if (v5)
  {
    *(_QWORD *)(v5 + 96) = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_context_set_association_dormant_delay";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_context_set_association_dormant_delay";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context->isolated_context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_context_set_association_dormant_delay";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null context->isolated_context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_context_set_association_dormant_delay";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null context->isolated_context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_context_set_association_dormant_delay";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null context->isolated_context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

uint64_t nw_context_get_context_purge_delay(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 13);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_context_get_context_purge_delay";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_context_purge_delay";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_context_get_context_purge_delay";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_context_purge_delay";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_context_purge_delay";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_context_set_context_purge_delay(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_context_set_context_purge_delay";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_context_set_context_purge_delay";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_context_set_context_purge_delay";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_context_set_context_purge_delay";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_context_set_context_purge_delay";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  v5 = *((_QWORD *)v3 + 5);
  if (v5)
  {
    *(_QWORD *)(v5 + 104) = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_context_set_context_purge_delay";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_context_set_context_purge_delay";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context->isolated_context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_context_set_context_purge_delay";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null context->isolated_context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_context_set_context_purge_delay";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null context->isolated_context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_context_set_context_purge_delay";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null context->isolated_context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

void nw_context_cleanup_timer(NWConcrete_nw_context *a1)
{
  NWConcrete_nw_context *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  int v8;
  _QWORD *v9;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  void *v13;

  v1 = a1;
  v2 = *((_QWORD *)v1 + 4);
  v3 = *(_QWORD *)(v2 + 8);
  v5 = nw_hash_table_count(*(_QWORD *)(v2 + 24), v4);
  if (v3)
    v7 = (_DWORD)v5 == 0;
  else
    v7 = 1;
  if (!v7)
  {
LABEL_11:

    return;
  }
  v8 = v5;
  if (v3)
  {
    __nwlog_obj(v5, v6);
    v10 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    v11 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v11))
      goto LABEL_16;
    free(v11);
    if (!v8)
      goto LABEL_8;
  }
  else if (!(_DWORD)v5)
  {
LABEL_8:
    v9 = (_QWORD *)*((_QWORD *)v1 + 4);
    if (*v9)
    {
      nw_queue_cancel_source(*v9, v6);
      **((_QWORD **)v1 + 4) = 0;
      v9 = (_QWORD *)*((_QWORD *)v1 + 4);
    }
    v9[4] = -1;
    goto LABEL_11;
  }
  __nwlog_obj(v5, v6);
  v12 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  v13 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v13))
  {
    free(v13);
    goto LABEL_8;
  }
LABEL_16:
  __break(1u);
}

void sub_183366708(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_reset_timer_block(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  dispatch_time_t v8;
  id v9;

  v9 = a1;
  v7 = a4;
  if (a3 == -1)
    v8 = -1;
  else
    v8 = dispatch_time(0x8000000000000000, 1000000 * a3);
  nw_context_reset_timer_block_with_time(v9, a2, v8, v7);

}

void sub_1833667A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t nw_context_1024k_buffer_manager(void *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = v1;
    v3 = nw_context_copy_globals_context(v1);

    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 132);
    if (!v4)
    {
      *(_QWORD *)(*(_QWORD *)(v3 + 32) + 132) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe_4, dword_1EDCDF468, (unsigned __int16)word_1EDCDF46C);
      v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 132);
    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_context_1024k_buffer_manager";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_1024k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_context_1024k_buffer_manager";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_1024k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_1024k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  v3 = 0;
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_183366A84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_context_1024k_buffer_length()
{
  return dword_1EDCDF468;
}

uint64_t nw_context_512k_buffer_manager(void *a1)
{
  NWConcrete_nw_context *v1;
  NWConcrete_nw_context *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = v1;
    v3 = nw_context_copy_globals_context(v1);

    v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 140);
    if (!v4)
    {
      *(_QWORD *)(*(_QWORD *)(v3 + 32) + 140) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe_5, dword_1EDCDF420, (unsigned __int16)word_1EDCDF424);
      v4 = *(_QWORD *)(*(_QWORD *)(v3 + 32) + 140);
    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_context_512k_buffer_manager";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_512k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_context_512k_buffer_manager";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_512k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_context_512k_buffer_manager";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  v3 = 0;
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_183366D6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_context_512k_buffer_length()
{
  return dword_1EDCDF420;
}

void nw_context_set_input_byte_cap(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  void *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  os_log_type_t v28;
  os_log_type_t v29;
  _QWORD v30[4];
  id v31;
  id v32;
  id v33;
  uint64_t v34;
  char v35;
  os_log_type_t v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a3;
  v9 = a4;
  v10 = v9;
  if (!v7)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_context_set_input_byte_cap";
    v12 = (char *)_os_log_send_and_compose_impl();

    v36 = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v12, &v36, &v35))
      goto LABEL_55;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null requested_context", buf, 0xCu);
      }
    }
    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v20 = v36;
      v21 = os_log_type_enabled(v13, v36);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v38 = "nw_context_set_input_byte_cap";
          v39 = 2082;
          v40 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null requested_context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v12)
          goto LABEL_5;
LABEL_56:
        free(v12);
        goto LABEL_5;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null requested_context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v27 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v27, "%{public}s called with null requested_context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v8)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_context_set_input_byte_cap";
    v12 = (char *)_os_log_send_and_compose_impl();

    v36 = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v12, &v36, &v35))
      goto LABEL_55;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null queue", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v35)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v28 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v28, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v23 = v36;
    v24 = os_log_type_enabled(v13, v36);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_context_set_input_byte_cap";
      v39 = 2082;
      v40 = v22;
      _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v9)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_context_set_input_byte_cap";
    v12 = (char *)_os_log_send_and_compose_impl();

    v36 = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v12, &v36, &v35))
      goto LABEL_55;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null cap_exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v35)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v29 = v36;
      if (os_log_type_enabled(v13, v36))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v29, "%{public}s called with null cap_exceeded, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v25 = v36;
    v26 = os_log_type_enabled(v13, v36);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_context_set_input_byte_cap";
        _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null cap_exceeded, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "nw_context_set_input_byte_cap";
      v39 = 2082;
      v40 = v22;
      _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null cap_exceeded, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v22);
    if (!v12)
      goto LABEL_5;
    goto LABEL_56;
  }
  v30[0] = MEMORY[0x1E0C809B0];
  v30[1] = 3221225472;
  v30[2] = __nw_context_set_input_byte_cap_block_invoke;
  v30[3] = &unk_1E14A5300;
  v31 = v7;
  v34 = a2;
  v32 = v8;
  v33 = v10;
  nw_queue_context_async_if_needed(v31, v30);

LABEL_5:
}

void sub_1833674D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void __nw_context_set_input_byte_cap_block_invoke(uint64_t a1)
{
  _BOOL8 v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int v10;
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = nw_context_copy_globals_context(*(NWConcrete_nw_context **)(a1 + 32));
  v3 = *(_QWORD *)(v2 + 32);
  if (*(_QWORD *)(v3 + 76))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *(_QWORD *)(*(_QWORD *)(v2 + 32) + 76);
      v6 = *(_QWORD *)(a1 + 56);
      v10 = 136446722;
      v11 = "nw_context_set_input_byte_cap_block_invoke";
      v12 = 2048;
      v13 = v5;
      v14 = 2048;
      v15 = v6;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s Context already has input byte cap of %llu bytes, ignoring request to cap at %llu bytes", (uint8_t *)&v10, 0x20u);
    }

  }
  else
  {
    g_some_context_has_cap = 1;
    *(_QWORD *)(v3 + 76) = *(_QWORD *)(a1 + 56);
    objc_storeStrong((id *)(v3 + 84), *(id *)(a1 + 40));
    v7 = _Block_copy(*(const void **)(a1 + 48));
    v8 = *(_QWORD *)(v2 + 32);
    v9 = *(void **)(v8 + 92);
    *(_QWORD *)(v8 + 92) = v7;

  }
}

void sub_183369ECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18336A084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18336A208(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  id *v3;
  uint64_t v4;

  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v4 - 72));
  _Unwind_Resume(a1);
}

void sub_18336A24C()
{
  JUMPOUT(0x18336A23CLL);
}

void sub_18336A4D4(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_18336A978(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18336BAE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_18336BDA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1673(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1674(uint64_t a1)
{

}

void sub_18336C3C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

void sub_18336CF5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_18336EA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

void sub_18336F800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183370DA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_ethernet_channel;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__1943(uint64_t a1, uint64_t a2)
{
  void *result;

  result = _Block_copy(*(const void **)(a2 + 40));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__1944(uint64_t a1)
{

}

void sub_183371DC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183373E04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183375344(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_ethernet_channel_cancel(nw_ethernet_channel_t ethernet_channel)
{
  nw_ethernet_channel_t v1;
  uint64_t v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = ethernet_channel;
  v2 = (uint64_t)v1;
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v1[1]);
    if (*(_BYTE *)(v2 + 112))
    {
      *(_BYTE *)(v2 + 114) = 1;
    }
    else if (!*(_BYTE *)(v2 + 113))
    {
      *(_WORD *)(v2 + 113) = 1;
      -[NWConcrete_nw_ethernet_channel updateClientState:error:](v2, 5, 0);
      -[NWConcrete_nw_ethernet_channel close](v2);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
    goto LABEL_7;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_ethernet_channel_cancel";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_ethernet_channel_cancel";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_ethernet_channel_cancel";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_ethernet_channel_cancel";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_ethernet_channel_cancel";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v4)
    free(v4);
LABEL_7:

}

void sub_183375654(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_ethernet_channel_t nw_ethernet_channel_create(uint16_t ether_type, nw_interface_t interface)
{
  NSObject *v3;
  unsigned __int16 *v4;
  NSObject *v5;
  unsigned __int16 *v6;

  v3 = interface;
  v4 = -[NWConcrete_nw_ethernet_channel initWithEtherType:interface:parameters:]([NWConcrete_nw_ethernet_channel alloc], ether_type, v3, 0);
  v5 = v4;
  if (v4)
    v6 = v4;

  return v5;
}

void sub_1833756C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_ethernet_channel_t nw_ethernet_channel_create_with_parameters(uint16_t ether_type, nw_interface_t interface, nw_parameters_t parameters)
{
  NSObject *v5;
  NSObject *v6;
  unsigned __int16 *v7;
  NSObject *v8;
  unsigned __int16 *v9;

  v5 = interface;
  v6 = parameters;
  v7 = -[NWConcrete_nw_ethernet_channel initWithEtherType:interface:parameters:]([NWConcrete_nw_ethernet_channel alloc], ether_type, v5, v6);
  v8 = v7;
  if (v7)
    v9 = v7;

  return v8;
}

void sub_183375740(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_ethernet_channel_set_state_changed_handler(nw_ethernet_channel_t ethernet_channel, nw_ethernet_channel_state_changed_handler_t handler)
{
  nw_ethernet_channel_t v3;
  nw_ethernet_channel_state_changed_handler_t v4;
  void *v5;
  objc_class *v6;
  Class isa;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = ethernet_channel;
  v4 = handler;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_ethernet_channel_set_state_changed_handler";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_ethernet_channel_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_ethernet_channel_set_state_changed_handler";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9)
          goto LABEL_6;
LABEL_41:
        free(v9);
        goto LABEL_6;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_ethernet_channel_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_ethernet_channel_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    if (!BYTE1(v3[14].isa))
    {
      v6 = (objc_class *)_Block_copy(v5);
      isa = v3[6].isa;
      v3[6].isa = v6;

    }
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
    goto LABEL_6;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_ethernet_channel_set_state_changed_handler";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_ethernet_channel_set_state_changed_handler";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null handler", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_ethernet_channel_set_state_changed_handler";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_ethernet_channel_set_state_changed_handler";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_ethernet_channel_set_state_changed_handler";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_41;
LABEL_6:

}

void nw_ethernet_channel_set_queue(nw_ethernet_channel_t ethernet_channel, dispatch_queue_t queue)
{
  nw_ethernet_channel_t v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = ethernet_channel;
  v4 = queue;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_ethernet_channel_set_queue";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_ethernet_channel_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_ethernet_channel_set_queue";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v7)
          goto LABEL_6;
LABEL_41:
        free(v7);
        goto LABEL_6;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_ethernet_channel_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_ethernet_channel_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    if (!BYTE1(v3[14].isa))
      objc_storeStrong((id *)&v3[5].isa, queue);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
    goto LABEL_6;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_ethernet_channel_set_queue";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_ethernet_channel_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v20)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_ethernet_channel_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_ethernet_channel_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_ethernet_channel_set_queue";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_41;
LABEL_6:

}

uint32_t nw_ethernet_channel_get_maximum_payload_size(nw_ethernet_channel_t ethernet_channel)
{
  nw_ethernet_channel_t v1;
  nw_ethernet_channel_t v2;
  uint32_t v3;
  Class isa;
  objc_class *v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = ethernet_channel;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v1[1]);
    if (BYTE1(v2[14].isa) || (isa = v2[2].isa) == 0)
    {
      v3 = 0;
    }
    else
    {
      v5 = isa;
      v3 = *((_DWORD *)v5 + 15);

    }
    os_unfair_lock_unlock((os_unfair_lock_t)&v2[1]);
    goto LABEL_7;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_ethernet_channel_get_maximum_payload_size";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_ethernet_channel_get_maximum_payload_size";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_ethernet_channel_get_maximum_payload_size";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_ethernet_channel_get_maximum_payload_size";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_ethernet_channel_get_maximum_payload_size";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v8)
    free(v8);
  v3 = 0;
LABEL_7:

  return v3;
}

void nw_ethernet_channel_start(nw_ethernet_channel_t ethernet_channel)
{
  nw_ethernet_channel_t v1;
  nw_ethernet_channel_t v2;
  Class isa;
  uint64_t v4;
  id *v5;
  id v6;
  id *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _QWORD v16[4];
  id *v17;
  _QWORD v18[4];
  id *v19;
  char v20;
  os_log_type_t v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = ethernet_channel;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v1[1]);
    if (!BYTE1(v2[14].isa))
    {
      isa = v2[9].isa;
      v4 = MEMORY[0x1E0C809B0];
      v18[0] = MEMORY[0x1E0C809B0];
      v18[1] = 3221225472;
      v18[2] = __nw_ethernet_channel_start_block_invoke;
      v18[3] = &unk_1E14AC2C8;
      v5 = v2;
      v19 = v5;
      nw_path_evaluator_set_update_handler(isa, 0, v18);
      v6 = v5[8];
      if (!v6)
      {
        if (nw_context_copy_implicit_context::onceToken[0] != -1)
          dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
        v6 = (id)nw_context_copy_implicit_context::implicit_context;
      }
      v16[0] = v4;
      v16[1] = 3221225472;
      v16[2] = __nw_ethernet_channel_start_block_invoke_6;
      v16[3] = &unk_1E14ACFD0;
      v7 = v5;
      v17 = v7;
      nw_queue_context_async(v6, v16);
      -[NWConcrete_nw_ethernet_channel updateClientState:error:]((uint64_t)v7, 1, 0);
      os_unfair_lock_unlock((os_unfair_lock_t)&v2[1]);

    }
    goto LABEL_8;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_ethernet_channel_start";
  v9 = (char *)_os_log_send_and_compose_impl();

  v21 = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &v21, &v20))
  {
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_ethernet_channel_start";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = v21;
      v14 = os_log_type_enabled(v10, v21);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_ethernet_channel_start";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_ethernet_channel_start";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = v21;
      if (os_log_type_enabled(v10, v21))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_ethernet_channel_start";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_25:
  if (v9)
    free(v9);
LABEL_8:

}

void sub_183376760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  void *v23;
  void *v24;

  _Unwind_Resume(a1);
}

void __nw_ethernet_channel_start_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  _BYTE v19[14];
  __int16 v20;
  int v21;
  __int16 v22;
  id v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = *(_QWORD *)(a1 + 32);
  if (v4 && *(_QWORD *)(v4 + 152))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      goto LABEL_8;
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(_QWORD *)(v6 + 24);
    v8 = v6 + 115;
    LODWORD(v6) = *(_DWORD *)(v6 + 168);
    v14 = 136447490;
    v15 = "nw_ethernet_channel_start_block_invoke";
    v16 = 2080;
    v17 = v7;
    v18 = 1042;
    *(_DWORD *)v19 = 16;
    *(_WORD *)&v19[4] = 2098;
    *(_QWORD *)&v19[6] = v8;
    v20 = 1024;
    v21 = v6;
    v22 = 2114;
    v23 = v3;
    v9 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Handling new path %{public}@";
    v10 = v5;
    v11 = 54;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      goto LABEL_8;
    v12 = *(_QWORD *)(a1 + 32);
    v14 = 136446722;
    v15 = "nw_ethernet_channel_start_block_invoke";
    v16 = 2114;
    v17 = v12;
    v18 = 2114;
    *(_QWORD *)v19 = v3;
    v9 = "%{public}s [%{public}@] Handling new path %{public}@";
    v10 = v5;
    v11 = 32;
  }
  _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, v9, (uint8_t *)&v14, v11);
LABEL_8:

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  v13 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v13 + 113))
  {
    nw_ethernet_channel_handle_path_update_locked((void *)v13, v3);
    v13 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v13 + 8));

}

void sub_183376980(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_ethernet_channel_start_block_invoke_6(uint64_t a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  id *v5;
  id v6;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 113))
  {
    v3 = *(os_unfair_lock_s **)(v2 + 72);
    if (v3)
    {
      v4 = v3 + 24;
      v5 = v3;
      os_unfair_lock_lock(v4);
      v6 = v5[6];
      os_unfair_lock_unlock(v4);

    }
    else
    {
      v6 = 0;
    }
    nw_ethernet_channel_handle_path_update_locked((void *)v2, v6);

    v2 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
}

void sub_183376A30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_ethernet_channel_handle_path_update_locked(void *a1, void *a2)
{
  char *v3;
  NSObject *v4;
  uint64_t v5;
  id *v6;
  id v7;
  id *v8;
  unsigned __int8 *v9;
  id v10;
  NSObject *v11;
  _BOOL4 v12;
  uint64_t v13;
  NSObject *v14;
  id *v15;
  int v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  void *v20;
  void *v21;
  id *v22;
  uint64_t v23;
  int v24;
  id *v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  _QWORD v29[4];
  id *v30;
  _QWORD v31[4];
  id *v32;
  _QWORD v33[4];
  id *v34;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  id *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_path_get_status(v4) == nw_path_status_satisfied)
  {
    v5 = MEMORY[0x1E0C809B0];
    v33[0] = MEMORY[0x1E0C809B0];
    v33[1] = 3221225472;
    v33[2] = ___ZL45nw_ethernet_channel_handle_path_update_lockedP30NWConcrete_nw_ethernet_channelPU21objcproto10OS_nw_path8NSObject_block_invoke;
    v33[3] = &unk_1E149CD80;
    v6 = v3;
    v34 = v6;
    nw_path_enumerate_interface_options(v4, v33);
    v7 = v6[8];
    if (!v7)
    {
      if (nw_context_copy_implicit_context::onceToken[0] != -1)
        dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      v7 = (id)nw_context_copy_implicit_context::implicit_context;
    }
    v31[0] = v5;
    v31[1] = 3221225472;
    v31[2] = ___ZL45nw_ethernet_channel_handle_path_update_lockedP30NWConcrete_nw_ethernet_channelPU21objcproto10OS_nw_path8NSObject_block_invoke_126;
    v31[3] = &unk_1E14ACFD0;
    v8 = v6;
    v32 = v8;
    nw_queue_context_async(v7, v31);
    v9 = (unsigned __int8 *)nw_path_copy_flows(v4);
    v10 = v8[19];
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
    if (v10)
    {
      if (v12)
      {
        if (v9)
          v13 = (*((_QWORD *)v9 + 3) - *((_QWORD *)v9 + 2)) >> 3;
        else
          LODWORD(v13) = 0;
        v24 = *((_DWORD *)v8 + 42);
        v25 = (id *)v8[3];
        *(_DWORD *)buf = 136447490;
        v36 = "nw_ethernet_channel_handle_path_update_locked";
        v37 = 2080;
        v38 = v25;
        v39 = 1042;
        v40 = 16;
        v41 = 2098;
        v42 = (char *)v8 + 115;
        v43 = 1024;
        v44 = v24;
        v45 = 1024;
        v46 = v13;
        v26 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: got %d flows from path";
        v27 = v11;
        v28 = 50;
LABEL_31:
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, v26, buf, v28);
      }
    }
    else if (v12)
    {
      if (v9)
        v23 = (*((_QWORD *)v9 + 3) - *((_QWORD *)v9 + 2)) >> 3;
      else
        LODWORD(v23) = 0;
      *(_DWORD *)buf = 136446722;
      v36 = "nw_ethernet_channel_handle_path_update_locked";
      v37 = 2114;
      v38 = v8;
      v39 = 1024;
      v40 = v23;
      v26 = "%{public}s [%{public}@] Ethernet Channel handle update: got %d flows from path";
      v27 = v11;
      v28 = 28;
      goto LABEL_31;
    }

    v29[0] = v5;
    v29[1] = 3221225472;
    v29[2] = ___ZL45nw_ethernet_channel_handle_path_update_lockedP30NWConcrete_nw_ethernet_channelPU21objcproto10OS_nw_path8NSObject_block_invoke_127;
    v29[3] = &unk_1E14AC200;
    v30 = v8;
    nw_array_apply(v9, (uint64_t)v29);

    v22 = v34;
    goto LABEL_33;
  }
  if (v3 && *((_QWORD *)v3 + 19))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      goto LABEL_17;
    v15 = (id *)*((_QWORD *)v3 + 3);
    v16 = *((_DWORD *)v3 + 42);
    *(_DWORD *)buf = 136447234;
    v36 = "nw_ethernet_channel_handle_path_update_locked";
    v37 = 2080;
    v38 = v15;
    v39 = 1042;
    v40 = 16;
    v41 = 2098;
    v42 = v3 + 115;
    v43 = 1024;
    v44 = v16;
    v17 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel - path not satisfied, closing flow";
    v18 = v14;
    v19 = 44;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      goto LABEL_17;
    *(_DWORD *)buf = 136446466;
    v36 = "nw_ethernet_channel_handle_path_update_locked";
    v37 = 2114;
    v38 = (id *)v3;
    v17 = "%{public}s [%{public}@] Ethernet Channel - path not satisfied, closing flow";
    v18 = v14;
    v19 = 22;
  }
  _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, v17, buf, v19);
LABEL_17:

  v20 = (void *)*((_QWORD *)v3 + 10);
  if (v20)
  {
    nw_path_flow_registration_close(v20);
    v21 = (void *)*((_QWORD *)v3 + 10);
    *((_QWORD *)v3 + 10) = 0;

  }
  if (*((_QWORD *)v3 + 11))
    -[NWConcrete_nw_ethernet_channel closeChannel:]((uint64_t)v3, 0);
  v22 = (id *)*((_QWORD *)v3 + 2);
  if (!v22 || !*((_DWORD *)v22 + 2))
  {
    *((_QWORD *)v3 + 2) = 0;
LABEL_33:

  }
}

void sub_183376EC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL45nw_ethernet_channel_handle_path_update_lockedP30NWConcrete_nw_ethernet_channelPU21objcproto10OS_nw_path8NSObject_block_invoke(uint64_t a1, void *a2, const unsigned __int8 *a3, void *a4)
{
  _DWORD *v8;
  id v9;
  uint64_t v10;
  id *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _DWORD *v21;
  uint64_t v22;
  NSObject *v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  _DWORD *v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  const char *v39;
  NSObject *v40;
  uint32_t v41;
  int v42;
  int v43;
  int is_null;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  _DWORD *v55;
  uint64_t v56;
  _DWORD *v57;
  int v58;
  const char *v59;
  NSObject *v60;
  uint32_t v61;
  int v62;
  int v63;
  uint64_t v64;
  void *v65;
  unsigned __int8 *v66;
  unsigned __int8 *v67;
  _BOOL4 v68;
  NSObject *v69;
  _DWORD *v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  const char *v74;
  NSObject *v75;
  uint32_t v76;
  _DWORD *v77;
  uint64_t v78;
  NWConcrete_nw_path_flow_registration *v79;
  uint64_t v80;
  void *v81;
  uint64_t v82;
  NSObject *v83;
  _DWORD *v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  const char *v88;
  NSObject *v89;
  os_log_type_t v90;
  uint32_t v91;
  _DWORD *v92;
  uint64_t v93;
  _DWORD *v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  _DWORD *v98;
  uint64_t v99;
  NSObject *v100;
  _DWORD *v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  _DWORD *v105;
  uint64_t v106;
  __int128 v107;
  uint8_t buf[4];
  const char *v109;
  __int16 v110;
  uint64_t v111;
  __int16 v112;
  _BYTE v113[14];
  __int16 v114;
  _BYTE v115[20];
  __int16 v116;
  _BYTE v117[14];
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v8 = a2;
  v9 = a4;
  v10 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(v10 + 16);
  v11 = (id *)(v10 + 16);
  v12 = v13;
  if (!v13)
  {
    objc_storeStrong(v11, a2);
    v15 = *(_QWORD *)(a1 + 32);
    if (v15 && *(_QWORD *)(v15 + 152))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v17 = *(_QWORD *)(a1 + 32);
        v18 = *(_QWORD *)(v17 + 24);
        v19 = v17 + 115;
        v20 = *(_DWORD *)(v17 + 168);
        v21 = v8 + 26;
        if (v8)
        {
          v43 = v8[2];
        }
        else
        {
          v21 = 0;
          v43 = 0;
        }
        *(_DWORD *)buf = 136447746;
        v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
        v110 = 2080;
        v111 = v18;
        v112 = 1042;
        *(_DWORD *)v113 = 16;
        *(_WORD *)&v113[4] = 2098;
        *(_QWORD *)&v113[6] = v19;
        v114 = 1024;
        *(_DWORD *)v115 = v20;
        *(_WORD *)&v115[4] = 2080;
        *(_QWORD *)&v115[6] = v21;
        *(_WORD *)&v115[14] = 1024;
        *(_DWORD *)&v115[16] = v43;
        v39 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: updating inte"
              "rface to %s (idx %d)";
        v40 = v16;
        v41 = 60;
LABEL_35:
        _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_DEBUG, v39, buf, v41);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v32 = *(_QWORD *)(a1 + 32);
        v33 = v8 + 26;
        if (v8)
        {
          v38 = v8[2];
        }
        else
        {
          v33 = 0;
          v38 = 0;
        }
        *(_DWORD *)buf = 136446978;
        v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
        v110 = 2114;
        v111 = v32;
        v112 = 2080;
        *(_QWORD *)v113 = v33;
        *(_WORD *)&v113[8] = 1024;
        *(_DWORD *)&v113[10] = v38;
        v39 = "%{public}s [%{public}@] Ethernet Channel handle update: updating interface to %s (idx %d)";
        v40 = v16;
        v41 = 38;
        goto LABEL_35;
      }
    }

    goto LABEL_37;
  }
  v14 = *(_DWORD *)(v12 + 8);
  if (!v8)
  {
    if (!v14)
      goto LABEL_37;
LABEL_12:
    v22 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 152);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (id)gLogObj;
    v24 = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    if (v22)
    {
      if (v24)
      {
        v25 = *(_QWORD *)(a1 + 32);
        v26 = v25 + 115;
        v27 = *(_QWORD *)(v25 + 16);
        v28 = v27 + 104;
        if (v27)
          LODWORD(v27) = *(_DWORD *)(v27 + 8);
        else
          v28 = 0;
        v29 = *(_QWORD *)(v25 + 24);
        v30 = *(_DWORD *)(v25 + 168);
        v31 = v8 + 26;
        if (v8)
        {
          v42 = v8[2];
        }
        else
        {
          v31 = 0;
          v42 = 0;
        }
        *(_DWORD *)buf = 136448258;
        v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
        v110 = 2080;
        v111 = v29;
        v112 = 1042;
        *(_DWORD *)v113 = 16;
        *(_WORD *)&v113[4] = 2098;
        *(_QWORD *)&v113[6] = v26;
        v114 = 1024;
        *(_DWORD *)v115 = v30;
        *(_WORD *)&v115[4] = 2080;
        *(_QWORD *)&v115[6] = v28;
        *(_WORD *)&v115[14] = 1024;
        *(_DWORD *)&v115[16] = v27;
        v116 = 2080;
        *(_QWORD *)v117 = v31;
        *(_WORD *)&v117[8] = 1024;
        *(_DWORD *)&v117[10] = v42;
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: mismatched interface %s (idx %d) != %s (idx %d)", buf, 0x4Cu);
      }
    }
    else if (v24)
    {
      v34 = *(_QWORD *)(a1 + 32);
      v35 = *(_QWORD *)(v34 + 16);
      v36 = v35 + 104;
      if (v35)
        LODWORD(v35) = *(_DWORD *)(v35 + 8);
      else
        v36 = 0;
      v37 = v8 + 26;
      if (v8)
      {
        v62 = v8[2];
      }
      else
      {
        v37 = 0;
        v62 = 0;
      }
      *(_DWORD *)buf = 136447490;
      v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
      v110 = 2114;
      v111 = v34;
      v112 = 2080;
      *(_QWORD *)v113 = v36;
      *(_WORD *)&v113[8] = 1024;
      *(_DWORD *)&v113[10] = v35;
      v114 = 2080;
      *(_QWORD *)v115 = v37;
      *(_WORD *)&v115[8] = 1024;
      *(_DWORD *)&v115[10] = v62;
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] Ethernet Channel handle update: mismatched interface %s (idx %d) != %s (idx %d)", buf, 0x36u);
    }
    goto LABEL_58;
  }
  if (v14 != v8[2])
    goto LABEL_12;
LABEL_37:
  is_null = uuid_is_null(a3);
  v45 = *(_QWORD *)(a1 + 32);
  if (is_null)
  {
    if (v45 && *(_QWORD *)(v45 + 152))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        v46 = *(_QWORD *)(a1 + 32);
        v47 = *(_QWORD *)(v46 + 24);
        v48 = v46 + 115;
        LODWORD(v46) = *(_DWORD *)(v46 + 168);
        *(_DWORD *)buf = 136447234;
        v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
        v110 = 2080;
        v111 = v47;
        v112 = 1042;
        *(_DWORD *)v113 = 16;
        *(_WORD *)&v113[4] = 2098;
        *(_QWORD *)&v113[6] = v48;
        v114 = 1024;
        *(_DWORD *)v115 = v46;
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: no nexus agent", buf, 0x2Cu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        v49 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)buf = 136446466;
        v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
        v110 = 2114;
        v111 = v49;
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, "%{public}s [%{public}@] Ethernet Channel handle update: no nexus agent", buf, 0x16u);
      }
    }
LABEL_58:

    goto LABEL_103;
  }
  if (v45 && *(_QWORD *)(v45 + 152))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v50 = (id)gLogObj;
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      goto LABEL_61;
    v51 = *(_QWORD *)(a1 + 32);
    v52 = *(_QWORD *)(v51 + 24);
    v53 = v51 + 115;
    v54 = *(_DWORD *)(v51 + 168);
    v55 = v8 + 26;
    if (v8)
    {
      v63 = v8[2];
    }
    else
    {
      v55 = 0;
      v63 = 0;
    }
    *(_DWORD *)buf = 136448258;
    v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
    v110 = 2080;
    v111 = v52;
    v112 = 1042;
    *(_DWORD *)v113 = 16;
    *(_WORD *)&v113[4] = 2098;
    *(_QWORD *)&v113[6] = v53;
    v114 = 1024;
    *(_DWORD *)v115 = v54;
    *(_WORD *)&v115[4] = 2080;
    *(_QWORD *)&v115[6] = v55;
    *(_WORD *)&v115[14] = 1024;
    *(_DWORD *)&v115[16] = v63;
    v116 = 1042;
    *(_DWORD *)v117 = 16;
    *(_WORD *)&v117[4] = 2098;
    *(_QWORD *)&v117[6] = a3;
    v59 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: for %s (%d) nexus"
          " agent %{public, uuid_t}.16P";
    v60 = v50;
    v61 = 76;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v50 = (id)gLogObj;
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      goto LABEL_61;
    v56 = *(_QWORD *)(a1 + 32);
    v57 = v8 + 26;
    if (v8)
    {
      v58 = v8[2];
    }
    else
    {
      v57 = 0;
      v58 = 0;
    }
    *(_DWORD *)buf = 136447490;
    v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
    v110 = 2114;
    v111 = v56;
    v112 = 2080;
    *(_QWORD *)v113 = v57;
    *(_WORD *)&v113[8] = 1024;
    *(_DWORD *)&v113[10] = v58;
    v114 = 1042;
    *(_DWORD *)v115 = 16;
    *(_WORD *)&v115[4] = 2098;
    *(_QWORD *)&v115[6] = a3;
    v59 = "%{public}s [%{public}@] Ethernet Channel handle update: for %s (%d) nexus agent %{public, uuid_t}.16P";
    v60 = v50;
    v61 = 54;
  }
  _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_DEBUG, v59, buf, v61);
LABEL_61:

  v64 = *(_QWORD *)(a1 + 32);
  v65 = *(void **)(v64 + 80);
  if (!v65)
  {
    v107 = *(_OWORD *)a3;
LABEL_67:
    if (*(_QWORD *)(v64 + 152))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v69 = (id)gLogObj;
      if (!os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
        goto LABEL_77;
      v70 = v8 + 26;
      v71 = *(_QWORD *)(a1 + 32);
      if (!v8)
        v70 = 0;
      v72 = *(_DWORD *)(v71 + 168);
      v73 = *(_QWORD *)(v71 + 24);
      *(_DWORD *)buf = 136448002;
      v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
      v110 = 2080;
      v111 = v73;
      v112 = 1042;
      *(_DWORD *)v113 = 16;
      *(_WORD *)&v113[4] = 2098;
      *(_QWORD *)&v113[6] = v71 + 115;
      v114 = 1024;
      *(_DWORD *)v115 = v72;
      *(_WORD *)&v115[4] = 1042;
      *(_DWORD *)&v115[6] = 16;
      *(_WORD *)&v115[10] = 2098;
      *(_QWORD *)&v115[12] = &v107;
      v116 = 2080;
      *(_QWORD *)v117 = v70;
      v74 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: adding flow reg"
            "istration for nexus agent %{public,uuid_t}.16P on %s";
      v75 = v69;
      v76 = 70;
      goto LABEL_76;
    }
LABEL_72:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v69 = (id)gLogObj;
    if (!os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
      goto LABEL_77;
    v77 = v8 + 26;
    v78 = *(_QWORD *)(a1 + 32);
    if (!v8)
      v77 = 0;
    *(_DWORD *)buf = 136447234;
    v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
    v110 = 2114;
    v111 = v78;
    v112 = 1042;
    *(_DWORD *)v113 = 16;
    *(_WORD *)&v113[4] = 2098;
    *(_QWORD *)&v113[6] = &v107;
    v114 = 2080;
    *(_QWORD *)v115 = v77;
    v74 = "%{public}s [%{public}@] Ethernet Channel handle update: adding flow registration for nexus agent %{public,uuid_t}.16P on %s";
    v75 = v69;
    v76 = 48;
LABEL_76:
    _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_DEBUG, v74, buf, v76);
LABEL_77:

    v79 = nw_path_evaluator_create_flow_inner(*(void **)(*(_QWORD *)(a1 + 32) + 72), 0, 1, 0, 0, &v107, 0, 0, 0);
    v80 = *(_QWORD *)(a1 + 32);
    if (v79)
    {
      v81 = *(void **)(v80 + 80);
      if (v81)
      {
        nw_path_flow_registration_close(v81);
        v80 = *(_QWORD *)(a1 + 32);
      }
      objc_storeStrong((id *)(v80 + 80), v79);
      v82 = *(_QWORD *)(a1 + 32);
      if (v82 && *(_QWORD *)(v82 + 152))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v83 = (id)gLogObj;
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
        {
          v84 = v8 + 26;
          v85 = *(_QWORD *)(a1 + 32);
          if (!v8)
            v84 = 0;
          v86 = *(_DWORD *)(v85 + 168);
          v87 = *(_QWORD *)(v85 + 24);
          *(_DWORD *)buf = 136448002;
          v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
          v110 = 2080;
          v111 = v87;
          v112 = 1042;
          *(_DWORD *)v113 = 16;
          *(_WORD *)&v113[4] = 2098;
          *(_QWORD *)&v113[6] = v85 + 115;
          v114 = 1024;
          *(_DWORD *)v115 = v86;
          *(_WORD *)&v115[4] = 1042;
          *(_DWORD *)&v115[6] = 16;
          *(_WORD *)&v115[10] = 2098;
          *(_QWORD *)&v115[12] = &v107;
          v116 = 2080;
          *(_QWORD *)v117 = v84;
          v88 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: added flow "
                "registration for nexus agent %{public,uuid_t}.16P on %s";
          v89 = v83;
          v90 = OS_LOG_TYPE_DEBUG;
          v91 = 70;
          goto LABEL_101;
        }
LABEL_102:

        goto LABEL_103;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v83 = (id)gLogObj;
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
        goto LABEL_102;
      v92 = v8 + 26;
      v93 = *(_QWORD *)(a1 + 32);
      if (!v8)
        v92 = 0;
      *(_DWORD *)buf = 136447234;
      v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
      v110 = 2114;
      v111 = v93;
      v112 = 1042;
      *(_DWORD *)v113 = 16;
      *(_WORD *)&v113[4] = 2098;
      *(_QWORD *)&v113[6] = &v107;
      v114 = 2080;
      *(_QWORD *)v115 = v92;
      v88 = "%{public}s [%{public}@] Ethernet Channel handle update: added flow registration for nexus agent %{public,uuid_t}.16P on %s";
      v89 = v83;
      v90 = OS_LOG_TYPE_DEBUG;
    }
    else
    {
      if (v80 && *(_QWORD *)(v80 + 152))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v83 = (id)gLogObj;
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        {
          v94 = v8 + 26;
          v95 = *(_QWORD *)(a1 + 32);
          if (!v8)
            v94 = 0;
          v96 = *(_DWORD *)(v95 + 168);
          v97 = *(_QWORD *)(v95 + 24);
          *(_DWORD *)buf = 136448002;
          v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
          v110 = 2080;
          v111 = v97;
          v112 = 1042;
          *(_DWORD *)v113 = 16;
          *(_WORD *)&v113[4] = 2098;
          *(_QWORD *)&v113[6] = v95 + 115;
          v114 = 1024;
          *(_DWORD *)v115 = v96;
          *(_WORD *)&v115[4] = 1042;
          *(_DWORD *)&v115[6] = 16;
          *(_WORD *)&v115[10] = 2098;
          *(_QWORD *)&v115[12] = &v107;
          v116 = 2080;
          *(_QWORD *)v117 = v94;
          v88 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: failed to c"
                "reate flow registration for nexus agent %{public,uuid_t}.16P on %s";
          v89 = v83;
          v90 = OS_LOG_TYPE_ERROR;
          v91 = 70;
          goto LABEL_101;
        }
        goto LABEL_102;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v83 = (id)gLogObj;
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        goto LABEL_102;
      v98 = v8 + 26;
      v99 = *(_QWORD *)(a1 + 32);
      if (!v8)
        v98 = 0;
      *(_DWORD *)buf = 136447234;
      v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
      v110 = 2114;
      v111 = v99;
      v112 = 1042;
      *(_DWORD *)v113 = 16;
      *(_WORD *)&v113[4] = 2098;
      *(_QWORD *)&v113[6] = &v107;
      v114 = 2080;
      *(_QWORD *)v115 = v98;
      v88 = "%{public}s [%{public}@] Ethernet Channel handle update: failed to create flow registration for nexus agent %"
            "{public,uuid_t}.16P on %s";
      v89 = v83;
      v90 = OS_LOG_TYPE_ERROR;
    }
    v91 = 48;
LABEL_101:
    _os_log_impl(&dword_182FBE000, v89, v90, v88, buf, v91);
    goto LABEL_102;
  }
  v66 = v65;
  v67 = v66;
  if ((v66[148] & 4) == 0)
  {

    v64 = *(_QWORD *)(a1 + 32);
    goto LABEL_66;
  }
  v68 = uuid_compare(v66 + 48, a3) == 0;

  v64 = *(_QWORD *)(a1 + 32);
  if (!v68)
  {
LABEL_66:
    v107 = *(_OWORD *)a3;
    if (!v64)
      goto LABEL_72;
    goto LABEL_67;
  }
  if (v64 && *(_QWORD *)(v64 + 152))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v100 = (id)gLogObj;
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
    {
      v101 = v8 + 26;
      v102 = *(_QWORD *)(a1 + 32);
      if (!v8)
        v101 = 0;
      v103 = *(_DWORD *)(v102 + 168);
      v104 = *(_QWORD *)(v102 + 24);
      *(_DWORD *)buf = 136448002;
      v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
      v110 = 2080;
      v111 = v104;
      v112 = 1042;
      *(_DWORD *)v113 = 16;
      *(_WORD *)&v113[4] = 2098;
      *(_QWORD *)&v113[6] = v102 + 115;
      v114 = 1024;
      *(_DWORD *)v115 = v103;
      *(_WORD *)&v115[4] = 1042;
      *(_DWORD *)&v115[6] = 16;
      *(_WORD *)&v115[10] = 2098;
      *(_QWORD *)&v115[12] = a3;
      v116 = 2080;
      *(_QWORD *)v117 = v101;
      _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: flow registration already exists for nexus agent %{public,uuid_t}.16P on %s", buf, 0x46u);
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v100 = (id)gLogObj;
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
    {
      v105 = v8 + 26;
      v106 = *(_QWORD *)(a1 + 32);
      if (!v8)
        v105 = 0;
      *(_DWORD *)buf = 136447234;
      v109 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
      v110 = 2114;
      v111 = v106;
      v112 = 1042;
      *(_DWORD *)v113 = 16;
      *(_WORD *)&v113[4] = 2098;
      *(_QWORD *)&v113[6] = a3;
      v114 = 2080;
      *(_QWORD *)v115 = v105;
      _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}@] Ethernet Channel handle update: flow registration already exists for nexus agent %{public,uuid_t}.16P on %s", buf, 0x30u);
    }
  }

LABEL_103:
}

void sub_183377DC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL45nw_ethernet_channel_handle_path_update_lockedP30NWConcrete_nw_ethernet_channelPU21objcproto10OS_nw_path8NSObject_block_invoke_126(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 113))
  {
    v2 = *(void **)(v1 + 72);
    if (v2)
      nw_path_evaluator_force_update(v2, 0);
  }
}

uint64_t ___ZL45nw_ethernet_channel_handle_path_update_lockedP30NWConcrete_nw_ethernet_channelPU21objcproto10OS_nw_path8NSObject_block_invoke_127(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  void *v9;
  void *v10;
  unsigned __int8 *v11;
  id v12;
  id *v13;
  id v14;
  _BYTE *ethernet_address;
  int v16;
  uint64_t v17;
  NSObject *v18;
  _BOOL4 v19;
  uint64_t v20;
  int v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  uint64_t v33;
  uint64_t v35;
  NSObject *v36;
  _BOOL4 v37;
  uint64_t v38;
  int v39;
  const char *v40;
  NSObject *v41;
  uint32_t v42;
  unsigned __int8 *v43;
  uint64_t v44;
  NSObject *v45;
  _BOOL4 v46;
  uint64_t v47;
  int v48;
  const char *v49;
  NSObject *v50;
  uint32_t v51;
  _BOOL4 v52;
  uint64_t v53;
  uint64_t v54;
  unsigned __int8 *v55;
  uint64_t v56;
  int v57;
  const char *v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  int v62;
  __int16 v63;
  unsigned __int8 *v64;
  __int16 v65;
  int v66;
  __int16 v67;
  int v68;
  __int16 v69;
  unsigned __int8 *v70;
  unsigned __int8 v71[16];
  __int128 v72;
  unsigned __int8 uu2[16];
  unsigned __int8 uu1[24];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(v6 + 88);
  v8 = v5;
  v9 = v8;
  if (v7)
  {
    memset(uu1, 0, 16);
    memset(uu2, 0, sizeof(uu2));
    v72 = 0uLL;
    memset(v71, 0, sizeof(v71));
    if (!v8)
      goto LABEL_7;
    v10 = *(void **)(v6 + 88);
    if (!v10)
      goto LABEL_7;
    v11 = v10;
    if (uuid_is_null(v11 + 128)
      || (*(_OWORD *)uu1 = *((_OWORD *)v11 + 8), v11, v11 = v9, uuid_is_null(v11 + 128)))
    {

LABEL_7:
      v6 = *(_QWORD *)(a1 + 32);
      goto LABEL_8;
    }
    *(_OWORD *)uu2 = *((_OWORD *)v11 + 8);

    v35 = *(_QWORD *)(v6 + 152);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v36 = (id)gLogObj;
    v37 = os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG);
    if (v35)
    {
      if (v37)
      {
        v38 = *(_QWORD *)(v6 + 24);
        v39 = *(_DWORD *)(v6 + 168);
        v57 = 136447746;
        v58 = "-[NWConcrete_nw_ethernet_channel matchesNexusInstance:]";
        v59 = 2080;
        v60 = v38;
        v61 = 1042;
        v62 = 16;
        v63 = 2098;
        v64 = (unsigned __int8 *)(v6 + 115);
        v65 = 1024;
        v66 = v39;
        v67 = 1042;
        v68 = 16;
        v69 = 2098;
        v70 = uu2;
        v40 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] matching Nexus instance %{public, uuid_t}.16P";
        v41 = v36;
        v42 = 60;
LABEL_40:
        _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, v40, (uint8_t *)&v57, v42);
      }
    }
    else if (v37)
    {
      v57 = 136446978;
      v58 = "-[NWConcrete_nw_ethernet_channel matchesNexusInstance:]";
      v59 = 2114;
      v60 = v6;
      v61 = 1042;
      v62 = 16;
      v63 = 2098;
      v64 = uu2;
      v40 = "%{public}s [%{public}@] matching Nexus instance %{public, uuid_t}.16P";
      v41 = v36;
      v42 = 38;
      goto LABEL_40;
    }

    if (uuid_compare(uu1, uu2) || !nw_path_flow_get_id(*(void **)(v6 + 88), &v72))
      goto LABEL_7;
    v43 = v11;
    if (uuid_is_null(v43 + 144))
    {

      goto LABEL_7;
    }
    *(_OWORD *)v71 = *((_OWORD *)v43 + 9);

    v44 = *(_QWORD *)(v6 + 152);
    __nwlog_obj();
    v45 = objc_claimAutoreleasedReturnValue();
    v46 = os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG);
    if (v44)
    {
      if (!v46)
        goto LABEL_51;
      v47 = *(_QWORD *)(v6 + 24);
      v48 = *(_DWORD *)(v6 + 168);
      v57 = 136447746;
      v58 = "-[NWConcrete_nw_ethernet_channel matchesNexusInstance:]";
      v59 = 2080;
      v60 = v47;
      v61 = 1042;
      v62 = 16;
      v63 = 2098;
      v64 = (unsigned __int8 *)(v6 + 115);
      v65 = 1024;
      v66 = v48;
      v67 = 1042;
      v68 = 16;
      v69 = 2098;
      v70 = v71;
      v49 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] matching flow id %{public, uuid_t}.16P";
      v50 = v45;
      v51 = 60;
    }
    else
    {
      if (!v46)
        goto LABEL_51;
      v57 = 136446978;
      v58 = "-[NWConcrete_nw_ethernet_channel matchesNexusInstance:]";
      v59 = 2114;
      v60 = v6;
      v61 = 1042;
      v62 = 16;
      v63 = 2098;
      v64 = v71;
      v49 = "%{public}s [%{public}@] matching flow id %{public, uuid_t}.16P";
      v50 = v45;
      v51 = 38;
    }
    _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_DEBUG, v49, (uint8_t *)&v57, v51);
LABEL_51:

    v52 = uuid_compare((const unsigned __int8 *)&v72, v71) == 0;
    v6 = *(_QWORD *)(a1 + 32);
    if (v52)
    {
      if (v6 && *(_QWORD *)(v6 + 152))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = (id)gLogObj;
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
          goto LABEL_34;
        v53 = *(_QWORD *)(a1 + 32);
        v54 = *(_QWORD *)(v53 + 24);
        v55 = (unsigned __int8 *)(v53 + 115);
        LODWORD(v53) = *(_DWORD *)(v53 + 168);
        v57 = 136447234;
        v58 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
        v59 = 2080;
        v60 = v54;
        v61 = 1042;
        v62 = 16;
        v63 = 2098;
        v64 = v55;
        v65 = 1024;
        v66 = v53;
        v30 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: flow already exists";
        goto LABEL_29;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = (id)gLogObj;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        goto LABEL_34;
      v56 = *(_QWORD *)(a1 + 32);
      v57 = 136446466;
      v58 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
      v59 = 2114;
      v60 = v56;
      v30 = "%{public}s [%{public}@] Ethernet Channel handle update: flow already exists";
      goto LABEL_32;
    }
LABEL_8:
    v12 = v9;
    if (!v6)
      goto LABEL_25;
  }
  if (*(_QWORD *)(v6 + 88))
    -[NWConcrete_nw_ethernet_channel closeChannel:](v6, 0);
  if (v9)
  {
    -[NWConcrete_nw_ethernet_channel updateClientState:error:](v6, 2, 0);
    v13 = v9;
    v14 = v13[4];

    if (v14)
    {
      ethernet_address = nw_endpoint_get_ethernet_address(v14);
      if (ethernet_address)
      {
        objc_storeStrong((id *)(v6 + 88), a3);
        v16 = *(_DWORD *)ethernet_address;
        *(_WORD *)(v6 + 100) = *((_WORD *)ethernet_address + 2);
        *(_DWORD *)(v6 + 96) = v16;
        if ((-[NWConcrete_nw_ethernet_channel createChannel](v6) & 1) != 0)
          goto LABEL_24;
        goto LABEL_23;
      }
    }
    v17 = *(_QWORD *)(v6 + 152);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (id)gLogObj;
    v19 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
    if (v17)
    {
      if (v19)
      {
        v20 = *(_QWORD *)(v6 + 24);
        v21 = *(_DWORD *)(v6 + 168);
        v57 = 136447234;
        v58 = "-[NWConcrete_nw_ethernet_channel resetFlow:]";
        v59 = 2080;
        v60 = v20;
        v61 = 1042;
        v62 = 16;
        v63 = 2098;
        v64 = (unsigned __int8 *)(v6 + 115);
        v65 = 1024;
        v66 = v21;
        v22 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] resetFlow failed to set flow, no local ethernet address";
        v23 = v18;
        v24 = 44;
LABEL_21:
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v57, v24);
      }
    }
    else if (v19)
    {
      v57 = 136446466;
      v58 = "-[NWConcrete_nw_ethernet_channel resetFlow:]";
      v59 = 2114;
      v60 = v6;
      v22 = "%{public}s [%{public}@] resetFlow failed to set flow, no local ethernet address";
      v23 = v18;
      v24 = 22;
      goto LABEL_21;
    }

LABEL_23:
    -[NWConcrete_nw_ethernet_channel closeChannel:](v6, 53);
LABEL_24:

  }
LABEL_25:

  v25 = *(_QWORD *)(a1 + 32);
  if (!v25 || !*(_QWORD *)(v25 + 152))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = (id)gLogObj;
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      goto LABEL_34;
    v33 = *(_QWORD *)(a1 + 32);
    v57 = 136446466;
    v58 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
    v59 = 2114;
    v60 = v33;
    v30 = "%{public}s [%{public}@] Ethernet Channel handle update: updated flow";
LABEL_32:
    v31 = v26;
    v32 = 22;
    goto LABEL_33;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v26 = (id)gLogObj;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
  {
    v27 = *(_QWORD *)(a1 + 32);
    v28 = *(_QWORD *)(v27 + 24);
    v29 = (unsigned __int8 *)(v27 + 115);
    LODWORD(v27) = *(_DWORD *)(v27 + 168);
    v57 = 136447234;
    v58 = "nw_ethernet_channel_handle_path_update_locked_block_invoke";
    v59 = 2080;
    v60 = v28;
    v61 = 1042;
    v62 = 16;
    v63 = 2098;
    v64 = v29;
    v65 = 1024;
    v66 = v27;
    v30 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>] Ethernet Channel handle update: updated flow";
LABEL_29:
    v31 = v26;
    v32 = 44;
LABEL_33:
    _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, v30, (uint8_t *)&v57, v32);
  }
LABEL_34:

  return 1;
}

void sub_1833785EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_ethernet_channel_set_receive_handler(nw_ethernet_channel_t ethernet_channel, nw_ethernet_channel_receive_handler_t handler)
{
  nw_ethernet_channel_t v3;
  nw_ethernet_channel_receive_handler_t v4;
  objc_class *v5;
  Class isa;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = ethernet_channel;
  v4 = handler;
  if (v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    if (!BYTE1(v3[14].isa))
    {
      v5 = (objc_class *)_Block_copy(v4);
      isa = v3[7].isa;
      v3[7].isa = v5;

    }
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_ethernet_channel_set_receive_handler";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_ethernet_channel_set_receive_handler";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_ethernet_channel_set_receive_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_ethernet_channel_set_receive_handler";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_ethernet_channel_set_receive_handler";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
LABEL_5:

}

void nw_ethernet_channel_send(nw_ethernet_channel_t ethernet_channel, dispatch_data_t content, uint16_t vlan_tag, unsigned __int8 *remote_address, nw_ethernet_channel_send_completion_t completion)
{
  nw_ethernet_channel_t v7;
  NSObject *v8;
  void (**v9)(nw_ethernet_channel_send_completion_t, _DWORD *);
  _DWORD *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  _DWORD *posix_error;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  void *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  char *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  NSObject *v27;
  Class isa;
  int v29;
  os_log_type_t v30;
  os_log_type_t v31;
  NSObject *v32;
  Class v33;
  int v34;
  Class v35;
  NSObject *v36;
  _BOOL4 v37;
  Class v38;
  int v39;
  const char *v40;
  NSObject *v41;
  uint32_t v42;
  Class v43;
  NSObject *v44;
  _BOOL4 v45;
  Class v46;
  int v47;
  const char *v48;
  NSObject *v49;
  uint32_t v50;
  Class v51;
  NSObject *v52;
  _BOOL4 v53;
  Class v54;
  int v55;
  const char *v56;
  NSObject *v57;
  uint32_t v58;
  Class v59;
  NSObject *v60;
  _BOOL4 v61;
  Class v62;
  int v63;
  const char *v64;
  NSObject *v65;
  uint32_t v66;
  os_log_type_t type[8];
  uint64_t v68;
  uint8_t v69[4];
  _BYTE buf[22];
  __int16 v71;
  _BYTE v72[14];
  __int16 v73;
  int v74;
  __int16 v75;
  const __CFString *v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v7 = ethernet_channel;
  v8 = content;
  v9 = completion;
  if (!v7)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
    v16 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v69[0] = 0;
    if (!__nwlog_fault(v16, type, v69))
      goto LABEL_52;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v18 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null ethernet_channel", buf, 0xCu);
      }
    }
    else if (v69[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v22 = type[0];
      v23 = os_log_type_enabled(v17, type[0]);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null ethernet_channel, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_52:
        if (!v16)
          goto LABEL_11;
LABEL_53:
        free(v16);
        goto LABEL_11;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
        _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null ethernet_channel, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v30 = type[0];
      if (os_log_type_enabled(v17, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
        _os_log_impl(&dword_182FBE000, v17, v30, "%{public}s called with null ethernet_channel, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_51:

    goto LABEL_52;
  }
  if (v8)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v7[1]);
    if (BYTE1(v7[14].isa))
    {
      v10 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 57);
LABEL_8:
      os_unfair_lock_unlock((os_unfair_lock_t)&v7[1]);
      if (v9)
        v9[2](v9, v10);

      goto LABEL_11;
    }
    v11 = v7;
    v12 = v8;
    v13 = v12;
    if (!v11[19].isa)
    {
      posix_error = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 53);
LABEL_7:
      v10 = posix_error;

      goto LABEL_8;
    }
    if (dispatch_data_get_size(v12) - 4294967278u < 0xFFFFFFFF00000013)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        isa = v11[3].isa;
        v29 = (int)v11[21].isa;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = isa;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(_QWORD *)&v72[6] = (char *)v11 + 115;
        v73 = 1024;
        v74 = v29;
        v75 = 2112;
        v76 = CFSTR("Bad TX data size");
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_ERROR, "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@", buf, 0x36u);
      }

      if (!v11[19].isa)
        goto LABEL_39;
      goto LABEL_37;
    }
    if (!v11[23].isa)
    {
      __nwlog_obj();
      v32 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v33 = v11[3].isa;
        v34 = (int)v11[21].isa;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v33;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(_QWORD *)&v72[6] = (char *)v11 + 115;
        v73 = 1024;
        v74 = v34;
        v75 = 2112;
        v76 = CFSTR("No rx_ring");
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_ERROR, "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@", buf, 0x36u);
      }

      if (!v11[19].isa)
        goto LABEL_39;
LABEL_37:
      if (os_channel_is_defunct())
        -[NWConcrete_nw_ethernet_channel closeChannel:]((uint64_t)v11, 0);
      goto LABEL_39;
    }
    if (os_channel_available_slot_count())
    {
LABEL_60:
      v68 = 0;
      if (os_channel_packet_alloc())
      {
        v35 = v11[19].isa;
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
        if (v35)
        {
          if (!v37)
            goto LABEL_71;
          v38 = v11[3].isa;
          v39 = (int)v11[21].isa;
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v38;
          v71 = 1042;
          *(_DWORD *)v72 = 16;
          *(_WORD *)&v72[4] = 2098;
          *(_QWORD *)&v72[6] = (char *)v11 + 115;
          v73 = 1024;
          v74 = v39;
          v75 = 2112;
          v76 = CFSTR("Failed to alloc TX packet");
          v40 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
          v41 = v36;
          v42 = 54;
        }
        else
        {
          if (!v37)
            goto LABEL_71;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
          *(_WORD *)&buf[12] = 2114;
          *(_QWORD *)&buf[14] = v11;
          v71 = 2112;
          *(_QWORD *)v72 = CFSTR("Failed to alloc TX packet");
          v40 = "%{public}s [%{public}@]  %@";
          v41 = v36;
          v42 = 32;
        }
        _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_ERROR, v40, buf, v42);
LABEL_71:

        if (v11[19].isa)
          goto LABEL_72;
        goto LABEL_74;
      }
      v51 = v11[19].isa;
      __nwlog_obj();
      v52 = objc_claimAutoreleasedReturnValue();
      v53 = os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
      if (v51)
      {
        if (!v53)
          goto LABEL_92;
        v54 = v11[3].isa;
        v55 = (int)v11[21].isa;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v54;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(_QWORD *)&v72[6] = (char *)v11 + 115;
        v73 = 1024;
        v74 = v55;
        v75 = 2112;
        v76 = CFSTR("no TX packet");
        v56 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
        v57 = v52;
        v58 = 54;
      }
      else
      {
        if (!v53)
          goto LABEL_92;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v11;
        v71 = 2112;
        *(_QWORD *)v72 = CFSTR("no TX packet");
        v56 = "%{public}s [%{public}@]  %@";
        v57 = v52;
        v58 = 32;
      }
      _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_ERROR, v56, buf, v58);
LABEL_92:

      if (v11[19].isa)
      {
LABEL_72:
        if (os_channel_is_defunct())
          -[NWConcrete_nw_ethernet_channel closeChannel:]((uint64_t)v11, 0);
      }
LABEL_74:
      posix_error = nw_error_create_posix_error(55);
      goto LABEL_7;
    }
    if (os_channel_sync())
    {
      v43 = v11[19].isa;
      __nwlog_obj();
      v44 = objc_claimAutoreleasedReturnValue();
      v45 = os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
      if (v43)
      {
        if (!v45)
          goto LABEL_78;
        v46 = v11[3].isa;
        v47 = (int)v11[21].isa;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v46;
        v71 = 1042;
        *(_DWORD *)v72 = 16;
        *(_WORD *)&v72[4] = 2098;
        *(_QWORD *)&v72[6] = (char *)v11 + 115;
        v73 = 1024;
        v74 = v47;
        v75 = 2112;
        v76 = CFSTR("Failed to sync TX");
        v48 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
        v49 = v44;
        v50 = 54;
      }
      else
      {
        if (!v45)
          goto LABEL_78;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v11;
        v71 = 2112;
        *(_QWORD *)v72 = CFSTR("Failed to sync TX");
        v48 = "%{public}s [%{public}@]  %@";
        v49 = v44;
        v50 = 32;
      }
      _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_ERROR, v48, buf, v50);
LABEL_78:

      if (v11[19].isa)
        goto LABEL_79;
      goto LABEL_39;
    }
    if (!os_channel_available_slot_count())
      goto LABEL_60;
    v59 = v11[19].isa;
    __nwlog_obj();
    v60 = objc_claimAutoreleasedReturnValue();
    v61 = os_log_type_enabled(v60, OS_LOG_TYPE_ERROR);
    if (v59)
    {
      if (!v61)
        goto LABEL_97;
      v62 = v11[3].isa;
      v63 = (int)v11[21].isa;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v62;
      v71 = 1042;
      *(_DWORD *)v72 = 16;
      *(_WORD *)&v72[4] = 2098;
      *(_QWORD *)&v72[6] = (char *)v11 + 115;
      v73 = 1024;
      v74 = v63;
      v75 = 2112;
      v76 = CFSTR("TX no available slot");
      v64 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
      v65 = v60;
      v66 = 54;
    }
    else
    {
      if (!v61)
        goto LABEL_97;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "send_data_on_ring_locked";
      *(_WORD *)&buf[12] = 2114;
      *(_QWORD *)&buf[14] = v11;
      v71 = 2112;
      *(_QWORD *)v72 = CFSTR("TX no available slot");
      v64 = "%{public}s [%{public}@]  %@";
      v65 = v60;
      v66 = 32;
    }
    _os_log_impl(&dword_182FBE000, v65, OS_LOG_TYPE_ERROR, v64, buf, v66);
LABEL_97:

    if (v11[19].isa)
    {
LABEL_79:
      if (os_channel_is_defunct())
        -[NWConcrete_nw_ethernet_channel closeChannel:]((uint64_t)v11, 0);
    }
LABEL_39:
    posix_error = nw_error_create_posix_error(53);
    goto LABEL_7;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
  v16 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v69[0] = 0;
  if (!__nwlog_fault(v16, type, v69))
    goto LABEL_52;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    v20 = type[0];
    if (os_log_type_enabled(v17, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
      _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null content", buf, 0xCu);
    }
    goto LABEL_51;
  }
  if (!v69[0])
  {
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    v31 = type[0];
    if (os_log_type_enabled(v17, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
      _os_log_impl(&dword_182FBE000, v17, v31, "%{public}s called with null content, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_51;
  }
  v24 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v17 = objc_claimAutoreleasedReturnValue();
  v25 = type[0];
  v26 = os_log_type_enabled(v17, type[0]);
  if (!v24)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
      _os_log_impl(&dword_182FBE000, v17, v25, "%{public}s called with null content, no backtrace", buf, 0xCu);
    }
    goto LABEL_51;
  }
  if (v26)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_ethernet_channel_send";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v24;
    _os_log_impl(&dword_182FBE000, v17, v25, "%{public}s called with null content, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v24);
  if (v16)
    goto LABEL_53;
LABEL_11:

}

void sub_18337A3C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL24send_data_on_ring_lockedP30NWConcrete_nw_ethernet_channelPU27objcproto16OS_dispatch_data8NSObjecttPh_block_invoke(uint64_t a1, void *a2, uint64_t a3, const void *a4, size_t a5)
{
  id v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  _DWORD *v19;
  _BOOL8 v20;
  int v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  _BYTE v27[14];
  __int16 v28;
  int v29;
  __int16 v30;
  const __CFString *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v8 = a2;
  v9 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v9 + a5 <= *(unsigned int *)(a1 + 64))
  {
    memcpy((void *)(*(_QWORD *)(a1 + 56) + v9), a4, a5);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += a5;
    v20 = 1;
    goto LABEL_15;
  }
  v10 = *(_QWORD *)(a1 + 32);
  if (v10 && *(_QWORD *)(v10 + 152))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = *(_QWORD *)(a1 + 32);
      v13 = *(_QWORD *)(v12 + 24);
      v14 = v12 + 115;
      LODWORD(v12) = *(_DWORD *)(v12 + 168);
      v22 = 136447490;
      v23 = "send_data_on_ring_locked_block_invoke";
      v24 = 2080;
      v25 = v13;
      v26 = 1042;
      *(_DWORD *)v27 = 16;
      *(_WORD *)&v27[4] = 2098;
      *(_QWORD *)&v27[6] = v14;
      v28 = 1024;
      v29 = v12;
      v30 = 2112;
      v31 = CFSTR("TX buffer no space");
      v15 = "%{public}s [%s: nexus instance %{public,uuid_t}.16P <fd %d>]  %@";
      v16 = v11;
      v17 = 54;
LABEL_8:
      _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v22, v17);
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v18 = *(_QWORD *)(a1 + 32);
      v22 = 136446722;
      v23 = "send_data_on_ring_locked_block_invoke";
      v24 = 2114;
      v25 = v18;
      v26 = 2112;
      *(_QWORD *)v27 = CFSTR("TX buffer no space");
      v15 = "%{public}s [%{public}@]  %@";
      v16 = v11;
      v17 = 32;
      goto LABEL_8;
    }
  }

  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 152))
  {
    if (*(_QWORD *)(a1 + 48))
      os_channel_packet_free();
    if (os_channel_is_defunct())
      -[NWConcrete_nw_ethernet_channel closeChannel:](*(_QWORD *)(a1 + 32), 0);
  }
  v19 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 55);
  v20 = v19 != 0;

LABEL_15:
  return v20;
}

void sub_18337A6BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_copy_swift_tls_definition(double a1)
{
  double Helper_x8__nwswifttls_copy_definition;
  uint64_t v2;
  uint64_t inited;
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  Helper_x8__nwswifttls_copy_definition = gotLoadHelper_x8__nwswifttls_copy_definition(a1);
  if (!*(_QWORD *)(v2 + 2312))
    return 0;
  inited = nwswifttls_copy_definition_delayInitStub(Helper_x8__nwswifttls_copy_definition);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    v6 = 136446466;
    v7 = "nw_protocol_copy_swift_tls_definition_if_present";
    v8 = 2048;
    v9 = inited;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, "%{public}s SwiftTLS protocol definition %p", (uint8_t *)&v6, 0x16u);
  }
  return inited;
}

uint64_t nw_tls_set_fallback()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_fallback";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_fallback";
      v3 = "%{public}s nw_tls_set_fallback not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_fallback";
      v3 = "%{public}s nw_tls_set_fallback not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_fallback";
      v3 = "%{public}s nw_tls_set_fallback not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_fallback";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_fallback not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_fallback()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_fallback";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_fallback";
      v3 = "%{public}s nw_tls_get_fallback not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_fallback";
      v3 = "%{public}s nw_tls_get_fallback not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_fallback";
      v3 = "%{public}s nw_tls_get_fallback not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_fallback";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_fallback not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_false_start()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_false_start";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_false_start";
      v3 = "%{public}s nw_tls_set_false_start not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_false_start";
      v3 = "%{public}s nw_tls_set_false_start not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_false_start";
      v3 = "%{public}s nw_tls_set_false_start not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_false_start";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_false_start not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_false_start()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_false_start";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_false_start";
      v3 = "%{public}s nw_tls_get_false_start not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_false_start";
      v3 = "%{public}s nw_tls_get_false_start not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_false_start";
      v3 = "%{public}s nw_tls_get_false_start not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_false_start";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_false_start not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_session_resumption_enabled()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_session_resumption_enabled";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_session_resumption_enabled";
      v3 = "%{public}s nw_tls_set_session_resumption_enabled not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_session_resumption_enabled";
      v3 = "%{public}s nw_tls_set_session_resumption_enabled not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_session_resumption_enabled";
      v3 = "%{public}s nw_tls_set_session_resumption_enabled not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_session_resumption_enabled";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_session_resumption_enabled not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_session_ticket_enabled()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_session_ticket_enabled";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_session_ticket_enabled";
      v3 = "%{public}s nw_tls_set_session_ticket_enabled not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_session_ticket_enabled";
      v3 = "%{public}s nw_tls_set_session_ticket_enabled not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_session_ticket_enabled";
      v3 = "%{public}s nw_tls_set_session_ticket_enabled not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_session_ticket_enabled";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_session_ticket_enabled not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_npn_enabled()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_npn_enabled";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_npn_enabled";
      v3 = "%{public}s nw_tls_set_npn_enabled not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_npn_enabled";
      v3 = "%{public}s nw_tls_set_npn_enabled not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_npn_enabled";
      v3 = "%{public}s nw_tls_set_npn_enabled not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_npn_enabled";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_npn_enabled not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_minimum_protocol_version()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_minimum_protocol_version";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_minimum_protocol_version";
      v3 = "%{public}s nw_tls_set_minimum_protocol_version not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_minimum_protocol_version";
      v3 = "%{public}s nw_tls_set_minimum_protocol_version not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_minimum_protocol_version";
      v3 = "%{public}s nw_tls_set_minimum_protocol_version not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_minimum_protocol_version";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_minimum_protocol_version not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_minimum_protocol_version()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_minimum_protocol_version";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_minimum_protocol_version";
      v3 = "%{public}s nw_tls_get_minimum_protocol_version not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_minimum_protocol_version";
      v3 = "%{public}s nw_tls_get_minimum_protocol_version not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_minimum_protocol_version";
      v3 = "%{public}s nw_tls_get_minimum_protocol_version not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_minimum_protocol_version";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_minimum_protocol_version not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_maximum_protocol_version()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_maximum_protocol_version";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_maximum_protocol_version";
      v3 = "%{public}s nw_tls_set_maximum_protocol_version not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_maximum_protocol_version";
      v3 = "%{public}s nw_tls_set_maximum_protocol_version not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_maximum_protocol_version";
      v3 = "%{public}s nw_tls_set_maximum_protocol_version not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_maximum_protocol_version";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_maximum_protocol_version not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_maximum_protocol_version()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_maximum_protocol_version";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_maximum_protocol_version";
      v3 = "%{public}s nw_tls_get_maximum_protocol_version not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_maximum_protocol_version";
      v3 = "%{public}s nw_tls_get_maximum_protocol_version not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_maximum_protocol_version";
      v3 = "%{public}s nw_tls_get_maximum_protocol_version not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_maximum_protocol_version";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_maximum_protocol_version not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_minimum_ssl_protocol()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_minimum_ssl_protocol";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_minimum_ssl_protocol";
      v3 = "%{public}s nw_tls_set_minimum_ssl_protocol not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_minimum_ssl_protocol";
      v3 = "%{public}s nw_tls_set_minimum_ssl_protocol not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_minimum_ssl_protocol";
      v3 = "%{public}s nw_tls_set_minimum_ssl_protocol not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_minimum_ssl_protocol";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_minimum_ssl_protocol not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_minimum_ssl_protocol()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_minimum_ssl_protocol";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_minimum_ssl_protocol";
      v3 = "%{public}s nw_tls_get_minimum_ssl_protocol not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_minimum_ssl_protocol";
      v3 = "%{public}s nw_tls_get_minimum_ssl_protocol not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_minimum_ssl_protocol";
      v3 = "%{public}s nw_tls_get_minimum_ssl_protocol not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_minimum_ssl_protocol";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_minimum_ssl_protocol not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_maximum_ssl_protocol()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_maximum_ssl_protocol";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_maximum_ssl_protocol";
      v3 = "%{public}s nw_tls_set_maximum_ssl_protocol not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_maximum_ssl_protocol";
      v3 = "%{public}s nw_tls_set_maximum_ssl_protocol not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_maximum_ssl_protocol";
      v3 = "%{public}s nw_tls_set_maximum_ssl_protocol not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_maximum_ssl_protocol";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_maximum_ssl_protocol not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_maximum_ssl_protocol()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_maximum_ssl_protocol";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_maximum_ssl_protocol";
      v3 = "%{public}s nw_tls_get_maximum_ssl_protocol not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_maximum_ssl_protocol";
      v3 = "%{public}s nw_tls_get_maximum_ssl_protocol not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_maximum_ssl_protocol";
      v3 = "%{public}s nw_tls_get_maximum_ssl_protocol not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_maximum_ssl_protocol";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_maximum_ssl_protocol not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_peer_hostname()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_peer_hostname";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_hostname";
      v3 = "%{public}s nw_tls_get_peer_hostname not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_hostname";
      v3 = "%{public}s nw_tls_get_peer_hostname not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_hostname";
      v3 = "%{public}s nw_tls_get_peer_hostname not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_peer_hostname";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_peer_hostname not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_peer_hostname()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_peer_hostname";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_hostname";
      v3 = "%{public}s nw_tls_set_peer_hostname not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_hostname";
      v3 = "%{public}s nw_tls_set_peer_hostname not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_hostname";
      v3 = "%{public}s nw_tls_set_peer_hostname not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_peer_hostname";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_peer_hostname not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_psk_secret()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_psk_secret";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_secret";
      v3 = "%{public}s nw_tls_set_psk_secret not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_secret";
      v3 = "%{public}s nw_tls_set_psk_secret not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_secret";
      v3 = "%{public}s nw_tls_set_psk_secret not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_psk_secret";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_psk_secret not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_psk_identity()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_psk_identity";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_identity";
      v3 = "%{public}s nw_tls_set_psk_identity not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_identity";
      v3 = "%{public}s nw_tls_set_psk_identity not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_identity";
      v3 = "%{public}s nw_tls_set_psk_identity not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_psk_identity";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_psk_identity not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_psk_identity_hint()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_psk_identity_hint";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_identity_hint";
      v3 = "%{public}s nw_tls_set_psk_identity_hint not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_identity_hint";
      v3 = "%{public}s nw_tls_set_psk_identity_hint not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_psk_identity_hint";
      v3 = "%{public}s nw_tls_set_psk_identity_hint not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_psk_identity_hint";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_psk_identity_hint not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_ciphersuites()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_ciphersuites";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_ciphersuites";
      v3 = "%{public}s nw_tls_set_ciphersuites not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_ciphersuites";
      v3 = "%{public}s nw_tls_set_ciphersuites not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_ciphersuites";
      v3 = "%{public}s nw_tls_set_ciphersuites not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_ciphersuites";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_ciphersuites not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_negotiated_cipher_spec()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_negotiated_cipher_spec";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_cipher_spec";
      v3 = "%{public}s nw_tls_get_negotiated_cipher_spec not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_cipher_spec";
      v3 = "%{public}s nw_tls_get_negotiated_cipher_spec not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_cipher_spec";
      v3 = "%{public}s nw_tls_get_negotiated_cipher_spec not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_negotiated_cipher_spec";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_negotiated_cipher_spec not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_dh_parameters()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_dh_parameters";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_dh_parameters";
      v3 = "%{public}s nw_tls_set_dh_parameters not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_dh_parameters";
      v3 = "%{public}s nw_tls_set_dh_parameters not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_dh_parameters";
      v3 = "%{public}s nw_tls_set_dh_parameters not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_dh_parameters";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_dh_parameters not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_alpn_data()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_alpn_data";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_alpn_data";
      v3 = "%{public}s nw_tls_set_alpn_data not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_alpn_data";
      v3 = "%{public}s nw_tls_set_alpn_data not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_alpn_data";
      v3 = "%{public}s nw_tls_set_alpn_data not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_alpn_data";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_alpn_data not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_peer_alpn_data()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_peer_alpn_data";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_alpn_data";
      v3 = "%{public}s nw_tls_get_peer_alpn_data not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_alpn_data";
      v3 = "%{public}s nw_tls_get_peer_alpn_data not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_alpn_data";
      v3 = "%{public}s nw_tls_get_peer_alpn_data not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_peer_alpn_data";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_peer_alpn_data not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_npn_data()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_npn_data";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_npn_data";
      v3 = "%{public}s nw_tls_set_npn_data not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_npn_data";
      v3 = "%{public}s nw_tls_set_npn_data not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_npn_data";
      v3 = "%{public}s nw_tls_set_npn_data not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_npn_data";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_npn_data not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_peer_npn_data()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_peer_npn_data";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_npn_data";
      v3 = "%{public}s nw_tls_get_peer_npn_data not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_npn_data";
      v3 = "%{public}s nw_tls_get_peer_npn_data not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_npn_data";
      v3 = "%{public}s nw_tls_get_peer_npn_data not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_peer_npn_data";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_peer_npn_data not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_copy_peer_certificates()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_copy_peer_certificates";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_copy_peer_certificates";
      v3 = "%{public}s nw_tls_copy_peer_certificates not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_copy_peer_certificates";
      v3 = "%{public}s nw_tls_copy_peer_certificates not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_copy_peer_certificates";
      v3 = "%{public}s nw_tls_copy_peer_certificates not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_copy_peer_certificates";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_copy_peer_certificates not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_peer_rsa_public_key()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_peer_rsa_public_key";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_rsa_public_key";
      v3 = "%{public}s nw_tls_set_peer_rsa_public_key not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_rsa_public_key";
      v3 = "%{public}s nw_tls_set_peer_rsa_public_key not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_rsa_public_key";
      v3 = "%{public}s nw_tls_set_peer_rsa_public_key not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_peer_rsa_public_key";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_peer_rsa_public_key not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_peer_ec_public_key()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_peer_ec_public_key";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_ec_public_key";
      v3 = "%{public}s nw_tls_set_peer_ec_public_key not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_ec_public_key";
      v3 = "%{public}s nw_tls_set_peer_ec_public_key not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_ec_public_key";
      v3 = "%{public}s nw_tls_set_peer_ec_public_key not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_peer_ec_public_key";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_peer_ec_public_key not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_peer_ocsp_response()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_peer_ocsp_response";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_ocsp_response";
      v3 = "%{public}s nw_tls_get_peer_ocsp_response not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_ocsp_response";
      v3 = "%{public}s nw_tls_get_peer_ocsp_response not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_peer_ocsp_response";
      v3 = "%{public}s nw_tls_get_peer_ocsp_response not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_peer_ocsp_response";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_peer_ocsp_response not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_peer_trust()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_peer_trust";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_trust";
      v3 = "%{public}s nw_tls_set_peer_trust not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_trust";
      v3 = "%{public}s nw_tls_set_peer_trust not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_peer_trust";
      v3 = "%{public}s nw_tls_set_peer_trust not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_peer_trust";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_peer_trust not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_client_auth()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_client_auth";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_client_auth";
      v3 = "%{public}s nw_tls_set_client_auth not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_client_auth";
      v3 = "%{public}s nw_tls_set_client_auth not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_client_auth";
      v3 = "%{public}s nw_tls_set_client_auth not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_client_auth";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_client_auth not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_client_auth_type()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_client_auth_type";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_client_auth_type";
      v3 = "%{public}s nw_tls_set_client_auth_type not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_client_auth_type";
      v3 = "%{public}s nw_tls_set_client_auth_type not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_client_auth_type";
      v3 = "%{public}s nw_tls_set_client_auth_type not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_client_auth_type";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_client_auth_type not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_negotiated_protocol_version()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_negotiated_protocol_version";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_protocol_version";
      v3 = "%{public}s nw_tls_get_negotiated_protocol_version not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_protocol_version";
      v3 = "%{public}s nw_tls_get_negotiated_protocol_version not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_protocol_version";
      v3 = "%{public}s nw_tls_get_negotiated_protocol_version not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_negotiated_protocol_version";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_negotiated_protocol_version not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_get_negotiated_ssl_protocol()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_get_negotiated_ssl_protocol";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_ssl_protocol";
      v3 = "%{public}s nw_tls_get_negotiated_ssl_protocol not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_ssl_protocol";
      v3 = "%{public}s nw_tls_get_negotiated_ssl_protocol not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_get_negotiated_ssl_protocol";
      v3 = "%{public}s nw_tls_get_negotiated_ssl_protocol not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_get_negotiated_ssl_protocol";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_get_negotiated_ssl_protocol not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_config()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_config";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_config";
      v3 = "%{public}s nw_tls_set_config not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_config";
      v3 = "%{public}s nw_tls_set_config not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_config";
      v3 = "%{public}s nw_tls_set_config not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_config";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_config not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_create_peer_acceptable_distinguished_names()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_create_peer_acceptable_distinguished_names";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_create_peer_acceptable_distinguished_names";
      v3 = "%{public}s nw_tls_create_peer_acceptable_distinguished_names not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_create_peer_acceptable_distinguished_names";
      v3 = "%{public}s nw_tls_create_peer_acceptable_distinguished_names not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_create_peer_acceptable_distinguished_names";
      v3 = "%{public}s nw_tls_create_peer_acceptable_distinguished_names not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_create_peer_acceptable_distinguished_names";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_create_peer_acceptable_distinguished_names not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_create_peer_trust()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_create_peer_trust";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_create_peer_trust";
      v3 = "%{public}s nw_tls_create_peer_trust not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_create_peer_trust";
      v3 = "%{public}s nw_tls_create_peer_trust not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_create_peer_trust";
      v3 = "%{public}s nw_tls_create_peer_trust not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_create_peer_trust";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_create_peer_trust not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_fetch_peer_public_key()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_fetch_peer_public_key";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_fetch_peer_public_key";
      v3 = "%{public}s nw_tls_fetch_peer_public_key not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_fetch_peer_public_key";
      v3 = "%{public}s nw_tls_fetch_peer_public_key not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_fetch_peer_public_key";
      v3 = "%{public}s nw_tls_fetch_peer_public_key not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_fetch_peer_public_key";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_fetch_peer_public_key not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

uint64_t nw_tls_set_identity_from_array()
{
  char *v0;
  NSObject *v1;
  os_log_type_t v2;
  const char *v3;
  char *backtrace_string;
  _BOOL4 v5;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "nw_tls_set_identity_from_array";
  v0 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v0, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_identity_from_array";
      v3 = "%{public}s nw_tls_set_identity_from_array not implemented";
LABEL_14:
      _os_log_impl(&dword_182FBE000, v1, v2, v3, buf, 0xCu);
      goto LABEL_15;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      v2 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_identity_from_array";
      v3 = "%{public}s nw_tls_set_identity_from_array not implemented, backtrace limit exceeded";
      goto LABEL_14;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v1 = gLogObj;
    v2 = type;
    v5 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v5)
        goto LABEL_15;
      *(_DWORD *)buf = 136446210;
      v10 = "nw_tls_set_identity_from_array";
      v3 = "%{public}s nw_tls_set_identity_from_array not implemented, no backtrace";
      goto LABEL_14;
    }
    if (v5)
    {
      *(_DWORD *)buf = 136446466;
      v10 = "nw_tls_set_identity_from_array";
      v11 = 2082;
      v12 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v1, v2, "%{public}s nw_tls_set_identity_from_array not implemented, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_15:
  if (v0)
    free(v0);
  return 0;
}

void sub_18338119C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183381724(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183382174(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_18338228C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_183382350(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_183382474(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1833824DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)NWCandidate;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1833825A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_inject(NWConcrete_nw_candidate_manager *a1, NWCandidate *a2)
{
  NWConcrete_nw_candidate_manager *v3;
  NWCandidate *v4;
  NWCandidate *v5;
  OS_nw_interface_option_details *details;
  id v7;
  NSObject *v8;
  unint64_t v9;
  NSObject *v10;
  unint64_t log_id;
  unint64_t v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  char v21;
  __int128 type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  NWCandidate *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v4)
  {
    if ((*((_BYTE *)v4 + 40) & 8) != 0)
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v10 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        log_id = v3->log_id;
        *(_DWORD *)buf = 136446722;
        v24 = "nw_candidate_manager_inject";
        v25 = 2048;
        v26 = (char *)log_id;
        v27 = 2112;
        v28 = v5;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Candidate %@ already injected, skipping", buf, 0x20u);
      }
    }
    else
    {
      if (v3->add_eligible_details)
      {
        type = 0uLL;
        nw_path_get_nexus_agent_uuid(v4->current_path, &type);
        nw_interface_option_details_set_nexus_agent(v5->details, &type);
        details = v5->details;
        v7 = nw_path_copy_interface(v5->current_path);
        nw_interface_option_details_set_interface(details, v7);

        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v8 = (id)gcandidate_managerLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
        {
          v9 = v3->log_id;
          *(_DWORD *)buf = 136446722;
          v24 = "nw_candidate_manager_inject";
          v25 = 2048;
          v26 = (char *)v9;
          v27 = 2112;
          v28 = v5;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] adding %@", buf, 0x20u);
        }

        (*((void (**)(void))v3->add_eligible_details + 2))();
        *((_BYTE *)v5 + 40) |= 8u;
        goto LABEL_19;
      }
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v10 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        v12 = v3->log_id;
        *(_DWORD *)buf = 136446722;
        v24 = "nw_candidate_manager_inject";
        v25 = 2048;
        v26 = (char *)v12;
        v27 = 2112;
        v28 = v5;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] Failed to add %@", buf, 0x20u);
      }
    }

    goto LABEL_19;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_candidate_manager_inject";
  v14 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(type) = 16;
  v21 = 0;
  if (__nwlog_fault(v14, &type, &v21))
  {
    if (type == 17)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, (os_log_type_t)type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_candidate_manager_inject";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null candidate", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v15, (os_log_type_t)type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_candidate_manager_inject";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null candidate, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_candidate_manager_inject";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null candidate, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v15, (os_log_type_t)type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_candidate_manager_inject";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null candidate, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_36:
  if (v14)
    free(v14);
LABEL_19:

}

void sub_183382A9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_remove(NWConcrete_nw_candidate_manager *a1, NWCandidate *a2)
{
  NWConcrete_nw_candidate_manager *v3;
  NWCandidate *v4;
  NWCandidate *v5;
  NSObject *v6;
  unint64_t log_id;
  NSObject *v8;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  NWCandidate *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v4)
  {
    if (v4->details)
    {
      if (v3->remove_eligible_details)
      {
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v6 = (id)gcandidate_managerLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          log_id = v3->log_id;
          *(_DWORD *)buf = 136446722;
          v22 = "nw_candidate_manager_remove";
          v23 = 2048;
          v24 = (char *)log_id;
          v25 = 2112;
          v26 = v5;
          _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Removing %@", buf, 0x20u);
        }

        *((_BYTE *)v5 + 40) &= ~8u;
        (*((void (**)(void))v3->remove_eligible_details + 2))();
        goto LABEL_19;
      }
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v8 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v10 = v3->log_id;
        *(_DWORD *)buf = 136446722;
        v22 = "nw_candidate_manager_remove";
        v23 = 2048;
        v24 = (char *)v10;
        v25 = 2112;
        v26 = v5;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] Unable to remove %@", buf, 0x20u);
      }
    }
    else
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v8 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        v9 = v3->log_id;
        *(_DWORD *)buf = 136446722;
        v22 = "nw_candidate_manager_remove";
        v23 = 2048;
        v24 = (char *)v9;
        v25 = 2112;
        v26 = v5;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Candidate %@ not injected, skipping", buf, 0x20u);
      }
    }

    goto LABEL_19;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_candidate_manager_remove";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_candidate_manager_remove";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null candidate", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_candidate_manager_remove";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null candidate, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_candidate_manager_remove";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null candidate, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_candidate_manager_remove";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null candidate, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_36:
  if (v12)
    free(v12);
LABEL_19:

}

void sub_183382F54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_18338345C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_candidate_manager_get_next_id(void)
{
  unsigned int v0;
  uint64_t result;
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  do
    v0 = __ldaxr(&nw_candidate_manager_get_next_id(void)::s_last_id);
  while (__stlxr(v0 + 1, &nw_candidate_manager_get_next_id(void)::s_last_id));
  result = v0 + 1;
  if (v0 == -1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136446466;
      v4 = "nw_candidate_manager_get_next_id";
      v5 = 1024;
      v6 = 0;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s reached %u agent ids, wrapping", (uint8_t *)&v3, 0x12u);
    }

    return nw_candidate_manager_get_next_id();
  }
  return result;
}

id nw_candidate_manager_create_raw(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = -[NWConcrete_nw_candidate_manager init:]([NWConcrete_nw_candidate_manager alloc], "init:", v1);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_candidate_manager_create_raw";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_candidate_manager_create_raw";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_candidate_manager_create_raw";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_candidate_manager_create_raw";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_candidate_manager_create_raw";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1833839C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *nw_candidate_manager_create(const unsigned __int8 *a1, void *a2)
{
  id v3;
  void *v4;
  _QWORD *v5;
  nw_endpoint_t bonjour_service;
  NSObject *v7;
  char *v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  _QWORD *v30;
  __int16 v31;
  void *v32;
  os_log_type_t out[40];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v4 = v3;
  if (!a1)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_candidate_manager_create";
    v11 = (char *)_os_log_send_and_compose_impl();

    out[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, out, &v24))
      goto LABEL_42;
    if (out[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = out[0];
      if (os_log_type_enabled(v12, out[0]))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_candidate_manager_create";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null session_id", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = out[0];
      v18 = os_log_type_enabled(v12, out[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_candidate_manager_create";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null session_id, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v11)
          goto LABEL_44;
        goto LABEL_43;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_candidate_manager_create";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null session_id, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = out[0];
      if (os_log_type_enabled(v12, out[0]))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_candidate_manager_create";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null session_id, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_41;
  }
  if (!v3)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_candidate_manager_create";
    v11 = (char *)_os_log_send_and_compose_impl();

    out[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, out, &v24))
      goto LABEL_42;
    if (out[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = out[0];
      if (os_log_type_enabled(v12, out[0]))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_candidate_manager_create";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v24)
    {
      v19 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v20 = out[0];
      v21 = os_log_type_enabled(v12, out[0]);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_candidate_manager_create";
          v27 = 2082;
          v28 = v19;
          _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v19);
LABEL_42:
        if (!v11)
        {
LABEL_44:
          v5 = 0;
          goto LABEL_8;
        }
LABEL_43:
        free(v11);
        goto LABEL_44;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_candidate_manager_create";
        _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v23 = out[0];
      if (os_log_type_enabled(v12, out[0]))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_candidate_manager_create";
        _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  memset(out, 0, 37);
  uuid_unparse(a1, (char *)out);
  v5 = -[NWConcrete_nw_candidate_manager init:]([NWConcrete_nw_candidate_manager alloc], "init:", v4);
  bonjour_service = nw_endpoint_create_bonjour_service((const char *)out, "_flexquic._udp", "local.");
  nw_candidate_manager_set_bonjour_service(v5, bonjour_service);

  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v7 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = (char *)v5[1];
    *(_DWORD *)buf = 136446978;
    v26 = "nw_candidate_manager_create";
    v27 = 2048;
    v28 = v8;
    v29 = 2112;
    v30 = v5;
    v31 = 2112;
    v32 = v4;
    _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Creating candidate_manager %@ with parameters %@", buf, 0x2Au);
  }

LABEL_8:
  return v5;
}

void sub_183383F80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_set_bonjour_service(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  id v6;
  int v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_candidate_manager_set_bonjour_service";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_candidate_manager_set_bonjour_service";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null manager", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_candidate_manager_set_bonjour_service";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v9)
          goto LABEL_5;
LABEL_40:
        free(v9);
        goto LABEL_5;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_candidate_manager_set_bonjour_service";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_candidate_manager_set_bonjour_service";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (!v4 || (v6 = v4, v7 = objc_msgSend(v6, "type"), v6, v7 == 3))
  {
    objc_storeStrong(v3 + 5, a2);
    goto LABEL_5;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_candidate_manager_set_bonjour_service";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_candidate_manager_set_bonjour_service";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service)", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_candidate_manager_set_bonjour_service";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service), backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_candidate_manager_set_bonjour_service";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service), no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_candidate_manager_set_bonjour_service";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null (service == nil || nw_endpoint_get_type(service) == nw_endpoint_type_bonjour_service), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_40;
LABEL_5:

}

void sub_18338448C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_candidate_manager_create_with_connection(void *a1, void *a2)
{
  NWConcrete_nw_connection *v3;
  id v4;
  void *v5;
  id v6;
  int v7;
  id v8;
  char *v9;
  NSObject *v10;
  char *v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  __int16 v33;
  id v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_candidate_manager_create_with_connection";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v14, &type, &v27))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_candidate_manager_create_with_connection";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_candidate_manager_create_with_connection";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v14)
          goto LABEL_47;
        goto LABEL_46;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_candidate_manager_create_with_connection";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_candidate_manager_create_with_connection";
        _os_log_impl(&dword_182FBE000, v15, v25, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_44;
  }
  if (v4)
  {
    v6 = v4;
    v7 = objc_msgSend(v6, "type");

    if (v7 != 3)
    {
      __nwlog_obj();
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v30 = "nw_candidate_manager_create_with_connection";
      v14 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v27 = 0;
      if (!__nwlog_fault(v14, &type, &v27))
        goto LABEL_45;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_candidate_manager_create_with_connection";
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null (bonjour_endpoint == nullptr || nw_endpoint_get_type((nw_endpoint_t)bonjour_endpoint) == nw_endpoint_type_bonjour_service)", buf, 0xCu);
        }
      }
      else if (v27)
      {
        v22 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        v24 = os_log_type_enabled(v15, type);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446466;
            v30 = "nw_candidate_manager_create_with_connection";
            v31 = 2082;
            v32 = v22;
            _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null (bonjour_endpoint == nullptr || nw_endpoint_get_type((nw_endpoint_t)bonjour_endpoint) == nw_endpoint_type_bonjour_service), dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v22);
LABEL_45:
          if (!v14)
          {
LABEL_47:
            v8 = 0;
            goto LABEL_11;
          }
LABEL_46:
          free(v14);
          goto LABEL_47;
        }
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_candidate_manager_create_with_connection";
          _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null (bonjour_endpoint == nullptr || nw_endpoint_get_type((nw_endpoint_t)bonjour_endpoint) == nw_endpoint_type_bonjour_service), no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_candidate_manager_create_with_connection";
          _os_log_impl(&dword_182FBE000, v15, v26, "%{public}s called with null (bonjour_endpoint == nullptr || nw_endpoint_get_type((nw_endpoint_t)bonjour_endpoint) == nw_endpoint_type_bonjour_service), backtrace limit exceeded", buf, 0xCu);
        }
      }
LABEL_44:

      goto LABEL_45;
    }
  }
  v8 = -[NWConcrete_nw_candidate_manager init:]([NWConcrete_nw_candidate_manager alloc], "init:", v3->parameters);
  nw_candidate_manager_set_bonjour_service(v8, v5);
  v9 = nw_parameters_copy_description_internal(*((NWConcrete_nw_parameters **)v8 + 10), 1);
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v10 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = (char *)*((_QWORD *)v8 + 1);
    *(_DWORD *)buf = 136446978;
    v30 = "nw_candidate_manager_create_with_connection";
    v31 = 2048;
    v32 = v11;
    v33 = 2112;
    v34 = v8;
    v35 = 2082;
    v36 = v9;
    _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Creating candidate_manager %@ with parameters %{public}s", buf, 0x2Au);
  }

  if (v9)
    free(v9);
  nw_candidate_manager_set_connection((NWConcrete_nw_candidate_manager *)v8, v3);
  nw_candidate_manager_set_state(v8, 2);
LABEL_11:

  return v8;
}

void sub_183384A7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_set_connection(NWConcrete_nw_candidate_manager *a1, NWConcrete_nw_connection *a2)
{
  NWConcrete_nw_candidate_manager *v3;
  NWConcrete_nw_connection *v4;
  uint64_t v5;
  NWConcrete_nw_candidate_manager *v6;
  NWConcrete_nw_connection *v7;
  void *v8;
  id add_eligible_details;
  NWConcrete_nw_candidate_manager *v10;
  void *v11;
  id remove_eligible_details;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  _QWORD v21[4];
  NWConcrete_nw_candidate_manager *v22;
  NWConcrete_nw_connection *v23;
  _QWORD aBlock[4];
  NWConcrete_nw_candidate_manager *v25;
  NWConcrete_nw_connection *v26;
  char v27;
  os_log_type_t v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong((id *)&v3->connection, a2);
    v5 = MEMORY[0x1E0C809B0];
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZL35nw_candidate_manager_set_connectionP31NWConcrete_nw_candidate_managerP24NWConcrete_nw_connection_block_invoke;
    aBlock[3] = &unk_1E149A6D8;
    v6 = v3;
    v25 = v6;
    v7 = v4;
    v26 = v7;
    v8 = _Block_copy(aBlock);
    add_eligible_details = v6->add_eligible_details;
    v6->add_eligible_details = v8;

    v21[0] = v5;
    v21[1] = 3221225472;
    v21[2] = ___ZL35nw_candidate_manager_set_connectionP31NWConcrete_nw_candidate_managerP24NWConcrete_nw_connection_block_invoke_145;
    v21[3] = &unk_1E149A6D8;
    v10 = v6;
    v22 = v10;
    v23 = v7;
    v11 = _Block_copy(v21);
    remove_eligible_details = v10->remove_eligible_details;
    v10->remove_eligible_details = v11;

    goto LABEL_3;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_candidate_manager_set_connection";
  v14 = (char *)_os_log_send_and_compose_impl();

  v28 = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v14, &v28, &v27))
  {
    if (v28 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = v28;
      if (os_log_type_enabled(v15, v28))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_candidate_manager_set_connection";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null manager", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v18 = v28;
      v19 = os_log_type_enabled(v15, v28);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_candidate_manager_set_connection";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_candidate_manager_set_connection";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = v28;
      if (os_log_type_enabled(v15, v28))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_candidate_manager_set_connection";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v14)
    free(v14);
LABEL_3:

}

void nw_candidate_manager_set_state(void *a1, uint64_t a2)
{
  NWConcrete_nw_candidate_manager *v3;
  NWConcrete_nw_candidate_manager *v4;
  NSObject *v5;
  unint64_t log_id;
  uint64_t state;
  const char *v8;
  char *v9;
  void (**state_handler)(id, uint64_t, _QWORD);
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (v3->state != (_DWORD)a2)
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v5 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        log_id = v4->log_id;
        state = v4->state;
        if (state > 4)
          v8 = "unknown-state";
        else
          v8 = off_1E149A7B0[state];
        v9 = off_1E149A7B0[a2];
        *(_DWORD *)buf = 136446978;
        v22 = "nw_candidate_manager_set_state";
        v23 = 2048;
        v24 = (char *)log_id;
        v25 = 2080;
        v26 = v8;
        v27 = 2080;
        v28 = v9;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Changing candidate_manager state changed from %s -> %s", buf, 0x2Au);
      }

      v4->state = a2;
      if ((_DWORD)a2 == 2
        && (nw_parameters_get_server_mode(v4->parameters) & 1) == 0
        && nw_parameters_get_include_peer_to_peer((nw_parameters_t)v4->parameters))
      {
        nw_candidate_manager_monitor_interface_use(v4);
      }
      state_handler = (void (**)(id, uint64_t, _QWORD))v4->state_handler;
      if (state_handler)
        state_handler[2](state_handler, a2, 0);
    }
    goto LABEL_16;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_candidate_manager_set_state";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_candidate_manager_set_state";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_candidate_manager_set_state";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_33;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_candidate_manager_set_state";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_candidate_manager_set_state";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_33:
  if (v12)
    free(v12);
LABEL_16:

}

void sub_1833851D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_monitor_interface_use(NWConcrete_nw_candidate_manager *a1)
{
  NWConcrete_nw_candidate_manager *v1;
  NWConcrete_nw_candidate_manager *v2;
  NWConcrete_nw_connection *connection;
  _QWORD v4[4];
  NWConcrete_nw_candidate_manager *v5;

  v1 = a1;
  v2 = v1;
  connection = v1->connection;
  if (connection && (*((_BYTE *)v1 + 184) & 4) == 0)
  {
    *((_BYTE *)v1 + 184) |= 4u;
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = ___ZL42nw_candidate_manager_monitor_interface_useP31NWConcrete_nw_candidate_manager_block_invoke;
    v4[3] = &unk_1E149A770;
    v5 = v1;
    nw_connection_set_interface_use_callback(connection, v4);

  }
}

void sub_183385280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void ___ZL42nw_candidate_manager_monitor_interface_useP31NWConcrete_nw_candidate_manager_block_invoke(uint64_t a1, uint64_t a2, int a3, void *a4, void *a5)
{
  id v8;
  id v9;
  void *v10;
  NSObject *v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  NWConcrete_nw_candidate_manager *v17;
  NSObject *v18;
  uint64_t v19;
  NWConcrete_nw_candidate_manager *v20;
  NWConcrete_nw_candidate_manager *v21;
  OS_nw_resolver *awdl_service_resolver;
  OS_nw_resolver *v23;
  NWConcrete_nw_candidate_manager *v24;
  NSObject *v25;
  unint64_t log_id;
  NSObject *v27;
  unint64_t v28;
  _BOOL8 source;
  dispatch_time_t v30;
  uint64_t v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  char *backtrace_string;
  os_log_type_t v37;
  _BOOL4 v38;
  os_log_type_t v39;
  char v40;
  os_log_type_t type;
  _BYTE buf[24];
  void *v43;
  NSObject *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v8 = a4;
  v9 = a5;
  v10 = v9;
  if (a3)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v11 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_candidate_manager_monitor_interface_use_block_invoke";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v12;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Connection cancelled", buf, 0x16u);
    }

    nw_candidate_manager_stop_lost_path_timer(*(NWConcrete_nw_candidate_manager **)(a1 + 32));
    goto LABEL_26;
  }
  if (v9)
  {
    v13 = v9;
    v14 = v13[25];

    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v15 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_candidate_manager_monitor_interface_use_block_invoke";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v16;
      *(_WORD *)&buf[22] = 2080;
      v43 = v13 + 26;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Changed to working path over interface %s", buf, 0x20u);
    }

    nw_candidate_manager_stop_lost_path_timer(*(NWConcrete_nw_candidate_manager **)(a1 + 32));
    v17 = *(NWConcrete_nw_candidate_manager **)(a1 + 32);
    if (v14 == 1002)
      goto LABEL_13;
    v20 = v17;
    v21 = v20;
    if (v20)
    {
      awdl_service_resolver = v20->awdl_service_resolver;
      if (awdl_service_resolver)
      {
        nw_resolver_cancel(awdl_service_resolver);
        v23 = v21->awdl_service_resolver;
        v21->awdl_service_resolver = 0;

      }
LABEL_25:

      goto LABEL_26;
    }
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_stop_awdl_resolver";
    v33 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v33, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_stop_awdl_resolver";
          _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null manager", buf, 0xCu);
        }
      }
      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v37 = type;
        v38 = os_log_type_enabled(v34, type);
        if (backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_stop_awdl_resolver";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_54;
        }
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_stop_awdl_resolver";
          _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null manager, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v34 = objc_claimAutoreleasedReturnValue();
        v39 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_stop_awdl_resolver";
          _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_54:
    if (v33)
      free(v33);
    goto LABEL_25;
  }
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v18 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    v19 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_monitor_interface_use_block_invoke";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v19;
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Changed to no working path", buf, 0x16u);
  }

  if ((nw_parameters_get_server_mode(*(void **)(*(_QWORD *)(a1 + 32) + 80)) & 1) == 0)
  {
    v17 = *(NWConcrete_nw_candidate_manager **)(a1 + 32);
    if (!v17->ids_endpoint || v17->ids_path_evaluator)
    {
LABEL_13:
      nw_candidate_manager_start_awdl_resolver(v17);
      goto LABEL_26;
    }
    v24 = v17;
    if (v24->lost_path_timer)
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v25 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        log_id = v24->log_id;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_start_lost_path_timer";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = log_id;
        _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Lost path timer already started", buf, 0x16u);
      }
    }
    else
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v27 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        v28 = v24->log_id;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_start_lost_path_timer";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v28;
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Starting lost path timer", buf, 0x16u);
      }

      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = ___ZL42nw_candidate_manager_start_lost_path_timerP31NWConcrete_nw_candidate_manager_block_invoke;
      v43 = &unk_1E14ACFD0;
      v44 = v24;
      source = nw_queue_context_create_source(0, 2, 3, 0, buf, 0);
      v24->lost_path_timer = (void *)source;
      v30 = dispatch_time(0x8000000000000000, 30000000000);
      nw_queue_set_timer_values(source, v30, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      nw_queue_activate_source((uint64_t)v24->lost_path_timer, v31);
      v25 = v44;
    }

    nw_candidate_manager_start_ids_internal(*(void **)(a1 + 32), *(void **)(*(_QWORD *)(a1 + 32) + 16));
  }
LABEL_26:

}

void sub_183385960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_stop_lost_path_timer(NWConcrete_nw_candidate_manager *a1)
{
  NWConcrete_nw_candidate_manager *v1;
  NSObject *v2;
  unint64_t log_id;
  uint64_t v4;
  uint64_t lost_path_timer;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v2 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      log_id = v1->log_id;
      *(_DWORD *)buf = 136446466;
      v17 = "nw_candidate_manager_stop_lost_path_timer";
      v18 = 2048;
      v19 = (char *)log_id;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Stopping lost path timer", buf, 0x16u);
    }

    lost_path_timer = (uint64_t)v1->lost_path_timer;
    if (lost_path_timer)
    {
      nw_queue_cancel_source(lost_path_timer, v4);
      v1->lost_path_timer = 0;
    }
    goto LABEL_8;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_candidate_manager_stop_lost_path_timer";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_candidate_manager_stop_lost_path_timer";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_candidate_manager_stop_lost_path_timer";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_candidate_manager_stop_lost_path_timer";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_candidate_manager_stop_lost_path_timer";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_25:
  if (v7)
    free(v7);
LABEL_8:

}

void sub_183385CCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL42nw_candidate_manager_start_lost_path_timerP31NWConcrete_nw_candidate_manager_block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  const char *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v2 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v4 = 136446466;
    v5 = "nw_candidate_manager_start_lost_path_timer_block_invoke";
    v6 = 2048;
    v7 = v3;
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Lost path timer timed out, falling back to AWDL", (uint8_t *)&v4, 0x16u);
  }

  nw_candidate_manager_stop_lost_path_timer(*(NWConcrete_nw_candidate_manager **)(a1 + 32));
  nw_candidate_manager_start_awdl_resolver(*(NWConcrete_nw_candidate_manager **)(a1 + 32));
}

void nw_candidate_manager_start_ids_internal(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  id v6;
  _BOOL8 v7;
  void (**v8)(id, _BOOL8);
  xpc_object_t v9;
  xpc_object_t v10;
  NSObject *v11;
  char *v12;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  id v14;
  os_unfair_lock_s *v15;
  uint64_t v16;
  os_unfair_lock_s *v17;
  id *v18;
  id v19;
  id v20;
  id v21;
  void *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  char *v31;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  os_log_type_t v35;
  _QWORD v36[4];
  id *v37;
  _QWORD v38[4];
  id *v39;
  id v40;
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  char *v46;
  __int16 v47;
  void *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v44 = "nw_candidate_manager_start_ids_internal";
    v23 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v23, &type, &v41))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_candidate_manager_start_ids_internal";
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      v30 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_candidate_manager_start_ids_internal";
          v45 = 2082;
          v46 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v23)
          goto LABEL_15;
LABEL_50:
        free(v23);
        goto LABEL_15;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_candidate_manager_start_ids_internal";
        _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v44 = "nw_candidate_manager_start_ids_internal";
        _os_log_impl(&dword_182FBE000, v24, v34, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_48:

    goto LABEL_49;
  }
  if (v4)
  {
    v6 = v3[10];
    v7 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v6, 0, 0);

    v8 = (void (**)(id, _BOOL8))v3[16];
    if (v8)
    {
      v8[2](v8, v7);
    }
    else
    {
      v9 = xpc_array_create(0, 0);
      xpc_array_set_string(v9, 0xFFFFFFFFFFFFFFFFLL, "com.apple.ids");
      v10 = xpc_array_create(0, 0);
      xpc_array_set_string(v10, 0xFFFFFFFFFFFFFFFFLL, "IDSGroupEntitledAgent");
      nw_parameters_set_required_netagent_classes((void *)v7, v9, v10);

    }
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v11 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = (char *)v3[1];
      *(_DWORD *)buf = 136446722;
      v44 = "nw_candidate_manager_start_ids_internal";
      v45 = 2048;
      v46 = v12;
      v47 = 2112;
      v48 = v5;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Starting: %@", buf, 0x20u);
    }

    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v5, (void *)v7);
    v14 = v3[22];
    v3[22] = evaluator_for_endpoint;

    v15 = (os_unfair_lock_s *)v3[22];
    v16 = MEMORY[0x1E0C809B0];
    if (v15)
    {
      v17 = v15 + 24;
      v18 = v15;
      os_unfair_lock_lock(v17);
      v19 = v18[6];
      os_unfair_lock_unlock(v17);

      if (v19)
      {
        v20 = nw_parameters_copy_context((void *)v7);
        v38[0] = v16;
        v38[1] = 3221225472;
        v38[2] = __nw_candidate_manager_start_ids_internal_block_invoke;
        v38[3] = &unk_1E14ACE68;
        v39 = v3;
        v19 = v19;
        v40 = v19;
        nw_queue_context_async(v20, v38);

      }
    }
    else
    {
      v19 = 0;
    }
    v21 = v3[22];
    v36[0] = v16;
    v36[1] = 3221225472;
    v36[2] = __nw_candidate_manager_start_ids_internal_block_invoke_2;
    v36[3] = &unk_1E14AC2C8;
    v37 = v3;
    nw_path_evaluator_set_update_handler(v21, 0, v36);

    goto LABEL_15;
  }
  __nwlog_obj();
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v44 = "nw_candidate_manager_start_ids_internal";
  v23 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (!__nwlog_fault(v23, &type, &v41))
    goto LABEL_49;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    if (os_log_type_enabled(v24, type))
    {
      *(_DWORD *)buf = 136446210;
      v44 = "nw_candidate_manager_start_ids_internal";
      _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s called with null ids_endpoint", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (!v41)
  {
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    v35 = type;
    if (os_log_type_enabled(v24, type))
    {
      *(_DWORD *)buf = 136446210;
      v44 = "nw_candidate_manager_start_ids_internal";
      _os_log_impl(&dword_182FBE000, v24, v35, "%{public}s called with null ids_endpoint, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_48;
  }
  v31 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v24 = objc_claimAutoreleasedReturnValue();
  v32 = type;
  v33 = os_log_type_enabled(v24, type);
  if (!v31)
  {
    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      v44 = "nw_candidate_manager_start_ids_internal";
      _os_log_impl(&dword_182FBE000, v24, v32, "%{public}s called with null ids_endpoint, no backtrace", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (v33)
  {
    *(_DWORD *)buf = 136446466;
    v44 = "nw_candidate_manager_start_ids_internal";
    v45 = 2082;
    v46 = v31;
    _os_log_impl(&dword_182FBE000, v24, v32, "%{public}s called with null ids_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v31);
  if (v23)
    goto LABEL_50;
LABEL_15:

}

void sub_1833864CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_start_awdl_resolver(NWConcrete_nw_candidate_manager *a1)
{
  NWConcrete_nw_candidate_manager *v1;
  NWConcrete_nw_candidate_manager *v2;
  NSObject *v3;
  char *log_id;
  NWConcrete_nw_interface *v5;
  OS_nw_parameters *v6;
  _BOOL8 v7;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  os_unfair_lock_s *v9;
  id *v10;
  id v11;
  nw_endpoint_t *v12;
  OS_nw_resolver *awdl_service_resolver;
  NSObject *v14;
  char *v15;
  OS_nw_resolver *v16;
  OS_nw_endpoint *service;
  OS_nw_resolver *v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  os_log_type_t v24;
  void *v25;
  os_log_type_t v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  os_log_type_t v36;
  os_log_type_t v37;
  _QWORD v38[4];
  NWConcrete_nw_candidate_manager *v39;
  char v40;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  char *v45;
  __int16 v46;
  OS_nw_resolver *v47;
  __int16 v48;
  OS_nw_endpoint *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_candidate_manager_start_awdl_resolver";
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v20, &type, &v40))
      goto LABEL_70;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null manager", buf, 0xCu);
      }
    }
    else if (v40)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      v29 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          v43 = "nw_candidate_manager_start_awdl_resolver";
          v44 = 2082;
          v45 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v28, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_70:
        if (!v20)
          goto LABEL_20;
LABEL_71:
        free(v20);
        goto LABEL_20;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v28, "%{public}s called with null manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v35, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_69:

    goto LABEL_70;
  }
  if (!v1->service)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_candidate_manager_start_awdl_resolver";
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v20, &type, &v40))
      goto LABEL_70;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null manager->service", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (!v40)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v36, "%{public}s called with null manager->service, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_69;
    }
    v30 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    v31 = type;
    v32 = os_log_type_enabled(v21, type);
    if (!v30)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v31, "%{public}s called with null manager->service, no backtrace", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_candidate_manager_start_awdl_resolver";
      v44 = 2082;
      v45 = v30;
      _os_log_impl(&dword_182FBE000, v21, v31, "%{public}s called with null manager->service, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_50;
  }
  if (!nw_parameters_get_include_peer_to_peer((nw_parameters_t)v1->parameters))
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_candidate_manager_start_awdl_resolver";
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v20, &type, &v40))
      goto LABEL_70;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null nw_parameters_get_include_peer_to_peer(manager->parameters)", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (!v40)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v37, "%{public}s called with null nw_parameters_get_include_peer_to_peer(manager->parameters), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_69;
    }
    v30 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    v33 = type;
    v34 = os_log_type_enabled(v21, type);
    if (!v30)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        _os_log_impl(&dword_182FBE000, v21, v33, "%{public}s called with null nw_parameters_get_include_peer_to_peer(manager->parameters), no backtrace", buf, 0xCu);
      }
      goto LABEL_69;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_candidate_manager_start_awdl_resolver";
      v44 = 2082;
      v45 = v30;
      _os_log_impl(&dword_182FBE000, v21, v33, "%{public}s called with null nw_parameters_get_include_peer_to_peer(manager->parameters), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_50:

    free(v30);
    if (!v20)
      goto LABEL_20;
    goto LABEL_71;
  }
  if (v2->awdl_service_resolver)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v3 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      log_id = (char *)v2->log_id;
      *(_DWORD *)buf = 136446466;
      v43 = "nw_candidate_manager_start_awdl_resolver";
      v44 = 2048;
      v45 = log_id;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] AWDL service resolver already running", buf, 0x16u);
    }

  }
  else
  {
    v5 = nw_interface_create_with_name("awdl0");
    if (v5)
    {
      v6 = v2->parameters;
      v7 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v6, 0, 0);

      nw_parameters_require_interface((nw_parameters_t)v7, &v5->super);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v2->service, (void *)v7);
      v9 = (os_unfair_lock_s *)evaluator_for_endpoint;
      if (evaluator_for_endpoint)
      {
        v10 = evaluator_for_endpoint;
        os_unfair_lock_lock(v9 + 24);
        v11 = v10[6];
        os_unfair_lock_unlock(v9 + 24);

      }
      else
      {
        v11 = 0;
      }
      v12 = nw_resolver_create_with_path(v11);
      awdl_service_resolver = v2->awdl_service_resolver;
      v2->awdl_service_resolver = (OS_nw_resolver *)v12;

      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v14 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = (char *)v2->log_id;
        v16 = v2->awdl_service_resolver;
        service = v2->service;
        *(_DWORD *)buf = 136446978;
        v43 = "nw_candidate_manager_start_awdl_resolver";
        v44 = 2048;
        v45 = v15;
        v46 = 2112;
        v47 = v16;
        v48 = 2112;
        v49 = service;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Created AWDL service resolver %@ for %@", buf, 0x2Au);
      }

      v18 = v2->awdl_service_resolver;
      v38[0] = MEMORY[0x1E0C809B0];
      v38[1] = 3221225472;
      v38[2] = ___ZL40nw_candidate_manager_start_awdl_resolverP31NWConcrete_nw_candidate_manager_block_invoke;
      v38[3] = &unk_1E149A6B0;
      v39 = v2;
      nw_resolver_set_update_handler(v18, 0, v38);

    }
  }
LABEL_20:

}

void sub_183386E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void ___ZL40nw_candidate_manager_start_awdl_resolverP31NWConcrete_nw_candidate_manager_block_invoke(uint64_t a1, int a2, void *a3)
{
  unsigned __int8 *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  void *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  _QWORD v18[5];
  _BYTE buf[24];
  uint64_t (*v20)(uint64_t, uint64_t);
  _BYTE v21[20];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v6 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(v7 + 8);
    v9 = "invalid";
    if (a2 == 2)
      v9 = "complete";
    v10 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 40);
    *(_QWORD *)&buf[4] = "nw_candidate_manager_start_awdl_resolver_block_invoke";
    *(_DWORD *)buf = 136447234;
    *(_WORD *)&buf[12] = 2048;
    if (a2 == 1)
      v9 = "in-progress";
    *(_QWORD *)&buf[14] = v8;
    *(_WORD *)&buf[22] = 2112;
    v20 = v10;
    *(_WORD *)v21 = 2082;
    *(_QWORD *)&v21[2] = v9;
    *(_WORD *)&v21[10] = 2112;
    *(_QWORD *)&v21[12] = v5;
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] %@ %{public}s resolves to %@", buf, 0x34u);
  }

  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3032000000;
  v20 = __Block_byref_object_copy__2752;
  *(_QWORD *)v21 = __Block_byref_object_dispose__2753;
  *(_QWORD *)&v21[8] = 0;
  if (v5)
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = ___ZL40nw_candidate_manager_start_awdl_resolverP31NWConcrete_nw_candidate_manager_block_invoke_162;
    v18[3] = &unk_1E14A8DC0;
    v18[4] = buf;
    nw_array_apply(v5, (uint64_t)v18);
    v11 = *(void **)(*(_QWORD *)&buf[8] + 40);
  }
  else
  {
    v11 = 0;
  }
  if ((nw_endpoint_is_equal(*(void **)(*(_QWORD *)(a1 + 32) + 64), v11, 1) & 1) == 0)
  {
    nw_candidate_manager_remove_hostname_resolver(*(void **)(a1 + 32), *(void **)(*(_QWORD *)(a1 + 32) + 64));
    objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 64), *(id *)(*(_QWORD *)&buf[8] + 40));
    v12 = *(_QWORD **)(a1 + 32);
    v13 = (void *)v12[8];
    if (v13)
    {
      if (!v12[11])
      {
        objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = *(_QWORD *)(a1 + 32);
        v16 = *(void **)(v15 + 88);
        *(_QWORD *)(v15 + 88) = v14;

        v12 = *(_QWORD **)(a1 + 32);
        v13 = (void *)v12[8];
      }
      nw_candidate_manager_resolver_for_service_resolved_endpoint(v12, v13);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 88), "setObject:forKeyedSubscript:", v17, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64));

    }
  }
  _Block_object_dispose(buf, 8);

}

void sub_1833870FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  void *v20;
  void *v21;

  _Block_object_dispose(&a15, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2752(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2753(uint64_t a1)
{

}

uint64_t ___ZL40nw_candidate_manager_start_awdl_resolverP31NWConcrete_nw_candidate_manager_block_invoke_162(uint64_t a1, int a2, id obj)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), obj);
  return 0;
}

void nw_candidate_manager_remove_hostname_resolver(void *a1, void *a2)
{
  id *v3;
  char *v4;
  char *v5;
  char *v6;
  NSObject *v7;
  char *v8;
  id v9;
  char *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *v14;
  const char *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *v19;
  os_log_type_t v20;
  char *v21;
  os_log_type_t v22;
  char *v23;
  void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  char v32;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  char *v37;
  __int16 v38;
  char *v39;
  __int16 v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_candidate_manager_remove_hostname_resolver";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v25, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null manager", buf, 0xCu);
        }
      }
      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        v30 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "nw_candidate_manager_remove_hostname_resolver";
            v36 = 2082;
            v37 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null manager, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          _os_log_impl(&dword_182FBE000, v26, v31, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_56:
    if (v25)
      free(v25);
    goto LABEL_21;
  }
  if (v4)
  {
    objc_msgSend(v3[11], "objectForKeyedSubscript:", v4);
    v6 = (char *)objc_claimAutoreleasedReturnValue();
    if (v6)
    {
      objc_msgSend(v3[11], "removeObjectForKey:", v5);
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v7 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = (char *)v3[1];
        *(_DWORD *)buf = 136446978;
        v35 = "nw_candidate_manager_remove_hostname_resolver";
        v36 = 2048;
        v37 = v8;
        v38 = 2112;
        v39 = v6;
        v40 = 2112;
        v41 = v5;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s [CM%zu] Removed %@ for %@", buf, 0x2Au);
      }

      nw_resolver_cancel(v6);
      goto LABEL_20;
    }
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v9 = (id)gcandidate_managerLogObj;
    v10 = (char *)v3[1];
    *(_DWORD *)buf = 136446722;
    v35 = "nw_candidate_manager_remove_hostname_resolver";
    v36 = 2048;
    v37 = v10;
    v38 = 2112;
    v39 = v5;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v11, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v12 = (id)gcandidate_managerLogObj;
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          v14 = (char *)v3[1];
          *(_DWORD *)buf = 136446722;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          v36 = 2048;
          v37 = v14;
          v38 = 2112;
          v39 = v5;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s [CM%zu] No resolver for %@", buf, 0x20u);
        }
      }
      else if (v32)
      {
        v15 = __nw_create_backtrace_string();
        if (v15)
        {
          v16 = (char *)v15;
          if (__nwlog_candidate_manager_log::onceToken != -1)
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
          v17 = (id)gcandidate_managerLogObj;
          v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            v19 = (char *)v3[1];
            *(_DWORD *)buf = 136446978;
            v35 = "nw_candidate_manager_remove_hostname_resolver";
            v36 = 2048;
            v37 = v19;
            v38 = 2112;
            v39 = v5;
            v40 = 2082;
            v41 = v16;
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s [CM%zu] No resolver for %@, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v16);
          if (!v11)
            goto LABEL_20;
          goto LABEL_19;
        }
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v12 = (id)gcandidate_managerLogObj;
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          v23 = (char *)v3[1];
          *(_DWORD *)buf = 136446722;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          v36 = 2048;
          v37 = v23;
          v38 = 2112;
          v39 = v5;
          _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s [CM%zu] No resolver for %@, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v12 = (id)gcandidate_managerLogObj;
        v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          v21 = (char *)v3[1];
          *(_DWORD *)buf = 136446722;
          v35 = "nw_candidate_manager_remove_hostname_resolver";
          v36 = 2048;
          v37 = v21;
          v38 = 2112;
          v39 = v5;
          _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s [CM%zu] No resolver for %@, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
    if (!v11)
    {
LABEL_20:

      goto LABEL_21;
    }
LABEL_19:
    free(v11);
    goto LABEL_20;
  }
LABEL_21:

}

void sub_18338784C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

nw_endpoint_t *nw_candidate_manager_resolver_for_service_resolved_endpoint(void *a1, void *a2)
{
  id *v3;
  id v4;
  id v5;
  _BOOL8 v6;
  NSObject *v7;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  os_unfair_lock_s *v9;
  id *v10;
  id v11;
  nw_endpoint_t *v12;
  id *v13;
  id v14;
  NSObject *v15;
  id v16;
  _QWORD v18[4];
  id *v19;
  id v20;
  id v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  id v25;
  __int16 v26;
  nw_endpoint_t *v27;
  __int16 v28;
  id v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v3[10];
  v6 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v5, 0, 0);

  v7 = nw_endpoint_copy_interface(v4);
  nw_parameters_require_interface((nw_parameters_t)v6, v7);

  nw_parameters_set_preferred_interface_subtypes((void *)v6, 0);
  nw_parameters_set_multipath_service((nw_parameters_t)v6, nw_multipath_service_disabled);
  evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v4, (void *)v6);
  v9 = (os_unfair_lock_s *)evaluator_for_endpoint;
  if (evaluator_for_endpoint)
  {
    v10 = evaluator_for_endpoint;
    os_unfair_lock_lock(v9 + 24);
    v11 = v10[6];
    os_unfair_lock_unlock(v9 + 24);

  }
  else
  {
    v11 = 0;
  }
  v12 = nw_resolver_create_with_path(v11);

  if (v12)
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = ___ZL59nw_candidate_manager_resolver_for_service_resolved_endpointP31NWConcrete_nw_candidate_managerPU25objcproto14OS_nw_endpoint8NSObject_block_invoke;
    v18[3] = &unk_1E149A700;
    v13 = v3;
    v19 = v13;
    v14 = v4;
    v20 = v14;
    v21 = (id)v6;
    nw_resolver_set_update_handler(v12, 0, v18);
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v15 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v16 = v13[1];
      *(_DWORD *)buf = 136446978;
      v23 = "nw_candidate_manager_resolver_for_service_resolved_endpoint";
      v24 = 2048;
      v25 = v16;
      v26 = 2112;
      v27 = v12;
      v28 = 2112;
      v29 = v14;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [CM%zu] Adding %@ for %@", buf, 0x2Au);
    }

  }
  return v12;
}

void sub_183387ADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void ___ZL59nw_candidate_manager_resolver_for_service_resolved_endpointP31NWConcrete_nw_candidate_managerPU25objcproto14OS_nw_endpoint8NSObject_block_invoke(id *a1, int a2, void *a3)
{
  unsigned __int8 *v5;
  NSObject *v6;
  id v7;
  const char *v8;
  uint64_t v9;
  _QWORD v10[4];
  id v11;
  id v12;
  id v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  id v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  unsigned __int8 *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v6 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = a1[5];
    v8 = "invalid";
    if (a2 == 2)
      v8 = "complete";
    v9 = *((_QWORD *)a1[4] + 1);
    v15 = "nw_candidate_manager_resolver_for_service_resolved_endpoint_block_invoke";
    *(_DWORD *)buf = 136447234;
    v16 = 2048;
    if (a2 == 1)
      v8 = "in-progress";
    v17 = v9;
    v18 = 2112;
    v19 = v7;
    v20 = 2082;
    v21 = v8;
    v22 = 2112;
    v23 = v5;
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] %@ %{public}s resolves to %@", buf, 0x34u);
  }

  if (v5)
  {
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = ___ZL59nw_candidate_manager_resolver_for_service_resolved_endpointP31NWConcrete_nw_candidate_managerPU25objcproto14OS_nw_endpoint8NSObject_block_invoke_152;
    v10[3] = &unk_1E14AA9F0;
    v11 = a1[6];
    v12 = a1[5];
    v13 = a1[4];
    nw_array_apply(v5, (uint64_t)v10);

  }
}

uint64_t ___ZL59nw_candidate_manager_resolver_for_service_resolved_endpointP31NWConcrete_nw_candidate_managerPU25objcproto14OS_nw_endpoint8NSObject_block_invoke_152(void **a1, uint64_t a2, void *a3)
{
  id v4;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  id v6;
  NWConcrete_nw_candidate_manager *v7;
  id v8;
  NWConcrete_nw_path_evaluator *v9;
  os_unfair_lock_s *v10;
  id *v11;
  id v12;
  _DWORD *v13;
  int v14;
  char v15;
  _DWORD *v16;
  int v17;
  _DWORD *v18;
  int v19;
  char v20;
  void *v21;
  NWConcrete_nw_interface_option_details *v22;
  NWCandidate *v23;
  _DWORD *v25;
  int v26;
  void *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  void *v31;
  os_log_type_t v32;
  void *v33;
  os_log_type_t v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  _BOOL4 v43;
  os_log_type_t v44;
  os_log_type_t v45;
  os_log_type_t v46;
  id v47;
  char v48;
  os_log_type_t type;
  _BYTE buf[22];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v4, a1[4]);
  v6 = nw_endpoint_copy_interface(a1[5]);
  if (v6)
  {
    v7 = a1[6];
    v8 = v4;
    v47 = v6;
    v9 = evaluator_for_endpoint;
    v10 = (os_unfair_lock_s *)v9;
    if (v7)
    {
      if (v8)
      {
        if (v9)
        {
          nw_endpoint_set_interface(v8, 0);
          v11 = v10;
          os_unfair_lock_lock(v10 + 24);
          v12 = v11[6];
          os_unfair_lock_unlock(v10 + 24);

          if (nw_path_is_direct(v12))
          {
            v13 = v47;
            v14 = v13[24];

            if (v14 == 3)
            {
              v15 = 10;
LABEL_12:
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = 0;
              nw_path_get_nexus_agent_uuid(v12, buf);
              v20 = v15;
              v21 = v47;
              v22 = nw_interface_option_details_create(v47, buf, v8, v20, 0, -1);
              nw_interface_option_details_set_evaluator(v22, v11);
              nw_candidate_create(v7, v22, v11);
              v23 = (NWCandidate *)objc_claimAutoreleasedReturnValue();
              nw_candidate_manager_process_candidate_internal(v7, v23);

LABEL_13:
              goto LABEL_14;
            }
            v16 = v13;
            v17 = v13[24];

            if (v17 == 1)
            {
              v18 = v16;
              v19 = v18[25];

              if (v19 == 1001)
              {
                v15 = -1;
              }
              else
              {
                v25 = v18;
                v26 = v18[25];

                if (v26 == 1002)
                  v15 = 0;
                else
                  v15 = -2;
              }
              goto LABEL_12;
            }
          }
          v15 = -2;
          goto LABEL_12;
        }
        __nwlog_obj();
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
        v28 = (char *)_os_log_send_and_compose_impl();

        v21 = v47;
        type = OS_LOG_TYPE_ERROR;
        v48 = 0;
        if (!__nwlog_fault(v28, &type, &v48))
          goto LABEL_67;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v34 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null evaluator", buf, 0xCu);
          }
LABEL_32:

          goto LABEL_67;
        }
        if (v48)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v42 = type;
          v43 = os_log_type_enabled(v36, type);
          if (backtrace_string)
          {
            if (v43)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v36, v42, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
            }
            goto LABEL_47;
          }
          if (v43)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_182FBE000, v36, v42, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v46 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_182FBE000, v36, v46, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      else
      {
        __nwlog_obj();
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
        v28 = (char *)_os_log_send_and_compose_impl();

        v21 = v47;
        type = OS_LOG_TYPE_ERROR;
        v48 = 0;
        if (!__nwlog_fault(v28, &type, &v48))
          goto LABEL_67;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v32 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null destination", buf, 0xCu);
          }
          goto LABEL_32;
        }
        if (v48)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v40 = type;
          v41 = os_log_type_enabled(v36, type);
          if (backtrace_string)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v36, v40, "%{public}s called with null destination, dumping backtrace:%{public}s", buf, 0x16u);
            }
LABEL_47:

            v21 = v47;
            free(backtrace_string);
            if (!v28)
              goto LABEL_13;
            goto LABEL_68;
          }
          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_182FBE000, v36, v40, "%{public}s called with null destination, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v45 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            _os_log_impl(&dword_182FBE000, v36, v45, "%{public}s called with null destination, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
    }
    else
    {
      __nwlog_obj();
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
      v28 = (char *)_os_log_send_and_compose_impl();

      v21 = v47;
      type = OS_LOG_TYPE_ERROR;
      v48 = 0;
      if (!__nwlog_fault(v28, &type, &v48))
        goto LABEL_67;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null candidate_manager", buf, 0xCu);
        }
        goto LABEL_32;
      }
      if (v48)
      {
        v35 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v37 = type;
        v38 = os_log_type_enabled(v36, type);
        if (v35)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v35;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
          }

          v21 = v47;
          free(v35);
LABEL_67:
          if (!v28)
            goto LABEL_13;
LABEL_68:
          free(v28);
          goto LABEL_13;
        }
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
          _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v36 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_bonjour_candidate";
          _os_log_impl(&dword_182FBE000, v36, v44, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    v21 = v47;
    goto LABEL_67;
  }
LABEL_14:

  return 1;
}

void sub_1833885C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

id nw_candidate_create(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (v5)
  {
    if (v6)
    {
      v8 = -[NWCandidate initCandidate:forManager:evaluator:]([NWCandidate alloc], "initCandidate:forManager:evaluator:", v6, v5, v7);
      goto LABEL_4;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_candidate_create";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_candidate_create";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null details", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_candidate_create";
          _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_candidate_create";
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null details, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_candidate_create";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_candidate_create";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_candidate_create";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null manager", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_candidate_create";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_candidate_create";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null manager, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_candidate_create";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v11)
    free(v11);
  v8 = 0;
LABEL_4:

  return v8;
}

void sub_183388B08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_candidate_manager_process_candidate_internal(NWConcrete_nw_candidate_manager *a1, NWCandidate *a2)
{
  NWConcrete_nw_candidate_manager *v3;
  NWCandidate *v4;
  NWCandidate *v5;
  NSObject *v6;
  unint64_t log_id;
  unsigned __int8 *candidates;
  uint64_t v9;
  NWCandidate *v10;
  NSObject *v11;
  unint64_t v12;
  OS_nw_endpoint *original_remote_endpoint;
  id v14;
  unint64_t v15;
  uint64_t v16;
  id v18;
  _BOOL4 v19;
  nw_parameters_t *v20;
  NWCandidate *v21;
  NSObject *v22;
  nw_connection_t v23;
  NWConcrete_nw_candidate_manager *v24;
  NWConcrete_nw_connection *v25;
  NSObject *v26;
  unint64_t v27;
  void (**new_connection_handler)(id, NWConcrete_nw_connection *);
  NSObject *v29;
  unint64_t v30;
  void *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  void *v35;
  os_log_type_t v36;
  char *backtrace_string;
  os_log_type_t v38;
  _BOOL4 v39;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  os_log_type_t v43;
  _QWORD v44[4];
  NWCandidate *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  char v50;
  uint8_t v51[4];
  const char *v52;
  __int16 v53;
  unint64_t v54;
  __int16 v55;
  NWConcrete_nw_connection *v56;
  _BYTE buf[24];
  NWCandidate *v58;
  NWConcrete_nw_candidate_manager *v59;
  NWConcrete_nw_connection *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v6 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        log_id = v3->log_id;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = log_id;
        *(_WORD *)&buf[22] = 2112;
        v58 = v5;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Checking candidate %@", buf, 0x20u);
      }

      v47 = 0;
      v48 = &v47;
      v49 = 0x2020000000;
      v50 = 0;
      candidates = (unsigned __int8 *)v3->candidates;
      v9 = MEMORY[0x1E0C809B0];
      v44[0] = MEMORY[0x1E0C809B0];
      v44[1] = 3221225472;
      v44[2] = ___ZL47nw_candidate_manager_process_candidate_internalP31NWConcrete_nw_candidate_managerP11NWCandidate_block_invoke;
      v44[3] = &unk_1E14AB5F0;
      v10 = v5;
      v45 = v10;
      v46 = &v47;
      nw_array_apply(candidates, (uint64_t)v44);
      if (*((_BYTE *)v48 + 24))
      {
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v11 = (id)gcandidate_managerLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          v12 = v3->log_id;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v12;
          *(_WORD *)&buf[22] = 2112;
          v58 = v10;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Candidate %@ already collected, ignoring", buf, 0x20u);
        }
      }
      else
      {
        original_remote_endpoint = v3->original_remote_endpoint;
        v14 = nw_interface_option_details_copy_remote_endpoint(v10->details);
        LODWORD(original_remote_endpoint) = nw_endpoint_is_equal(original_remote_endpoint, v14, 0);

        if (!(_DWORD)original_remote_endpoint)
        {
          nw_array_append((uint64_t)v3->candidates, v10);
          -[NWCandidate startEvaluator](v10, "startEvaluator");
          if (-[NWCandidate isEligible](v10, "isEligible"))
          {
            nw_candidate_manager_inject(v3, v10);
          }
          else if ((*((_BYTE *)v10 + 40) & 2) != 0
                 || (*((_BYTE *)v3 + 184) & 2) == 0
                 || v3->connection
                 || (v18 = nw_interface_option_details_copy_interface(v10->details),
                     v19 = nw_interface_get_subtype(v18) == 1002,
                     v18,
                     !v19))
          {
            if (__nwlog_candidate_manager_log::onceToken != -1)
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            v29 = (id)gcandidate_managerLogObj;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
            {
              v30 = v3->log_id;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v30;
              *(_WORD *)&buf[22] = 2112;
              v58 = v10;
              _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Candidate %@ not eligible", buf, 0x20u);
            }

          }
          else
          {
            v20 = v3;
            v21 = v10;
            v22 = nw_interface_option_details_copy_remote_endpoint(v10->details);
            v23 = nw_connection_create(v22, v20[10]);

            *(_QWORD *)buf = v9;
            *(_QWORD *)&buf[8] = 3221225472;
            *(_QWORD *)&buf[16] = ___ZL28nw_candidate_manager_connectP31NWConcrete_nw_candidate_managerP11NWCandidate_block_invoke;
            v58 = (NWCandidate *)&unk_1E14AD048;
            v24 = v20;
            v59 = v24;
            v25 = v23;
            v60 = v25;
            nw_connection_set_state_changed_handler(&v25->super, buf);
            nw_candidate_manager_set_connection(v24, v25);
            *((_BYTE *)v10 + 40) |= 1u;
            if (__nwlog_candidate_manager_log::onceToken != -1)
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            v26 = (id)gcandidate_managerLogObj;
            if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
            {
              v27 = v24->log_id;
              *(_DWORD *)v51 = 136446722;
              v52 = "nw_candidate_manager_connect";
              v53 = 2048;
              v54 = v27;
              v55 = 2112;
              v56 = v25;
              _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Created outgoing connection %@", v51, 0x20u);
            }

            new_connection_handler = (void (**)(id, NWConcrete_nw_connection *))v24->new_connection_handler;
            if (new_connection_handler)
              new_connection_handler[2](new_connection_handler, v25);

          }
          v16 = 1;
          goto LABEL_19;
        }
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v11 = (id)gcandidate_managerLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
        {
          v15 = v3->log_id;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v15;
          *(_WORD *)&buf[22] = 2112;
          v58 = v10;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Candidate %@ matches original, ignoring", buf, 0x20u);
        }
      }

      v16 = 0;
LABEL_19:

      _Block_object_dispose(&v47, 8);
      goto LABEL_20;
    }
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
    v32 = (char *)_os_log_send_and_compose_impl();

    v51[0] = 16;
    LOBYTE(v47) = 0;
    if (__nwlog_fault(v32, v51, &v47))
    {
      if (v51[0] == 17)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v36 = v51[0];
        if (os_log_type_enabled(v33, (os_log_type_t)v51[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          _os_log_impl(&dword_182FBE000, v33, v36, "%{public}s called with null new_candidate", buf, 0xCu);
        }
LABEL_71:

        goto LABEL_72;
      }
      if (!(_BYTE)v47)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v43 = v51[0];
        if (os_log_type_enabled(v33, (os_log_type_t)v51[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          _os_log_impl(&dword_182FBE000, v33, v43, "%{public}s called with null new_candidate, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_71;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v40 = v51[0];
      v41 = os_log_type_enabled(v33, (os_log_type_t)v51[0]);
      if (!backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          _os_log_impl(&dword_182FBE000, v33, v40, "%{public}s called with null new_candidate, no backtrace", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v33, v40, "%{public}s called with null new_candidate, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_59;
    }
  }
  else
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
    v32 = (char *)_os_log_send_and_compose_impl();

    v51[0] = 16;
    LOBYTE(v47) = 0;
    if (__nwlog_fault(v32, v51, &v47))
    {
      if (v51[0] == 17)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v34 = v51[0];
        if (os_log_type_enabled(v33, (os_log_type_t)v51[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null candidate_manager", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (!(_BYTE)v47)
      {
        __nwlog_obj();
        v33 = objc_claimAutoreleasedReturnValue();
        v42 = v51[0];
        if (os_log_type_enabled(v33, (os_log_type_t)v51[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          _os_log_impl(&dword_182FBE000, v33, v42, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_71;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      v38 = v51[0];
      v39 = os_log_type_enabled(v33, (os_log_type_t)v51[0]);
      if (!backtrace_string)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
          _os_log_impl(&dword_182FBE000, v33, v38, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_process_candidate_internal";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v33, v38, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_59:

      free(backtrace_string);
    }
  }
LABEL_72:
  if (v32)
    free(v32);
  v16 = 0;
LABEL_20:

  return v16;
}

void sub_183389498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31,id a32)
{
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;

  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

BOOL ___ZL47nw_candidate_manager_process_candidate_internalP31NWConcrete_nw_candidate_managerP11NWCandidate_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  unint64_t v6;
  unint64_t v7;
  void *v8;
  int v9;
  _BOOL8 v10;

  v4 = a3;
  v5 = *(void **)(a1 + 32);
  v6 = (unint64_t)v4;
  v7 = v5;
  if (v6 | v7)
  {
    v8 = (void *)v7;
    if (!v6 || !v7)
    {

      goto LABEL_8;
    }
    v9 = objc_msgSend(*(id *)(v6 + 16), "isEqual:", *(_QWORD *)(v7 + 16));

    if (!v9)
      goto LABEL_8;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
LABEL_8:
  v10 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) == 0;

  return v10;
}

void sub_1833895B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL28nw_candidate_manager_connectP31NWConcrete_nw_candidate_managerP11NWCandidate_block_invoke(uint64_t a1, int a2, void *a3)
{
  id v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  nw_protocol_metadata_t v11;
  NSObject *v12;
  NSObject *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 is_quic_stream;
  id v18;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  id v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (a2 == 3)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v6 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = *(_QWORD *)(a1 + 40);
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v19 = 136446722;
      v20 = "nw_candidate_manager_connect_block_invoke";
      v21 = 2048;
      v22 = v8;
      v23 = 2112;
      v24 = v7;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Outgoing connection %@ is ready", (uint8_t *)&v19, 0x20u);
    }

    v9 = *(NSObject **)(a1 + 40);
    if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
    v10 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
    v11 = nw_connection_copy_protocol_metadata(v9, v10);

    if (!v11)
      goto LABEL_19;
    v12 = v11;
    if (nw_protocol_metadata_is_quic_connection(v12))
    {

    }
    else
    {
      is_quic_stream = nw_protocol_metadata_is_quic_stream(v12);

      if (!is_quic_stream)
      {
LABEL_19:
        nw_candidate_manager_set_state(*(_QWORD *)(a1 + 32), 2);

        goto LABEL_20;
      }
    }
    v18 = nw_quic_stream_copy_connection_metadata(v12);
    nw_quic_connection_set_keepalive(v18, 10);

    goto LABEL_19;
  }
  if ((a2 & 0xFFFFFFFE) == 4)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v13 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = off_1E149DE10[a2];
      v15 = *(_QWORD *)(a1 + 40);
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v19 = 136447234;
      v20 = "nw_candidate_manager_connect_block_invoke";
      v21 = 2048;
      v22 = v16;
      v23 = 2112;
      v24 = v15;
      v25 = 2080;
      v26 = v14;
      v27 = 2112;
      v28 = v5;
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Outgoing connection %@ to endpoint disconnected, state=%s, error=%@", (uint8_t *)&v19, 0x34u);
    }

    nw_candidate_manager_cancel(*(_QWORD *)(a1 + 32));
  }
LABEL_20:

}

void sub_18338986C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_cancel(void *a1)
{
  NSObject *v1;
  unint64_t log_id;
  NSObject *listener;
  OS_nw_listener *v4;
  OS_nw_resolver *awdl_service_resolver;
  OS_nw_resolver *v6;
  OS_nw_resolver *service_resolver;
  OS_nw_resolver *v8;
  NSMutableDictionary *hostname_resolvers;
  void *v10;
  NSMutableDictionary *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NWConcrete_nw_candidate_manager *v16;
  NSObject *v17;
  unint64_t v18;
  NSObject *p_super;
  NWConcrete_nw_connection *connection;
  OS_nw_array *candidates;
  id state_handler;
  id new_connection_handler;
  OS_nw_parameters *parameters;
  id add_eligible_details;
  id remove_eligible_details;
  id modify_ids_parameters;
  void *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  NWConcrete_nw_candidate_manager *v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  char v41;
  os_log_type_t type;
  uint8_t v43[128];
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  char *v47;
  __int16 v48;
  NWConcrete_nw_candidate_manager *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v36 = a1;
  if (v36)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v1 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      log_id = v36->log_id;
      *(_DWORD *)buf = 136446722;
      v45 = "nw_candidate_manager_cancel";
      v46 = 2048;
      v47 = (char *)log_id;
      v48 = 2112;
      v49 = v36;
      _os_log_impl(&dword_182FBE000, v1, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Cancelling candidate_manager %@", buf, 0x20u);
    }

    nw_candidate_manager_set_state(v36, 4);
    nw_candidate_manager_stop_lost_path_timer(v36);
    listener = v36->listener;
    if (listener)
    {
      nw_listener_cancel(listener);
      v4 = v36->listener;
      v36->listener = 0;

    }
    awdl_service_resolver = v36->awdl_service_resolver;
    if (awdl_service_resolver)
    {
      nw_resolver_cancel(awdl_service_resolver);
      v6 = v36->awdl_service_resolver;
      v36->awdl_service_resolver = 0;

    }
    service_resolver = v36->service_resolver;
    if (service_resolver)
    {
      nw_resolver_cancel(service_resolver);
      v8 = v36->service_resolver;
      v36->service_resolver = 0;

    }
    hostname_resolvers = v36->hostname_resolvers;
    if (hostname_resolvers)
    {
      -[NSMutableDictionary allValues](hostname_resolvers, "allValues");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = v36->hostname_resolvers;
      v36->hostname_resolvers = 0;

      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      v12 = v10;
      v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v37, v43, 16);
      if (v13)
      {
        v14 = *(_QWORD *)v38;
        do
        {
          v15 = 0;
          do
          {
            if (*(_QWORD *)v38 != v14)
              objc_enumerationMutation(v12);
            v16 = *(NWConcrete_nw_candidate_manager **)(*((_QWORD *)&v37 + 1) + 8 * v15);
            if (__nwlog_candidate_manager_log::onceToken != -1)
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            v17 = (id)gcandidate_managerLogObj;
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              v18 = v36->log_id;
              *(_DWORD *)buf = 136446722;
              v45 = "nw_candidate_manager_cancel";
              v46 = 2048;
              v47 = (char *)v18;
              v48 = 2112;
              v49 = v16;
              _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [CM%zu] Removed %@", buf, 0x20u);
            }

            nw_resolver_cancel(v16);
            ++v15;
          }
          while (v13 != v15);
          v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v37, v43, 16);
        }
        while (v13);
      }

    }
    p_super = &v36->connection->super;
    if (p_super)
    {
      nw_connection_cancel(p_super);
      connection = v36->connection;
      v36->connection = 0;

    }
    nw_candidate_manager_stop_ids(v36);
    candidates = v36->candidates;
    v36->candidates = 0;

    state_handler = v36->state_handler;
    v36->state_handler = 0;

    new_connection_handler = v36->new_connection_handler;
    v36->new_connection_handler = 0;

    parameters = v36->parameters;
    v36->parameters = 0;

    add_eligible_details = v36->add_eligible_details;
    v36->add_eligible_details = 0;

    remove_eligible_details = v36->remove_eligible_details;
    v36->remove_eligible_details = 0;

    modify_ids_parameters = v36->modify_ids_parameters;
    v36->modify_ids_parameters = 0;

    goto LABEL_28;
  }
  __nwlog_obj();
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v45 = "nw_candidate_manager_cancel";
  v29 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v29, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_candidate_manager_cancel";
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      v34 = os_log_type_enabled(v30, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_candidate_manager_cancel";
          v46 = 2082;
          v47 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v30, v33, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_45;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_candidate_manager_cancel";
        _os_log_impl(&dword_182FBE000, v30, v33, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_candidate_manager_cancel";
        _os_log_impl(&dword_182FBE000, v30, v35, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_45:
  if (v29)
    free(v29);
LABEL_28:

}

void sub_183389E6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_stop_ids(NWConcrete_nw_candidate_manager *a1)
{
  NWConcrete_nw_candidate_manager *v1;
  NSObject *v2;
  unint64_t log_id;
  OS_nw_path_evaluator *ids_path_evaluator;
  uint64_t ids_resolve_registrations;
  OS_nw_endpoint *ids_endpoint;
  _QWORD v7[4];
  NWConcrete_nw_candidate_manager *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1->ids_path_evaluator)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v2 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      log_id = v1->log_id;
      *(_DWORD *)buf = 136446466;
      v10 = "nw_candidate_manager_stop_ids";
      v11 = 2048;
      v12 = log_id;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Stopping IDS path evaluator", buf, 0x16u);
    }

    nw_path_evaluator_cancel(v1->ids_path_evaluator);
    ids_path_evaluator = v1->ids_path_evaluator;
    v1->ids_path_evaluator = 0;

  }
  ids_resolve_registrations = (uint64_t)v1->ids_resolve_registrations;
  if (ids_resolve_registrations)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZL29nw_candidate_manager_stop_idsP31NWConcrete_nw_candidate_manager_block_invoke;
    v7[3] = &unk_1E14A8D48;
    v8 = v1;
    nw_dictionary_apply(ids_resolve_registrations, (uint64_t)v7);

  }
  ids_endpoint = v1->ids_endpoint;
  v1->ids_endpoint = 0;

}

void sub_18338A008(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_candidate_manager_stop_idsP31NWConcrete_nw_candidate_manager_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  NSObject *v6;
  uint64_t v7;
  int v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v6 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v9 = 136446722;
    v10 = "nw_candidate_manager_stop_ids_block_invoke";
    v11 = 2048;
    v12 = v7;
    v13 = 2082;
    v14 = a2;
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] closed resolver flow to %{public}s", (uint8_t *)&v9, 0x20u);
  }

  nw_path_flow_registration_close(v5);
  return 1;
}

void sub_18338A138(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_candidate_manager_start_ids_internal_block_invoke(uint64_t a1)
{
  nw_candidate_manager_handle_ids_path(*(void **)(a1 + 32), *(void **)(a1 + 40));
}

void __nw_candidate_manager_start_ids_internal_block_invoke_2(uint64_t a1, void *a2)
{
  nw_candidate_manager_handle_ids_path(*(void **)(a1 + 32), a2);
}

void nw_candidate_manager_handle_ids_path(void *a1, void *a2)
{
  char **v3;
  NSObject *v4;
  char *v5;
  uint64_t v6;
  id *v7;
  id v8;
  id *v9;
  NSObject *v10;
  char *v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  id v16;
  id *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  id v24;
  id v25;
  NSObject *v26;
  os_log_type_t v27;
  id v28;
  char *v29;
  const char *v30;
  NSObject *v31;
  os_log_type_t v32;
  id v33;
  NSObject *v34;
  os_log_type_t v35;
  id v36;
  NSObject *v37;
  os_log_type_t v38;
  id v39;
  uint64_t v40;
  unsigned __int8 *v41;
  uint64_t v42;
  void *v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  char *backtrace_string;
  NSObject *v48;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  uint8_t *v52;
  uint64_t v53;
  char *v54;
  NSObject *log;
  NSObject *loga;
  id *v57;
  const char *v58;
  char **v59;
  unsigned __int8 *object;
  unsigned __int8 *v61;
  _QWORD v62[4];
  id *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  void (*v69)(uint64_t);
  id v70;
  char v71;
  os_log_type_t type;
  os_log_type_t v73[16];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  _QWORD v77[4];
  id v78;
  id *v79;
  uint8_t v80[4];
  const char *v81;
  __int16 v82;
  id v83;
  __int16 v84;
  uint64_t v85;
  __int16 v86;
  char *v87;
  uint8_t buf[4];
  const char *v89;
  __int16 v90;
  char *v91;
  __int16 v92;
  unsigned __int8 *v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v61 = a2;
  v59 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v89 = "nw_candidate_manager_handle_ids_path";
    v44 = (char *)_os_log_send_and_compose_impl();

    v73[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v77[0]) = 0;
    if (__nwlog_fault(v44, v73, v77))
    {
      if (v73[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v45 = objc_claimAutoreleasedReturnValue();
        v46 = v73[0];
        if (os_log_type_enabled(v45, v73[0]))
        {
          *(_DWORD *)buf = 136446210;
          v89 = "nw_candidate_manager_handle_ids_path";
          _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s called with null manager", buf, 0xCu);
        }
      }
      else
      {
        if (LOBYTE(v77[0]))
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v48 = objc_claimAutoreleasedReturnValue();
          v49 = v73[0];
          v50 = os_log_type_enabled(v48, v73[0]);
          if (backtrace_string)
          {
            if (v50)
            {
              *(_DWORD *)buf = 136446466;
              v89 = "nw_candidate_manager_handle_ids_path";
              v90 = 2082;
              v91 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v50)
            {
              *(_DWORD *)buf = 136446210;
              v89 = "nw_candidate_manager_handle_ids_path";
              _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null manager, no backtrace", buf, 0xCu);
            }

          }
          goto LABEL_75;
        }
        __nwlog_obj();
        v45 = objc_claimAutoreleasedReturnValue();
        v51 = v73[0];
        if (os_log_type_enabled(v45, v73[0]))
        {
          *(_DWORD *)buf = 136446210;
          v89 = "nw_candidate_manager_handle_ids_path";
          _os_log_impl(&dword_182FBE000, v45, v51, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_75:
    if (v44)
      free(v44);
    goto LABEL_55;
  }
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v4 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = v3[1];
    *(_DWORD *)buf = 136446722;
    v89 = "nw_candidate_manager_handle_ids_path";
    v90 = 2048;
    v91 = v5;
    v92 = 2112;
    v93 = v61;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] path: %@", buf, 0x20u);
  }

  v65 = 0;
  v66 = &v65;
  v67 = 0x3032000000;
  v68 = __Block_byref_object_copy__2752;
  v69 = __Block_byref_object_dispose__2753;
  v6 = MEMORY[0x1E0C809B0];
  v70 = 0;
  v62[0] = MEMORY[0x1E0C809B0];
  v62[1] = 3221225472;
  v62[2] = ___ZL36nw_candidate_manager_handle_ids_pathP31NWConcrete_nw_candidate_managerPU21objcproto10OS_nw_path8NSObject_block_invoke;
  v62[3] = &unk_1E149A728;
  v64 = &v65;
  v7 = v59;
  v63 = v7;
  nw_path_enumerate_resolve_options(v61, v62);
  objc_storeStrong(v7 + 3, (id)v66[5]);
  v8 = nw_path_copy_resolved_endpoints(v61);
  v9 = v7;
  object = (unsigned __int8 *)v8;
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v10 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = (char *)v9[1];
    *(_DWORD *)buf = 136446722;
    v89 = "nw_candidate_manager_handle_ids_endpoints";
    v90 = 2048;
    v91 = v11;
    v92 = 2112;
    v93 = object;
    _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] endpoints: %@", buf, 0x20u);
  }

  v12 = v9[4];
  if (v12)
  {
    v13 = (void *)MEMORY[0x1E0C99DE8];
    objc_msgSend(v12, "allKeys");
    v14 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "arrayWithArray:", v14);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_12:

    v77[0] = v6;
    v77[1] = 3221225472;
    v77[2] = ___ZL41nw_candidate_manager_handle_ids_endpointsP31NWConcrete_nw_candidate_managerPU22objcproto11OS_nw_array8NSObject_block_invoke;
    v77[3] = &unk_1E14A8D20;
    v16 = v15;
    v78 = v16;
    v17 = v9;
    v79 = v17;
    nw_array_apply(object, (uint64_t)v77);
    *(_OWORD *)v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    v76 = 0u;
    v18 = v16;
    v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", v73, buf, 16);
    if (!v19)
      goto LABEL_53;
    v20 = *(_QWORD *)v74;
    while (1)
    {
      v21 = 0;
      do
      {
        if (*(_QWORD *)v74 != v20)
          objc_enumerationMutation(v18);
        v22 = *(_QWORD *)(*(_QWORD *)&v73[8] + 8 * v21);
        objc_msgSend(v9[4], "objectForKeyedSubscript:", v22, v52, v53);
        v23 = objc_claimAutoreleasedReturnValue();
        objc_msgSend(v9[4], "removeObjectForKey:", v22);
        if (v23)
        {
          if (nw_array_remove_object((uint64_t)v17[18], v23) && (*(_BYTE *)(v23 + 40) & 8) != 0)
            nw_candidate_manager_remove((NWConcrete_nw_candidate_manager *)v17, (NWCandidate *)v23);
        }
        else
        {
          if (__nwlog_candidate_manager_log::onceToken != -1)
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
          v24 = (id)gcandidate_managerLogObj;
          v25 = v17[1];
          *(_DWORD *)v80 = 136446722;
          v81 = "nw_candidate_manager_handle_ids_endpoints";
          v82 = 2048;
          v83 = v25;
          v84 = 2112;
          v85 = v22;
          LODWORD(v53) = 32;
          v52 = v80;
          v58 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v71 = 0;
          if (!__nwlog_fault(v58, &type, &v71))
            goto LABEL_32;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v57 = v7;
            if (__nwlog_candidate_manager_log::onceToken != -1)
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            v26 = (id)gcandidate_managerLogObj;
            v27 = type;
            if (os_log_type_enabled(v26, type))
            {
              v28 = v17[1];
              *(_DWORD *)v80 = 136446722;
              v81 = "nw_candidate_manager_handle_ids_endpoints";
              v82 = 2048;
              v83 = v28;
              v84 = 2112;
              v85 = v22;
              _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s [CM%zu] No resolver for %@", v80, 0x20u);
            }

            v7 = v57;
LABEL_32:
            v29 = (char *)v58;
            if (!v58)
              goto LABEL_21;
LABEL_33:
            free(v29);
            goto LABEL_21;
          }
          if (!v71)
          {
            if (__nwlog_candidate_manager_log::onceToken != -1)
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            v34 = (id)gcandidate_managerLogObj;
            v35 = type;
            loga = v34;
            if (os_log_type_enabled(v34, type))
            {
              v36 = v17[1];
              *(_DWORD *)v80 = 136446722;
              v81 = "nw_candidate_manager_handle_ids_endpoints";
              v82 = 2048;
              v83 = v36;
              v84 = 2112;
              v85 = v22;
              _os_log_impl(&dword_182FBE000, loga, v35, "%{public}s [CM%zu] No resolver for %@, backtrace limit exceeded", v80, 0x20u);
            }
            goto LABEL_46;
          }
          v30 = __nw_create_backtrace_string();
          if (!v30)
          {
            if (__nwlog_candidate_manager_log::onceToken != -1)
              dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
            v37 = (id)gcandidate_managerLogObj;
            v38 = type;
            loga = v37;
            if (os_log_type_enabled(v37, type))
            {
              v39 = v17[1];
              *(_DWORD *)v80 = 136446722;
              v81 = "nw_candidate_manager_handle_ids_endpoints";
              v82 = 2048;
              v83 = v39;
              v84 = 2112;
              v85 = v22;
              _os_log_impl(&dword_182FBE000, loga, v38, "%{public}s [CM%zu] No resolver for %@, no backtrace", v80, 0x20u);
            }
LABEL_46:

            goto LABEL_32;
          }
          v54 = (char *)v30;
          if (__nwlog_candidate_manager_log::onceToken != -1)
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
          v31 = (id)gcandidate_managerLogObj;
          v32 = type;
          log = v31;
          if (os_log_type_enabled(v31, type))
          {
            v33 = v17[1];
            *(_DWORD *)v80 = 136446978;
            v81 = "nw_candidate_manager_handle_ids_endpoints";
            v82 = 2048;
            v83 = v33;
            v84 = 2112;
            v85 = v22;
            v86 = 2082;
            v87 = v54;
            _os_log_impl(&dword_182FBE000, log, v32, "%{public}s [CM%zu] No resolver for %@, dumping backtrace:%{public}s", v80, 0x2Au);
          }

          free(v54);
          v29 = (char *)v58;
          if (v58)
            goto LABEL_33;
        }
LABEL_21:

        ++v21;
      }
      while (v19 != v21);
      v40 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", v73, buf, 16);
      v19 = v40;
      if (!v40)
      {
LABEL_53:

        v41 = object;
        goto LABEL_54;
      }
    }
  }
  v41 = object;
  if (object && *((_QWORD *)object + 2) != *((_QWORD *)object + 3))
  {
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v42 = objc_claimAutoreleasedReturnValue();
    v15 = 0;
    v14 = v9[4];
    v9[4] = (id)v42;
    goto LABEL_12;
  }
LABEL_54:

  _Block_object_dispose(&v65, 8);
LABEL_55:

}

void sub_18338ABA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,id a37)
{
  void *v37;
  void *v38;
  void *v39;

  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

void ___ZL36nw_candidate_manager_handle_ids_pathP31NWConcrete_nw_candidate_managerPU21objcproto10OS_nw_path8NSObject_block_invoke(uint64_t a1, unsigned __int8 *uu)
{
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  NWConcrete_nw_path_flow_registration *v11;
  NWConcrete_nw_path_flow_registration *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unsigned __int8 *v25;
  char out[40];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40))
  {
    v4 = nw_dictionary_create();
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v6 = *(void **)(v5 + 40);
    *(_QWORD *)(v5 + 40) = v4;

  }
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(v7 + 24);
  if (v8)
  {
    v9 = nw_dictionary_copy_value(v8, (uint64_t)out);
    if (v9)
    {
      v10 = v9;
      nw_dictionary_set_value(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), out, v9);

      return;
    }
    v7 = *(_QWORD *)(a1 + 32);
  }
  v17 = 0;
  v11 = nw_path_evaluator_create_flow_inner(*(void **)(v7 + 176), 0, 0, 0, 1, uu, 0, 0, &v17);
  v12 = v11;
  if (v17 || !v11)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v15 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)buf = 136446722;
      v19 = "nw_candidate_manager_handle_ids_path_block_invoke";
      v20 = 2048;
      v21 = v16;
      v22 = 1024;
      v23 = v17;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] nw_path_evaluator_create_flow failed: %{darwin.errno}d", buf, 0x1Cu);
    }

  }
  else
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v13 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)buf = 136446978;
      v19 = "nw_candidate_manager_handle_ids_path_block_invoke";
      v20 = 2048;
      v21 = v14;
      v22 = 1040;
      v23 = 16;
      v24 = 2096;
      v25 = uu;
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] created resolver flow to %{uuid_t}.16P", buf, 0x26u);
    }

    nw_dictionary_set_value(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), out, v12);
  }

}

uint64_t ___ZL41nw_candidate_manager_handle_ids_endpointsP31NWConcrete_nw_candidate_managerPU22objcproto11OS_nw_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  nw_txt_record_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  id v10;
  NWConcrete_nw_path_evaluator *evaluator_for_client_id;
  id *v12;
  NSObject *v13;
  nw_endpoint_t v14;
  NSObject *v15;
  uint64_t v16;
  BOOL v17;
  id v18;
  void *v19;
  char v20;
  NWConcrete_nw_interface_option_details *v21;
  NWCandidate *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  unsigned int *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  const char *v32;
  NSObject *v33;
  uint64_t v34;
  nw_txt_record_t v35;
  void *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  void *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  void *v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  void *v49;
  NSObject *v50;
  os_log_type_t v51;
  void *v52;
  NSObject *v53;
  os_log_type_t v54;
  void *v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  char *backtrace_string;
  os_log_type_t v60;
  _BOOL4 v61;
  char *v62;
  os_log_type_t v63;
  _BOOL4 v64;
  char *v65;
  os_log_type_t v66;
  _BOOL4 v67;
  char *v68;
  os_log_type_t v69;
  _BOOL4 v70;
  os_log_type_t v71;
  _BOOL4 v72;
  char *v73;
  os_log_type_t v74;
  _BOOL4 v75;
  os_log_type_t v76;
  os_log_type_t v77;
  os_log_type_t v78;
  os_log_type_t v79;
  os_log_type_t v80;
  os_log_type_t v81;
  uint64_t v82;
  NSObject *v83;
  uint64_t v84;
  id v85;
  NSObject *endpoint;
  char v87;
  uint64_t v88;
  void *v89;
  void *v90;
  _BYTE access_value[24];
  _BYTE v92[18];
  __int16 v93;
  const char *v94;
  __int16 v95;
  const char *v96;
  __int16 v97;
  NWCandidate *v98;
  __int128 v99;
  _QWORD v100[4];

  v100[2] = *MEMORY[0x1E0C80C00];
  v4 = a3;
  endpoint = v4;
  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:", v4))
  {
    objc_msgSend(*(id *)(a1 + 32), "removeObject:", v4);
    goto LABEL_52;
  }
  v85 = *(id *)(a1 + 40);
  v5 = nw_endpoint_copy_txt_record(v4);
  v6 = v5;
  v84 = a1;
  if (!v5)
  {
    __nwlog_obj();
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_value = 136446210;
    *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    v38 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v100[0]) = 16;
    LOBYTE(v99) = 0;
    if (__nwlog_fault(v38, v100, &v99))
    {
      if (LOBYTE(v100[0]) == 17)
      {
        __nwlog_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v40 = v100[0];
        if (os_log_type_enabled(v39, v100[0]))
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s called with null metadata", access_value, 0xCu);
        }
      }
      else if ((_BYTE)v99)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v60 = v100[0];
        v61 = os_log_type_enabled(v39, v100[0]);
        if (backtrace_string)
        {
          if (v61)
          {
            *(_DWORD *)access_value = 136446466;
            *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
            *(_WORD *)&access_value[12] = 2082;
            *(_QWORD *)&access_value[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v39, v60, "%{public}s called with null metadata, dumping backtrace:%{public}s", access_value, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_136;
        }
        if (v61)
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v39, v60, "%{public}s called with null metadata, no backtrace", access_value, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v39 = objc_claimAutoreleasedReturnValue();
        v76 = v100[0];
        if (os_log_type_enabled(v39, v100[0]))
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v39, v76, "%{public}s called with null metadata, backtrace limit exceeded", access_value, 0xCu);
        }
      }

    }
LABEL_136:
    if (v38)
      free(v38);
    v22 = 0;
    goto LABEL_44;
  }
  v90 = 0;
  v83 = v5;
  if (!nw_txt_record_get_key_data_value(v5, "lcid", &v90))
  {
    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_value = 136446210;
    *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    v42 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v100[0]) = 16;
    LOBYTE(v99) = 0;
    if (__nwlog_fault(v42, v100, &v99))
    {
      if (LOBYTE(v100[0]) == 17)
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v44 = v100[0];
        if (os_log_type_enabled(v43, v100[0]))
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyLocalCID, &lcid)", access_value, 0xCu);
        }
      }
      else if ((_BYTE)v99)
      {
        v62 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v63 = v100[0];
        v64 = os_log_type_enabled(v43, v100[0]);
        if (v62)
        {
          if (v64)
          {
            *(_DWORD *)access_value = 136446466;
            *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
            *(_WORD *)&access_value[12] = 2082;
            *(_QWORD *)&access_value[14] = v62;
            _os_log_impl(&dword_182FBE000, v43, v63, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyLocalCID, &lcid), dumping backtrace:%{public}s", access_value, 0x16u);
          }

          free(v62);
          goto LABEL_142;
        }
        if (v64)
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v43, v63, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyLocalCID, &lcid), no backtrace", access_value, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v77 = v100[0];
        if (os_log_type_enabled(v43, v100[0]))
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v43, v77, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyLocalCID, &lcid), backtrace limit exceeded", access_value, 0xCu);
        }
      }

    }
LABEL_142:
    if (v42)
      free(v42);
    v22 = 0;
    goto LABEL_43;
  }
  v89 = 0;
  if (!nw_txt_record_get_key_data_value(v6, "rcid", &v89))
  {
    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_value = 136446210;
    *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    v46 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v100[0]) = 16;
    LOBYTE(v99) = 0;
    if (!__nwlog_fault(v46, v100, &v99))
      goto LABEL_154;
    if (LOBYTE(v100[0]) == 17)
    {
      __nwlog_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      v48 = v100[0];
      if (os_log_type_enabled(v47, v100[0]))
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyRemoteCID, &rcid)", access_value, 0xCu);
      }
    }
    else if ((_BYTE)v99)
    {
      v65 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      v66 = v100[0];
      v67 = os_log_type_enabled(v47, v100[0]);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)access_value = 136446466;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          *(_WORD *)&access_value[12] = 2082;
          *(_QWORD *)&access_value[14] = v65;
          _os_log_impl(&dword_182FBE000, v47, v66, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyRemoteCID, &rcid), dumping backtrace:%{public}s", access_value, 0x16u);
        }

        free(v65);
LABEL_154:
        if (!v46)
        {
LABEL_156:
          v22 = 0;
          goto LABEL_42;
        }
LABEL_155:
        free(v46);
        goto LABEL_156;
      }
      if (v67)
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v47, v66, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyRemoteCID, &rcid), no backtrace", access_value, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v47 = objc_claimAutoreleasedReturnValue();
      v78 = v100[0];
      if (os_log_type_enabled(v47, v100[0]))
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v47, v78, "%{public}s called with null nw_txt_record_get_key_data_value(metadata, kIDSKeyRemoteCID, &rcid), backtrace limit exceeded", access_value, 0xCu);
      }
    }

    goto LABEL_154;
  }
  v88 = 0;
  v7 = MEMORY[0x1E0C809B0];
  *(_QWORD *)access_value = MEMORY[0x1E0C809B0];
  *(_QWORD *)&access_value[8] = 3221225472;
  *(_QWORD *)&access_value[16] = ___ZL34nw_txt_record_get_key_uint64_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPy_block_invoke;
  *(_QWORD *)v92 = &__block_descriptor_40_e19_B36__0r_8i16r_20Q28l;
  *(_QWORD *)&v92[8] = &v88;
  if (!nw_txt_record_access_key(v6, "rift", access_value))
  {
    __nwlog_obj();
    v49 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_value = 136446210;
    *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    v46 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v100[0]) = 16;
    LOBYTE(v99) = 0;
    if (!__nwlog_fault(v46, v100, &v99))
      goto LABEL_154;
    if (LOBYTE(v100[0]) == 17)
    {
      __nwlog_obj();
      v50 = objc_claimAutoreleasedReturnValue();
      v51 = v100[0];
      if (os_log_type_enabled(v50, v100[0]))
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v50, v51, "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift)", access_value, 0xCu);
      }
    }
    else if ((_BYTE)v99)
    {
      v68 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v50 = objc_claimAutoreleasedReturnValue();
      v69 = v100[0];
      v70 = os_log_type_enabled(v50, v100[0]);
      if (v68)
      {
        if (v70)
        {
          *(_DWORD *)access_value = 136446466;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          *(_WORD *)&access_value[12] = 2082;
          *(_QWORD *)&access_value[14] = v68;
          _os_log_impl(&dword_182FBE000, v50, v69, "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift), dumping backtrace:%{public}s", access_value, 0x16u);
        }

        goto LABEL_108;
      }
      if (v70)
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v50, v69, "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift), no backtrace", access_value, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v50 = objc_claimAutoreleasedReturnValue();
      v79 = v100[0];
      if (os_log_type_enabled(v50, v100[0]))
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v50, v79, "%{public}s called with null nw_txt_record_get_key_uint64_value(metadata, kIDSKeyRemoteInterfaceType, &rift), backtrace limit exceeded", access_value, 0xCu);
      }
    }

    goto LABEL_154;
  }
  v100[0] = 0;
  v100[1] = 0;
  *(_QWORD *)access_value = v7;
  *(_QWORD *)&access_value[8] = 3221225472;
  *(_QWORD *)&access_value[16] = ___ZL32nw_txt_record_get_key_uuid_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPh_block_invoke;
  *(_QWORD *)v92 = &__block_descriptor_40_e19_B36__0r_8i16r_20Q28l;
  *(_QWORD *)&v92[8] = v100;
  if (!nw_txt_record_access_key(v6, "eval", access_value))
  {
    __nwlog_obj();
    v52 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_value = 136446210;
    *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    v46 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v99) = 16;
    v87 = 0;
    if (!__nwlog_fault(v46, &v99, &v87))
      goto LABEL_154;
    if (v99 == 17)
    {
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v54 = v99;
      if (os_log_type_enabled(v53, (os_log_type_t)v99))
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id)", access_value, 0xCu);
      }
LABEL_153:

      goto LABEL_154;
    }
    if (!v87)
    {
      __nwlog_obj();
      v53 = objc_claimAutoreleasedReturnValue();
      v80 = v99;
      if (os_log_type_enabled(v53, (os_log_type_t)v99))
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v53, v80, "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id), backtrace limit exceeded", access_value, 0xCu);
      }
      goto LABEL_153;
    }
    v68 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v53 = objc_claimAutoreleasedReturnValue();
    v71 = v99;
    v72 = os_log_type_enabled(v53, (os_log_type_t)v99);
    if (!v68)
    {
      if (v72)
      {
        *(_DWORD *)access_value = 136446210;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        _os_log_impl(&dword_182FBE000, v53, v71, "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id), no backtrace", access_value, 0xCu);
      }
      goto LABEL_153;
    }
    if (v72)
    {
      *(_DWORD *)access_value = 136446466;
      *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
      *(_WORD *)&access_value[12] = 2082;
      *(_QWORD *)&access_value[14] = v68;
      _os_log_impl(&dword_182FBE000, v53, v71, "%{public}s called with null nw_txt_record_get_key_uuid_value(metadata, kIDSKeyEvaluatorUUID, evaluator_id), dumping backtrace:%{public}s", access_value, 0x16u);
    }

LABEL_108:
    free(v68);
    if (!v46)
      goto LABEL_156;
    goto LABEL_155;
  }
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v8 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v9 = *((_QWORD *)v85 + 1);
    *(_DWORD *)access_value = 136446978;
    *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    *(_WORD *)&access_value[12] = 2048;
    *(_QWORD *)&access_value[14] = v9;
    *(_WORD *)&access_value[22] = 1040;
    *(_DWORD *)v92 = 16;
    *(_WORD *)&v92[4] = 2096;
    *(_QWORD *)&v92[6] = v100;
    _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s [CM%zu] looking up evaluator for %{uuid_t}.16P", access_value, 0x26u);
  }

  v10 = nw_parameters_copy_context(*((void **)v85 + 10));
  evaluator_for_client_id = nw_path_create_evaluator_for_client_id((const unsigned __int8 *)v100, v10);

  if (!evaluator_for_client_id)
  {
    __nwlog_obj();
    v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)access_value = 136446210;
    *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
    v56 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v99) = 16;
    v87 = 0;
    if (__nwlog_fault(v56, &v99, &v87))
    {
      if (v99 == 17)
      {
        __nwlog_obj();
        v57 = objc_claimAutoreleasedReturnValue();
        v58 = v99;
        if (os_log_type_enabled(v57, (os_log_type_t)v99))
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s called with null evaluator", access_value, 0xCu);
        }
      }
      else if (v87)
      {
        v73 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v57 = objc_claimAutoreleasedReturnValue();
        v74 = v99;
        v75 = os_log_type_enabled(v57, (os_log_type_t)v99);
        if (v73)
        {
          if (v75)
          {
            *(_DWORD *)access_value = 136446466;
            *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
            *(_WORD *)&access_value[12] = 2082;
            *(_QWORD *)&access_value[14] = v73;
            _os_log_impl(&dword_182FBE000, v57, v74, "%{public}s called with null evaluator, dumping backtrace:%{public}s", access_value, 0x16u);
          }

          free(v73);
          goto LABEL_160;
        }
        if (v75)
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v57, v74, "%{public}s called with null evaluator, no backtrace", access_value, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v57 = objc_claimAutoreleasedReturnValue();
        v81 = v99;
        if (os_log_type_enabled(v57, (os_log_type_t)v99))
        {
          *(_DWORD *)access_value = 136446210;
          *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
          _os_log_impl(&dword_182FBE000, v57, v81, "%{public}s called with null evaluator, backtrace limit exceeded", access_value, 0xCu);
        }
      }

    }
LABEL_160:
    if (v56)
      free(v56);
    v22 = 0;
    goto LABEL_41;
  }
  v12 = evaluator_for_client_id;
  os_unfair_lock_lock((os_unfair_lock_t)evaluator_for_client_id + 24);
  v13 = v12[6];
  os_unfair_lock_unlock((os_unfair_lock_t)evaluator_for_client_id + 24);

  if (v13)
  {
    v14 = nw_path_copy_effective_remote_endpoint(v13);
    if (v14)
    {
      v15 = v14;
      v99 = 0uLL;
      nw_path_get_nexus_agent_uuid(v13, &v99);
      v16 = v88;
      v17 = nw_path_uses_interface_type(v13, nw_interface_type_cellular);
      v18 = nw_path_copy_interface(v13);
      v19 = v18;
      if (v16 == 2)
        v20 = -6;
      else
        v20 = -5;
      v21 = nw_interface_option_details_create(v18, &v99, v15, v20 - v17, 0, -1);
      nw_interface_option_details_set_local_cid(v21, v90);
      nw_interface_option_details_set_remote_cid(v21, v89);
      nw_interface_option_details_set_evaluator(v21, v12);
      nw_candidate_create(v85, v21, v12);
      v22 = (NWCandidate *)objc_claimAutoreleasedReturnValue();
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v23 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v82 = *((_QWORD *)v85 + 1);
        v24 = nw_path_copy_effective_local_endpoint(v13);
        v25 = nw_path_copy_effective_remote_endpoint(v13);
        if (v19 && (v26 = v19, v27 = v26[24], v26, v27 <= 4))
          v28 = off_1E14AD0B0[v27];
        else
          v28 = "unknown";
        if (v88 > 4)
          v32 = "unknown";
        else
          v32 = off_1E14AD0B0[v88];
        *(_DWORD *)access_value = 136447746;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        *(_WORD *)&access_value[12] = 2048;
        *(_QWORD *)&access_value[14] = v82;
        *(_WORD *)&access_value[22] = 2112;
        *(_QWORD *)v92 = v24;
        *(_WORD *)&v92[8] = 2112;
        *(_QWORD *)&v92[10] = v25;
        v93 = 2080;
        v94 = v28;
        v95 = 2080;
        v96 = v32;
        v97 = 2112;
        v98 = v22;
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] %@<->%@ %s<->%s %@", access_value, 0x48u);

      }
    }
    else
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v30 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        v31 = *((_QWORD *)v85 + 1);
        *(_DWORD *)access_value = 136446722;
        *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
        *(_WORD *)&access_value[12] = 2048;
        *(_QWORD *)&access_value[14] = v31;
        *(_WORD *)&access_value[22] = 2112;
        *(_QWORD *)v92 = v13;
        _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] %@ has no effective remote endpoint", access_value, 0x20u);
      }

      v15 = 0;
      v22 = 0;
    }
  }
  else
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v15 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v29 = *((_QWORD *)v85 + 1);
      *(_DWORD *)access_value = 136446722;
      *(_QWORD *)&access_value[4] = "nw_candidate_manager_candidate_for_ids_resolved_endpoint";
      *(_WORD *)&access_value[12] = 2048;
      *(_QWORD *)&access_value[14] = v29;
      *(_WORD *)&access_value[22] = 2112;
      *(_QWORD *)v92 = v12;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] %@ has no path", access_value, 0x20u);
    }
    v22 = 0;
  }

LABEL_41:
LABEL_42:

LABEL_43:
  v6 = v83;
LABEL_44:

  if (nw_candidate_manager_process_candidate_internal(*(NWConcrete_nw_candidate_manager **)(v84 + 40), v22))
  {
    objc_msgSend(*(id *)(*(_QWORD *)(v84 + 40) + 32), "setObject:forKeyedSubscript:", v22, endpoint);
  }
  else
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v33 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v34 = *(_QWORD *)(*(_QWORD *)(v84 + 40) + 8);
      v35 = nw_endpoint_copy_txt_record(endpoint);
      *(_DWORD *)access_value = 136446978;
      *(_QWORD *)&access_value[4] = "nw_candidate_manager_handle_ids_endpoints_block_invoke";
      *(_WORD *)&access_value[12] = 2048;
      *(_QWORD *)&access_value[14] = v34;
      *(_WORD *)&access_value[22] = 2112;
      *(_QWORD *)v92 = endpoint;
      *(_WORD *)&v92[8] = 2112;
      *(_QWORD *)&v92[10] = v35;
      _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] duplicate endpoint: %@, metadata:%@", access_value, 0x2Au);

    }
  }

  v4 = endpoint;
LABEL_52:

  return 1;
}

void sub_18338C238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;

  _Unwind_Resume(a1);
}

BOOL nw_txt_record_get_key_data_value(void *a1, const char *a2, void **a3)
{
  NSObject *v5;
  void *v6;
  _BOOL8 v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  _QWORD access_value[5];
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (a2)
  {
    if (a3)
    {
      v6 = *a3;
      *a3 = 0;

      access_value[0] = MEMORY[0x1E0C809B0];
      access_value[1] = 3221225472;
      access_value[2] = ___ZL32nw_txt_record_get_key_data_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPU8__strongPU27objcproto16OS_dispatch_dataS__block_invoke;
      access_value[3] = &__block_descriptor_40_e19_B36__0r_8i16r_20Q28l;
      access_value[4] = a3;
      v7 = nw_txt_record_access_key(v5, a2, access_value);
      goto LABEL_4;
    }
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_txt_record_get_key_data_value";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_txt_record_get_key_data_value";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null out_value", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_txt_record_get_key_data_value";
          _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null out_value, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_txt_record_get_key_data_value";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null out_value, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_txt_record_get_key_data_value";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null out_value, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_txt_record_get_key_data_value";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_txt_record_get_key_data_value";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null key", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_txt_record_get_key_data_value";
          _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_txt_record_get_key_data_value";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null key, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_txt_record_get_key_data_value";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null key, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v10)
    free(v10);
  v7 = 0;
LABEL_4:

  return v7;
}

void sub_18338C7CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL ___ZL34nw_txt_record_get_key_uint64_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPy_block_invoke(uint64_t a1, uint64_t a2, int a3, const char *a4, uint64_t a5)
{
  _BOOL8 result;
  char *__endptr;
  char __str[8];
  _QWORD v10[3];

  result = 0;
  v10[2] = *MEMORY[0x1E0C80C00];
  *(_QWORD *)__str = 0;
  v10[0] = 0;
  *(_QWORD *)((char *)v10 + 5) = 0;
  if (a3 == 4 && a4)
  {
    if (snprintf(__str, 0x15uLL, "%.*s", a5, a4) <= 20)
    {
      __endptr = 0;
      **(_QWORD **)(a1 + 32) = strtoull(__str, &__endptr, 0);
      return __endptr - __str == a5;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL ___ZL32nw_txt_record_get_key_uuid_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPh_block_invoke(uint64_t a1, uint64_t a2, int a3, const char *a4, int a5)
{
  _BOOL8 result;
  char __str[16];
  _BYTE v8[21];
  uint64_t v9;

  result = 0;
  v9 = *MEMORY[0x1E0C80C00];
  if (a3 == 4 && a4)
  {
    *(_OWORD *)__str = 0u;
    memset(v8, 0, sizeof(v8));
    return snprintf(__str, 0x25uLL, "%.*s", a5, a4) <= 36 && uuid_parse(__str, *(unsigned __int8 **)(a1 + 32)) == 0;
  }
  return result;
}

BOOL ___ZL32nw_txt_record_get_key_data_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPU8__strongPU27objcproto16OS_dispatch_dataS__block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unint64_t a5)
{
  _BOOL8 result;
  _BYTE *v9;
  unint64_t v10;
  char v11;
  int v12;
  char v13;
  unint64_t v14;
  dispatch_data_t v15;
  void **v16;
  void *v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  void *v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  unint64_t v27;
  uint64_t v28;

  result = 0;
  v28 = *MEMORY[0x1E0C80C00];
  if ((a5 & 1) != 0 || a3 != 4 || !a4 || a5 < 2)
    return result;
  v9 = malloc_type_calloc(1uLL, a5 >> 1, 0xEAFB8F1AuLL);
  if (!v9)
  {
    __nwlog_obj();
    v20 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v23 = "strict_calloc";
    v24 = 2048;
    v25 = 1;
    v26 = 2048;
    v27 = a5 >> 1;
    v21 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v21);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v21);
  }
  v10 = 0;
  while (1)
  {
    v12 = *(unsigned __int8 *)(a4 + v10);
    v13 = v12 - 48;
    if ((v12 - 48) < 0xA)
      goto LABEL_12;
    if ((v12 - 97) <= 5)
    {
      v13 = v12 - 87;
LABEL_12:
      v14 = v10 >> 1;
      if ((v10 & 1) == 0)
        goto LABEL_13;
      goto LABEL_7;
    }
    if ((v12 - 65) > 5)
      break;
    v13 = v12 - 55;
    v14 = v10 >> 1;
    if ((v10 & 1) == 0)
    {
LABEL_13:
      v11 = 16 * v13;
      goto LABEL_8;
    }
LABEL_7:
    v11 = v9[v14] | v13;
LABEL_8:
    v9[v14] = v11;
    if (a5 == ++v10)
    {
      v15 = dispatch_data_create(v9, a5 >> 1, 0, (dispatch_block_t)*MEMORY[0x1E0C80CE0]);
      v16 = *(void ***)(a1 + 32);
      v17 = *v16;
      *v16 = v15;

      return 1;
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    v19 = *(unsigned __int8 *)(a4 + v10);
    *(_DWORD *)buf = 136446466;
    v23 = "nw_txt_record_get_key_data_value_block_invoke";
    v24 = 1024;
    LODWORD(v25) = v19;
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s Not hex character: %c", buf, 0x12u);
  }

  if (v9)
    free(v9);
  return 0;
}

void ___ZL35nw_candidate_manager_set_connectionP31NWConcrete_nw_candidate_managerP24NWConcrete_nw_connection_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  id v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  _QWORD *v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  _BYTE buf[32];
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v4 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_set_connection_block_invoke";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2112;
    *(_QWORD *)&buf[24] = v3;
    LOWORD(v31) = 2112;
    *(_QWORD *)((char *)&v31 + 2) = v5;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Injecting %@ into %@", buf, 0x2Au);
  }

  v7 = *(id *)(a1 + 40);
  v8 = v3;
  v9 = v8;
  if (!v7)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v15)
          goto LABEL_15;
LABEL_50:
        free(v15);
        goto LABEL_15;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_48:

    goto LABEL_49;
  }
  if (v8)
  {
    v10 = v7[2];
    if (v10 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v10 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        v12 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v12;
        *(_WORD *)&buf[18] = 2112;
        *(_QWORD *)&buf[20] = v9;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s [C%u] Adding interface option details %@ to connection", buf, 0x1Cu);
      }

    }
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __nw_connection_add_extra_interface_option_block_invoke;
    *(_QWORD *)&buf[24] = &unk_1E14ACE68;
    v13 = v7;
    *(_QWORD *)&v31 = v13;
    *((_QWORD *)&v31 + 1) = v9;
    nw_connection_async_if_needed(v13, buf);

    goto LABEL_15;
  }
  __nwlog_obj();
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (!__nwlog_fault(v15, &type, &v28))
    goto LABEL_49;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
      _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null interface_option_details", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (!v28)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
      _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_48;
  }
  v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  v24 = type;
  v25 = os_log_type_enabled(v16, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
      _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_connection_add_extra_interface_option";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v23;
    _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v15)
    goto LABEL_50;
LABEL_15:

}

void sub_18338D25C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void ___ZL35nw_candidate_manager_set_connectionP31NWConcrete_nw_candidate_managerP24NWConcrete_nw_connection_block_invoke_145(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  id v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  _QWORD *v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  _BYTE buf[32];
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v4 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_set_connection_block_invoke";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2112;
    *(_QWORD *)&buf[24] = v3;
    LOWORD(v31) = 2112;
    *(_QWORD *)((char *)&v31 + 2) = v5;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] Removing %@ from %@", buf, 0x2Au);
  }

  v7 = *(id *)(a1 + 40);
  v8 = v3;
  v9 = v8;
  if (!v7)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v15)
          goto LABEL_15;
LABEL_50:
        free(v15);
        goto LABEL_15;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_48:

    goto LABEL_49;
  }
  if (v8)
  {
    v10 = v7[2];
    if (v10 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v10 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        v12 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v12;
        *(_WORD *)&buf[18] = 2112;
        *(_QWORD *)&buf[20] = v9;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s [C%u] Removing interface option details %@", buf, 0x1Cu);
      }

    }
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __nw_connection_remove_extra_interface_option_block_invoke;
    *(_QWORD *)&buf[24] = &unk_1E14ACE68;
    v13 = v7;
    *(_QWORD *)&v31 = v13;
    *((_QWORD *)&v31 + 1) = v9;
    nw_connection_async_if_needed(v13, buf);

    goto LABEL_15;
  }
  __nwlog_obj();
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
  v15 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (!__nwlog_fault(v15, &type, &v28))
    goto LABEL_49;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
      _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null details", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (!v28)
  {
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    if (os_log_type_enabled(v16, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
      _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null details, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_48;
  }
  v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  v24 = type;
  v25 = os_log_type_enabled(v16, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
      _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null details, no backtrace", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_connection_remove_extra_interface_option";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v23;
    _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s called with null details, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v15)
    goto LABEL_50;
LABEL_15:

}

void sub_18338D904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

const char *nw_candidate_manager_state_to_string(unsigned int a1)
{
  if (a1 > 4)
    return "unknown-state";
  else
    return off_1E149A7B0[a1];
}

void nw_candidate_manager_set_state_changed_handler(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  id v6;
  char *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *v11;
  void *v12;
  void *v13;
  const char *backtrace_string;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *v18;
  os_log_type_t v19;
  char *v20;
  os_log_type_t v21;
  char *v22;
  void *v23;
  os_log_type_t v24;
  void *v25;
  os_log_type_t v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  _BOOL4 v31;
  os_log_type_t v32;
  os_log_type_t v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  __int16 v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      if (*((_DWORD *)v3 + 38) != 4)
      {
        v12 = _Block_copy(v4);
        v13 = (void *)v3[20];
        v3[20] = v12;

        goto LABEL_34;
      }
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v6 = (id)gcandidate_managerLogObj;
      v7 = (char *)v3[1];
      *(_DWORD *)buf = 136446466;
      v37 = "nw_candidate_manager_set_state_changed_handler";
      v38 = 2048;
      v39 = v7;
      v8 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (!__nwlog_fault(v8, &type, &v34))
        goto LABEL_32;
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v9 = (id)gcandidate_managerLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          v11 = (char *)v3[1];
          *(_DWORD *)buf = 136446466;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          v38 = 2048;
          v39 = v11;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s [CM%zu] Cannot set state changed handler after cancel", buf, 0x16u);
        }
      }
      else if (v34)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v15 = (char *)backtrace_string;
          if (__nwlog_candidate_manager_log::onceToken != -1)
            dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
          v16 = (id)gcandidate_managerLogObj;
          v17 = type;
          if (os_log_type_enabled(v16, type))
          {
            v18 = (char *)v3[1];
            *(_DWORD *)buf = 136446722;
            v37 = "nw_candidate_manager_set_state_changed_handler";
            v38 = 2048;
            v39 = v18;
            v40 = 2082;
            v41 = v15;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s [CM%zu] Cannot set state changed handler after cancel, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v15);
          if (v8)
            goto LABEL_33;
          goto LABEL_34;
        }
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v9 = (id)gcandidate_managerLogObj;
        v21 = type;
        if (os_log_type_enabled(v9, type))
        {
          v22 = (char *)v3[1];
          *(_DWORD *)buf = 136446466;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          v38 = 2048;
          v39 = v22;
          _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s [CM%zu] Cannot set state changed handler after cancel, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        if (__nwlog_candidate_manager_log::onceToken != -1)
          dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
        v9 = (id)gcandidate_managerLogObj;
        v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          v20 = (char *)v3[1];
          *(_DWORD *)buf = 136446466;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          v38 = 2048;
          v39 = v20;
          _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s [CM%zu] Cannot set state changed handler after cancel, backtrace limit exceeded", buf, 0x16u);
        }
      }
      goto LABEL_31;
    }
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_candidate_manager_set_state_changed_handler";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (__nwlog_fault(v8, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_182FBE000, v9, v26, "%{public}s called with null handler", buf, 0xCu);
        }
LABEL_31:

        goto LABEL_32;
      }
      if (!v34)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_182FBE000, v9, v33, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_31;
      }
      v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      v31 = os_log_type_enabled(v9, type);
      if (!v27)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_182FBE000, v9, v30, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_31;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_candidate_manager_set_state_changed_handler";
        v38 = 2082;
        v39 = v27;
        _os_log_impl(&dword_182FBE000, v9, v30, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_54:

      free(v27);
      if (!v8)
        goto LABEL_34;
      goto LABEL_33;
    }
  }
  else
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_candidate_manager_set_state_changed_handler";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (__nwlog_fault(v8, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null candidate_manager", buf, 0xCu);
        }
        goto LABEL_31;
      }
      if (!v34)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_182FBE000, v9, v32, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_31;
      }
      v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      v29 = os_log_type_enabled(v9, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_candidate_manager_set_state_changed_handler";
          _os_log_impl(&dword_182FBE000, v9, v28, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
        }
        goto LABEL_31;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_candidate_manager_set_state_changed_handler";
        v38 = 2082;
        v39 = v27;
        _os_log_impl(&dword_182FBE000, v9, v28, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_54;
    }
  }
LABEL_32:
  if (v8)
LABEL_33:
    free(v8);
LABEL_34:

}

void nw_candidate_manager_set_add_block(void *a1, const void *a2)
{
  _QWORD *v3;
  void *v4;
  id v5;

  v3 = a1;
  v4 = _Block_copy(a2);
  v5 = (id)v3[14];
  v3[14] = v4;

}

void nw_candidate_manager_set_remove_block(void *a1, const void *a2)
{
  _QWORD *v3;
  void *v4;
  id v5;

  v3 = a1;
  v4 = _Block_copy(a2);
  v5 = (id)v3[15];
  v3[15] = v4;

}

void nw_candidate_manager_set_modify_ids_parameters_block(void *a1, const void *a2)
{
  _QWORD *v3;
  void *v4;
  id v5;

  v3 = a1;
  v4 = _Block_copy(a2);
  v5 = (id)v3[16];
  v3[16] = v4;

}

void nw_candidate_manager_set_new_connection_handler(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  NSObject *v6;
  char *v7;
  void *v8;
  void *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_candidate_manager_set_new_connection_handler";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24))
      goto LABEL_44;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_candidate_manager_set_new_connection_handler";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_candidate_manager_set_new_connection_handler";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_44:
        if (!v11)
          goto LABEL_10;
LABEL_45:
        free(v11);
        goto LABEL_10;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_candidate_manager_set_new_connection_handler";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_candidate_manager_set_new_connection_handler";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_43:

    goto LABEL_44;
  }
  if (v4)
  {
    if (*((_DWORD *)v3 + 38) == 4)
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v6 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v7 = (char *)v3[1];
        *(_DWORD *)buf = 136446466;
        v27 = "nw_candidate_manager_set_new_connection_handler";
        v28 = 2048;
        v29 = v7;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] Cannot set new connection handler after cancel", buf, 0x16u);
      }

    }
    else
    {
      v8 = _Block_copy(v4);
      v9 = (void *)v3[21];
      v3[21] = v8;

    }
    goto LABEL_10;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_candidate_manager_set_new_connection_handler";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v11, &type, &v24))
    goto LABEL_44;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_candidate_manager_set_new_connection_handler";
      _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null handler", buf, 0xCu);
    }
    goto LABEL_43;
  }
  if (!v24)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_candidate_manager_set_new_connection_handler";
      _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_43;
  }
  v19 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  v20 = type;
  v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      v27 = "nw_candidate_manager_set_new_connection_handler";
      _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_43;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v27 = "nw_candidate_manager_set_new_connection_handler";
    v28 = 2082;
    v29 = v19;
    _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11)
    goto LABEL_45;
LABEL_10:

}

BOOL nw_candidate_manager_start_client(void *a1, int a2)
{
  _QWORD *v3;
  _QWORD *v4;
  NSObject *v5;
  char *v6;
  _BOOL8 v7;
  char v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_candidate_manager_start_client";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_candidate_manager_start_client";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null candidate_manager", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v21 = "nw_candidate_manager_start_client";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_candidate_manager_start_client";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_candidate_manager_start_client";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_32:
    if (v11)
      free(v11);
    goto LABEL_10;
  }
  if (v3[7] || v3[9] || v3[6])
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v5 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = (char *)v4[1];
      *(_DWORD *)buf = 136446466;
      v21 = "nw_candidate_manager_start_client";
      v22 = 2048;
      v23 = v6;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] Cannot start an already started candidate_manager", buf, 0x16u);
    }

LABEL_10:
    v7 = 0;
    goto LABEL_11;
  }
  if (a2)
    v9 = 2;
  else
    v9 = 0;
  *((_BYTE *)v3 + 184) = v3[23] & 0xFD | v9;
  nw_candidate_manager_start_bonjour_service_resolve(v3);
  v7 = v4[6] != 0;
LABEL_11:

  return v7;
}

void sub_18338EAD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_start_bonjour_service_resolve(void *a1)
{
  id *v1;
  id *v2;
  NSObject *v3;
  char *v4;
  id v5;
  _BOOL8 v6;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  os_unfair_lock_s *v8;
  id *v9;
  id v10;
  nw_endpoint_t *v11;
  id v12;
  NSObject *v13;
  char *v14;
  id v15;
  id v16;
  id v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  void *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  os_log_type_t v31;
  _QWORD v32[4];
  id *v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  __int16 v40;
  id v41;
  __int16 v42;
  id v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_candidate_manager_start_bonjour_service_resolve";
    v19 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v19, &type, &v34))
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_candidate_manager_start_bonjour_service_resolve";
        _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null manager", buf, 0xCu);
      }
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_candidate_manager_start_bonjour_service_resolve";
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_51:
        if (!v19)
          goto LABEL_17;
LABEL_52:
        free(v19);
        goto LABEL_17;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_candidate_manager_start_bonjour_service_resolve";
        _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_candidate_manager_start_bonjour_service_resolve";
        _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s called with null manager, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_50:

    goto LABEL_51;
  }
  if (v1[5])
  {
    if (v1[6])
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v3 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        v4 = (char *)v2[1];
        *(_DWORD *)buf = 136446466;
        v37 = "nw_candidate_manager_start_bonjour_service_resolve";
        v38 = 2048;
        v39 = v4;
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] service resolver already running", buf, 0x16u);
      }

    }
    else
    {
      v5 = v1[10];
      v6 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v5, 0, 0);

      nw_parameters_set_include_peer_to_peer((nw_parameters_t)v6, 0);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v2[5], (void *)v6);
      v8 = (os_unfair_lock_s *)evaluator_for_endpoint;
      if (evaluator_for_endpoint)
      {
        v9 = evaluator_for_endpoint;
        os_unfair_lock_lock(v8 + 24);
        v10 = v9[6];
        os_unfair_lock_unlock(v8 + 24);

      }
      else
      {
        v10 = 0;
      }
      v11 = nw_resolver_create_with_path(v10);
      v12 = v2[6];
      v2[6] = v11;

      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v13 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        v14 = (char *)v2[1];
        v16 = v2[5];
        v15 = v2[6];
        *(_DWORD *)buf = 136446978;
        v37 = "nw_candidate_manager_start_bonjour_service_resolve";
        v38 = 2048;
        v39 = v14;
        v40 = 2112;
        v41 = v15;
        v42 = 2112;
        v43 = v16;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Created service resolver %@ for %@", buf, 0x2Au);
      }

      v17 = v2[6];
      v32[0] = MEMORY[0x1E0C809B0];
      v32[1] = 3221225472;
      v32[2] = __nw_candidate_manager_start_bonjour_service_resolve_block_invoke;
      v32[3] = &unk_1E149A6B0;
      v33 = v2;
      nw_resolver_set_update_handler(v17, 0, v32);

    }
    goto LABEL_17;
  }
  __nwlog_obj();
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_candidate_manager_start_bonjour_service_resolve";
  v19 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (!__nwlog_fault(v19, &type, &v34))
    goto LABEL_51;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v20 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_candidate_manager_start_bonjour_service_resolve";
      _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null manager->service", buf, 0xCu);
    }
    goto LABEL_50;
  }
  if (!v34)
  {
    __nwlog_obj();
    v20 = objc_claimAutoreleasedReturnValue();
    v31 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_candidate_manager_start_bonjour_service_resolve";
      _os_log_impl(&dword_182FBE000, v20, v31, "%{public}s called with null manager->service, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_50;
  }
  v27 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v20 = objc_claimAutoreleasedReturnValue();
  v28 = type;
  v29 = os_log_type_enabled(v20, type);
  if (!v27)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_candidate_manager_start_bonjour_service_resolve";
      _os_log_impl(&dword_182FBE000, v20, v28, "%{public}s called with null manager->service, no backtrace", buf, 0xCu);
    }
    goto LABEL_50;
  }
  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    v37 = "nw_candidate_manager_start_bonjour_service_resolve";
    v38 = 2082;
    v39 = v27;
    _os_log_impl(&dword_182FBE000, v20, v28, "%{public}s called with null manager->service, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v27);
  if (v19)
    goto LABEL_52;
LABEL_17:

}

void sub_18338F1A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __nw_candidate_manager_start_bonjour_service_resolve_block_invoke(uint64_t a1, int a2, void *a3)
{
  id v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  _QWORD *v11;
  unsigned __int8 *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t i;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _QWORD v27[4];
  id v28;
  _QWORD *v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  id v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v6 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(a1 + 32);
    v8 = *(_QWORD *)(v7 + 8);
    v9 = *(_QWORD *)(v7 + 40);
    v10 = "invalid";
    v31 = "nw_candidate_manager_start_bonjour_service_resolve_block_invoke";
    if (a2 == 2)
      v10 = "complete";
    v32 = 2048;
    *(_DWORD *)buf = 136447234;
    if (a2 == 1)
      v10 = "in-progress";
    v33 = v8;
    v34 = 2112;
    v35 = v9;
    v36 = 2082;
    v37 = v10;
    v38 = 2112;
    v39 = v5;
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [CM%zu] %@ %{public}s resolves to %@", buf, 0x34u);
  }

  v11 = *(id *)(a1 + 32);
  v12 = (unsigned __int8 *)v5;
  v13 = (void *)v11[11];
  if (!v13)
  {
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v17 = objc_claimAutoreleasedReturnValue();
    v18 = (void *)v11[11];
    v11[11] = v17;

    v16 = 0;
    if (!v12)
      goto LABEL_17;
    goto LABEL_16;
  }
  v14 = (void *)MEMORY[0x1E0C99DE8];
  objc_msgSend(v13, "allKeys");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v14, "arrayWithArray:", v15);
  v16 = (void *)objc_claimAutoreleasedReturnValue();

  if (v11[8] && objc_msgSend(v16, "containsObject:"))
    objc_msgSend(v16, "removeObject:", v11[8]);
  if (v12)
  {
LABEL_16:
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 3221225472;
    v27[2] = ___ZL54nw_candidate_manager_handle_service_resolved_endpointsP31NWConcrete_nw_candidate_managerPU22objcproto11OS_nw_array8NSObject_block_invoke;
    v27[3] = &unk_1E14A8D20;
    v28 = v16;
    v29 = v11;
    nw_array_apply(v12, (uint64_t)v27);

  }
LABEL_17:
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v19 = v16;
  v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v23, buf, 16);
  if (v20)
  {
    v21 = *(_QWORD *)v24;
    do
    {
      for (i = 0; i != v20; ++i)
      {
        if (*(_QWORD *)v24 != v21)
          objc_enumerationMutation(v19);
        nw_candidate_manager_remove_hostname_resolver(v11, *(void **)(*((_QWORD *)&v23 + 1) + 8 * i));
      }
      v20 = objc_msgSend(v19, "countByEnumeratingWithState:objects:count:", &v23, buf, 16);
    }
    while (v20);
  }

}

void sub_18338F4DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZL54nw_candidate_manager_handle_service_resolved_endpointsP31NWConcrete_nw_candidate_managerPU22objcproto11OS_nw_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;

  v4 = a3;
  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:", v4))
  {
    objc_msgSend(*(id *)(a1 + 32), "removeObject:", v4);
  }
  else
  {
    nw_candidate_manager_resolver_for_service_resolved_endpoint(*(_QWORD *)(a1 + 40), v4);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 88), "setObject:forKeyedSubscript:", v5, v4);

  }
  return 1;
}

void sub_18338F5A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_candidate_manager_start_advertise(void *a1, int a2)
{
  _QWORD *v3;
  id *v4;
  NSObject *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  NSObject *v10;
  const char *bonjour_service_name;
  const char *bonjour_service_type;
  const char *bonjour_service_domain;
  NSObject *bonjour_service;
  uint64_t v15;
  id *v16;
  NSObject *v17;
  id *v18;
  id *v19;
  id v20;
  void *v21;
  _QWORD *v22;
  id v23;
  _BOOL8 v24;
  id v25;
  NSObject *v26;
  char *v27;
  void *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  void *v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  void *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  void *v44;
  os_log_type_t v45;
  char *v46;
  os_log_type_t v47;
  _BOOL4 v48;
  char *v49;
  _BOOL4 v50;
  char *v51;
  _BOOL4 v52;
  os_log_type_t v53;
  os_log_type_t v54;
  os_log_type_t v55;
  os_log_type_t v56;
  os_log_type_t v57;
  _QWORD v58[4];
  NSObject *v59;
  id *v60;
  _QWORD handler[4];
  id *v62;
  char v63;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v66;
  __int16 v67;
  char *v68;
  __int16 v69;
  NSObject *v70;
  char __str[16];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (id *)v3;
  if (!v3)
  {
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_candidate_manager_start_advertise";
    v29 = (char *)_os_log_send_and_compose_impl();

    __str[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v29, __str, &type))
    {
      if (__str[0] == 17)
      {
        __nwlog_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        v31 = __str[0];
        if (os_log_type_enabled(v30, (os_log_type_t)__str[0]))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_candidate_manager_start_advertise";
          _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null candidate_manager", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        v33 = __str[0];
        v34 = os_log_type_enabled(v30, (os_log_type_t)__str[0]);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v66 = "nw_candidate_manager_start_advertise";
            v67 = 2082;
            v68 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v30, v33, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_candidate_manager_start_advertise";
          _os_log_impl(&dword_182FBE000, v30, v33, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v30 = objc_claimAutoreleasedReturnValue();
        v35 = __str[0];
        if (os_log_type_enabled(v30, (os_log_type_t)__str[0]))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_candidate_manager_start_advertise";
          _os_log_impl(&dword_182FBE000, v30, v35, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_45:
    if (v29)
      free(v29);
    goto LABEL_15;
  }
  if (!v3[21])
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v5 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = (char *)v4[1];
      *(_DWORD *)buf = 136446466;
      v66 = "nw_candidate_manager_start_advertise";
      v67 = 2048;
      v68 = v7;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] Cannot advertise without a new connection handler", buf, 0x16u);
    }
    goto LABEL_14;
  }
  if (v3[6] || v3[9])
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v5 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = (char *)v4[1];
      *(_DWORD *)buf = 136446466;
      v66 = "nw_candidate_manager_start_advertise";
      v67 = 2048;
      v68 = v6;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] Cannot start an already started candidate_manager", buf, 0x16u);
    }
LABEL_14:

LABEL_15:
    v8 = 0;
    goto LABEL_16;
  }
  snprintf(__str, 0x10uLL, "%d", a2);
  v10 = nw_listener_create_with_port(__str, (nw_parameters_t)v4[10]);
  bonjour_service_name = nw_endpoint_get_bonjour_service_name((nw_endpoint_t)v4[5]);
  bonjour_service_type = nw_endpoint_get_bonjour_service_type((nw_endpoint_t)v4[5]);
  bonjour_service_domain = nw_endpoint_get_bonjour_service_domain((nw_endpoint_t)v4[5]);
  bonjour_service = nw_advertise_descriptor_create_bonjour_service(bonjour_service_name, bonjour_service_type, bonjour_service_domain);
  nw_listener_set_advertise_descriptor(v10, bonjour_service);
  v15 = MEMORY[0x1E0C809B0];
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 3221225472;
  handler[2] = __nw_candidate_manager_start_advertise_block_invoke;
  handler[3] = &unk_1E149B7B0;
  v16 = v4;
  v62 = v16;
  nw_listener_set_new_connection_handler(v10, handler);
  v58[0] = v15;
  v58[1] = 3221225472;
  v58[2] = __nw_candidate_manager_start_advertise_block_invoke_134;
  v58[3] = &unk_1E14AD048;
  v17 = v10;
  v59 = v17;
  v18 = v16;
  v60 = v18;
  nw_listener_set_state_changed_handler(v17, v58);
  objc_storeStrong(v4 + 9, v10);
  v19 = v18;
  v20 = v4[10];
  v21 = v20;
  if (!v20)
  {
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_candidate_manager_copy_workloop";
    v37 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (__nwlog_fault(v37, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v38 = objc_claimAutoreleasedReturnValue();
        v39 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_candidate_manager_copy_workloop";
          _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v63)
      {
        v46 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v38 = objc_claimAutoreleasedReturnValue();
        v47 = type;
        v48 = os_log_type_enabled(v38, type);
        if (v46)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            v66 = "nw_candidate_manager_copy_workloop";
            v67 = 2082;
            v68 = v46;
            _os_log_impl(&dword_182FBE000, v38, v47, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v46);
          goto LABEL_90;
        }
        if (v48)
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_candidate_manager_copy_workloop";
          _os_log_impl(&dword_182FBE000, v38, v47, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v38 = objc_claimAutoreleasedReturnValue();
        v53 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_candidate_manager_copy_workloop";
          _os_log_impl(&dword_182FBE000, v38, v53, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_90:
    if (v37)
      free(v37);
    v24 = 0;
    goto LABEL_24;
  }
  v22 = v20;
  v23 = *(id *)(v22[13] + 136);

  if (!v23)
  {
    __nwlog_obj();
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_candidate_manager_copy_workloop";
    v41 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (!__nwlog_fault(v41, &type, &v63))
      goto LABEL_99;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v63)
    {
      v49 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v56 = type;
      v50 = os_log_type_enabled(v42, type);
      if (v49)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_candidate_manager_copy_workloop";
          v67 = 2082;
          v68 = v49;
          _os_log_impl(&dword_182FBE000, v42, v56, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v49);
        if (!v41)
          goto LABEL_101;
        goto LABEL_100;
      }
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_182FBE000, v42, v56, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v54 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_182FBE000, v42, v54, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_98;
  }
  v24 = nw_context_copy_workloop(v23);
  if (v24)
    goto LABEL_23;
  if (nw_context_copy_implicit_context::onceToken[0] != -1)
    dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  v25 = (id)nw_context_copy_implicit_context::implicit_context;
  v24 = nw_context_copy_workloop(v25);

  if (v24)
    goto LABEL_23;
  __nwlog_obj();
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v66 = "nw_candidate_manager_copy_workloop";
  v41 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v63 = 0;
  if (__nwlog_fault(v41, &type, &v63))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_182FBE000, v42, v45, "%{public}s called with null workloop", buf, 0xCu);
      }
LABEL_98:

      goto LABEL_99;
    }
    if (!v63)
    {
      __nwlog_obj();
      v42 = objc_claimAutoreleasedReturnValue();
      v55 = type;
      if (os_log_type_enabled(v42, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_182FBE000, v42, v55, "%{public}s called with null workloop, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_98;
    }
    v51 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v42 = objc_claimAutoreleasedReturnValue();
    v57 = type;
    v52 = os_log_type_enabled(v42, type);
    if (!v51)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_candidate_manager_copy_workloop";
        _os_log_impl(&dword_182FBE000, v42, v57, "%{public}s called with null workloop, no backtrace", buf, 0xCu);
      }
      goto LABEL_98;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      v66 = "nw_candidate_manager_copy_workloop";
      v67 = 2082;
      v68 = v51;
      _os_log_impl(&dword_182FBE000, v42, v57, "%{public}s called with null workloop, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v51);
  }
LABEL_99:
  if (v41)
LABEL_100:
    free(v41);
LABEL_101:
  v24 = 0;
LABEL_23:

LABEL_24:
  nw_listener_set_queue(v17, (dispatch_queue_t)v24);

  nw_listener_start(v17);
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v26 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
  {
    v27 = (char *)v19[1];
    *(_DWORD *)buf = 136446722;
    v66 = "nw_candidate_manager_start_advertise";
    v67 = 2048;
    v68 = v27;
    v69 = 2112;
    v70 = v17;
    _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Created listener %@", buf, 0x20u);
  }

  v8 = 1;
LABEL_16:

  return v8;
}

void sub_183390294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

void __nw_candidate_manager_start_advertise_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  NWConcrete_nw_connection *v4;
  NSObject *v5;
  uint64_t v6;
  NWConcrete_nw_candidate_manager *v7;
  void (**new_connection_handler)(id, NWConcrete_nw_connection *);
  _QWORD v9[4];
  id v10;
  NWConcrete_nw_connection *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  NWConcrete_nw_connection *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __nw_candidate_manager_start_advertise_block_invoke_2;
  v9[3] = &unk_1E14AD048;
  v10 = *(id *)(a1 + 32);
  v4 = (NWConcrete_nw_connection *)v3;
  v11 = v4;
  nw_connection_set_state_changed_handler(&v4->super, v9);
  if (__nwlog_candidate_manager_log::onceToken != -1)
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  v5 = (id)gcandidate_managerLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_DWORD *)buf = 136446722;
    v13 = "nw_candidate_manager_start_advertise_block_invoke";
    v14 = 2048;
    v15 = v6;
    v16 = 2112;
    v17 = v4;
    _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Received incoming connection %@", buf, 0x20u);
  }

  v7 = *(NWConcrete_nw_candidate_manager **)(a1 + 32);
  if (v7->connection)
  {
    new_connection_handler = (void (**)(id, NWConcrete_nw_connection *))v7->new_connection_handler;
    if (!new_connection_handler)
      goto LABEL_10;
    goto LABEL_9;
  }
  nw_candidate_manager_set_connection(v7, v4);
  new_connection_handler = *(void (***)(id, NWConcrete_nw_connection *))(*(_QWORD *)(a1 + 32) + 168);
  if (new_connection_handler)
LABEL_9:
    new_connection_handler[2](new_connection_handler, v4);
LABEL_10:

}

void sub_1833904C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void __nw_candidate_manager_start_advertise_block_invoke_134(uint64_t a1, int a2, void *a3)
{
  id v5;
  void *v6;
  int port;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  uint64_t v13;
  int v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = v5;
  if (a2 == 2)
  {
    port = nw_listener_get_port(*(nw_listener_t *)(a1 + 32));
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v8 = (id)gcandidate_managerLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      goto LABEL_12;
    v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v14 = 136446722;
    v15 = "nw_candidate_manager_start_advertise_block_invoke";
    v16 = 2048;
    v17 = v9;
    v18 = 1024;
    LODWORD(v19) = port;
    v10 = "%{public}s [CM%zu] Listener entered ready state, using port %d";
    v11 = v8;
    v12 = 28;
LABEL_11:
    _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, v10, (uint8_t *)&v14, v12);
LABEL_12:

    goto LABEL_13;
  }
  if (v5)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v8 = (id)gcandidate_managerLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      goto LABEL_12;
    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v14 = 136446722;
    v15 = "nw_candidate_manager_start_advertise_block_invoke";
    v16 = 2048;
    v17 = v13;
    v18 = 2112;
    v19 = v6;
    v10 = "%{public}s [CM%zu] Listener failed with error '%@'";
    v11 = v8;
    v12 = 32;
    goto LABEL_11;
  }
LABEL_13:

}

void sub_1833906B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_candidate_manager_start_advertise_block_invoke_2(uint64_t a1, int a2, void *a3)
{
  id v5;
  void *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  nw_protocol_metadata_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 is_quic_stream;
  id v18;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  void *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = v5;
  if (a2 == 3)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v7 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      v8 = *(_QWORD *)(a1 + 40);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v19 = 136446722;
      v20 = "nw_candidate_manager_start_advertise_block_invoke_2";
      v21 = 2048;
      v22 = v9;
      v23 = 2112;
      v24 = v8;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Incoming connection %@ entered ready state", (uint8_t *)&v19, 0x20u);
    }

    v10 = *(NSObject **)(a1 + 40);
    if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
    v11 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
    v12 = nw_connection_copy_protocol_metadata(v10, v11);

    if (!v12)
      goto LABEL_19;
    v13 = v12;
    if (nw_protocol_metadata_is_quic_connection(v13))
    {

    }
    else
    {
      is_quic_stream = nw_protocol_metadata_is_quic_stream(v13);

      if (!is_quic_stream)
      {
LABEL_19:
        nw_candidate_manager_set_state(*(void **)(a1 + 32), 2);

        goto LABEL_20;
      }
    }
    v18 = nw_quic_stream_copy_connection_metadata(v13);
    nw_quic_connection_set_keepalive(v18, 10);

    goto LABEL_19;
  }
  if (v5)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v14 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      v15 = *(_QWORD *)(a1 + 40);
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v19 = 136446978;
      v20 = "nw_candidate_manager_start_advertise_block_invoke";
      v21 = 2048;
      v22 = v16;
      v23 = 2112;
      v24 = v15;
      v25 = 2112;
      v26 = v6;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Incoming connection %@ failed with error '%@'", (uint8_t *)&v19, 0x2Au);
    }

    nw_candidate_manager_cancel(*(void **)(a1 + 32));
  }
LABEL_20:

}

void sub_183390944(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_set_internet_fallback(void *a1, void *a2)
{
  id v3;
  id v4;
  NSObject *v5;
  char *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    if (nw_parameters_get_local_only(*((nw_parameters_t *)v3 + 10)))
    {
      if (__nwlog_candidate_manager_log::onceToken != -1)
        dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
      v5 = (id)gcandidate_managerLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        v6 = (char *)*((_QWORD *)v3 + 1);
        *(_DWORD *)buf = 136446466;
        v18 = "nw_candidate_manager_set_internet_fallback";
        v19 = 2048;
        v20 = v6;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s [CM%zu] Can't set Internet fallback with local only parameters", buf, 0x16u);
      }

    }
    if (v4)
    {
      if (nw_parameters_get_server_mode(*((void **)v3 + 10)))
      {
        nw_candidate_manager_start_ids_internal(v3, v4);
      }
      else
      {
        objc_storeStrong((id *)v3 + 2, a2);
        nw_candidate_manager_monitor_interface_use((NWConcrete_nw_candidate_manager *)v3);
      }
    }
    else
    {
      nw_candidate_manager_stop_ids((NWConcrete_nw_candidate_manager *)v3);
    }
    goto LABEL_13;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_candidate_manager_set_internet_fallback";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_candidate_manager_set_internet_fallback";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_candidate_manager_set_internet_fallback";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_candidate_manager_set_internet_fallback";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_candidate_manager_set_internet_fallback";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_30:
  if (v8)
    free(v8);
LABEL_13:

}

void sub_183390D00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_candidate_manager_set_original_path(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  NSObject *v6;
  char *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  void *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_candidate_manager_set_original_path";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_candidate_manager_set_original_path";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_candidate_manager_set_original_path";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v9)
          goto LABEL_8;
LABEL_43:
        free(v9);
        goto LABEL_8;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_candidate_manager_set_original_path";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_candidate_manager_set_original_path";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (v4)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v6 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = (char *)*((_QWORD *)v3 + 1);
      *(_DWORD *)buf = 136446722;
      v25 = "nw_candidate_manager_set_original_path";
      v26 = 2048;
      v27 = v7;
      v28 = 2112;
      v29 = v5;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Setting original remote endpoint %@", buf, 0x20u);
    }

    objc_storeStrong((id *)v3 + 13, a2);
    goto LABEL_8;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_candidate_manager_set_original_path";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_candidate_manager_set_original_path";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null original_remote_endpoint", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_candidate_manager_set_original_path";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null original_remote_endpoint, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_candidate_manager_set_original_path";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null original_remote_endpoint, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_candidate_manager_set_original_path";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null original_remote_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_43;
LABEL_8:

}

void nw_candidate_manager_remove_injected_paths(void *a1)
{
  NWConcrete_nw_candidate_manager *v1;
  NSObject *v2;
  unint64_t log_id;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    if (__nwlog_candidate_manager_log::onceToken != -1)
      dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
    v2 = (id)gcandidate_managerLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      log_id = v1->log_id;
      *(_DWORD *)buf = 136446466;
      v15 = "nw_candidate_manager_remove_injected_paths";
      v16 = 2048;
      v17 = (char *)log_id;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_INFO, "%{public}s [CM%zu] Removing injected paths", buf, 0x16u);
    }

    nw_candidate_manager_stop_ids(v1);
    nw_connection_remove_all_interface_options(v1->connection);
    goto LABEL_7;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_candidate_manager_remove_injected_paths";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_candidate_manager_remove_injected_paths";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null candidate_manager", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_candidate_manager_remove_injected_paths";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null candidate_manager, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_candidate_manager_remove_injected_paths";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null candidate_manager, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_candidate_manager_remove_injected_paths";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null candidate_manager, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v5)
    free(v5);
LABEL_7:

}

void sub_18339159C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_candidate_manager_encode_ids_path(void *a1, void *a2, void *a3, void *a4)
{
  NSObject *v7;
  id v8;
  id v9;
  id v10;
  nw_endpoint_t v11;
  NSObject *v12;
  NSObject *v13;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = a4;
  if (v7)
  {
    v11 = nw_path_copy_effective_remote_endpoint(v7);
    if (v11)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_candidate_manager_encode_ids_path";
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Not supported", buf, 0xCu);
      }

      v13 = v11;
LABEL_6:

      goto LABEL_7;
    }
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_candidate_manager_encode_ids_path";
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v20, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_candidate_manager_encode_ids_path";
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        v28 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            v34 = "nw_candidate_manager_encode_ids_path";
            v35 = 2082;
            v36 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_43;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_candidate_manager_encode_ids_path";
          _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_candidate_manager_encode_ids_path";
          _os_log_impl(&dword_182FBE000, v21, v30, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_43:
    if (v20)
      free(v20);
    goto LABEL_6;
  }
  __nwlog_obj();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v34 = "nw_candidate_manager_encode_ids_path";
  v16 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (__nwlog_fault(v16, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_candidate_manager_encode_ids_path";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v31)
    {
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v17, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_candidate_manager_encode_ids_path";
          v35 = 2082;
          v36 = v23;
          _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
        goto LABEL_37;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_candidate_manager_encode_ids_path";
        _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_candidate_manager_encode_ids_path";
        _os_log_impl(&dword_182FBE000, v17, v29, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_37:
  if (v16)
    free(v16);
  v11 = 0;
LABEL_7:

  return v11;
}

uint64_t nw_candidate_manager_encode_ids_connection(void *a1, void *a2, void *a3, uint64_t a4, void *a5, unsigned int a6, void *a7)
{
  return nw_candidate_endpoint_for_ids_connection(a1, a2, a3, a5, a6, a7);
}

uint64_t nw_candidate_endpoint_for_ids_connection(void *a1, void *a2, void *a3, void *a4, unsigned int a5, void *a6)
{
  id v11;
  id v12;
  id v13;
  NSObject *v14;
  id v15;
  NWConcrete_nw_parameters *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  size_t size;
  id v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  size_t v25;
  void *v26;
  NWConcrete_nw_protocol_options *options;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  size_t v32;
  __int16 v33;
  unsigned __int16 v34;
  unsigned int v35;
  os_log_type_t v36;
  size_t v37;
  size_t v38;
  _QWORD *v39;
  int v40;
  NSObject *v41;
  uint64_t v42;
  id v43;
  unint64_t StatusReg;
  int v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  int v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  _BOOL4 v53;
  int v54;
  os_log_type_t v55;
  int v56;
  int v57;
  NSObject *v58;
  nw_endpoint_t v59;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  nw_endpoint_t v61;
  nw_endpoint_t v62;
  id v63;
  _BOOL8 dictionary_with_initial_length;
  NSObject *v65;
  int v66;
  uint64_t v67;
  id v68;
  uint64_t v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  id v73;
  char *v74;
  NSObject *v75;
  os_log_type_t v76;
  id v77;
  NSObject *v78;
  os_log_type_t v79;
  char *v80;
  os_log_type_t v81;
  _BOOL4 v82;
  id v83;
  os_log_type_t v84;
  os_log_type_t v85;
  _BOOL4 v86;
  os_log_type_t v87;
  id v88;
  os_log_type_t v89;
  const char *v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  os_log_type_t v94;
  BOOL v95;
  uint64_t v96;
  os_log_type_t v97;
  _BOOL4 v98;
  os_log_type_t v99;
  char *v100;
  NSObject *v101;
  _BOOL4 v102;
  os_log_type_t v103;
  os_log_type_t v104;
  os_log_type_t v105;
  id v106;
  NSObject *v107;
  os_log_type_t v108;
  char *v109;
  os_log_type_t v110;
  _BOOL4 v111;
  os_log_type_t v112;
  NSObject *v113;
  void *v115;
  char *v116;
  NSObject *v117;
  os_log_type_t v118;
  void *v119;
  os_log_type_t v120;
  void *v121;
  os_log_type_t v122;
  void *v123;
  os_log_type_t v124;
  void *v125;
  os_log_type_t v126;
  void *v127;
  char *v128;
  NSObject *v129;
  os_log_type_t v130;
  void *v131;
  os_log_type_t v132;
  void *v133;
  char *v134;
  NSObject *v135;
  os_log_type_t v136;
  void *v137;
  os_log_type_t v138;
  char *backtrace_string;
  os_log_type_t v140;
  _BOOL4 v141;
  os_log_type_t v142;
  _BOOL4 v143;
  os_log_type_t v144;
  _BOOL4 v145;
  os_log_type_t v146;
  _BOOL4 v147;
  char *v148;
  os_log_type_t v149;
  _BOOL4 v150;
  char *v151;
  os_log_type_t v152;
  _BOOL4 v153;
  char *v154;
  os_log_type_t v155;
  _BOOL4 v156;
  char *v157;
  os_log_type_t v158;
  _BOOL4 v159;
  char *v160;
  os_log_type_t v161;
  _BOOL4 v162;
  os_log_type_t v163;
  os_log_type_t v164;
  os_log_type_t v165;
  os_log_type_t v166;
  os_log_type_t v167;
  os_log_type_t v168;
  os_log_type_t v169;
  os_log_type_t v170;
  os_log_type_t v171;
  os_log_type_t v172;
  unsigned int v173;
  void *v174;
  void *v175;
  void *v176;
  void (**v177)(id, NWConcrete_nw_path_evaluator *, void *);
  id v178;
  NSObject *v179;
  char v180;
  os_log_type_t v181;
  _BYTE type[24];
  _QWORD v183[2];
  _BYTE v184[17];
  int v185;
  _BYTE uu[17];
  int v187;
  uint8_t buf[48];
  uint64_t v189;
  _QWORD __str[7];

  __str[4] = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = a2;
  v13 = a3;
  v178 = a4;
  v176 = v11;
  v177 = a6;
  v174 = v12;
  v175 = v13;
  if (!v11)
  {
    __nwlog_obj();
    v115 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v116 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v116, type, __str))
      goto LABEL_316;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v118 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v118, "%{public}s called with null connection", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (!LOBYTE(__str[0]))
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v163 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v163, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_315;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v117 = objc_claimAutoreleasedReturnValue();
    v140 = type[0];
    v141 = os_log_type_enabled(v117, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (v141)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v140, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (v141)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v117, v140, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_246;
  }
  if (!v12)
  {
    __nwlog_obj();
    v119 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v116 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v116, type, __str))
      goto LABEL_316;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v120 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v120, "%{public}s called with null client_parameters", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (!LOBYTE(__str[0]))
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v164 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v164, "%{public}s called with null client_parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_315;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v117 = objc_claimAutoreleasedReturnValue();
    v142 = type[0];
    v143 = os_log_type_enabled(v117, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (v143)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v142, "%{public}s called with null client_parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (v143)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v117, v142, "%{public}s called with null client_parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_246;
  }
  if (!v13)
  {
    __nwlog_obj();
    v121 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v116 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v116, type, __str))
      goto LABEL_316;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v122 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v122, "%{public}s called with null lcid", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (!LOBYTE(__str[0]))
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v165 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v165, "%{public}s called with null lcid, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_315;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v117 = objc_claimAutoreleasedReturnValue();
    v144 = type[0];
    v145 = os_log_type_enabled(v117, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (v145)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v144, "%{public}s called with null lcid, no backtrace", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (v145)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v117, v144, "%{public}s called with null lcid, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_246;
  }
  if (!v178)
  {
    __nwlog_obj();
    v123 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v116 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v116, type, __str))
      goto LABEL_316;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v124 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v124, "%{public}s called with null rcid", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (!LOBYTE(__str[0]))
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v166 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v166, "%{public}s called with null rcid, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_315;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v117 = objc_claimAutoreleasedReturnValue();
    v146 = type[0];
    v147 = os_log_type_enabled(v117, (os_log_type_t)type[0]);
    if (!backtrace_string)
    {
      if (v147)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v146, "%{public}s called with null rcid, no backtrace", buf, 0xCu);
      }
      goto LABEL_315;
    }
    if (v147)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v117, v146, "%{public}s called with null rcid, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_246:

    free(backtrace_string);
    if (!v116)
      goto LABEL_318;
    goto LABEL_317;
  }
  if (!v177)
  {
    __nwlog_obj();
    v125 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v116 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v116, type, __str))
      goto LABEL_316;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v126 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v126, "%{public}s called with null completion", buf, 0xCu);
      }
    }
    else if (LOBYTE(__str[0]))
    {
      v148 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v149 = type[0];
      v150 = os_log_type_enabled(v117, (os_log_type_t)type[0]);
      if (v148)
      {
        if (v150)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v148;
          _os_log_impl(&dword_182FBE000, v117, v149, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v148);
LABEL_316:
        if (!v116)
        {
LABEL_318:
          v96 = 0;
          goto LABEL_181;
        }
LABEL_317:
        free(v116);
        goto LABEL_318;
      }
      if (v150)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v149, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v117 = objc_claimAutoreleasedReturnValue();
      v167 = type[0];
      if (os_log_type_enabled(v117, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v117, v167, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_315:

    goto LABEL_316;
  }
  v14 = nw_connection_copy_connected_path(v11);
  v179 = v14;
  if (!v14)
  {
    __nwlog_obj();
    v127 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v128 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (__nwlog_fault(v128, type, __str))
    {
      if (type[0] == 17)
      {
        __nwlog_obj();
        v129 = objc_claimAutoreleasedReturnValue();
        v130 = type[0];
        if (os_log_type_enabled(v129, (os_log_type_t)type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
          _os_log_impl(&dword_182FBE000, v129, v130, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (LOBYTE(__str[0]))
      {
        v151 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v129 = objc_claimAutoreleasedReturnValue();
        v152 = type[0];
        v153 = os_log_type_enabled(v129, (os_log_type_t)type[0]);
        if (v151)
        {
          if (v153)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v151;
            _os_log_impl(&dword_182FBE000, v129, v152, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v151);
          goto LABEL_322;
        }
        if (v153)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
          _os_log_impl(&dword_182FBE000, v129, v152, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v129 = objc_claimAutoreleasedReturnValue();
        v168 = type[0];
        if (os_log_type_enabled(v129, (os_log_type_t)type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
          _os_log_impl(&dword_182FBE000, v129, v168, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_322:
    v113 = 0;
    if (v128)
      free(v128);
    v96 = 0;
    goto LABEL_180;
  }
  v15 = v12;
  v16 = (NWConcrete_nw_parameters *)-[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v15, 0, 0);

  nw_parameters_set_required_netagent_classes(v16, 0, 0);
  v17 = nw_path_copy_interface(v14);
  nw_parameters_require_interface(&v16->super, v17);

  v18 = nw_path_copy_effective_local_endpoint(v14);
  nw_parameters_set_local_endpoint(&v16->super, v18);

  nw_parameters_set_reuse_local_address(&v16->super, 1);
  v19 = v175;
  size = dispatch_data_get_size(v19);
  v173 = a5;
  if (!size)
  {
    __nwlog_obj();
    v131 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
    v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v22, type, __str))
      goto LABEL_35;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v132 = type[0];
      if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
        _os_log_impl(&dword_182FBE000, v23, v132, "%{public}s called with null dispatch_data_get_size(dst_cid)", buf, 0xCu);
      }
      goto LABEL_327;
    }
    if (!LOBYTE(__str[0]))
    {
      __nwlog_obj();
      v23 = objc_claimAutoreleasedReturnValue();
      v169 = type[0];
      if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
        _os_log_impl(&dword_182FBE000, v23, v169, "%{public}s called with null dispatch_data_get_size(dst_cid), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_327;
    }
    v154 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    v155 = type[0];
    v156 = os_log_type_enabled(v23, (os_log_type_t)type[0]);
    if (!v154)
    {
      if (v156)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
        _os_log_impl(&dword_182FBE000, v23, v155, "%{public}s called with null dispatch_data_get_size(dst_cid), no backtrace", buf, 0xCu);
      }
      goto LABEL_327;
    }
    if (v156)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v154;
      _os_log_impl(&dword_182FBE000, v23, v155, "%{public}s called with null dispatch_data_get_size(dst_cid), dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v154);
    goto LABEL_35;
  }
  *(_QWORD *)&uu[9] = 0;
  *(_QWORD *)&uu[1] = 0;
  v187 = 0;
  *(_QWORD *)&v184[9] = 0;
  *(_QWORD *)&v184[1] = 0;
  v185 = 0;
  if (size >= 0x15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = dispatch_data_get_size(v19);
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = 20;
    v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v22, type, __str))
      goto LABEL_35;
    if (type[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (id)gLogObj;
      v24 = type[0];
      if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
      {
        v25 = dispatch_data_get_size(v19);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v25;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 20;
        _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s connection id length %zu is too large (> %d)", buf, 0x1Cu);
      }
LABEL_327:

      goto LABEL_35;
    }
    if (!LOBYTE(__str[0]))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (id)gLogObj;
      v36 = type[0];
      if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
      {
        v37 = dispatch_data_get_size(v19);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 20;
        _os_log_impl(&dword_182FBE000, v23, v36, "%{public}s connection id length %zu is too large (> %d), backtrace limit exceeded", buf, 0x1Cu);
      }
      goto LABEL_327;
    }
    v28 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v29 = (id)gLogObj;
    v30 = type[0];
    v31 = os_log_type_enabled(v29, (os_log_type_t)type[0]);
    if (v28)
    {
      if (v31)
      {
        v32 = dispatch_data_get_size(v19);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v32;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = 20;
        *(_WORD *)&buf[28] = 2082;
        *(_QWORD *)&buf[30] = v28;
        _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s connection id length %zu is too large (> %d), dumping backtrace:%{public}s", buf, 0x26u);
      }

      free(v28);
      if (!v22)
        goto LABEL_37;
      goto LABEL_36;
    }
    if (v31)
    {
      v38 = dispatch_data_get_size(v19);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_candidate_manager_ids_quic_demux";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v38;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = 20;
      _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s connection id length %zu is too large (> %d), no backtrace", buf, 0x1Cu);
    }

LABEL_35:
    if (!v22)
    {
LABEL_37:
      options = 0;
      goto LABEL_38;
    }
LABEL_36:
    free(v22);
    goto LABEL_37;
  }
  if (nw_protocol_demux_copy_definition::onceToken != -1)
    dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_5_25927);
  if (nw_protocol_demux_copy_definition::definition)
  {
    v26 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
    options = nw_protocol_create_options(v26);
    if (v26)
      os_release(v26);
  }
  else
  {
    options = nw_protocol_create_options(0);
  }
  uu[0] = -64;
  v184[0] = 64;
  v33 = dispatch_data_get_size(v19);
  v34 = v33 + 1;
  v35 = (unsigned __int16)(v33 + 1);
  if (v35 >= 2)
    memset(&uu[1], 255, (unsigned __int16)(v33 - 1) + 1);
  *(_QWORD *)type = 0;
  *(_QWORD *)&type[8] = type;
  *(_QWORD *)&type[16] = 0x2000000000;
  v183[0] = 0;
  __str[1] = __str;
  __str[2] = 0x2000000000;
  __str[3] = &v184[1];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
  *(_QWORD *)&buf[24] = &unk_1E14A3448;
  v189 = v34 - 1;
  __str[0] = 0;
  *(_QWORD *)&buf[32] = type;
  *(_QWORD *)&buf[40] = __str;
  dispatch_data_apply(v19, buf);
  _Block_object_dispose(__str, 8);
  _Block_object_dispose(type, 8);
  nw_demux_options_add_pattern(options, 0, v35, (uint64_t)v184, (uint64_t)uu);
LABEL_38:

  nw_parameters_set_channel_demux_options(v16, options);
  v39 = v15;
  v40 = *(_DWORD *)(v39[13] + 64);

  v41 = v179;
  if (!v40)
    goto LABEL_62;
  v42 = v40;
  v189 = 0;
  memset(buf, 0, sizeof(buf));
  if (proc_pidinfo(v40, 17, 1uLL, buf, 56) != 56)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v43 = (id)gLogObj;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v45 = **(_DWORD **)(StatusReg + 8);
    *(_DWORD *)type = 136446722;
    *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    *(_WORD *)&type[12] = 2048;
    *(_QWORD *)&type[14] = v42;
    *(_WORD *)&type[22] = 1024;
    LODWORD(v183[0]) = v45;
    v46 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    uu[0] = 0;
    if (!__nwlog_fault(v46, __str, uu))
      goto LABEL_58;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v47 = (id)gLogObj;
      v48 = __str[0];
      if (os_log_type_enabled(v47, __str[0]))
      {
        v49 = **(_DWORD **)(StatusReg + 8);
        *(_DWORD *)type = 136446722;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        *(_WORD *)&type[12] = 2048;
        *(_QWORD *)&type[14] = v42;
        *(_WORD *)&type[22] = 1024;
        LODWORD(v183[0]) = v49;
        _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s proc_pidinfo PROC_PIDUNIQIDENTIFIERINFO for %llu failed: %{darwin.errno}d", type, 0x1Cu);
      }
    }
    else
    {
      if (uu[0])
      {
        v50 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v51 = (id)gLogObj;
        v52 = __str[0];
        v53 = os_log_type_enabled(v51, __str[0]);
        if (v50)
        {
          if (v53)
          {
            v54 = **(_DWORD **)(StatusReg + 8);
            *(_DWORD *)type = 136446978;
            *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
            *(_WORD *)&type[12] = 2048;
            *(_QWORD *)&type[14] = v42;
            *(_WORD *)&type[22] = 1024;
            LODWORD(v183[0]) = v54;
            WORD2(v183[0]) = 2082;
            *(_QWORD *)((char *)v183 + 6) = v50;
            _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s proc_pidinfo PROC_PIDUNIQIDENTIFIERINFO for %llu failed: %{darwin.errno}d, dumping backtrace:%{public}s", type, 0x26u);
          }

          free(v50);
          if (!v46)
            goto LABEL_60;
          goto LABEL_59;
        }
        if (v53)
        {
          v57 = **(_DWORD **)(StatusReg + 8);
          *(_DWORD *)type = 136446722;
          *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&type[12] = 2048;
          *(_QWORD *)&type[14] = v42;
          *(_WORD *)&type[22] = 1024;
          LODWORD(v183[0]) = v57;
          _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s proc_pidinfo PROC_PIDUNIQIDENTIFIERINFO for %llu failed: %{darwin.errno}d, no backtrace", type, 0x1Cu);
        }

LABEL_58:
        if (!v46)
        {
LABEL_60:
          v41 = v179;
          goto LABEL_61;
        }
LABEL_59:
        free(v46);
        goto LABEL_60;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v47 = (id)gLogObj;
      v55 = __str[0];
      if (os_log_type_enabled(v47, __str[0]))
      {
        v56 = **(_DWORD **)(StatusReg + 8);
        *(_DWORD *)type = 136446722;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        *(_WORD *)&type[12] = 2048;
        *(_QWORD *)&type[14] = v42;
        *(_WORD *)&type[22] = 1024;
        LODWORD(v183[0]) = v56;
        _os_log_impl(&dword_182FBE000, v47, v55, "%{public}s proc_pidinfo PROC_PIDUNIQIDENTIFIERINFO for %llu failed: %{darwin.errno}d, backtrace limit exceeded", type, 0x1Cu);
      }
    }

    goto LABEL_58;
  }
  v42 = *(_QWORD *)&buf[16];
LABEL_61:
  nw_parameters_set_delegated_unique_pid(v16, v42);
LABEL_62:
  *(_QWORD *)uu = 0;
  *(_QWORD *)&uu[8] = 0;
  v58 = v41;
  *(_OWORD *)uu = *(_OWORD *)&v58[15].isa;

  if (!uuid_is_null(uu))
    nw_parameters_set_parent_id_inner(v16, uu, 1);
  nw_parameters_set_preferred_interface_subtypes(v16, 0);
  nw_parameters_set_multipath_service(&v16->super, nw_multipath_service_disabled);
  v59 = nw_path_copy_effective_remote_endpoint(v58);
  evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v59, v16);

  v61 = nw_path_copy_effective_remote_endpoint(v58);
  if (!v61)
  {
    __nwlog_obj();
    v133 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v134 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v134, type, __str))
      goto LABEL_334;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v135 = objc_claimAutoreleasedReturnValue();
      v136 = type[0];
      if (os_log_type_enabled(v135, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v135, v136, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (LOBYTE(__str[0]))
    {
      v157 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v135 = objc_claimAutoreleasedReturnValue();
      v158 = type[0];
      v159 = os_log_type_enabled(v135, (os_log_type_t)type[0]);
      if (v157)
      {
        if (v159)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v157;
          _os_log_impl(&dword_182FBE000, v135, v158, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v157);
        if (!v134)
          goto LABEL_336;
        goto LABEL_335;
      }
      if (v159)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v135, v158, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v135 = objc_claimAutoreleasedReturnValue();
      v170 = type[0];
      if (os_log_type_enabled(v135, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v135, v170, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_333;
  }
  v62 = v61;
  v63 = -[NSObject copy](v61, "copy");

  if (!v63)
  {
    __nwlog_obj();
    v137 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v134 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v134, type, __str))
      goto LABEL_334;
    if (type[0] == 17)
    {
      __nwlog_obj();
      v135 = objc_claimAutoreleasedReturnValue();
      v138 = type[0];
      if (os_log_type_enabled(v135, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v135, v138, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (LOBYTE(__str[0]))
    {
      v160 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v135 = objc_claimAutoreleasedReturnValue();
      v161 = type[0];
      v162 = os_log_type_enabled(v135, (os_log_type_t)type[0]);
      if (v160)
      {
        if (v162)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v160;
          _os_log_impl(&dword_182FBE000, v135, v161, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v160);
LABEL_334:
        if (!v134)
        {
LABEL_336:
          v96 = 0;
          goto LABEL_179;
        }
LABEL_335:
        free(v134);
        goto LABEL_336;
      }
      if (v162)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v135, v161, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v135 = objc_claimAutoreleasedReturnValue();
      v171 = type[0];
      if (os_log_type_enabled(v135, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v135, v171, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_333:

    goto LABEL_334;
  }
  dictionary_with_initial_length = nw_txt_record_create_dictionary_with_initial_length(0x100uLL);
  *(_QWORD *)v184 = 0;
  *(_QWORD *)&v184[8] = 0;
  if (!nw_path_evaluator_get_client_id(evaluator_for_endpoint, v184))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v73 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
    v74 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    LOBYTE(__str[0]) = 0;
    if (!__nwlog_fault(v74, type, __str))
      goto LABEL_175;
    if (type[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v75 = (id)gLogObj;
      v76 = type[0];
      if (os_log_type_enabled(v75, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s nw_path_evaluator_get_client_id failed", buf, 0xCu);
      }
    }
    else if (LOBYTE(__str[0]))
    {
      v80 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v75 = (id)gLogObj;
      v81 = type[0];
      v82 = os_log_type_enabled(v75, (os_log_type_t)type[0]);
      if (v80)
      {
        if (v82)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v80;
          _os_log_impl(&dword_182FBE000, v75, v81, "%{public}s nw_path_evaluator_get_client_id failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

LABEL_101:
        free(v80);
        if (!v74)
          goto LABEL_177;
        goto LABEL_176;
      }
      if (v82)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v75, v81, "%{public}s nw_path_evaluator_get_client_id failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v75 = (id)gLogObj;
      v87 = type[0];
      if (os_log_type_enabled(v75, (os_log_type_t)type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v75, v87, "%{public}s nw_path_evaluator_get_client_id failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_175;
  }
  memset(buf, 0, 37);
  uuid_unparse(v184, (char *)buf);
  if (!nw_txt_record_set_key((nw_txt_record_t)dictionary_with_initial_length, "eval", buf, 0x24uLL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v77 = (id)gLogObj;
    *(_DWORD *)type = 136446210;
    *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    v181 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v74, __str, &v181))
      goto LABEL_175;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v78 = (id)gLogObj;
      v79 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s failed to add kIDSKeyPathUUID", type, 0xCu);
      }
      goto LABEL_149;
    }
    if (v181 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v78 = (id)gLogObj;
      v94 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v94, "%{public}s failed to add kIDSKeyPathUUID, backtrace limit exceeded", type, 0xCu);
      }
      goto LABEL_149;
    }
    v80 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v78 = (id)gLogObj;
    v85 = __str[0];
    v86 = os_log_type_enabled(v78, __str[0]);
    if (!v80)
    {
      if (v86)
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v85, "%{public}s failed to add kIDSKeyPathUUID, no backtrace", type, 0xCu);
      }
      goto LABEL_149;
    }
    if (v86)
    {
      *(_DWORD *)type = 136446466;
      *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
      *(_WORD *)&type[12] = 2082;
      *(_QWORD *)&type[14] = v80;
      _os_log_impl(&dword_182FBE000, v78, v85, "%{public}s failed to add kIDSKeyPathUUID, dumping backtrace:%{public}s", type, 0x16u);
    }
LABEL_100:

    goto LABEL_101;
  }
  if (!nw_txt_record_set_key_data_value((void *)dictionary_with_initial_length, "lcid", v19))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v83 = (id)gLogObj;
    *(_DWORD *)type = 136446210;
    *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    v181 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v74, __str, &v181))
      goto LABEL_175;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v78 = (id)gLogObj;
      v84 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v84, "%{public}s failed to add kIDSKeyLocalCID", type, 0xCu);
      }
    }
    else if (v181)
    {
      v90 = __nw_create_backtrace_string();
      if (v90)
      {
        v91 = (char *)v90;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v92 = (id)gLogObj;
        v93 = __str[0];
        if (os_log_type_enabled(v92, __str[0]))
        {
          *(_DWORD *)type = 136446466;
          *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&type[12] = 2082;
          *(_QWORD *)&type[14] = v91;
          _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s failed to add kIDSKeyLocalCID, dumping backtrace:%{public}s", type, 0x16u);
        }

        free(v91);
        if (!v74)
          goto LABEL_177;
        goto LABEL_176;
      }
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v103 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v103, "%{public}s failed to add kIDSKeyLocalCID, no backtrace", type, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v78 = (id)gLogObj;
      v99 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v99, "%{public}s failed to add kIDSKeyLocalCID, backtrace limit exceeded", type, 0xCu);
      }
    }
    goto LABEL_149;
  }
  if (!nw_txt_record_set_key_data_value((void *)dictionary_with_initial_length, "rcid", v178))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v88 = (id)gLogObj;
    *(_DWORD *)type = 136446210;
    *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    v181 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v74, __str, &v181))
      goto LABEL_175;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v78 = (id)gLogObj;
      v89 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v89, "%{public}s failed to add kIDSKeyRemoteCID", type, 0xCu);
      }
LABEL_149:

      goto LABEL_175;
    }
    if (v181 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v78 = objc_claimAutoreleasedReturnValue();
      v104 = __str[0];
      if (os_log_type_enabled(v78, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v104, "%{public}s failed to add kIDSKeyRemoteCID, backtrace limit exceeded", type, 0xCu);
      }
      goto LABEL_149;
    }
    v80 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v78 = objc_claimAutoreleasedReturnValue();
    v97 = __str[0];
    v98 = os_log_type_enabled(v78, __str[0]);
    if (!v80)
    {
      if (v98)
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v78, v97, "%{public}s failed to add kIDSKeyRemoteCID, no backtrace", type, 0xCu);
      }
      goto LABEL_149;
    }
    if (v98)
    {
      *(_DWORD *)type = 136446466;
      *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
      *(_WORD *)&type[12] = 2082;
      *(_QWORD *)&type[14] = v80;
      _os_log_impl(&dword_182FBE000, v78, v97, "%{public}s failed to add kIDSKeyRemoteCID, dumping backtrace:%{public}s", type, 0x16u);
    }
    goto LABEL_100;
  }
  v65 = (id)dictionary_with_initial_length;
  v66 = snprintf((char *)__str, 0x15uLL, "%llu", v173);
  v67 = v66;
  if (v66 >= 0x15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v68 = (id)gLogObj;
    v69 = v67 - 20;
    *(_DWORD *)type = 136446466;
    *(_QWORD *)&type[4] = "nw_txt_record_set_key_uint64_value";
    *(_WORD *)&type[12] = 2048;
    *(_QWORD *)&type[14] = v67 - 20;
    v70 = (char *)_os_log_send_and_compose_impl();

    v181 = OS_LOG_TYPE_ERROR;
    v180 = 0;
    if (__nwlog_fault(v70, &v181, &v180))
    {
      if (v181 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v71 = objc_claimAutoreleasedReturnValue();
        v72 = v181;
        if (os_log_type_enabled(v71, v181))
        {
          *(_DWORD *)type = 136446466;
          *(_QWORD *)&type[4] = "nw_txt_record_set_key_uint64_value";
          *(_WORD *)&type[12] = 2048;
          *(_QWORD *)&type[14] = v69;
          _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s buffer was too small by %lu bytes", type, 0x16u);
        }
      }
      else
      {
        if (v180)
        {
          v100 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v101 = objc_claimAutoreleasedReturnValue();
          v172 = v181;
          v102 = os_log_type_enabled(v101, v181);
          if (v100)
          {
            if (v102)
            {
              *(_DWORD *)type = 136446722;
              *(_QWORD *)&type[4] = "nw_txt_record_set_key_uint64_value";
              *(_WORD *)&type[12] = 2048;
              *(_QWORD *)&type[14] = v69;
              *(_WORD *)&type[22] = 2082;
              v183[0] = v100;
              _os_log_impl(&dword_182FBE000, v101, v172, "%{public}s buffer was too small by %lu bytes, dumping backtrace:%{public}s", type, 0x20u);
            }

            free(v100);
          }
          else
          {
            if (v102)
            {
              *(_DWORD *)type = 136446466;
              *(_QWORD *)&type[4] = "nw_txt_record_set_key_uint64_value";
              *(_WORD *)&type[12] = 2048;
              *(_QWORD *)&type[14] = v69;
              _os_log_impl(&dword_182FBE000, v101, v172, "%{public}s buffer was too small by %lu bytes, no backtrace", type, 0x16u);
            }

          }
          goto LABEL_156;
        }
        __nwlog_obj();
        v71 = objc_claimAutoreleasedReturnValue();
        v105 = v181;
        if (os_log_type_enabled(v71, v181))
        {
          *(_DWORD *)type = 136446466;
          *(_QWORD *)&type[4] = "nw_txt_record_set_key_uint64_value";
          *(_WORD *)&type[12] = 2048;
          *(_QWORD *)&type[14] = v69;
          _os_log_impl(&dword_182FBE000, v71, v105, "%{public}s buffer was too small by %lu bytes, backtrace limit exceeded", type, 0x16u);
        }
      }

    }
LABEL_156:
    if (v70)
      free(v70);

LABEL_159:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v106 = (id)gLogObj;
    *(_DWORD *)type = 136446210;
    *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
    v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__str[0]) = 16;
    v181 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v74, __str, &v181))
      goto LABEL_175;
    if (LOBYTE(__str[0]) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v107 = (id)gLogObj;
      v108 = __str[0];
      if (os_log_type_enabled(v107, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v107, v108, "%{public}s failed to add kIDSKeyRemoteInterfaceType", type, 0xCu);
      }
    }
    else if (v181)
    {
      v109 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v107 = objc_claimAutoreleasedReturnValue();
      v110 = __str[0];
      v111 = os_log_type_enabled(v107, __str[0]);
      if (v109)
      {
        if (v111)
        {
          *(_DWORD *)type = 136446466;
          *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
          *(_WORD *)&type[12] = 2082;
          *(_QWORD *)&type[14] = v109;
          _os_log_impl(&dword_182FBE000, v107, v110, "%{public}s failed to add kIDSKeyRemoteInterfaceType, dumping backtrace:%{public}s", type, 0x16u);
        }

        free(v109);
LABEL_175:
        if (!v74)
        {
LABEL_177:
          v96 = 0;
          goto LABEL_178;
        }
LABEL_176:
        free(v74);
        goto LABEL_177;
      }
      if (v111)
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v107, v110, "%{public}s failed to add kIDSKeyRemoteInterfaceType, no backtrace", type, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v107 = objc_claimAutoreleasedReturnValue();
      v112 = __str[0];
      if (os_log_type_enabled(v107, __str[0]))
      {
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_candidate_endpoint_for_ids_connection";
        _os_log_impl(&dword_182FBE000, v107, v112, "%{public}s failed to add kIDSKeyRemoteInterfaceType, backtrace limit exceeded", type, 0xCu);
      }
    }

    goto LABEL_175;
  }
  v95 = nw_txt_record_set_key(v65, "rift", (const uint8_t *)__str, v66);

  if (!v95)
    goto LABEL_159;
  nw_endpoint_set_txt_record(v63, v65);
  v177[2](v177, evaluator_for_endpoint, v63);
  v96 = 1;
LABEL_178:

LABEL_179:
  v113 = v179;
LABEL_180:

LABEL_181:
  return v96;
}

void sub_183394688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

BOOL nw_txt_record_set_key_data_value(void *a1, const char *a2, void *a3)
{
  NSObject *v5;
  NSObject *v6;
  size_t size;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  size_t v12;
  _BOOL8 v13;
  uint8_t *v14;
  _BOOL8 result;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  size_t v19;
  os_log_type_t v20;
  size_t v21;
  size_t v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  _QWORD applier[6];
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  size_t v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  size = dispatch_data_get_size(v6);
  if (strlen(a2) + 2 * size >= 0x100)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    v31 = "nw_txt_record_set_key_data_value";
    v32 = 2080;
    v33 = (uint64_t)a2;
    v34 = 2048;
    v35 = dispatch_data_get_size(v6);
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v9, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          v12 = dispatch_data_get_size(v6);
          *(_DWORD *)buf = 136446722;
          v31 = "nw_txt_record_set_key_data_value";
          v32 = 2080;
          v33 = (uint64_t)a2;
          v34 = 2048;
          v35 = v12;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s Key %s + data value length %zu too large", buf, 0x20u);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v18)
          {
            v19 = dispatch_data_get_size(v6);
            *(_DWORD *)buf = 136446978;
            v31 = "nw_txt_record_set_key_data_value";
            v32 = 2080;
            v33 = (uint64_t)a2;
            v34 = 2048;
            v35 = v19;
            v36 = 2082;
            v37 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s Key %s + data value length %zu too large, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(backtrace_string);
          if (!v9)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (v18)
        {
          v22 = dispatch_data_get_size(v6);
          *(_DWORD *)buf = 136446722;
          v31 = "nw_txt_record_set_key_data_value";
          v32 = 2080;
          v33 = (uint64_t)a2;
          v34 = 2048;
          v35 = v22;
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s Key %s + data value length %zu too large, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          v21 = dispatch_data_get_size(v6);
          *(_DWORD *)buf = 136446722;
          v31 = "nw_txt_record_set_key_data_value";
          v32 = 2080;
          v33 = (uint64_t)a2;
          v34 = 2048;
          v35 = v21;
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s Key %s + data value length %zu too large, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
    if (!v9)
    {
LABEL_9:
      v13 = 0;
LABEL_14:

      return v13;
    }
LABEL_8:
    free(v9);
    goto LABEL_9;
  }
  if (!(2 * size))
  {
    __nwlog_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v31 = "strict_calloc";
    v24 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v24);
    if (result)
      goto LABEL_31;
    free(v24);
  }
  v14 = (uint8_t *)malloc_type_calloc(1uLL, 2 * size, 0xEAFB8F1AuLL);
  if (v14)
    goto LABEL_12;
  __nwlog_obj();
  v25 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v31 = "strict_calloc";
  v32 = 2048;
  v33 = 1;
  v34 = 2048;
  v35 = 2 * size;
  v26 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
LABEL_12:
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = ___ZL32nw_txt_record_set_key_data_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPU27objcproto16OS_dispatch_dataS__block_invoke;
    applier[3] = &__block_descriptor_48_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
    applier[4] = size;
    applier[5] = v14;
    dispatch_data_apply(v6, applier);
    v13 = nw_txt_record_set_key(v5, a2, v14, 2 * size);
    if (v14)
      free(v14);
    goto LABEL_14;
  }
LABEL_31:
  __break(1u);
  return result;
}

void sub_183394CC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_txt_record_set_key_data_valuePU27objcproto16OS_nw_txt_record8NSObjectPKcPU27objcproto16OS_dispatch_dataS__block_invoke(uint64_t a1, uint64_t a2, unint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v5;
  char v6;

  if (a5)
  {
    v5 = 2 * a3;
    do
    {
      if (a3 >= *(_QWORD *)(a1 + 32))
        break;
      *(_BYTE *)(*(_QWORD *)(a1 + 40) + v5) = nw_printf_write_data::hex_chars[(unint64_t)*a4 >> 4];
      v6 = *a4++;
      *(_BYTE *)(*(_QWORD *)(a1 + 40) + v5 + 1) = nw_printf_write_data::hex_chars[v6 & 0xF];
      v5 += 2;
      ++a3;
      --a5;
    }
    while (a5);
  }
  return 1;
}

uint64_t nw_protocol_fulfill_frame_request(_QWORD *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, unsigned int *a6, _BYTE *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  unsigned int v18;
  os_log_type_t *v19;
  _QWORD *v20;
  os_log_type_t *v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  char *v32;
  const char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  NSObject *v38;
  char *backtrace_string;
  _BOOL4 v40;
  const char *v41;
  _BOOL4 v42;
  NSObject *v43;
  int v44;
  int v45;
  _BOOL4 v46;
  NSObject *v47;
  int v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  int v56;
  os_log_type_t type[8];
  os_log_type_t *v58;
  uint64_t v59;
  __n128 (*v60)(uint64_t, uint64_t);
  uint64_t (*v61)();
  _QWORD v62[2];
  uint8_t v63[4];
  const char *v64;
  __int16 v65;
  int v66;
  __int16 v67;
  int v68;
  __int16 v69;
  _QWORD *v70;
  __int16 v71;
  uint64_t v72;
  _BYTE v73[24];
  void *v74;
  os_log_type_t *v75;
  uint64_t v76;
  char v77;
  _BYTE buf[24];
  void *v79;
  char *v80;
  uint64_t *v81;
  os_log_type_t *v82;
  _BYTE *v83;
  _QWORD *v84;
  int v85;
  unsigned int v86;
  char v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (a6)
    *a6 = 0;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
    v34 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v73[0] = 0;
    if (!__nwlog_fault(v34, type, v73))
      goto LABEL_91;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (!os_log_type_enabled(v35, type[0]))
        goto LABEL_91;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
      v37 = "%{public}s called with null source_array";
LABEL_90:
      _os_log_impl(&dword_182FBE000, v35, v36, v37, buf, 0xCu);
      goto LABEL_91;
    }
    if (!v73[0])
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
        v37 = "%{public}s called with null source_array, backtrace limit exceeded";
        goto LABEL_90;
      }
      goto LABEL_91;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v35 = __nwlog_obj();
    v36 = type[0];
    v40 = os_log_type_enabled(v35, type[0]);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
        v37 = "%{public}s called with null source_array, no backtrace";
        goto LABEL_90;
      }
      goto LABEL_91;
    }
    if (!v40)
      goto LABEL_77;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v41 = "%{public}s called with null source_array, dumping backtrace:%{public}s";
LABEL_76:
    _os_log_impl(&dword_182FBE000, v35, v36, v41, buf, 0x16u);
    goto LABEL_77;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
    v34 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v73[0] = 0;
    if (!__nwlog_fault(v34, type, v73))
      goto LABEL_91;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (!os_log_type_enabled(v35, type[0]))
        goto LABEL_91;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
      v37 = "%{public}s called with null destination_array";
      goto LABEL_90;
    }
    if (!v73[0])
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
        v37 = "%{public}s called with null destination_array, backtrace limit exceeded";
        goto LABEL_90;
      }
      goto LABEL_91;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v35 = __nwlog_obj();
    v36 = type[0];
    v42 = os_log_type_enabled(v35, type[0]);
    if (!backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
        v37 = "%{public}s called with null destination_array, no backtrace";
        goto LABEL_90;
      }
      goto LABEL_91;
    }
    if (!v42)
      goto LABEL_77;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v41 = "%{public}s called with null destination_array, dumping backtrace:%{public}s";
    goto LABEL_76;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
    v34 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v73[0] = 0;
    if (!__nwlog_fault(v34, type, v73))
      goto LABEL_91;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
        v37 = "%{public}s called with null metadata_complete";
        goto LABEL_90;
      }
LABEL_91:
      if (!v34)
        return 0;
      v32 = (char *)v34;
      goto LABEL_45;
    }
    if (!v73[0])
    {
      v35 = __nwlog_obj();
      v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
        v37 = "%{public}s called with null metadata_complete, backtrace limit exceeded";
        goto LABEL_90;
      }
      goto LABEL_91;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v35 = __nwlog_obj();
    v36 = type[0];
    v46 = os_log_type_enabled(v35, type[0]);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
        v37 = "%{public}s called with null metadata_complete, no backtrace";
        goto LABEL_90;
      }
      goto LABEL_91;
    }
    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v41 = "%{public}s called with null metadata_complete, dumping backtrace:%{public}s";
      goto LABEL_76;
    }
LABEL_77:
    free(backtrace_string);
    goto LABEL_91;
  }
  if (gLogDatapath)
  {
    v38 = __nwlog_obj();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = a4;
      LOWORD(v79) = 1024;
      *(_DWORD *)((char *)&v79 + 2) = a5;
      _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s called with minimum bytes: %u, maximum bytes: %u, maximum frames: %u", buf, 0x1Eu);
    }
  }
  if (a4 < a3 || !a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a4;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    LOWORD(v79) = 1024;
    *(_DWORD *)((char *)&v79 + 2) = a5;
    v26 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v73[0] = 0;
    if (__nwlog_fault(v26, type, v73))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = gLogObj;
        v28 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a4;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = a3;
          LOWORD(v79) = 1024;
          *(_DWORD *)((char *)&v79 + 2) = a5;
          v29 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u";
LABEL_42:
          _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0x1Eu);
        }
      }
      else if (v73[0])
      {
        v30 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = gLogObj;
        v28 = type[0];
        v31 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v30)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = a4;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = a3;
            LOWORD(v79) = 1024;
            *(_DWORD *)((char *)&v79 + 2) = a5;
            HIWORD(v79) = 2082;
            v80 = v30;
            _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s invalid values for frame request, max %u, min %u, max frame %u, dumping backtrace:%{public}s", buf, 0x28u);
          }
          free(v30);
          goto LABEL_43;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a4;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = a3;
          LOWORD(v79) = 1024;
          *(_DWORD *)((char *)&v79 + 2) = a5;
          v29 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, no backtrace";
          goto LABEL_42;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = gLogObj;
        v28 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "__nw_protocol_fulfill_frame_request";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a4;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = a3;
          LOWORD(v79) = 1024;
          *(_DWORD *)((char *)&v79 + 2) = a5;
          v29 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, backtrace limit exceeded";
          goto LABEL_42;
        }
      }
    }
LABEL_43:
    if (!v26)
      return 0;
    v32 = (char *)v26;
LABEL_45:
    free(v32);
    return 0;
  }
  *(_QWORD *)type = 0;
  v58 = type;
  v59 = 0x3802000000;
  v60 = __Block_byref_object_copy__3150;
  v61 = __Block_byref_object_dispose__3151;
  v62[0] = 0;
  v62[1] = v62;
  v53 = 0;
  v54 = &v53;
  v56 = 0;
  v55 = 0x2000000000;
  v49 = 0;
  v50 = &v49;
  v52 = 0;
  v51 = 0x2000000000;
  v14 = MEMORY[0x1E0C809B0];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke;
  v79 = &unk_1E149A808;
  v80 = (char *)&v53;
  v81 = &v49;
  v85 = a5;
  v86 = a4;
  v83 = a7;
  v84 = a1;
  v87 = 1;
  v82 = type;
  v88 = 1;
  v15 = *a1;
  do
  {
    if (!v15)
      break;
    v16 = *(_QWORD *)(v15 + 32);
    v17 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v15 = v16;
  }
  while ((v17 & 1) != 0);
  v18 = *((_DWORD *)v50 + 6);
  if (v18 < a3 && *((_QWORD *)v58 + 5) && !*a7)
  {
    if (gLogDatapath)
    {
      v47 = __nwlog_obj();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
      {
        v48 = *((_DWORD *)v50 + 6);
        *(_DWORD *)v73 = 136446722;
        *(_QWORD *)&v73[4] = "__nw_protocol_fulfill_frame_request";
        *(_WORD *)&v73[12] = 1024;
        *(_DWORD *)&v73[14] = a3;
        *(_WORD *)&v73[18] = 1024;
        *(_DWORD *)&v73[20] = v48;
        _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_DEBUG, "%{public}s could not meet minimum byte count %u with %u bytes from source array", v73, 0x18u);
      }
    }
    v19 = v58;
    v20 = v58 + 40;
    if (*a1)
    {
      **((_QWORD **)v58 + 6) = *a1;
      *(_QWORD *)(*a1 + 40) = *((_QWORD *)v19 + 6);
      *((_QWORD *)v19 + 6) = a1[1];
      *a1 = 0;
      a1[1] = a1;
    }
    if (*v20)
    {
      *(_QWORD *)a1[1] = *v20;
      *(_QWORD *)(*((_QWORD *)v19 + 5) + 40) = a1[1];
      a1[1] = *((_QWORD *)v19 + 6);
      *((_QWORD *)v19 + 5) = 0;
      *((_QWORD *)v19 + 6) = v20;
    }
    v18 = 0;
    v21 = v58;
    *((_QWORD *)v58 + 5) = 0;
    *((_QWORD *)v21 + 6) = v21 + 40;
    *((_DWORD *)v54 + 6) = 0;
    *((_DWORD *)v50 + 6) = 0;
  }
  if (a6)
    *a6 = v18;
  v22 = *((_QWORD *)v58 + 5);
  if (v22)
  {
    *(_QWORD *)v73 = v14;
    *(_QWORD *)&v73[8] = 0x40000000;
    *(_QWORD *)&v73[16] = ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke_25;
    v74 = &unk_1E149A830;
    v77 = 1;
    v75 = type;
    v76 = a2;
    do
    {
      if (!v22)
        break;
      v23 = *(_QWORD *)(v22 + 32);
      v24 = (*(uint64_t (**)(_BYTE *))&v73[16])(v73);
      v22 = v23;
    }
    while ((v24 & 1) != 0);
  }
  if (gLogDatapath)
  {
    v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      v44 = *((_DWORD *)v54 + 6);
      v45 = *((_DWORD *)v50 + 6);
      *(_DWORD *)v63 = 136447234;
      v64 = "__nw_protocol_fulfill_frame_request";
      v65 = 1024;
      v66 = v44;
      v67 = 1024;
      v68 = v45;
      v69 = 2048;
      v70 = a1;
      v71 = 2048;
      v72 = a2;
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s moved (%u frames, %u bytes) from %p to %p", v63, 0x2Cu);
    }
  }
  v25 = *((unsigned int *)v54 + 6);
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  _Block_object_dispose(type, 8);
  return v25;
}

__n128 __Block_byref_object_copy__3150(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

BOOL ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  _BOOL8 result;
  unsigned int v6;
  int v7;
  os_log_t *v8;
  uint64_t v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  unsigned int v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t v27;
  const char *v28;
  NSObject *v29;
  NSObject **v30;
  char *v31;
  NSObject **v32;
  _BOOL4 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  NSObject *v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  const char *v47;
  uint64_t v48;
  int v49;
  os_log_t *v50;
  uint64_t v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  uint64_t v55;
  const char *v56;
  char *v57;
  _BOOL4 v58;
  char *v59;
  _BOOL4 v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  NSObject *v72;
  os_log_type_t v73;
  uint64_t v74;
  const char *v75;
  char *v76;
  _BOOL4 v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  NSObject *v91;
  os_log_type_t v92;
  uint64_t v93;
  const char *v94;
  char *v95;
  _BOOL4 v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;
  NSObject *v103;
  NSObject *v104;
  int v105;
  int v106;
  char v107;
  os_log_type_t type[8];
  os_log_type_t v109;
  uint8_t buf[4];
  const char *v111;
  __int16 v112;
  _BYTE v113[10];
  uint64_t v114;
  _BYTE v115[10];
  __int16 v116;
  char *v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  if ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 1) > *(_DWORD *)(a1 + 72))
    return 0;
  v6 = v4;
  v7 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v8 = (os_log_t *)&unk_1ECD84000;
  v9 = v7 + v4;
  if (__CFADD__(v7, v4))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
    v112 = 2082;
    *(_QWORD *)v113 = "bytes_count_with_this_frame";
    *(_WORD *)&v113[8] = 2048;
    v114 = v6;
    *(_WORD *)v115 = 2048;
    *(_QWORD *)&v115[2] = v9;
    v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v109 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v10, type, &v109))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(_QWORD *)v113 = "bytes_count_with_this_frame";
          *(_WORD *)&v113[8] = 2048;
          v114 = v6;
          *(_WORD *)v115 = 2048;
          *(_QWORD *)&v115[2] = v9;
          v13 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_18:
          _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0x2Au);
        }
      }
      else if (v109)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type[0];
        v15 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136447234;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v112 = 2082;
            *(_QWORD *)v113 = "bytes_count_with_this_frame";
            *(_WORD *)&v113[8] = 2048;
            v114 = v6;
            *(_WORD *)v115 = 2048;
            *(_QWORD *)&v115[2] = v9;
            v116 = 2082;
            v117 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          v8 = (os_log_t *)&unk_1ECD84000;
          goto LABEL_19;
        }
        v8 = (os_log_t *)&unk_1ECD84000;
        if (v15)
        {
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(_QWORD *)v113 = "bytes_count_with_this_frame";
          *(_WORD *)&v113[8] = 2048;
          v114 = v6;
          *(_WORD *)v115 = 2048;
          *(_QWORD *)&v115[2] = v9;
          v13 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_18;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(_QWORD *)v113 = "bytes_count_with_this_frame";
          *(_WORD *)&v113[8] = 2048;
          v114 = v6;
          *(_WORD *)v115 = 2048;
          *(_QWORD *)&v115[2] = v9;
          v13 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_18;
        }
      }
    }
LABEL_19:
    if (v10)
      free(v10);
    LODWORD(v9) = -1;
  }
  v16 = *(_DWORD *)(a1 + 76);
  if (v9 <= v16)
  {
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v22 = *(_DWORD *)(v21 + 24);
    *(_DWORD *)(v21 + 24) = v22 + v6;
    if (!__CFADD__(v22, v6))
      goto LABEL_81;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    *(_DWORD *)buf = 136446978;
    v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
    v112 = 2082;
    *(_QWORD *)v113 = "bytes_count";
    *(_WORD *)&v113[8] = 2048;
    v114 = v6;
    *(_WORD *)v115 = 2048;
    *(_QWORD *)&v115[2] = v23;
    v24 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v109 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v24, type, &v109))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = v8[463];
        v26 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          v27 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(_QWORD *)v113 = "bytes_count";
          *(_WORD *)&v113[8] = 2048;
          v114 = v6;
          *(_WORD *)v115 = 2048;
          *(_QWORD *)&v115[2] = v27;
          v28 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_77:
          _os_log_impl(&dword_182FBE000, v25, v26, v28, buf, 0x2Au);
        }
      }
      else if (v109)
      {
        v30 = v8;
        v31 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = v30;
        v25 = v30[463];
        v26 = type[0];
        v33 = os_log_type_enabled(v25, type[0]);
        if (v31)
        {
          if (v33)
          {
            v34 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
            *(_DWORD *)buf = 136447234;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v112 = 2082;
            *(_QWORD *)v113 = "bytes_count";
            *(_WORD *)&v113[8] = 2048;
            v114 = v6;
            *(_WORD *)v115 = 2048;
            *(_QWORD *)&v115[2] = v34;
            v116 = 2082;
            v117 = v31;
            _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v31);
          v8 = v32;
          goto LABEL_78;
        }
        v8 = v32;
        if (v33)
        {
          v63 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(_QWORD *)v113 = "bytes_count";
          *(_WORD *)&v113[8] = 2048;
          v114 = v6;
          *(_WORD *)v115 = 2048;
          *(_QWORD *)&v115[2] = v63;
          v28 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_77;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = v8[463];
        v26 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          v62 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(_QWORD *)v113 = "bytes_count";
          *(_WORD *)&v113[8] = 2048;
          v114 = v6;
          *(_WORD *)v115 = 2048;
          *(_QWORD *)&v115[2] = v62;
          v28 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_77;
        }
      }
    }
LABEL_78:
    if (v24)
      free(v24);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = -1;
LABEL_81:
    if (nw_frame_is_metadata_complete(a2))
      **(_BYTE **)(a1 + 56) = 1;
    if (*(_BYTE *)(a1 + 80))
    {
      v65 = *(_QWORD *)(a2 + 32);
      v66 = *(_QWORD **)(a2 + 40);
      v64 = (_QWORD *)(a2 + 32);
      if (v65)
      {
        *(_QWORD *)(v65 + 40) = v66;
        **(_QWORD **)(a2 + 40) = v65;
LABEL_90:
        *v64 = 0;
        v64[1] = 0;
        if (gLogDatapath)
        {
          v103 = __nwlog_obj();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v112 = 1024;
            *(_DWORD *)v113 = v6;
            _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_DEBUG, "%{public}s Moving entire frame (%u bytes)", buf, 0x12u);
          }
        }
        v67 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v68 = *(unsigned int *)(v67 + 24) + 1;
        v69 = v68 << 31 >> 31;
        *(_DWORD *)(v67 + 24) = v68;
        if (v69 == v68 && (v69 & 0x8000000000000000) == 0)
          goto LABEL_110;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v70 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        *(_DWORD *)buf = 136446978;
        v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
        v112 = 2082;
        *(_QWORD *)v113 = "frame_count";
        *(_WORD *)&v113[8] = 2048;
        v114 = 1;
        *(_WORD *)v115 = 2048;
        *(_QWORD *)&v115[2] = v70;
        v71 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v109 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v71, type, &v109))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v72 = v8[463];
            v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              v74 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136446978;
              v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
              v112 = 2082;
              *(_QWORD *)v113 = "frame_count";
              *(_WORD *)&v113[8] = 2048;
              v114 = 1;
              *(_WORD *)v115 = 2048;
              *(_QWORD *)&v115[2] = v74;
              v75 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_106:
              _os_log_impl(&dword_182FBE000, v72, v73, v75, buf, 0x2Au);
            }
          }
          else if (v109)
          {
            v76 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v72 = v8[463];
            v73 = type[0];
            v77 = os_log_type_enabled(v72, type[0]);
            if (v76)
            {
              if (v77)
              {
                v78 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136447234;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(_QWORD *)v113 = "frame_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = 1;
                *(_WORD *)v115 = 2048;
                *(_QWORD *)&v115[2] = v78;
                v116 = 2082;
                v117 = v76;
                _os_log_impl(&dword_182FBE000, v72, v73, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v76);
              goto LABEL_107;
            }
            if (v77)
            {
              v80 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136446978;
              v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
              v112 = 2082;
              *(_QWORD *)v113 = "frame_count";
              *(_WORD *)&v113[8] = 2048;
              v114 = 1;
              *(_WORD *)v115 = 2048;
              *(_QWORD *)&v115[2] = v80;
              v75 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_106;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v72 = v8[463];
            v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              v79 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136446978;
              v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
              v112 = 2082;
              *(_QWORD *)v113 = "frame_count";
              *(_WORD *)&v113[8] = 2048;
              v114 = 1;
              *(_WORD *)v115 = 2048;
              *(_QWORD *)&v115[2] = v79;
              v75 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_106;
            }
          }
        }
LABEL_107:
        if (v71)
          free(v71);
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
LABEL_110:
        v81 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
        if (*(_BYTE *)(a1 + 80))
        {
          *(_QWORD *)(a2 + 32) = 0;
          v82 = a2 + 32;
        }
        else
        {
          *(_QWORD *)(a2 + 16) = 0;
          v82 = a2 + 16;
        }
        v83 = *(uint64_t **)(v81 + 48);
        *(_QWORD *)(v82 + 8) = v83;
        *v83 = a2;
        *(_QWORD *)(v81 + 48) = v82;
        return 1;
      }
    }
    else
    {
      v65 = *(_QWORD *)(a2 + 16);
      v66 = *(_QWORD **)(a2 + 24);
      v64 = (_QWORD *)(a2 + 16);
      if (v65)
      {
        *(_QWORD *)(v65 + 24) = v66;
        v66 = *(_QWORD **)(a2 + 24);
LABEL_89:
        *v66 = v65;
        goto LABEL_90;
      }
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v66;
    goto LABEL_89;
  }
  if (*(_BYTE *)(a1 + 81))
  {
    v17 = v16 - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    if (*(_BYTE *)(a1 + 80))
    {
      v19 = *(_QWORD *)(a2 + 32);
      v20 = *(_QWORD **)(a2 + 40);
      v18 = (_QWORD *)(a2 + 32);
      if (v19)
      {
        *(_QWORD *)(v19 + 40) = v20;
        **(_QWORD **)(a2 + 40) = v19;
        goto LABEL_45;
      }
    }
    else
    {
      v19 = *(_QWORD *)(a2 + 16);
      v20 = *(_QWORD **)(a2 + 24);
      v18 = (_QWORD *)(a2 + 16);
      if (v19)
      {
        *(_QWORD *)(v19 + 24) = v20;
        v20 = *(_QWORD **)(a2 + 24);
LABEL_44:
        *v20 = v19;
LABEL_45:
        *v18 = 0;
        v18[1] = 0;
        *(_QWORD *)type = a2;
        v35 = nw_frame_split((uint64_t *)type, v17);
        if (v35)
        {
          v36 = v35;
          v37 = *(uint64_t **)(a1 + 64);
          v38 = *(_QWORD *)type;
          v39 = v37 + 1;
          v40 = *v37;
          if (*(_BYTE *)(a1 + 80))
          {
            *(_QWORD *)(*(_QWORD *)type + 32) = v40;
            v41 = v38 + 32;
            v42 = (_QWORD *)(v40 + 40);
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)type + 16) = v40;
            v41 = v38 + 16;
            v42 = (_QWORD *)(v40 + 24);
          }
          if (v40)
            v39 = v42;
          *v39 = v41;
          *v37 = v38;
          *(_QWORD *)(v41 + 8) = v37;
          v48 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
          v49 = *(_DWORD *)(v48 + 24);
          *(_DWORD *)(v48 + 24) = v49 + v17;
          if (!__CFADD__(v49, (_DWORD)v17))
          {
LABEL_130:
            if (gLogDatapath)
            {
              v104 = __nwlog_obj();
              if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
              {
                v105 = nw_frame_unclaimed_length(*(_DWORD **)type);
                v106 = *(_DWORD *)(v36 + 52);
                if (v106)
                  v106 -= *(_DWORD *)(v36 + 56) + *(_DWORD *)(v36 + 60);
                *(_DWORD *)buf = 136447234;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 1024;
                *(_DWORD *)v113 = v17;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v6;
                LOWORD(v114) = 1024;
                *(_DWORD *)((char *)&v114 + 2) = v105;
                HIWORD(v114) = 1024;
                *(_DWORD *)v115 = v106;
                _os_log_impl(&dword_182FBE000, v104, OS_LOG_TYPE_DEBUG, "%{public}s Moving split frame (%u bytes of %u, %u bytes remaining, delivering %u bytes)", buf, 0x24u);
              }
            }
            v86 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
            v87 = *(unsigned int *)(v86 + 24) + 1;
            v88 = v87 << 31 >> 31;
            *(_DWORD *)(v86 + 24) = v87;
            if (v88 == v87 && (v88 & 0x8000000000000000) == 0)
              goto LABEL_150;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v89 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136446978;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v112 = 2082;
            *(_QWORD *)v113 = "frame_count";
            *(_WORD *)&v113[8] = 2048;
            v114 = 1;
            *(_WORD *)v115 = 2048;
            *(_QWORD *)&v115[2] = v89;
            v90 = (char *)_os_log_send_and_compose_impl();
            v109 = OS_LOG_TYPE_ERROR;
            v107 = 0;
            if (__nwlog_fault(v90, &v109, &v107))
            {
              if (v109 == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v91 = v8[463];
                v92 = v109;
                if (os_log_type_enabled(v91, v109))
                {
                  v93 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136446978;
                  v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  v112 = 2082;
                  *(_QWORD *)v113 = "frame_count";
                  *(_WORD *)&v113[8] = 2048;
                  v114 = 1;
                  *(_WORD *)v115 = 2048;
                  *(_QWORD *)&v115[2] = v93;
                  v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_146:
                  _os_log_impl(&dword_182FBE000, v91, v92, v94, buf, 0x2Au);
                }
              }
              else if (v107)
              {
                v95 = (char *)__nw_create_backtrace_string();
                v91 = __nwlog_obj();
                v92 = v109;
                v96 = os_log_type_enabled(v91, v109);
                if (v95)
                {
                  if (v96)
                  {
                    v97 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                    *(_DWORD *)buf = 136447234;
                    v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                    v112 = 2082;
                    *(_QWORD *)v113 = "frame_count";
                    *(_WORD *)&v113[8] = 2048;
                    v114 = 1;
                    *(_WORD *)v115 = 2048;
                    *(_QWORD *)&v115[2] = v97;
                    v116 = 2082;
                    v117 = v95;
                    _os_log_impl(&dword_182FBE000, v91, v92, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v95);
                  goto LABEL_147;
                }
                if (v96)
                {
                  v99 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136446978;
                  v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  v112 = 2082;
                  *(_QWORD *)v113 = "frame_count";
                  *(_WORD *)&v113[8] = 2048;
                  v114 = 1;
                  *(_WORD *)v115 = 2048;
                  *(_QWORD *)&v115[2] = v99;
                  v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                  goto LABEL_146;
                }
              }
              else
              {
                v91 = __nwlog_obj();
                v92 = v109;
                if (os_log_type_enabled(v91, v109))
                {
                  v98 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136446978;
                  v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  v112 = 2082;
                  *(_QWORD *)v113 = "frame_count";
                  *(_WORD *)&v113[8] = 2048;
                  v114 = 1;
                  *(_WORD *)v115 = 2048;
                  *(_QWORD *)&v115[2] = v98;
                  v94 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_146;
                }
              }
            }
LABEL_147:
            if (v90)
              free(v90);
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
LABEL_150:
            v100 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
            if (*(_BYTE *)(a1 + 80))
            {
              *(_QWORD *)(v36 + 32) = 0;
              v101 = v36 + 32;
            }
            else
            {
              *(_QWORD *)(v36 + 16) = 0;
              v101 = v36 + 16;
            }
            v102 = *(uint64_t **)(v100 + 48);
            *(_QWORD *)(v101 + 8) = v102;
            *v102 = v36;
            *(_QWORD *)(v100 + 48) = v101;
            return 0;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v50 = v8;
          v51 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2082;
          *(_QWORD *)v113 = "bytes_count";
          *(_WORD *)&v113[8] = 2048;
          v114 = v17;
          *(_WORD *)v115 = 2048;
          *(_QWORD *)&v115[2] = v51;
          v52 = (char *)_os_log_send_and_compose_impl();
          v109 = OS_LOG_TYPE_ERROR;
          v107 = 0;
          if (__nwlog_fault(v52, &v109, &v107))
          {
            if (v109 == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v53 = v8[463];
              v54 = v109;
              if (os_log_type_enabled(v50[463], v109))
              {
                v55 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(_QWORD *)v113 = "bytes_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = v17;
                *(_WORD *)v115 = 2048;
                *(_QWORD *)&v115[2] = v55;
                v56 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_126:
                _os_log_impl(&dword_182FBE000, v53, v54, v56, buf, 0x2Au);
              }
            }
            else if (v107)
            {
              v59 = (char *)__nw_create_backtrace_string();
              v53 = __nwlog_obj();
              v54 = v109;
              v60 = os_log_type_enabled(v53, v109);
              if (v59)
              {
                if (v60)
                {
                  v61 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
                  *(_DWORD *)buf = 136447234;
                  v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                  v112 = 2082;
                  *(_QWORD *)v113 = "bytes_count";
                  *(_WORD *)&v113[8] = 2048;
                  v114 = v17;
                  *(_WORD *)v115 = 2048;
                  *(_QWORD *)&v115[2] = v61;
                  v116 = 2082;
                  v117 = v59;
                  _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v59);
                goto LABEL_127;
              }
              if (v60)
              {
                v85 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(_QWORD *)v113 = "bytes_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = v17;
                *(_WORD *)v115 = 2048;
                *(_QWORD *)&v115[2] = v85;
                v56 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_126;
              }
            }
            else
            {
              v53 = __nwlog_obj();
              v54 = v109;
              if (os_log_type_enabled(v53, v109))
              {
                v84 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
                v112 = 2082;
                *(_QWORD *)v113 = "bytes_count";
                *(_WORD *)&v113[8] = 2048;
                v114 = v17;
                *(_WORD *)v115 = 2048;
                *(_QWORD *)&v115[2] = v84;
                v56 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_126;
              }
            }
          }
LABEL_127:
          if (v52)
            free(v52);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = -1;
          v8 = v50;
          goto LABEL_130;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v43 = v8[463];
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
          v112 = 2048;
          *(_QWORD *)v113 = a2;
          *(_WORD *)&v113[8] = 1024;
          LODWORD(v114) = v17;
          _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s failed to split frame %p at offset %u", buf, 0x1Cu);
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
        v44 = (char *)_os_log_send_and_compose_impl();
        v109 = OS_LOG_TYPE_ERROR;
        v107 = 0;
        if (__nwlog_fault(v44, &v109, &v107))
        {
          if (v109 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v45 = v8[463];
            v46 = v109;
            if (!os_log_type_enabled(v45, v109))
              goto LABEL_122;
            *(_DWORD *)buf = 136446210;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v47 = "%{public}s nw_frame_split with partial frame failed";
            goto LABEL_121;
          }
          if (!v107)
          {
            v45 = __nwlog_obj();
            v46 = v109;
            if (!os_log_type_enabled(v45, v109))
              goto LABEL_122;
            *(_DWORD *)buf = 136446210;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v47 = "%{public}s nw_frame_split with partial frame failed, backtrace limit exceeded";
            goto LABEL_121;
          }
          v57 = (char *)__nw_create_backtrace_string();
          v45 = __nwlog_obj();
          v46 = v109;
          v58 = os_log_type_enabled(v45, v109);
          if (v57)
          {
            if (v58)
            {
              *(_DWORD *)buf = 136446466;
              v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
              v112 = 2082;
              *(_QWORD *)v113 = v57;
              _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s nw_frame_split with partial frame failed, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v57);
            goto LABEL_122;
          }
          if (v58)
          {
            *(_DWORD *)buf = 136446210;
            v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
            v47 = "%{public}s nw_frame_split with partial frame failed, no backtrace";
LABEL_121:
            _os_log_impl(&dword_182FBE000, v45, v46, v47, buf, 0xCu);
          }
        }
LABEL_122:
        if (v44)
          free(v44);
        return 0;
      }
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v20;
    goto LABEL_44;
  }
  if (!gLogDatapath)
    return 0;
  v29 = __nwlog_obj();
  result = os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    *(_DWORD *)buf = 136446210;
    v111 = "__nw_protocol_fulfill_frame_request_block_invoke";
    _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s skipping partial frame, split frames not allowed", buf, 0xCu);
    return 0;
  }
  return result;
}

uint64_t ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke_25(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;

  if (!a2)
    return 1;
  if (!*(_BYTE *)(a1 + 48))
  {
    v3 = a2[2];
    v4 = (_QWORD *)a2[3];
    v2 = a2 + 2;
    if (v3)
    {
      *(_QWORD *)(v3 + 24) = v4;
      v4 = (_QWORD *)a2[3];
LABEL_8:
      *v4 = v3;
      goto LABEL_9;
    }
LABEL_7:
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48) = v4;
    goto LABEL_8;
  }
  v3 = a2[4];
  v4 = (_QWORD *)a2[5];
  v2 = a2 + 4;
  if (!v3)
    goto LABEL_7;
  *(_QWORD *)(v3 + 40) = v4;
  *(_QWORD *)a2[5] = v3;
LABEL_9:
  *v2 = 0;
  v2[1] = 0;
  v5 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(a1 + 48))
  {
    a2[4] = 0;
    v6 = a2 + 4;
  }
  else
  {
    a2[2] = 0;
    v6 = a2 + 2;
  }
  v7 = *(_QWORD **)(v5 + 8);
  v6[1] = v7;
  *v7 = a2;
  *(_QWORD *)(v5 + 8) = v6;
  return 1;
}

void nw_protocol_plugin_metadata_get_and_process_frames(uint64_t a1, _QWORD *a2, uint64_t a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, unsigned int *a8, _DWORD *a9, uint64_t a10, uint64_t *a11)
{
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t);
  _QWORD *v23;
  int v24;
  uint64_t v25;
  _DWORD *v26;
  BOOL v27;
  _DWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;
  const char *v33;
  BOOL v34;
  uint64_t v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint64_t v39;
  const char *v40;
  _QWORD *v41;
  NSObject *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  void (**v46)(_QWORD);
  const void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (**v53)(_QWORD);
  const void *v54;
  char *v55;
  _BOOL4 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  NSObject *v63;
  int v64;
  unsigned int v65;
  uint64_t v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  const char *v71;
  const char *v72;
  NSObject *v73;
  os_log_type_t v74;
  const char *v75;
  const char *v76;
  char *backtrace_string;
  _BOOL4 v78;
  char *v79;
  _BOOL4 v80;
  const char *v81;
  _QWORD *v82;
  _DWORD *v83;
  NSObject *v84;
  _BOOL4 v85;
  int v86;
  int v87;
  int v88;
  _DWORD *v89;
  _QWORD *v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  const char *v94;
  _BOOL4 v95;
  char *v96;
  _BOOL4 v97;
  const char *v98;
  uint64_t v99;
  NSObject *v100;
  char *v101;
  _BOOL4 v102;
  NSObject *v103;
  const char *v104;
  NSObject *v105;
  os_log_type_t v106;
  const char *v107;
  os_log_type_t v108;
  os_log_t log;
  NSObject *loga;
  void *v111;
  char *v112;
  _DWORD *v114;
  _DWORD *v115;
  unsigned int *v116;
  uint64_t v117;
  uint64_t *v118;
  char v119;
  os_log_type_t type[8];
  os_log_type_t *v121;
  uint64_t v122;
  int v123;
  _BYTE buf[24];
  const char *v125;
  _BYTE v126[24];
  _DWORD *v127;
  uint64_t *v128;
  uint64_t *v129;
  _DWORD *v130;
  _DWORD *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  char v135;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
    v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v117) = 0;
    if (!__nwlog_fault(v67, type, &v117))
      goto LABEL_163;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
        goto LABEL_163;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      v70 = "%{public}s called with null input_protocol";
    }
    else if ((_BYTE)v117)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v68 = __nwlog_obj();
      v69 = type[0];
      v78 = os_log_type_enabled(v68, type[0]);
      if (backtrace_string)
      {
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_163:
        if (!v67)
          return;
        goto LABEL_164;
      }
      if (!v78)
        goto LABEL_163;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      v70 = "%{public}s called with null input_protocol, no backtrace";
    }
    else
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
        goto LABEL_163;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      v70 = "%{public}s called with null input_protocol, backtrace limit exceeded";
    }
    goto LABEL_162;
  }
  if (!a10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
    v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v117) = 0;
    if (!__nwlog_fault(v67, type, &v117))
      goto LABEL_163;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v117)
      {
        v68 = __nwlog_obj();
        v69 = type[0];
        if (!os_log_type_enabled(v68, type[0]))
          goto LABEL_163;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
        v70 = "%{public}s called with null processor, backtrace limit exceeded";
        goto LABEL_162;
      }
      v79 = (char *)__nw_create_backtrace_string();
      v68 = __nwlog_obj();
      v69 = type[0];
      v80 = os_log_type_enabled(v68, type[0]);
      if (!v79)
      {
        if (!v80)
          goto LABEL_163;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
        v70 = "%{public}s called with null processor, no backtrace";
        goto LABEL_162;
      }
      if (v80)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v79;
        v81 = "%{public}s called with null processor, dumping backtrace:%{public}s";
LABEL_122:
        _os_log_impl(&dword_182FBE000, v68, v69, v81, buf, 0x16u);
      }
LABEL_123:
      free(v79);
      if (!v67)
        return;
LABEL_164:
      free(v67);
      return;
    }
    v68 = __nwlog_obj();
    v69 = type[0];
    if (!os_log_type_enabled(v68, type[0]))
      goto LABEL_163;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
    v70 = "%{public}s called with null processor";
LABEL_162:
    _os_log_impl(&dword_182FBE000, v68, v69, v70, buf, 0xCu);
    goto LABEL_163;
  }
  if (!a11)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
    v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v117) = 0;
    if (!__nwlog_fault(v67, type, &v117))
      goto LABEL_163;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
        goto LABEL_163;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      v70 = "%{public}s called with null destination_array";
      goto LABEL_162;
    }
    if (!(_BYTE)v117)
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
        goto LABEL_163;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      v70 = "%{public}s called with null destination_array, backtrace limit exceeded";
      goto LABEL_162;
    }
    v79 = (char *)__nw_create_backtrace_string();
    v68 = __nwlog_obj();
    v69 = type[0];
    v95 = os_log_type_enabled(v68, type[0]);
    if (!v79)
    {
      if (!v95)
        goto LABEL_163;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      v70 = "%{public}s called with null destination_array, no backtrace";
      goto LABEL_162;
    }
    if (v95)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v79;
      v81 = "%{public}s called with null destination_array, dumping backtrace:%{public}s";
      goto LABEL_122;
    }
    goto LABEL_123;
  }
  if ((*(_BYTE *)(a1 + 142) & 0x10) == 0)
  {
    if (*(_BYTE *)(a1 + 140) == 3)
    {
      *a5 = 0;
      *a6 = -1;
      *a7 = -1;
    }
    if (gLogDatapath)
    {
      v82 = a2;
      v83 = a7;
      v84 = __nwlog_obj();
      v85 = os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG);
      a7 = v83;
      a2 = v82;
      if (v85)
      {
        v86 = *a5;
        v87 = *a6;
        v88 = *v83;
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v86;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v87;
        LOWORD(v125) = 1024;
        *(_DWORD *)((char *)&v125 + 2) = v88;
        _os_log_impl(&dword_182FBE000, v84, OS_LOG_TYPE_DEBUG, "%{public}s Getting new frames from below with minimum_bytes %u, maximum_bytes %u, maximum_frame_count %u", buf, 0x1Eu);
        a7 = v83;
        a2 = v82;
      }
    }
    v117 = 0;
    v118 = &v117;
    v16 = a2[4];
    if (v16)
    {
      v116 = a8;
      v115 = a5;
      v17 = *(void **)(v16 + 40);
      if (v17 == &nw_protocol_ref_counted_handle)
      {
        v18 = *(_QWORD *)(v16 + 88);
        if (v18)
          *(_QWORD *)(v16 + 88) = v18 + 1;
      }
      v19 = (void *)a2[5];
      if (v19 == &nw_protocol_ref_counted_handle)
      {
        v20 = a2[11];
        if (v20)
          a2[11] = v20 + 1;
      }
      v114 = a7;
      v21 = *(_QWORD *)(v16 + 24);
      if (v21)
      {
        v22 = *(uint64_t (**)(uint64_t))(v21 + 80);
        if (v22)
        {
          v23 = a2;
          v24 = v22(v16);
          goto LABEL_18;
        }
      }
      v23 = a2;
      __nwlog_obj();
      v71 = *(const char **)(v16 + 16);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
      if (!v71)
        v71 = "invalid";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v71;
      *(_WORD *)&buf[22] = 2048;
      v125 = (const char *)v16;
      v72 = (const char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v119 = 0;
      v112 = (char *)v72;
      if (__nwlog_fault(v72, type, &v119))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v73 = __nwlog_obj();
          v74 = type[0];
          log = v73;
          if (os_log_type_enabled(v73, type[0]))
          {
            v75 = *(const char **)(v16 + 16);
            if (!v75)
              v75 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v75;
            *(_WORD *)&buf[22] = 2048;
            v125 = (const char *)v16;
            v76 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_151:
            v105 = log;
            v106 = v74;
LABEL_152:
            _os_log_impl(&dword_182FBE000, v105, v106, v76, buf, 0x20u);
          }
        }
        else if (v119)
        {
          v96 = (char *)__nw_create_backtrace_string();
          loga = __nwlog_obj();
          v108 = type[0];
          v97 = os_log_type_enabled(loga, type[0]);
          if (v96)
          {
            if (v97)
            {
              v98 = *(const char **)(v16 + 16);
              if (!v98)
                v98 = "invalid";
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v98;
              *(_WORD *)&buf[22] = 2048;
              v125 = (const char *)v16;
              *(_WORD *)v126 = 2082;
              *(_QWORD *)&v126[2] = v96;
              _os_log_impl(&dword_182FBE000, loga, v108, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v96);
            goto LABEL_153;
          }
          if (v97)
          {
            v107 = *(const char **)(v16 + 16);
            if (!v107)
              v107 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v107;
            *(_WORD *)&buf[22] = 2048;
            v125 = (const char *)v16;
            v76 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            v105 = loga;
            v106 = v108;
            goto LABEL_152;
          }
        }
        else
        {
          v103 = __nwlog_obj();
          v74 = type[0];
          log = v103;
          if (os_log_type_enabled(v103, type[0]))
          {
            v104 = *(const char **)(v16 + 16);
            if (!v104)
              v104 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v104;
            *(_WORD *)&buf[22] = 2048;
            v125 = (const char *)v16;
            v76 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            goto LABEL_151;
          }
        }
      }
LABEL_153:
      if (v112)
        free(v112);
      v24 = 0;
LABEL_18:
      v25 = (uint64_t)v23;
      v26 = a9;
      if (v19 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v25 + 40) == &nw_protocol_ref_counted_handle)
      {
        v44 = *(_QWORD *)(v25 + 88);
        if (v44)
        {
          v45 = v44 - 1;
          *(_QWORD *)(v25 + 88) = v45;
          if (!v45)
          {
            v46 = *(void (***)(_QWORD))(v25 + 64);
            if (v46)
            {
              *(_QWORD *)(v25 + 64) = 0;
              v111 = (void *)v25;
              v46[2](v46);
              _Block_release(v46);
              v25 = (uint64_t)v111;
            }
            if ((*(_BYTE *)(v25 + 72) & 1) != 0)
            {
              v47 = *(const void **)(v25 + 64);
              if (v47)
              {
                v48 = v25;
                _Block_release(v47);
                v25 = v48;
              }
            }
            v49 = v25;
            free((void *)v25);
            v25 = v49;
          }
        }
      }
      v27 = v17 == &nw_protocol_ref_counted_handle;
      v28 = v115;
      if (v27 && *(_UNKNOWN **)(v16 + 40) == &nw_protocol_ref_counted_handle)
      {
        v50 = *(_QWORD *)(v16 + 88);
        if (v50)
        {
          v51 = v50 - 1;
          *(_QWORD *)(v16 + 88) = v51;
          if (!v51)
          {
            v52 = v25;
            v53 = *(void (***)(_QWORD))(v16 + 64);
            if (v53)
            {
              *(_QWORD *)(v16 + 64) = 0;
              v53[2](v53);
              _Block_release(v53);
            }
            if ((*(_BYTE *)(v16 + 72) & 1) != 0)
            {
              v54 = *(const void **)(v16 + 64);
              if (v54)
                _Block_release(v54);
            }
            free((void *)v16);
            v25 = v52;
          }
        }
      }
      a8 = v116;
      if (!v24 || *(_BYTE *)(a1 + 140) == 2)
        goto LABEL_69;
      *(_QWORD *)type = 0;
      v121 = type;
      v123 = 0;
      v122 = 0x2000000000;
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
      v125 = (const char *)&unk_1E149A880;
      *(_QWORD *)&v126[16] = a1;
      v127 = a6;
      v135 = 1;
      v128 = &v117;
      v129 = a11;
      v130 = v115;
      v131 = a9;
      v132 = v25;
      *(_QWORD *)v126 = type;
      *(_QWORD *)&v126[8] = v114;
      v29 = v25;
      v133 = a10;
      v134 = a3;
      v30 = v117;
      do
      {
        if (!v30)
          break;
        v31 = *(_QWORD *)(v30 + 32);
        v32 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v30 = v31;
      }
      while ((v32 & 1) != 0);
      v33 = (const char *)*((unsigned int *)v121 + 6);
      _Block_object_dispose(type, 8);
      v34 = __CFADD__(*v116, (_DWORD)v33);
      *v116 += v33;
      v25 = v29;
      if (!v34)
      {
LABEL_69:
        v60 = v117;
        if (!v117)
        {
LABEL_73:
          if (*a8 && *v28)
          {
            v62 = v25;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v63 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 0;
              nw_frame_array_get_frame_count(a11, 1, buf);
              v64 = *(_DWORD *)buf;
              v65 = *a8;
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = a4;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v64;
              LOWORD(v125) = 1024;
              *(_DWORD *)((char *)&v125 + 2) = v65;
              _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_DEBUG, "%{public}s could not fulfill minimum byte requirement of %u bytes (have %u bytes in %u frames), saving in input_frames_pending_delivery for later", buf, 0x1Eu);
            }
            v25 = v62;
            if (*a11)
            {
              **(_QWORD **)(a1 + 24) = *a11;
              *(_QWORD *)(*a11 + 40) = *(_QWORD *)(a1 + 24);
              *(_QWORD *)(a1 + 24) = a11[1];
            }
            v66 = 0;
            *a11 = 0;
            a11[1] = (uint64_t)a11;
            *a8 = 0;
            *v26 = 0;
          }
          else
          {
            v66 = *v26;
          }
          nw_protocol_plugin_metadata_report_transfer(a1, v25, *(_QWORD *)(a1 + 48), v66, 1);
          return;
        }
LABEL_70:
        if (!gLogDatapath)
          goto LABEL_71;
        v99 = v25;
        v100 = __nwlog_obj();
        if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
          _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s new_input_array is not empty after processing input frames, moving to saved_input_frames for later", buf, 0xCu);
        }
        v60 = v117;
        v25 = v99;
        if (v117)
        {
LABEL_71:
          **(_QWORD **)(a1 + 8) = v60;
          v61 = v118;
          *(_QWORD *)(v117 + 40) = *(_QWORD *)(a1 + 8);
          *(_QWORD *)(a1 + 8) = v61;
        }
        v117 = 0;
        v118 = &v117;
        goto LABEL_73;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = *v116;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = "count";
      *(_WORD *)&buf[22] = 2048;
      v125 = v33;
      *(_WORD *)v126 = 2048;
      *(_QWORD *)&v126[2] = v35;
      v36 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      a8 = v116;
      v119 = 0;
      if (__nwlog_fault(v36, type, &v119))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v37 = gLogObj;
          v38 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            v39 = *v116;
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v125 = v33;
            *(_WORD *)v126 = 2048;
            *(_QWORD *)&v126[2] = v39;
            v40 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_65:
            _os_log_impl(&dword_182FBE000, v37, v38, v40, buf, 0x2Au);
          }
        }
        else if (v119)
        {
          v55 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v37 = gLogObj;
          v38 = type[0];
          v56 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v55)
          {
            if (v56)
            {
              v57 = *v116;
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "count";
              *(_WORD *)&buf[22] = 2048;
              v125 = v33;
              *(_WORD *)v126 = 2048;
              *(_QWORD *)&v126[2] = v57;
              *(_WORD *)&v126[10] = 2082;
              *(_QWORD *)&v126[12] = v55;
              _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v55);
            goto LABEL_66;
          }
          if (v56)
          {
            v59 = *v116;
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v125 = v33;
            *(_WORD *)v126 = 2048;
            *(_QWORD *)&v126[2] = v59;
            v40 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_65;
          }
        }
        else
        {
          v37 = __nwlog_obj();
          v38 = type[0];
          if (os_log_type_enabled(v37, type[0]))
          {
            v58 = *v116;
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v125 = v33;
            *(_WORD *)v126 = 2048;
            *(_QWORD *)&v126[2] = v58;
            v40 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_65;
          }
        }
      }
LABEL_66:
      if (v36)
        free(v36);
      *v116 = -1;
      v25 = v29;
      v28 = v115;
      v26 = a9;
      goto LABEL_69;
    }
    v89 = a5;
    v90 = a2;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
    v91 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v119 = 0;
    if (__nwlog_fault(v91, type, &v119))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v92 = __nwlog_obj();
        v93 = type[0];
        if (!os_log_type_enabled(v92, type[0]))
          goto LABEL_174;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        v94 = "%{public}s called with null protocol";
LABEL_173:
        _os_log_impl(&dword_182FBE000, v92, v93, v94, buf, 0xCu);
        goto LABEL_174;
      }
      if (!v119)
      {
        v92 = __nwlog_obj();
        v93 = type[0];
        if (!os_log_type_enabled(v92, type[0]))
          goto LABEL_174;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        v94 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_173;
      }
      v101 = (char *)__nw_create_backtrace_string();
      v92 = __nwlog_obj();
      v93 = type[0];
      v102 = os_log_type_enabled(v92, type[0]);
      if (!v101)
      {
        if (!v102)
          goto LABEL_174;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        v94 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_173;
      }
      if (v102)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v101;
        _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v101);
    }
LABEL_174:
    if (v91)
      free(v91);
    v25 = (uint64_t)v90;
    v26 = a9;
    v28 = v89;
    v60 = v117;
    if (!v117)
      goto LABEL_73;
    goto LABEL_70;
  }
  if (gLogDatapath)
  {
    v41 = a2;
    v42 = __nwlog_obj();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      v43 = "invalid";
      if (v41 && v41[2])
        v43 = (const char *)v41[2];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_get_and_process_frames";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v41;
      *(_WORD *)&buf[22] = 2080;
      v125 = v43;
      _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_DEBUG, "%{public}s short circuiting because protocol %p:%s has already handled eof", buf, 0x20u);
    }
  }
}

uint64_t __nw_protocol_plugin_metadata_process_frames_block_invoke(uint64_t a1, _DWORD *a2)
{
  _DWORD *v3;
  void *v4;
  void *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  _BOOL8 v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  unsigned int v16;
  _DWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  char v22;
  void *v23;
  _DWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  unsigned int v28;
  _DWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  int is_metadata_complete;
  _DWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  char v38;
  void *v39;
  int v40;
  NSObject *v41;
  int v42;
  const char *v43;
  NSObject *v44;
  uint32_t v45;
  uint64_t v46;
  _DWORD *v47;
  _DWORD *v48;
  _QWORD *v49;
  unsigned int *v50;
  BOOL v51;
  unsigned int *v52;
  _DWORD *v53;
  _DWORD *v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  _DWORD *v59;
  const char *v60;
  uint64_t v61;
  uint64_t *v62;
  _DWORD *v63;
  uint64_t v64;
  _DWORD *v65;
  _DWORD *v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t *v69;
  _DWORD *v70;
  _DWORD *v72;
  char *v73;
  NSObject *v74;
  os_log_type_t v75;
  _DWORD *v76;
  const char *v77;
  _DWORD *v78;
  _QWORD *v79;
  uint64_t v80;
  _QWORD *v81;
  char *v82;
  _BOOL4 v83;
  char *v84;
  _BOOL4 v85;
  _DWORD *v86;
  void (*v87)(_QWORD);
  char *v88;
  _BOOL4 v89;
  _DWORD *v90;
  NSObject *v91;
  int v92;
  uint64_t v93;
  _DWORD *v94;
  _DWORD *v95;
  _QWORD *v96;
  unsigned int *v97;
  unsigned int *v98;
  _DWORD *v99;
  _DWORD *v101;
  char *v102;
  NSObject *v103;
  os_log_type_t v104;
  _DWORD *v105;
  const char *v106;
  _DWORD *v107;
  uint64_t v108;
  uint64_t *v109;
  _DWORD *v110;
  uint64_t v111;
  _DWORD *v112;
  _DWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  uint64_t *v116;
  _DWORD *v117;
  _DWORD *v119;
  char *v120;
  NSObject *v121;
  os_log_type_t v122;
  _DWORD *v123;
  const char *v124;
  _DWORD *v125;
  _DWORD *v126;
  uint64_t v127;
  _DWORD *v128;
  char *v129;
  NSObject *v130;
  os_log_type_t v131;
  _DWORD *v132;
  const char *v133;
  char *v134;
  _BOOL4 v135;
  _DWORD *v136;
  _DWORD *v137;
  _DWORD *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  _DWORD *v142;
  char *v143;
  NSObject *v144;
  os_log_type_t v145;
  _DWORD *v146;
  const char *v147;
  char *v148;
  _BOOL4 v149;
  _DWORD *v150;
  _DWORD *v151;
  _DWORD *v152;
  _DWORD *v153;
  char *v154;
  _BOOL4 v155;
  _DWORD *v156;
  _DWORD *v157;
  _DWORD *v158;
  int v159;
  uint64_t v160;
  _DWORD *v161;
  char *v162;
  NSObject *v163;
  os_log_type_t v164;
  uint64_t v165;
  _DWORD *v166;
  const char *v167;
  char *v168;
  _BOOL4 v169;
  uint64_t v170;
  _DWORD *v171;
  uint64_t v172;
  _DWORD *v173;
  uint64_t v174;
  _DWORD *v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  _DWORD *v179;
  char *v180;
  NSObject *v181;
  os_log_type_t v182;
  _DWORD *v183;
  const char *v184;
  char *v185;
  _BOOL4 v186;
  _DWORD *v187;
  _DWORD *v188;
  _DWORD *v189;
  char *v190;
  _BOOL4 v191;
  _DWORD *v192;
  _DWORD *v193;
  _DWORD *v194;
  _DWORD *v195;
  uint64_t v196;
  _DWORD *v197;
  char *v198;
  NSObject *v199;
  os_log_type_t v200;
  _DWORD *v201;
  const char *v202;
  char *v203;
  _BOOL4 v204;
  _DWORD *v205;
  _DWORD *v206;
  _DWORD *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  _DWORD *v211;
  char *v212;
  NSObject *v213;
  os_log_type_t v214;
  _DWORD *v215;
  const char *v216;
  char *v217;
  _BOOL4 v218;
  _DWORD *v219;
  _DWORD *v220;
  _DWORD *v221;
  _DWORD *v223;
  _DWORD *v224;
  _DWORD *v225;
  int v226;
  uint64_t v227;
  _DWORD *v228;
  char *v229;
  NSObject *v230;
  os_log_type_t v231;
  uint64_t v232;
  _DWORD *v233;
  const char *v234;
  char *v235;
  _BOOL4 v236;
  uint64_t v237;
  _DWORD *v238;
  uint64_t v239;
  _DWORD *v240;
  uint64_t v241;
  _DWORD *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  _DWORD *v246;
  char *v247;
  NSObject *v248;
  os_log_type_t v249;
  _DWORD *v250;
  const char *v251;
  char *v252;
  _BOOL4 v253;
  _DWORD *v254;
  _DWORD *v255;
  _DWORD *v256;
  char *v257;
  NSObject *v258;
  os_log_type_t v259;
  const char *v260;
  NSObject *v261;
  char *backtrace_string;
  _BOOL4 v263;
  NSObject *v264;
  NSObject *v265;
  uint64_t v266;
  const char *v267;
  const char *v268;
  const char *v269;
  NSObject *v270;
  _BOOL4 v271;
  const char *v272;
  NSObject *v273;
  NSObject *v274;
  int v275;
  NSObject *v276;
  _DWORD *v277;
  NSObject *v278;
  _DWORD *v279;
  NSObject *v280;
  NSObject *v281;
  NSObject *v282;
  int v283;
  NSObject *v284;
  _DWORD *v285;
  NSObject *v286;
  _DWORD *v287;
  char v288;
  os_log_type_t type;
  _DWORD *v290;
  _BYTE buf[24];
  uint64_t v292;
  __int16 v293;
  _DWORD *v294;
  __int16 v295;
  char *v296;
  uint64_t v297;

  v297 = *MEMORY[0x1E0C80C00];
  v290 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    v257 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v288 = 0;
    if (!__nwlog_fault(v257, &type, &v288))
      goto LABEL_364;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v258 = __nwlog_obj();
      v259 = type;
      if (!os_log_type_enabled(v258, type))
        goto LABEL_364;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v260 = "%{public}s called with null frame";
    }
    else if (v288)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v258 = __nwlog_obj();
      v259 = type;
      v263 = os_log_type_enabled(v258, type);
      if (backtrace_string)
      {
        if (v263)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v258, v259, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_364;
      }
      if (!v263)
      {
LABEL_364:
        if (v257)
          free(v257);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v260 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v258 = __nwlog_obj();
      v259 = type;
      if (!os_log_type_enabled(v258, type))
        goto LABEL_364;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v260 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v258, v259, v260, buf, 0xCu);
    goto LABEL_364;
  }
  if (!**(_DWORD **)(a1 + 40))
  {
    if (!gLogDatapath)
      return 0;
    v264 = __nwlog_obj();
    if (!os_log_type_enabled(v264, OS_LOG_TYPE_DEBUG))
      return 0;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    v43 = "%{public}s stopping after reaching maximum frame count";
    v44 = v264;
    v45 = 12;
    goto LABEL_344;
  }
  v3 = a2;
  if (gLogDatapath)
  {
    v261 = __nwlog_obj();
    if (os_log_type_enabled(v261, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v3;
      _os_log_impl(&dword_182FBE000, v261, OS_LOG_TYPE_DEBUG, "%{public}s processing frame %p", buf, 0x16u);
      v3 = v290;
    }
  }
  v4 = nw_frame_copy_metadata_for_protocol((uint64_t)v3, *(_QWORD *)(*(_QWORD *)(a1 + 48) + 80));
  if (v4)
  {
    v5 = v4;
    v6 = *(unsigned __int8 *)(a1 + 120);
    v7 = *(_QWORD *)(a1 + 48);
    v8 = 48;
    if (!*(_BYTE *)(a1 + 120))
      v8 = 64;
    if (*(void **)(v7 + v8) == v4 || (*(_BYTE *)(v7 + 142) & 1) == 0)
    {
      v9 = v6 == 0;
      v10 = 140;
      if (v9)
        v10 = 141;
      v11 = 0;
      switch(*(_BYTE *)(v7 + v10))
      {
        case 0:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v12 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v288 = 0;
          if (!__nwlog_fault(v12, &type, &v288))
            goto LABEL_128;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v13 = gLogObj;
            v14 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type))
              goto LABEL_128;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            v15 = "%{public}s current metadata processor result must not be unknown";
LABEL_127:
            _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
            goto LABEL_128;
          }
          if (!v288)
          {
            v13 = __nwlog_obj();
            v14 = type;
            if (!os_log_type_enabled(v13, type))
              goto LABEL_128;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            v15 = "%{public}s current metadata processor result must not be unknown, backtrace limit exceeded";
            goto LABEL_127;
          }
          v82 = (char *)__nw_create_backtrace_string();
          v13 = __nwlog_obj();
          v14 = type;
          v83 = os_log_type_enabled(v13, type);
          if (!v82)
          {
            if (!v83)
              goto LABEL_128;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            v15 = "%{public}s current metadata processor result must not be unknown, no backtrace";
            goto LABEL_127;
          }
          if (v83)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v82;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s current metadata processor result must not be unknown, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v82);
LABEL_128:
          if (v12)
            free(v12);
LABEL_281:
          v11 = 1;
          break;
        case 1:
          v28 = nw_frame_unclaimed_length(v290);
          if (v28 > **(_DWORD **)(a1 + 56))
          {
            if (!*(_BYTE *)(a1 + 120))
            {
              if (gLogDatapath)
              {
                v91 = __nwlog_obj();
                if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
                {
                  v92 = **(_DWORD **)(a1 + 56);
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v28;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v92;
                  _os_log_impl(&dword_182FBE000, v91, OS_LOG_TYPE_DEBUG, "%{public}s not delivering frame with length %u maximum bytes %u", buf, 0x18u);
                }
              }
              goto LABEL_313;
            }
            if (gLogDatapath)
            {
              v282 = __nwlog_obj();
              if (os_log_type_enabled(v282, OS_LOG_TYPE_DEBUG))
              {
                v283 = **(_DWORD **)(a1 + 56);
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v290;
                *(_WORD *)&buf[22] = 1024;
                LODWORD(v292) = v283;
                _os_log_impl(&dword_182FBE000, v282, OS_LOG_TYPE_DEBUG, "%{public}s splitting frame %p that is part of handled message by offset %d", buf, 0x1Cu);
              }
            }
            v29 = v290;
            v30 = v290 + 8;
            v31 = *((_QWORD *)v290 + 4);
            v32 = (_QWORD *)*((_QWORD *)v290 + 5);
            if (v31)
            {
              *(_QWORD *)(v31 + 40) = v32;
              v32 = (_QWORD *)*((_QWORD *)v29 + 5);
            }
            else
            {
              *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v32;
            }
            *v32 = v31;
            *v30 = 0;
            v30[1] = 0;
            v108 = nw_frame_split((uint64_t *)&v290, **(_DWORD **)(a1 + 56));
            v109 = *(uint64_t **)(a1 + 64);
            v110 = v290;
            v111 = *v109;
            v112 = v290;
            *((_QWORD *)v290 + 4) = *v109;
            v113 = v112 + 8;
            if (v111)
              v114 = (_QWORD *)(v111 + 40);
            else
              v114 = v109 + 1;
            *v114 = v113;
            *v109 = (uint64_t)v110;
            *((_QWORD *)v110 + 5) = v109;
            v115 = *(_QWORD *)(a1 + 72);
            *(_QWORD *)(v108 + 32) = 0;
            v116 = *(uint64_t **)(v115 + 8);
            *(_QWORD *)(v108 + 40) = v116;
            *v116 = v108;
            *(_QWORD *)(v115 + 8) = v108 + 32;
            **(_DWORD **)(a1 + 80) = 0;
            **(_DWORD **)(a1 + 56) = 0;
            v117 = *(_DWORD **)(a1 + 40);
            if ((*v117)--)
            {
LABEL_292:
              v225 = *(_DWORD **)(a1 + 88);
              v226 = **(_DWORD **)(a1 + 56);
              v51 = __CFADD__(*v225, v226);
              *v225 += v226;
              if (!v51)
                goto LABEL_311;
              __nwlog_obj();
              v227 = **(unsigned int **)(a1 + 56);
              v228 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "moved_bytes";
              *(_WORD *)&buf[22] = 2048;
              v292 = v227;
              v293 = 2048;
              v294 = v228;
              v229 = (char *)_os_log_send_and_compose_impl();
              type = OS_LOG_TYPE_ERROR;
              v288 = 0;
              if (__nwlog_fault(v229, &type, &v288))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  v230 = __nwlog_obj();
                  v231 = type;
                  if (os_log_type_enabled(v230, type))
                  {
                    v232 = **(unsigned int **)(a1 + 56);
                    v233 = (_DWORD *)**(unsigned int **)(a1 + 88);
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "moved_bytes";
                    *(_WORD *)&buf[22] = 2048;
                    v292 = v232;
                    v293 = 2048;
                    v294 = v233;
                    v234 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_307:
                    _os_log_impl(&dword_182FBE000, v230, v231, v234, buf, 0x2Au);
                  }
                }
                else if (v288)
                {
                  v235 = (char *)__nw_create_backtrace_string();
                  v230 = __nwlog_obj();
                  v231 = type;
                  v236 = os_log_type_enabled(v230, type);
                  if (v235)
                  {
                    if (v236)
                    {
                      v237 = **(unsigned int **)(a1 + 56);
                      v238 = (_DWORD *)**(unsigned int **)(a1 + 88);
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = "moved_bytes";
                      *(_WORD *)&buf[22] = 2048;
                      v292 = v237;
                      v293 = 2048;
                      v294 = v238;
                      v295 = 2082;
                      v296 = v235;
                      _os_log_impl(&dword_182FBE000, v230, v231, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                    }
                    free(v235);
                    goto LABEL_308;
                  }
                  if (v236)
                  {
                    v241 = **(unsigned int **)(a1 + 56);
                    v242 = (_DWORD *)**(unsigned int **)(a1 + 88);
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "moved_bytes";
                    *(_WORD *)&buf[22] = 2048;
                    v292 = v241;
                    v293 = 2048;
                    v294 = v242;
                    v234 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                    goto LABEL_307;
                  }
                }
                else
                {
                  v230 = __nwlog_obj();
                  v231 = type;
                  if (os_log_type_enabled(v230, type))
                  {
                    v239 = **(unsigned int **)(a1 + 56);
                    v240 = (_DWORD *)**(unsigned int **)(a1 + 88);
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "moved_bytes";
                    *(_WORD *)&buf[22] = 2048;
                    v292 = v239;
                    v293 = 2048;
                    v294 = v240;
                    v234 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                    goto LABEL_307;
                  }
                }
              }
LABEL_308:
              if (v229)
                free(v229);
              **(_DWORD **)(a1 + 88) = -1;
LABEL_311:
              v243 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
              v244 = *(unsigned int *)(v243 + 24) + 1;
              v245 = v244 << 31 >> 31;
              *(_DWORD *)(v243 + 24) = v244;
              if (v245 == v244 && (v245 & 0x8000000000000000) == 0)
              {
LABEL_313:
                v11 = 0;
                break;
              }
              __nwlog_obj();
              v246 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "count";
              *(_WORD *)&buf[22] = 2048;
              v292 = 1;
              v293 = 2048;
              v294 = v246;
              v247 = (char *)_os_log_send_and_compose_impl();
              type = OS_LOG_TYPE_ERROR;
              v288 = 0;
              if (!__nwlog_fault(v247, &type, &v288))
                goto LABEL_328;
              if (type == OS_LOG_TYPE_FAULT)
              {
                v248 = __nwlog_obj();
                v249 = type;
                if (os_log_type_enabled(v248, type))
                {
                  v250 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "count";
                  *(_WORD *)&buf[22] = 2048;
                  v292 = 1;
                  v293 = 2048;
                  v294 = v250;
                  v251 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_327:
                  _os_log_impl(&dword_182FBE000, v248, v249, v251, buf, 0x2Au);
                }
              }
              else if (v288)
              {
                v252 = (char *)__nw_create_backtrace_string();
                v248 = __nwlog_obj();
                v249 = type;
                v253 = os_log_type_enabled(v248, type);
                if (v252)
                {
                  if (v253)
                  {
                    v254 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "count";
                    *(_WORD *)&buf[22] = 2048;
                    v292 = 1;
                    v293 = 2048;
                    v294 = v254;
                    v295 = 2082;
                    v296 = v252;
                    _os_log_impl(&dword_182FBE000, v248, v249, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v252);
                  goto LABEL_328;
                }
                if (v253)
                {
                  v256 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "count";
                  *(_WORD *)&buf[22] = 2048;
                  v292 = 1;
                  v293 = 2048;
                  v294 = v256;
                  v251 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                  goto LABEL_327;
                }
              }
              else
              {
                v248 = __nwlog_obj();
                v249 = type;
                if (os_log_type_enabled(v248, type))
                {
                  v255 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "count";
                  *(_WORD *)&buf[22] = 2048;
                  v292 = 1;
                  v293 = 2048;
                  v294 = v255;
                  v251 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_327;
                }
              }
LABEL_328:
              if (v247)
                free(v247);
              v11 = 0;
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
              break;
            }
            __nwlog_obj();
            v119 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v119;
            v120 = (char *)_os_log_send_and_compose_impl();
            type = OS_LOG_TYPE_ERROR;
            v288 = 0;
            if (__nwlog_fault(v120, &type, &v288))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                v121 = __nwlog_obj();
                v122 = type;
                if (os_log_type_enabled(v121, type))
                {
                  v123 = (_DWORD *)**(unsigned int **)(a1 + 40);
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "maximum_frame_count";
                  *(_WORD *)&buf[22] = 2048;
                  v292 = 1;
                  v293 = 2048;
                  v294 = v123;
                  v124 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_288:
                  _os_log_impl(&dword_182FBE000, v121, v122, v124, buf, 0x2Au);
                }
              }
              else if (v288)
              {
                v190 = (char *)__nw_create_backtrace_string();
                v121 = __nwlog_obj();
                v122 = type;
                v191 = os_log_type_enabled(v121, type);
                if (v190)
                {
                  if (v191)
                  {
                    v192 = (_DWORD *)**(unsigned int **)(a1 + 40);
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = "maximum_frame_count";
                    *(_WORD *)&buf[22] = 2048;
                    v292 = 1;
                    v293 = 2048;
                    v294 = v192;
                    v295 = 2082;
                    v296 = v190;
                    _os_log_impl(&dword_182FBE000, v121, v122, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v190);
                  goto LABEL_289;
                }
                if (v191)
                {
                  v224 = (_DWORD *)**(unsigned int **)(a1 + 40);
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "maximum_frame_count";
                  *(_WORD *)&buf[22] = 2048;
                  v292 = 1;
                  v293 = 2048;
                  v294 = v224;
                  v124 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                  goto LABEL_288;
                }
              }
              else
              {
                v121 = __nwlog_obj();
                v122 = type;
                if (os_log_type_enabled(v121, type))
                {
                  v223 = (_DWORD *)**(unsigned int **)(a1 + 40);
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "maximum_frame_count";
                  *(_WORD *)&buf[22] = 2048;
                  v292 = 1;
                  v293 = 2048;
                  v294 = v223;
                  v124 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_288;
                }
              }
            }
LABEL_289:
            if (v120)
              free(v120);
            **(_DWORD **)(a1 + 40) = 0;
            goto LABEL_292;
          }
          if (gLogDatapath)
          {
            v281 = __nwlog_obj();
            if (os_log_type_enabled(v281, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v290;
              _os_log_impl(&dword_182FBE000, v281, OS_LOG_TYPE_DEBUG, "%{public}s delivering frame %p that is part of handled message", buf, 0x16u);
            }
          }
          v78 = v290;
          v79 = v290 + 8;
          v80 = *((_QWORD *)v290 + 4);
          v81 = (_QWORD *)*((_QWORD *)v290 + 5);
          if (v80)
          {
            *(_QWORD *)(v80 + 40) = v81;
            v81 = (_QWORD *)*((_QWORD *)v78 + 5);
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v81;
          }
          *v81 = v80;
          *v79 = 0;
          v79[1] = 0;
          v93 = *(_QWORD *)(a1 + 72);
          v94 = v290;
          v95 = v290;
          *((_QWORD *)v290 + 4) = 0;
          v96 = *(_QWORD **)(v93 + 8);
          *((_QWORD *)v94 + 5) = v96;
          *v96 = v94;
          *(_QWORD *)(v93 + 8) = v95 + 8;
          v97 = *(unsigned int **)(a1 + 80);
          v51 = *v97 >= v28;
          *v97 -= v28;
          if (!v51)
          {
            if (gLogDatapath)
            {
              v284 = __nwlog_obj();
              if (os_log_type_enabled(v284, OS_LOG_TYPE_DEBUG))
              {
                v285 = (_DWORD *)**(unsigned int **)(a1 + 80);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "minimum_bytes";
                *(_WORD *)&buf[22] = 2048;
                v292 = v28;
                v293 = 2048;
                v294 = v285;
                _os_log_impl(&dword_182FBE000, v284, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
              }
            }
            **(_DWORD **)(a1 + 80) = 0;
          }
          v98 = *(unsigned int **)(a1 + 56);
          v51 = *v98 >= v28;
          *v98 -= v28;
          if (!v51)
          {
            if (gLogDatapath)
            {
              v286 = __nwlog_obj();
              if (os_log_type_enabled(v286, OS_LOG_TYPE_DEBUG))
              {
                v287 = (_DWORD *)**(unsigned int **)(a1 + 56);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "maximum_bytes";
                *(_WORD *)&buf[22] = 2048;
                v292 = v28;
                v293 = 2048;
                v294 = v287;
                _os_log_impl(&dword_182FBE000, v286, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
              }
            }
            **(_DWORD **)(a1 + 56) = 0;
          }
          v99 = *(_DWORD **)(a1 + 40);
          if ((*v99)--)
            goto LABEL_241;
          __nwlog_obj();
          v101 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v101;
          v102 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v288 = 0;
          if (!__nwlog_fault(v102, &type, &v288))
            goto LABEL_238;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v103 = __nwlog_obj();
            v104 = type;
            if (!os_log_type_enabled(v103, type))
              goto LABEL_238;
            v105 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v105;
            v106 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_237:
            _os_log_impl(&dword_182FBE000, v103, v104, v106, buf, 0x2Au);
            goto LABEL_238;
          }
          if (!v288)
          {
            v103 = __nwlog_obj();
            v104 = type;
            if (!os_log_type_enabled(v103, type))
              goto LABEL_238;
            v193 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v193;
            v106 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_237;
          }
          v154 = (char *)__nw_create_backtrace_string();
          v103 = __nwlog_obj();
          v104 = type;
          v155 = os_log_type_enabled(v103, type);
          if (!v154)
          {
            if (!v155)
              goto LABEL_238;
            v194 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v194;
            v106 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_237;
          }
          if (v155)
          {
            v156 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v156;
            v295 = 2082;
            v296 = v154;
            _os_log_impl(&dword_182FBE000, v103, v104, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v154);
LABEL_238:
          if (v102)
            free(v102);
          **(_DWORD **)(a1 + 40) = 0;
LABEL_241:
          v195 = *(_DWORD **)(a1 + 88);
          v51 = __CFADD__(*v195, v28);
          *v195 += v28;
          if (!v51)
            goto LABEL_260;
          __nwlog_obj();
          v196 = v28;
          v197 = (_DWORD *)**(unsigned int **)(a1 + 88);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "moved_bytes";
          *(_WORD *)&buf[22] = 2048;
          v292 = v28;
          v293 = 2048;
          v294 = v197;
          v198 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v288 = 0;
          if (!__nwlog_fault(v198, &type, &v288))
            goto LABEL_257;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v199 = __nwlog_obj();
            v200 = type;
            if (!os_log_type_enabled(v199, type))
              goto LABEL_257;
            v201 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "moved_bytes";
            *(_WORD *)&buf[22] = 2048;
            v292 = v196;
            v293 = 2048;
            v294 = v201;
            v202 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_256:
            _os_log_impl(&dword_182FBE000, v199, v200, v202, buf, 0x2Au);
            goto LABEL_257;
          }
          if (!v288)
          {
            v199 = __nwlog_obj();
            v200 = type;
            if (!os_log_type_enabled(v199, type))
              goto LABEL_257;
            v206 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "moved_bytes";
            *(_WORD *)&buf[22] = 2048;
            v292 = v196;
            v293 = 2048;
            v294 = v206;
            v202 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_256;
          }
          v203 = (char *)__nw_create_backtrace_string();
          v199 = __nwlog_obj();
          v200 = type;
          v204 = os_log_type_enabled(v199, type);
          if (!v203)
          {
            if (!v204)
              goto LABEL_257;
            v207 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "moved_bytes";
            *(_WORD *)&buf[22] = 2048;
            v292 = v196;
            v293 = 2048;
            v294 = v207;
            v202 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_256;
          }
          if (v204)
          {
            v205 = (_DWORD *)**(unsigned int **)(a1 + 88);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "moved_bytes";
            *(_WORD *)&buf[22] = 2048;
            v292 = v196;
            v293 = 2048;
            v294 = v205;
            v295 = 2082;
            v296 = v203;
            _os_log_impl(&dword_182FBE000, v199, v200, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v203);
LABEL_257:
          if (v198)
            free(v198);
          **(_DWORD **)(a1 + 88) = -1;
LABEL_260:
          v208 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v209 = *(unsigned int *)(v208 + 24) + 1;
          v210 = v209 << 31 >> 31;
          *(_DWORD *)(v208 + 24) = v209;
          if (v210 == v209 && (v210 & 0x8000000000000000) == 0)
            goto LABEL_279;
          __nwlog_obj();
          v211 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v211;
          v212 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v288 = 0;
          if (!__nwlog_fault(v212, &type, &v288))
            goto LABEL_276;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v213 = __nwlog_obj();
            v214 = type;
            if (!os_log_type_enabled(v213, type))
              goto LABEL_276;
            v215 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v215;
            v216 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_275:
            _os_log_impl(&dword_182FBE000, v213, v214, v216, buf, 0x2Au);
            goto LABEL_276;
          }
          if (!v288)
          {
            v213 = __nwlog_obj();
            v214 = type;
            if (!os_log_type_enabled(v213, type))
              goto LABEL_276;
            v220 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v220;
            v216 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_275;
          }
          v217 = (char *)__nw_create_backtrace_string();
          v213 = __nwlog_obj();
          v214 = type;
          v218 = os_log_type_enabled(v213, type);
          if (!v217)
          {
            if (!v218)
              goto LABEL_276;
            v221 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v221;
            v216 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_275;
          }
          if (v218)
          {
            v219 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v219;
            v295 = 2082;
            v296 = v217;
            _os_log_impl(&dword_182FBE000, v213, v214, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v217);
LABEL_276:
          if (v212)
            free(v212);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
LABEL_279:
          if (!nw_frame_is_metadata_complete((uint64_t)v290))
            goto LABEL_281;
          **(_DWORD **)(a1 + 80) = 0;
          v11 = 1;
          break;
        case 2:
          break;
        case 3:
          is_metadata_complete = nw_frame_is_metadata_complete((uint64_t)v290);
          if (gLogDatapath)
          {
            v280 = __nwlog_obj();
            if (os_log_type_enabled(v280, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v290;
              _os_log_impl(&dword_182FBE000, v280, OS_LOG_TYPE_DEBUG, "%{public}s discarding frame %p that is part of handled message", buf, 0x16u);
            }
          }
          v34 = v290;
          v35 = v290 + 8;
          v36 = *((_QWORD *)v290 + 4);
          v37 = (_QWORD *)*((_QWORD *)v290 + 5);
          if (v36)
          {
            *(_QWORD *)(v36 + 40) = v37;
            v37 = (_QWORD *)*((_QWORD *)v34 + 5);
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v37;
          }
          *v37 = v36;
          *v35 = 0;
          v35[1] = 0;
          nw_frame_finalize((uint64_t)v290);
          if (is_metadata_complete)
          {
            v87 = *(void (**)(_QWORD))(*(_QWORD *)(a1 + 48) + 120);
            if (v87)
              v87(*(_QWORD *)(a1 + 96));
          }
          goto LABEL_281;
        default:
          goto LABEL_45;
      }
LABEL_282:
      os_release(v5);
      return v11;
    }
    if (gLogDatapath)
    {
      v270 = __nwlog_obj();
      v271 = os_log_type_enabled(v270, OS_LOG_TYPE_DEBUG);
      v6 = *(unsigned __int8 *)(a1 + 120);
      if (v271)
      {
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_DWORD *)buf = 136446722;
        if (v6)
          v272 = "input";
        else
          v272 = "output";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v290;
        *(_WORD *)&buf[22] = 2080;
        v292 = (uint64_t)v272;
        _os_log_impl(&dword_182FBE000, v270, OS_LOG_TYPE_DEBUG, "%{public}s frame %p begins a %s new message", buf, 0x20u);
        v6 = *(unsigned __int8 *)(a1 + 120);
      }
    }
    v21 = *(_QWORD *)(a1 + 48);
    if (v6)
    {
      v22 = *(_BYTE *)(v21 + 56);
      if ((v22 & 1) != 0)
      {
        v23 = *(void **)(v21 + 48);
        if (v23)
        {
          os_release(v23);
          v22 = *(_BYTE *)(v21 + 56);
        }
      }
      *(_QWORD *)(v21 + 48) = v5;
      *(_BYTE *)(v21 + 56) = v22 | 1;
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + 140) = 0;
    }
    else
    {
      v38 = *(_BYTE *)(v21 + 72);
      if ((v38 & 1) != 0)
      {
        v39 = *(void **)(v21 + 64);
        if (v39)
        {
          os_release(v39);
          v38 = *(_BYTE *)(v21 + 72);
        }
      }
      *(_QWORD *)(v21 + 64) = v5;
      *(_BYTE *)(v21 + 72) = v38 | 1;
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + 141) = 0;
    }
    v5 = 0;
LABEL_45:
    if (nw_frame_unclaimed_length(v290))
    {
      v40 = 0;
      if (!gLogDatapath)
        goto LABEL_49;
    }
    else
    {
      v40 = nw_frame_is_metadata_complete((uint64_t)v290);
      if (!gLogDatapath)
        goto LABEL_49;
    }
    v265 = __nwlog_obj();
    if (os_log_type_enabled(v265, OS_LOG_TYPE_DEBUG))
    {
      v266 = *(_QWORD *)(a1 + 96);
      v267 = "invalid";
      if (v266)
      {
        v268 = *(const char **)(v266 + 16);
        if (v268)
          v267 = v268;
      }
      v269 = "input";
      if (!*(_BYTE *)(a1 + 120))
        v269 = "output";
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v267;
      *(_WORD *)&buf[22] = 2080;
      v292 = (uint64_t)v269;
      v293 = 2048;
      v294 = v290;
      v295 = 1024;
      LODWORD(v296) = v40;
      _os_log_impl(&dword_182FBE000, v265, OS_LOG_TYPE_DEBUG, "%{public}s calling %s processor with %s frame %p metadata_only %{BOOL}d", buf, 0x30u);
    }
LABEL_49:
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    LOBYTE(v292) = 1;
    (*(void (**)(void))(a1 + 104))();
    v11 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    if (!v5)
      return v11;
    goto LABEL_282;
  }
  v16 = nw_frame_unclaimed_length(v290);
  if (v16 > **(_DWORD **)(a1 + 56))
  {
    if (*(_BYTE *)(a1 + 120))
    {
      if (gLogDatapath)
      {
        v274 = __nwlog_obj();
        if (os_log_type_enabled(v274, OS_LOG_TYPE_DEBUG))
        {
          v275 = **(_DWORD **)(a1 + 56);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v290;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v292) = v275;
          _os_log_impl(&dword_182FBE000, v274, OS_LOG_TYPE_DEBUG, "%{public}s splitting frame %p with unknown metadata by offset %d", buf, 0x1Cu);
        }
      }
      v17 = v290;
      v18 = v290 + 8;
      v19 = *((_QWORD *)v290 + 4);
      v20 = (_QWORD *)*((_QWORD *)v290 + 5);
      if (v19)
      {
        *(_QWORD *)(v19 + 40) = v20;
        v20 = (_QWORD *)*((_QWORD *)v17 + 5);
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v20;
      }
      *v20 = v19;
      *v18 = 0;
      v18[1] = 0;
      v61 = nw_frame_split((uint64_t *)&v290, **(_DWORD **)(a1 + 56));
      v62 = *(uint64_t **)(a1 + 64);
      v63 = v290;
      v64 = *v62;
      v65 = v290;
      *((_QWORD *)v290 + 4) = *v62;
      v66 = v65 + 8;
      if (v64)
        v67 = (_QWORD *)(v64 + 40);
      else
        v67 = v62 + 1;
      *v67 = v66;
      *v62 = (uint64_t)v63;
      *((_QWORD *)v63 + 5) = v62;
      v68 = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(v61 + 32) = 0;
      v69 = *(uint64_t **)(v68 + 8);
      *(_QWORD *)(v61 + 40) = v69;
      *v69 = v61;
      *(_QWORD *)(v68 + 8) = v61 + 32;
      **(_DWORD **)(a1 + 80) = 0;
      **(_DWORD **)(a1 + 56) = 0;
      v70 = *(_DWORD **)(a1 + 40);
      if ((*v70)--)
      {
LABEL_190:
        v158 = *(_DWORD **)(a1 + 88);
        v159 = **(_DWORD **)(a1 + 56);
        v51 = __CFADD__(*v158, v159);
        *v158 += v159;
        if (!v51)
          goto LABEL_209;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v160 = **(unsigned int **)(a1 + 56);
        v161 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "moved_bytes";
        *(_WORD *)&buf[22] = 2048;
        v292 = v160;
        v293 = 2048;
        v294 = v161;
        v162 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v288 = 0;
        if (__nwlog_fault(v162, &type, &v288))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v163 = __nwlog_obj();
            v164 = type;
            if (os_log_type_enabled(v163, type))
            {
              v165 = **(unsigned int **)(a1 + 56);
              v166 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "moved_bytes";
              *(_WORD *)&buf[22] = 2048;
              v292 = v165;
              v293 = 2048;
              v294 = v166;
              v167 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_205:
              _os_log_impl(&dword_182FBE000, v163, v164, v167, buf, 0x2Au);
            }
          }
          else if (v288)
          {
            v168 = (char *)__nw_create_backtrace_string();
            v163 = __nwlog_obj();
            v164 = type;
            v169 = os_log_type_enabled(v163, type);
            if (v168)
            {
              if (v169)
              {
                v170 = **(unsigned int **)(a1 + 56);
                v171 = (_DWORD *)**(unsigned int **)(a1 + 88);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "moved_bytes";
                *(_WORD *)&buf[22] = 2048;
                v292 = v170;
                v293 = 2048;
                v294 = v171;
                v295 = 2082;
                v296 = v168;
                _os_log_impl(&dword_182FBE000, v163, v164, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v168);
              goto LABEL_206;
            }
            if (v169)
            {
              v174 = **(unsigned int **)(a1 + 56);
              v175 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "moved_bytes";
              *(_WORD *)&buf[22] = 2048;
              v292 = v174;
              v293 = 2048;
              v294 = v175;
              v167 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_205;
            }
          }
          else
          {
            v163 = __nwlog_obj();
            v164 = type;
            if (os_log_type_enabled(v163, type))
            {
              v172 = **(unsigned int **)(a1 + 56);
              v173 = (_DWORD *)**(unsigned int **)(a1 + 88);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "moved_bytes";
              *(_WORD *)&buf[22] = 2048;
              v292 = v172;
              v293 = 2048;
              v294 = v173;
              v167 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_205;
            }
          }
        }
LABEL_206:
        if (v162)
          free(v162);
        **(_DWORD **)(a1 + 88) = -1;
LABEL_209:
        v176 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v177 = *(unsigned int *)(v176 + 24) + 1;
        v178 = v177 << 31 >> 31;
        *(_DWORD *)(v176 + 24) = v177;
        if (v178 != v177 || v178 < 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v179 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v179;
          v180 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v288 = 0;
          if (__nwlog_fault(v180, &type, &v288))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v181 = __nwlog_obj();
              v182 = type;
              if (os_log_type_enabled(v181, type))
              {
                v183 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "count";
                *(_WORD *)&buf[22] = 2048;
                v292 = 1;
                v293 = 2048;
                v294 = v183;
                v184 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_224:
                _os_log_impl(&dword_182FBE000, v181, v182, v184, buf, 0x2Au);
              }
            }
            else if (v288)
            {
              v185 = (char *)__nw_create_backtrace_string();
              v181 = __nwlog_obj();
              v182 = type;
              v186 = os_log_type_enabled(v181, type);
              if (v185)
              {
                if (v186)
                {
                  v187 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "count";
                  *(_WORD *)&buf[22] = 2048;
                  v292 = 1;
                  v293 = 2048;
                  v294 = v187;
                  v295 = 2082;
                  v296 = v185;
                  _os_log_impl(&dword_182FBE000, v181, v182, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v185);
                goto LABEL_225;
              }
              if (v186)
              {
                v189 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "count";
                *(_WORD *)&buf[22] = 2048;
                v292 = 1;
                v293 = 2048;
                v294 = v189;
                v184 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_224;
              }
            }
            else
            {
              v181 = __nwlog_obj();
              v182 = type;
              if (os_log_type_enabled(v181, type))
              {
                v188 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "count";
                *(_WORD *)&buf[22] = 2048;
                v292 = 1;
                v293 = 2048;
                v294 = v188;
                v184 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_224;
              }
            }
          }
LABEL_225:
          if (v180)
            free(v180);
          v11 = 0;
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
          return v11;
        }
        return 0;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v72 = (_DWORD *)**(unsigned int **)(a1 + 40);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = "maximum_frame_count";
      *(_WORD *)&buf[22] = 2048;
      v292 = 1;
      v293 = 2048;
      v294 = v72;
      v73 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v288 = 0;
      if (__nwlog_fault(v73, &type, &v288))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v74 = __nwlog_obj();
          v75 = type;
          if (os_log_type_enabled(v74, type))
          {
            v76 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v76;
            v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_186:
            _os_log_impl(&dword_182FBE000, v74, v75, v77, buf, 0x2Au);
          }
        }
        else if (v288)
        {
          v88 = (char *)__nw_create_backtrace_string();
          v74 = __nwlog_obj();
          v75 = type;
          v89 = os_log_type_enabled(v74, type);
          if (v88)
          {
            if (v89)
            {
              v90 = (_DWORD *)**(unsigned int **)(a1 + 40);
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "maximum_frame_count";
              *(_WORD *)&buf[22] = 2048;
              v292 = 1;
              v293 = 2048;
              v294 = v90;
              v295 = 2082;
              v296 = v88;
              _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v88);
            goto LABEL_187;
          }
          if (v89)
          {
            v157 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v157;
            v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_186;
          }
        }
        else
        {
          v74 = __nwlog_obj();
          v75 = type;
          if (os_log_type_enabled(v74, type))
          {
            v153 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v153;
            v77 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_186;
          }
        }
      }
LABEL_187:
      if (v73)
        free(v73);
      **(_DWORD **)(a1 + 40) = 0;
      goto LABEL_190;
    }
    if (!gLogDatapath)
      return 0;
    v41 = __nwlog_obj();
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      return 0;
    v42 = **(_DWORD **)(a1 + 56);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v42;
    v43 = "%{public}s not delivering frame with length %u maximum bytes %u";
    v44 = v41;
    v45 = 24;
LABEL_344:
    _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, v43, buf, v45);
    return 0;
  }
  if (gLogDatapath)
  {
    v273 = __nwlog_obj();
    if (os_log_type_enabled(v273, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v290;
      _os_log_impl(&dword_182FBE000, v273, OS_LOG_TYPE_DEBUG, "%{public}s delivering frame %p with unknown metadata", buf, 0x16u);
    }
  }
  v24 = v290;
  v25 = v290 + 8;
  v26 = *((_QWORD *)v290 + 4);
  v27 = (_QWORD *)*((_QWORD *)v290 + 5);
  if (v26)
  {
    *(_QWORD *)(v26 + 40) = v27;
    v27 = (_QWORD *)*((_QWORD *)v24 + 5);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) = v27;
  }
  *v27 = v26;
  *v25 = 0;
  v25[1] = 0;
  v46 = *(_QWORD *)(a1 + 72);
  v47 = v290;
  v48 = v290;
  *((_QWORD *)v290 + 4) = 0;
  v49 = *(_QWORD **)(v46 + 8);
  *((_QWORD *)v47 + 5) = v49;
  *v49 = v47;
  *(_QWORD *)(v46 + 8) = v48 + 8;
  v50 = *(unsigned int **)(a1 + 80);
  v51 = *v50 >= v16;
  *v50 -= v16;
  if (!v51)
  {
    if (gLogDatapath)
    {
      v276 = __nwlog_obj();
      if (os_log_type_enabled(v276, OS_LOG_TYPE_DEBUG))
      {
        v277 = (_DWORD *)**(unsigned int **)(a1 + 80);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "minimum_bytes";
        *(_WORD *)&buf[22] = 2048;
        v292 = v16;
        v293 = 2048;
        v294 = v277;
        _os_log_impl(&dword_182FBE000, v276, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
      }
    }
    **(_DWORD **)(a1 + 80) = 0;
  }
  v52 = *(unsigned int **)(a1 + 56);
  v51 = *v52 >= v16;
  *v52 -= v16;
  if (!v51)
  {
    if (gLogDatapath)
    {
      v278 = __nwlog_obj();
      if (os_log_type_enabled(v278, OS_LOG_TYPE_DEBUG))
      {
        v279 = (_DWORD *)**(unsigned int **)(a1 + 56);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "maximum_bytes";
        *(_WORD *)&buf[22] = 2048;
        v292 = v16;
        v293 = 2048;
        v294 = v279;
        _os_log_impl(&dword_182FBE000, v278, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
      }
    }
    **(_DWORD **)(a1 + 56) = 0;
  }
  v53 = *(_DWORD **)(a1 + 40);
  if (!(*v53)--)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v55 = (_DWORD *)**(unsigned int **)(a1 + 40);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = "maximum_frame_count";
    *(_WORD *)&buf[22] = 2048;
    v292 = 1;
    v293 = 2048;
    v294 = v55;
    v56 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v288 = 0;
    if (__nwlog_fault(v56, &type, &v288))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v57 = gLogObj;
        v58 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v59 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v59;
          v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_132:
          _os_log_impl(&dword_182FBE000, v57, v58, v60, buf, 0x2Au);
        }
      }
      else if (v288)
      {
        v84 = (char *)__nw_create_backtrace_string();
        v57 = __nwlog_obj();
        v58 = type;
        v85 = os_log_type_enabled(v57, type);
        if (v84)
        {
          if (v85)
          {
            v86 = (_DWORD *)**(unsigned int **)(a1 + 40);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "maximum_frame_count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v86;
            v295 = 2082;
            v296 = v84;
            _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v84);
          goto LABEL_133;
        }
        if (v85)
        {
          v125 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v125;
          v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_132;
        }
      }
      else
      {
        v57 = __nwlog_obj();
        v58 = type;
        if (os_log_type_enabled(v57, type))
        {
          v107 = (_DWORD *)**(unsigned int **)(a1 + 40);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "maximum_frame_count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v107;
          v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_132;
        }
      }
    }
LABEL_133:
    if (v56)
      free(v56);
    **(_DWORD **)(a1 + 40) = 0;
  }
  v126 = *(_DWORD **)(a1 + 88);
  v51 = __CFADD__(*v126, v16);
  *v126 += v16;
  if (!v51)
    goto LABEL_155;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v127 = v16;
  v128 = (_DWORD *)**(unsigned int **)(a1 + 88);
  *(_DWORD *)buf = 136446978;
  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = "moved_bytes";
  *(_WORD *)&buf[22] = 2048;
  v292 = v16;
  v293 = 2048;
  v294 = v128;
  v129 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v288 = 0;
  if (__nwlog_fault(v129, &type, &v288))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v130 = gLogObj;
      v131 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v132 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "moved_bytes";
        *(_WORD *)&buf[22] = 2048;
        v292 = v127;
        v293 = 2048;
        v294 = v132;
        v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_151:
        _os_log_impl(&dword_182FBE000, v130, v131, v133, buf, 0x2Au);
      }
    }
    else if (v288)
    {
      v134 = (char *)__nw_create_backtrace_string();
      v130 = __nwlog_obj();
      v131 = type;
      v135 = os_log_type_enabled(v130, type);
      if (v134)
      {
        if (v135)
        {
          v136 = (_DWORD *)**(unsigned int **)(a1 + 88);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "moved_bytes";
          *(_WORD *)&buf[22] = 2048;
          v292 = v127;
          v293 = 2048;
          v294 = v136;
          v295 = 2082;
          v296 = v134;
          _os_log_impl(&dword_182FBE000, v130, v131, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v134);
        goto LABEL_152;
      }
      if (v135)
      {
        v138 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "moved_bytes";
        *(_WORD *)&buf[22] = 2048;
        v292 = v127;
        v293 = 2048;
        v294 = v138;
        v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_151;
      }
    }
    else
    {
      v130 = __nwlog_obj();
      v131 = type;
      if (os_log_type_enabled(v130, type))
      {
        v137 = (_DWORD *)**(unsigned int **)(a1 + 88);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "moved_bytes";
        *(_WORD *)&buf[22] = 2048;
        v292 = v127;
        v293 = 2048;
        v294 = v137;
        v133 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_151;
      }
    }
  }
LABEL_152:
  if (v129)
    free(v129);
  **(_DWORD **)(a1 + 88) = -1;
LABEL_155:
  v139 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v140 = *(unsigned int *)(v139 + 24) + 1;
  v141 = v140 << 31 >> 31;
  *(_DWORD *)(v139 + 24) = v140;
  if (v141 != v140 || v141 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v142 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = "count";
    *(_WORD *)&buf[22] = 2048;
    v292 = 1;
    v293 = 2048;
    v294 = v142;
    v143 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v288 = 0;
    if (__nwlog_fault(v143, &type, &v288))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v144 = gLogObj;
        v145 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v146 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v146;
          v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_170:
          _os_log_impl(&dword_182FBE000, v144, v145, v147, buf, 0x2Au);
        }
      }
      else if (v288)
      {
        v148 = (char *)__nw_create_backtrace_string();
        v144 = __nwlog_obj();
        v145 = type;
        v149 = os_log_type_enabled(v144, type);
        if (v148)
        {
          if (v149)
          {
            v150 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v292 = 1;
            v293 = 2048;
            v294 = v150;
            v295 = 2082;
            v296 = v148;
            _os_log_impl(&dword_182FBE000, v144, v145, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v148);
          goto LABEL_171;
        }
        if (v149)
        {
          v152 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v152;
          v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_170;
        }
      }
      else
      {
        v144 = __nwlog_obj();
        v145 = type;
        if (os_log_type_enabled(v144, type))
        {
          v151 = (_DWORD *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v292 = 1;
          v293 = 2048;
          v294 = v151;
          v147 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_170;
        }
      }
    }
LABEL_171:
    if (v143)
      free(v143);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
  }
  if (nw_frame_is_metadata_complete((uint64_t)v290))
    **(_DWORD **)(a1 + 80) = 0;
  return 1;
}

void nw_protocol_plugin_metadata_report_transfer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void (*v5)(uint64_t, uint64_t, uint64_t, uint64_t);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!(_DWORD)a4)
    return;
  if (a3)
  {
    v5 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 112);
    if (v5)
      v5(a2, a3, a4, a5);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_plugin_metadata_report_transfer";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_plugin_metadata_report_transfer";
      v9 = "%{public}s called with null metadata";
      goto LABEL_18;
    }
    if (!v12)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_plugin_metadata_report_transfer";
      v9 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_18;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v15 = "nw_protocol_plugin_metadata_report_transfer";
        v16 = 2082;
        v17 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_19;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_plugin_metadata_report_transfer";
      v9 = "%{public}s called with null metadata, no backtrace";
LABEL_18:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_19:
  if (v6)
    free(v6);
}

void __nw_protocol_plugin_metadata_process_frames_block_invoke_30(uint64_t a1, unsigned int a2, NSObject *a3)
{
  uint64_t v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  int is_metadata_complete;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  char *backtrace_string;
  _BOOL4 v26;
  void (*v27)(_QWORD);
  NSObject *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  unsigned int *v33;
  BOOL v34;
  unsigned int *v35;
  _DWORD *v36;
  const char *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  const char *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t *v52;
  _DWORD *v53;
  const char *v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  const char *v59;
  const char *v60;
  char *v61;
  _BOOL4 v62;
  const char *v63;
  char *v64;
  _BOOL4 v65;
  const char *v66;
  const char *v67;
  const char *v68;
  _DWORD *v69;
  uint64_t v70;
  const char *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  const char *v75;
  const char *v76;
  char *v77;
  _BOOL4 v78;
  const char *v79;
  const char *v80;
  const char *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  const char *v85;
  char *v86;
  NSObject *v87;
  os_log_type_t v88;
  const char *v89;
  const char *v90;
  char *v91;
  _BOOL4 v92;
  const char *v93;
  const char *v94;
  const char *v95;
  const char *v96;
  const char *v97;
  _DWORD *v98;
  int v99;
  uint64_t v100;
  const char *v101;
  char *v102;
  NSObject *v103;
  os_log_type_t v104;
  uint64_t v105;
  const char *v106;
  const char *v107;
  char *v108;
  _BOOL4 v109;
  uint64_t v110;
  const char *v111;
  uint64_t v112;
  const char *v113;
  uint64_t v114;
  const char *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  char *v120;
  NSObject *v121;
  os_log_type_t v122;
  const char *v123;
  const char *v124;
  char *v125;
  _BOOL4 v126;
  const char *v127;
  const char *v128;
  const char *v129;
  NSObject *v130;
  uint64_t v131;
  const char *v132;
  const char *v133;
  const char *v134;
  const char *v135;
  char *v136;
  NSObject *v137;
  uint64_t v138;
  int v139;
  NSObject *v140;
  const char *v141;
  NSObject *v142;
  const char *v143;
  char v144;
  os_log_type_t type[8];
  os_log_type_t v146;
  uint8_t buf[4];
  const char *v148;
  __int16 v149;
  _BYTE v150[10];
  uint64_t v151;
  __int16 v152;
  const char *v153;
  __int16 v154;
  char *v155;
  uint64_t v156;

  v156 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v130 = __nwlog_obj();
    if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
    {
      v131 = *(_QWORD *)(a1 + 48);
      v132 = "invalid";
      if (v131)
      {
        v133 = *(const char **)(v131 + 16);
        if (v133)
          v132 = v133;
      }
      if (a2 > 3)
        v134 = "invalid";
      else
        v134 = off_1E149A920[a2];
      v135 = "input";
      v136 = *(char **)(a1 + 56);
      if (!*(_BYTE *)(a1 + 120))
        v135 = "output";
      *(_DWORD *)buf = 136447234;
      v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v149 = 2080;
      *(_QWORD *)v150 = v132;
      *(_WORD *)&v150[8] = 2080;
      v151 = (uint64_t)v134;
      v152 = 2080;
      v153 = v135;
      v154 = 2048;
      v155 = v136;
      _os_log_impl(&dword_182FBE000, v130, OS_LOG_TYPE_DEBUG, "%{public}s %s processor returned result %s for %s frame %p", buf, 0x34u);
    }
  }
  v6 = *(_QWORD *)(a1 + 64);
  if (*(_BYTE *)(a1 + 120))
  {
    *(_BYTE *)(v6 + 140) = a2;
    if (a2 > 3)
      return;
  }
  else
  {
    *(_BYTE *)(v6 + 141) = a2;
  }
  switch(a2)
  {
    case 0u:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
      v7 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v146 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v7, type, &v146))
        goto LABEL_62;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_62;
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v10 = "%{public}s metadata processor result must not be unknown";
LABEL_61:
        _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
        goto LABEL_62;
      }
      if (v146 == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_62;
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v10 = "%{public}s metadata processor result must not be unknown, backtrace limit exceeded";
        goto LABEL_61;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type[0];
      v26 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!backtrace_string)
      {
        if (!v26)
          goto LABEL_62;
        *(_DWORD *)buf = 136446210;
        v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v10 = "%{public}s metadata processor result must not be unknown, no backtrace";
        goto LABEL_61;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v149 = 2082;
        *(_QWORD *)v150 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s metadata processor result must not be unknown, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
LABEL_62:
      if (v7)
        free(v7);
      return;
    case 1u:
      v11 = nw_frame_unclaimed_length(*(_DWORD **)(a1 + 56));
      if (v11 <= **(_DWORD **)(a1 + 72))
      {
        v19 = 48;
        if (!*(_BYTE *)(a1 + 120))
          v19 = 64;
        if (*(NSObject **)(*(_QWORD *)(a1 + 64) + v19) != a3)
        {
          v20 = *(_QWORD *)(a1 + 56);
          is_metadata_complete = nw_frame_is_metadata_complete(v20);
          nw_frame_set_metadata(v20, a3, 0, is_metadata_complete);
        }
        v22 = *(_QWORD *)(a1 + 56);
        v23 = *(_QWORD *)(v22 + 32);
        v24 = *(_QWORD **)(v22 + 40);
        if (v23)
        {
          *(_QWORD *)(v23 + 40) = v24;
          v24 = *(_QWORD **)(v22 + 40);
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) = v24;
        }
        *v24 = v23;
        *(_QWORD *)(v22 + 32) = 0;
        *(_QWORD *)(v22 + 40) = 0;
        v30 = *(_QWORD *)(a1 + 88);
        v31 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)(v31 + 32) = 0;
        v32 = *(_QWORD **)(v30 + 8);
        *(_QWORD *)(v31 + 40) = v32;
        *v32 = v31;
        *(_QWORD *)(v30 + 8) = v31 + 32;
        v33 = *(unsigned int **)(a1 + 96);
        v34 = *v33 >= v11;
        *v33 -= v11;
        if (!v34)
        {
          if (gLogDatapath)
          {
            v140 = __nwlog_obj();
            if (os_log_type_enabled(v140, OS_LOG_TYPE_DEBUG))
            {
              v141 = (const char *)**(unsigned int **)(a1 + 96);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "minimum_bytes";
              *(_WORD *)&v150[8] = 2048;
              v151 = v11;
              v152 = 2048;
              v153 = v141;
              _os_log_impl(&dword_182FBE000, v140, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          **(_DWORD **)(a1 + 96) = 0;
        }
        v35 = *(unsigned int **)(a1 + 72);
        v34 = *v35 >= v11;
        *v35 -= v11;
        if (!v34)
        {
          if (gLogDatapath)
          {
            v142 = __nwlog_obj();
            if (os_log_type_enabled(v142, OS_LOG_TYPE_DEBUG))
            {
              v143 = (const char *)**(unsigned int **)(a1 + 72);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "maximum_bytes";
              *(_WORD *)&v150[8] = 2048;
              v151 = v11;
              v152 = 2048;
              v153 = v143;
              _os_log_impl(&dword_182FBE000, v142, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          **(_DWORD **)(a1 + 72) = 0;
        }
        v36 = *(_DWORD **)(a1 + 104);
        if ((*v36)--)
        {
LABEL_82:
          v69 = *(_DWORD **)(a1 + 112);
          v34 = __CFADD__(*v69, v11);
          *v69 += v11;
          if (!v34)
            goto LABEL_101;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v70 = v11;
          v71 = (const char *)**(unsigned int **)(a1 + 112);
          *(_DWORD *)buf = 136446978;
          v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v149 = 2082;
          *(_QWORD *)v150 = "moved_bytes";
          *(_WORD *)&v150[8] = 2048;
          v151 = v11;
          v152 = 2048;
          v153 = v71;
          v72 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v146 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v72, type, &v146))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v73 = gLogObj;
              v74 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                v75 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v70;
                v152 = 2048;
                v153 = v75;
                v76 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_97:
                _os_log_impl(&dword_182FBE000, v73, v74, v76, buf, 0x2Au);
              }
            }
            else if (v146)
            {
              v77 = (char *)__nw_create_backtrace_string();
              v73 = __nwlog_obj();
              v74 = type[0];
              v78 = os_log_type_enabled(v73, type[0]);
              if (v77)
              {
                if (v78)
                {
                  v79 = (const char *)**(unsigned int **)(a1 + 112);
                  *(_DWORD *)buf = 136447234;
                  v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  v149 = 2082;
                  *(_QWORD *)v150 = "moved_bytes";
                  *(_WORD *)&v150[8] = 2048;
                  v151 = v70;
                  v152 = 2048;
                  v153 = v79;
                  v154 = 2082;
                  v155 = v77;
                  _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v77);
                goto LABEL_98;
              }
              if (v78)
              {
                v81 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v70;
                v152 = 2048;
                v153 = v81;
                v76 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_97;
              }
            }
            else
            {
              v73 = __nwlog_obj();
              v74 = type[0];
              if (os_log_type_enabled(v73, type[0]))
              {
                v80 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v70;
                v152 = 2048;
                v153 = v80;
                v76 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_97;
              }
            }
          }
LABEL_98:
          if (v72)
            free(v72);
          **(_DWORD **)(a1 + 112) = -1;
LABEL_101:
          v82 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v83 = *(unsigned int *)(v82 + 24) + 1;
          v84 = v83 << 31 >> 31;
          *(_DWORD *)(v82 + 24) = v83;
          if (v84 == v83 && (v84 & 0x8000000000000000) == 0)
          {
LABEL_120:
            if (nw_frame_is_metadata_complete(*(_QWORD *)(a1 + 56)))
              **(_DWORD **)(a1 + 96) = 0;
            return;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v85 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v149 = 2082;
          *(_QWORD *)v150 = "count";
          *(_WORD *)&v150[8] = 2048;
          v151 = 1;
          v152 = 2048;
          v153 = v85;
          v86 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v146 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v86, type, &v146))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v87 = gLogObj;
              v88 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                v89 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "count";
                *(_WORD *)&v150[8] = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v89;
                v90 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_116:
                _os_log_impl(&dword_182FBE000, v87, v88, v90, buf, 0x2Au);
              }
            }
            else if (v146)
            {
              v91 = (char *)__nw_create_backtrace_string();
              v87 = __nwlog_obj();
              v88 = type[0];
              v92 = os_log_type_enabled(v87, type[0]);
              if (v91)
              {
                if (v92)
                {
                  v93 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  *(_DWORD *)buf = 136447234;
                  v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  v149 = 2082;
                  *(_QWORD *)v150 = "count";
                  *(_WORD *)&v150[8] = 2048;
                  v151 = 1;
                  v152 = 2048;
                  v153 = v93;
                  v154 = 2082;
                  v155 = v91;
                  _os_log_impl(&dword_182FBE000, v87, v88, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v91);
                goto LABEL_117;
              }
              if (v92)
              {
                v95 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "count";
                *(_WORD *)&v150[8] = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v95;
                v90 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_116;
              }
            }
            else
            {
              v87 = __nwlog_obj();
              v88 = type[0];
              if (os_log_type_enabled(v87, type[0]))
              {
                v94 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "count";
                *(_WORD *)&v150[8] = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v94;
                v90 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_116;
              }
            }
          }
LABEL_117:
          if (v86)
            free(v86);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
          goto LABEL_120;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (const char *)**(unsigned int **)(a1 + 104);
        *(_DWORD *)buf = 136446978;
        v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v149 = 2082;
        *(_QWORD *)v150 = "maximum_frame_count";
        *(_WORD *)&v150[8] = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v38;
        v39 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v146 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v39, type, &v146))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v40 = __nwlog_obj();
            v41 = type[0];
            if (os_log_type_enabled(v40, type[0]))
            {
              v42 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v42;
              v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_78:
              _os_log_impl(&dword_182FBE000, v40, v41, v43, buf, 0x2Au);
            }
          }
          else if (v146)
          {
            v61 = (char *)__nw_create_backtrace_string();
            v40 = __nwlog_obj();
            v41 = type[0];
            v62 = os_log_type_enabled(v40, type[0]);
            if (v61)
            {
              if (v62)
              {
                v63 = (const char *)**(unsigned int **)(a1 + 104);
                *(_DWORD *)buf = 136447234;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "maximum_frame_count";
                *(_WORD *)&v150[8] = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v63;
                v154 = 2082;
                v155 = v61;
                _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v61);
              goto LABEL_79;
            }
            if (v62)
            {
              v68 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v68;
              v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_78;
            }
          }
          else
          {
            v40 = __nwlog_obj();
            v41 = type[0];
            if (os_log_type_enabled(v40, type[0]))
            {
              v67 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v67;
              v43 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_78;
            }
          }
        }
LABEL_79:
        if (v39)
          free(v39);
        **(_DWORD **)(a1 + 104) = 0;
        goto LABEL_82;
      }
      if (*(_BYTE *)(a1 + 120))
      {
        if (gLogDatapath)
        {
          v137 = __nwlog_obj();
          if (os_log_type_enabled(v137, OS_LOG_TYPE_DEBUG))
          {
            v138 = *(_QWORD *)(a1 + 56);
            v139 = **(_DWORD **)(a1 + 72);
            *(_DWORD *)buf = 136446722;
            v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
            v149 = 2048;
            *(_QWORD *)v150 = v138;
            *(_WORD *)&v150[8] = 1024;
            LODWORD(v151) = v139;
            _os_log_impl(&dword_182FBE000, v137, OS_LOG_TYPE_DEBUG, "%{public}s splitting frame %p by offset %d", buf, 0x1Cu);
          }
        }
        v12 = *(_QWORD *)(a1 + 56);
        v13 = *(_QWORD *)(v12 + 32);
        v14 = *(_QWORD **)(v12 + 40);
        if (v13)
        {
          *(_QWORD *)(v13 + 40) = v14;
          v14 = *(_QWORD **)(v12 + 40);
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) = v14;
        }
        *v14 = v13;
        *(_QWORD *)(v12 + 32) = 0;
        *(_QWORD *)(v12 + 40) = 0;
        *(_QWORD *)type = *(_QWORD *)(a1 + 56);
        v44 = nw_frame_split((uint64_t *)type, **(_DWORD **)(a1 + 72));
        v45 = *(uint64_t **)(a1 + 80);
        v46 = *(_QWORD *)type;
        v47 = *v45;
        v48 = *(_QWORD *)type;
        *(_QWORD *)(*(_QWORD *)type + 32) = *v45;
        v49 = v48 + 32;
        if (v47)
          v50 = (_QWORD *)(v47 + 40);
        else
          v50 = v45 + 1;
        *v50 = v49;
        *v45 = v46;
        *(_QWORD *)(v46 + 40) = v45;
        v51 = *(_QWORD *)(a1 + 88);
        *(_QWORD *)(v44 + 32) = 0;
        v52 = *(uint64_t **)(v51 + 8);
        *(_QWORD *)(v44 + 40) = v52;
        *v52 = v44;
        *(_QWORD *)(v51 + 8) = v44 + 32;
        **(_DWORD **)(a1 + 96) = 0;
        **(_DWORD **)(a1 + 72) = 0;
        v53 = *(_DWORD **)(a1 + 104);
        if ((*v53)--)
        {
LABEL_130:
          v98 = *(_DWORD **)(a1 + 112);
          v99 = **(_DWORD **)(a1 + 72);
          v34 = __CFADD__(*v98, v99);
          *v98 += v99;
          if (!v34)
            goto LABEL_149;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v100 = **(unsigned int **)(a1 + 72);
          v101 = (const char *)**(unsigned int **)(a1 + 112);
          *(_DWORD *)buf = 136446978;
          v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v149 = 2082;
          *(_QWORD *)v150 = "moved_bytes";
          *(_WORD *)&v150[8] = 2048;
          v151 = v100;
          v152 = 2048;
          v153 = v101;
          v102 = (char *)_os_log_send_and_compose_impl();
          v146 = OS_LOG_TYPE_ERROR;
          v144 = 0;
          if (__nwlog_fault(v102, &v146, &v144))
          {
            if (v146 == OS_LOG_TYPE_FAULT)
            {
              v103 = __nwlog_obj();
              v104 = v146;
              if (os_log_type_enabled(v103, v146))
              {
                v105 = **(unsigned int **)(a1 + 72);
                v106 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v105;
                v152 = 2048;
                v153 = v106;
                v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_145:
                _os_log_impl(&dword_182FBE000, v103, v104, v107, buf, 0x2Au);
              }
            }
            else if (v144)
            {
              v108 = (char *)__nw_create_backtrace_string();
              v103 = __nwlog_obj();
              v104 = v146;
              v109 = os_log_type_enabled(v103, v146);
              if (v108)
              {
                if (v109)
                {
                  v110 = **(unsigned int **)(a1 + 72);
                  v111 = (const char *)**(unsigned int **)(a1 + 112);
                  *(_DWORD *)buf = 136447234;
                  v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                  v149 = 2082;
                  *(_QWORD *)v150 = "moved_bytes";
                  *(_WORD *)&v150[8] = 2048;
                  v151 = v110;
                  v152 = 2048;
                  v153 = v111;
                  v154 = 2082;
                  v155 = v108;
                  _os_log_impl(&dword_182FBE000, v103, v104, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v108);
                goto LABEL_146;
              }
              if (v109)
              {
                v114 = **(unsigned int **)(a1 + 72);
                v115 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v114;
                v152 = 2048;
                v153 = v115;
                v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_145;
              }
            }
            else
            {
              v103 = __nwlog_obj();
              v104 = v146;
              if (os_log_type_enabled(v103, v146))
              {
                v112 = **(unsigned int **)(a1 + 72);
                v113 = (const char *)**(unsigned int **)(a1 + 112);
                *(_DWORD *)buf = 136446978;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "moved_bytes";
                *(_WORD *)&v150[8] = 2048;
                v151 = v112;
                v152 = 2048;
                v153 = v113;
                v107 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_145;
              }
            }
          }
LABEL_146:
          if (v102)
            free(v102);
          **(_DWORD **)(a1 + 112) = -1;
LABEL_149:
          v116 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v117 = *(unsigned int *)(v116 + 24) + 1;
          v118 = v117 << 31 >> 31;
          *(_DWORD *)(v116 + 24) = v117;
          if (v118 == v117 && (v118 & 0x8000000000000000) == 0)
            goto LABEL_168;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v119 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v149 = 2082;
          *(_QWORD *)v150 = "count";
          *(_WORD *)&v150[8] = 2048;
          v151 = 1;
          v152 = 2048;
          v153 = v119;
          v120 = (char *)_os_log_send_and_compose_impl();
          v146 = OS_LOG_TYPE_ERROR;
          v144 = 0;
          if (!__nwlog_fault(v120, &v146, &v144))
            goto LABEL_165;
          if (v146 == OS_LOG_TYPE_FAULT)
          {
            v121 = __nwlog_obj();
            v122 = v146;
            if (os_log_type_enabled(v121, v146))
            {
              v123 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v123;
              v124 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_164:
              _os_log_impl(&dword_182FBE000, v121, v122, v124, buf, 0x2Au);
            }
          }
          else if (v144)
          {
            v125 = (char *)__nw_create_backtrace_string();
            v121 = __nwlog_obj();
            v122 = v146;
            v126 = os_log_type_enabled(v121, v146);
            if (v125)
            {
              if (v126)
              {
                v127 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                *(_DWORD *)buf = 136447234;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "count";
                *(_WORD *)&v150[8] = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v127;
                v154 = 2082;
                v155 = v125;
                _os_log_impl(&dword_182FBE000, v121, v122, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v125);
              goto LABEL_165;
            }
            if (v126)
            {
              v129 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v129;
              v124 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_164;
            }
          }
          else
          {
            v121 = __nwlog_obj();
            v122 = v146;
            if (os_log_type_enabled(v121, v146))
            {
              v128 = (const char *)*(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v128;
              v124 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_164;
            }
          }
LABEL_165:
          if (v120)
            free(v120);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -1;
          goto LABEL_168;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = (const char *)**(unsigned int **)(a1 + 104);
        *(_DWORD *)buf = 136446978;
        v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
        v149 = 2082;
        *(_QWORD *)v150 = "maximum_frame_count";
        *(_WORD *)&v150[8] = 2048;
        v151 = 1;
        v152 = 2048;
        v153 = v55;
        v56 = (char *)_os_log_send_and_compose_impl();
        v146 = OS_LOG_TYPE_ERROR;
        v144 = 0;
        if (__nwlog_fault(v56, &v146, &v144))
        {
          if (v146 == OS_LOG_TYPE_FAULT)
          {
            v57 = __nwlog_obj();
            v58 = v146;
            if (os_log_type_enabled(v57, v146))
            {
              v59 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v59;
              v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_126:
              _os_log_impl(&dword_182FBE000, v57, v58, v60, buf, 0x2Au);
            }
          }
          else if (v144)
          {
            v64 = (char *)__nw_create_backtrace_string();
            v57 = __nwlog_obj();
            v58 = v146;
            v65 = os_log_type_enabled(v57, v146);
            if (v64)
            {
              if (v65)
              {
                v66 = (const char *)**(unsigned int **)(a1 + 104);
                *(_DWORD *)buf = 136447234;
                v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
                v149 = 2082;
                *(_QWORD *)v150 = "maximum_frame_count";
                *(_WORD *)&v150[8] = 2048;
                v151 = 1;
                v152 = 2048;
                v153 = v66;
                v154 = 2082;
                v155 = v64;
                _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v64);
              goto LABEL_127;
            }
            if (v65)
            {
              v97 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v97;
              v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_126;
            }
          }
          else
          {
            v57 = __nwlog_obj();
            v58 = v146;
            if (os_log_type_enabled(v57, v146))
            {
              v96 = (const char *)**(unsigned int **)(a1 + 104);
              *(_DWORD *)buf = 136446978;
              v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
              v149 = 2082;
              *(_QWORD *)v150 = "maximum_frame_count";
              *(_WORD *)&v150[8] = 2048;
              v151 = 1;
              v152 = 2048;
              v153 = v96;
              v60 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_126;
            }
          }
        }
LABEL_127:
        if (v56)
          free(v56);
        **(_DWORD **)(a1 + 104) = 0;
        goto LABEL_130;
      }
      if (gLogDatapath)
      {
        v28 = __nwlog_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          v29 = **(_DWORD **)(a1 + 72);
          *(_DWORD *)buf = 136446722;
          v148 = "nw_protocol_plugin_metadata_process_frames_block_invoke";
          v149 = 1024;
          *(_DWORD *)v150 = v11;
          *(_WORD *)&v150[4] = 1024;
          *(_DWORD *)&v150[6] = v29;
          _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s not delivering frame with length %u maximum bytes %u", buf, 0x18u);
        }
      }
LABEL_168:
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
      return;
    case 2u:
      goto LABEL_168;
    case 3u:
      v15 = nw_frame_is_metadata_complete(*(_QWORD *)(a1 + 56));
      v16 = *(_QWORD *)(a1 + 56);
      v17 = *(_QWORD *)(v16 + 32);
      v18 = *(_QWORD **)(v16 + 40);
      if (v17)
      {
        *(_QWORD *)(v17 + 40) = v18;
        v18 = *(_QWORD **)(v16 + 40);
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) = v18;
      }
      *v18 = v17;
      *(_QWORD *)(v16 + 32) = 0;
      *(_QWORD *)(v16 + 40) = 0;
      nw_frame_finalize(*(_QWORD *)(a1 + 56));
      if (v15)
      {
        v27 = *(void (**)(_QWORD))(*(_QWORD *)(a1 + 64) + 120);
        if (v27)
          v27(*(_QWORD *)(a1 + 48));
      }
      return;
    default:
      return;
  }
}

uint64_t nw_protocol_plugin_metadata_get_input_frames(_QWORD *a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, uint64_t *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  char v27;
  char *v28;
  uint64_t v29;
  os_log_type_t v30;
  const char *v31;
  char *v32;
  _BOOL4 v33;
  os_log_type_t *v34;
  _QWORD *v35;
  os_log_type_t *v36;
  NSObject *v37;
  BOOL v38;
  char *v39;
  uint64_t v40;
  os_log_type_t v41;
  const char *v42;
  char *v43;
  _BOOL4 v44;
  NSObject *v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  os_log_type_t v49;
  const char *v50;
  char *v51;
  _BOOL4 v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  unsigned int v58;
  unint64_t v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  NSObject *v64;
  const char *v65;
  char *v66;
  _BOOL4 v67;
  NSObject *v68;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  uint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  uint64_t v80;
  void (*v81)(_QWORD *, uint64_t);
  char v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  void *v86;
  uint64_t v87;
  uint64_t v88;
  void (*v89)(_QWORD *, uint64_t);
  void *v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  void (*v96)(_QWORD *, uint64_t);
  _QWORD *v97;
  uint64_t v99;
  uint64_t v100;
  void (**v101)(_QWORD);
  void *v102;
  const void *v103;
  uint64_t v104;
  uint64_t v105;
  void (**v106)(_QWORD);
  const void *v107;
  char *v108;
  NSObject *v109;
  os_log_type_t v110;
  _BOOL4 v111;
  uint64_t v112;
  uint64_t v113;
  void (**v114)(_QWORD);
  void *v115;
  const void *v116;
  uint64_t v117;
  uint64_t v118;
  void (**v119)(_QWORD);
  const void *v120;
  NSObject *v121;
  os_log_type_t v122;
  uint64_t v123;
  uint64_t v124;
  void (**v125)(_QWORD);
  void *v126;
  const void *v127;
  uint64_t v128;
  uint64_t v129;
  void (**v130)(_QWORD);
  const void *v131;
  char *v132;
  NSObject *v133;
  os_log_type_t v134;
  const char *v135;
  char *backtrace_string;
  _BOOL4 v137;
  const char *v138;
  _BOOL4 v139;
  _BOOL4 v140;
  _BOOL4 v141;
  char *v142;
  NSObject *v143;
  os_log_type_t v144;
  const char *v145;
  NSObject *v146;
  _BOOL4 v147;
  const char *v148;
  char *v149;
  NSObject *v150;
  os_log_type_t v151;
  const char *v152;
  const char *v153;
  const char **v154;
  const char *v155;
  char *v156;
  NSObject *v157;
  os_log_type_t v158;
  const char *v159;
  const char *v160;
  char *v161;
  _BOOL4 v162;
  const char *v163;
  _BOOL4 v164;
  NSObject *v165;
  _BOOL4 v166;
  NSObject *v167;
  os_log_type_t v168;
  const char *v169;
  NSObject *v170;
  NSObject *v171;
  char *v172;
  _BOOL4 v173;
  const char *v174;
  NSObject *v175;
  char *v176;
  NSObject *v177;
  os_log_type_t v178;
  const char *v179;
  NSObject *v180;
  os_log_type_t v181;
  const char *v182;
  char *v183;
  _BOOL4 v184;
  const char *v185;
  NSObject *v186;
  int v187;
  int v188;
  NSObject *v189;
  NSObject *v190;
  char *v191;
  _BOOL4 v192;
  char *v193;
  _BOOL4 v194;
  char *v195;
  _BOOL4 v196;
  const char *v197;
  const char *v198;
  const char *v199;
  const char **v200;
  const char *v201;
  char *v202;
  NSObject *v203;
  os_log_type_t v204;
  const char *v205;
  const char *v206;
  const char *v207;
  NSObject *v208;
  int v209;
  char *v210;
  NSObject *v211;
  os_log_type_t v212;
  const char *v213;
  char *v214;
  _BOOL4 v215;
  const char *v216;
  char *v217;
  _BOOL4 v218;
  const char *v219;
  const char *v220;
  NSObject *v221;
  NSObject *v222;
  NSObject *log;
  NSObject *loga;
  unsigned int v225;
  char v228;
  unsigned int v229;
  unsigned int v230;
  unsigned int v231;
  unsigned int v232;
  unsigned int v233;
  uint64_t v234;
  uint64_t *v235;
  uint64_t v236;
  int v237;
  uint64_t v238;
  uint64_t *v239;
  uint64_t v240;
  int v241;
  os_log_type_t type[8];
  os_log_type_t *v243;
  uint64_t v244;
  __n128 (*v245)(uint64_t, uint64_t);
  uint64_t (*v246)();
  _QWORD v247[2];
  int v248;
  const char *v249;
  __int16 v250;
  int v251;
  __int16 v252;
  int v253;
  __int16 v254;
  uint64_t v255;
  __int16 v256;
  uint64_t *v257;
  _QWORD v258[6];
  char v259;
  _QWORD buf[3];
  unint64_t v261;
  _QWORD v262[3];
  unsigned int *v263;
  uint64_t v264;
  unint64_t v265;
  unsigned int *v266;
  unsigned int *v267;
  _QWORD *v268;
  uint64_t v269;
  uint64_t v270;
  char v271;
  uint64_t v272;

  v272 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    v132 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v132, type, v258))
      goto LABEL_414;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null protocol";
      goto LABEL_413;
    }
    if (!LOBYTE(v258[0]))
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_413;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v133 = __nwlog_obj();
    v134 = type[0];
    v137 = os_log_type_enabled(v133, type[0]);
    if (!backtrace_string)
    {
      if (!v137)
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_413;
    }
    if (!v137)
      goto LABEL_320;
    LODWORD(buf[0]) = 136446466;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = backtrace_string;
    v138 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_319:
    _os_log_impl(&dword_182FBE000, v133, v134, v138, (uint8_t *)buf, 0x16u);
    goto LABEL_320;
  }
  v6 = a1[5];
  if (!v6)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    v132 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v132, type, v258))
      goto LABEL_414;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null protocol->handle";
      goto LABEL_413;
    }
    if (!LOBYTE(v258[0]))
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_413;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v133 = __nwlog_obj();
    v134 = type[0];
    v139 = os_log_type_enabled(v133, type[0]);
    if (!backtrace_string)
    {
      if (!v139)
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null protocol->handle, no backtrace";
      goto LABEL_413;
    }
    if (!v139)
      goto LABEL_320;
    LODWORD(buf[0]) = 136446466;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = backtrace_string;
    v138 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
    goto LABEL_319;
  }
  v7 = *(_QWORD *)(v6 + 72);
  if (!v7)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    v132 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v132, type, v258))
      goto LABEL_414;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null metadata_plugin";
      goto LABEL_413;
    }
    if (!LOBYTE(v258[0]))
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_413;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v133 = __nwlog_obj();
    v134 = type[0];
    v140 = os_log_type_enabled(v133, type[0]);
    if (!backtrace_string)
    {
      if (!v140)
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null metadata_plugin, no backtrace";
      goto LABEL_413;
    }
    if (!v140)
      goto LABEL_320;
    LODWORD(buf[0]) = 136446466;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = backtrace_string;
    v138 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
    goto LABEL_319;
  }
  if (!a2)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    v132 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v132, type, v258))
      goto LABEL_414;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null input_protocol";
      goto LABEL_413;
    }
    if (!LOBYTE(v258[0]))
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_413;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v133 = __nwlog_obj();
    v134 = type[0];
    v141 = os_log_type_enabled(v133, type[0]);
    if (!backtrace_string)
    {
      if (!v141)
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_413;
    }
    if (!v141)
      goto LABEL_320;
    LODWORD(buf[0]) = 136446466;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = backtrace_string;
    v138 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_319;
  }
  if (!a6)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    v132 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v132, type, v258))
      goto LABEL_414;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null return_array";
      goto LABEL_413;
    }
    if (!LOBYTE(v258[0]))
    {
      v133 = __nwlog_obj();
      v134 = type[0];
      if (!os_log_type_enabled(v133, type[0]))
        goto LABEL_414;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
      v135 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_413;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v133 = __nwlog_obj();
    v134 = type[0];
    v147 = os_log_type_enabled(v133, type[0]);
    if (backtrace_string)
    {
      if (v147)
      {
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = backtrace_string;
        v138 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_319;
      }
LABEL_320:
      free(backtrace_string);
      goto LABEL_414;
    }
    if (!v147)
      goto LABEL_414;
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
    v135 = "%{public}s called with null return_array, no backtrace";
LABEL_413:
    _os_log_impl(&dword_182FBE000, v133, v134, v135, (uint8_t *)buf, 0xCu);
LABEL_414:
    if (v132)
      free(v132);
    return 0;
  }
  if ((*(_BYTE *)(v7 + 142) & 2) != 0)
  {
    if (gLogDatapath)
    {
      v146 = __nwlog_obj();
      if (os_log_type_enabled(v146, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames";
        _os_log_impl(&dword_182FBE000, v146, OS_LOG_TYPE_DEBUG, "%{public}s get_input_frames called reentrantly, returning", (uint8_t *)buf, 0xCu);
        return 0;
      }
    }
    return 0;
  }
  *(_BYTE *)(v7 + 142) |= 2u;
  v12 = *(_QWORD *)(v6 + 88);
  if (v12 && (*(_BYTE *)(v12 + 212) & 1) == 0)
    *(_BYTE *)(v12 + 212) |= 1u;
  v232 = a4;
  v233 = a3;
  v231 = a5;
  v13 = a1[5];
  if (!v13)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v142 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v142, type, v258))
      goto LABEL_452;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v143 = __nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0]))
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null protocol->handle";
      goto LABEL_451;
    }
    if (!LOBYTE(v258[0]))
    {
      v143 = __nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0]))
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_451;
    }
    v161 = (char *)__nw_create_backtrace_string();
    v143 = __nwlog_obj();
    v144 = type[0];
    v162 = os_log_type_enabled(v143, type[0]);
    if (!v161)
    {
      if (!v162)
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null protocol->handle, no backtrace";
      goto LABEL_451;
    }
    if (!v162)
      goto LABEL_360;
    LODWORD(buf[0]) = 136446466;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = v161;
    v163 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
LABEL_359:
    _os_log_impl(&dword_182FBE000, v143, v144, v163, (uint8_t *)buf, 0x16u);
    goto LABEL_360;
  }
  v14 = *(_QWORD *)(v13 + 72);
  if (!v14)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v142 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v142, type, v258))
      goto LABEL_452;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v143 = __nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0]))
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin";
      goto LABEL_451;
    }
    if (!LOBYTE(v258[0]))
    {
      v143 = __nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0]))
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_451;
    }
    v161 = (char *)__nw_create_backtrace_string();
    v143 = __nwlog_obj();
    v144 = type[0];
    v164 = os_log_type_enabled(v143, type[0]);
    if (!v161)
    {
      if (!v164)
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin, no backtrace";
      goto LABEL_451;
    }
    if (!v164)
      goto LABEL_360;
    LODWORD(buf[0]) = 136446466;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = v161;
    v163 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
    goto LABEL_359;
  }
  if ((*(_BYTE *)(v14 + 142) & 2) == 0)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v142 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (!__nwlog_fault(v142, type, v258))
      goto LABEL_452;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v143 = __nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0]))
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin->getting_input_frames";
      goto LABEL_451;
    }
    if (!LOBYTE(v258[0]))
    {
      v143 = __nwlog_obj();
      v144 = type[0];
      if (!os_log_type_enabled(v143, type[0]))
        goto LABEL_452;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      v145 = "%{public}s called with null metadata_plugin->getting_input_frames, backtrace limit exceeded";
      goto LABEL_451;
    }
    v161 = (char *)__nw_create_backtrace_string();
    v143 = __nwlog_obj();
    v144 = type[0];
    v166 = os_log_type_enabled(v143, type[0]);
    if (v161)
    {
      if (v166)
      {
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v161;
        v163 = "%{public}s called with null metadata_plugin->getting_input_frames, dumping backtrace:%{public}s";
        goto LABEL_359;
      }
LABEL_360:
      free(v161);
      goto LABEL_452;
    }
    if (!v166)
      goto LABEL_452;
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v145 = "%{public}s called with null metadata_plugin->getting_input_frames, no backtrace";
LABEL_451:
    _os_log_impl(&dword_182FBE000, v143, v144, v145, (uint8_t *)buf, 0xCu);
LABEL_452:
    if (v142)
      free(v142);
    goto LABEL_15;
  }
  v229 = 0;
  v230 = 0;
  if (*(_BYTE *)(v14 + 140) == 2)
  {
    if (gLogDatapath)
    {
      v165 = __nwlog_obj();
      if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        _os_log_impl(&dword_182FBE000, v165, OS_LOG_TYPE_DEBUG, "%{public}s cannot process frames, waiting for saved input frames to be resumed", (uint8_t *)buf, 0xCu);
        v15 = 0;
        goto LABEL_148;
      }
    }
LABEL_15:
    v15 = 0;
    goto LABEL_148;
  }
  v16 = (uint64_t *)(v14 + 16);
  if (!*(_QWORD *)(v14 + 16))
  {
    v15 = 0;
    goto LABEL_108;
  }
  v228 = 0;
  if (gLogDatapath)
  {
    v170 = __nwlog_obj();
    if (os_log_type_enabled(v170, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136446978;
      *(_QWORD *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = a3;
      WORD1(buf[2]) = 1024;
      HIDWORD(buf[2]) = a4;
      LOWORD(v261) = 1024;
      *(_DWORD *)((char *)&v261 + 2) = a5;
      _os_log_impl(&dword_182FBE000, v170, OS_LOG_TYPE_DEBUG, "%{public}s called with minimum bytes: %u, maximum bytes: %u, maximum frames: %u", (uint8_t *)buf, 0x1Eu);
    }
  }
  if (a4 >= a3 && a5)
  {
    *(_QWORD *)type = 0;
    v243 = type;
    v244 = 0x3802000000;
    v245 = __Block_byref_object_copy__3150;
    v246 = __Block_byref_object_dispose__3151;
    v247[0] = 0;
    v247[1] = v247;
    v238 = 0;
    v239 = &v238;
    v241 = 0;
    v240 = 0x2000000000;
    v234 = 0;
    v235 = &v234;
    v237 = 0;
    v236 = 0x2000000000;
    v17 = MEMORY[0x1E0C809B0];
    buf[0] = MEMORY[0x1E0C809B0];
    buf[1] = 0x40000000;
    buf[2] = ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke;
    v261 = (unint64_t)&unk_1E149A808;
    v262[0] = &v238;
    v262[1] = &v234;
    v265 = __PAIR64__(a4, a5);
    v263 = (unsigned int *)&v228;
    v264 = v14 + 16;
    LOWORD(v266) = 257;
    v262[2] = type;
    v18 = *v16;
    do
    {
      if (!v18)
        break;
      v19 = *(_QWORD *)(v18 + 32);
      v20 = ((uint64_t (*)(_QWORD *))buf[2])(buf);
      v18 = v19;
    }
    while ((v20 & 1) != 0);
    v21 = *((_QWORD *)v243 + 5);
    v22 = *((_DWORD *)v235 + 6);
    if (v22 < a3 && (v21 ? (v23 = v228 == 0) : (v23 = 0), v23))
    {
      if (gLogDatapath)
      {
        v208 = __nwlog_obj();
        if (os_log_type_enabled(v208, OS_LOG_TYPE_DEBUG))
        {
          v209 = *((_DWORD *)v235 + 6);
          LODWORD(v258[0]) = 136446722;
          *(_QWORD *)((char *)v258 + 4) = "__nw_protocol_fulfill_frame_request";
          WORD2(v258[1]) = 1024;
          *(_DWORD *)((char *)&v258[1] + 6) = a3;
          WORD1(v258[2]) = 1024;
          HIDWORD(v258[2]) = v209;
          _os_log_impl(&dword_182FBE000, v208, OS_LOG_TYPE_DEBUG, "%{public}s could not meet minimum byte count %u with %u bytes from source array", (uint8_t *)v258, 0x18u);
        }
      }
      v34 = v243;
      v35 = v243 + 40;
      if (*v16)
      {
        **((_QWORD **)v243 + 6) = *v16;
        *(_QWORD *)(*(_QWORD *)(v14 + 16) + 40) = *((_QWORD *)v34 + 6);
        *((_QWORD *)v34 + 6) = *(_QWORD *)(v14 + 24);
        *(_QWORD *)(v14 + 16) = 0;
        *(_QWORD *)(v14 + 24) = v16;
      }
      if (*v35)
      {
        **(_QWORD **)(v14 + 24) = *v35;
        *(_QWORD *)(*((_QWORD *)v34 + 5) + 40) = *(_QWORD *)(v14 + 24);
        *(_QWORD *)(v14 + 24) = *((_QWORD *)v34 + 6);
        *((_QWORD *)v34 + 5) = 0;
        *((_QWORD *)v34 + 6) = v35;
      }
      v25 = 0;
      v36 = v243;
      *((_QWORD *)v243 + 5) = 0;
      *((_QWORD *)v36 + 6) = v36 + 40;
      *((_DWORD *)v239 + 6) = 0;
      *((_DWORD *)v235 + 6) = 0;
    }
    else if (v21)
    {
      v258[0] = v17;
      v258[1] = 0x40000000;
      v258[2] = ___ZL35__nw_protocol_fulfill_frame_requestP16nw_frame_array_sS0_bbjjjPjPb_block_invoke_25;
      v258[3] = &unk_1E149A830;
      v259 = 1;
      v258[4] = type;
      v258[5] = a6;
      v24 = *((_QWORD *)v243 + 5);
      v25 = v22;
      do
      {
        if (!v24)
          break;
        v26 = *(_QWORD *)(v24 + 32);
        v27 = ((uint64_t (*)(_QWORD *))v258[2])(v258);
        v24 = v26;
      }
      while ((v27 & 1) != 0);
    }
    else
    {
      v25 = *((_DWORD *)v235 + 6);
    }
    if (gLogDatapath)
    {
      v186 = __nwlog_obj();
      if (os_log_type_enabled(v186, OS_LOG_TYPE_DEBUG))
      {
        v187 = *((_DWORD *)v239 + 6);
        v188 = *((_DWORD *)v235 + 6);
        v248 = 136447234;
        v249 = "__nw_protocol_fulfill_frame_request";
        v250 = 1024;
        v251 = v187;
        v252 = 1024;
        v253 = v188;
        v254 = 2048;
        v255 = v14 + 16;
        v256 = 2048;
        v257 = a6;
        _os_log_impl(&dword_182FBE000, v186, OS_LOG_TYPE_DEBUG, "%{public}s moved (%u frames, %u bytes) from %p to %p", (uint8_t *)&v248, 0x2Cu);
      }
    }
    v15 = *((unsigned int *)v239 + 6);
    _Block_object_dispose(&v234, 8);
    _Block_object_dispose(&v238, 8);
    _Block_object_dispose(type, 8);
    goto LABEL_61;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  LODWORD(buf[0]) = 136446978;
  *(_QWORD *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
  WORD2(buf[1]) = 1024;
  *(_DWORD *)((char *)&buf[1] + 6) = a4;
  WORD1(buf[2]) = 1024;
  HIDWORD(buf[2]) = a3;
  LOWORD(v261) = 1024;
  *(_DWORD *)((char *)&v261 + 2) = a5;
  v28 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v258[0]) = 0;
  if (__nwlog_fault(v28, type, v258))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v29 = gLogObj;
      v30 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = a4;
        WORD1(buf[2]) = 1024;
        HIDWORD(buf[2]) = a3;
        LOWORD(v261) = 1024;
        *(_DWORD *)((char *)&v261 + 2) = a5;
        v31 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u";
LABEL_56:
        v37 = v29;
LABEL_57:
        _os_log_impl(&dword_182FBE000, v37, v30, v31, (uint8_t *)buf, 0x1Eu);
      }
    }
    else if (LOBYTE(v258[0]))
    {
      v32 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = type[0];
      log = gLogObj;
      v33 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v32)
      {
        if (v33)
        {
          LODWORD(buf[0]) = 136447234;
          *(_QWORD *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = a4;
          WORD1(buf[2]) = 1024;
          HIDWORD(buf[2]) = a3;
          LOWORD(v261) = 1024;
          *(_DWORD *)((char *)&v261 + 2) = a5;
          HIWORD(v261) = 2082;
          v262[0] = v32;
          _os_log_impl(&dword_182FBE000, log, v30, "%{public}s invalid values for frame request, max %u, min %u, max frame %u, dumping backtrace:%{public}s", (uint8_t *)buf, 0x28u);
        }
        free(v32);
        goto LABEL_58;
      }
      if (v33)
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = a4;
        WORD1(buf[2]) = 1024;
        HIDWORD(buf[2]) = a3;
        LOWORD(v261) = 1024;
        *(_DWORD *)((char *)&v261 + 2) = a5;
        v31 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, no backtrace";
        v37 = log;
        goto LABEL_57;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v29 = gLogObj;
      v30 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_fulfill_frame_request";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = a4;
        WORD1(buf[2]) = 1024;
        HIDWORD(buf[2]) = a3;
        LOWORD(v261) = 1024;
        *(_DWORD *)((char *)&v261 + 2) = a5;
        v31 = "%{public}s invalid values for frame request, max %u, min %u, max frame %u, backtrace limit exceeded";
        goto LABEL_56;
      }
    }
  }
LABEL_58:
  if (v28)
    free(v28);
  v25 = 0;
  v15 = 0;
LABEL_61:
  v38 = v233 >= v25;
  v233 -= v25;
  if (!v38)
  {
    if (gLogDatapath)
    {
      v189 = __nwlog_obj();
      if (os_log_type_enabled(v189, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "minimum_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v25;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v233;
        _os_log_impl(&dword_182FBE000, v189, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", (uint8_t *)buf, 0x2Au);
      }
    }
    v233 = 0;
  }
  v38 = v232 >= v25;
  v232 -= v25;
  if (!v38)
  {
    if (gLogDatapath)
    {
      v190 = __nwlog_obj();
      if (os_log_type_enabled(v190, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "maximum_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v25;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v232;
        _os_log_impl(&dword_182FBE000, v190, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", (uint8_t *)buf, 0x2Au);
      }
    }
    v232 = 0;
  }
  v38 = v231 >= v15;
  v231 -= v15;
  v225 = v25;
  if (!v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    LODWORD(buf[0]) = 136446978;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = "maximum_frame_count";
    HIWORD(buf[2]) = 2048;
    v261 = v15;
    LOWORD(v262[0]) = 2048;
    *(_QWORD *)((char *)v262 + 2) = v231;
    v39 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (__nwlog_fault(v39, type, v258))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = gLogObj;
        v41 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          LODWORD(buf[0]) = 136446978;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = "maximum_frame_count";
          HIWORD(buf[2]) = 2048;
          v261 = v15;
          LOWORD(v262[0]) = 2048;
          *(_QWORD *)((char *)v262 + 2) = v231;
          v42 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_79:
          v45 = v40;
LABEL_80:
          _os_log_impl(&dword_182FBE000, v45, v41, v42, (uint8_t *)buf, 0x2Au);
        }
      }
      else if (LOBYTE(v258[0]))
      {
        v43 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = type[0];
        v221 = gLogObj;
        v44 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v43)
        {
          if (v44)
          {
            LODWORD(buf[0]) = 136447234;
            *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = "maximum_frame_count";
            HIWORD(buf[2]) = 2048;
            v261 = v15;
            LOWORD(v262[0]) = 2048;
            *(_QWORD *)((char *)v262 + 2) = v231;
            WORD1(v262[1]) = 2082;
            *(_QWORD *)((char *)&v262[1] + 4) = v43;
            _os_log_impl(&dword_182FBE000, v221, v41, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", (uint8_t *)buf, 0x34u);
          }
          free(v43);
          goto LABEL_81;
        }
        if (v44)
        {
          LODWORD(buf[0]) = 136446978;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = "maximum_frame_count";
          HIWORD(buf[2]) = 2048;
          v261 = v15;
          LOWORD(v262[0]) = 2048;
          *(_QWORD *)((char *)v262 + 2) = v231;
          v42 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          v45 = v221;
          goto LABEL_80;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = gLogObj;
        v41 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          LODWORD(buf[0]) = 136446978;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = "maximum_frame_count";
          HIWORD(buf[2]) = 2048;
          v261 = v15;
          LOWORD(v262[0]) = 2048;
          *(_QWORD *)((char *)v262 + 2) = v231;
          v42 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_79;
        }
      }
    }
LABEL_81:
    if (v39)
      free(v39);
    v231 = 0;
    v25 = v225;
  }
  v38 = __CFADD__(v229, v25);
  v229 += v25;
  if (!v38)
    goto LABEL_102;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v46 = v25;
  LODWORD(buf[0]) = 136446978;
  *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
  WORD2(buf[1]) = 2082;
  *(_QWORD *)((char *)&buf[1] + 6) = "received_bytes";
  HIWORD(buf[2]) = 2048;
  v261 = v25;
  LOWORD(v262[0]) = 2048;
  *(_QWORD *)((char *)v262 + 2) = v229;
  v47 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v258[0]) = 0;
  if (__nwlog_fault(v47, type, v258))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = gLogObj;
      v49 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "received_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v46;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v229;
        v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_97:
        v53 = v48;
LABEL_98:
        _os_log_impl(&dword_182FBE000, v53, v49, v50, (uint8_t *)buf, 0x2Au);
      }
    }
    else if (LOBYTE(v258[0]))
    {
      v51 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v49 = type[0];
      v222 = gLogObj;
      v52 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v51)
      {
        if (v52)
        {
          LODWORD(buf[0]) = 136447234;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = "received_bytes";
          HIWORD(buf[2]) = 2048;
          v261 = v46;
          LOWORD(v262[0]) = 2048;
          *(_QWORD *)((char *)v262 + 2) = v229;
          WORD1(v262[1]) = 2082;
          *(_QWORD *)((char *)&v262[1] + 4) = v51;
          _os_log_impl(&dword_182FBE000, v222, v49, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", (uint8_t *)buf, 0x34u);
        }
        free(v51);
        goto LABEL_99;
      }
      if (v52)
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "received_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v46;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v229;
        v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        v53 = v222;
        goto LABEL_98;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = gLogObj;
      v49 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "received_bytes";
        HIWORD(buf[2]) = 2048;
        v261 = v46;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v229;
        v50 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_97;
      }
    }
  }
LABEL_99:
  if (v47)
    free(v47);
  v229 = -1;
  v25 = v225;
LABEL_102:
  v230 = v15;
  if (v228)
    v233 = 0;
  if (gLogDatapath)
  {
    v171 = __nwlog_obj();
    if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136446722;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = v25;
      WORD1(buf[2]) = 1024;
      HIDWORD(buf[2]) = v15;
      _os_log_impl(&dword_182FBE000, v171, OS_LOG_TYPE_DEBUG, "%{public}s moved (%u bytes, %u frames) from input_frames_pending_delivery", (uint8_t *)buf, 0x18u);
    }
  }
  if ((_DWORD)v15 && (!v232 || !v231))
  {
    if (!gLogDatapath)
      goto LABEL_147;
    v64 = __nwlog_obj();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      goto LABEL_147;
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v65 = "%{public}s returning frames only from input_frames_pending_delivery";
LABEL_464:
    _os_log_impl(&dword_182FBE000, v64, OS_LOG_TYPE_DEBUG, v65, (uint8_t *)buf, 0xCu);
    goto LABEL_147;
  }
LABEL_108:
  if (*(_QWORD *)v14)
  {
    if (gLogDatapath)
    {
      v175 = __nwlog_obj();
      if (os_log_type_enabled(v175, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        _os_log_impl(&dword_182FBE000, v175, OS_LOG_TYPE_DEBUG, "%{public}s resuming saved input frames", (uint8_t *)buf, 0xCu);
      }
    }
    v54 = *(_QWORD *)(v14 + 96);
    if (v54)
    {
      *(_QWORD *)type = 0;
      v243 = type;
      LODWORD(v245) = 0;
      v244 = 0x2000000000;
      buf[0] = MEMORY[0x1E0C809B0];
      buf[1] = 0x40000000;
      buf[2] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
      v261 = (unint64_t)&unk_1E149A880;
      v262[2] = v14;
      v263 = &v232;
      v271 = 1;
      v266 = &v233;
      v267 = &v229;
      v264 = v14;
      v265 = (unint64_t)a6;
      v262[0] = type;
      v262[1] = &v231;
      v268 = a1;
      v269 = v54;
      v270 = a2;
      v55 = *(_QWORD *)v14;
      do
      {
        if (!v55)
          break;
        v56 = *(_QWORD *)(v55 + 32);
        v57 = ((uint64_t (*)(_QWORD *))buf[2])(buf);
        v55 = v56;
      }
      while ((v57 & 1) != 0);
      v58 = *((_DWORD *)v243 + 6);
      _Block_object_dispose(type, 8);
      goto LABEL_115;
    }
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
    v176 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (__nwlog_fault(v176, type, v258))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v177 = __nwlog_obj();
        v178 = type[0];
        if (os_log_type_enabled(v177, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
          v179 = "%{public}s called with null processor";
LABEL_513:
          _os_log_impl(&dword_182FBE000, v177, v178, v179, (uint8_t *)buf, 0xCu);
        }
      }
      else if (LOBYTE(v258[0]))
      {
        v193 = (char *)__nw_create_backtrace_string();
        v177 = __nwlog_obj();
        v178 = type[0];
        v194 = os_log_type_enabled(v177, type[0]);
        if (v193)
        {
          if (v194)
          {
            LODWORD(buf[0]) = 136446466;
            *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v193;
            _os_log_impl(&dword_182FBE000, v177, v178, "%{public}s called with null processor, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
          }
          free(v193);
          goto LABEL_514;
        }
        if (v194)
        {
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
          v179 = "%{public}s called with null processor, no backtrace";
          goto LABEL_513;
        }
      }
      else
      {
        v177 = __nwlog_obj();
        v178 = type[0];
        if (os_log_type_enabled(v177, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_process_frames";
          v179 = "%{public}s called with null processor, backtrace limit exceeded";
          goto LABEL_513;
        }
      }
    }
LABEL_514:
    if (v176)
      free(v176);
    v58 = 0;
LABEL_115:
    v38 = __CFADD__((_DWORD)v15, v58);
    v15 = v15 + v58;
    v230 = v15;
    if (!v38)
      goto LABEL_121;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    LODWORD(buf[0]) = 136446978;
    v59 = v58;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    WORD2(buf[1]) = 2082;
    *(_QWORD *)((char *)&buf[1] + 6) = "count";
    HIWORD(buf[2]) = 2048;
    v261 = v58;
    LOWORD(v262[0]) = 2048;
    *(_QWORD *)((char *)v262 + 2) = v15;
    v60 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (__nwlog_fault(v60, type, v258))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v61 = gLogObj;
        v62 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_136;
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "count";
        HIWORD(buf[2]) = 2048;
        v261 = v59;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v15;
        v63 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_134:
        v68 = v61;
LABEL_135:
        _os_log_impl(&dword_182FBE000, v68, v62, v63, (uint8_t *)buf, 0x2Au);
        goto LABEL_136;
      }
      if (!LOBYTE(v258[0]))
      {
        v61 = __nwlog_obj();
        v62 = type[0];
        if (!os_log_type_enabled(v61, type[0]))
          goto LABEL_136;
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "count";
        HIWORD(buf[2]) = 2048;
        v261 = v59;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v15;
        v63 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_134;
      }
      v66 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v62 = type[0];
      loga = gLogObj;
      v67 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v66)
      {
        if (v67)
        {
          LODWORD(buf[0]) = 136447234;
          *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = "count";
          HIWORD(buf[2]) = 2048;
          v261 = v59;
          LOWORD(v262[0]) = 2048;
          *(_QWORD *)((char *)v262 + 2) = v15;
          WORD1(v262[1]) = 2082;
          *(_QWORD *)((char *)&v262[1] + 4) = v66;
          _os_log_impl(&dword_182FBE000, loga, v62, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", (uint8_t *)buf, 0x34u);
        }
        free(v66);
      }
      else if (v67)
      {
        LODWORD(buf[0]) = 136446978;
        *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = "count";
        HIWORD(buf[2]) = 2048;
        v261 = v59;
        LOWORD(v262[0]) = 2048;
        *(_QWORD *)((char *)v262 + 2) = v15;
        v63 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        v68 = loga;
        goto LABEL_135;
      }
    }
LABEL_136:
    if (v60)
      free(v60);
    v15 = 0xFFFFFFFFLL;
    v230 = -1;
    if (*(_BYTE *)(v14 + 140) == 2)
      goto LABEL_147;
    goto LABEL_139;
  }
LABEL_121:
  if (*(_BYTE *)(v14 + 140) == 2)
  {
LABEL_147:
    nw_protocol_plugin_metadata_report_transfer(v14, (uint64_t)a1, *(_QWORD *)(v14 + 48), v229, 1);
    goto LABEL_148;
  }
  if (!(_DWORD)v15)
    goto LABEL_141;
LABEL_139:
  if (!v232 || !v231)
  {
    if (!gLogDatapath)
      goto LABEL_147;
    v64 = __nwlog_obj();
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      goto LABEL_147;
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v65 = "%{public}s returning frames from input_frames_pending_delivery and saved input frames";
    goto LABEL_464;
  }
LABEL_141:
  if (!*(_QWORD *)v14)
  {
    nw_protocol_plugin_metadata_get_and_process_frames(v14, a1, a2, a3, &v233, &v232, &v231, &v230, &v229, *(_QWORD *)(v14 + 96), a6);
    v15 = v230;
    goto LABEL_148;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  LODWORD(buf[0]) = 136446210;
  *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
  v69 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v258[0]) = 0;
  if (!__nwlog_fault(v69, type, v258))
    goto LABEL_250;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v70 = gLogObj;
    v71 = type[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
      goto LABEL_250;
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v72 = "%{public}s Getting new input from below, but we still have saved input frames that we didn't use";
LABEL_248:
    v121 = v70;
    v122 = v71;
LABEL_249:
    _os_log_impl(&dword_182FBE000, v121, v122, v72, (uint8_t *)buf, 0xCu);
    goto LABEL_250;
  }
  if (!LOBYTE(v258[0]))
  {
    v70 = __nwlog_obj();
    v71 = type[0];
    if (!os_log_type_enabled(v70, type[0]))
      goto LABEL_250;
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v72 = "%{public}s Getting new input from below, but we still have saved input frames that we didn't use, backtrace limit exceeded";
    goto LABEL_248;
  }
  v108 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v109 = gLogObj;
  v110 = type[0];
  v111 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
  if (v108)
  {
    if (v111)
    {
      LODWORD(buf[0]) = 136446466;
      *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = v108;
      _os_log_impl(&dword_182FBE000, v109, v110, "%{public}s Getting new input from below, but we still have saved input frames that we didn't use, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
    }
    free(v108);
    goto LABEL_250;
  }
  if (v111)
  {
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_protocol_plugin_metadata_get_input_frames_internal";
    v72 = "%{public}s Getting new input from below, but we still have saved input frames that we didn't use, no backtrace";
    v121 = v109;
    v122 = v110;
    goto LABEL_249;
  }
LABEL_250:
  if (v69)
    free(v69);
LABEL_148:
  *(_BYTE *)(v7 + 142) &= ~2u;
  v73 = *(_QWORD *)(v6 + 88);
  if (v73)
    nw_protocol_plugin_retry_set_getting_input_frames(v73, (uint64_t)a1, 0);
  if (*(_BYTE *)(v7 + 140) != 2)
  {
    v74 = a1;
    if (!*(_DWORD *)(v7 + 136))
      goto LABEL_166;
    *(_DWORD *)(v7 + 136) = 0;
    v75 = a1[4];
    v76 = (void *)a1[5];
    if (v76 == &nw_protocol_ref_counted_handle)
    {
      v77 = a1[11];
      if (v77)
        a1[11] = v77 + 1;
    }
    if (v75)
    {
      v78 = *(void **)(v75 + 40);
      if (v78 == &nw_protocol_ref_counted_handle)
      {
        v79 = *(_QWORD *)(v75 + 88);
        if (v79)
          *(_QWORD *)(v75 + 88) = v79 + 1;
      }
      v80 = a1[3];
      if (v80)
      {
        v81 = *(void (**)(_QWORD *, uint64_t))(v80 + 56);
        if (v81)
        {
          v81(a1, v75);
LABEL_162:
          v74 = a1;
          if (v78 != &nw_protocol_ref_counted_handle
            || *(_UNKNOWN **)(v75 + 40) != &nw_protocol_ref_counted_handle
            || (v104 = *(_QWORD *)(v75 + 88)) == 0
            || (v105 = v104 - 1, (*(_QWORD *)(v75 + 88) = v105) != 0))
          {
LABEL_164:
            if (v76 == &nw_protocol_ref_counted_handle && (_UNKNOWN *)v74[5] == &nw_protocol_ref_counted_handle)
            {
              v99 = v74[11];
              if (v99)
              {
                v100 = v99 - 1;
                v74[11] = v100;
                if (!v100)
                {
                  v101 = (void (**)(_QWORD))v74[8];
                  if (v101)
                  {
                    v74[8] = 0;
                    v101[2](v101);
                    _Block_release(v101);
                    v74 = a1;
                  }
                  v102 = v74;
                  if ((v74[9] & 1) != 0)
                  {
                    v103 = (const void *)v74[8];
                    if (v103)
                      _Block_release(v103);
                  }
                  free(v102);
                  v74 = v102;
                }
              }
            }
LABEL_166:
            v82 = *(_BYTE *)(v7 + 142);
            if ((v82 & 4) == 0 || *(_QWORD *)v7 || *(_QWORD *)(v7 + 16))
              goto LABEL_184;
            *(_BYTE *)(v7 + 142) = v82 & 0xFB;
            v83 = v74[4];
            v84 = (void *)v74[5];
            if (v84 == &nw_protocol_ref_counted_handle)
            {
              v85 = v74[11];
              if (v85)
                v74[11] = v85 + 1;
            }
            if (v83)
            {
              v86 = *(void **)(v83 + 40);
              if (v86 == &nw_protocol_ref_counted_handle)
              {
                v87 = *(_QWORD *)(v83 + 88);
                if (v87)
                  *(_QWORD *)(v83 + 88) = v87 + 1;
              }
              v88 = v74[3];
              if (v88)
              {
                v89 = *(void (**)(_QWORD *, uint64_t))(v88 + 184);
                if (v89)
                {
                  v89(v74, v83);
LABEL_179:
                  v74 = a1;
                  if (v86 != &nw_protocol_ref_counted_handle)
                    goto LABEL_181;
                  if (*(_UNKNOWN **)(v83 + 40) != &nw_protocol_ref_counted_handle)
                    goto LABEL_181;
                  v128 = *(_QWORD *)(v83 + 88);
                  if (!v128)
                    goto LABEL_181;
                  v129 = v128 - 1;
                  *(_QWORD *)(v83 + 88) = v129;
                  if (v129)
                    goto LABEL_181;
                  v130 = *(void (***)(_QWORD))(v83 + 64);
                  if (v130)
                  {
                    *(_QWORD *)(v83 + 64) = 0;
                    v130[2](v130);
                    _Block_release(v130);
                  }
                  if ((*(_BYTE *)(v83 + 72) & 1) != 0)
                  {
                    v131 = *(const void **)(v83 + 64);
                    if (v131)
                      _Block_release(v131);
                  }
                  free((void *)v83);
LABEL_272:
                  v74 = a1;
LABEL_181:
                  if (v84 == &nw_protocol_ref_counted_handle && (_UNKNOWN *)v74[5] == &nw_protocol_ref_counted_handle)
                  {
                    v123 = v74[11];
                    if (v123)
                    {
                      v124 = v123 - 1;
                      v74[11] = v124;
                      if (!v124)
                      {
                        v125 = (void (**)(_QWORD))v74[8];
                        if (v125)
                        {
                          v74[8] = 0;
                          v125[2](v125);
                          _Block_release(v125);
                          v74 = a1;
                        }
                        v126 = v74;
                        if ((v74[9] & 1) != 0)
                        {
                          v127 = (const void *)v74[8];
                          if (v127)
                            _Block_release(v127);
                        }
                        free(v126);
                        v74 = v126;
                      }
                    }
                  }
                  v82 = *(_BYTE *)(v7 + 142);
LABEL_184:
                  if ((v82 & 8) == 0)
                    return v15;
                  *(_BYTE *)(v7 + 142) = v82 & 0xF7;
                  v91 = v74[4];
                  v90 = (void *)v74[5];
                  if (v90 == &nw_protocol_ref_counted_handle)
                  {
                    v92 = v74[11];
                    if (v92)
                      v74[11] = v92 + 1;
                  }
                  if (v91)
                  {
                    v93 = *(void **)(v91 + 40);
                    if (v93 == &nw_protocol_ref_counted_handle)
                    {
                      v94 = *(_QWORD *)(v91 + 88);
                      if (v94)
                        *(_QWORD *)(v91 + 88) = v94 + 1;
                    }
                    v95 = v74[3];
                    if (v95)
                    {
                      v96 = *(void (**)(_QWORD *, uint64_t))(v95 + 48);
                      if (v96)
                      {
                        v96(v74, v91);
LABEL_195:
                        v97 = a1;
                        if (v93 != &nw_protocol_ref_counted_handle
                          || *(_UNKNOWN **)(v91 + 40) != &nw_protocol_ref_counted_handle
                          || (v117 = *(_QWORD *)(v91 + 88)) == 0
                          || (v118 = v117 - 1, (*(_QWORD *)(v91 + 88) = v118) != 0))
                        {
LABEL_197:
                          if (v90 == &nw_protocol_ref_counted_handle
                            && (_UNKNOWN *)v97[5] == &nw_protocol_ref_counted_handle)
                          {
                            v112 = v97[11];
                            if (v112)
                            {
                              v113 = v112 - 1;
                              v97[11] = v113;
                              if (!v113)
                              {
                                v114 = (void (**)(_QWORD))v97[8];
                                if (v114)
                                {
                                  v97[8] = 0;
                                  v114[2](v114);
                                  _Block_release(v114);
                                  v97 = a1;
                                }
                                v115 = v97;
                                if ((v97[9] & 1) != 0)
                                {
                                  v116 = (const void *)v97[8];
                                  if (v116)
                                    _Block_release(v116);
                                }
                                free(v115);
                              }
                            }
                          }
                          return v15;
                        }
                        v119 = *(void (***)(_QWORD))(v91 + 64);
                        if (v119)
                        {
                          *(_QWORD *)(v91 + 64) = 0;
                          v119[2](v119);
                          _Block_release(v119);
                        }
                        if ((*(_BYTE *)(v91 + 72) & 1) != 0)
                        {
                          v120 = *(const void **)(v91 + 64);
                          if (v120)
                            _Block_release(v120);
                        }
LABEL_238:
                        free((void *)v91);
LABEL_239:
                        v97 = a1;
                        goto LABEL_197;
                      }
                    }
                    v154 = (const char **)v74;
                    __nwlog_obj();
                    v155 = v154[2];
                    LODWORD(buf[0]) = 136446722;
                    *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                    if (!v155)
                      v155 = "invalid";
                    WORD2(buf[1]) = 2082;
                    *(_QWORD *)((char *)&buf[1] + 6) = v155;
                    HIWORD(buf[2]) = 2048;
                    v261 = (unint64_t)v154;
                    v156 = (char *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    LOBYTE(v258[0]) = 0;
                    if (__nwlog_fault(v156, type, v258))
                    {
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        v157 = __nwlog_obj();
                        v158 = type[0];
                        if (!os_log_type_enabled(v157, type[0]))
                          goto LABEL_485;
                        v159 = (const char *)a1[2];
                        if (!v159)
                          v159 = "invalid";
                        LODWORD(buf[0]) = 136446722;
                        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = v159;
                        HIWORD(buf[2]) = 2048;
                        v261 = (unint64_t)a1;
                        v160 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
                        goto LABEL_484;
                      }
                      if (!LOBYTE(v258[0]))
                      {
                        v157 = __nwlog_obj();
                        v158 = type[0];
                        if (!os_log_type_enabled(v157, type[0]))
                          goto LABEL_485;
                        v198 = (const char *)a1[2];
                        if (!v198)
                          v198 = "invalid";
                        LODWORD(buf[0]) = 136446722;
                        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = v198;
                        HIWORD(buf[2]) = 2048;
                        v261 = (unint64_t)a1;
                        v160 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
                        goto LABEL_484;
                      }
                      v183 = (char *)__nw_create_backtrace_string();
                      v157 = __nwlog_obj();
                      v158 = type[0];
                      v184 = os_log_type_enabled(v157, type[0]);
                      if (v183)
                      {
                        if (v184)
                        {
                          v185 = (const char *)a1[2];
                          if (!v185)
                            v185 = "invalid";
                          LODWORD(buf[0]) = 136446978;
                          *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                          WORD2(buf[1]) = 2082;
                          *(_QWORD *)((char *)&buf[1] + 6) = v185;
                          HIWORD(buf[2]) = 2048;
                          v261 = (unint64_t)a1;
                          LOWORD(v262[0]) = 2082;
                          *(_QWORD *)((char *)v262 + 2) = v183;
                          _os_log_impl(&dword_182FBE000, v157, v158, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x2Au);
                        }
                        free(v183);
                        goto LABEL_485;
                      }
                      if (v184)
                      {
                        v207 = (const char *)a1[2];
                        if (!v207)
                          v207 = "invalid";
                        LODWORD(buf[0]) = 136446722;
                        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = v207;
                        HIWORD(buf[2]) = 2048;
                        v261 = (unint64_t)a1;
                        v160 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_484:
                        _os_log_impl(&dword_182FBE000, v157, v158, v160, (uint8_t *)buf, 0x20u);
                      }
                    }
LABEL_485:
                    if (v156)
                      free(v156);
                    goto LABEL_195;
                  }
                  __nwlog_obj();
                  LODWORD(buf[0]) = 136446210;
                  *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                  v91 = _os_log_send_and_compose_impl();
                  type[0] = OS_LOG_TYPE_ERROR;
                  LOBYTE(v258[0]) = 0;
                  if (__nwlog_fault((const char *)v91, type, v258))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v180 = __nwlog_obj();
                      v181 = type[0];
                      if (!os_log_type_enabled(v180, type[0]))
                        goto LABEL_520;
                      LODWORD(buf[0]) = 136446210;
                      *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                      v182 = "%{public}s called with null other_protocol";
                      goto LABEL_519;
                    }
                    if (!LOBYTE(v258[0]))
                    {
                      v180 = __nwlog_obj();
                      v181 = type[0];
                      if (!os_log_type_enabled(v180, type[0]))
                        goto LABEL_520;
                      LODWORD(buf[0]) = 136446210;
                      *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                      v182 = "%{public}s called with null other_protocol, backtrace limit exceeded";
                      goto LABEL_519;
                    }
                    v195 = (char *)__nw_create_backtrace_string();
                    v180 = __nwlog_obj();
                    v181 = type[0];
                    v196 = os_log_type_enabled(v180, type[0]);
                    if (v195)
                    {
                      if (v196)
                      {
                        LODWORD(buf[0]) = 136446466;
                        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                        WORD2(buf[1]) = 2082;
                        *(_QWORD *)((char *)&buf[1] + 6) = v195;
                        _os_log_impl(&dword_182FBE000, v180, v181, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
                      }
                      free(v195);
                      if (!v91)
                        goto LABEL_239;
                      goto LABEL_238;
                    }
                    if (v196)
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(_QWORD *)((char *)buf + 4) = "__nw_protocol_disconnected";
                      v182 = "%{public}s called with null other_protocol, no backtrace";
LABEL_519:
                      _os_log_impl(&dword_182FBE000, v180, v181, v182, (uint8_t *)buf, 0xCu);
                    }
                  }
LABEL_520:
                  if (!v91)
                    goto LABEL_239;
                  goto LABEL_238;
                }
              }
              v200 = (const char **)v74;
              __nwlog_obj();
              v201 = v200[2];
              LODWORD(buf[0]) = 136446722;
              *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
              if (!v201)
                v201 = "invalid";
              WORD2(buf[1]) = 2082;
              *(_QWORD *)((char *)&buf[1] + 6) = v201;
              HIWORD(buf[2]) = 2048;
              v261 = (unint64_t)v200;
              v202 = (char *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v258[0]) = 0;
              if (__nwlog_fault(v202, type, v258))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  v203 = __nwlog_obj();
                  v204 = type[0];
                  if (!os_log_type_enabled(v203, type[0]))
                    goto LABEL_536;
                  v205 = (const char *)a1[2];
                  if (!v205)
                    v205 = "invalid";
                  LODWORD(buf[0]) = 136446722;
                  *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v205;
                  HIWORD(buf[2]) = 2048;
                  v261 = (unint64_t)a1;
                  v206 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback";
                  goto LABEL_535;
                }
                if (!LOBYTE(v258[0]))
                {
                  v203 = __nwlog_obj();
                  v204 = type[0];
                  if (!os_log_type_enabled(v203, type[0]))
                    goto LABEL_536;
                  v219 = (const char *)a1[2];
                  if (!v219)
                    v219 = "invalid";
                  LODWORD(buf[0]) = 136446722;
                  *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v219;
                  HIWORD(buf[2]) = 2048;
                  v261 = (unint64_t)a1;
                  v206 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded";
                  goto LABEL_535;
                }
                v214 = (char *)__nw_create_backtrace_string();
                v203 = __nwlog_obj();
                v204 = type[0];
                v215 = os_log_type_enabled(v203, type[0]);
                if (v214)
                {
                  if (v215)
                  {
                    v216 = (const char *)a1[2];
                    if (!v216)
                      v216 = "invalid";
                    LODWORD(buf[0]) = 136446978;
                    *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                    WORD2(buf[1]) = 2082;
                    *(_QWORD *)((char *)&buf[1] + 6) = v216;
                    HIWORD(buf[2]) = 2048;
                    v261 = (unint64_t)a1;
                    LOWORD(v262[0]) = 2082;
                    *(_QWORD *)((char *)v262 + 2) = v214;
                    _os_log_impl(&dword_182FBE000, v203, v204, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x2Au);
                  }
                  free(v214);
                  goto LABEL_536;
                }
                if (v215)
                {
                  v220 = (const char *)a1[2];
                  if (!v220)
                    v220 = "invalid";
                  LODWORD(buf[0]) = 136446722;
                  *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v220;
                  HIWORD(buf[2]) = 2048;
                  v261 = (unint64_t)a1;
                  v206 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace";
LABEL_535:
                  _os_log_impl(&dword_182FBE000, v203, v204, v206, (uint8_t *)buf, 0x20u);
                }
              }
LABEL_536:
              if (v202)
                free(v202);
              goto LABEL_179;
            }
            __nwlog_obj();
            LODWORD(buf[0]) = 136446210;
            *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
            v210 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v258[0]) = 0;
            if (__nwlog_fault(v210, type, v258))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                v211 = __nwlog_obj();
                v212 = type[0];
                if (!os_log_type_enabled(v211, type[0]))
                  goto LABEL_543;
                LODWORD(buf[0]) = 136446210;
                *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                v213 = "%{public}s called with null other_protocol";
                goto LABEL_542;
              }
              if (!LOBYTE(v258[0]))
              {
                v211 = __nwlog_obj();
                v212 = type[0];
                if (!os_log_type_enabled(v211, type[0]))
                  goto LABEL_543;
                LODWORD(buf[0]) = 136446210;
                *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                v213 = "%{public}s called with null other_protocol, backtrace limit exceeded";
                goto LABEL_542;
              }
              v217 = (char *)__nw_create_backtrace_string();
              v211 = __nwlog_obj();
              v212 = type[0];
              v218 = os_log_type_enabled(v211, type[0]);
              if (v217)
              {
                if (v218)
                {
                  LODWORD(buf[0]) = 136446466;
                  *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                  WORD2(buf[1]) = 2082;
                  *(_QWORD *)((char *)&buf[1] + 6) = v217;
                  _os_log_impl(&dword_182FBE000, v211, v212, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
                }
                free(v217);
                goto LABEL_543;
              }
              if (v218)
              {
                LODWORD(buf[0]) = 136446210;
                *(_QWORD *)((char *)buf + 4) = "__nw_protocol_input_finished";
                v213 = "%{public}s called with null other_protocol, no backtrace";
LABEL_542:
                _os_log_impl(&dword_182FBE000, v211, v212, v213, (uint8_t *)buf, 0xCu);
              }
            }
LABEL_543:
            if (v210)
              free(v210);
            goto LABEL_272;
          }
          v106 = *(void (***)(_QWORD))(v75 + 64);
          if (v106)
          {
            *(_QWORD *)(v75 + 64) = 0;
            v106[2](v106);
            _Block_release(v106);
          }
          if ((*(_BYTE *)(v75 + 72) & 1) != 0)
          {
            v107 = *(const void **)(v75 + 64);
            if (v107)
              _Block_release(v107);
          }
LABEL_216:
          free((void *)v75);
LABEL_217:
          v74 = a1;
          goto LABEL_164;
        }
      }
      __nwlog_obj();
      v148 = (const char *)a1[2];
      LODWORD(buf[0]) = 136446722;
      *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
      if (!v148)
        v148 = "invalid";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = v148;
      HIWORD(buf[2]) = 2048;
      v261 = (unint64_t)a1;
      v149 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v258[0]) = 0;
      if (__nwlog_fault(v149, type, v258))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v150 = __nwlog_obj();
          v151 = type[0];
          if (!os_log_type_enabled(v150, type[0]))
            goto LABEL_470;
          v152 = (const char *)a1[2];
          if (!v152)
            v152 = "invalid";
          LODWORD(buf[0]) = 136446722;
          *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = v152;
          HIWORD(buf[2]) = 2048;
          v261 = (unint64_t)a1;
          v153 = "%{public}s protocol %{public}s (%p) has invalid error callback";
          goto LABEL_469;
        }
        if (!LOBYTE(v258[0]))
        {
          v150 = __nwlog_obj();
          v151 = type[0];
          if (!os_log_type_enabled(v150, type[0]))
            goto LABEL_470;
          v197 = (const char *)a1[2];
          if (!v197)
            v197 = "invalid";
          LODWORD(buf[0]) = 136446722;
          *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = v197;
          HIWORD(buf[2]) = 2048;
          v261 = (unint64_t)a1;
          v153 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
          goto LABEL_469;
        }
        v172 = (char *)__nw_create_backtrace_string();
        v150 = __nwlog_obj();
        v151 = type[0];
        v173 = os_log_type_enabled(v150, type[0]);
        if (v172)
        {
          if (v173)
          {
            v174 = (const char *)a1[2];
            if (!v174)
              v174 = "invalid";
            LODWORD(buf[0]) = 136446978;
            *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v174;
            HIWORD(buf[2]) = 2048;
            v261 = (unint64_t)a1;
            LOWORD(v262[0]) = 2082;
            *(_QWORD *)((char *)v262 + 2) = v172;
            _os_log_impl(&dword_182FBE000, v150, v151, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x2Au);
          }
          free(v172);
          goto LABEL_470;
        }
        if (v173)
        {
          v199 = (const char *)a1[2];
          if (!v199)
            v199 = "invalid";
          LODWORD(buf[0]) = 136446722;
          *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = v199;
          HIWORD(buf[2]) = 2048;
          v261 = (unint64_t)a1;
          v153 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
LABEL_469:
          _os_log_impl(&dword_182FBE000, v150, v151, v153, (uint8_t *)buf, 0x20u);
        }
      }
LABEL_470:
      if (v149)
        free(v149);
      goto LABEL_162;
    }
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
    v75 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v258[0]) = 0;
    if (__nwlog_fault((const char *)v75, type, v258))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v167 = __nwlog_obj();
        v168 = type[0];
        if (!os_log_type_enabled(v167, type[0]))
          goto LABEL_498;
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
        v169 = "%{public}s called with null other_protocol";
        goto LABEL_497;
      }
      if (!LOBYTE(v258[0]))
      {
        v167 = __nwlog_obj();
        v168 = type[0];
        if (!os_log_type_enabled(v167, type[0]))
          goto LABEL_498;
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
        v169 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_497;
      }
      v191 = (char *)__nw_create_backtrace_string();
      v167 = __nwlog_obj();
      v168 = type[0];
      v192 = os_log_type_enabled(v167, type[0]);
      if (v191)
      {
        if (v192)
        {
          LODWORD(buf[0]) = 136446466;
          *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = v191;
          _os_log_impl(&dword_182FBE000, v167, v168, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        free(v191);
        if (!v75)
          goto LABEL_217;
        goto LABEL_216;
      }
      if (v192)
      {
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "__nw_protocol_error";
        v169 = "%{public}s called with null other_protocol, no backtrace";
LABEL_497:
        _os_log_impl(&dword_182FBE000, v167, v168, v169, (uint8_t *)buf, 0xCu);
      }
    }
LABEL_498:
    if (!v75)
      goto LABEL_217;
    goto LABEL_216;
  }
  return v15;
}

uint64_t nw_protocol_plugin_retry_set_getting_input_frames(uint64_t a1, uint64_t a2, int a3)
{
  char v4;
  char v6;
  uint64_t (*v8)(uint64_t, _QWORD, BOOL);
  uint64_t (*v9)(uint64_t, _QWORD, BOOL);
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v10, &type, &v16))
      goto LABEL_31;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
      v13 = "%{public}s called with null retry_plugin";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null retry_plugin, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_31;
      }
      if (!v15)
      {
LABEL_31:
        if (v10)
          free(v10);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
      v13 = "%{public}s called with null retry_plugin, no backtrace";
    }
    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_plugin_retry_set_getting_input_frames";
      v13 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_31;
  }
  v4 = *(_BYTE *)(a1 + 212);
  if (((((v4 & 1) == 0) ^ a3) & 1) != 0)
    return 0;
  if (a3)
  {
    v6 = v4 | 1;
  }
  else
  {
    if ((*(_BYTE *)(a1 + 212) & 4) != 0)
    {
      *(_BYTE *)(a1 + 212) = v4 & 0xFB;
      v8 = *(uint64_t (**)(uint64_t, _QWORD, BOOL))(a1 + 152);
      if (!v8 || (v8(a2, *(_QWORD *)(a2 + 32), *(_DWORD *)(a1 + 208) != 0) & 1) == 0)
        nw_protocol_common_input_finished(a2, *(_QWORD *)(a2 + 32));
    }
    if ((*(_BYTE *)(a1 + 212) & 2) != 0)
    {
      *(_BYTE *)(a1 + 212) &= ~2u;
      v9 = *(uint64_t (**)(uint64_t, _QWORD, BOOL))(a1 + 152);
      if (!v9 || (v9(a2, *(_QWORD *)(a2 + 32), *(_DWORD *)(a1 + 208) != 0) & 1) == 0)
        nw_protocol_common_disconnected(a2, *(_QWORD *)(a2 + 32));
    }
    v6 = *(_BYTE *)(a1 + 212) & 0xFE;
  }
  *(_BYTE *)(a1 + 212) = v6;
  return 1;
}

BOOL nw_protocol_plugin_metadata_handle_eof(uint64_t a1, _QWORD *a2)
{
  char v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  unsigned int v11;
  uint64_t *v12;
  uint64_t *v13;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  const char *v20;
  const char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  char *v27;
  _BOOL4 v28;
  char *v29;
  uint64_t v30;
  uint64_t *v31;
  int v32;
  unsigned int v33;
  int v34;
  int v35;
  int v36;
  os_log_type_t type[8];
  os_log_type_t *v38;
  uint64_t v39;
  int v40;
  char v41;
  _BYTE buf[24];
  void *v43;
  os_log_type_t *v44;
  int *v45;
  uint64_t v46;
  int *v47;
  uint64_t v48;
  uint64_t *v49;
  int *v50;
  int *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v3 = *(_BYTE *)(a1 + 142);
  if (*(_BYTE *)(a1 + 140) == 3 || (v3 & 0x10) != 0)
    return (v3 & 1) == 0 || *(_BYTE *)(a1 + 140) != 2;
  v35 = -1;
  v36 = 0;
  v33 = 0;
  v34 = -1;
  v32 = 0;
  v30 = 0;
  v31 = &v30;
  if (*(_QWORD *)a1)
  {
    if (gLogDatapath)
    {
      v15 = __nwlog_obj();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_handle_eof";
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s resuming saved input frames", buf, 0xCu);
      }
    }
    v6 = a2[6];
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 96);
      if (v7)
      {
        *(_QWORD *)type = 0;
        v38 = type;
        v40 = 0;
        v39 = 0x2000000000;
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
        v43 = &unk_1E149A880;
        v46 = a1;
        v47 = &v35;
        v55 = 1;
        v48 = a1;
        v49 = &v30;
        v50 = &v36;
        v51 = &v32;
        v44 = type;
        v45 = &v34;
        v52 = a2;
        v53 = v7;
        v54 = v6;
        v8 = *(_QWORD *)a1;
        do
        {
          if (!v8)
            break;
          v9 = *(_QWORD *)(v8 + 32);
          v10 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          v8 = v9;
        }
        while ((v10 & 1) != 0);
        v11 = *((_DWORD *)v38 + 6);
        _Block_object_dispose(type, 8);
LABEL_14:
        v33 = v11;
        if (v30)
        {
          **(_QWORD **)(a1 + 24) = v30;
          v12 = v31;
          *(_QWORD *)(v30 + 40) = *(_QWORD *)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v12;
        }
        goto LABEL_16;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
      v16 = (const char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v41 = 0;
      if (__nwlog_fault(v16, type, &v41))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v17 = __nwlog_obj();
          v18 = type[0];
          if (!os_log_type_enabled(v17, type[0]))
            goto LABEL_48;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
          v19 = "%{public}s called with null processor";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
          goto LABEL_48;
        }
        if (!v41)
        {
          v17 = __nwlog_obj();
          v18 = type[0];
          if (!os_log_type_enabled(v17, type[0]))
            goto LABEL_48;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
          v19 = "%{public}s called with null processor, backtrace limit exceeded";
          goto LABEL_47;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v17 = __nwlog_obj();
        v18 = type[0];
        v26 = os_log_type_enabled(v17, type[0]);
        if (!backtrace_string)
        {
          if (!v26)
            goto LABEL_48;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
          v19 = "%{public}s called with null processor, no backtrace";
          goto LABEL_47;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null processor, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
      }
LABEL_48:
      if (v16)
      {
        v29 = (char *)v16;
LABEL_57:
        free(v29);
        goto LABEL_58;
      }
      goto LABEL_58;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
    v20 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v41 = 0;
    v21 = v20;
    if (__nwlog_fault(v20, type, &v41))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v22 = __nwlog_obj();
        v23 = type[0];
        if (!os_log_type_enabled(v22, type[0]))
          goto LABEL_55;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v24 = "%{public}s called with null input_protocol";
LABEL_54:
        _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
        goto LABEL_55;
      }
      if (!v41)
      {
        v22 = __nwlog_obj();
        v23 = type[0];
        if (!os_log_type_enabled(v22, type[0]))
          goto LABEL_55;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v24 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_54;
      }
      v27 = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type[0];
      v28 = os_log_type_enabled(v22, type[0]);
      if (!v27)
      {
        if (!v28)
          goto LABEL_55;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v24 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_54;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v27;
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v27);
    }
LABEL_55:
    if (v21)
    {
      v29 = (char *)v21;
      goto LABEL_57;
    }
LABEL_58:
    v11 = 0;
    goto LABEL_14;
  }
LABEL_16:
  while (1)
  {
    v30 = 0;
    v31 = &v30;
    nw_protocol_plugin_metadata_get_and_process_frames(a1, a2, a2[6], v36, &v36, &v35, &v34, &v33, &v32, *(_QWORD *)(a1 + 96), &v30);
    if (!v30)
      break;
    **(_QWORD **)(a1 + 24) = v30;
    v13 = v31;
    *(_QWORD *)(v30 + 40) = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = v13;
    v30 = 0;
    v31 = &v30;
    v32 = 0;
  }
  v3 = *(_BYTE *)(a1 + 142) | 0x10;
  *(_BYTE *)(a1 + 142) = v3;
  return (v3 & 1) == 0 || *(_BYTE *)(a1 + 140) != 2;
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

void nw_protocol_plugin_metadata_deep_copy_input_frame_array(nw_frame_array_s *a1)
{
  uint64_t v2;
  nw_frame *tqh_first;
  nw_frame *v4;
  char v5;
  nw_frame *v6;
  nw_frame *v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  nw_frame *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  NSObject *v16;
  char *backtrace_string;
  _BOOL4 v18;
  _QWORD v19[2];
  BOOL (*v20)(uint64_t, uint64_t);
  void *v21;
  _BYTE *v22;
  char v23;
  _BYTE v24[24];
  __n128 (*v25)(uint64_t, uint64_t);
  uint64_t (*v26)();
  _QWORD v27[3];
  __int128 buf;
  uint64_t (*v29)(uint64_t, uint64_t);
  void *v30;
  nw_frame_array_s *v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)v24 = 0;
    *(_QWORD *)&v24[8] = v24;
    *(_QWORD *)&v24[16] = 0x3802000000;
    v25 = __Block_byref_object_copy__3150;
    v26 = __Block_byref_object_dispose__3151;
    v27[0] = 0;
    v27[1] = v27;
    v2 = MEMORY[0x1E0C809B0];
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 0x40000000;
    v20 = ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke;
    v21 = &unk_1E149A8E8;
    v22 = v24;
    tqh_first = a1->tqh_first;
    do
    {
      if (!tqh_first)
        break;
      v4 = (nw_frame *)*((_QWORD *)tqh_first + 4);
      v5 = ((uint64_t (*)(_QWORD *))v20)(v19);
      tqh_first = v4;
    }
    while ((v5 & 1) != 0);
    if (gLogDatapath)
    {
      v16 = __nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&buf, 0xCu);
      }
    }
    *(_QWORD *)&buf = v2;
    *((_QWORD *)&buf + 1) = 0x40000000;
    v29 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
    v30 = &__block_descriptor_tmp_34_3301;
    v31 = a1;
    v32 = 1;
    v6 = a1->tqh_first;
    do
    {
      if (!v6)
        break;
      v7 = (nw_frame *)*((_QWORD *)v6 + 4);
      v8 = ((uint64_t (*)(__int128 *))v29)(&buf);
      v6 = v7;
    }
    while ((v8 & 1) != 0);
    v9 = *(_QWORD *)&v24[8];
    v10 = *(_QWORD *)&v24[8] + 40;
    v11 = *(nw_frame **)(*(_QWORD *)&v24[8] + 40);
    if (v11)
    {
      *a1->tqh_last = v11;
      *(_QWORD *)(*(_QWORD *)(v9 + 40) + 40) = a1->tqh_last;
      a1->tqh_last = *(nw_frame ***)(v9 + 48);
      *(_QWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = v10;
    }
    _Block_object_dispose(v24, 8);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)v24 = 136446210;
  *(_QWORD *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
  v12 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(buf) = 16;
  v23 = 0;
  if (__nwlog_fault(v12, &buf, &v23))
  {
    if (buf == 17)
    {
      v13 = __nwlog_obj();
      v14 = buf;
      if (!os_log_type_enabled(v13, (os_log_type_t)buf))
        goto LABEL_29;
      *(_DWORD *)v24 = 136446210;
      *(_QWORD *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
      v15 = "%{public}s called with null frame_array";
      goto LABEL_28;
    }
    if (!v23)
    {
      v13 = __nwlog_obj();
      v14 = buf;
      if (!os_log_type_enabled(v13, (os_log_type_t)buf))
        goto LABEL_29;
      *(_DWORD *)v24 = 136446210;
      *(_QWORD *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
      v15 = "%{public}s called with null frame_array, backtrace limit exceeded";
      goto LABEL_28;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = buf;
    v18 = os_log_type_enabled(v13, (os_log_type_t)buf);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)v24 = 136446466;
        *(_QWORD *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
        *(_WORD *)&v24[12] = 2082;
        *(_QWORD *)&v24[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null frame_array, dumping backtrace:%{public}s", v24, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_29;
    }
    if (v18)
    {
      *(_DWORD *)v24 = 136446210;
      *(_QWORD *)&v24[4] = "nw_protocol_plugin_metadata_deep_copy_input_frame_array";
      v15 = "%{public}s called with null frame_array, no backtrace";
LABEL_28:
      _os_log_impl(&dword_182FBE000, v13, v14, v15, v24, 0xCu);
    }
  }
LABEL_29:
  if (v12)
    free(v12);
}

BOOL ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  void *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  _BOOL8 result;
  NSObject *v13;
  void *v14;
  _QWORD v15[6];
  size_t size;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  LODWORD(size) = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &size);
  v5 = size;
  if (!(_DWORD)size)
  {
    v8 = 0;
    v7 = 0;
    goto LABEL_5;
  }
  v6 = (const void *)v4;
  v7 = malloc_type_malloc(size, 0xF2B69DE5uLL);
  if (v7)
  {
LABEL_3:
    memcpy(v7, v6, size);
    v8 = size;
LABEL_5:
    v9 = nw_frame_create(0, (uint64_t)v7, v8, (uint64_t)nw_protocol_plugin_metadata_input_frame_finalizer, 0);
    nw_frame_set_buffer_used_malloc(v9, 1);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 0x40000000;
    v15[2] = ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke_2;
    v15[3] = &__block_descriptor_tmp_36_3305;
    v15[4] = v9;
    v15[5] = a2;
    nw_frame_foreach_protocol_metadata(a2, 0, (uint64_t)v15);
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_QWORD *)(v9 + 32) = 0;
    v11 = *(uint64_t **)(v10 + 48);
    *(_QWORD *)(v9 + 40) = v11;
    *v11 = v9;
    *(_QWORD *)(v10 + 48) = v9 + 32;
    return 1;
  }
  v13 = __nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  HIDWORD(size) = 136446466;
  v17 = "strict_malloc";
  v18 = 2048;
  v19 = v5;
  v14 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void nw_protocol_plugin_metadata_input_frame_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_frame_free_buffer((uint64_t)a1);
    nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
    os_release(a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
      v7 = "%{public}s called with null frame";
      goto LABEL_16;
    }
    if (!v10)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
      v7 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
        v14 = 2082;
        v15 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_17;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      v13 = "nw_protocol_plugin_metadata_input_frame_finalizer";
      v7 = "%{public}s called with null frame, no backtrace";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_17:
  if (v4)
    free(v4);
}

uint64_t ___ZL55nw_protocol_plugin_metadata_deep_copy_input_frame_arrayP16nw_frame_array_s_block_invoke_2(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int is_metadata_complete;

  v3 = *(_QWORD *)(a1 + 32);
  is_metadata_complete = nw_frame_is_metadata_complete(*(_QWORD *)(a1 + 40));
  nw_frame_set_metadata(v3, a2, 0, is_metadata_complete);
  return 1;
}

uint64_t nw_protocol_plugin_metadata_finalize_output_frames(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  int v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  const char *v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  char *v25;
  _BOOL4 v26;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(uint64_t, _QWORD *);
  uint64_t v33;
  uint64_t v34;
  void (**v35)(_QWORD);
  const void *v36;
  const char *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  const char *v42;
  NSObject *v43;
  NSObject *v44;
  os_log_type_t v45;
  const char *v46;
  char *v47;
  _BOOL4 v48;
  const char *v49;
  char *v50;
  _BOOL4 v51;
  const char *v52;
  const char *v53;
  int v54;
  int v55;
  int v56;
  _QWORD v57[2];
  unsigned int v58;
  os_log_type_t type[8];
  os_log_type_t *v60;
  uint64_t v61;
  int v62;
  char v63;
  _BYTE buf[24];
  void *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  _QWORD *v70;
  int *v71;
  unsigned int *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v57[0]) = 0;
    if (!__nwlog_fault(v10, type, v57))
      goto LABEL_77;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v57[0]))
      {
        v11 = __nwlog_obj();
        v12 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type[0];
      v20 = os_log_type_enabled(v11, type[0]);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      if (!v20)
        goto LABEL_54;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_53;
    }
    v11 = __nwlog_obj();
    v12 = type[0];
    if (!os_log_type_enabled(v11, type[0]))
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v13 = "%{public}s called with null protocol";
LABEL_76:
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_77;
  }
  v3 = *(_QWORD *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v57[0]) = 0;
    if (!__nwlog_fault(v10, type, v57))
      goto LABEL_77;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v57[0]))
      {
        v11 = __nwlog_obj();
        v12 = type[0];
        if (os_log_type_enabled(v11, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type[0];
      v22 = os_log_type_enabled(v11, type[0]);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          v13 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      if (!v22)
        goto LABEL_54;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v21 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_53;
    }
    v11 = __nwlog_obj();
    v12 = type[0];
    if (!os_log_type_enabled(v11, type[0]))
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v13 = "%{public}s called with null protocol->handle";
    goto LABEL_76;
  }
  v4 = *(_QWORD *)(v3 + 72);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v57[0]) = 0;
    if (!__nwlog_fault(v10, type, v57))
      goto LABEL_77;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (!os_log_type_enabled(v11, type[0]))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      v13 = "%{public}s called with null metadata_plugin";
      goto LABEL_76;
    }
    if (!LOBYTE(v57[0]))
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type[0];
    v23 = os_log_type_enabled(v11, type[0]);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null metadata_plugin, no backtrace";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    if (!v23)
      goto LABEL_54;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v21 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
LABEL_53:
    _os_log_impl(&dword_182FBE000, v11, v12, v21, buf, 0x16u);
    goto LABEL_54;
  }
  if (a2)
  {
    v58 = 0;
    v57[0] = 0;
    v57[1] = v57;
    if (*a2)
    {
      **(_QWORD **)(v4 + 40) = *a2;
      *(_QWORD *)(*a2 + 40) = *(_QWORD *)(v4 + 40);
      *(_QWORD *)(v4 + 40) = a2[1];
      *a2 = 0;
      a2[1] = a2;
    }
    if (!*(_QWORD *)(v4 + 32))
    {
LABEL_87:
      v9 = 0;
      if (!v57[0])
      {
LABEL_98:
        nw_protocol_plugin_metadata_report_transfer(v4, a1, *(_QWORD *)(v4 + 64), v58, 0);
        return 1;
      }
LABEL_88:
      if (gLogDatapath)
      {
        v43 = __nwlog_obj();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v9;
          _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s sending %u frames to the below protocol", buf, 0x12u);
        }
      }
      v28 = *(_QWORD *)(a1 + 32);
      if (v28)
      {
        v29 = *(void **)(v28 + 40);
        if (v29 == &nw_protocol_ref_counted_handle)
        {
          v30 = *(_QWORD *)(v28 + 88);
          if (v30)
            *(_QWORD *)(v28 + 88) = v30 + 1;
        }
        v31 = *(_QWORD *)(v28 + 24);
        if (v31)
        {
          v32 = *(void (**)(uint64_t, _QWORD *))(v31 + 96);
          if (v32)
          {
            v32(v28, v57);
LABEL_96:
            if (v29 != &nw_protocol_ref_counted_handle)
              goto LABEL_98;
            if (*(_UNKNOWN **)(v28 + 40) != &nw_protocol_ref_counted_handle)
              goto LABEL_98;
            v33 = *(_QWORD *)(v28 + 88);
            if (!v33)
              goto LABEL_98;
            v34 = v33 - 1;
            *(_QWORD *)(v28 + 88) = v34;
            if (v34)
              goto LABEL_98;
            v35 = *(void (***)(_QWORD))(v28 + 64);
            if (v35)
            {
              *(_QWORD *)(v28 + 64) = 0;
              v35[2](v35);
              _Block_release(v35);
            }
            if ((*(_BYTE *)(v28 + 72) & 1) != 0)
            {
              v36 = *(const void **)(v28 + 64);
              if (v36)
                _Block_release(v36);
            }
            goto LABEL_106;
          }
        }
        __nwlog_obj();
        v37 = *(const char **)(v28 + 16);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
        if (!v37)
          v37 = "invalid";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2048;
        v65 = (void *)v28;
        v38 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v56) = 0;
        if (__nwlog_fault(v38, type, &v56))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v39 = __nwlog_obj();
            v40 = type[0];
            if (!os_log_type_enabled(v39, type[0]))
              goto LABEL_143;
            v41 = *(const char **)(v28 + 16);
            if (!v41)
              v41 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v41;
            *(_WORD *)&buf[22] = 2048;
            v65 = (void *)v28;
            v42 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
            goto LABEL_142;
          }
          if (!(_BYTE)v56)
          {
            v39 = __nwlog_obj();
            v40 = type[0];
            if (!os_log_type_enabled(v39, type[0]))
              goto LABEL_143;
            v52 = *(const char **)(v28 + 16);
            if (!v52)
              v52 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v52;
            *(_WORD *)&buf[22] = 2048;
            v65 = (void *)v28;
            v42 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
            goto LABEL_142;
          }
          v47 = (char *)__nw_create_backtrace_string();
          v39 = __nwlog_obj();
          v40 = type[0];
          v48 = os_log_type_enabled(v39, type[0]);
          if (v47)
          {
            if (v48)
            {
              v49 = *(const char **)(v28 + 16);
              if (!v49)
                v49 = "invalid";
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v49;
              *(_WORD *)&buf[22] = 2048;
              v65 = (void *)v28;
              LOWORD(v66) = 2082;
              *(_QWORD *)((char *)&v66 + 2) = v47;
              _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v47);
            goto LABEL_143;
          }
          if (v48)
          {
            v53 = *(const char **)(v28 + 16);
            if (!v53)
              v53 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v53;
            *(_WORD *)&buf[22] = 2048;
            v65 = (void *)v28;
            v42 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_142:
            _os_log_impl(&dword_182FBE000, v39, v40, v42, buf, 0x20u);
          }
        }
LABEL_143:
        if (v38)
          free(v38);
        goto LABEL_96;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
      v28 = _os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v56) = 0;
      if (__nwlog_fault((const char *)v28, type, &v56))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v44 = __nwlog_obj();
          v45 = type[0];
          if (!os_log_type_enabled(v44, type[0]))
            goto LABEL_150;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
          v46 = "%{public}s called with null protocol";
          goto LABEL_149;
        }
        if (!(_BYTE)v56)
        {
          v44 = __nwlog_obj();
          v45 = type[0];
          if (!os_log_type_enabled(v44, type[0]))
            goto LABEL_150;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
          v46 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_149;
        }
        v50 = (char *)__nw_create_backtrace_string();
        v44 = __nwlog_obj();
        v45 = type[0];
        v51 = os_log_type_enabled(v44, type[0]);
        if (v50)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v50;
            _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v50);
          if (!v28)
            goto LABEL_98;
LABEL_106:
          free((void *)v28);
          goto LABEL_98;
        }
        if (v51)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
          v46 = "%{public}s called with null protocol, no backtrace";
LABEL_149:
          _os_log_impl(&dword_182FBE000, v44, v45, v46, buf, 0xCu);
        }
      }
LABEL_150:
      if (!v28)
        goto LABEL_98;
      goto LABEL_106;
    }
    if (gLogDatapath)
    {
      v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s resuming saved output frames", buf, 0xCu);
      }
    }
    v55 = -1;
    v56 = 0;
    v54 = -1;
    v5 = *(_QWORD *)(v4 + 104);
    if (v5)
    {
      *(_QWORD *)type = 0;
      v60 = type;
      v62 = 0;
      v61 = 0x2000000000;
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __nw_protocol_plugin_metadata_process_frames_block_invoke;
      v65 = &unk_1E149A880;
      *((_QWORD *)&v66 + 1) = &v54;
      v67 = v4;
      v76 = 0;
      v68 = &v55;
      v69 = v4 + 32;
      v70 = v57;
      v71 = &v56;
      *(_QWORD *)&v66 = type;
      v72 = &v58;
      v73 = a1;
      v74 = v5;
      v75 = 0;
      v6 = *(_QWORD *)(v4 + 32);
      do
      {
        if (!v6)
          break;
        v7 = *(_QWORD *)(v6 + 32);
        v8 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v6 = v7;
      }
      while ((v8 & 1) != 0);
      v9 = *((_DWORD *)v60 + 6);
      _Block_object_dispose(type, 8);
      if (!v57[0])
        goto LABEL_98;
      goto LABEL_88;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
    v15 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (__nwlog_fault(v15, type, &v63))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        v17 = type[0];
        if (!os_log_type_enabled(v16, type[0]))
          goto LABEL_85;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v18 = "%{public}s called with null processor";
        goto LABEL_84;
      }
      if (!v63)
      {
        v16 = __nwlog_obj();
        v17 = type[0];
        if (!os_log_type_enabled(v16, type[0]))
          goto LABEL_85;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v18 = "%{public}s called with null processor, backtrace limit exceeded";
        goto LABEL_84;
      }
      v25 = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type[0];
      v26 = os_log_type_enabled(v16, type[0]);
      if (v25)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v25;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null processor, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v25);
        goto LABEL_85;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_process_frames";
        v18 = "%{public}s called with null processor, no backtrace";
LABEL_84:
        _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      }
    }
LABEL_85:
    if (v15)
      free(v15);
    goto LABEL_87;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
  v10 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v57[0]) = 0;
  if (!__nwlog_fault(v10, type, v57))
    goto LABEL_77;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!LOBYTE(v57[0]))
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null frames, backtrace limit exceeded";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type[0];
    v24 = os_log_type_enabled(v11, type[0]);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
        v13 = "%{public}s called with null frames, no backtrace";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v21 = "%{public}s called with null frames, dumping backtrace:%{public}s";
      goto LABEL_53;
    }
LABEL_54:
    free(backtrace_string);
    goto LABEL_77;
  }
  v11 = __nwlog_obj();
  v12 = type[0];
  if (os_log_type_enabled(v11, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_finalize_output_frames";
    v13 = "%{public}s called with null frames";
    goto LABEL_76;
  }
LABEL_77:
  if (v10)
    free(v10);
  return 0;
}

void nw_protocol_plugin_metadata_output_available(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  void (**v14)(_QWORD);
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  void (**v18)(_QWORD);
  const void *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  NSObject *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *backtrace_string;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  _BOOL4 v38;
  const char *v39;
  const char *v40;
  os_log_type_t type[8];
  os_log_type_t *v42;
  char v43;
  os_log_type_t v44;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  void *v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_plugin_metadata_output_available";
    v5 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v44 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v5, type, &v44))
      goto LABEL_117;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null protocol";
      goto LABEL_116;
    }
    if (v44 == OS_LOG_TYPE_DEFAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type[0];
    v31 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v31)
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_116;
    }
    if (!v31)
      goto LABEL_93;
    *(_DWORD *)buf = 136446466;
    v46 = "nw_protocol_plugin_metadata_output_available";
    v47 = 2082;
    v48 = backtrace_string;
    v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_92:
    _os_log_impl(&dword_182FBE000, v20, v21, v32, buf, 0x16u);
    goto LABEL_93;
  }
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_plugin_metadata_output_available";
    v5 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v44 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v5, type, &v44))
      goto LABEL_117;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null protocol->handle";
      goto LABEL_116;
    }
    if (v44 == OS_LOG_TYPE_DEFAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type[0];
    v33 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v33)
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null protocol->handle, no backtrace";
      goto LABEL_116;
    }
    if (!v33)
      goto LABEL_93;
    *(_DWORD *)buf = 136446466;
    v46 = "nw_protocol_plugin_metadata_output_available";
    v47 = 2082;
    v48 = backtrace_string;
    v32 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
    goto LABEL_92;
  }
  v3 = *(_QWORD *)(v2 + 72);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_plugin_metadata_output_available";
    v5 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v44 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v5, type, &v44))
      goto LABEL_117;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null metadata_plugin";
      goto LABEL_116;
    }
    if (v44 == OS_LOG_TYPE_DEFAULT)
    {
      v20 = __nwlog_obj();
      v21 = type[0];
      if (!os_log_type_enabled(v20, type[0]))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type[0];
    v34 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v34)
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v22 = "%{public}s called with null metadata_plugin, no backtrace";
      goto LABEL_116;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_plugin_metadata_output_available";
      v47 = 2082;
      v48 = backtrace_string;
      v32 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
      goto LABEL_92;
    }
LABEL_93:
    free(backtrace_string);
    if (!v5)
      return;
LABEL_36:
    free((void *)v5);
    return;
  }
  if (gLogDatapath)
  {
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_plugin_metadata_output_available";
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  *(_QWORD *)type = 0;
  v42 = type;
  nw_protocol_plugin_metadata_finalize_output_frames(a1, type);
  if (*(_QWORD *)(v3 + 32))
    return;
  v4 = *(_QWORD *)(v3 + 128);
  v5 = *(_QWORD *)(v4 + 48);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    v5 = _os_log_send_and_compose_impl();
    v44 = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (!__nwlog_fault((const char *)v5, &v44, &v43))
      goto LABEL_117;
    if (v44 == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = v44;
      if (!os_log_type_enabled(v20, v44))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "__nw_protocol_output_available";
      v22 = "%{public}s called with null protocol";
      goto LABEL_116;
    }
    if (!v43)
    {
      v20 = __nwlog_obj();
      v21 = v44;
      if (!os_log_type_enabled(v20, v44))
        goto LABEL_117;
      *(_DWORD *)buf = 136446210;
      v46 = "__nw_protocol_output_available";
      v22 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = v44;
    v38 = os_log_type_enabled(v20, v44);
    if (backtrace_string)
    {
      if (!v38)
        goto LABEL_93;
      *(_DWORD *)buf = 136446466;
      v46 = "__nw_protocol_output_available";
      v47 = 2082;
      v48 = backtrace_string;
      v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_92;
    }
    if (!v38)
      goto LABEL_117;
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_output_available";
    v22 = "%{public}s called with null protocol, no backtrace";
LABEL_116:
    _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
LABEL_117:
    if (!v5)
      return;
    goto LABEL_36;
  }
  v6 = *(void **)(v5 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(v5 + 88);
    if (v7)
      *(_QWORD *)(v5 + 88) = v7 + 1;
  }
  v8 = *(void **)(v4 + 40);
  if (v8 == &nw_protocol_ref_counted_handle)
  {
    v9 = *(_QWORD *)(v4 + 88);
    if (v9)
      *(_QWORD *)(v4 + 88) = v9 + 1;
  }
  v10 = *(_QWORD *)(v5 + 24);
  if (v10)
  {
    v11 = *(void (**)(uint64_t, uint64_t))(v10 + 72);
    if (v11)
    {
      v11(v5, v4);
      goto LABEL_16;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v5 + 16);
  *(_DWORD *)buf = 136446722;
  v46 = "__nw_protocol_output_available";
  if (!v24)
    v24 = "invalid";
  v47 = 2082;
  v48 = (void *)v24;
  v49 = 2048;
  v50 = v5;
  v25 = (char *)_os_log_send_and_compose_impl();
  v44 = OS_LOG_TYPE_ERROR;
  v43 = 0;
  if (__nwlog_fault(v25, &v44, &v43))
  {
    if (v44 == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = v44;
      if (!os_log_type_enabled(v26, v44))
        goto LABEL_110;
      v28 = *(const char **)(v5 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v46 = "__nw_protocol_output_available";
      v47 = 2082;
      v48 = (void *)v28;
      v49 = 2048;
      v50 = v5;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback";
      goto LABEL_109;
    }
    if (!v43)
    {
      v26 = __nwlog_obj();
      v27 = v44;
      if (!os_log_type_enabled(v26, v44))
        goto LABEL_110;
      v39 = *(const char **)(v5 + 16);
      if (!v39)
        v39 = "invalid";
      *(_DWORD *)buf = 136446722;
      v46 = "__nw_protocol_output_available";
      v47 = 2082;
      v48 = (void *)v39;
      v49 = 2048;
      v50 = v5;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded";
      goto LABEL_109;
    }
    v35 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = v44;
    v36 = os_log_type_enabled(v26, v44);
    if (v35)
    {
      if (v36)
      {
        v37 = *(const char **)(v5 + 16);
        if (!v37)
          v37 = "invalid";
        *(_DWORD *)buf = 136446978;
        v46 = "__nw_protocol_output_available";
        v47 = 2082;
        v48 = (void *)v37;
        v49 = 2048;
        v50 = v5;
        v51 = 2082;
        v52 = v35;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v35);
      goto LABEL_110;
    }
    if (v36)
    {
      v40 = *(const char **)(v5 + 16);
      if (!v40)
        v40 = "invalid";
      *(_DWORD *)buf = 136446722;
      v46 = "__nw_protocol_output_available";
      v47 = 2082;
      v48 = (void *)v40;
      v49 = 2048;
      v50 = v5;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace";
LABEL_109:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_110:
  if (v25)
    free(v25);
LABEL_16:
  if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    v12 = *(_QWORD *)(v4 + 88);
    if (v12)
    {
      v13 = v12 - 1;
      *(_QWORD *)(v4 + 88) = v13;
      if (!v13)
      {
        v14 = *(void (***)(_QWORD))(v4 + 64);
        if (v14)
        {
          *(_QWORD *)(v4 + 64) = 0;
          v14[2](v14);
          _Block_release(v14);
        }
        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          v15 = *(const void **)(v4 + 64);
          if (v15)
            _Block_release(v15);
        }
        free((void *)v4);
      }
    }
  }
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
  {
    v16 = *(_QWORD *)(v5 + 88);
    if (v16)
    {
      v17 = v16 - 1;
      *(_QWORD *)(v5 + 88) = v17;
      if (!v17)
      {
        v18 = *(void (***)(_QWORD))(v5 + 64);
        if (v18)
        {
          *(_QWORD *)(v5 + 64) = 0;
          v18[2](v18);
          _Block_release(v18);
        }
        if ((*(_BYTE *)(v5 + 72) & 1) != 0)
        {
          v19 = *(const void **)(v5 + 64);
          if (v19)
            _Block_release(v19);
        }
        goto LABEL_36;
      }
    }
  }
}

void nw_protocol_plugin_metadata_resume_input(uint64_t a1, int a2)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(uint64_t, uint64_t);
  uint64_t v13;
  uint64_t v14;
  void (**v15)(_QWORD);
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(_QWORD);
  const void *v20;
  const char *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  NSObject *v30;
  char *v31;
  char *v32;
  _BOOL4 v33;
  const char *v34;
  char *backtrace_string;
  _BOOL4 v36;
  const char *v37;
  _BOOL4 v38;
  _BOOL4 v39;
  const char *v40;
  const char *v41;
  char v42;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  void *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  char *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_plugin_metadata_resume_input";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault((const char *)v6, &type, &v42))
      goto LABEL_105;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin";
      goto LABEL_104;
    }
    if (!v42)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_104;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v36 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v36)
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin, no backtrace";
      goto LABEL_104;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v46 = 2082;
      v47 = backtrace_string;
      v37 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
LABEL_78:
      _os_log_impl(&dword_182FBE000, v27, v28, v37, buf, 0x16u);
    }
LABEL_79:
    free(backtrace_string);
    if (!v6)
      return;
LABEL_36:
    free((void *)v6);
    return;
  }
  if (gLogDatapath)
  {
    v30 = __nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      v31 = off_1E149A908[(a2 - 1)];
      *(_DWORD *)buf = 136446466;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v46 = 2080;
      v47 = v31;
      _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s resuming input with result: %s", buf, 0x16u);
    }
  }
  *(_BYTE *)(a1 + 140) = a2;
  if (a2 == 3)
  {
    v4 = *(_BYTE *)(a1 + 142);
    *(_DWORD *)(a1 + 136) = 0;
    *(_BYTE *)(a1 + 142) = v4 & 0xE3;
  }
  v5 = *(_QWORD *)(a1 + 128);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_plugin_metadata_resume_input";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault((const char *)v6, &type, &v42))
      goto LABEL_105;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin->protocol";
      goto LABEL_104;
    }
    if (!v42)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin->protocol, backtrace limit exceeded";
      goto LABEL_104;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v38 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v38)
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v29 = "%{public}s called with null metadata_plugin->protocol, no backtrace";
      goto LABEL_104;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      v45 = "nw_protocol_plugin_metadata_resume_input";
      v46 = 2082;
      v47 = backtrace_string;
      v37 = "%{public}s called with null metadata_plugin->protocol, dumping backtrace:%{public}s";
      goto LABEL_78;
    }
    goto LABEL_79;
  }
  v6 = *(_QWORD *)(v5 + 48);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "__nw_protocol_input_available";
    v6 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault((const char *)v6, &type, &v42))
      goto LABEL_105;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "__nw_protocol_input_available";
      v29 = "%{public}s called with null protocol";
      goto LABEL_104;
    }
    if (!v42)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_105;
      *(_DWORD *)buf = 136446210;
      v45 = "__nw_protocol_input_available";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_104;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v39 = os_log_type_enabled(v27, type);
    if (backtrace_string)
    {
      if (!v39)
        goto LABEL_79;
      *(_DWORD *)buf = 136446466;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = backtrace_string;
      v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_78;
    }
    if (!v39)
      goto LABEL_105;
    *(_DWORD *)buf = 136446210;
    v45 = "__nw_protocol_input_available";
    v29 = "%{public}s called with null protocol, no backtrace";
LABEL_104:
    _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
LABEL_105:
    if (!v6)
      return;
    goto LABEL_36;
  }
  v7 = *(void **)(v6 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    v8 = *(_QWORD *)(v6 + 88);
    if (v8)
      *(_QWORD *)(v6 + 88) = v8 + 1;
  }
  v9 = *(void **)(v5 + 40);
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v5 + 88);
    if (v10)
      *(_QWORD *)(v5 + 88) = v10 + 1;
  }
  v11 = *(_QWORD *)(v6 + 24);
  if (v11)
  {
    v12 = *(void (**)(uint64_t, uint64_t))(v11 + 64);
    if (v12)
    {
      v12(v6, v5);
      goto LABEL_16;
    }
  }
  __nwlog_obj();
  v21 = *(const char **)(v6 + 16);
  *(_DWORD *)buf = 136446722;
  v45 = "__nw_protocol_input_available";
  if (!v21)
    v21 = "invalid";
  v46 = 2082;
  v47 = (void *)v21;
  v48 = 2048;
  v49 = v6;
  v22 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v22, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_90;
      v25 = *(const char **)(v6 + 16);
      if (!v25)
        v25 = "invalid";
      *(_DWORD *)buf = 136446722;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = (void *)v25;
      v48 = 2048;
      v49 = v6;
      v26 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
      goto LABEL_89;
    }
    if (!v42)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_90;
      v40 = *(const char **)(v6 + 16);
      if (!v40)
        v40 = "invalid";
      *(_DWORD *)buf = 136446722;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = (void *)v40;
      v48 = 2048;
      v49 = v6;
      v26 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_89;
    }
    v32 = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type;
    v33 = os_log_type_enabled(v23, type);
    if (v32)
    {
      if (v33)
      {
        v34 = *(const char **)(v6 + 16);
        if (!v34)
          v34 = "invalid";
        *(_DWORD *)buf = 136446978;
        v45 = "__nw_protocol_input_available";
        v46 = 2082;
        v47 = (void *)v34;
        v48 = 2048;
        v49 = v6;
        v50 = 2082;
        v51 = v32;
        _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v32);
      goto LABEL_90;
    }
    if (v33)
    {
      v41 = *(const char **)(v6 + 16);
      if (!v41)
        v41 = "invalid";
      *(_DWORD *)buf = 136446722;
      v45 = "__nw_protocol_input_available";
      v46 = 2082;
      v47 = (void *)v41;
      v48 = 2048;
      v49 = v6;
      v26 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
LABEL_89:
      _os_log_impl(&dword_182FBE000, v23, v24, v26, buf, 0x20u);
    }
  }
LABEL_90:
  if (v22)
    free(v22);
LABEL_16:
  if (v9 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
  {
    v13 = *(_QWORD *)(v5 + 88);
    if (v13)
    {
      v14 = v13 - 1;
      *(_QWORD *)(v5 + 88) = v14;
      if (!v14)
      {
        v15 = *(void (***)(_QWORD))(v5 + 64);
        if (v15)
        {
          *(_QWORD *)(v5 + 64) = 0;
          v15[2](v15);
          _Block_release(v15);
        }
        if ((*(_BYTE *)(v5 + 72) & 1) != 0)
        {
          v16 = *(const void **)(v5 + 64);
          if (v16)
            _Block_release(v16);
        }
        free((void *)v5);
      }
    }
  }
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v6 + 40) == &nw_protocol_ref_counted_handle)
  {
    v17 = *(_QWORD *)(v6 + 88);
    if (v17)
    {
      v18 = v17 - 1;
      *(_QWORD *)(v6 + 88) = v18;
      if (!v18)
      {
        v19 = *(void (***)(_QWORD))(v6 + 64);
        if (v19)
        {
          *(_QWORD *)(v6 + 64) = 0;
          v19[2](v19);
          _Block_release(v19);
        }
        if ((*(_BYTE *)(v6 + 72) & 1) != 0)
        {
          v20 = *(const void **)(v6 + 64);
          if (v20)
            _Block_release(v20);
        }
        goto LABEL_36;
      }
    }
  }
}

void nw_protocol_plugin_metadata_prepare_for_reissue(uint64_t a1)
{
  char v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  NSObject *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  _BYTE buf[24];
  void *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (gLogDatapath)
    {
      v10 = __nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s discarding pending input and output", buf, 0xCu);
      }
    }
    v2 = *(_BYTE *)(a1 + 142);
    *(_DWORD *)(a1 + 136) = 0;
    *(_BYTE *)(a1 + 142) = v2 & 0xE2;
    *(_BYTE *)(a1 + 141) = 3;
    if (gLogDatapath)
    {
      v11 = __nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
    v17 = &__block_descriptor_tmp_34_3301;
    v18 = a1 + 16;
    v19 = 0;
    v3 = *(_QWORD *)(a1 + 16);
    do
    {
      if (!v3)
        break;
      v4 = *(_QWORD *)(v3 + 32);
      v5 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
      v3 = v4;
    }
    while ((v5 & 1) != 0);
    nw_protocol_plugin_metadata_resume_input(a1, 3);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v6, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
      v9 = "%{public}s called with null metadata_plugin";
      goto LABEL_26;
    }
    if (!v14)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
      v9 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
      goto LABEL_26;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_27;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_metadata_prepare_for_reissue";
      v9 = "%{public}s called with null metadata_plugin, no backtrace";
LABEL_26:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_27:
  if (v6)
    free(v6);
}

void nw_protocol_plugin_metadata_reset(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  char v12;
  void *v13;
  char v14;
  void *v15;
  char v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  __int128 v21;
  uint64_t (*v22)(uint64_t, uint64_t);
  void *v23;
  uint64_t *v24;
  char v25;
  uint8_t buf[4];
  const char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v21) = 136446210;
      *(_QWORD *)((char *)&v21 + 4) = "nw_protocol_plugin_metadata_reset";
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v21, 0xCu);
    }
    if (gLogDatapath)
    {
      v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }
  }
  v2 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v21 = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v21 + 1) = 0x40000000;
  v22 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
  v23 = &__block_descriptor_tmp_34_3301;
  v24 = a1;
  v25 = 0;
  v3 = *a1;
  do
  {
    if (!v3)
      break;
    v4 = *(_QWORD *)(v3 + 32);
    v5 = ((uint64_t (*)(__int128 *))v22)(&v21);
    v3 = v4;
  }
  while ((v5 & 1) != 0);
  if (gLogDatapath)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v21) = 136446210;
      *(_QWORD *)((char *)&v21 + 4) = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v21, 0xCu);
    }
  }
  *(_QWORD *)&v21 = v2;
  *((_QWORD *)&v21 + 1) = 0x40000000;
  v22 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
  v23 = &__block_descriptor_tmp_34_3301;
  v24 = a1 + 2;
  v25 = 0;
  v6 = a1[2];
  do
  {
    if (!v6)
      break;
    v7 = *(_QWORD *)(v6 + 32);
    v8 = ((uint64_t (*)(__int128 *))v22)(&v21);
    v6 = v7;
  }
  while ((v8 & 1) != 0);
  if (gLogDatapath)
  {
    v20 = __nwlog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v21) = 136446210;
      *(_QWORD *)((char *)&v21 + 4) = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v21, 0xCu);
    }
  }
  *(_QWORD *)&v21 = v2;
  *((_QWORD *)&v21 + 1) = 0x40000000;
  v22 = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
  v23 = &__block_descriptor_tmp_34_3301;
  v24 = a1 + 4;
  v25 = 0;
  v9 = a1[4];
  do
  {
    if (!v9)
      break;
    v10 = *(_QWORD *)(v9 + 32);
    v11 = ((uint64_t (*)(__int128 *))v22)(&v21);
    v9 = v10;
  }
  while ((v11 & 1) != 0);
  v12 = *((_BYTE *)a1 + 56);
  if ((v12 & 1) != 0)
  {
    v13 = (void *)a1[6];
    if (v13)
    {
      os_release(v13);
      v12 = *((_BYTE *)a1 + 56);
    }
  }
  a1[6] = 0;
  *((_BYTE *)a1 + 56) = v12 | 1;
  v14 = *((_BYTE *)a1 + 72);
  if ((v14 & 1) != 0)
  {
    v15 = (void *)a1[8];
    if (v15)
    {
      os_release(v15);
      v14 = *((_BYTE *)a1 + 72);
    }
  }
  a1[8] = 0;
  *((_BYTE *)a1 + 72) = v14 | 1;
  v16 = *((_BYTE *)a1 + 142);
  *((_DWORD *)a1 + 34) = 0;
  *((_BYTE *)a1 + 142) = v16 & 0xE2;
  *((_WORD *)a1 + 70) = 2;
}

void nw_protocol_plugin_metadata_set_callbacks(uint64_t a1, void *object, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v9;
  void *v10;
  char v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  _BOOL4 v20;
  const char *v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_92;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_91;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v18 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (!v18)
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_91;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v30 = 2082;
        v31 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
LABEL_92:
      if (v13)
        goto LABEL_93;
      return;
    }
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_92;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v16 = "%{public}s called with null protocol";
    goto LABEL_91;
  }
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_92;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_91;
      }
      v19 = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v20 = os_log_type_enabled(v14, type);
      if (!v19)
      {
        if (!v20)
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_91;
      }
      if (!v20)
        goto LABEL_65;
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      v30 = 2082;
      v31 = v19;
      v21 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_64;
    }
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_92;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v16 = "%{public}s called with null protocol->handle";
LABEL_91:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_92;
  }
  v6 = *(_QWORD *)(v5 + 72);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_92;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null metadata_plugin, backtrace limit exceeded";
        goto LABEL_91;
      }
      v19 = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v22 = os_log_type_enabled(v14, type);
      if (!v19)
      {
        if (!v22)
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null metadata_plugin, no backtrace";
        goto LABEL_91;
      }
      if (!v22)
        goto LABEL_65;
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      v30 = 2082;
      v31 = v19;
      v21 = "%{public}s called with null metadata_plugin, dumping backtrace:%{public}s";
      goto LABEL_64;
    }
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_92;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v16 = "%{public}s called with null metadata_plugin";
    goto LABEL_91;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_92;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null input_processor, backtrace limit exceeded";
        goto LABEL_91;
      }
      v19 = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v23 = os_log_type_enabled(v14, type);
      if (!v19)
      {
        if (!v23)
          goto LABEL_92;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_plugin_metadata_set_callbacks";
        v16 = "%{public}s called with null input_processor, no backtrace";
        goto LABEL_91;
      }
      if (!v23)
        goto LABEL_65;
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      v30 = 2082;
      v31 = v19;
      v21 = "%{public}s called with null input_processor, dumping backtrace:%{public}s";
      goto LABEL_64;
    }
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_92;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v16 = "%{public}s called with null input_processor";
    goto LABEL_91;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_92;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_92;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      v16 = "%{public}s called with null output_processor";
      goto LABEL_91;
    }
    if (!v26)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_92;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      v16 = "%{public}s called with null output_processor, backtrace limit exceeded";
      goto LABEL_91;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v24 = os_log_type_enabled(v14, type);
    if (!v19)
    {
      if (!v24)
        goto LABEL_92;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_plugin_metadata_set_callbacks";
      v16 = "%{public}s called with null output_processor, no backtrace";
      goto LABEL_91;
    }
    if (!v24)
      goto LABEL_65;
    *(_DWORD *)buf = 136446466;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v30 = 2082;
    v31 = v19;
    v21 = "%{public}s called with null output_processor, dumping backtrace:%{public}s";
LABEL_64:
    _os_log_impl(&dword_182FBE000, v14, v15, v21, buf, 0x16u);
    goto LABEL_65;
  }
  v9 = *(_QWORD **)(a1 + 24);
  if (v9)
  {
    if (object)
    {
      v10 = os_retain(object);
      v11 = *(_BYTE *)(v6 + 88);
      if ((v11 & 1) == 0)
        goto LABEL_13;
    }
    else
    {
      v10 = 0;
      v11 = *(_BYTE *)(v6 + 88);
      if ((v11 & 1) == 0)
      {
LABEL_13:
        *(_QWORD *)(v6 + 80) = v10;
        *(_BYTE *)(v6 + 88) = v11 | 1;
        *(_QWORD *)(v6 + 96) = a3;
        *(_QWORD *)(v6 + 104) = a4;
        *(_QWORD *)(v6 + 128) = a1;
        v9[12] = nw_protocol_plugin_metadata_finalize_output_frames;
        v9[9] = nw_protocol_plugin_metadata_output_available;
        v9[10] = nw_protocol_plugin_metadata_get_input_frames;
        v9[4] = nw_protocol_plugins_disconnect;
        v9[5] = nw_protocol_plugins_connected;
        v9[23] = nw_protocol_plugins_input_finished;
        v9[6] = nw_protocol_plugins_disconnected;
        v9[7] = nw_protocol_plugins_error;
        v9[20] = nw_protocol_plugins_notify;
        v9[32] = nw_protocol_plugins_reset;
        return;
      }
    }
    v12 = *(void **)(v6 + 80);
    if (v12)
    {
      os_release(v12);
      v11 = *(_BYTE *)(v6 + 88);
    }
    goto LABEL_13;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v29 = "nw_protocol_plugin_metadata_set_callbacks";
  v13 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (!__nwlog_fault(v13, &type, &v26))
    goto LABEL_92;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_92;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v16 = "%{public}s called with null callbacks";
    goto LABEL_91;
  }
  if (!v26)
  {
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_92;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v16 = "%{public}s called with null callbacks, backtrace limit exceeded";
    goto LABEL_91;
  }
  v19 = (char *)__nw_create_backtrace_string();
  v14 = __nwlog_obj();
  v15 = type;
  v25 = os_log_type_enabled(v14, type);
  if (!v19)
  {
    if (!v25)
      goto LABEL_92;
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v16 = "%{public}s called with null callbacks, no backtrace";
    goto LABEL_91;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    v29 = "nw_protocol_plugin_metadata_set_callbacks";
    v30 = 2082;
    v31 = v19;
    v21 = "%{public}s called with null callbacks, dumping backtrace:%{public}s";
    goto LABEL_64;
  }
LABEL_65:
  free(v19);
  if (v13)
LABEL_93:
    free(v13);
}

void nw_protocol_plugins_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  uint64_t output_handler;
  void *v10;
  nw_protocol_callbacks *v11;
  void *v12;
  uint64_t v13;
  nw_protocol_callbacks *v14;
  void (*v15)(nw_protocol *, uint64_t);
  nw_protocol *v16;
  void *v17;
  nw_protocol_callbacks *v18;
  void *v19;
  nw_protocol_callbacks *v20;
  nw_protocol_callbacks *v21;
  void (*disconnect)(nw_protocol *, nw_protocol *);
  nw_protocol_callbacks *v23;
  nw_protocol_callbacks *v24;
  void (**v25)(_QWORD);
  const void *v26;
  nw_protocol *v27;
  void *v28;
  nw_protocol_callbacks *callbacks;
  void *v30;
  nw_protocol_callbacks *v31;
  nw_protocol_callbacks *v32;
  void (*disconnected)(nw_protocol *, nw_protocol *);
  nw_protocol_identifier *v34;
  char *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  _BOOL4 v39;
  nw_protocol_identifier *v40;
  nw_protocol_callbacks *v41;
  nw_protocol_callbacks *v42;
  nw_protocol_callbacks *v43;
  nw_protocol_identifier *v44;
  char *v45;
  _BOOL4 v46;
  nw_protocol_identifier *v47;
  nw_protocol_callbacks *v48;
  nw_protocol_callbacks *v49;
  nw_protocol_callbacks *v50;
  nw_protocol_callbacks *v51;
  nw_protocol_callbacks *v52;
  void (**v53)(_QWORD);
  const void *v54;
  nw_protocol_callbacks *v55;
  nw_protocol_callbacks *v56;
  void (**v57)(_QWORD);
  const void *v58;
  nw_protocol_callbacks *v59;
  nw_protocol_callbacks *v60;
  void (**v61)(_QWORD);
  const void *v62;
  nw_protocol_callbacks *v63;
  nw_protocol_callbacks *v64;
  void (**v65)(_QWORD);
  const void *v66;
  uint64_t v67;
  uint64_t v68;
  void (**v69)(_QWORD);
  const void *v70;
  const char *v71;
  NSObject *v72;
  os_log_type_t v73;
  const char *v74;
  NSObject *v75;
  nw_protocol_identifier *identifier;
  const char *name;
  char *v78;
  NSObject *v79;
  os_log_type_t v80;
  const char *v81;
  const char *v82;
  NSObject *v83;
  char *backtrace_string;
  _BOOL4 v85;
  char *v86;
  _BOOL4 v87;
  const char *v88;
  _BOOL4 v89;
  NSObject *v90;
  nw_protocol_identifier *v91;
  nw_protocol_identifier *v92;
  char *v93;
  NSObject *v94;
  os_log_type_t v95;
  nw_protocol_identifier *v96;
  const char *v97;
  char *v98;
  _BOOL4 v99;
  const char *v100;
  NSObject *v101;
  nw_protocol_identifier *v102;
  nw_protocol_identifier *v103;
  const char *v104;
  NSObject *v105;
  nw_protocol_identifier *v106;
  NSObject *v107;
  os_log_type_t v108;
  const char *v109;
  void *v110;
  char *v111;
  _BOOL4 v112;
  nw_protocol_identifier *v113;
  NSObject *v114;
  nw_protocol_identifier *v115;
  nw_protocol_identifier *v116;
  const char *v117;
  nw_protocol_identifier *v118;
  char *v119;
  _BOOL4 v120;
  const char *v121;
  nw_protocol_identifier *v122;
  nw_protocol_identifier *v123;
  nw_protocol_identifier *v124;
  nw_protocol_identifier *v125;
  char v126;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v129;
  __int16 v130;
  nw_protocol *v131;
  __int16 v132;
  nw_protocol *v133;
  __int16 v134;
  char *v135;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v129 = "nw_protocol_plugins_disconnect";
    v71 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v126 = 0;
    if (!__nwlog_fault(v71, &type, &v126))
      goto LABEL_265;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v72 = __nwlog_obj();
      v73 = type;
      if (!os_log_type_enabled(v72, type))
        goto LABEL_265;
      *(_DWORD *)buf = 136446210;
      v129 = "nw_protocol_plugins_disconnect";
      v74 = "%{public}s called with null protocol";
    }
    else if (v126)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v72 = __nwlog_obj();
      v73 = type;
      v85 = os_log_type_enabled(v72, type);
      if (backtrace_string)
      {
        if (v85)
        {
          *(_DWORD *)buf = 136446466;
          v129 = "nw_protocol_plugins_disconnect";
          v130 = 2082;
          v131 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v72, v73, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_265:
        if (!v71)
          return;
        goto LABEL_266;
      }
      if (!v85)
        goto LABEL_265;
      *(_DWORD *)buf = 136446210;
      v129 = "nw_protocol_plugins_disconnect";
      v74 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v72 = __nwlog_obj();
      v73 = type;
      if (!os_log_type_enabled(v72, type))
        goto LABEL_265;
      *(_DWORD *)buf = 136446210;
      v129 = "nw_protocol_plugins_disconnect";
      v74 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_264;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v129 = "nw_protocol_plugins_disconnect";
    v71 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v126 = 0;
    if (!__nwlog_fault(v71, &type, &v126))
      goto LABEL_265;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v126)
      {
        v72 = __nwlog_obj();
        v73 = type;
        if (!os_log_type_enabled(v72, type))
          goto LABEL_265;
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_plugins_disconnect";
        v74 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_264;
      }
      v86 = (char *)__nw_create_backtrace_string();
      v72 = __nwlog_obj();
      v73 = type;
      v87 = os_log_type_enabled(v72, type);
      if (!v86)
      {
        if (!v87)
          goto LABEL_265;
        *(_DWORD *)buf = 136446210;
        v129 = "nw_protocol_plugins_disconnect";
        v74 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_264;
      }
      if (v87)
      {
        *(_DWORD *)buf = 136446466;
        v129 = "nw_protocol_plugins_disconnect";
        v130 = 2082;
        v131 = (nw_protocol *)v86;
        v88 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
LABEL_185:
        _os_log_impl(&dword_182FBE000, v72, v73, v88, buf, 0x16u);
      }
LABEL_186:
      free(v86);
      if (!v71)
        return;
LABEL_266:
      v27 = (nw_protocol *)v71;
LABEL_121:
      free(v27);
      return;
    }
    v72 = __nwlog_obj();
    v73 = type;
    if (!os_log_type_enabled(v72, type))
      goto LABEL_265;
    *(_DWORD *)buf = 136446210;
    v129 = "nw_protocol_plugins_disconnect";
    v74 = "%{public}s called with null protocol->handle";
LABEL_264:
    _os_log_impl(&dword_182FBE000, v72, v73, v74, buf, 0xCu);
    goto LABEL_265;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v129 = "nw_protocol_plugins_handle_disconnect";
    v71 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v126 = 0;
    if (!__nwlog_fault(v71, &type, &v126))
      goto LABEL_265;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v72 = __nwlog_obj();
      v73 = type;
      if (!os_log_type_enabled(v72, type))
        goto LABEL_265;
      *(_DWORD *)buf = 136446210;
      v129 = "nw_protocol_plugins_handle_disconnect";
      v74 = "%{public}s called with null other_protocol";
      goto LABEL_264;
    }
    if (!v126)
    {
      v72 = __nwlog_obj();
      v73 = type;
      if (!os_log_type_enabled(v72, type))
        goto LABEL_265;
      *(_DWORD *)buf = 136446210;
      v129 = "nw_protocol_plugins_handle_disconnect";
      v74 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_264;
    }
    v86 = (char *)__nw_create_backtrace_string();
    v72 = __nwlog_obj();
    v73 = type;
    v89 = os_log_type_enabled(v72, type);
    if (!v86)
    {
      if (!v89)
        goto LABEL_265;
      *(_DWORD *)buf = 136446210;
      v129 = "nw_protocol_plugins_handle_disconnect";
      v74 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_264;
    }
    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      v129 = "nw_protocol_plugins_handle_disconnect";
      v130 = 2082;
      v131 = (nw_protocol *)v86;
      v88 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_185;
    }
    goto LABEL_186;
  }
  if (gLogDatapath)
  {
    v75 = __nwlog_obj();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      identifier = a1->identifier;
      if (!identifier)
        identifier = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v129 = "nw_protocol_plugins_handle_disconnect";
      v130 = 2080;
      v131 = (nw_protocol *)identifier;
      v132 = 2048;
      v133 = a1;
      _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
    }
  }
  v5 = handle[11];
  if (v5)
  {
    if (gLogDatapath)
    {
      v83 = __nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "nw_protocol_plugin_retry_disconnect";
        v130 = 2048;
        v131 = a1;
        _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s called %p", buf, 0x16u);
      }
    }
    v6 = *(_BYTE *)(v5 + 212);
    *(_BYTE *)(v5 + 212) = v6 | 0x80;
    if ((v6 & 0x20) != 0)
    {
      if (gLogDatapath)
      {
        v101 = __nwlog_obj();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v129 = "nw_protocol_plugin_retry_disconnect";
          v130 = 2048;
          v131 = a1;
          v132 = 2048;
          v133 = a2;
          _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_DEBUG, "%{public}s %p sending disconnected immediately to %p as async reissue is pending", buf, 0x20u);
        }
      }
      v28 = a2->handle;
      if (v28 == &nw_protocol_ref_counted_handle)
      {
        callbacks = a2[1].callbacks;
        if (callbacks)
          a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      v30 = a1->handle;
      if (v30 == &nw_protocol_ref_counted_handle)
      {
        v31 = a1[1].callbacks;
        if (v31)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v31->add_input_handler + 1);
      }
      v32 = a2->callbacks;
      if (v32)
      {
        disconnected = (void (*)(nw_protocol *, nw_protocol *))v32->disconnected;
        if (disconnected)
          goto LABEL_99;
      }
      __nwlog_obj();
      v34 = a2->identifier;
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_disconnected";
      if (!v34)
        v34 = (nw_protocol_identifier *)"invalid";
      v130 = 2082;
      v131 = (nw_protocol *)v34;
      v132 = 2048;
      v133 = a2;
      v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v126 = 0;
      if (!__nwlog_fault(v35, &type, &v126))
        goto LABEL_299;
      if (type == OS_LOG_TYPE_FAULT)
        goto LABEL_213;
      if (v126)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v37 = __nwlog_obj();
        v38 = type;
        v39 = os_log_type_enabled(v37, type);
        if (v36)
        {
          if (v39)
          {
            if (a2->identifier)
              v40 = a2->identifier;
            else
              v40 = (nw_protocol_identifier *)"invalid";
            *(_DWORD *)buf = 136446978;
            v129 = "__nw_protocol_disconnected";
            v130 = 2082;
            v131 = (nw_protocol *)v40;
            v132 = 2048;
            v133 = a2;
            v134 = 2082;
            v135 = v36;
            _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v36);
          goto LABEL_299;
        }
LABEL_267:
        if (!v39)
          goto LABEL_299;
        v118 = a2->identifier;
        if (!v118)
          v118 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v129 = "__nw_protocol_disconnected";
        v130 = 2082;
        v131 = (nw_protocol *)v118;
        goto LABEL_297;
      }
    }
    else
    {
      if (((*(uint64_t (**)(nw_protocol *, nw_protocol *))(v5 + 136))(a1, a2) & 1) != 0)
        goto LABEL_9;
      if (gLogDatapath)
      {
        v114 = __nwlog_obj();
        if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v129 = "nw_protocol_plugin_retry_disconnect";
          v130 = 2048;
          v131 = a1;
          v132 = 2048;
          v133 = a2;
          _os_log_impl(&dword_182FBE000, v114, OS_LOG_TYPE_DEBUG, "%{public}s %p sending disconnected immediately to %p without disconnect", buf, 0x20u);
        }
      }
      v28 = a2->handle;
      if (v28 == &nw_protocol_ref_counted_handle)
      {
        v48 = a2[1].callbacks;
        if (v48)
          a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v48->add_input_handler + 1);
      }
      v30 = a1->handle;
      if (v30 == &nw_protocol_ref_counted_handle)
      {
        v49 = a1[1].callbacks;
        if (v49)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v49->add_input_handler + 1);
      }
      v50 = a2->callbacks;
      if (v50)
      {
        disconnected = (void (*)(nw_protocol *, nw_protocol *))v50->disconnected;
        if (disconnected)
          goto LABEL_99;
      }
      __nwlog_obj();
      v102 = a2->identifier;
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_disconnected";
      if (!v102)
        v102 = (nw_protocol_identifier *)"invalid";
      v130 = 2082;
      v131 = (nw_protocol *)v102;
      v132 = 2048;
      v133 = a2;
      v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v126 = 0;
      if (!__nwlog_fault(v35, &type, &v126))
        goto LABEL_299;
      if (type == OS_LOG_TYPE_FAULT)
        goto LABEL_213;
      if (v126)
      {
        v45 = (char *)__nw_create_backtrace_string();
        v37 = __nwlog_obj();
        v38 = type;
        v39 = os_log_type_enabled(v37, type);
        if (v45)
        {
          if (!v39)
            goto LABEL_248;
          if (a2->identifier)
            v115 = a2->identifier;
          else
            v115 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446978;
          v129 = "__nw_protocol_disconnected";
          v130 = 2082;
          v131 = (nw_protocol *)v115;
          v132 = 2048;
          v133 = a2;
          v134 = 2082;
LABEL_247:
          v135 = v45;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
LABEL_248:
          free(v45);
          if (!v35)
            goto LABEL_100;
          goto LABEL_300;
        }
        goto LABEL_267;
      }
    }
    v37 = __nwlog_obj();
    v38 = type;
    if (!os_log_type_enabled(v37, type))
      goto LABEL_299;
    v116 = a2->identifier;
    if (!v116)
      v116 = (nw_protocol_identifier *)"invalid";
    *(_DWORD *)buf = 136446722;
    v129 = "__nw_protocol_disconnected";
    v130 = 2082;
    v131 = (nw_protocol *)v116;
    goto LABEL_288;
  }
LABEL_9:
  v7 = handle[9];
  if (v7)
  {
    if (gLogDatapath)
    {
      v90 = __nwlog_obj();
      if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
      {
        v91 = a1->identifier;
        if (!v91)
          v91 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v129 = "nw_protocol_plugin_metadata_disconnect";
        v130 = 2048;
        v131 = a1;
        v132 = 2080;
        v133 = (nw_protocol *)v91;
        _os_log_impl(&dword_182FBE000, v90, OS_LOG_TYPE_DEBUG, "%{public}s protocol %p:%s disconnect", buf, 0x20u);
      }
    }
    v8 = *(_BYTE *)(v7 + 142);
    if ((v8 & 1) != 0)
      *(_BYTE *)(v7 + 140) = 3;
    *(_BYTE *)(v7 + 142) = v8 & 0xFE;
    if ((v8 & 8) != 0)
    {
      if (gLogDatapath)
      {
        v105 = __nwlog_obj();
        if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
        {
          v106 = a1->identifier;
          if (!v106)
            v106 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          v129 = "nw_protocol_plugin_metadata_disconnect";
          v130 = 2048;
          v131 = a1;
          v132 = 2080;
          v133 = (nw_protocol *)v106;
          _os_log_impl(&dword_182FBE000, v105, OS_LOG_TYPE_DEBUG, "%{public}s protocol %p:%s sending disconnected immediately as it had previously received disconnected", buf, 0x20u);
        }
      }
      *(_BYTE *)(v7 + 142) &= ~8u;
      output_handler = (uint64_t)a1->output_handler;
      v10 = a1->handle;
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        v11 = a1[1].callbacks;
        if (v11)
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v11->add_input_handler + 1);
      }
      if (output_handler)
      {
        v12 = *(void **)(output_handler + 40);
        if (v12 == &nw_protocol_ref_counted_handle)
        {
          v13 = *(_QWORD *)(output_handler + 88);
          if (v13)
            *(_QWORD *)(output_handler + 88) = v13 + 1;
        }
        v14 = a1->callbacks;
        if (v14)
        {
          v15 = (void (*)(nw_protocol *, uint64_t))v14->disconnected;
          if (v15)
          {
            v15(a1, output_handler);
LABEL_25:
            if (v12 != &nw_protocol_ref_counted_handle
              || *(_UNKNOWN **)(output_handler + 40) != &nw_protocol_ref_counted_handle
              || (v67 = *(_QWORD *)(output_handler + 88)) == 0
              || (v68 = v67 - 1, (*(_QWORD *)(output_handler + 88) = v68) != 0))
            {
LABEL_27:
              if (v10 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
              {
                v63 = a1[1].callbacks;
                if (v63)
                {
                  v64 = (nw_protocol_callbacks *)((char *)v63 - 1);
                  a1[1].callbacks = v64;
                  if (!v64)
                  {
                    v65 = *(void (***)(_QWORD))a1[1].flow_id;
                    if (v65)
                    {
                      *(_QWORD *)a1[1].flow_id = 0;
                      v65[2](v65);
                      _Block_release(v65);
                    }
                    if ((a1[1].flow_id[8] & 1) != 0)
                    {
                      v66 = *(const void **)a1[1].flow_id;
                      if (v66)
                        _Block_release(v66);
                    }
                    free(a1);
                  }
                }
              }
              goto LABEL_29;
            }
            v69 = *(void (***)(_QWORD))(output_handler + 64);
            if (v69)
            {
              *(_QWORD *)(output_handler + 64) = 0;
              v69[2](v69);
              _Block_release(v69);
            }
            if ((*(_BYTE *)(output_handler + 72) & 1) != 0)
            {
              v70 = *(const void **)(output_handler + 64);
              if (v70)
                _Block_release(v70);
            }
LABEL_145:
            free((void *)output_handler);
            goto LABEL_27;
          }
        }
        __nwlog_obj();
        v92 = a1->identifier;
        *(_DWORD *)buf = 136446722;
        v129 = "__nw_protocol_disconnected";
        if (!v92)
          v92 = (nw_protocol_identifier *)"invalid";
        v130 = 2082;
        v131 = (nw_protocol *)v92;
        v132 = 2048;
        v133 = a1;
        v93 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v126 = 0;
        if (__nwlog_fault(v93, &type, &v126))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v94 = __nwlog_obj();
            v95 = type;
            if (!os_log_type_enabled(v94, type))
              goto LABEL_306;
            v96 = a1->identifier;
            if (!v96)
              v96 = (nw_protocol_identifier *)"invalid";
            *(_DWORD *)buf = 136446722;
            v129 = "__nw_protocol_disconnected";
            v130 = 2082;
            v131 = (nw_protocol *)v96;
            v132 = 2048;
            v133 = a1;
            v97 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
            goto LABEL_305;
          }
          v110 = v12;
          if (!v126)
          {
            v94 = __nwlog_obj();
            v95 = type;
            if (!os_log_type_enabled(v94, type))
              goto LABEL_306;
            v123 = a1->identifier;
            if (!v123)
              v123 = (nw_protocol_identifier *)"invalid";
            *(_DWORD *)buf = 136446722;
            v129 = "__nw_protocol_disconnected";
            v130 = 2082;
            v131 = (nw_protocol *)v123;
            v132 = 2048;
            v133 = a1;
            v97 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
            goto LABEL_305;
          }
          v111 = (char *)__nw_create_backtrace_string();
          v94 = __nwlog_obj();
          v95 = type;
          v112 = os_log_type_enabled(v94, type);
          if (v111)
          {
            if (v112)
            {
              v113 = a1->identifier;
              if (!v113)
                v113 = (nw_protocol_identifier *)"invalid";
              *(_DWORD *)buf = 136446978;
              v129 = "__nw_protocol_disconnected";
              v130 = 2082;
              v131 = (nw_protocol *)v113;
              v132 = 2048;
              v133 = a1;
              v134 = 2082;
              v135 = v111;
              _os_log_impl(&dword_182FBE000, v94, v95, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v111);
            v12 = v110;
            goto LABEL_306;
          }
          v12 = v110;
          if (v112)
          {
            v125 = a1->identifier;
            if (!v125)
              v125 = (nw_protocol_identifier *)"invalid";
            *(_DWORD *)buf = 136446722;
            v129 = "__nw_protocol_disconnected";
            v130 = 2082;
            v131 = (nw_protocol *)v125;
            v132 = 2048;
            v133 = a1;
            v97 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_305:
            _os_log_impl(&dword_182FBE000, v94, v95, v97, buf, 0x20u);
          }
        }
LABEL_306:
        if (v93)
          free(v93);
        goto LABEL_25;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v129 = "__nw_protocol_disconnected";
      output_handler = _os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v126 = 0;
      if (__nwlog_fault((const char *)output_handler, &type, &v126))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v107 = __nwlog_obj();
          v108 = type;
          if (!os_log_type_enabled(v107, type))
            goto LABEL_313;
          *(_DWORD *)buf = 136446210;
          v129 = "__nw_protocol_disconnected";
          v109 = "%{public}s called with null other_protocol";
          goto LABEL_312;
        }
        if (!v126)
        {
          v107 = __nwlog_obj();
          v108 = type;
          if (!os_log_type_enabled(v107, type))
            goto LABEL_313;
          *(_DWORD *)buf = 136446210;
          v129 = "__nw_protocol_disconnected";
          v109 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_312;
        }
        v119 = (char *)__nw_create_backtrace_string();
        v107 = __nwlog_obj();
        v108 = type;
        v120 = os_log_type_enabled(v107, type);
        if (v119)
        {
          if (v120)
          {
            *(_DWORD *)buf = 136446466;
            v129 = "__nw_protocol_disconnected";
            v130 = 2082;
            v131 = (nw_protocol *)v119;
            _os_log_impl(&dword_182FBE000, v107, v108, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v119);
          if (!output_handler)
            goto LABEL_27;
          goto LABEL_145;
        }
        if (v120)
        {
          *(_DWORD *)buf = 136446210;
          v129 = "__nw_protocol_disconnected";
          v109 = "%{public}s called with null other_protocol, no backtrace";
LABEL_312:
          _os_log_impl(&dword_182FBE000, v107, v108, v109, buf, 0xCu);
        }
      }
LABEL_313:
      if (!output_handler)
        goto LABEL_27;
      goto LABEL_145;
    }
  }
LABEL_29:
  v16 = a1->output_handler;
  if (!v16)
  {
    v28 = a2->handle;
    if (v28 == &nw_protocol_ref_counted_handle)
    {
      v41 = a2[1].callbacks;
      if (v41)
        a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v41->add_input_handler + 1);
    }
    v30 = a1->handle;
    if (v30 == &nw_protocol_ref_counted_handle)
    {
      v42 = a1[1].callbacks;
      if (v42)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v42->add_input_handler + 1);
    }
    v43 = a2->callbacks;
    if (!v43 || (disconnected = (void (*)(nw_protocol *, nw_protocol *))v43->disconnected) == 0)
    {
      __nwlog_obj();
      v44 = a2->identifier;
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_disconnected";
      if (!v44)
        v44 = (nw_protocol_identifier *)"invalid";
      v130 = 2082;
      v131 = (nw_protocol *)v44;
      v132 = 2048;
      v133 = a2;
      v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v126 = 0;
      if (__nwlog_fault(v35, &type, &v126))
      {
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (v126)
          {
            v45 = (char *)__nw_create_backtrace_string();
            v37 = __nwlog_obj();
            v38 = type;
            v46 = os_log_type_enabled(v37, type);
            if (v45)
            {
              if (!v46)
                goto LABEL_248;
              v47 = a2->identifier;
              if (!v47)
                v47 = (nw_protocol_identifier *)"invalid";
              *(_DWORD *)buf = 136446978;
              v129 = "__nw_protocol_disconnected";
              v130 = 2082;
              v131 = (nw_protocol *)v47;
              v132 = 2048;
              v133 = a2;
              v134 = 2082;
              goto LABEL_247;
            }
            if (!v46)
              goto LABEL_299;
            v124 = a2->identifier;
            if (!v124)
              v124 = (nw_protocol_identifier *)"invalid";
            *(_DWORD *)buf = 136446722;
            v129 = "__nw_protocol_disconnected";
            v130 = 2082;
            v131 = (nw_protocol *)v124;
LABEL_297:
            v132 = 2048;
            v133 = a2;
            v104 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
            goto LABEL_298;
          }
          v37 = __nwlog_obj();
          v38 = type;
          if (!os_log_type_enabled(v37, type))
            goto LABEL_299;
          v122 = a2->identifier;
          if (!v122)
            v122 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          v129 = "__nw_protocol_disconnected";
          v130 = 2082;
          v131 = (nw_protocol *)v122;
LABEL_288:
          v132 = 2048;
          v133 = a2;
          v104 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
LABEL_298:
          _os_log_impl(&dword_182FBE000, v37, v38, v104, buf, 0x20u);
          goto LABEL_299;
        }
LABEL_213:
        v37 = __nwlog_obj();
        v38 = type;
        if (!os_log_type_enabled(v37, type))
          goto LABEL_299;
        v103 = a2->identifier;
        if (!v103)
          v103 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v129 = "__nw_protocol_disconnected";
        v130 = 2082;
        v131 = (nw_protocol *)v103;
        v132 = 2048;
        v133 = a2;
        v104 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
        goto LABEL_298;
      }
LABEL_299:
      if (v35)
LABEL_300:
        free(v35);
LABEL_100:
      if (v30 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
      {
        v51 = a1[1].callbacks;
        if (v51)
        {
          v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
          a1[1].callbacks = v52;
          if (!v52)
          {
            v53 = *(void (***)(_QWORD))a1[1].flow_id;
            if (v53)
            {
              *(_QWORD *)a1[1].flow_id = 0;
              v53[2](v53);
              _Block_release(v53);
            }
            if ((a1[1].flow_id[8] & 1) != 0)
            {
              v54 = *(const void **)a1[1].flow_id;
              if (v54)
                _Block_release(v54);
            }
            free(a1);
          }
        }
      }
      if (v28 == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
      {
        v55 = a2[1].callbacks;
        if (v55)
        {
          v56 = (nw_protocol_callbacks *)((char *)v55 - 1);
          a2[1].callbacks = v56;
          if (!v56)
          {
            v57 = *(void (***)(_QWORD))a2[1].flow_id;
            if (v57)
            {
              *(_QWORD *)a2[1].flow_id = 0;
              v57[2](v57);
              _Block_release(v57);
            }
            if ((a2[1].flow_id[8] & 1) != 0)
            {
              v58 = *(const void **)a2[1].flow_id;
              if (v58)
                _Block_release(v58);
            }
            v27 = a2;
            goto LABEL_121;
          }
        }
      }
      return;
    }
LABEL_99:
    disconnected(a2, a1);
    goto LABEL_100;
  }
  v17 = v16->handle;
  if (v17 == &nw_protocol_ref_counted_handle)
  {
    v18 = v16[1].callbacks;
    if (v18)
      v16[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
  }
  v19 = a1->handle;
  if (v19 == &nw_protocol_ref_counted_handle)
  {
    v20 = a1[1].callbacks;
    if (v20)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v20->add_input_handler + 1);
  }
  v21 = v16->callbacks;
  if (v21)
  {
    disconnect = (void (*)(nw_protocol *, nw_protocol *))v21->disconnect;
    if (disconnect)
    {
      disconnect(v16, a1);
      goto LABEL_39;
    }
  }
  __nwlog_obj();
  name = v16->identifier->name;
  *(_DWORD *)buf = 136446722;
  v129 = "__nw_protocol_disconnect";
  if (!name)
    name = "invalid";
  v130 = 2082;
  v131 = (nw_protocol *)name;
  v132 = 2048;
  v133 = v16;
  v78 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v126 = 0;
  if (__nwlog_fault(v78, &type, &v126))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v79 = __nwlog_obj();
      v80 = type;
      if (!os_log_type_enabled(v79, type))
        goto LABEL_282;
      v81 = v16->identifier->name;
      if (!v81)
        v81 = "invalid";
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_disconnect";
      v130 = 2082;
      v131 = (nw_protocol *)v81;
      v132 = 2048;
      v133 = v16;
      v82 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
      goto LABEL_281;
    }
    if (!v126)
    {
      v79 = __nwlog_obj();
      v80 = type;
      if (!os_log_type_enabled(v79, type))
        goto LABEL_282;
      v117 = v16->identifier->name;
      if (!v117)
        v117 = "invalid";
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_disconnect";
      v130 = 2082;
      v131 = (nw_protocol *)v117;
      v132 = 2048;
      v133 = v16;
      v82 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
      goto LABEL_281;
    }
    v98 = (char *)__nw_create_backtrace_string();
    v79 = __nwlog_obj();
    v80 = type;
    v99 = os_log_type_enabled(v79, type);
    if (v98)
    {
      if (v99)
      {
        v100 = v16->identifier->name;
        if (!v100)
          v100 = "invalid";
        *(_DWORD *)buf = 136446978;
        v129 = "__nw_protocol_disconnect";
        v130 = 2082;
        v131 = (nw_protocol *)v100;
        v132 = 2048;
        v133 = v16;
        v134 = 2082;
        v135 = v98;
        _os_log_impl(&dword_182FBE000, v79, v80, "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v98);
      goto LABEL_282;
    }
    if (v99)
    {
      v121 = v16->identifier->name;
      if (!v121)
        v121 = "invalid";
      *(_DWORD *)buf = 136446722;
      v129 = "__nw_protocol_disconnect";
      v130 = 2082;
      v131 = (nw_protocol *)v121;
      v132 = 2048;
      v133 = v16;
      v82 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
LABEL_281:
      _os_log_impl(&dword_182FBE000, v79, v80, v82, buf, 0x20u);
    }
  }
LABEL_282:
  if (v78)
    free(v78);
LABEL_39:
  if (v19 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    v59 = a1[1].callbacks;
    if (v59)
    {
      v60 = (nw_protocol_callbacks *)((char *)v59 - 1);
      a1[1].callbacks = v60;
      if (!v60)
      {
        v61 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v61)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v61[2](v61);
          _Block_release(v61);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v62 = *(const void **)a1[1].flow_id;
          if (v62)
            _Block_release(v62);
        }
        free(a1);
      }
    }
  }
  if (v17 == &nw_protocol_ref_counted_handle && v16->handle == &nw_protocol_ref_counted_handle)
  {
    v23 = v16[1].callbacks;
    if (v23)
    {
      v24 = (nw_protocol_callbacks *)((char *)v23 - 1);
      v16[1].callbacks = v24;
      if (!v24)
      {
        v25 = *(void (***)(_QWORD))v16[1].flow_id;
        if (v25)
        {
          *(_QWORD *)v16[1].flow_id = 0;
          v25[2](v25);
          _Block_release(v25);
        }
        if ((v16[1].flow_id[8] & 1) != 0)
        {
          v26 = *(const void **)v16[1].flow_id;
          if (v26)
            _Block_release(v26);
        }
        v27 = v16;
        goto LABEL_121;
      }
    }
  }
}

void nw_protocol_plugins_connected(nw_protocol *a1, nw_protocol *a2)
{
  void *handle;
  uint64_t v5;
  char v6;
  nw_protocol_plugin_retry *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  nw_protocol_identifier *identifier;
  NSObject *v14;
  nw_protocol_identifier *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char *v18;
  _BOOL4 v19;
  const char *v20;
  _BOOL4 v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  nw_protocol *v27;
  __int16 v28;
  nw_protocol *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_plugins_connected";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_63;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_plugins_connected";
      v11 = "%{public}s called with null protocol";
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_plugins_connected";
          v26 = 2082;
          v27 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_63:
        if (!v8)
          return;
        goto LABEL_64;
      }
      if (!v17)
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_plugins_connected";
      v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_plugins_connected";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_62;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_plugins_connected";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_63;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_63;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_plugins_connected";
        v11 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_62;
      }
      v18 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v19 = os_log_type_enabled(v9, type);
      if (!v18)
      {
        if (!v19)
          goto LABEL_63;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_plugins_connected";
        v11 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_62;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_protocol_plugins_connected";
        v26 = 2082;
        v27 = (nw_protocol *)v18;
        v20 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
LABEL_47:
        _os_log_impl(&dword_182FBE000, v9, v10, v20, buf, 0x16u);
      }
LABEL_48:
      free(v18);
      if (!v8)
        return;
LABEL_64:
      free(v8);
      return;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_63;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_plugins_connected";
    v11 = "%{public}s called with null protocol->handle";
LABEL_62:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_63;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_plugins_handle_connected";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_63;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_plugins_handle_connected";
      v11 = "%{public}s called with null other_protocol";
      goto LABEL_62;
    }
    if (!v22)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_plugins_handle_connected";
      v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_62;
    }
    v18 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v21 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (!v21)
        goto LABEL_63;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_plugins_handle_connected";
      v11 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_62;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_protocol_plugins_handle_connected";
      v26 = 2082;
      v27 = (nw_protocol *)v18;
      v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_47;
    }
    goto LABEL_48;
  }
  if (gLogDatapath)
  {
    v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      identifier = a1->identifier;
      if (!identifier)
        identifier = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v25 = "nw_protocol_plugins_handle_connected";
      v26 = 2080;
      v27 = (nw_protocol *)identifier;
      v28 = 2048;
      v29 = a1;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
    }
  }
  v5 = *((_QWORD *)handle + 9);
  if (v5)
  {
    if (gLogDatapath)
    {
      v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v15 = a1->identifier;
        if (!v15)
          v15 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446722;
        v25 = "nw_protocol_plugin_metadata_connected";
        v26 = 2048;
        v27 = a1;
        v28 = 2080;
        v29 = (nw_protocol *)v15;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s protocol %p:%s got connected event", buf, 0x20u);
      }
    }
    v6 = *(_BYTE *)(v5 + 142);
    if ((v6 & 1) == 0)
    {
      v6 |= 1u;
      *(_BYTE *)(v5 + 140) = 0;
    }
    *(_BYTE *)(v5 + 142) = v6 & 0xEF;
  }
  v7 = (nw_protocol_plugin_retry *)*((_QWORD *)handle + 11);
  if (v7)
    nw_protocol_plugin_retry_connected(v7, a1, a2);
  else
    nw_protocol_common_connected((uint64_t)a1, (uint64_t)a2);
}

void nw_protocol_plugins_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v5;
  uint64_t v6;
  char v7;
  unsigned int (*v8)(nw_protocol *, nw_protocol *, BOOL);
  NSObject *v9;
  NSObject *v10;
  nw_protocol_identifier *v11;
  const char *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  NSObject *v21;
  nw_protocol_identifier *identifier;
  char *backtrace_string;
  _BOOL4 v24;
  char *v25;
  _BOOL4 v26;
  char *v27;
  _BOOL4 v28;
  nw_protocol_identifier *v29;
  NSObject *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  nw_protocol_identifier *v36;
  __int16 v37;
  nw_protocol *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_plugins_input_finished";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31))
      goto LABEL_78;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_78;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_input_finished";
      v16 = "%{public}s called with null protocol";
      goto LABEL_77;
    }
    if (!v31)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_78;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_input_finished";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_77;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v24)
        goto LABEL_78;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_input_finished";
      v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_77;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_protocol_plugins_input_finished";
      v35 = 2082;
      v36 = (nw_protocol_identifier *)backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_78:
    if (!v13)
      return;
    goto LABEL_79;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_plugins_input_finished";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31))
      goto LABEL_78;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_78;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_input_finished";
      v16 = "%{public}s called with null protocol->handle";
      goto LABEL_77;
    }
    if (!v31)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_78;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_input_finished";
      v16 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_77;
    }
    v25 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v26 = os_log_type_enabled(v14, type);
    if (v25)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v34 = "nw_protocol_plugins_input_finished";
        v35 = 2082;
        v36 = (nw_protocol_identifier *)v25;
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol->handle, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v25);
      if (!v13)
        return;
LABEL_79:
      free(v13);
      return;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_input_finished";
      v16 = "%{public}s called with null protocol->handle, no backtrace";
LABEL_77:
      _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
      goto LABEL_78;
    }
    goto LABEL_78;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_plugins_handle_input_finished";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v17, &type, &v31))
      goto LABEL_83;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_83;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_handle_input_finished";
      v20 = "%{public}s called with null other_protocol";
    }
    else if (v31)
    {
      v27 = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v28 = os_log_type_enabled(v18, type);
      if (v27)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_protocol_plugins_handle_input_finished";
          v35 = 2082;
          v36 = (nw_protocol_identifier *)v27;
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v27);
        goto LABEL_83;
      }
      if (!v28)
      {
LABEL_83:
        if (v17)
          free(v17);
        goto LABEL_16;
      }
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_handle_input_finished";
      v20 = "%{public}s called with null other_protocol, no backtrace";
    }
    else
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_83;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugins_handle_input_finished";
      v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
    goto LABEL_83;
  }
  if (gLogDatapath)
  {
    v21 = __nwlog_obj();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      identifier = a1->identifier;
      if (!identifier)
        identifier = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v34 = "nw_protocol_plugins_handle_input_finished";
      v35 = 2080;
      v36 = identifier;
      v37 = 2048;
      v38 = a1;
      _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
    }
  }
  v5 = handle[11];
  if (v5 && (*(_BYTE *)(v5 + 212) & 0x20) != 0)
    return;
  v6 = handle[9];
  if (!v6)
    goto LABEL_11;
  v7 = *(_BYTE *)(v6 + 142);
  if ((v7 & 2) != 0)
  {
LABEL_21:
    *(_BYTE *)(v6 + 142) = v7 | 4;
    if (gLogDatapath)
    {
      v10 = __nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v29 = (nw_protocol_identifier *)"invalid";
        if (a1->identifier)
          v29 = a1->identifier;
        *(_DWORD *)buf = 136446466;
        v34 = "nw_protocol_plugins_handle_input_finished";
        v35 = 2080;
        v36 = v29;
        v12 = "%{public}s metadata plugin for %s caused input_finished to defer input_finished";
        goto LABEL_66;
      }
    }
    return;
  }
  if (!nw_protocol_plugin_metadata_handle_eof(handle[9], a1))
  {
    v7 = *(_BYTE *)(v6 + 142);
    goto LABEL_21;
  }
  v5 = handle[11];
LABEL_11:
  if (!v5)
  {
LABEL_16:
    nw_protocol_common_input_finished((uint64_t)a1, (uint64_t)a2);
    return;
  }
  if ((*(_BYTE *)(v5 + 212) & 0x10) != 0)
  {
    if (!gLogDatapath)
      return;
    v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_plugin_retry_input_finished";
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s holding onto input_finished because reissuing", buf, 0xCu);
    }
  }
  else if ((*(_BYTE *)(v5 + 212) & 1) != 0)
  {
    if (gLogDatapath)
    {
      v30 = __nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_plugin_retry_input_finished";
        _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s holding onto input_finished because getting input frames", buf, 0xCu);
      }
    }
    *(_BYTE *)(v5 + 212) |= 4u;
  }
  else
  {
    v8 = *(unsigned int (**)(nw_protocol *, nw_protocol *, BOOL))(v5 + 152);
    if (!v8 || !v8(a1, a2, *(_DWORD *)(v5 + 208) != 0))
      goto LABEL_16;
  }
  if (gLogDatapath)
  {
    v10 = __nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v11 = (nw_protocol_identifier *)"invalid";
      if (a1->identifier)
        v11 = a1->identifier;
      *(_DWORD *)buf = 136446466;
      v34 = "nw_protocol_plugins_handle_input_finished";
      v35 = 2080;
      v36 = v11;
      v12 = "%{public}s retry plugin for %s caused input_finished to defer input_finished";
LABEL_66:
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, v12, buf, 0x16u);
    }
  }
}

void nw_protocol_plugins_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v5;
  uint64_t v6;
  char v7;
  int v8;
  uint64_t (*v9)(nw_protocol *, nw_protocol *, BOOL);
  int v10;
  nw_frame_array_s *v11;
  uint64_t v12;
  nw_frame *tqh_first;
  nw_frame *v14;
  char v15;
  nw_frame_array_s *v16;
  nw_frame *v17;
  nw_frame *v18;
  char v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  NSObject *v28;
  nw_protocol_identifier *identifier;
  char *backtrace_string;
  _BOOL4 v31;
  char *v32;
  _BOOL4 v33;
  char *v34;
  _BOOL4 v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  _BOOL4 v42;
  char v43;
  os_log_type_t type;
  _BYTE buf[24];
  nw_protocol *v46;
  nw_frame_array_s *v47;
  char v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
    v20 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (!__nwlog_fault(v20, &type, &v43))
      goto LABEL_89;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
      v23 = "%{public}s called with null protocol";
    }
    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v21 = __nwlog_obj();
      v22 = type;
      v31 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_89:
        if (!v20)
          return;
LABEL_90:
        free(v20);
        return;
      }
      if (!v31)
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
      v23 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
      v23 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_88:
    _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0xCu);
    goto LABEL_89;
  }
  handle = a1->handle;
  if (handle)
  {
    if (a2)
    {
      if (gLogDatapath)
      {
        v28 = __nwlog_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          identifier = a1->identifier;
          if (!identifier)
            identifier = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_plugins_handle_disconnected";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = identifier;
          *(_WORD *)&buf[22] = 2048;
          v46 = a1;
          _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
        }
      }
      v5 = handle[11];
      if (v5 && (*(_BYTE *)(v5 + 212) & 0x20) != 0)
        goto LABEL_22;
      v6 = handle[9];
      if (v6)
      {
        v7 = *(_BYTE *)(v6 + 142);
        if ((v7 & 2) == 0)
        {
          if (nw_protocol_plugin_metadata_handle_eof(handle[9], a1))
          {
            v5 = handle[11];
            goto LABEL_11;
          }
          v7 = *(_BYTE *)(v6 + 142);
        }
        v10 = 0;
        *(_BYTE *)(v6 + 142) = v7 | 8;
        goto LABEL_23;
      }
LABEL_11:
      if (v5)
      {
        v8 = *(char *)(v5 + 212);
        if ((v8 & 0x80000000) == 0)
        {
          if ((v8 & 0x10) == 0)
          {
            if ((v8 & 1) == 0)
            {
              v9 = *(uint64_t (**)(nw_protocol *, nw_protocol *, BOOL))(v5 + 152);
              if (v9)
              {
                v10 = v9(a1, a2, *(_DWORD *)(v5 + 208) != 0) ^ 1;
                goto LABEL_23;
              }
              goto LABEL_20;
            }
            if (gLogDatapath)
            {
              v40 = v5;
              v41 = __nwlog_obj();
              v42 = os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG);
              v5 = v40;
              if (v42)
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_disconnected";
                _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s holding onto disconnected because getting input frames", buf, 0xCu);
                v5 = v40;
              }
            }
            v10 = 0;
            *(_BYTE *)(v5 + 212) |= 2u;
LABEL_23:
            v11 = (nw_frame_array_s *)handle[9];
            if (v11)
            {
              if ((BYTE6(v11[8].tqh_last) & 1) != 0)
              {
                nw_protocol_plugin_metadata_deep_copy_input_frame_array((nw_frame_array_s *)handle[9]);
                nw_protocol_plugin_metadata_deep_copy_input_frame_array(v11 + 1);
                if ((v10 & 1) == 0)
                  return;
              }
              else
              {
                if (gLogDatapath)
                {
                  v36 = __nwlog_obj();
                  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
                    _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                  }
                }
                v12 = MEMORY[0x1E0C809B0];
                *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                *(_QWORD *)&buf[8] = 0x40000000;
                *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
                v46 = (nw_protocol *)&__block_descriptor_tmp_34_3301;
                v47 = v11;
                v48 = 0;
                tqh_first = v11->tqh_first;
                do
                {
                  if (!tqh_first)
                    break;
                  v14 = (nw_frame *)*((_QWORD *)tqh_first + 4);
                  v15 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                  tqh_first = v14;
                }
                while ((v15 & 1) != 0);
                v16 = v11 + 1;
                if (gLogDatapath)
                {
                  v37 = __nwlog_obj();
                  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
                    _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                  }
                }
                *(_QWORD *)buf = v12;
                *(_QWORD *)&buf[8] = 0x40000000;
                *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
                v46 = (nw_protocol *)&__block_descriptor_tmp_34_3301;
                v47 = v16;
                v48 = 0;
                v17 = v16->tqh_first;
                do
                {
                  if (!v17)
                    break;
                  v18 = (nw_frame *)*((_QWORD *)v17 + 4);
                  v19 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                  v17 = v18;
                }
                while ((v19 & 1) != 0);
                if ((v10 & 1) == 0)
                  return;
              }
            }
            else if (!v10)
            {
              return;
            }
LABEL_38:
            nw_protocol_common_disconnected((uint64_t)a1, (uint64_t)a2);
            return;
          }
          if (gLogDatapath)
          {
            v39 = __nwlog_obj();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_disconnected";
              _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s holding onto disconnected because reissuing", buf, 0xCu);
              v10 = 0;
              goto LABEL_23;
            }
          }
LABEL_22:
          v10 = 0;
          goto LABEL_23;
        }
        if (gLogDatapath)
        {
          v38 = __nwlog_obj();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_disconnected";
            _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s sending disconnected because disconnect was received", buf, 0xCu);
          }
        }
      }
LABEL_20:
      v10 = 1;
      goto LABEL_23;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugins_handle_disconnected";
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (__nwlog_fault(v24, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugins_handle_disconnected";
        v27 = "%{public}s called with null other_protocol";
        goto LABEL_93;
      }
      if (!v43)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugins_handle_disconnected";
        v27 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
      v34 = (char *)__nw_create_backtrace_string();
      v25 = __nwlog_obj();
      v26 = type;
      v35 = os_log_type_enabled(v25, type);
      if (v34)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_plugins_handle_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v34;
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v34);
        goto LABEL_94;
      }
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_plugins_handle_disconnected";
        v27 = "%{public}s called with null other_protocol, no backtrace";
LABEL_93:
        _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
      }
    }
LABEL_94:
    if (v24)
      free(v24);
    goto LABEL_38;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v43 = 0;
  if (!__nwlog_fault(v20, &type, &v43))
    goto LABEL_89;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_89;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
    v23 = "%{public}s called with null protocol->handle";
    goto LABEL_88;
  }
  if (!v43)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_89;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
    v23 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
    goto LABEL_88;
  }
  v32 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v33 = os_log_type_enabled(v21, type);
  if (!v32)
  {
    if (!v33)
      goto LABEL_89;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
    v23 = "%{public}s called with null protocol->handle, no backtrace";
    goto LABEL_88;
  }
  if (v33)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_plugins_disconnected";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v32;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null protocol->handle, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v32);
  if (v20)
    goto LABEL_90;
}

void nw_protocol_plugins_error(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  _QWORD *handle;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(nw_protocol *, nw_protocol *, BOOL);
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  NSObject *v19;
  nw_protocol_identifier *identifier;
  char *backtrace_string;
  _BOOL4 v22;
  char *v23;
  _BOOL4 v24;
  char *v25;
  _BOOL4 v26;
  NSObject *v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  nw_protocol_identifier *v33;
  __int16 v34;
  nw_protocol *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_plugins_error";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v11, &type, &v28))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_error";
      v14 = "%{public}s called with null protocol";
      goto LABEL_60;
    }
    if (!v28)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_error";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_60;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v22)
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_error";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_60;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_protocol_plugins_error";
      v32 = 2082;
      v33 = (nw_protocol_identifier *)backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_61:
    if (!v11)
      return;
    goto LABEL_62;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_plugins_error";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v11, &type, &v28))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_error";
      v14 = "%{public}s called with null protocol->handle";
      goto LABEL_60;
    }
    if (!v28)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_error";
      v14 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
      goto LABEL_60;
    }
    v23 = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v24 = os_log_type_enabled(v12, type);
    if (v23)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_protocol_plugins_error";
        v32 = 2082;
        v33 = (nw_protocol_identifier *)v23;
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null protocol->handle, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v23);
      if (!v11)
        return;
LABEL_62:
      free(v11);
      return;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_error";
      v14 = "%{public}s called with null protocol->handle, no backtrace";
LABEL_60:
      _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
      goto LABEL_61;
    }
    goto LABEL_61;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_plugins_handle_error";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_handle_error";
      v18 = "%{public}s called with null other_protocol";
    }
    else if (v28)
    {
      v25 = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v26 = os_log_type_enabled(v16, type);
      if (v25)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_protocol_plugins_handle_error";
          v32 = 2082;
          v33 = (nw_protocol_identifier *)v25;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v25);
        goto LABEL_66;
      }
      if (!v26)
      {
LABEL_66:
        if (v15)
          free(v15);
        goto LABEL_14;
      }
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_handle_error";
      v18 = "%{public}s called with null other_protocol, no backtrace";
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_plugins_handle_error";
      v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
    goto LABEL_66;
  }
  if (gLogDatapath)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      identifier = a1->identifier;
      if (!identifier)
        identifier = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v31 = "nw_protocol_plugins_handle_error";
      v32 = 2080;
      v33 = identifier;
      v34 = 2048;
      v35 = a1;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
    }
  }
  v7 = handle[11];
  if (!v7
    || (*(_BYTE *)(v7 + 212) & 0x20) == 0
    && (*(unsigned int (**)(nw_protocol *, nw_protocol *, uint64_t))(v7 + 144))(a1, a2, a3))
  {
    v8 = handle[9];
    if (v8 && (*(_BYTE *)(v8 + 142) & 2) != 0)
    {
      *(_DWORD *)(v8 + 136) = a3;
    }
    else
    {
      v9 = handle[11];
      if (!v9)
      {
LABEL_14:
        nw_protocol_common_error((uint64_t)a1, (uint64_t)a2);
        return;
      }
      *(_DWORD *)(v9 + 176) = a3;
      if ((*(_BYTE *)(v9 + 212) & 0x10) != 0)
      {
        if (gLogDatapath)
        {
          v27 = __nwlog_obj();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            v31 = "nw_protocol_plugin_retry_error";
            _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s holding onto error because reissuing", buf, 0xCu);
          }
        }
      }
      else
      {
        v10 = *(uint64_t (**)(nw_protocol *, nw_protocol *, BOOL))(v9 + 152);
        if (!v10 || (v10(a1, a2, *(_DWORD *)(v9 + 208) != 0) & 1) == 0)
          goto LABEL_14;
      }
    }
  }
}

void nw_protocol_plugins_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_plugins_notify";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_plugins_notify";
      v9 = "%{public}s called with null protocol";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_plugins_notify";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v6)
          return;
        goto LABEL_35;
      }
      if (!v11)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_plugins_notify";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_plugins_notify";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_34;
  }
  v3 = a1;
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    v5 = a2;
    if (a3 == 15)
    {
      nw_protocol_plugins_handle_reset(v4 + 64, a1, a2);
      a1 = v3;
      a2 = v5;
      a3 = 15;
    }
    nw_protocol_common_notify(a1, a2, a3);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_plugins_notify";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_plugins_notify";
    v9 = "%{public}s called with null protocol->handle";
    goto LABEL_33;
  }
  if (!v14)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_plugins_notify";
    v9 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
    goto LABEL_33;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13)
      goto LABEL_34;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_plugins_notify";
    v9 = "%{public}s called with null protocol->handle, no backtrace";
    goto LABEL_33;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v17 = "nw_protocol_plugins_notify";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol->handle, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v6)
LABEL_35:
    free(v6);
}

uint64_t nw_protocol_plugins_reset(nw_protocol *a1, nw_protocol *a2)
{
  void *handle;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *v10;
  _BOOL4 v11;
  char *backtrace_string;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      nw_protocol_plugins_handle_reset((uint64_t)handle + 64, (uint64_t)a1, (uint64_t)a2);
      return nw_protocol_common_reset((uint64_t)a1, (uint64_t)a2);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_plugins_reset";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_plugins_reset";
        v9 = "%{public}s called with null protocol->handle";
        goto LABEL_31;
      }
      if (!v14)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_plugins_reset";
        v9 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_31;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_plugins_reset";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol->handle, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v6)
          return 0;
        goto LABEL_33;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_plugins_reset";
        v9 = "%{public}s called with null protocol->handle, no backtrace";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_plugins_reset";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_plugins_reset";
      v9 = "%{public}s called with null protocol";
      goto LABEL_31;
    }
    if (!v14)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_plugins_reset";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_31;
    }
    v10 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (!v10)
    {
      if (!v11)
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_plugins_reset";
      v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_31;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_plugins_reset";
      v18 = 2082;
      v19 = v10;
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v10);
  }
LABEL_32:
  if (v6)
LABEL_33:
    free(v6);
  return 0;
}

void nw_protocol_plugins_handle_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;
  void (**v7)(uint64_t, uint64_t);
  void (*v8)(uint64_t, uint64_t);
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  NSObject *v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  char *v17;
  _BOOL4 v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  void *v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_plugins_handle_reset";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v9, &type, &v19))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_plugins_handle_reset";
      v12 = "%{public}s called with null plugins";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_plugins_handle_reset";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null plugins, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_43:
        if (!v9)
          return;
LABEL_44:
        free(v9);
        return;
      }
      if (!v16)
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_plugins_handle_reset";
      v12 = "%{public}s called with null plugins, no backtrace";
    }
    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_plugins_handle_reset";
      v12 = "%{public}s called with null plugins, backtrace limit exceeded";
    }
LABEL_42:
    _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
    goto LABEL_43;
  }
  if (a3)
  {
    if (gLogDatapath)
    {
      v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v14 = "invalid";
        if (a2 && *(_QWORD *)(a2 + 16))
          v14 = *(const char **)(a2 + 16);
        *(_DWORD *)buf = 136446722;
        v22 = "nw_protocol_plugins_handle_reset";
        v23 = 2080;
        v24 = (void *)v14;
        v25 = 2048;
        v26 = a2;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s called for %s:%p", buf, 0x20u);
      }
    }
    v6 = *(uint64_t **)(a1 + 8);
    if (v6)
      nw_protocol_plugin_metadata_reset(v6);
    v7 = *(void (***)(uint64_t, uint64_t))(a1 + 16);
    if (v7)
    {
      v8 = *v7;
      if (v8)
        v8(a2, a3);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_plugins_handle_reset";
  v9 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v9, &type, &v19))
    goto LABEL_43;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_plugins_handle_reset";
    v12 = "%{public}s called with null other_protocol";
    goto LABEL_42;
  }
  if (!v19)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_plugins_handle_reset";
    v12 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_42;
  }
  v17 = (char *)__nw_create_backtrace_string();
  v10 = __nwlog_obj();
  v11 = type;
  v18 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (!v18)
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_plugins_handle_reset";
    v12 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_42;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_plugins_handle_reset";
    v23 = 2082;
    v24 = v17;
    _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v17);
  if (v9)
    goto LABEL_44;
}

void nw_protocol_plugin_retry_connected(nw_protocol_plugin_retry *a1, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t default_input_handler;
  void *v7;
  uint64_t v8;
  void *handle;
  nw_protocol_callbacks *callbacks;
  uint64_t v11;
  void (*v12)(uint64_t, nw_protocol *);
  NSObject *v13;
  nw_protocol *output_handler;
  const char *name;
  nw_protocol_identifier *identifier;
  nw_protocol *v17;
  void *v18;
  nw_protocol_callbacks *v19;
  void *v20;
  nw_protocol_callbacks *v21;
  nw_protocol_callbacks *v22;
  void (*connected)(nw_protocol *, nw_protocol *);
  nw_protocol *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  nw_protocol_callbacks *v28;
  void *v29;
  nw_protocol_callbacks *v30;
  nw_protocol_callbacks *v31;
  uint64_t (*get_output_frames)(nw_protocol *, nw_protocol *, uint64_t, uint64_t);
  int v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  void (*v38)(uint64_t, os_log_type_t *);
  uint64_t v39;
  uint64_t v40;
  void (**v41)(_QWORD);
  const void *v42;
  uint64_t v43;
  uint64_t v44;
  void (**v45)(_QWORD);
  const void *v46;
  nw_protocol_callbacks *v47;
  nw_protocol_callbacks *v48;
  void (**v49)(_QWORD);
  const void *v50;
  nw_protocol *v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  nw_protocol_callbacks *v55;
  nw_protocol_callbacks *v56;
  void (**v57)(_QWORD);
  const void *v58;
  nw_protocol_callbacks *v59;
  nw_protocol_callbacks *v60;
  void (**v61)(_QWORD);
  const void *v62;
  nw_protocol *v63;
  nw_protocol_callbacks *v64;
  nw_protocol_callbacks *v65;
  void (**v66)(_QWORD);
  const void *v67;
  nw_protocol_callbacks *v68;
  nw_protocol_callbacks *v69;
  void (**v70)(_QWORD);
  const void *v71;
  const char *v72;
  NSObject *v73;
  os_log_type_t v74;
  const char *v75;
  const char *v76;
  NSObject *v77;
  NSObject *v78;
  os_log_type_t v79;
  const char *v80;
  const char *v81;
  NSObject *v82;
  os_log_type_t v83;
  const char *v84;
  char *backtrace_string;
  NSObject *v86;
  _BOOL4 v87;
  const char *v88;
  const char *v89;
  char *v90;
  NSObject *v91;
  os_log_type_t v92;
  const char *v93;
  const char *v94;
  char *v95;
  _BOOL4 v96;
  char *v97;
  NSObject *v98;
  _BOOL4 v99;
  NSObject *v100;
  int v101;
  const char *v102;
  NSObject *v103;
  os_log_type_t v104;
  const char *v105;
  char *v106;
  _BOOL4 v107;
  const char *v108;
  const char *v109;
  NSObject *v110;
  const char *v111;
  char *v112;
  NSObject *v113;
  os_log_type_t v114;
  const char *v115;
  const char *v116;
  const char *v117;
  NSObject *v118;
  char *v119;
  _BOOL4 v120;
  const char *v121;
  char *v122;
  NSObject *v123;
  os_log_type_t v124;
  const char *v125;
  char *v126;
  NSObject *v127;
  _BOOL4 v128;
  const char *v129;
  const char *v130;
  char *v131;
  NSObject *v132;
  os_log_type_t v133;
  const char *v134;
  const char *v135;
  const char *v136;
  char *v137;
  _BOOL4 v138;
  NSObject *v139;
  os_log_type_t v140;
  const char *v141;
  NSObject *v142;
  char *v143;
  _BOOL4 v144;
  const char *v145;
  const char *v146;
  NSObject *v147;
  char *v148;
  _BOOL4 v149;
  const char *v150;
  const char *v151;
  NSObject *v152;
  NSObject *v153;
  int v154;
  int v155;
  int v156;
  const char *v157;
  NSObject *log;
  NSObject *v159;
  NSObject *v160;
  char *v161;
  os_log_type_t type[8];
  os_log_type_t *v163;
  char v164;
  os_log_type_t v165;
  _BYTE buf[24];
  void *v167;
  _BYTE v168[10];
  __int16 v169;
  nw_protocol *v170;
  uint64_t v171;

  v171 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v77 = __nwlog_obj();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_connected";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = a2;
      _os_log_impl(&dword_182FBE000, v77, OS_LOG_TYPE_DEBUG, "%{public}s called %p", buf, 0x16u);
    }
  }
  default_input_handler = (uint64_t)a2->default_input_handler;
  if (default_input_handler)
  {
    v7 = *(void **)(default_input_handler + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      v8 = *(_QWORD *)(default_input_handler + 88);
      if (v8)
        *(_QWORD *)(default_input_handler + 88) = v8 + 1;
    }
    if (a3)
    {
      handle = a3->handle;
      if (handle == &nw_protocol_ref_counted_handle)
      {
        callbacks = a3[1].callbacks;
        if (callbacks)
          a3[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      v11 = *(_QWORD *)(default_input_handler + 24);
      if (v11)
      {
        v12 = *(void (**)(uint64_t, nw_protocol *))(v11 + 40);
        if (v12)
        {
          v12(default_input_handler, a3);
LABEL_13:
          if (handle != &nw_protocol_ref_counted_handle
            || a3->handle != &nw_protocol_ref_counted_handle
            || (v47 = a3[1].callbacks) == 0
            || (v48 = (nw_protocol_callbacks *)((char *)v47 - 1), (a3[1].callbacks = v48) != 0))
          {
LABEL_15:
            if (v7 == &nw_protocol_ref_counted_handle
              && *(_UNKNOWN **)(default_input_handler + 40) == &nw_protocol_ref_counted_handle)
            {
              v43 = *(_QWORD *)(default_input_handler + 88);
              if (v43)
              {
                v44 = v43 - 1;
                *(_QWORD *)(default_input_handler + 88) = v44;
                if (!v44)
                {
                  v45 = *(void (***)(_QWORD))(default_input_handler + 64);
                  if (v45)
                  {
                    *(_QWORD *)(default_input_handler + 64) = 0;
                    v45[2](v45);
                    _Block_release(v45);
                  }
                  if ((*(_BYTE *)(default_input_handler + 72) & 1) != 0)
                  {
                    v46 = *(const void **)(default_input_handler + 64);
                    if (v46)
                      _Block_release(v46);
                  }
                  goto LABEL_85;
                }
              }
            }
            goto LABEL_17;
          }
          v49 = *(void (***)(_QWORD))a3[1].flow_id;
          if (v49)
          {
            *(_QWORD *)a3[1].flow_id = 0;
            v49[2](v49);
            _Block_release(v49);
          }
          if ((a3[1].flow_id[8] & 1) != 0)
          {
            v50 = *(const void **)a3[1].flow_id;
            if (v50)
              _Block_release(v50);
          }
          v51 = a3;
LABEL_94:
          free(v51);
          goto LABEL_15;
        }
      }
      __nwlog_obj();
      v72 = *(const char **)(default_input_handler + 16);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_connected";
      if (!v72)
        v72 = "invalid";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v72;
      *(_WORD *)&buf[22] = 2048;
      v167 = (void *)default_input_handler;
      type[0] = OS_LOG_TYPE_ERROR;
      v165 = OS_LOG_TYPE_DEFAULT;
      v161 = (char *)_os_log_send_and_compose_impl();
      if (__nwlog_fault(v161, type, &v165))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v73 = __nwlog_obj();
          v74 = type[0];
          if (!os_log_type_enabled(v73, type[0]))
            goto LABEL_196;
          v75 = *(const char **)(default_input_handler + 16);
          if (!v75)
            v75 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v75;
          *(_WORD *)&buf[22] = 2048;
          v167 = (void *)default_input_handler;
          v76 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
LABEL_194:
          v110 = v73;
LABEL_195:
          _os_log_impl(&dword_182FBE000, v110, v74, v76, buf, 0x20u);
          goto LABEL_196;
        }
        if (v165 == OS_LOG_TYPE_DEFAULT)
        {
          v73 = __nwlog_obj();
          v74 = type[0];
          if (!os_log_type_enabled(v73, type[0]))
            goto LABEL_196;
          v109 = *(const char **)(default_input_handler + 16);
          if (!v109)
            v109 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v109;
          *(_WORD *)&buf[22] = 2048;
          v167 = (void *)default_input_handler;
          v76 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
          goto LABEL_194;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v86 = __nwlog_obj();
        v74 = type[0];
        log = v86;
        v87 = os_log_type_enabled(v86, type[0]);
        if (backtrace_string)
        {
          if (v87)
          {
            v88 = *(const char **)(default_input_handler + 16);
            if (!v88)
              v88 = "invalid";
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "__nw_protocol_connected";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v88;
            *(_WORD *)&buf[22] = 2048;
            v167 = (void *)default_input_handler;
            *(_WORD *)v168 = 2082;
            *(_QWORD *)&v168[2] = backtrace_string;
            _os_log_impl(&dword_182FBE000, log, v74, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
          goto LABEL_196;
        }
        if (v87)
        {
          v117 = *(const char **)(default_input_handler + 16);
          if (!v117)
            v117 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v117;
          *(_WORD *)&buf[22] = 2048;
          v167 = (void *)default_input_handler;
          v76 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
          v110 = log;
          goto LABEL_195;
        }
      }
LABEL_196:
      if (v161)
        free(v161);
      goto LABEL_13;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_connected";
    v81 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v165 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v81, type, &v165))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v82 = __nwlog_obj();
        v83 = type[0];
        if (os_log_type_enabled(v82, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          v84 = "%{public}s called with null other_protocol";
LABEL_214:
          v118 = v82;
LABEL_215:
          _os_log_impl(&dword_182FBE000, v118, v83, v84, buf, 0xCu);
        }
      }
      else if (v165)
      {
        v97 = (char *)__nw_create_backtrace_string();
        v98 = __nwlog_obj();
        v83 = type[0];
        v159 = v98;
        v99 = os_log_type_enabled(v98, type[0]);
        if (v97)
        {
          if (v99)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_connected";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v97;
            _os_log_impl(&dword_182FBE000, v159, v83, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v97);
          goto LABEL_216;
        }
        if (v99)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          v84 = "%{public}s called with null other_protocol, no backtrace";
          v118 = v159;
          goto LABEL_215;
        }
      }
      else
      {
        v82 = __nwlog_obj();
        v83 = type[0];
        if (os_log_type_enabled(v82, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          v84 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_214;
        }
      }
    }
LABEL_216:
    if (!v81)
      goto LABEL_15;
    v51 = (nw_protocol *)v81;
    goto LABEL_94;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "__nw_protocol_connected";
  default_input_handler = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v165 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault((const char *)default_input_handler, type, &v165))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
        goto LABEL_234;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_connected";
      v80 = "%{public}s called with null protocol";
    }
    else if (v165)
    {
      v95 = (char *)__nw_create_backtrace_string();
      v78 = __nwlog_obj();
      v79 = type[0];
      v96 = os_log_type_enabled(v78, type[0]);
      if (v95)
      {
        if (v96)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v95;
          _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v95);
        if (default_input_handler)
          goto LABEL_85;
        goto LABEL_17;
      }
      if (!v96)
        goto LABEL_234;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_connected";
      v80 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v78 = __nwlog_obj();
      v79 = type[0];
      if (!os_log_type_enabled(v78, type[0]))
        goto LABEL_234;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_protocol_connected";
      v80 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v78, v79, v80, buf, 0xCu);
  }
LABEL_234:
  if (default_input_handler)
LABEL_85:
    free((void *)default_input_handler);
LABEL_17:
  if (a2->output_handler != a3)
  {
    if (gLogDatapath)
    {
      v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        output_handler = a2->output_handler;
        name = "invalid";
        if (output_handler && output_handler->identifier)
          name = output_handler->identifier->name;
        identifier = (nw_protocol_identifier *)"invalid";
        if (a3)
        {
          if (a3->identifier)
            identifier = a3->identifier;
        }
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_connected";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = name;
        *(_WORD *)&buf[22] = 2048;
        v167 = output_handler;
        *(_WORD *)v168 = 2080;
        *(_QWORD *)&v168[2] = identifier;
        v169 = 2048;
        v170 = a3;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s connected protocol %s: %p is not our output_handler %s: %p, ignoring", buf, 0x34u);
      }
    }
    return;
  }
  *((_DWORD *)a1 + 44) = 0;
  if (gLogDatapath)
  {
    v100 = __nwlog_obj();
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
    {
      v101 = (*((unsigned __int8 *)a1 + 212) >> 4) & 1;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_send_output_frames";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v101;
      _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s reissuing %{BOOL}d", buf, 0x12u);
    }
  }
  if ((*((_BYTE *)a1 + 212) & 0x10) != 0)
  {
    *((_BYTE *)a1 + 212) &= ~0x10u;
    *(_QWORD *)type = 0;
    v163 = type;
    if (!*((_DWORD *)a1 + 47))
      goto LABEL_60;
    v24 = a2->output_handler;
    if (v24)
    {
      v25 = *((unsigned int *)a1 + 45);
      v26 = *((unsigned int *)a1 + 46);
      v27 = v24->handle;
      if (v27 == &nw_protocol_ref_counted_handle)
      {
        v28 = v24[1].callbacks;
        if (v28)
          v24[1].callbacks = (nw_protocol_callbacks *)((char *)&v28->add_input_handler + 1);
      }
      v29 = a2->handle;
      if (v29 == &nw_protocol_ref_counted_handle)
      {
        v30 = a2[1].callbacks;
        if (v30)
          a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v30->add_input_handler + 1);
      }
      v31 = v24->callbacks;
      if (v31)
      {
        get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t))v31->get_output_frames;
        if (get_output_frames)
        {
          v33 = get_output_frames(v24, a2, v25, v26);
          if (v29 != &nw_protocol_ref_counted_handle)
            goto LABEL_56;
          goto LABEL_55;
        }
      }
      __nwlog_obj();
      v111 = v24->identifier->name;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
      if (!v111)
        v111 = "invalid";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v111;
      *(_WORD *)&buf[22] = 2048;
      v167 = v24;
      v112 = (char *)_os_log_send_and_compose_impl();
      v165 = OS_LOG_TYPE_ERROR;
      v164 = 0;
      if (__nwlog_fault(v112, &v165, &v164))
      {
        if (v165 == OS_LOG_TYPE_FAULT)
        {
          v113 = __nwlog_obj();
          v114 = v165;
          if (!os_log_type_enabled(v113, v165))
            goto LABEL_291;
          v115 = v24->identifier->name;
          if (!v115)
            v115 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v115;
          *(_WORD *)&buf[22] = 2048;
          v167 = v24;
          v116 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_289:
          v147 = v113;
LABEL_290:
          _os_log_impl(&dword_182FBE000, v147, v114, v116, buf, 0x20u);
          goto LABEL_291;
        }
        if (!v164)
        {
          v113 = __nwlog_obj();
          v114 = v165;
          if (!os_log_type_enabled(v113, v165))
            goto LABEL_291;
          v146 = v24->identifier->name;
          if (!v146)
            v146 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v146;
          *(_WORD *)&buf[22] = 2048;
          v167 = v24;
          v116 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
          goto LABEL_289;
        }
        v126 = (char *)__nw_create_backtrace_string();
        v127 = __nwlog_obj();
        v114 = v165;
        v160 = v127;
        v128 = os_log_type_enabled(v127, v165);
        if (v126)
        {
          if (v128)
          {
            v129 = v24->identifier->name;
            if (!v129)
              v129 = "invalid";
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v129;
            *(_WORD *)&buf[22] = 2048;
            v167 = v24;
            *(_WORD *)v168 = 2082;
            *(_QWORD *)&v168[2] = v126;
            _os_log_impl(&dword_182FBE000, v160, v114, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v126);
        }
        else if (v128)
        {
          v150 = v24->identifier->name;
          if (!v150)
            v150 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v150;
          *(_WORD *)&buf[22] = 2048;
          v167 = v24;
          v116 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
          v147 = v160;
          goto LABEL_290;
        }
      }
LABEL_291:
      if (v112)
        free(v112);
      v33 = 0;
      if (v29 != &nw_protocol_ref_counted_handle)
      {
LABEL_56:
        if (v27 == &nw_protocol_ref_counted_handle && v24->handle == &nw_protocol_ref_counted_handle)
        {
          v68 = v24[1].callbacks;
          if (v68)
          {
            v69 = (nw_protocol_callbacks *)((char *)v68 - 1);
            v24[1].callbacks = v69;
            if (!v69)
            {
              v70 = *(void (***)(_QWORD))v24[1].flow_id;
              if (v70)
              {
                *(_QWORD *)v24[1].flow_id = 0;
                v70[2](v70);
                _Block_release(v70);
              }
              if ((v24[1].flow_id[8] & 1) != 0)
              {
                v71 = *(const void **)v24[1].flow_id;
                if (v71)
                  _Block_release(v71);
              }
              free(v24);
            }
          }
        }
        if (*(_QWORD *)type)
        {
          if (v33)
          {
LABEL_60:
            if (!(*(unsigned int (**)(_QWORD, os_log_type_t *))(*((_QWORD *)a1 + 14) + 16))(*((_QWORD *)a1 + 14), type))
            {
              if (gLogDatapath)
              {
                v142 = __nwlog_obj();
                if (os_log_type_enabled(v142, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
                  _os_log_impl(&dword_182FBE000, v142, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                }
              }
              *(_QWORD *)buf = MEMORY[0x1E0C809B0];
              *(_QWORD *)&buf[8] = 0x40000000;
              *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_3300;
              v167 = &__block_descriptor_tmp_34_3301;
              *(_QWORD *)v168 = type;
              v168[8] = 0;
              v52 = *(_QWORD *)type;
              do
              {
                if (!v52)
                  break;
                v53 = *(_QWORD *)(v52 + 32);
                v54 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                v52 = v53;
              }
              while ((v54 & 1) != 0);
              goto LABEL_29;
            }
            v34 = (uint64_t)a2->output_handler;
            if (v34)
            {
              v35 = *(void **)(v34 + 40);
              if (v35 == &nw_protocol_ref_counted_handle)
              {
                v36 = *(_QWORD *)(v34 + 88);
                if (v36)
                  *(_QWORD *)(v34 + 88) = v36 + 1;
              }
              v37 = *(_QWORD *)(v34 + 24);
              if (v37)
              {
                v38 = *(void (**)(uint64_t, os_log_type_t *))(v37 + 96);
                if (v38)
                {
                  v38(v34, type);
LABEL_68:
                  if (v35 != &nw_protocol_ref_counted_handle)
                    goto LABEL_29;
                  if (*(_UNKNOWN **)(v34 + 40) != &nw_protocol_ref_counted_handle)
                    goto LABEL_29;
                  v39 = *(_QWORD *)(v34 + 88);
                  if (!v39)
                    goto LABEL_29;
                  v40 = v39 - 1;
                  *(_QWORD *)(v34 + 88) = v40;
                  if (v40)
                    goto LABEL_29;
                  v41 = *(void (***)(_QWORD))(v34 + 64);
                  if (v41)
                  {
                    *(_QWORD *)(v34 + 64) = 0;
                    v41[2](v41);
                    _Block_release(v41);
                  }
                  if ((*(_BYTE *)(v34 + 72) & 1) != 0)
                  {
                    v42 = *(const void **)(v34 + 64);
                    if (v42)
                      _Block_release(v42);
                  }
LABEL_77:
                  free((void *)v34);
                  goto LABEL_29;
                }
              }
              __nwlog_obj();
              v130 = *(const char **)(v34 + 16);
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
              if (!v130)
                v130 = "invalid";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v130;
              *(_WORD *)&buf[22] = 2048;
              v167 = (void *)v34;
              v131 = (char *)_os_log_send_and_compose_impl();
              v165 = OS_LOG_TYPE_ERROR;
              v164 = 0;
              if (__nwlog_fault(v131, &v165, &v164))
              {
                if (v165 == OS_LOG_TYPE_FAULT)
                {
                  v132 = __nwlog_obj();
                  v133 = v165;
                  if (!os_log_type_enabled(v132, v165))
                    goto LABEL_325;
                  v134 = *(const char **)(v34 + 16);
                  if (!v134)
                    v134 = "invalid";
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v134;
                  *(_WORD *)&buf[22] = 2048;
                  v167 = (void *)v34;
                  v135 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
                  goto LABEL_324;
                }
                if (!v164)
                {
                  v132 = __nwlog_obj();
                  v133 = v165;
                  if (!os_log_type_enabled(v132, v165))
                    goto LABEL_325;
                  v151 = *(const char **)(v34 + 16);
                  if (!v151)
                    v151 = "invalid";
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v151;
                  *(_WORD *)&buf[22] = 2048;
                  v167 = (void *)v34;
                  v135 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
                  goto LABEL_324;
                }
                v143 = (char *)__nw_create_backtrace_string();
                v132 = __nwlog_obj();
                v133 = v165;
                v144 = os_log_type_enabled(v132, v165);
                if (v143)
                {
                  if (v144)
                  {
                    v145 = *(const char **)(v34 + 16);
                    if (!v145)
                      v145 = "invalid";
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v145;
                    *(_WORD *)&buf[22] = 2048;
                    v167 = (void *)v34;
                    *(_WORD *)v168 = 2082;
                    *(_QWORD *)&v168[2] = v143;
                    _os_log_impl(&dword_182FBE000, v132, v133, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }
                  free(v143);
                  goto LABEL_325;
                }
                if (v144)
                {
                  v157 = *(const char **)(v34 + 16);
                  if (!v157)
                    v157 = "invalid";
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v157;
                  *(_WORD *)&buf[22] = 2048;
                  v167 = (void *)v34;
                  v135 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
LABEL_324:
                  _os_log_impl(&dword_182FBE000, v132, v133, v135, buf, 0x20u);
                }
              }
LABEL_325:
              if (v131)
                free(v131);
              goto LABEL_68;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
            v34 = _os_log_send_and_compose_impl();
            v165 = OS_LOG_TYPE_ERROR;
            v164 = 0;
            if (__nwlog_fault((const char *)v34, &v165, &v164))
            {
              if (v165 == OS_LOG_TYPE_FAULT)
              {
                v139 = __nwlog_obj();
                v140 = v165;
                if (!os_log_type_enabled(v139, v165))
                  goto LABEL_332;
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                v141 = "%{public}s called with null protocol";
LABEL_331:
                _os_log_impl(&dword_182FBE000, v139, v140, v141, buf, 0xCu);
                goto LABEL_332;
              }
              if (!v164)
              {
                v139 = __nwlog_obj();
                v140 = v165;
                if (!os_log_type_enabled(v139, v165))
                  goto LABEL_332;
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                v141 = "%{public}s called with null protocol, backtrace limit exceeded";
                goto LABEL_331;
              }
              v148 = (char *)__nw_create_backtrace_string();
              v139 = __nwlog_obj();
              v140 = v165;
              v149 = os_log_type_enabled(v139, v165);
              if (!v148)
              {
                if (!v149)
                  goto LABEL_332;
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                v141 = "%{public}s called with null protocol, no backtrace";
                goto LABEL_331;
              }
              if (v149)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "__nw_protocol_finalize_output_frames";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v148;
                _os_log_impl(&dword_182FBE000, v139, v140, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v148);
            }
LABEL_332:
            if (!v34)
              goto LABEL_29;
            goto LABEL_77;
          }
LABEL_316:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v152 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_send_output_frames";
            _os_log_impl(&dword_182FBE000, v152, OS_LOG_TYPE_ERROR, "%{public}s Output frames is not empty but returned frame count is 0", buf, 0xCu);
          }
          goto LABEL_29;
        }
LABEL_318:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v153 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v154 = *((_DWORD *)a1 + 45);
          v155 = *((_DWORD *)a1 + 46);
          v156 = *((_DWORD *)a1 + 47);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_plugin_retry_send_output_frames";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v154;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v155;
          LOWORD(v167) = 1024;
          *(_DWORD *)((char *)&v167 + 2) = v156;
          _os_log_impl(&dword_182FBE000, v153, OS_LOG_TYPE_ERROR, "%{public}s Asked for %u minimum bytes, %u maximum bytes, %u frames but received no frames", buf, 0x1Eu);
        }
        goto LABEL_29;
      }
LABEL_55:
      if (a2->handle == &nw_protocol_ref_counted_handle)
      {
        v64 = a2[1].callbacks;
        if (v64)
        {
          v65 = (nw_protocol_callbacks *)((char *)v64 - 1);
          a2[1].callbacks = v65;
          if (!v65)
          {
            v66 = *(void (***)(_QWORD))a2[1].flow_id;
            if (v66)
            {
              *(_QWORD *)a2[1].flow_id = 0;
              v66[2](v66);
              _Block_release(v66);
            }
            if ((a2[1].flow_id[8] & 1) != 0)
            {
              v67 = *(const void **)a2[1].flow_id;
              if (v67)
                _Block_release(v67);
            }
            free(a2);
          }
        }
      }
      goto LABEL_56;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
    v122 = (char *)_os_log_send_and_compose_impl();
    v165 = OS_LOG_TYPE_ERROR;
    v164 = 0;
    if (__nwlog_fault(v122, &v165, &v164))
    {
      if (v165 == OS_LOG_TYPE_FAULT)
      {
        v123 = __nwlog_obj();
        v124 = v165;
        if (!os_log_type_enabled(v123, v165))
          goto LABEL_313;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
        v125 = "%{public}s called with null protocol";
LABEL_312:
        _os_log_impl(&dword_182FBE000, v123, v124, v125, buf, 0xCu);
        goto LABEL_313;
      }
      if (!v164)
      {
        v123 = __nwlog_obj();
        v124 = v165;
        if (!os_log_type_enabled(v123, v165))
          goto LABEL_313;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
        v125 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_312;
      }
      v137 = (char *)__nw_create_backtrace_string();
      v123 = __nwlog_obj();
      v124 = v165;
      v138 = os_log_type_enabled(v123, v165);
      if (!v137)
      {
        if (!v138)
          goto LABEL_313;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
        v125 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_312;
      }
      if (v138)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "__nw_protocol_get_output_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v137;
        _os_log_impl(&dword_182FBE000, v123, v124, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v137);
    }
LABEL_313:
    if (v122)
      free(v122);
    if (*(_QWORD *)type)
      goto LABEL_316;
    goto LABEL_318;
  }
LABEL_29:
  v17 = a2->default_input_handler;
  if (!v17)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_connected";
    v102 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v165 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v102, type, &v165))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v103 = __nwlog_obj();
        v104 = type[0];
        if (os_log_type_enabled(v103, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          v105 = "%{public}s called with null protocol";
LABEL_282:
          _os_log_impl(&dword_182FBE000, v103, v104, v105, buf, 0xCu);
        }
      }
      else if (v165)
      {
        v119 = (char *)__nw_create_backtrace_string();
        v103 = __nwlog_obj();
        v104 = type[0];
        v120 = os_log_type_enabled(v103, type[0]);
        if (v119)
        {
          if (v120)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_protocol_connected";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v119;
            _os_log_impl(&dword_182FBE000, v103, v104, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v119);
          goto LABEL_283;
        }
        if (v120)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          v105 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_282;
        }
      }
      else
      {
        v103 = __nwlog_obj();
        v104 = type[0];
        if (os_log_type_enabled(v103, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_connected";
          v105 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_282;
        }
      }
    }
LABEL_283:
    if (!v102)
      return;
    v63 = (nw_protocol *)v102;
LABEL_116:
    free(v63);
    return;
  }
  v18 = v17->handle;
  if (v18 == &nw_protocol_ref_counted_handle)
  {
    v19 = v17[1].callbacks;
    if (v19)
      v17[1].callbacks = (nw_protocol_callbacks *)((char *)&v19->add_input_handler + 1);
  }
  v20 = a2->handle;
  if (v20 == &nw_protocol_ref_counted_handle)
  {
    v21 = a2[1].callbacks;
    if (v21)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v21->add_input_handler + 1);
  }
  v22 = v17->callbacks;
  if (v22)
  {
    connected = (void (*)(nw_protocol *, nw_protocol *))v22->connected;
    if (connected)
    {
      connected(v17, a2);
      goto LABEL_39;
    }
  }
  __nwlog_obj();
  v89 = v17->identifier->name;
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "__nw_protocol_connected";
  if (!v89)
    v89 = "invalid";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = v89;
  *(_WORD *)&buf[22] = 2048;
  v167 = v17;
  v90 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v165 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v90, type, &v165))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v91 = __nwlog_obj();
      v92 = type[0];
      if (!os_log_type_enabled(v91, type[0]))
        goto LABEL_258;
      v93 = v17->identifier->name;
      if (!v93)
        v93 = "invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v93;
      *(_WORD *)&buf[22] = 2048;
      v167 = v17;
      v94 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_257;
    }
    if (v165 == OS_LOG_TYPE_DEFAULT)
    {
      v91 = __nwlog_obj();
      v92 = type[0];
      if (!os_log_type_enabled(v91, type[0]))
        goto LABEL_258;
      v121 = v17->identifier->name;
      if (!v121)
        v121 = "invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v121;
      *(_WORD *)&buf[22] = 2048;
      v167 = v17;
      v94 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_257;
    }
    v106 = (char *)__nw_create_backtrace_string();
    v91 = __nwlog_obj();
    v92 = type[0];
    v107 = os_log_type_enabled(v91, type[0]);
    if (v106)
    {
      if (v107)
      {
        v108 = v17->identifier->name;
        if (!v108)
          v108 = "invalid";
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "__nw_protocol_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v108;
        *(_WORD *)&buf[22] = 2048;
        v167 = v17;
        *(_WORD *)v168 = 2082;
        *(_QWORD *)&v168[2] = v106;
        _os_log_impl(&dword_182FBE000, v91, v92, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v106);
      goto LABEL_258;
    }
    if (v107)
    {
      v136 = v17->identifier->name;
      if (!v136)
        v136 = "invalid";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v136;
      *(_WORD *)&buf[22] = 2048;
      v167 = v17;
      v94 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_257:
      _os_log_impl(&dword_182FBE000, v91, v92, v94, buf, 0x20u);
    }
  }
LABEL_258:
  if (v90)
    free(v90);
LABEL_39:
  if (v20 == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
  {
    v55 = a2[1].callbacks;
    if (v55)
    {
      v56 = (nw_protocol_callbacks *)((char *)v55 - 1);
      a2[1].callbacks = v56;
      if (!v56)
      {
        v57 = *(void (***)(_QWORD))a2[1].flow_id;
        if (v57)
        {
          *(_QWORD *)a2[1].flow_id = 0;
          v57[2](v57);
          _Block_release(v57);
        }
        if ((a2[1].flow_id[8] & 1) != 0)
        {
          v58 = *(const void **)a2[1].flow_id;
          if (v58)
            _Block_release(v58);
        }
        free(a2);
      }
    }
  }
  if (v18 == &nw_protocol_ref_counted_handle && v17->handle == &nw_protocol_ref_counted_handle)
  {
    v59 = v17[1].callbacks;
    if (v59)
    {
      v60 = (nw_protocol_callbacks *)((char *)v59 - 1);
      v17[1].callbacks = v60;
      if (!v60)
      {
        v61 = *(void (***)(_QWORD))v17[1].flow_id;
        if (v61)
        {
          *(_QWORD *)v17[1].flow_id = 0;
          v61[2](v61);
          _Block_release(v61);
        }
        if ((v17[1].flow_id[8] & 1) != 0)
        {
          v62 = *(const void **)v17[1].flow_id;
          if (v62)
            _Block_release(v62);
        }
        v63 = v17;
        goto LABEL_116;
      }
    }
  }
}

void nw_protocol_plugin_name_set_name(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *v4;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  unsigned __int8 *v17;
  __int16 v18;
  NSObject *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void (**v23)(_QWORD);
  const void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  const char *v34;
  char *backtrace_string;
  _BOOL4 v36;
  char *v37;
  _BOOL4 v38;
  const char *v39;
  _BOOL4 v40;
  char *v41;
  _BOOL4 v42;
  const char *v43;
  const char *v44;
  const char *v45;
  char v46;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  void *v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  char *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_plugin_name_set_name";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v25, &type, &v46))
      goto LABEL_89;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_plugin_name_set_name";
      v28 = "%{public}s called with null name_plugin";
    }
    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v36 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          v49 = "nw_protocol_plugin_name_set_name";
          v50 = 2082;
          v51 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null name_plugin, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_89:
        if (!v25)
          return;
        goto LABEL_90;
      }
      if (!v36)
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_plugin_name_set_name";
      v28 = "%{public}s called with null name_plugin, no backtrace";
    }
    else
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_plugin_name_set_name";
      v28 = "%{public}s called with null name_plugin, backtrace limit exceeded";
    }
    goto LABEL_88;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_plugin_name_set_name";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v25, &type, &v46))
      goto LABEL_89;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_89;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_plugin_name_set_name";
        v28 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_88;
      }
      v37 = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v38 = os_log_type_enabled(v26, type);
      if (!v37)
      {
        if (!v38)
          goto LABEL_89;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_plugin_name_set_name";
        v28 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_88;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446466;
        v49 = "nw_protocol_plugin_name_set_name";
        v50 = 2082;
        v51 = v37;
        v39 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_62:
        _os_log_impl(&dword_182FBE000, v26, v27, v39, buf, 0x16u);
      }
LABEL_63:
      free(v37);
      if (!v25)
        return;
LABEL_90:
      free(v25);
      return;
    }
    v26 = __nwlog_obj();
    v27 = type;
    if (!os_log_type_enabled(v26, type))
      goto LABEL_89;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_plugin_name_set_name";
    v28 = "%{public}s called with null protocol";
LABEL_88:
    _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
    goto LABEL_89;
  }
  v4 = a3;
  if (a3)
    goto LABEL_12;
  v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a2 + 88);
    if (v7)
      *(_QWORD *)(a2 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(a2 + 24);
  if (v8)
  {
    v9 = *(uint64_t (**)(uint64_t))(v8 + 112);
    if (v9)
    {
      v4 = (uint64_t *)v9(a2);
      if (v6 != &nw_protocol_ref_counted_handle)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  __nwlog_obj();
  v29 = *(const char **)(a2 + 16);
  *(_DWORD *)buf = 136446722;
  v49 = "__nw_protocol_get_parameters";
  if (!v29)
    v29 = "invalid";
  v50 = 2082;
  v51 = (void *)v29;
  v52 = 2048;
  v53 = a2;
  v30 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v46 = 0;
  if (__nwlog_fault(v30, &type, &v46))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type))
        goto LABEL_96;
      v33 = *(const char **)(a2 + 16);
      if (!v33)
        v33 = "invalid";
      *(_DWORD *)buf = 136446722;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v33;
      v52 = 2048;
      v53 = a2;
      v34 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_95:
      _os_log_impl(&dword_182FBE000, v31, v32, v34, buf, 0x20u);
      goto LABEL_96;
    }
    if (!v46)
    {
      v31 = __nwlog_obj();
      v32 = type;
      if (!os_log_type_enabled(v31, type))
        goto LABEL_96;
      v44 = *(const char **)(a2 + 16);
      if (!v44)
        v44 = "invalid";
      *(_DWORD *)buf = 136446722;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v44;
      v52 = 2048;
      v53 = a2;
      v34 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
      goto LABEL_95;
    }
    v41 = (char *)__nw_create_backtrace_string();
    v31 = __nwlog_obj();
    v32 = type;
    v42 = os_log_type_enabled(v31, type);
    if (!v41)
    {
      if (!v42)
        goto LABEL_96;
      v45 = *(const char **)(a2 + 16);
      if (!v45)
        v45 = "invalid";
      *(_DWORD *)buf = 136446722;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v45;
      v52 = 2048;
      v53 = a2;
      v34 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
      goto LABEL_95;
    }
    if (v42)
    {
      v43 = *(const char **)(a2 + 16);
      if (!v43)
        v43 = "invalid";
      *(_DWORD *)buf = 136446978;
      v49 = "__nw_protocol_get_parameters";
      v50 = 2082;
      v51 = (void *)v43;
      v52 = 2048;
      v53 = a2;
      v54 = 2082;
      v55 = v41;
      _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v41);
  }
LABEL_96:
  if (v30)
    free(v30);
  v4 = 0;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
LABEL_10:
    if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
    {
      v21 = *(_QWORD *)(a2 + 88);
      if (v21)
      {
        v22 = v21 - 1;
        *(_QWORD *)(a2 + 88) = v22;
        if (!v22)
        {
          v23 = *(void (***)(_QWORD))(a2 + 64);
          if (v23)
          {
            *(_QWORD *)(a2 + 64) = 0;
            v23[2](v23);
            _Block_release(v23);
          }
          if ((*(_BYTE *)(a2 + 72) & 1) != 0)
          {
            v24 = *(const void **)(a2 + 64);
            if (v24)
              _Block_release(v24);
          }
          free((void *)a2);
        }
      }
    }
  }
LABEL_11:
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_plugin_name_set_name";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v25, &type, &v46))
      goto LABEL_89;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_plugin_name_set_name";
      v28 = "%{public}s called with null parameters";
      goto LABEL_88;
    }
    if (!v46)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_plugin_name_set_name";
      v28 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_88;
    }
    v37 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v40 = os_log_type_enabled(v26, type);
    if (!v37)
    {
      if (!v40)
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_plugin_name_set_name";
      v28 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_88;
    }
    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_plugin_name_set_name";
      v50 = 2082;
      v51 = v37;
      v39 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
      goto LABEL_62;
    }
    goto LABEL_63;
  }
LABEL_12:
  *(_BYTE *)(a1 + 94) = *(_BYTE *)(a1 + 94) & 0xFE | nw_path_parameters_get_logging_disabled(v4[13]);
  v10 = nw_parameters_copy_protocol_options_legacy(v4, (nw_protocol *)a2);
  if (v10)
  {
    v11 = v10;
    v12 = v11;
    v13 = 0;
    *(_BYTE *)(a1 + 10) = 0;
    v14 = a1 + 10;
    v15 = 84;
    while (1)
    {
      v16 = v11[v13 + 48];
      *(_BYTE *)(v14 + v13) = v16;
      if (!v16)
        break;
      --v15;
      ++v13;
      if (v15 <= 1)
      {
        *(_BYTE *)(v14 + v13) = 0;
        break;
      }
    }

    v17 = v12;
    v18 = *((_WORD *)v17 + 68);

    *(_WORD *)(a1 + 8) = v18;
    os_release(v17);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      v20 = *(void **)(a2 + 16);
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_plugin_name_set_name";
      v50 = 2080;
      v51 = v20;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s No options found for %s in parameters, cannot find name", buf, 0x16u);
    }
  }
}

uint64_t nw_protocol_plugin_name_add_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int (**v4)(uint64_t, uint64_t);
  uint64_t v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _BOOL4 v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_plugin_name_add_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18))
      goto LABEL_61;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_protocol_plugin_name_add_input_handler";
          v11 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_protocol_plugin_name_add_input_handler";
          v11 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      if (!v13)
        goto LABEL_43;
      *(_DWORD *)buf = 136446466;
      v21 = "nw_protocol_plugin_name_add_input_handler";
      v22 = 2082;
      v23 = backtrace_string;
      v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_plugin_name_add_input_handler";
    v11 = "%{public}s called with null protocol";
LABEL_60:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_61;
  }
  v3 = *(_QWORD *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_plugin_name_add_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18))
      goto LABEL_61;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v18)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_protocol_plugin_name_add_input_handler";
          v11 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_protocol_plugin_name_add_input_handler";
          v11 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      if (!v15)
        goto LABEL_43;
      *(_DWORD *)buf = 136446466;
      v21 = "nw_protocol_plugin_name_add_input_handler";
      v22 = 2082;
      v23 = backtrace_string;
      v14 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_plugin_name_add_input_handler";
    v11 = "%{public}s called with null protocol->handle";
    goto LABEL_60;
  }
  v4 = *(unsigned int (***)(uint64_t, uint64_t))(v3 + 64);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_plugin_name_add_input_handler";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_plugin_name_add_input_handler";
      v11 = "%{public}s called with null name_plugin";
      goto LABEL_60;
    }
    if (!v18)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_plugin_name_add_input_handler";
        v11 = "%{public}s called with null name_plugin, backtrace limit exceeded";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v16 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_plugin_name_add_input_handler";
        v11 = "%{public}s called with null name_plugin, no backtrace";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    if (!v16)
      goto LABEL_43;
    *(_DWORD *)buf = 136446466;
    v21 = "nw_protocol_plugin_name_add_input_handler";
    v22 = 2082;
    v23 = backtrace_string;
    v14 = "%{public}s called with null name_plugin, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_182FBE000, v9, v10, v14, buf, 0x16u);
    goto LABEL_43;
  }
  if (a2)
  {
    if ((*v4)(a1, a2))
      v6 = nw_protocol_common_add_input_handler(a1, a2);
    else
      v6 = 0;
    nw_protocol_plugin_name_set_name((uint64_t)v4, a1, 0);
    return v6;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_protocol_plugin_name_add_input_handler";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v8, &type, &v18))
    goto LABEL_61;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v18)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_plugin_name_add_input_handler";
        v11 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_plugin_name_add_input_handler";
        v11 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v21 = "nw_protocol_plugin_name_add_input_handler";
      v22 = 2082;
      v23 = backtrace_string;
      v14 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
LABEL_43:
    free(backtrace_string);
    goto LABEL_61;
  }
  v9 = __nwlog_obj();
  v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_plugin_name_add_input_handler";
    v11 = "%{public}s called with null input_protocol";
    goto LABEL_60;
  }
LABEL_61:
  if (v8)
    free(v8);
  return 0;
}

void nw_protocol_plugin_name_set_callbacks(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t (**v4)(uint64_t, uint64_t);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  const char *v13;
  _BOOL4 v14;
  _BOOL4 v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
      goto LABEL_73;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_plugin_name_set_callbacks";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_72;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v10)
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_plugin_name_set_callbacks";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_72;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_plugin_name_set_callbacks";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
LABEL_73:
      if (v5)
        goto LABEL_74;
      return;
    }
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_73;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v8 = "%{public}s called with null protocol";
    goto LABEL_72;
  }
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
      goto LABEL_73;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_plugin_name_set_callbacks";
        v8 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_72;
      }
      v11 = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v12 = os_log_type_enabled(v6, type);
      if (!v11)
      {
        if (!v12)
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_plugin_name_set_callbacks";
        v8 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_72;
      }
      if (!v12)
        goto LABEL_50;
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_plugin_name_set_callbacks";
      v21 = 2082;
      v22 = v11;
      v13 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_49;
    }
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_73;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v8 = "%{public}s called with null protocol->handle";
LABEL_72:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_73;
  }
  v3 = *(_QWORD **)(v2 + 64);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
      goto LABEL_73;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_plugin_name_set_callbacks";
        v8 = "%{public}s called with null name_plugin, backtrace limit exceeded";
        goto LABEL_72;
      }
      v11 = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v14 = os_log_type_enabled(v6, type);
      if (!v11)
      {
        if (!v14)
          goto LABEL_73;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_plugin_name_set_callbacks";
        v8 = "%{public}s called with null name_plugin, no backtrace";
        goto LABEL_72;
      }
      if (!v14)
        goto LABEL_50;
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_plugin_name_set_callbacks";
      v21 = 2082;
      v22 = v11;
      v13 = "%{public}s called with null name_plugin, dumping backtrace:%{public}s";
      goto LABEL_49;
    }
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_73;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v8 = "%{public}s called with null name_plugin";
    goto LABEL_72;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_73;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_plugin_name_set_callbacks";
      v8 = "%{public}s called with null add_input_handler_processor";
      goto LABEL_72;
    }
    if (!v17)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_73;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_plugin_name_set_callbacks";
      v8 = "%{public}s called with null add_input_handler_processor, backtrace limit exceeded";
      goto LABEL_72;
    }
    v11 = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v15 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v15)
        goto LABEL_73;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_plugin_name_set_callbacks";
      v8 = "%{public}s called with null add_input_handler_processor, no backtrace";
      goto LABEL_72;
    }
    if (!v15)
      goto LABEL_50;
    *(_DWORD *)buf = 136446466;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v21 = 2082;
    v22 = v11;
    v13 = "%{public}s called with null add_input_handler_processor, dumping backtrace:%{public}s";
LABEL_49:
    _os_log_impl(&dword_182FBE000, v6, v7, v13, buf, 0x16u);
    goto LABEL_50;
  }
  *v3 = a2;
  v4 = *(uint64_t (***)(uint64_t, uint64_t))(a1 + 24);
  if (v4)
  {
    *v4 = nw_protocol_plugin_name_add_input_handler;
    v4[4] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_disconnect;
    v4[5] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_connected;
    v4[23] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_input_finished;
    v4[6] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_disconnected;
    v4[7] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_error;
    v4[20] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_notify;
    v4[32] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_plugins_reset;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_plugin_name_set_callbacks";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v5, &type, &v17))
    goto LABEL_73;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_73;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v8 = "%{public}s called with null callbacks";
    goto LABEL_72;
  }
  if (!v17)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_73;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v8 = "%{public}s called with null callbacks, backtrace limit exceeded";
    goto LABEL_72;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v16 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v16)
      goto LABEL_73;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v8 = "%{public}s called with null callbacks, no backtrace";
    goto LABEL_72;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v20 = "nw_protocol_plugin_name_set_callbacks";
    v21 = 2082;
    v22 = v11;
    v13 = "%{public}s called with null callbacks, dumping backtrace:%{public}s";
    goto LABEL_49;
  }
LABEL_50:
  free(v11);
  if (v5)
LABEL_74:
    free(v5);
}

void nw_protocol_plugin_retry_begin_async(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  uint64_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(unsigned int *)(a1 + 208) + 1;
    v3 = v2 << 31 >> 31;
    *(_DWORD *)(a1 + 208) = v2;
    if (v3 == v2 && (v3 & 0x8000000000000000) == 0)
      return;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = *(unsigned int *)(a1 + 208);
    *(_DWORD *)buf = 136446978;
    v24 = "nw_protocol_plugin_retry_begin_async";
    v25 = 2082;
    v26 = "retry->async_count";
    v27 = 2048;
    v28 = 1;
    v29 = 2048;
    v30 = v4;
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v5, &type, &v21))
      goto LABEL_18;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v8 = *(unsigned int *)(a1 + 208);
        *(_DWORD *)buf = 136446978;
        v24 = "nw_protocol_plugin_retry_begin_async";
        v25 = 2082;
        v26 = "retry->async_count";
        v27 = 2048;
        v28 = 1;
        v29 = 2048;
        v30 = v8;
        v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v9, buf, 0x2Au);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v11)
        {
          v12 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)buf = 136447234;
          v24 = "nw_protocol_plugin_retry_begin_async";
          v25 = 2082;
          v26 = "retry->async_count";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v12;
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v11)
      {
        v14 = *(unsigned int *)(a1 + 208);
        *(_DWORD *)buf = 136446978;
        v24 = "nw_protocol_plugin_retry_begin_async";
        v25 = 2082;
        v26 = "retry->async_count";
        v27 = 2048;
        v28 = 1;
        v29 = 2048;
        v30 = v14;
        v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v13 = *(unsigned int *)(a1 + 208);
        *(_DWORD *)buf = 136446978;
        v24 = "nw_protocol_plugin_retry_begin_async";
        v25 = 2082;
        v26 = "retry->async_count";
        v27 = 2048;
        v28 = 1;
        v29 = 2048;
        v30 = v13;
        v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
    if (v5)
      free(v5);
    *(_DWORD *)(a1 + 208) = -1;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_protocol_plugin_retry_begin_async";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_plugin_retry_begin_async";
      v18 = "%{public}s called with null retry";
      goto LABEL_35;
    }
    if (!v21)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_plugin_retry_begin_async";
      v18 = "%{public}s called with null retry, backtrace limit exceeded";
      goto LABEL_35;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v20 = os_log_type_enabled(v16, type);
    if (v19)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_plugin_retry_begin_async";
        v25 = 2082;
        v26 = v19;
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null retry, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v19);
      goto LABEL_36;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_plugin_retry_begin_async";
      v18 = "%{public}s called with null retry, no backtrace";
LABEL_35:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
    }
  }
LABEL_36:
  if (v15)
    free(v15);
}

BOOL nw_protocol_plugin_retry_end_async(uint64_t a1)
{
  int v2;
  uint64_t v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 208);
    *(_DWORD *)(a1 + 208) = v2 - 1;
    if (v2)
      return (*(_BYTE *)(a1 + 212) & 0x40) == 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = *(unsigned int *)(a1 + 208);
    *(_DWORD *)buf = 136446978;
    v24 = "nw_protocol_plugin_retry_end_async";
    v25 = 2082;
    v26 = "retry->async_count";
    v27 = 2048;
    v28 = 1;
    v29 = 2048;
    v30 = v3;
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v4, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v7 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)buf = 136446978;
          v24 = "nw_protocol_plugin_retry_end_async";
          v25 = 2082;
          v26 = "retry->async_count";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v7;
          v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_16:
          _os_log_impl(&dword_182FBE000, v5, v6, v8, buf, 0x2Au);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        v10 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v10)
          {
            v11 = *(unsigned int *)(a1 + 208);
            *(_DWORD *)buf = 136447234;
            v24 = "nw_protocol_plugin_retry_end_async";
            v25 = 2082;
            v26 = "retry->async_count";
            v27 = 2048;
            v28 = 1;
            v29 = 2048;
            v30 = v11;
            v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          goto LABEL_17;
        }
        if (v10)
        {
          v13 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)buf = 136446978;
          v24 = "nw_protocol_plugin_retry_end_async";
          v25 = 2082;
          v26 = "retry->async_count";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v13;
          v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_16;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v12 = *(unsigned int *)(a1 + 208);
          *(_DWORD *)buf = 136446978;
          v24 = "nw_protocol_plugin_retry_end_async";
          v25 = 2082;
          v26 = "retry->async_count";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v12;
          v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_16;
        }
      }
    }
LABEL_17:
    if (v4)
      free(v4);
    *(_DWORD *)(a1 + 208) = 0;
    return (*(_BYTE *)(a1 + 212) & 0x40) == 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_protocol_plugin_retry_end_async";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_plugin_retry_end_async";
        v18 = "%{public}s called with null retry";
LABEL_35:
        _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      }
    }
    else if (v21)
    {
      v19 = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v20 = os_log_type_enabled(v16, type);
      if (v19)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_protocol_plugin_retry_end_async";
          v25 = 2082;
          v26 = v19;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null retry, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v19);
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_plugin_retry_end_async";
        v18 = "%{public}s called with null retry, no backtrace";
        goto LABEL_35;
      }
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_plugin_retry_end_async";
        v18 = "%{public}s called with null retry, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
  }
LABEL_36:
  if (v15)
    free(v15);
  return 0;
}

void nw_protocol_plugin_retry_reissue_output_frames(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, int a6, int a7, const void *a8, const void *a9, uint64_t a10)
{
  char v16;
  NSObject *v17;
  char v18;
  const char *v19;
  id v20;
  int v21;
  _BOOL8 v22;
  id v23;
  char v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(uint64_t);
  void *v30;
  char v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *v36;
  _BOOL4 v37;
  const char *v38;
  char v39;
  void *v40;
  void *v41;
  void *v42;
  char v43;
  const void *v44;
  void *v45;
  char v46;
  const void *v47;
  uint64_t v48;
  uint64_t v49;
  void (**v50)(_QWORD);
  const void *v51;
  char *backtrace_string;
  _BOOL4 v53;
  _BOOL4 v54;
  _BOOL4 v55;
  _BOOL4 v56;
  _BOOL4 v57;
  _BOOL4 v58;
  const char *v59;
  NSObject *v60;
  os_log_type_t v61;
  NSObject *v62;
  const char *v63;
  const char *v64;
  char *v65;
  NSObject *v66;
  os_log_type_t v67;
  const char *v68;
  char *v69;
  _BOOL4 v70;
  const char *v71;
  char *v72;
  NSObject *v73;
  _BOOL4 v74;
  const char *v75;
  NSObject *v76;
  os_log_type_t v77;
  const char *v78;
  NSObject *v79;
  os_log_type_t v80;
  NSObject *log;
  os_log_type_t type;
  char *v83;
  os_log_type_t v84;
  void *v85;
  const void *aBlocka;
  _QWORD v89[7];
  char v90;
  char v91;
  os_log_type_t v92;
  uint8_t buf[4];
  const char *v94;
  __int16 v95;
  void *v96;
  __int16 v97;
  uint64_t v98;
  __int16 v99;
  char *v100;
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v32, &v92, &v91))
      goto LABEL_64;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = v92;
        v53 = os_log_type_enabled(v33, v92);
        if (backtrace_string)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null retry, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v53)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null retry, no backtrace";
          goto LABEL_63;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null retry, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
      goto LABEL_64;
    }
    v33 = __nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null retry";
LABEL_63:
    _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
    goto LABEL_64;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v32, &v92, &v91))
      goto LABEL_64;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = v92;
        v54 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_41;
          }
LABEL_42:
          free(v36);
          if (!v32)
            return;
LABEL_65:
          free(v32);
          return;
        }
        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_63;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
      goto LABEL_64;
    }
    v33 = __nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null protocol";
    goto LABEL_63;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v32, &v92, &v91))
      goto LABEL_64;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = v92;
        v55 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null context, dumping backtrace:%{public}s";
            goto LABEL_41;
          }
          goto LABEL_42;
        }
        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null context, no backtrace";
          goto LABEL_63;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null context, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
      goto LABEL_64;
    }
    v33 = __nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null context";
    goto LABEL_63;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v32, &v92, &v91))
      goto LABEL_64;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = v92;
        v56 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null _output_frames_handler, dumping backtrace:%{public}s";
            goto LABEL_41;
          }
          goto LABEL_42;
        }
        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _output_frames_handler, no backtrace";
          goto LABEL_63;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _output_frames_handler, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
      goto LABEL_64;
    }
    v33 = __nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null _output_frames_handler";
    goto LABEL_63;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v32, &v92, &v91))
      goto LABEL_64;
    if (v92 != OS_LOG_TYPE_FAULT)
    {
      if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = v92;
        v57 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v57)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null _before_connect_handler, dumping backtrace:%{public}s";
            goto LABEL_41;
          }
          goto LABEL_42;
        }
        if (v57)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _before_connect_handler, no backtrace";
          goto LABEL_63;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null _before_connect_handler, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
      goto LABEL_64;
    }
    v33 = __nwlog_obj();
    v34 = v92;
    if (!os_log_type_enabled(v33, v92))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v35 = "%{public}s called with null _before_connect_handler";
    goto LABEL_63;
  }
  if (!a10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (__nwlog_fault(v32, &v92, &v91))
    {
      if (v92 == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null destroy_handler";
          goto LABEL_63;
        }
      }
      else if (v91)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = v92;
        v58 = os_log_type_enabled(v33, v92);
        if (v36)
        {
          if (v58)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_protocol_plugin_retry_reissue_output_frames";
            v95 = 2082;
            v96 = v36;
            v38 = "%{public}s called with null destroy_handler, dumping backtrace:%{public}s";
            goto LABEL_41;
          }
          goto LABEL_42;
        }
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null destroy_handler, no backtrace";
          goto LABEL_63;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = v92;
        if (os_log_type_enabled(v33, v92))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_protocol_plugin_retry_reissue_output_frames";
          v35 = "%{public}s called with null destroy_handler, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
    }
LABEL_64:
    if (!v32)
      return;
    goto LABEL_65;
  }
  v16 = *(_BYTE *)(a1 + 212);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = gLogObj;
  if ((v16 & 0x20) != 0)
  {
    *(_DWORD *)buf = 136446210;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v32 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (!__nwlog_fault(v32, &v92, &v91))
      goto LABEL_64;
    if (v92 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v33 = gLogObj;
      v34 = v92;
      if (!os_log_type_enabled((os_log_t)gLogObj, v92))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      v94 = "nw_protocol_plugin_retry_reissue_output_frames";
      v35 = "%{public}s trying to reissue output frames when an async reissue is pending";
      goto LABEL_63;
    }
    if (!v91)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v33 = gLogObj;
      v34 = v92;
      if (!os_log_type_enabled((os_log_t)gLogObj, v92))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      v94 = "nw_protocol_plugin_retry_reissue_output_frames";
      v35 = "%{public}s trying to reissue output frames when an async reissue is pending, backtrace limit exceeded";
      goto LABEL_63;
    }
    v36 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v33 = gLogObj;
    v34 = v92;
    v37 = os_log_type_enabled((os_log_t)gLogObj, v92);
    if (!v36)
    {
      if (!v37)
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      v94 = "nw_protocol_plugin_retry_reissue_output_frames";
      v35 = "%{public}s trying to reissue output frames when an async reissue is pending, no backtrace";
      goto LABEL_63;
    }
    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      v94 = "nw_protocol_plugin_retry_reissue_output_frames";
      v95 = 2082;
      v96 = v36;
      v38 = "%{public}s trying to reissue output frames when an async reissue is pending, dumping backtrace:%{public}s";
LABEL_41:
      _os_log_impl(&dword_182FBE000, v33, v34, v38, buf, 0x16u);
      goto LABEL_42;
    }
    goto LABEL_42;
  }
  v18 = a6;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
  {
    v19 = *(const char **)(a2 + 16);
    if (!v19)
      v19 = "invalid";
    *(_DWORD *)buf = 136446722;
    v94 = "nw_protocol_plugin_retry_reissue_output_frames";
    v95 = 2082;
    v96 = (void *)v19;
    v97 = 1024;
    LODWORD(v98) = a6;
    _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_INFO, "%{public}s Rebuilding stack and reissuing output frames for %{public}s, behavior %u", buf, 0x1Cu);
  }
  *(_BYTE *)(a1 + 212) = *(_BYTE *)(a1 + 212) & 0x69 | 0x10;
  if (a4)
  {
    v20 = a4;
    v21 = objc_msgSend(v20, "type");

    if (v21 == 4)
    {
      v22 = nw_endpoint_copy_host_port_endpoint_for_url(v20);
      v23 = nw_context_copy_registered_endpoint(a3, (void *)v22);
      v24 = *(_BYTE *)(a1 + 88);
      if ((v24 & 1) != 0)
      {
        v25 = *(void **)(a1 + 80);
        if (v25)
        {
          os_release(v25);
          v24 = *(_BYTE *)(a1 + 88);
        }
      }
      *(_QWORD *)(a1 + 80) = v23;
      *(_BYTE *)(a1 + 88) = v24 | 1;
      if (a5)
      {
LABEL_28:
        if (v22)
          os_release((void *)v22);
        if (a5)
          goto LABEL_31;
LABEL_49:
        v30 = 0;
        v31 = *(_BYTE *)(a1 + 56);
        if ((v31 & 1) == 0)
          goto LABEL_52;
LABEL_50:
        v41 = *(void **)(a1 + 48);
        if (v41)
        {
          os_release(v41);
          v31 = *(_BYTE *)(a1 + 56);
        }
        goto LABEL_52;
      }
      v26 = *(_QWORD *)(a2 + 48);
      if (v26)
      {
        v85 = *(void **)(v26 + 40);
        if (v85 == &nw_protocol_ref_counted_handle)
        {
          v27 = *(_QWORD *)(v26 + 88);
          if (v27)
            *(_QWORD *)(v26 + 88) = v27 + 1;
        }
        v28 = *(_QWORD *)(v26 + 24);
        if (v28)
        {
          v29 = *(uint64_t (**)(uint64_t))(v28 + 112);
          if (v29)
          {
            a5 = (void *)v29(v26);
LABEL_25:
            if (v85 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v26 + 40) == &nw_protocol_ref_counted_handle)
            {
              v48 = *(_QWORD *)(v26 + 88);
              if (v48)
              {
                v49 = v48 - 1;
                *(_QWORD *)(v26 + 88) = v49;
                if (!v49)
                {
                  v50 = *(void (***)(_QWORD))(v26 + 64);
                  if (v50)
                  {
                    *(_QWORD *)(v26 + 64) = 0;
                    aBlocka = v50;
                    v50[2](v50);
                    _Block_release(aBlocka);
                  }
                  if ((*(_BYTE *)(v26 + 72) & 1) != 0)
                  {
                    v51 = *(const void **)(v26 + 64);
                    if (v51)
                      _Block_release(v51);
                  }
                  free((void *)v26);
                }
              }
            }
LABEL_27:
            nw_parameters_set_url_endpoint(a5, v20);
            goto LABEL_28;
          }
        }
        __nwlog_obj();
        v59 = *(const char **)(v26 + 16);
        *(_DWORD *)buf = 136446722;
        v94 = "__nw_protocol_get_parameters";
        if (!v59)
          v59 = "invalid";
        v95 = 2082;
        v96 = (void *)v59;
        v97 = 2048;
        v98 = v26;
        v92 = OS_LOG_TYPE_ERROR;
        v91 = 0;
        v83 = (char *)_os_log_send_and_compose_impl();
        if (__nwlog_fault(v83, &v92, &v91))
        {
          if (v92 == OS_LOG_TYPE_FAULT)
          {
            v60 = __nwlog_obj();
            v61 = v92;
            v62 = v60;
            if (os_log_type_enabled(v60, v92))
            {
              v63 = *(const char **)(v26 + 16);
              if (!v63)
                v63 = "invalid";
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = (void *)v63;
              v97 = 2048;
              v98 = v26;
              v64 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_176:
              v76 = v62;
              v77 = v61;
LABEL_177:
              _os_log_impl(&dword_182FBE000, v76, v77, v64, buf, 0x20u);
            }
          }
          else if (v91)
          {
            v69 = (char *)__nw_create_backtrace_string();
            log = __nwlog_obj();
            type = v92;
            v70 = os_log_type_enabled(log, v92);
            if (v69)
            {
              if (v70)
              {
                v71 = *(const char **)(v26 + 16);
                if (!v71)
                  v71 = "invalid";
                *(_DWORD *)buf = 136446978;
                v94 = "__nw_protocol_get_parameters";
                v95 = 2082;
                v96 = (void *)v71;
                v97 = 2048;
                v98 = v26;
                v99 = 2082;
                v100 = v69;
                _os_log_impl(&dword_182FBE000, log, type, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
              }
              free(v69);
              goto LABEL_178;
            }
            if (v70)
            {
              v78 = *(const char **)(v26 + 16);
              if (!v78)
                v78 = "invalid";
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = (void *)v78;
              v97 = 2048;
              v98 = v26;
              v64 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
              v76 = log;
              v77 = type;
              goto LABEL_177;
            }
          }
          else
          {
            v62 = __nwlog_obj();
            v61 = v92;
            if (os_log_type_enabled(v62, v92))
            {
              v75 = *(const char **)(v26 + 16);
              if (!v75)
                v75 = "invalid";
              *(_DWORD *)buf = 136446722;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = (void *)v75;
              v97 = 2048;
              v98 = v26;
              v64 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
              goto LABEL_176;
            }
          }
        }
LABEL_178:
        if (v83)
          free(v83);
        a5 = 0;
        v18 = a6;
        goto LABEL_25;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v94 = "__nw_protocol_get_parameters";
      v92 = OS_LOG_TYPE_ERROR;
      v91 = 0;
      v65 = (char *)_os_log_send_and_compose_impl();
      if (__nwlog_fault(v65, &v92, &v91))
      {
        if (v92 == OS_LOG_TYPE_FAULT)
        {
          v66 = __nwlog_obj();
          v67 = v92;
          if (os_log_type_enabled(v66, v92))
          {
            *(_DWORD *)buf = 136446210;
            v94 = "__nw_protocol_get_parameters";
            v68 = "%{public}s called with null protocol";
LABEL_187:
            v79 = v66;
            v80 = v67;
LABEL_188:
            _os_log_impl(&dword_182FBE000, v79, v80, v68, buf, 0xCu);
          }
        }
        else if (v91)
        {
          v72 = (char *)__nw_create_backtrace_string();
          v73 = __nwlog_obj();
          v84 = v92;
          v74 = os_log_type_enabled(v73, v92);
          if (v72)
          {
            if (v74)
            {
              *(_DWORD *)buf = 136446466;
              v94 = "__nw_protocol_get_parameters";
              v95 = 2082;
              v96 = v72;
              _os_log_impl(&dword_182FBE000, v73, v84, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v72);
            goto LABEL_189;
          }
          if (v74)
          {
            *(_DWORD *)buf = 136446210;
            v94 = "__nw_protocol_get_parameters";
            v68 = "%{public}s called with null protocol, no backtrace";
            v79 = v73;
            v80 = v84;
            goto LABEL_188;
          }
        }
        else
        {
          v66 = __nwlog_obj();
          v67 = v92;
          if (os_log_type_enabled(v66, v92))
          {
            *(_DWORD *)buf = 136446210;
            v94 = "__nw_protocol_get_parameters";
            v68 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_187;
          }
        }
      }
LABEL_189:
      if (v65)
        free(v65);
      a5 = 0;
      v18 = a6;
      goto LABEL_27;
    }
    a4 = os_retain(v20);
  }
  v39 = *(_BYTE *)(a1 + 88);
  if ((v39 & 1) != 0)
  {
    v40 = *(void **)(a1 + 80);
    if (v40)
    {
      os_release(v40);
      v39 = *(_BYTE *)(a1 + 88);
    }
  }
  *(_QWORD *)(a1 + 80) = a4;
  *(_BYTE *)(a1 + 88) = v39 | 1;
  if (!a5)
    goto LABEL_49;
LABEL_31:
  v30 = os_retain(a5);
  v31 = *(_BYTE *)(a1 + 56);
  if ((v31 & 1) != 0)
    goto LABEL_50;
LABEL_52:
  *(_QWORD *)(a1 + 48) = v30;
  *(_BYTE *)(a1 + 56) = v31 | 1;
  *(_DWORD *)(a1 + 180) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 188) = a7;
  v42 = _Block_copy(a8);
  v43 = *(_BYTE *)(a1 + 120);
  if ((v43 & 1) != 0)
  {
    v44 = *(const void **)(a1 + 112);
    if (v44)
    {
      _Block_release(v44);
      v43 = *(_BYTE *)(a1 + 120);
    }
  }
  *(_QWORD *)(a1 + 112) = v42;
  *(_BYTE *)(a1 + 120) = v43 | 1;
  v45 = _Block_copy(a9);
  v46 = *(_BYTE *)(a1 + 168);
  if ((v46 & 1) != 0)
  {
    v47 = *(const void **)(a1 + 160);
    if (v47)
    {
      _Block_release(v47);
      v46 = *(_BYTE *)(a1 + 168);
    }
  }
  *(_QWORD *)(a1 + 160) = v45;
  *(_BYTE *)(a1 + 168) = v46 | 1;
  *(_BYTE *)(a1 + 212) |= 0x20u;
  nw_protocol_plugin_retry_begin_async(a1);
  v89[0] = MEMORY[0x1E0C809B0];
  v89[1] = 0x40000000;
  v89[2] = __nw_protocol_plugin_retry_reissue_output_frames_block_invoke;
  v89[3] = &unk_1E149A7E0;
  v89[4] = a10;
  v89[5] = a1;
  v90 = v18;
  v89[6] = a2;
  nw_queue_context_async(a3, v89);
}

void sub_1833AE598(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_protocol_plugin_retry_reissue_output_frames_block_invoke(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  char v19;
  NSObject *v20;
  const char **v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD);
  NSObject *v31;
  const char **v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  void (**v36)(_QWORD);
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  void (**v40)(_QWORD);
  const void *v41;
  uint64_t v42;
  uint64_t v43;
  void (**v44)(_QWORD);
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  void (**v48)(_QWORD);
  const void *v49;
  uint64_t v50;
  uint64_t v51;
  void (**v52)(_QWORD);
  const void *v53;
  uint64_t v54;
  uint64_t v55;
  void (**v56)(_QWORD);
  const void *v57;
  uint64_t v58;
  char v59;
  const void *v60;
  const char *v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  const char *v65;
  const char *v66;
  NSObject *v67;
  const char *v68;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  const char *v73;
  NSObject *v74;
  const char *v75;
  char *v76;
  NSObject *v77;
  os_log_type_t v78;
  const char *v79;
  const char *v80;
  NSObject *v81;
  NSObject *v82;
  os_log_type_t v83;
  const char *v84;
  char *v85;
  NSObject *v86;
  os_log_type_t v87;
  const char *v88;
  NSObject *v89;
  os_log_type_t v90;
  const char *v91;
  void *v92;
  char *v93;
  NSObject *v94;
  _BOOL4 v95;
  const char *v96;
  void *v97;
  char *v98;
  NSObject *v99;
  _BOOL4 v100;
  const char *v101;
  void *v102;
  char *backtrace_string;
  NSObject *v104;
  _BOOL4 v105;
  const char *v106;
  char *v107;
  _BOOL4 v108;
  char *v109;
  _BOOL4 v110;
  char *v111;
  _BOOL4 v112;
  NSObject *v113;
  const char *v114;
  NSObject *v115;
  const char *v116;
  NSObject *v117;
  const char *v118;
  const char *v119;
  const char *v120;
  const char *v121;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  char v125;
  os_log_type_t type[193];
  uint8_t buf[4];
  const char *v128;
  __int16 v129;
  void *v130;
  __int16 v131;
  uint64_t v132;
  __int16 v133;
  char *v134;
  uint64_t v135;

  v135 = *MEMORY[0x1E0C80C00];
  if (!nw_protocol_plugin_retry_end_async(*(_QWORD *)(a1 + 40)))
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    return;
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 212) &= ~0x20u;
  v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 == 2)
  {
    v23 = *(_QWORD *)(a1 + 48);
    v24 = *(_QWORD *)(v23 + 48);
    if (v24)
    {
      v25 = *(void **)(v24 + 40);
      if (v25 == &nw_protocol_ref_counted_handle)
      {
        v26 = *(_QWORD *)(v24 + 88);
        if (v26)
          *(_QWORD *)(v24 + 88) = v26 + 1;
      }
      v27 = *(void **)(v23 + 40);
      if (v27 == &nw_protocol_ref_counted_handle)
      {
        v28 = *(_QWORD *)(v23 + 88);
        if (v28)
          *(_QWORD *)(v23 + 88) = v28 + 1;
      }
      v29 = *(_QWORD *)(v24 + 24);
      if (v29)
      {
        v30 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(v29 + 160);
        if (v30)
        {
          v30(v24, v23, 19, 0, 0);
LABEL_48:
          if (v27 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v23 + 40) == &nw_protocol_ref_counted_handle)
          {
            v50 = *(_QWORD *)(v23 + 88);
            if (v50)
            {
              v51 = v50 - 1;
              *(_QWORD *)(v23 + 88) = v51;
              if (!v51)
              {
                v52 = *(void (***)(_QWORD))(v23 + 64);
                if (v52)
                {
                  *(_QWORD *)(v23 + 64) = 0;
                  v52[2](v52);
                  _Block_release(v52);
                }
                if ((*(_BYTE *)(v23 + 72) & 1) != 0)
                {
                  v53 = *(const void **)(v23 + 64);
                  if (v53)
                    _Block_release(v53);
                }
                free((void *)v23);
              }
            }
          }
          if (v25 != &nw_protocol_ref_counted_handle)
            goto LABEL_52;
          if (*(_UNKNOWN **)(v24 + 40) != &nw_protocol_ref_counted_handle)
            goto LABEL_52;
          v54 = *(_QWORD *)(v24 + 88);
          if (!v54)
            goto LABEL_52;
          v55 = v54 - 1;
          *(_QWORD *)(v24 + 88) = v55;
          if (v55)
            goto LABEL_52;
          v56 = *(void (***)(_QWORD))(v24 + 64);
          if (v56)
          {
            *(_QWORD *)(v24 + 64) = 0;
            v56[2](v56);
            _Block_release(v56);
          }
          if ((*(_BYTE *)(v24 + 72) & 1) != 0)
          {
            v57 = *(const void **)(v24 + 64);
            if (v57)
              _Block_release(v57);
          }
          goto LABEL_105;
        }
      }
      __nwlog_obj();
      v75 = *(const char **)(v24 + 16);
      *(_DWORD *)buf = 136446722;
      v128 = "__nw_protocol_notify";
      if (!v75)
        v75 = "invalid";
      v129 = 2082;
      v130 = (void *)v75;
      v131 = 2048;
      v132 = v24;
      v76 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v125 = 0;
      if (__nwlog_fault(v76, type, &v125))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v77 = __nwlog_obj();
          v78 = type[0];
          if (!os_log_type_enabled(v77, type[0]))
            goto LABEL_223;
          v79 = *(const char **)(v24 + 16);
          if (!v79)
            v79 = "invalid";
          *(_DWORD *)buf = 136446722;
          v128 = "__nw_protocol_notify";
          v129 = 2082;
          v130 = (void *)v79;
          v131 = 2048;
          v132 = v24;
          v80 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
          v81 = v77;
          goto LABEL_222;
        }
        v102 = v25;
        if (!v125)
        {
          v117 = __nwlog_obj();
          v78 = type[0];
          logb = v117;
          if (!os_log_type_enabled(v117, type[0]))
            goto LABEL_223;
          v118 = *(const char **)(v24 + 16);
          if (!v118)
            v118 = "invalid";
          *(_DWORD *)buf = 136446722;
          v128 = "__nw_protocol_notify";
          v129 = 2082;
          v130 = (void *)v118;
          v131 = 2048;
          v132 = v24;
          v80 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
          goto LABEL_221;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v104 = __nwlog_obj();
        v78 = type[0];
        logb = v104;
        v105 = os_log_type_enabled(v104, type[0]);
        if (backtrace_string)
        {
          if (v105)
          {
            v106 = *(const char **)(v24 + 16);
            if (!v106)
              v106 = "invalid";
            *(_DWORD *)buf = 136446978;
            v128 = "__nw_protocol_notify";
            v129 = 2082;
            v130 = (void *)v106;
            v131 = 2048;
            v132 = v24;
            v133 = 2082;
            v134 = backtrace_string;
            _os_log_impl(&dword_182FBE000, logb, v78, "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
          v25 = v102;
          goto LABEL_223;
        }
        v25 = v102;
        if (v105)
        {
          v121 = *(const char **)(v24 + 16);
          if (!v121)
            v121 = "invalid";
          *(_DWORD *)buf = 136446722;
          v128 = "__nw_protocol_notify";
          v129 = 2082;
          v130 = (void *)v121;
          v131 = 2048;
          v132 = v24;
          v80 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
LABEL_221:
          v81 = logb;
LABEL_222:
          _os_log_impl(&dword_182FBE000, v81, v78, v80, buf, 0x20u);
        }
      }
LABEL_223:
      if (v76)
        free(v76);
      goto LABEL_48;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v128 = "__nw_protocol_notify";
    v24 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v125 = 0;
    if (!__nwlog_fault((const char *)v24, type, &v125))
      goto LABEL_244;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v89 = __nwlog_obj();
      v90 = type[0];
      if (!os_log_type_enabled(v89, type[0]))
        goto LABEL_244;
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_notify";
      v91 = "%{public}s called with null protocol";
    }
    else if (v125)
    {
      v111 = (char *)__nw_create_backtrace_string();
      v89 = __nwlog_obj();
      v90 = type[0];
      v112 = os_log_type_enabled(v89, type[0]);
      if (v111)
      {
        if (v112)
        {
          *(_DWORD *)buf = 136446466;
          v128 = "__nw_protocol_notify";
          v129 = 2082;
          v130 = v111;
          _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v111);
        if (!v24)
          goto LABEL_52;
        goto LABEL_105;
      }
      if (!v112)
      {
LABEL_244:
        if (!v24)
        {
LABEL_52:
          if (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 160))
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v31 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              v32 = *(const char ***)(*(_QWORD *)(a1 + 48) + 32);
              if (v32)
              {
                v33 = v32[2];
                if (!v33)
                  v33 = "invalid";
              }
              else
              {
                v33 = 0;
              }
              *(_DWORD *)buf = 136446722;
              v128 = "nw_protocol_plugin_retry_reissue_output_frames_block_invoke";
              v129 = 2048;
              v130 = v32;
              v131 = 2080;
              v132 = (uint64_t)v33;
              _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_ERROR, "%{public}s Connect was not called by endpoint_flow <%p:%s>", buf, 0x20u);
            }
            v58 = *(_QWORD *)(a1 + 40);
            v59 = *(_BYTE *)(v58 + 168);
            if ((v59 & 1) != 0)
            {
              v60 = *(const void **)(v58 + 160);
              if (v60)
              {
                _Block_release(v60);
                v59 = *(_BYTE *)(v58 + 168);
              }
            }
            *(_QWORD *)(v58 + 160) = 0;
            *(_BYTE *)(v58 + 168) = v59 | 1;
          }
          return;
        }
LABEL_105:
        free((void *)v24);
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_notify";
      v91 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v89 = __nwlog_obj();
      v90 = type[0];
      if (!os_log_type_enabled(v89, type[0]))
        goto LABEL_244;
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_notify";
      v91 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v89, v90, v91, buf, 0xCu);
    goto LABEL_244;
  }
  if (v2 != 1)
    return;
  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(_QWORD *)(v3 + 32);
  if (v4)
  {
    v5 = *(void **)(v4 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      v6 = *(_QWORD *)(v4 + 88);
      if (v6)
        *(_QWORD *)(v4 + 88) = v6 + 1;
    }
    v7 = *(void **)(v3 + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      v8 = *(_QWORD *)(v3 + 88);
      if (v8)
        *(_QWORD *)(v3 + 88) = v8 + 1;
    }
    v9 = *(_QWORD *)(v4 + 24);
    if (v9)
    {
      v10 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(v9 + 160);
      if (v10)
      {
        v10(v4, v3, 15, 0, 0);
        goto LABEL_14;
      }
    }
    __nwlog_obj();
    v61 = *(const char **)(v4 + 16);
    *(_DWORD *)buf = 136446722;
    v128 = "__nw_protocol_notify";
    if (!v61)
      v61 = "invalid";
    v129 = 2082;
    v130 = (void *)v61;
    v131 = 2048;
    v132 = v4;
    v62 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v125 = 0;
    if (__nwlog_fault(v62, type, &v125))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v63 = __nwlog_obj();
        v64 = type[0];
        if (!os_log_type_enabled(v63, type[0]))
          goto LABEL_205;
        v65 = *(const char **)(v4 + 16);
        if (!v65)
          v65 = "invalid";
        *(_DWORD *)buf = 136446722;
        v128 = "__nw_protocol_notify";
        v129 = 2082;
        v130 = (void *)v65;
        v131 = 2048;
        v132 = v4;
        v66 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
        v67 = v63;
        goto LABEL_204;
      }
      v92 = v5;
      if (!v125)
      {
        v113 = __nwlog_obj();
        v64 = type[0];
        log = v113;
        if (!os_log_type_enabled(v113, type[0]))
          goto LABEL_205;
        v114 = *(const char **)(v4 + 16);
        if (!v114)
          v114 = "invalid";
        *(_DWORD *)buf = 136446722;
        v128 = "__nw_protocol_notify";
        v129 = 2082;
        v130 = (void *)v114;
        v131 = 2048;
        v132 = v4;
        v66 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
        goto LABEL_203;
      }
      v93 = (char *)__nw_create_backtrace_string();
      v94 = __nwlog_obj();
      v64 = type[0];
      log = v94;
      v95 = os_log_type_enabled(v94, type[0]);
      if (v93)
      {
        if (v95)
        {
          v96 = *(const char **)(v4 + 16);
          if (!v96)
            v96 = "invalid";
          *(_DWORD *)buf = 136446978;
          v128 = "__nw_protocol_notify";
          v129 = 2082;
          v130 = (void *)v96;
          v131 = 2048;
          v132 = v4;
          v133 = 2082;
          v134 = v93;
          _os_log_impl(&dword_182FBE000, log, v64, "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v93);
        v5 = v92;
        goto LABEL_205;
      }
      v5 = v92;
      if (v95)
      {
        v119 = *(const char **)(v4 + 16);
        if (!v119)
          v119 = "invalid";
        *(_DWORD *)buf = 136446722;
        v128 = "__nw_protocol_notify";
        v129 = 2082;
        v130 = (void *)v119;
        v131 = 2048;
        v132 = v4;
        v66 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
LABEL_203:
        v67 = log;
LABEL_204:
        _os_log_impl(&dword_182FBE000, v67, v64, v66, buf, 0x20u);
      }
    }
LABEL_205:
    if (v62)
      free(v62);
LABEL_14:
    if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
    {
      v34 = *(_QWORD *)(v3 + 88);
      if (v34)
      {
        v35 = v34 - 1;
        *(_QWORD *)(v3 + 88) = v35;
        if (!v35)
        {
          v36 = *(void (***)(_QWORD))(v3 + 64);
          if (v36)
          {
            *(_QWORD *)(v3 + 64) = 0;
            v36[2](v36);
            _Block_release(v36);
          }
          if ((*(_BYTE *)(v3 + 72) & 1) != 0)
          {
            v37 = *(const void **)(v3 + 64);
            if (v37)
              _Block_release(v37);
          }
          free((void *)v3);
        }
      }
    }
    if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
    {
      v38 = *(_QWORD *)(v4 + 88);
      if (v38)
      {
        v39 = v38 - 1;
        *(_QWORD *)(v4 + 88) = v39;
        if (!v39)
        {
          v40 = *(void (***)(_QWORD))(v4 + 64);
          if (v40)
          {
            *(_QWORD *)(v4 + 64) = 0;
            v40[2](v40);
            _Block_release(v40);
          }
          if ((*(_BYTE *)(v4 + 72) & 1) != 0)
          {
            v41 = *(const void **)(v4 + 64);
            if (v41)
              _Block_release(v41);
          }
          goto LABEL_73;
        }
      }
    }
    goto LABEL_18;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v128 = "__nw_protocol_notify";
  v4 = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v125 = 0;
  if (__nwlog_fault((const char *)v4, type, &v125))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v82 = __nwlog_obj();
      v83 = type[0];
      if (!os_log_type_enabled(v82, type[0]))
        goto LABEL_234;
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_notify";
      v84 = "%{public}s called with null protocol";
    }
    else if (v125)
    {
      v107 = (char *)__nw_create_backtrace_string();
      v82 = __nwlog_obj();
      v83 = type[0];
      v108 = os_log_type_enabled(v82, type[0]);
      if (v107)
      {
        if (v108)
        {
          *(_DWORD *)buf = 136446466;
          v128 = "__nw_protocol_notify";
          v129 = 2082;
          v130 = v107;
          _os_log_impl(&dword_182FBE000, v82, v83, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v107);
        if (v4)
          goto LABEL_73;
        goto LABEL_18;
      }
      if (!v108)
        goto LABEL_234;
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_notify";
      v84 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v82 = __nwlog_obj();
      v83 = type[0];
      if (!os_log_type_enabled(v82, type[0]))
        goto LABEL_234;
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_notify";
      v84 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v82, v83, v84, buf, 0xCu);
  }
LABEL_234:
  if (v4)
LABEL_73:
    free((void *)v4);
LABEL_18:
  v11 = *(_QWORD *)(a1 + 48);
  v12 = *(_QWORD *)(v11 + 32);
  if (!v12)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v128 = "__nw_protocol_connect";
    v85 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v125 = 0;
    if (!__nwlog_fault(v85, type, &v125))
      goto LABEL_239;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v86 = __nwlog_obj();
      v87 = type[0];
      if (!os_log_type_enabled(v86, type[0]))
        goto LABEL_239;
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_connect";
      v88 = "%{public}s called with null protocol";
    }
    else if (v125)
    {
      v109 = (char *)__nw_create_backtrace_string();
      v86 = __nwlog_obj();
      v87 = type[0];
      v110 = os_log_type_enabled(v86, type[0]);
      if (v109)
      {
        if (v110)
        {
          *(_DWORD *)buf = 136446466;
          v128 = "__nw_protocol_connect";
          v129 = 2082;
          v130 = v109;
          _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v109);
        goto LABEL_239;
      }
      if (!v110)
      {
LABEL_239:
        if (v85)
          free(v85);
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_connect";
      v88 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v86 = __nwlog_obj();
      v87 = type[0];
      if (!os_log_type_enabled(v86, type[0]))
        goto LABEL_239;
      *(_DWORD *)buf = 136446210;
      v128 = "__nw_protocol_connect";
      v88 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v86, v87, v88, buf, 0xCu);
    goto LABEL_239;
  }
  v13 = *(void **)(v12 + 40);
  if (v13 == &nw_protocol_ref_counted_handle)
  {
    v14 = *(_QWORD *)(v12 + 88);
    if (v14)
      *(_QWORD *)(v12 + 88) = v14 + 1;
  }
  v15 = *(void **)(v11 + 40);
  if (v15 == &nw_protocol_ref_counted_handle)
  {
    v16 = *(_QWORD *)(v11 + 88);
    if (v16)
      *(_QWORD *)(v11 + 88) = v16 + 1;
  }
  v17 = *(_QWORD *)(v12 + 24);
  if (v17)
  {
    v18 = *(uint64_t (**)(uint64_t, uint64_t))(v17 + 24);
    if (v18)
    {
      v19 = v18(v12, v11);
      if (v15 != &nw_protocol_ref_counted_handle)
        goto LABEL_29;
      goto LABEL_28;
    }
  }
  __nwlog_obj();
  v68 = *(const char **)(v12 + 16);
  *(_DWORD *)buf = 136446722;
  v128 = "__nw_protocol_connect";
  if (!v68)
    v68 = "invalid";
  v129 = 2082;
  v130 = (void *)v68;
  v131 = 2048;
  v132 = v12;
  v69 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v125 = 0;
  if (__nwlog_fault(v69, type, &v125))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v70 = __nwlog_obj();
      v71 = type[0];
      if (!os_log_type_enabled(v70, type[0]))
        goto LABEL_213;
      v72 = *(const char **)(v12 + 16);
      if (!v72)
        v72 = "invalid";
      *(_DWORD *)buf = 136446722;
      v128 = "__nw_protocol_connect";
      v129 = 2082;
      v130 = (void *)v72;
      v131 = 2048;
      v132 = v12;
      v73 = "%{public}s protocol %{public}s (%p) has invalid connect callback";
      v74 = v70;
      goto LABEL_212;
    }
    v97 = v13;
    if (v125)
    {
      v98 = (char *)__nw_create_backtrace_string();
      v99 = __nwlog_obj();
      v71 = type[0];
      loga = v99;
      v100 = os_log_type_enabled(v99, type[0]);
      if (v98)
      {
        if (v100)
        {
          v101 = *(const char **)(v12 + 16);
          if (!v101)
            v101 = "invalid";
          *(_DWORD *)buf = 136446978;
          v128 = "__nw_protocol_connect";
          v129 = 2082;
          v130 = (void *)v101;
          v131 = 2048;
          v132 = v12;
          v133 = 2082;
          v134 = v98;
          _os_log_impl(&dword_182FBE000, loga, v71, "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v98);
        v13 = v97;
        goto LABEL_213;
      }
      v13 = v97;
      if (!v100)
        goto LABEL_213;
      v120 = *(const char **)(v12 + 16);
      if (!v120)
        v120 = "invalid";
      *(_DWORD *)buf = 136446722;
      v128 = "__nw_protocol_connect";
      v129 = 2082;
      v130 = (void *)v120;
      v131 = 2048;
      v132 = v12;
      v73 = "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace";
    }
    else
    {
      v115 = __nwlog_obj();
      v71 = type[0];
      loga = v115;
      if (!os_log_type_enabled(v115, type[0]))
        goto LABEL_213;
      v116 = *(const char **)(v12 + 16);
      if (!v116)
        v116 = "invalid";
      *(_DWORD *)buf = 136446722;
      v128 = "__nw_protocol_connect";
      v129 = 2082;
      v130 = (void *)v116;
      v131 = 2048;
      v132 = v12;
      v73 = "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded";
    }
    v74 = loga;
LABEL_212:
    _os_log_impl(&dword_182FBE000, v74, v71, v73, buf, 0x20u);
  }
LABEL_213:
  if (v69)
    free(v69);
  v19 = 0;
  if (v15 == &nw_protocol_ref_counted_handle)
  {
LABEL_28:
    if (*(_UNKNOWN **)(v11 + 40) == &nw_protocol_ref_counted_handle)
    {
      v42 = *(_QWORD *)(v11 + 88);
      if (v42)
      {
        v43 = v42 - 1;
        *(_QWORD *)(v11 + 88) = v43;
        if (!v43)
        {
          v44 = *(void (***)(_QWORD))(v11 + 64);
          if (v44)
          {
            *(_QWORD *)(v11 + 64) = 0;
            v44[2](v44);
            _Block_release(v44);
          }
          if ((*(_BYTE *)(v11 + 72) & 1) != 0)
          {
            v45 = *(const void **)(v11 + 64);
            if (v45)
              _Block_release(v45);
          }
          free((void *)v11);
        }
      }
    }
  }
LABEL_29:
  if (v13 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v12 + 40) == &nw_protocol_ref_counted_handle)
  {
    v46 = *(_QWORD *)(v12 + 88);
    if (v46)
    {
      v47 = v46 - 1;
      *(_QWORD *)(v12 + 88) = v47;
      if (!v47)
      {
        v48 = *(void (***)(_QWORD))(v12 + 64);
        if (v48)
        {
          *(_QWORD *)(v12 + 64) = 0;
          v48[2](v48);
          _Block_release(v48);
        }
        if ((*(_BYTE *)(v12 + 72) & 1) != 0)
        {
          v49 = *(const void **)(v12 + 64);
          if (v49)
            _Block_release(v49);
        }
        free((void *)v12);
      }
    }
  }
  if ((v19 & 1) == 0)
  {
LABEL_32:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v21 = *(const char ***)(*(_QWORD *)(a1 + 48) + 32);
      v22 = "invalid";
      if (v21)
      {
        if (v21[2])
          v22 = v21[2];
      }
      *(_DWORD *)buf = 136446722;
      v128 = "nw_protocol_plugin_retry_reissue_output_frames_block_invoke";
      v129 = 2048;
      v130 = v21;
      v131 = 2080;
      v132 = (uint64_t)v22;
      _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s Unable to connect protocol <%p:%s>", buf, 0x20u);
    }
  }
}

void nw_protocol_plugin_retry_set_callbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  _BOOL4 v20;
  _BOOL4 v21;
  _BOOL4 v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_112;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_111;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v13)
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_111;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v27 = 2082;
        v28 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
LABEL_112:
      if (v8)
        goto LABEL_113;
      return;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null protocol";
    goto LABEL_111;
  }
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_112;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
        goto LABEL_111;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v15)
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null protocol->handle, no backtrace";
        goto LABEL_111;
      }
      if (!v15)
        goto LABEL_77;
      *(_DWORD *)buf = 136446466;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v27 = 2082;
      v28 = v14;
      v16 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_76;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null protocol->handle";
LABEL_111:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_112;
  }
  v6 = *(_QWORD **)(v5 + 88);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_112;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
        goto LABEL_111;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v17)
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null retry_plugin, no backtrace";
        goto LABEL_111;
      }
      if (!v17)
        goto LABEL_77;
      *(_DWORD *)buf = 136446466;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v27 = 2082;
      v28 = v14;
      v16 = "%{public}s called with null retry_plugin, dumping backtrace:%{public}s";
      goto LABEL_76;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null retry_plugin";
    goto LABEL_111;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_112;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null retry_processor, backtrace limit exceeded";
        goto LABEL_111;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v18 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v18)
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null retry_processor, no backtrace";
        goto LABEL_111;
      }
      if (!v18)
        goto LABEL_77;
      *(_DWORD *)buf = 136446466;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v27 = 2082;
      v28 = v14;
      v16 = "%{public}s called with null retry_processor, dumping backtrace:%{public}s";
      goto LABEL_76;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null retry_processor";
    goto LABEL_111;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_112;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null connect_processor, backtrace limit exceeded";
        goto LABEL_111;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v19 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v19)
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null connect_processor, no backtrace";
        goto LABEL_111;
      }
      if (!v19)
        goto LABEL_77;
      *(_DWORD *)buf = 136446466;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v27 = 2082;
      v28 = v14;
      v16 = "%{public}s called with null connect_processor, dumping backtrace:%{public}s";
      goto LABEL_76;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null connect_processor";
    goto LABEL_111;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_112;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null disconnect_processor, backtrace limit exceeded";
        goto LABEL_111;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v20 = os_log_type_enabled(v9, type);
      if (!v14)
      {
        if (!v20)
          goto LABEL_112;
        *(_DWORD *)buf = 136446210;
        v26 = "nw_protocol_plugin_retry_set_callbacks";
        v11 = "%{public}s called with null disconnect_processor, no backtrace";
        goto LABEL_111;
      }
      if (!v20)
        goto LABEL_77;
      *(_DWORD *)buf = 136446466;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v27 = 2082;
      v28 = v14;
      v16 = "%{public}s called with null disconnect_processor, dumping backtrace:%{public}s";
      goto LABEL_76;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null disconnect_processor";
    goto LABEL_111;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_112;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_112;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v11 = "%{public}s called with null error_processor";
      goto LABEL_111;
    }
    if (!v23)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_112;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v11 = "%{public}s called with null error_processor, backtrace limit exceeded";
      goto LABEL_111;
    }
    v14 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v21 = os_log_type_enabled(v9, type);
    if (!v14)
    {
      if (!v21)
        goto LABEL_112;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_protocol_plugin_retry_set_callbacks";
      v11 = "%{public}s called with null error_processor, no backtrace";
      goto LABEL_111;
    }
    if (!v21)
      goto LABEL_77;
    *(_DWORD *)buf = 136446466;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v27 = 2082;
    v28 = v14;
    v16 = "%{public}s called with null error_processor, dumping backtrace:%{public}s";
LABEL_76:
    _os_log_impl(&dword_182FBE000, v9, v10, v16, buf, 0x16u);
    goto LABEL_77;
  }
  v6[16] = a3;
  v6[17] = a4;
  v6[18] = a5;
  v6[19] = a2;
  v7 = *(_QWORD **)(a1 + 24);
  if (v7)
  {
    v7[14] = nw_protocol_plugin_retry_get_parameters;
    v7[17] = nw_protocol_plugin_retry_get_remote_endpoint;
    v7[3] = nw_protocol_plugin_retry_connect;
    v7[4] = nw_protocol_plugins_disconnect;
    v7[23] = nw_protocol_plugins_input_finished;
    v7[5] = nw_protocol_plugins_connected;
    v7[6] = nw_protocol_plugins_disconnected;
    v7[7] = nw_protocol_plugins_error;
    v7[20] = nw_protocol_plugins_notify;
    v7[32] = nw_protocol_plugins_reset;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_protocol_plugin_retry_set_callbacks";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_112;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null callbacks";
    goto LABEL_111;
  }
  if (!v23)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null callbacks, backtrace limit exceeded";
    goto LABEL_111;
  }
  v14 = (char *)__nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v10 = type;
  v22 = os_log_type_enabled(v9, type);
  if (!v14)
  {
    if (!v22)
      goto LABEL_112;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v11 = "%{public}s called with null callbacks, no backtrace";
    goto LABEL_111;
  }
  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_protocol_plugin_retry_set_callbacks";
    v27 = 2082;
    v28 = v14;
    v16 = "%{public}s called with null callbacks, dumping backtrace:%{public}s";
    goto LABEL_76;
  }
LABEL_77:
  free(v14);
  if (v8)
LABEL_113:
    free(v8);
}

uint64_t nw_protocol_plugin_retry_connect(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v4;
  void *v6;
  nw_protocol_callbacks *callbacks;
  void *v8;
  nw_protocol_callbacks *v9;
  nw_protocol_callbacks *v10;
  void (*notify)(nw_protocol *, nw_protocol *, uint64_t, char *, uint64_t);
  uint64_t (**v12)(_QWORD);
  char v13;
  char v14;
  nw_protocol *output_handler;
  void *v16;
  nw_protocol_callbacks *v17;
  void *v18;
  nw_protocol_callbacks *v19;
  nw_protocol_callbacks *v20;
  uint64_t (*connect)(nw_protocol *, nw_protocol *);
  uint64_t v22;
  nw_protocol_callbacks *v23;
  nw_protocol_callbacks *v24;
  void (**v25)(_QWORD);
  const void *v26;
  nw_protocol_callbacks *v28;
  nw_protocol_callbacks *v29;
  void (**v30)(_QWORD);
  const void *v31;
  nw_protocol_callbacks *v32;
  nw_protocol_callbacks *v33;
  void (**v34)(_QWORD);
  const void *v35;
  nw_protocol_callbacks *v36;
  nw_protocol_callbacks *v37;
  void (**v38)(_QWORD);
  const void *v39;
  nw_protocol_identifier *identifier;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  nw_protocol_identifier *v44;
  const char *v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  NSObject *v50;
  const char *name;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  const char *v56;
  char *v57;
  _BOOL4 v58;
  nw_protocol_identifier *v59;
  char *backtrace_string;
  _BOOL4 v61;
  const char *v62;
  _BOOL4 v63;
  _BOOL4 v64;
  _BOOL4 v65;
  char *v66;
  _BOOL4 v67;
  const char *v68;
  _BOOL4 v69;
  nw_protocol_identifier *v70;
  const char *v71;
  nw_protocol_identifier *v72;
  const char *v73;
  char v74;
  char v75;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v78;
  __int16 v79;
  nw_protocol *v80;
  __int16 v81;
  nw_protocol *v82;
  __int16 v83;
  char *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_protocol_plugin_retry_connect";
    v46 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v46, &type, &v75))
      goto LABEL_188;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v75)
      {
        v47 = __nwlog_obj();
        v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          v78 = "nw_protocol_plugin_retry_connect";
          v49 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_187;
        }
        goto LABEL_188;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v47 = __nwlog_obj();
      v48 = type;
      v61 = os_log_type_enabled(v47, type);
      if (!backtrace_string)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136446210;
          v78 = "nw_protocol_plugin_retry_connect";
          v49 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_187;
        }
        goto LABEL_188;
      }
      if (!v61)
        goto LABEL_142;
      *(_DWORD *)buf = 136446466;
      v78 = "nw_protocol_plugin_retry_connect";
      v79 = 2082;
      v80 = (nw_protocol *)backtrace_string;
      v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_141;
    }
    v47 = __nwlog_obj();
    v48 = type;
    if (!os_log_type_enabled(v47, type))
      goto LABEL_188;
    *(_DWORD *)buf = 136446210;
    v78 = "nw_protocol_plugin_retry_connect";
    v49 = "%{public}s called with null protocol";
LABEL_187:
    _os_log_impl(&dword_182FBE000, v47, v48, v49, buf, 0xCu);
    goto LABEL_188;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_protocol_plugin_retry_connect";
    v46 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v46, &type, &v75))
      goto LABEL_188;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v75)
      {
        v47 = __nwlog_obj();
        v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          v78 = "nw_protocol_plugin_retry_connect";
          v49 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_187;
        }
        goto LABEL_188;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v47 = __nwlog_obj();
      v48 = type;
      v63 = os_log_type_enabled(v47, type);
      if (!backtrace_string)
      {
        if (v63)
        {
          *(_DWORD *)buf = 136446210;
          v78 = "nw_protocol_plugin_retry_connect";
          v49 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_187;
        }
        goto LABEL_188;
      }
      if (!v63)
        goto LABEL_142;
      *(_DWORD *)buf = 136446466;
      v78 = "nw_protocol_plugin_retry_connect";
      v79 = 2082;
      v80 = (nw_protocol *)backtrace_string;
      v62 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_141;
    }
    v47 = __nwlog_obj();
    v48 = type;
    if (!os_log_type_enabled(v47, type))
      goto LABEL_188;
    *(_DWORD *)buf = 136446210;
    v78 = "nw_protocol_plugin_retry_connect";
    v49 = "%{public}s called with null protocol->handle";
    goto LABEL_187;
  }
  v4 = handle[11];
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_protocol_plugin_retry_connect";
    v46 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v46, &type, &v75))
      goto LABEL_188;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v75)
      {
        v47 = __nwlog_obj();
        v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          v78 = "nw_protocol_plugin_retry_connect";
          v49 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
          goto LABEL_187;
        }
        goto LABEL_188;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v47 = __nwlog_obj();
      v48 = type;
      v64 = os_log_type_enabled(v47, type);
      if (!backtrace_string)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          v78 = "nw_protocol_plugin_retry_connect";
          v49 = "%{public}s called with null retry_plugin, no backtrace";
          goto LABEL_187;
        }
        goto LABEL_188;
      }
      if (!v64)
        goto LABEL_142;
      *(_DWORD *)buf = 136446466;
      v78 = "nw_protocol_plugin_retry_connect";
      v79 = 2082;
      v80 = (nw_protocol *)backtrace_string;
      v62 = "%{public}s called with null retry_plugin, dumping backtrace:%{public}s";
      goto LABEL_141;
    }
    v47 = __nwlog_obj();
    v48 = type;
    if (!os_log_type_enabled(v47, type))
      goto LABEL_188;
    *(_DWORD *)buf = 136446210;
    v78 = "nw_protocol_plugin_retry_connect";
    v49 = "%{public}s called with null retry_plugin";
    goto LABEL_187;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v78 = "nw_protocol_plugin_retry_connect";
    v46 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v46, &type, &v75))
      goto LABEL_188;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (!os_log_type_enabled(v47, type))
        goto LABEL_188;
      *(_DWORD *)buf = 136446210;
      v78 = "nw_protocol_plugin_retry_connect";
      v49 = "%{public}s called with null other_protocol";
      goto LABEL_187;
    }
    if (!v75)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (os_log_type_enabled(v47, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_protocol_plugin_retry_connect";
        v49 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_187;
      }
      goto LABEL_188;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v47 = __nwlog_obj();
    v48 = type;
    v65 = os_log_type_enabled(v47, type);
    if (!backtrace_string)
    {
      if (v65)
      {
        *(_DWORD *)buf = 136446210;
        v78 = "nw_protocol_plugin_retry_connect";
        v49 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_187;
      }
      goto LABEL_188;
    }
    if (!v65)
      goto LABEL_142;
    *(_DWORD *)buf = 136446466;
    v78 = "nw_protocol_plugin_retry_connect";
    v79 = 2082;
    v80 = (nw_protocol *)backtrace_string;
    v62 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_141:
    _os_log_impl(&dword_182FBE000, v47, v48, v62, buf, 0x16u);
    goto LABEL_142;
  }
  if (gLogDatapath)
  {
    v50 = __nwlog_obj();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v78 = "nw_protocol_plugin_retry_connect";
      v79 = 2048;
      v80 = a1;
      _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_DEBUG, "%{public}s called %p", buf, 0x16u);
    }
  }
  if (!*(_QWORD *)(v4 + 160))
  {
    if ((*(unsigned int (**)(nw_protocol *, nw_protocol *))(v4 + 128))(a1, a2))
      goto LABEL_21;
    return 1;
  }
  v74 = 1;
  v6 = a2->handle;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    callbacks = a2[1].callbacks;
    if (callbacks)
      a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  v8 = a1->handle;
  if (v8 == &nw_protocol_ref_counted_handle)
  {
    v9 = a1[1].callbacks;
    if (v9)
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v9->add_input_handler + 1);
  }
  v10 = a2->callbacks;
  if (v10)
  {
    notify = (void (*)(nw_protocol *, nw_protocol *, uint64_t, char *, uint64_t))v10->notify;
    if (notify)
    {
      notify(a2, a1, 23, &v74, 1);
      goto LABEL_16;
    }
  }
  __nwlog_obj();
  identifier = a2->identifier;
  *(_DWORD *)buf = 136446722;
  v78 = "__nw_protocol_notify";
  if (!identifier)
    identifier = (nw_protocol_identifier *)"invalid";
  v79 = 2082;
  v80 = (nw_protocol *)identifier;
  v81 = 2048;
  v82 = a2;
  v41 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v75 = 0;
  if (__nwlog_fault(v41, &type, &v75))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v42 = __nwlog_obj();
      v43 = type;
      if (!os_log_type_enabled(v42, type))
        goto LABEL_164;
      v44 = a2->identifier;
      if (!v44)
        v44 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v78 = "__nw_protocol_notify";
      v79 = 2082;
      v80 = (nw_protocol *)v44;
      v81 = 2048;
      v82 = a2;
      v45 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
      goto LABEL_163;
    }
    if (!v75)
    {
      v42 = __nwlog_obj();
      v43 = type;
      if (!os_log_type_enabled(v42, type))
        goto LABEL_164;
      v70 = a2->identifier;
      if (!v70)
        v70 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v78 = "__nw_protocol_notify";
      v79 = 2082;
      v80 = (nw_protocol *)v70;
      v81 = 2048;
      v82 = a2;
      v45 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
      goto LABEL_163;
    }
    v57 = (char *)__nw_create_backtrace_string();
    v42 = __nwlog_obj();
    v43 = type;
    v58 = os_log_type_enabled(v42, type);
    if (v57)
    {
      if (v58)
      {
        v59 = a2->identifier;
        if (!v59)
          v59 = (nw_protocol_identifier *)"invalid";
        *(_DWORD *)buf = 136446978;
        v78 = "__nw_protocol_notify";
        v79 = 2082;
        v80 = (nw_protocol *)v59;
        v81 = 2048;
        v82 = a2;
        v83 = 2082;
        v84 = v57;
        _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v57);
      goto LABEL_164;
    }
    if (v58)
    {
      v72 = a2->identifier;
      if (!v72)
        v72 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v78 = "__nw_protocol_notify";
      v79 = 2082;
      v80 = (nw_protocol *)v72;
      v81 = 2048;
      v82 = a2;
      v45 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
LABEL_163:
      _os_log_impl(&dword_182FBE000, v42, v43, v45, buf, 0x20u);
    }
  }
LABEL_164:
  if (v41)
    free(v41);
LABEL_16:
  if (v8 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    v28 = a1[1].callbacks;
    if (v28)
    {
      v29 = (nw_protocol_callbacks *)((char *)v28 - 1);
      a1[1].callbacks = v29;
      if (!v29)
      {
        v30 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v30)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v30[2](v30);
          _Block_release(v30);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v31 = *(const void **)a1[1].flow_id;
          if (v31)
            _Block_release(v31);
        }
        free(a1);
      }
    }
  }
  if (v6 == &nw_protocol_ref_counted_handle && a2->handle == &nw_protocol_ref_counted_handle)
  {
    v32 = a2[1].callbacks;
    if (v32)
    {
      v33 = (nw_protocol_callbacks *)((char *)v32 - 1);
      a2[1].callbacks = v33;
      if (!v33)
      {
        v34 = *(void (***)(_QWORD))a2[1].flow_id;
        if (v34)
        {
          *(_QWORD *)a2[1].flow_id = 0;
          v34[2](v34);
          _Block_release(v34);
        }
        if ((a2[1].flow_id[8] & 1) != 0)
        {
          v35 = *(const void **)a2[1].flow_id;
          if (v35)
            _Block_release(v35);
        }
        free(a2);
      }
    }
  }
  v12 = *(uint64_t (***)(_QWORD))(v4 + 160);
  v13 = *(_BYTE *)(v4 + 168);
  *(_QWORD *)(v4 + 160) = 0;
  *(_BYTE *)(v4 + 168) = v13 | 1;
  v14 = v12[2](v12);
  _Block_release(v12);
  if ((v14 & 1) == 0)
    return 1;
LABEL_21:
  output_handler = a1->output_handler;
  if (output_handler)
  {
    v16 = output_handler->handle;
    if (v16 == &nw_protocol_ref_counted_handle)
    {
      v17 = output_handler[1].callbacks;
      if (v17)
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v17->add_input_handler + 1);
    }
    v18 = a1->handle;
    if (v18 == &nw_protocol_ref_counted_handle)
    {
      v19 = a1[1].callbacks;
      if (v19)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v19->add_input_handler + 1);
    }
    v20 = output_handler->callbacks;
    if (v20)
    {
      connect = (uint64_t (*)(nw_protocol *, nw_protocol *))v20->connect;
      if (connect)
      {
        v22 = connect(output_handler, a1);
        if (v18 != &nw_protocol_ref_counted_handle)
        {
LABEL_32:
          if (v16 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
          {
            v23 = output_handler[1].callbacks;
            if (v23)
            {
              v24 = (nw_protocol_callbacks *)((char *)v23 - 1);
              output_handler[1].callbacks = v24;
              if (!v24)
              {
                v25 = *(void (***)(_QWORD))output_handler[1].flow_id;
                if (v25)
                {
                  *(_QWORD *)output_handler[1].flow_id = 0;
                  v25[2](v25);
                  _Block_release(v25);
                }
                if ((output_handler[1].flow_id[8] & 1) != 0)
                {
                  v26 = *(const void **)output_handler[1].flow_id;
                  if (v26)
                    _Block_release(v26);
                }
                free(output_handler);
              }
            }
          }
          return v22;
        }
LABEL_31:
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          v36 = a1[1].callbacks;
          if (v36)
          {
            v37 = (nw_protocol_callbacks *)((char *)v36 - 1);
            a1[1].callbacks = v37;
            if (!v37)
            {
              v38 = *(void (***)(_QWORD))a1[1].flow_id;
              if (v38)
              {
                *(_QWORD *)a1[1].flow_id = 0;
                v38[2](v38);
                _Block_release(v38);
              }
              if ((a1[1].flow_id[8] & 1) != 0)
              {
                v39 = *(const void **)a1[1].flow_id;
                if (v39)
                  _Block_release(v39);
              }
              free(a1);
            }
          }
        }
        goto LABEL_32;
      }
    }
    __nwlog_obj();
    name = output_handler->identifier->name;
    *(_DWORD *)buf = 136446722;
    v78 = "__nw_protocol_connect";
    if (!name)
      name = "invalid";
    v79 = 2082;
    v80 = (nw_protocol *)name;
    v81 = 2048;
    v82 = output_handler;
    v52 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (__nwlog_fault(v52, &type, &v75))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v53 = __nwlog_obj();
        v54 = type;
        if (!os_log_type_enabled(v53, type))
          goto LABEL_179;
        v55 = output_handler->identifier->name;
        if (!v55)
          v55 = "invalid";
        *(_DWORD *)buf = 136446722;
        v78 = "__nw_protocol_connect";
        v79 = 2082;
        v80 = (nw_protocol *)v55;
        v81 = 2048;
        v82 = output_handler;
        v56 = "%{public}s protocol %{public}s (%p) has invalid connect callback";
LABEL_178:
        _os_log_impl(&dword_182FBE000, v53, v54, v56, buf, 0x20u);
        goto LABEL_179;
      }
      if (!v75)
      {
        v53 = __nwlog_obj();
        v54 = type;
        if (!os_log_type_enabled(v53, type))
          goto LABEL_179;
        v71 = output_handler->identifier->name;
        if (!v71)
          v71 = "invalid";
        *(_DWORD *)buf = 136446722;
        v78 = "__nw_protocol_connect";
        v79 = 2082;
        v80 = (nw_protocol *)v71;
        v81 = 2048;
        v82 = output_handler;
        v56 = "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded";
        goto LABEL_178;
      }
      v66 = (char *)__nw_create_backtrace_string();
      v53 = __nwlog_obj();
      v54 = type;
      v67 = os_log_type_enabled(v53, type);
      if (!v66)
      {
        if (!v67)
          goto LABEL_179;
        v73 = output_handler->identifier->name;
        if (!v73)
          v73 = "invalid";
        *(_DWORD *)buf = 136446722;
        v78 = "__nw_protocol_connect";
        v79 = 2082;
        v80 = (nw_protocol *)v73;
        v81 = 2048;
        v82 = output_handler;
        v56 = "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace";
        goto LABEL_178;
      }
      if (v67)
      {
        v68 = output_handler->identifier->name;
        if (!v68)
          v68 = "invalid";
        *(_DWORD *)buf = 136446978;
        v78 = "__nw_protocol_connect";
        v79 = 2082;
        v80 = (nw_protocol *)v68;
        v81 = 2048;
        v82 = output_handler;
        v83 = 2082;
        v84 = v66;
        _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v66);
    }
LABEL_179:
    if (v52)
      free(v52);
    v22 = 0;
    if (v18 != &nw_protocol_ref_counted_handle)
      goto LABEL_32;
    goto LABEL_31;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v78 = "__nw_protocol_connect";
  v46 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v75 = 0;
  if (!__nwlog_fault(v46, &type, &v75))
    goto LABEL_188;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v75)
    {
      v47 = __nwlog_obj();
      v48 = type;
      if (os_log_type_enabled(v47, type))
      {
        *(_DWORD *)buf = 136446210;
        v78 = "__nw_protocol_connect";
        v49 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_187;
      }
      goto LABEL_188;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v47 = __nwlog_obj();
    v48 = type;
    v69 = os_log_type_enabled(v47, type);
    if (!backtrace_string)
    {
      if (v69)
      {
        *(_DWORD *)buf = 136446210;
        v78 = "__nw_protocol_connect";
        v49 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_187;
      }
      goto LABEL_188;
    }
    if (v69)
    {
      *(_DWORD *)buf = 136446466;
      v78 = "__nw_protocol_connect";
      v79 = 2082;
      v80 = (nw_protocol *)backtrace_string;
      v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_141;
    }
LABEL_142:
    free(backtrace_string);
    goto LABEL_188;
  }
  v47 = __nwlog_obj();
  v48 = type;
  if (os_log_type_enabled(v47, type))
  {
    *(_DWORD *)buf = 136446210;
    v78 = "__nw_protocol_connect";
    v49 = "%{public}s called with null protocol";
    goto LABEL_187;
  }
LABEL_188:
  if (v46)
    free(v46);
  return 0;
}

uint64_t nw_protocol_plugin_retry_get_parameters(nw_protocol *a1)
{
  _QWORD *handle;
  uint64_t v2;
  uint64_t v3;
  nw_protocol *default_input_handler;
  void *v5;
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v7;
  uint64_t (*get_parameters)(nw_protocol *);
  nw_protocol_callbacks *v10;
  nw_protocol_callbacks *v11;
  void (**v12)(_QWORD);
  const void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  const char *name;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  char *backtrace_string;
  _BOOL4 v25;
  const char *v26;
  _BOOL4 v27;
  _BOOL4 v28;
  char *v29;
  _BOOL4 v30;
  const char *v31;
  _BOOL4 v32;
  const char *v33;
  const char *v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  void *v40;
  __int16 v41;
  nw_protocol *v42;
  __int16 v43;
  char *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_plugin_retry_get_parameters";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v14, &type, &v35))
      goto LABEL_101;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_plugin_retry_get_parameters";
          v17 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_100;
        }
        goto LABEL_101;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v25 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_plugin_retry_get_parameters";
          v17 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_100;
        }
        goto LABEL_101;
      }
      if (!v25)
        goto LABEL_76;
      *(_DWORD *)buf = 136446466;
      v38 = "nw_protocol_plugin_retry_get_parameters";
      v39 = 2082;
      v40 = backtrace_string;
      v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }
    v15 = __nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type))
      goto LABEL_101;
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_plugin_retry_get_parameters";
    v17 = "%{public}s called with null protocol";
LABEL_100:
    _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
    goto LABEL_101;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_plugin_retry_get_parameters";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v14, &type, &v35))
      goto LABEL_101;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_plugin_retry_get_parameters";
          v17 = "%{public}s called with null protocol->handle, backtrace limit exceeded";
          goto LABEL_100;
        }
        goto LABEL_101;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v27 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_protocol_plugin_retry_get_parameters";
          v17 = "%{public}s called with null protocol->handle, no backtrace";
          goto LABEL_100;
        }
        goto LABEL_101;
      }
      if (!v27)
        goto LABEL_76;
      *(_DWORD *)buf = 136446466;
      v38 = "nw_protocol_plugin_retry_get_parameters";
      v39 = 2082;
      v40 = backtrace_string;
      v26 = "%{public}s called with null protocol->handle, dumping backtrace:%{public}s";
      goto LABEL_75;
    }
    v15 = __nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type))
      goto LABEL_101;
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_plugin_retry_get_parameters";
    v17 = "%{public}s called with null protocol->handle";
    goto LABEL_100;
  }
  v2 = handle[11];
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_protocol_plugin_retry_get_parameters";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v14, &type, &v35))
      goto LABEL_101;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_101;
      *(_DWORD *)buf = 136446210;
      v38 = "nw_protocol_plugin_retry_get_parameters";
      v17 = "%{public}s called with null retry_plugin";
      goto LABEL_100;
    }
    if (!v35)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_protocol_plugin_retry_get_parameters";
        v17 = "%{public}s called with null retry_plugin, backtrace limit exceeded";
        goto LABEL_100;
      }
      goto LABEL_101;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = type;
    v28 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "nw_protocol_plugin_retry_get_parameters";
        v17 = "%{public}s called with null retry_plugin, no backtrace";
        goto LABEL_100;
      }
      goto LABEL_101;
    }
    if (!v28)
      goto LABEL_76;
    *(_DWORD *)buf = 136446466;
    v38 = "nw_protocol_plugin_retry_get_parameters";
    v39 = 2082;
    v40 = backtrace_string;
    v26 = "%{public}s called with null retry_plugin, dumping backtrace:%{public}s";
LABEL_75:
    _os_log_impl(&dword_182FBE000, v15, v16, v26, buf, 0x16u);
    goto LABEL_76;
  }
  v3 = *(_QWORD *)(v2 + 48);
  if (v3)
    return v3;
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v38 = "__nw_protocol_get_parameters";
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v14, &type, &v35))
      goto LABEL_101;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "__nw_protocol_get_parameters";
        v17 = "%{public}s called with null protocol";
        goto LABEL_100;
      }
LABEL_101:
      if (v14)
        free(v14);
      return 0;
    }
    if (!v35)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v38 = "__nw_protocol_get_parameters";
        v17 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_100;
      }
      goto LABEL_101;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = type;
    v32 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v38 = "__nw_protocol_get_parameters";
        v17 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_100;
      }
      goto LABEL_101;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v38 = "__nw_protocol_get_parameters";
      v39 = 2082;
      v40 = backtrace_string;
      v26 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }
LABEL_76:
    free(backtrace_string);
    goto LABEL_101;
  }
  v5 = default_input_handler->handle;
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    callbacks = default_input_handler[1].callbacks;
    if (callbacks)
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  v7 = default_input_handler->callbacks;
  if (v7)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v7->get_parameters;
    if (get_parameters)
    {
      v3 = get_parameters(default_input_handler);
      if (v5 != &nw_protocol_ref_counted_handle)
        return v3;
      goto LABEL_12;
    }
  }
  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  v38 = "__nw_protocol_get_parameters";
  if (!name)
    name = "invalid";
  v39 = 2082;
  v40 = (void *)name;
  v41 = 2048;
  v42 = default_input_handler;
  v19 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v35 = 0;
  if (!__nwlog_fault(v19, &type, &v35))
    goto LABEL_92;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_92;
    v22 = default_input_handler->identifier->name;
    if (!v22)
      v22 = "invalid";
    *(_DWORD *)buf = 136446722;
    v38 = "__nw_protocol_get_parameters";
    v39 = 2082;
    v40 = (void *)v22;
    v41 = 2048;
    v42 = default_input_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_91:
    _os_log_impl(&dword_182FBE000, v20, v21, v23, buf, 0x20u);
    goto LABEL_92;
  }
  if (!v35)
  {
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_92;
    v33 = default_input_handler->identifier->name;
    if (!v33)
      v33 = "invalid";
    *(_DWORD *)buf = 136446722;
    v38 = "__nw_protocol_get_parameters";
    v39 = 2082;
    v40 = (void *)v33;
    v41 = 2048;
    v42 = default_input_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_91;
  }
  v29 = (char *)__nw_create_backtrace_string();
  v20 = __nwlog_obj();
  v21 = type;
  v30 = os_log_type_enabled(v20, type);
  if (!v29)
  {
    if (!v30)
      goto LABEL_92;
    v34 = default_input_handler->identifier->name;
    if (!v34)
      v34 = "invalid";
    *(_DWORD *)buf = 136446722;
    v38 = "__nw_protocol_get_parameters";
    v39 = 2082;
    v40 = (void *)v34;
    v41 = 2048;
    v42 = default_input_handler;
    v23 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_91;
  }
  if (v30)
  {
    v31 = default_input_handler->identifier->name;
    if (!v31)
      v31 = "invalid";
    *(_DWORD *)buf = 136446978;
    v38 = "__nw_protocol_get_parameters";
    v39 = 2082;
    v40 = (void *)v31;
    v41 = 2048;
    v42 = default_input_handler;
    v43 = 2082;
    v44 = v29;
    _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v29);
LABEL_92:
  if (v19)
    free(v19);
  v3 = 0;
  if (v5 == &nw_protocol_ref_counted_handle)
  {
LABEL_12:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      v10 = default_input_handler[1].callbacks;
      if (v10)
      {
        v11 = (nw_protocol_callbacks *)((char *)v10 - 1);
        default_input_handler[1].callbacks = v11;
        if (!v11)
        {
          v12 = *(void (***)(_QWORD))default_input_handler[1].flow_id;
          if (v12)
          {
            *(_QWORD *)default_input_handler[1].flow_id = 0;
            v12[2](v12);
            _Block_release(v12);
          }
          if ((default_input_handler[1].flow_id[8] & 1) != 0)
          {
            v13 = *(const void **)default_input_handler[1].flow_id;
            if (v13)
              _Block_release(v13);
          }
          free(default_input_handler);
        }
      }
    }
  }
  return v3;
}

