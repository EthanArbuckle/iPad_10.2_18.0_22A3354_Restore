void sub_1830D7AE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_flow_get_path(nw_protocol *a1)
{
  id v1;
  void *v2;
  unsigned int *v3;
  uint64_t v4;
  id v5;
  NSObject *v6;
  const char *v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  void *v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = *((id *)a1->handle + 20);
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_flow_get_path";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v10, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_flow_get_path";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_flow_get_path";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_flow_get_path";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_flow_get_path";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_28:
    if (v10)
      free(v10);
    goto LABEL_10;
  }
  v3 = (unsigned int *)v1;
  v4 = v3[29];

  if ((_DWORD)v4 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      if (v4 > 5)
        v7 = "unknown-mode";
      else
        v7 = off_1E149FC18[v4];
      *(_DWORD *)buf = 136446722;
      v20 = "nw_flow_get_path";
      v21 = 2082;
      v22 = (void *)v7;
      v23 = 2082;
      v24 = "flow";
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }

LABEL_10:
    v5 = 0;
    goto LABEL_11;
  }
  v5 = nw_endpoint_flow_copy_path(v3);
LABEL_11:

  return v5;
}

void sub_1830D7E68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1830D9E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,void *a25,void *a26)
{
  void *v26;
  void *v27;

  _Unwind_Resume(a1);
}

uint64_t nw_path_allows_multipath(void *a1)
{
  void **v1;
  void **v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_path_allows_multipath";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v6, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_path_allows_multipath";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v6)
      free(v6);
    goto LABEL_8;
  }
  if (nw_parameters_get_multipath(v1[2])
    && !*((_DWORD *)v2 + 88)
    && *((_DWORD *)v2 + 66) != 4
    && (nw_path_uses_interface_subtype(v2, 5001) & 1) == 0
    && (nw_parameters_multipath_fallback_allowed(v2[2])
     || !nw_parameters_get_required_interface_index(v2[2])))
  {
    v3 = 1;
    goto LABEL_9;
  }
LABEL_8:
  v3 = 0;
LABEL_9:

  return v3;
}

void sub_1830DA2E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_path_is_multilayer_packet_logging_enabled(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  char *v4;
  __int16 v5;
  void *v6;
  char *v7;
  uint64_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_path_is_multilayer_packet_logging_enabled";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_path_is_multilayer_packet_logging_enabled";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v21 = "nw_path_is_multilayer_packet_logging_enabled";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_path_is_multilayer_packet_logging_enabled";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_path_is_multilayer_packet_logging_enabled";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_23:
    if (v10)
      free(v10);
    goto LABEL_25;
  }
  v3 = (void *)v1[12];
  if (v3)
  {
    v4 = v3;
    v5 = *(_WORD *)(v4 + 85);

    if ((v5 & 0x40) != 0)
    {
      v8 = 1;
      goto LABEL_26;
    }
  }
  v6 = (void *)v2[13];
  if (!v6)
  {
LABEL_25:
    v8 = 0;
    goto LABEL_26;
  }
  v7 = v6;
  v8 = (*(unsigned __int16 *)(v7 + 85) >> 6) & 1;

LABEL_26:
  return v8;
}

BOOL nw_path_is_flow_divert(void *a1)
{
  _DWORD *v1;
  _BOOL8 v2;

  v1 = a1;
  if (v1)
  {
    if (v1[88])
      v2 = 1;
    else
      v2 = v1[66] == 4;
  }
  else
  {
    v2 = 0;
  }

  return v2;
}

BOOL nw_endpoint_flow_expected_to_join(NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2)
{
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_flow *v4;
  NWConcrete_nw_endpoint_handler *v5;
  NWConcrete_nw_endpoint_handler *v6;
  OS_nw_parameters *v7;
  nw_endpoint_t v8;
  NSObject *v9;
  OS_nw_parameters *v10;
  void *v11;
  _BOOL8 v12;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  os_log_type_t v29;
  _QWORD aBlock[4];
  NSObject *v31;
  NWConcrete_nw_endpoint_handler *v32;
  OS_nw_parameters *v33;
  NWConcrete_nw_endpoint_flow *v34;
  _BYTE *v35;
  _QWORD *v36;
  os_log_type_t *v37;
  _QWORD v38[3];
  char v39;
  os_log_type_t type[8];
  os_log_type_t *v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE buf[24];
  uint64_t (*v45)(uint64_t, uint64_t);
  void (*v46)(uint64_t);
  NSObject *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v4)
  {
    v5 = v3;
    v6 = v5;
    if (v5)
    {
      v7 = v5->parameters;
LABEL_4:

      *(_QWORD *)type = 0;
      v41 = type;
      v42 = 0x2020000000;
      v43 = 0;
      v38[0] = 0;
      v38[1] = v38;
      v38[2] = 0x2020000000;
      v39 = 0;
      v8 = nw_endpoint_handler_copy_endpoint(v6);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v45 = __Block_byref_object_copy__79983;
      v46 = __Block_byref_object_dispose__79984;
      v47 = v8;
      aBlock[0] = MEMORY[0x1E0C809B0];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZL33nw_endpoint_flow_expected_to_joinP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flow_block_invoke;
      aBlock[3] = &unk_1E14AB618;
      v35 = buf;
      v9 = v47;
      v31 = v9;
      v32 = v6;
      v36 = v38;
      v10 = v7;
      v33 = v10;
      v34 = v4;
      v37 = type;
      v11 = _Block_copy(aBlock);
      nw_parameters_internal_iterate_protocol_stack(v10, 5, 0, v11);
      if (*((_QWORD *)v41 + 3))
      {
        v12 = 1;
      }
      else
      {
        nw_parameters_internal_iterate_protocol_stack(v10, 4, 0, v11);
        v12 = *((_QWORD *)v41 + 3) != 0;
      }

      _Block_object_dispose(buf, 8);
      _Block_object_dispose(v38, 8);
      _Block_object_dispose(type, 8);

      goto LABEL_8;
    }
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_parameters";
    v19 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v38[0]) = 0;
    if (__nwlog_fault(v19, type, v38))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_parameters";
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (LOBYTE(v38[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v26 = type[0];
        v27 = os_log_type_enabled(v20, type[0]);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_parameters";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v20, v26, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_parameters";
          _os_log_impl(&dword_182FBE000, v20, v26, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v29 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_parameters";
          _os_log_impl(&dword_182FBE000, v20, v29, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_44:
    if (v19)
      free(v19);
    v7 = 0;
    goto LABEL_4;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_endpoint_flow_expected_to_join";
  v15 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v38[0]) = 0;
  if (__nwlog_fault(v15, type, v38))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_expected_to_join";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null flow", buf, 0xCu);
      }
    }
    else if (LOBYTE(v38[0]))
    {
      v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v23 = type[0];
      v24 = os_log_type_enabled(v16, type[0]);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_expected_to_join";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v22;
          _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        goto LABEL_38;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_expected_to_join";
        _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s called with null flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v28 = type[0];
      if (os_log_type_enabled(v16, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_expected_to_join";
        _os_log_impl(&dword_182FBE000, v16, v28, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_38:
  if (v15)
    free(v15);
  v12 = 0;
LABEL_8:

  return v12;
}

void sub_1830DAC4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  void *v29;
  void *v30;
  void *v31;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);

  _Unwind_Resume(a1);
}

void nw_path_libinfo_path_check(const char *a1, const char *a2)
{
  int v4;
  const char *v5;
  _BOOL8 host_with_numeric_port;
  NSObject *legacy_tcp_socket;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  NWConcrete_nw_path_evaluator *v9;
  _DWORD *v10;
  NSObject *v11;
  const char *logging_description;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  _BYTE v28[14];
  __int16 v29;
  const char *v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if ((sNWDispatchAllowedNow & 1) != 0)
    {
      v4 = 1;
      if (!a1)
        return;
    }
    else if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
           || (getpid(), sandbox_check() == 1))
    {
      v4 = 1;
      sNWDispatchAllowedNow = 1;
      if (!a1)
        return;
    }
    else
    {
      v4 = sNWDispatchAllowedNow;
      if (!a1)
        return;
    }
    if (v4)
    {
      if (a2)
        v5 = a2;
      else
        v5 = "0";
      *(_WORD *)buf = 0;
      if ((nw_utilities_port_for_string(v5, buf) & 1) != 0)
      {
        host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(a1, bswap32(*(unsigned __int16 *)buf) >> 16);
        if (host_with_numeric_port)
        {
          legacy_tcp_socket = nw_parameters_create_legacy_tcp_socket(&__block_literal_global_86);
          evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint((void *)host_with_numeric_port, legacy_tcp_socket);
          v9 = evaluator_for_endpoint;
          if (evaluator_for_endpoint)
          {
            v10 = nw_parameters_copy_context(*((void **)evaluator_for_endpoint + 1));
            nw_path_watch_necp_changes(v10);
            os_unfair_lock_lock((os_unfair_lock_t)v9 + 24);
            if ((*((_BYTE *)v9 + 107) & 0x40) != 0 && (!v10 || v10[31] != 4))
            {
              if (__nwlog_path_log::onceToken[0] != -1)
                dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44205);
              v11 = (id)gpathLogObj;
              if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
              {
                logging_description = nw_endpoint_get_logging_description(*((void **)v9 + 2));
                v13 = *((_QWORD *)v9 + 1);
                v14 = *((_QWORD *)v9 + 6);
                *(_DWORD *)buf = 136447490;
                v26 = "nw_path_libinfo_path_check";
                v27 = 1042;
                *(_DWORD *)v28 = 16;
                *(_WORD *)&v28[4] = 2098;
                *(_QWORD *)&v28[6] = (char *)v9 + 80;
                v29 = 2082;
                v30 = logging_description;
                v31 = 2112;
                v32 = v13;
                v33 = 2112;
                v34 = v14;
                _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public,uuid_t}.16P %{public}s %@]\n\tlibinfo check path: %@", buf, 0x3Au);
              }

            }
            os_unfair_lock_unlock((os_unfair_lock_t)v9 + 24);

          }
          goto LABEL_37;
        }
      }
      __nwlog_obj();
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v26 = "nw_path_libinfo_path_check";
      v16 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v23 = 0;
      if (__nwlog_fault(v16, &type, &v23))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            v26 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null endpoint", buf, 0xCu);
          }
        }
        else if (v23)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          v20 = type;
          v21 = os_log_type_enabled(v17, type);
          if (backtrace_string)
          {
            if (v21)
            {
              *(_DWORD *)buf = 136446466;
              v26 = "nw_path_libinfo_path_check";
              v27 = 2082;
              *(_QWORD *)v28 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v16)
              goto LABEL_36;
            goto LABEL_35;
          }
          if (v21)
          {
            *(_DWORD *)buf = 136446210;
            v26 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v17 = objc_claimAutoreleasedReturnValue();
          v22 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            v26 = "nw_path_libinfo_path_check";
            _os_log_impl(&dword_182FBE000, v17, v22, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v16)
      {
LABEL_36:
        host_with_numeric_port = 0;
LABEL_37:

        return;
      }
LABEL_35:
      free(v16);
      goto LABEL_36;
    }
  }
}

void sub_1830DB154(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_host(const char *hostname, const char *port)
{
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  void *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!hostname)
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_endpoint_create_host";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_host";
        v8 = "%{public}s called with null hostname";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
LABEL_32:

LABEL_33:
      if (v5)
        free(v5);
      return 0;
    }
    if (!v14)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_host";
        v8 = "%{public}s called with null hostname, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v7 = type;
    v11 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_host";
        v8 = "%{public}s called with null hostname, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_endpoint_create_host";
      v18 = 2082;
      v19 = backtrace_string;
      v12 = "%{public}s called with null hostname, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v6, v7, v12, buf, 0x16u);
    }
LABEL_22:

    free(backtrace_string);
    goto LABEL_33;
  }
  if (!port)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_endpoint_create_host";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_host";
        v8 = "%{public}s called with null port_string";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v14)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_host";
        v8 = "%{public}s called with null port_string, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v7 = type;
    v13 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_host";
        v8 = "%{public}s called with null port_string, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_endpoint_create_host";
      v18 = 2082;
      v19 = backtrace_string;
      v12 = "%{public}s called with null port_string, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  *(_WORD *)buf = 0;
  if (nw_utilities_port_for_string(port, buf))
    return (nw_endpoint_t)nw_endpoint_create_host_with_numeric_port(hostname, bswap32(*(unsigned __int16 *)buf) >> 16);
  return 0;
}

void nw_parameters_set_url(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  nw_endpoint_t url;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2 && *a2)
    {
      url = nw_endpoint_create_url(a2);
      v6 = (void *)v4[25];
      v4[25] = url;
    }
    else
    {
      v6 = (void *)v3[25];
      v3[25] = 0;
    }

    goto LABEL_7;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_parameters_set_url";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_parameters_set_url";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_url";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v8)
    free(v8);
LABEL_7:

}

void sub_1830DB864(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_get_sanitized_url_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 32);
  if (!*(_QWORD *)(v1 + 280))
  {
    v2 = result;
    result = nw_utilities_copy_sanitized_url(*(CFURLRef *)(v1 + 232));
    *(_QWORD *)(*(_QWORD *)(v2 + 32) + 280) = result;
  }
  return result;
}

uint64_t nw_utilities_copy_sanitized_url(CFURLRef url)
{
  CFIndex v2;
  uint64_t v3;
  CFIndex v4;
  CFRange v5;
  CFRange v6;
  CFIndex v7;
  void *v9;
  NSObject *v10;
  os_log_type_t location;
  const char *v12;
  NSObject *v13;
  NSObject *v14;
  char *backtrace_string;
  _BOOL4 v16;
  CFRange rangeIncludingSeparators;
  char v18;
  _BYTE v19[22];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!url)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v19 = 136446210;
    *(_QWORD *)&v19[4] = "nw_utilities_copy_sanitized_url";
    v3 = _os_log_send_and_compose_impl();

    LOBYTE(rangeIncludingSeparators.location) = 16;
    v18 = 0;
    if (!__nwlog_fault((const char *)v3, &rangeIncludingSeparators, &v18))
      goto LABEL_38;
    if (LOBYTE(rangeIncludingSeparators.location) == 17)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      location = rangeIncludingSeparators.location;
      if (os_log_type_enabled(v10, rangeIncludingSeparators.location))
      {
        *(_DWORD *)v19 = 136446210;
        *(_QWORD *)&v19[4] = "nw_utilities_copy_sanitized_url";
        v12 = "%{public}s called with null absolute_url";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v10, location, v12, v19, 0xCu);
      }
    }
    else
    {
      if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        location = rangeIncludingSeparators.location;
        v16 = os_log_type_enabled(v10, rangeIncludingSeparators.location);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)v19 = 136446466;
            *(_QWORD *)&v19[4] = "nw_utilities_copy_sanitized_url";
            *(_WORD *)&v19[12] = 2082;
            *(_QWORD *)&v19[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, location, "%{public}s called with null absolute_url, dumping backtrace:%{public}s", v19, 0x16u);
          }

          free(backtrace_string);
          if (!v3)
            return 0;
          goto LABEL_12;
        }
        if (!v16)
          goto LABEL_37;
        *(_DWORD *)v19 = 136446210;
        *(_QWORD *)&v19[4] = "nw_utilities_copy_sanitized_url";
        v12 = "%{public}s called with null absolute_url, no backtrace";
        goto LABEL_36;
      }
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      location = rangeIncludingSeparators.location;
      if (os_log_type_enabled(v10, rangeIncludingSeparators.location))
      {
        *(_DWORD *)v19 = 136446210;
        *(_QWORD *)&v19[4] = "nw_utilities_copy_sanitized_url";
        v12 = "%{public}s called with null absolute_url, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
LABEL_37:

LABEL_38:
    if (!v3)
      return 0;
    goto LABEL_12;
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v19 = 136446467;
      *(_QWORD *)&v19[4] = "nw_utilities_copy_sanitized_url";
      *(_WORD *)&v19[12] = 2117;
      *(_QWORD *)&v19[14] = url;
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s Sanitizing URL: %{sensitive}@", v19, 0x16u);
    }

  }
  v2 = CFURLGetBytes(url, 0, 0);
  v3 = nw_calloc_type<unsigned char>(v2 + 1);
  CFURLGetBytes(url, (UInt8 *)v3, v2);
  CFURLGetByteRangeForComponent(url, kCFURLComponentQuery, &rangeIncludingSeparators);
  v4 = rangeIncludingSeparators.location;
  if (rangeIncludingSeparators.location != -1
    || (CFURLGetByteRangeForComponent(url, kCFURLComponentFragment, (CFRange *)v19),
        v4 = *(_QWORD *)v19,
        *(_QWORD *)v19 != -1))
  {
    *(_BYTE *)(v3 + v4) = 0;
  }
  v5 = CFURLGetByteRangeForComponent(url, kCFURLComponentUser, 0);
  v6 = CFURLGetByteRangeForComponent(url, kCFURLComponentPassword, 0);
  if (v5.location != -1)
  {
    v7 = v5.location + v5.length;
    if (v6.location != -1)
      v7 = v6.location + v6.length;
    memmove((void *)(v3 + v5.location), (const void *)(v3 + v7 + 1), v2 - v7);
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v19 = 136446466;
      *(_QWORD *)&v19[4] = "nw_utilities_copy_sanitized_url";
      *(_WORD *)&v19[12] = 2082;
      *(_QWORD *)&v19[14] = v3;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s Sanitized URL: %{public}s", v19, 0x16u);
    }

    if (!*(_BYTE *)v3)
      goto LABEL_12;
  }
  else if (!*(_BYTE *)v3)
  {
LABEL_12:
    free((void *)v3);
    return 0;
  }
  return v3;
}

nw_endpoint_t nw_endpoint_create_url(const char *url)
{
  CFIndex v2;
  const __CFURL *v3;
  _BOOL8 v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (url)
  {
    v2 = strlen(url);
    v3 = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)url, v2, 0x600u, 0, 0);
    v4 = -[NWConcrete_nw_url_endpoint initWithURL:]([NWConcrete_nw_url_endpoint alloc], v3);
    if (v3)
      CFRelease(v3);
    return (nw_endpoint_t)v4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_endpoint_create_url";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null url", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_endpoint_create_url";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null url, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null url, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_endpoint_create_url";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null url, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  return 0;
}

void sub_1830DBF94(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_1830DBFA0(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (!v1)
    _Unwind_Resume(exception_object);
  CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void sub_1830DC9A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_utilities_port_for_string(const char *a1, _WORD *a2)
{
  int v4;
  const char *v5;
  NSObject *v6;
  const char *v7;
  uint64_t result;
  uint64_t v9;
  addrinfo *v10;
  sockaddr *ai_addr;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  void *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  char v29;
  os_log_type_t type;
  addrinfo *v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  void *v37;
  addrinfo v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
    {
      if (!strcasecmp(a1, "http"))
      {
        v9 = 0;
      }
      else if (!strcasecmp(a1, "https"))
      {
        v9 = 1;
      }
      else if (!strcasecmp(a1, "ws"))
      {
        v9 = 2;
      }
      else
      {
        if (strcasecmp(a1, "wss"))
        {
          memset(&v38.ai_socktype, 0, 40);
          *(_QWORD *)&v38.ai_flags = 0x1E00000600;
          v38.ai_socktype = 1;
          v31 = 0;
          v4 = getaddrinfo(0, a1, &v38, &v31);
          if (v4)
          {
            v5 = gai_strerror(v4);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v6 = (id)gLogObj;
            if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            {
              v7 = "Unknown error";
              *(_DWORD *)buf = 136446722;
              v33 = "nw_utilities_port_for_string";
              v34 = 2082;
              if (v5)
                v7 = v5;
              v35 = a1;
              v36 = 2082;
              v37 = (void *)v7;
              _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s Unable to convert \"%{public}s\" to port: %{public}s", buf, 0x20u);
            }

            return 0;
          }
          v10 = v31;
          if (v31)
          {
            ai_addr = v31->ai_addr;
            if (ai_addr)
            {
              if (ai_addr->sa_family == 30)
              {
                *a2 = *(_WORD *)ai_addr->sa_data;
                freeaddrinfo(v10);
                return 1;
              }
            }
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          v33 = "nw_utilities_port_for_string";
          v34 = 2082;
          v35 = a1;
          v13 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v29 = 0;
          if (!__nwlog_fault(v13, &type, &v29))
            goto LABEL_39;
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = (id)gLogObj;
            v15 = type;
            if (os_log_type_enabled(v14, type))
            {
              *(_DWORD *)buf = 136446466;
              v33 = "nw_utilities_port_for_string";
              v34 = 2082;
              v35 = a1;
              v16 = "%{public}s getaddrinfo(NULL, %{public}s, ...) failed";
LABEL_37:
              _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0x16u);
            }
          }
          else if (v29)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v14 = objc_claimAutoreleasedReturnValue();
            v15 = type;
            v18 = os_log_type_enabled(v14, type);
            if (backtrace_string)
            {
              if (v18)
              {
                *(_DWORD *)buf = 136446722;
                v33 = "nw_utilities_port_for_string";
                v34 = 2082;
                v35 = a1;
                v36 = 2082;
                v37 = backtrace_string;
                _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s getaddrinfo(NULL, %{public}s, ...) failed, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(backtrace_string);
              goto LABEL_39;
            }
            if (v18)
            {
              *(_DWORD *)buf = 136446466;
              v33 = "nw_utilities_port_for_string";
              v34 = 2082;
              v35 = a1;
              v16 = "%{public}s getaddrinfo(NULL, %{public}s, ...) failed, no backtrace";
              goto LABEL_37;
            }
          }
          else
          {
            __nwlog_obj();
            v14 = objc_claimAutoreleasedReturnValue();
            v15 = type;
            if (os_log_type_enabled(v14, type))
            {
              *(_DWORD *)buf = 136446466;
              v33 = "nw_utilities_port_for_string";
              v34 = 2082;
              v35 = a1;
              v16 = "%{public}s getaddrinfo(NULL, %{public}s, ...) failed, backtrace limit exceeded";
              goto LABEL_37;
            }
          }

LABEL_39:
          if (v13)
            free(v13);
          result = (uint64_t)v31;
          if (v31)
          {
            freeaddrinfo(v31);
            return 0;
          }
          return result;
        }
        v9 = 3;
      }
      *a2 = (&kWellKnownSchemes)[2 * v9 + 1];
      return 1;
    }
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    v38.ai_flags = 136446210;
    *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
    v20 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v31) = 0;
    if (__nwlog_fault(v20, buf, &v31))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null out_port";
          goto LABEL_69;
        }
        goto LABEL_70;
      }
      if (!(_BYTE)v31)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null out_port, backtrace limit exceeded";
          goto LABEL_69;
        }
        goto LABEL_70;
      }
      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = buf[0];
      v28 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (!v25)
      {
        if (v28)
        {
          v38.ai_flags = 136446210;
          *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null out_port, no backtrace";
          goto LABEL_69;
        }
        goto LABEL_70;
      }
      if (!v28)
        goto LABEL_60;
      v38.ai_flags = 136446466;
      *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
      LOWORD(v38.ai_protocol) = 2082;
      *(_QWORD *)((char *)&v38.ai_protocol + 2) = v25;
      v27 = "%{public}s called with null out_port, dumping backtrace:%{public}s";
LABEL_59:
      _os_log_impl(&dword_182FBE000, v21, v22, v27, (uint8_t *)&v38, 0x16u);
LABEL_60:

      free(v25);
    }
  }
  else
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v38.ai_flags = 136446210;
    *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
    v20 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v31) = 0;
    if (__nwlog_fault(v20, buf, &v31))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null string";
LABEL_69:
          _os_log_impl(&dword_182FBE000, v21, v22, v23, (uint8_t *)&v38, 0xCu);
        }
LABEL_70:

        goto LABEL_71;
      }
      if (!(_BYTE)v31)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          v38.ai_flags = 136446210;
          *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null string, backtrace limit exceeded";
          goto LABEL_69;
        }
        goto LABEL_70;
      }
      v25 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = buf[0];
      v26 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (!v25)
      {
        if (v26)
        {
          v38.ai_flags = 136446210;
          *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
          v23 = "%{public}s called with null string, no backtrace";
          goto LABEL_69;
        }
        goto LABEL_70;
      }
      if (!v26)
        goto LABEL_60;
      v38.ai_flags = 136446466;
      *(_QWORD *)&v38.ai_family = "nw_utilities_port_for_string";
      LOWORD(v38.ai_protocol) = 2082;
      *(_QWORD *)((char *)&v38.ai_protocol + 2) = v25;
      v27 = "%{public}s called with null string, dumping backtrace:%{public}s";
      goto LABEL_59;
    }
  }
LABEL_71:
  if (v20)
    free(v20);
  return 0;
}

BOOL nw_calloc_type<unsigned char>(size_t count)
{
  void *v2;
  _BOOL8 result;
  NSObject *v4;
  void *v5;
  NSObject *v6;
  void *v7;

  if (!count)
  {
    v4 = __nwlog_obj();
    os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    v5 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v5);
    if (result)
      goto LABEL_8;
    free(v5);
  }
  v2 = malloc_type_calloc(count, 1uLL, 0xEAFB8F1AuLL);
  if (v2)
    return (BOOL)v2;
  v6 = __nwlog_obj();
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  v7 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    return (BOOL)v2;
  }
LABEL_8:
  __break(1u);
  return result;
}

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = endpoint;
  v4 = parameters;
  v5 = v4;
  if (v3)
  {
    if (v4)
    {
      v6 = nw_connection_create_with_id(v3, v4, 0);
      goto LABEL_4;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_connection_create";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_connection_create";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_connection_create";
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_connection_create";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_connection_create";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_connection_create";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_connection_create";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v21)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_connection_create";
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_connection_create";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_connection_create";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_4:

  return v6;
}

void sub_1830DD800(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_connection_create_with_id(void *a1, void *a2, int a3)
{
  id v5;
  id v6;
  id v7;
  _BOOL8 v8;
  NWConcrete_nw_connection *v9;
  id v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t (*v16)(uint64_t, uint64_t);
  uint64_t v17;
  NSObject *v18;
  int v19;
  id *inner;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  const char *logging_description;
  id v26;
  id v27;
  id v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  id v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  char *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  NSObject *v39;
  int v40;
  char *v41;
  os_log_type_t v42;
  _BOOL4 v43;
  os_log_type_t v44;
  os_log_type_t v45;
  void *v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  void *v51;
  os_log_type_t v52;
  char *backtrace_string;
  os_log_type_t v54;
  _BOOL4 v55;
  char *v56;
  os_log_type_t v57;
  _BOOL4 v58;
  os_log_type_t v59;
  os_log_type_t v60;
  _QWORD v61[4];
  id v62;
  char v63;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v66;
  __int16 v67;
  _WORD v68[17];

  *(_QWORD *)&v68[13] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  nw_allow_use_of_dispatch_internal();
  if (!v5)
  {
    __nwlog_obj();
    v47 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_connection_create_with_id";
    v48 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (!__nwlog_fault(v48, &type, &v63))
      goto LABEL_110;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v49 = objc_claimAutoreleasedReturnValue();
      v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v49 = objc_claimAutoreleasedReturnValue();
      v54 = type;
      v55 = os_log_type_enabled(v49, type);
      if (backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_connection_create_with_id";
          v67 = 2082;
          *(_QWORD *)v68 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v49, v54, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v48)
          goto LABEL_112;
        goto LABEL_111;
      }
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v49, v54, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v49 = objc_claimAutoreleasedReturnValue();
      v59 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v49, v59, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_109;
  }
  if (!v6)
  {
    __nwlog_obj();
    v51 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v66 = "nw_connection_create_with_id";
    v48 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (!__nwlog_fault(v48, &type, &v63))
      goto LABEL_110;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v49 = objc_claimAutoreleasedReturnValue();
      v52 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v49, v52, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v63)
    {
      v56 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v49 = objc_claimAutoreleasedReturnValue();
      v57 = type;
      v58 = os_log_type_enabled(v49, type);
      if (v56)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_connection_create_with_id";
          v67 = 2082;
          *(_QWORD *)v68 = v56;
          _os_log_impl(&dword_182FBE000, v49, v57, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v56);
LABEL_110:
        if (!v48)
        {
LABEL_112:
          v27 = 0;
          goto LABEL_76;
        }
LABEL_111:
        free(v48);
        goto LABEL_112;
      }
      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v49, v57, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v49 = objc_claimAutoreleasedReturnValue();
      v60 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v49, v60, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_109:

    goto LABEL_110;
  }
  v7 = v6;
  v8 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v7, 0, 0);

  if (v8)
  {
    v9 = [NWConcrete_nw_connection alloc];
    v10 = v5;
    v11 = (void *)objc_msgSend(v10, "copyEndpoint");
    nw_endpoint_copy_properties(v10, v11);

    v12 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]((void **)&v9->super.isa, v11, (void *)v8, a3);
    if (v12)
    {
      v13 = *(_QWORD *)(v12 + 8);
      v14 = *(_QWORD *)(v12 + 16);
      nw_allow_use_of_dispatch_internal();
      if (has_modifiers == 1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
        v15 = (_QWORD *)g_modifier_list;
        if (g_modifier_list)
        {
          while (1)
          {
            v16 = (uint64_t (*)(uint64_t, uint64_t))v15[2];
            if (v16)
            {
              if ((v16(v13, v14) & 1) != 0)
                break;
            }
            v15 = (_QWORD *)*v15;
            if (!v15)
              goto LABEL_7;
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
          v17 = *(_QWORD *)(v12 + 16);
          if (v17 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v17 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v18 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              v19 = *(_DWORD *)(v12 + 448);
              *(_DWORD *)buf = 136446466;
              v66 = "nw_connection_create_with_id";
              v67 = 1024;
              *(_DWORD *)v68 = v19;
              _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Connection parameters were modified", buf, 0x12u);
            }

          }
        }
        else
        {
LABEL_7:
          os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
        }
      }
      inner = nw_endpoint_handler_create_inner(*(void **)(v12 + 8), *(void **)(v12 + 16), nw_connection_endpoint_report_on_nw_queue, (void *)v12, 0, *(_DWORD *)(v12 + 448), 0);
      v21 = *(void **)(v12 + 144);
      *(_QWORD *)(v12 + 144) = inner;

      v22 = *(_QWORD *)(v12 + 16);
      if (*(_QWORD *)(v12 + 144))
      {
        if (v22 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v22 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v23 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            v24 = *(_DWORD *)(v12 + 448);
            logging_description = nw_endpoint_get_logging_description(v10);
            *(_DWORD *)buf = 136446722;
            v66 = "nw_connection_create_with_id";
            v67 = 1024;
            *(_DWORD *)v68 = v24;
            v68[2] = 2082;
            *(_QWORD *)&v68[3] = logging_description;
            _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_INFO, "%{public}s [C%u] create connection to %{public}s", buf, 0x1Cu);
          }

        }
        v61[0] = MEMORY[0x1E0C809B0];
        v61[1] = 3221225472;
        v61[2] = __nw_connection_create_with_id_block_invoke;
        v61[3] = &unk_1E149DA10;
        v26 = (id)v12;
        v62 = v26;
        nw_endpoint_enumerate_alternatives(v10, v61);
        v27 = v26;

        goto LABEL_74;
      }
      if (v22 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v22 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v39 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          v40 = *(_DWORD *)(v12 + 448);
          *(_DWORD *)buf = 136446466;
          v66 = "nw_connection_create_with_id";
          v67 = 1024;
          *(_DWORD *)v68 = v40;
          _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Failed to create parent endpoint handler", buf, 0x12u);
        }

      }
LABEL_73:
      v27 = 0;
LABEL_74:

      goto LABEL_75;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v32 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v66 = "nw_connection_create_with_id";
    v33 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v63 = 0;
    if (__nwlog_fault(v33, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v34 = (id)gLogObj;
        v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_connection_create_with_id";
          _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s [nw_connection initWithEndpoint:parameters:] failed", buf, 0xCu);
        }
      }
      else if (v63)
      {
        v41 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v34 = (id)gLogObj;
        v42 = type;
        v43 = os_log_type_enabled(v34, type);
        if (v41)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            v66 = "nw_connection_create_with_id";
            v67 = 2082;
            *(_QWORD *)v68 = v41;
            _os_log_impl(&dword_182FBE000, v34, v42, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v41);
          if (!v33)
            goto LABEL_73;
          goto LABEL_72;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_connection_create_with_id";
          _os_log_impl(&dword_182FBE000, v34, v42, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v34 = (id)gLogObj;
        v45 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          v66 = "nw_connection_create_with_id";
          _os_log_impl(&dword_182FBE000, v34, v45, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v33)
      goto LABEL_73;
LABEL_72:
    free(v33);
    goto LABEL_73;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v28 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v66 = "nw_connection_create_with_id";
  v29 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v63 = 0;
  if (__nwlog_fault(v29, &type, &v63))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (id)gLogObj;
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s nw_parameters_copy failed", buf, 0xCu);
      }
    }
    else if (v63)
    {
      v36 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (id)gLogObj;
      v37 = type;
      v38 = os_log_type_enabled(v30, type);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          v66 = "nw_connection_create_with_id";
          v67 = 2082;
          *(_QWORD *)v68 = v36;
          _os_log_impl(&dword_182FBE000, v30, v37, "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v36);
        if (!v29)
          goto LABEL_64;
        goto LABEL_63;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v30, v37, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (id)gLogObj;
      v44 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_182FBE000, v30, v44, "%{public}s nw_parameters_copy failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
  if (v29)
LABEL_63:
    free(v29);
LABEL_64:
  v27 = 0;
LABEL_75:

LABEL_76:
  return v27;
}

void sub_1830DE534(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

BOOL nw_endpoint_create_host_with_numeric_port(const char *a1, unsigned int a2)
{
  size_t v4;
  NSObject *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  NWConcrete_nw_host_endpoint *v10;
  void *address;
  char *v12;
  const char *v13;
  size_t v14;
  unint64_t v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  sockaddr *ai_addr;
  socklen_t ai_addrlen;
  unsigned int sa_len;
  int sa_family;
  BOOL v23;
  BOOL v24;
  id v25;
  char *v26;
  NSObject *v27;
  os_log_type_t receiver;
  os_log_type_t v29;
  const char *v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  _BOOL8 result;
  os_log_type_t v35;
  os_log_type_t v36;
  void *v37;
  os_log_type_t v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  void *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  NSObject *v46;
  void *v47;
  os_log_type_t v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  os_log_type_t v52;
  id v53;
  NSObject *v54;
  os_log_type_t v55;
  os_log_type_t v56;
  _BOOL4 v57;
  os_log_type_t v58;
  addrinfo *v59;
  char v60;
  os_log_type_t v61;
  objc_super v62;
  os_log_type_t type[4];
  const char *v64;
  __int16 v65;
  void *v66;
  __int16 v67;
  char *v68;
  addrinfo buf;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    buf.ai_flags = 136446210;
    *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
    v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62.receiver) = 0;
    if (!__nwlog_fault(v7, type, &v62))
      goto LABEL_60;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v38 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446210;
        *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_182FBE000, v8, v38, "%{public}s called with null hostname", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (LOBYTE(v62.receiver))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v40 = type[0];
      v41 = os_log_type_enabled(v8, type[0]);
      if (backtrace_string)
      {
        if (v41)
        {
          buf.ai_flags = 136446466;
          *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
          LOWORD(buf.ai_protocol) = 2082;
          *(_QWORD *)((char *)&buf.ai_protocol + 2) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v40, "%{public}s called with null hostname, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x16u);
        }

        free(backtrace_string);
LABEL_60:
        if (!v7)
          return 0;
LABEL_61:
        free(v7);
        return 0;
      }
      if (v41)
      {
        buf.ai_flags = 136446210;
        *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_182FBE000, v8, v40, "%{public}s called with null hostname, no backtrace", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v48 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446210;
        *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_182FBE000, v8, v48, "%{public}s called with null hostname, backtrace limit exceeded", (uint8_t *)&buf, 0xCu);
      }
    }
    goto LABEL_59;
  }
  v4 = strlen(a1);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    buf.ai_flags = 136446466;
    *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
    LOWORD(buf.ai_protocol) = 2082;
    *(_QWORD *)((char *)&buf.ai_protocol + 2) = "hostname";
    v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62.receiver) = 0;
    if (!__nwlog_fault(v7, type, &v62))
      goto LABEL_60;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446466;
        *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        LOWORD(buf.ai_protocol) = 2082;
        *(_QWORD *)((char *)&buf.ai_protocol + 2) = "hostname";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s invalid empty string %{public}s", (uint8_t *)&buf, 0x16u);
      }
    }
    else if (LOBYTE(v62.receiver))
    {
      v16 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v17 = type[0];
      v18 = os_log_type_enabled(v8, type[0]);
      if (v16)
      {
        if (v18)
        {
          buf.ai_flags = 136446722;
          *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
          LOWORD(buf.ai_protocol) = 2082;
          *(_QWORD *)((char *)&buf.ai_protocol + 2) = "hostname";
          *((_WORD *)&buf.ai_addrlen + 3) = 2082;
          buf.ai_canonname = v16;
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x20u);
        }

        goto LABEL_26;
      }
      if (v18)
      {
        buf.ai_flags = 136446466;
        *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        LOWORD(buf.ai_protocol) = 2082;
        *(_QWORD *)((char *)&buf.ai_protocol + 2) = "hostname";
        _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s invalid empty string %{public}s, no backtrace", (uint8_t *)&buf, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v29 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446466;
        *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        LOWORD(buf.ai_protocol) = 2082;
        *(_QWORD *)((char *)&buf.ai_protocol + 2) = "hostname";
        _os_log_impl(&dword_182FBE000, v8, v29, "%{public}s invalid empty string %{public}s, backtrace limit exceeded", (uint8_t *)&buf, 0x16u);
      }
    }
LABEL_59:

    goto LABEL_60;
  }
  if (v4 >= 0x400)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      buf.ai_flags = 136446722;
      *(_QWORD *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
      LOWORD(buf.ai_protocol) = 2082;
      *(_QWORD *)((char *)&buf.ai_protocol + 2) = "hostname";
      *((_WORD *)&buf.ai_addrlen + 3) = 1024;
      LODWORD(buf.ai_canonname) = 1024;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", (uint8_t *)&buf, 0x1Cu);
    }

    return 0;
  }
  memset(&buf, 0, sizeof(buf));
  buf.ai_flags = 4;
  buf.ai_socktype = 1;
  v59 = 0;
  if (!getaddrinfo(a1, 0, &buf, &v59))
  {
    if (v59)
    {
      ai_addr = v59->ai_addr;
      if (ai_addr)
      {
        ai_addrlen = v59->ai_addrlen;
        if (ai_addrlen <= 0x1C)
        {
          sa_len = ai_addr->sa_len;
          if (ai_addrlen == sa_len)
          {
            sa_family = ai_addr->sa_family;
            v23 = sa_len >= 0x10 && sa_family == 2;
            if (v23 || (sa_len >= 0x1C ? (v24 = sa_family == 30) : (v24 = 0), v24))
              *(_WORD *)ai_addr->sa_data = __rev16(a2);
            address = nw_endpoint_create_address(v59->ai_addr);
LABEL_73:
            if (v59)
            {
              freeaddrinfo(v59);
              v59 = 0;
            }
            if (address)
              return (BOOL)address;
            goto LABEL_13;
          }
        }
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = (id)gLogObj;
    *(_DWORD *)type = 136446467;
    v64 = "nw_endpoint_create_host_with_numeric_port";
    v65 = 2085;
    v66 = (void *)a1;
    v26 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v62.receiver) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v26, &v62, &v61))
    {
      if (LOBYTE(v62.receiver) == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = (id)gLogObj;
        receiver = (os_log_type_t)v62.receiver;
        if (os_log_type_enabled(v27, (os_log_type_t)v62.receiver))
        {
          *(_DWORD *)type = 136446467;
          v64 = "nw_endpoint_create_host_with_numeric_port";
          v65 = 2085;
          v66 = (void *)a1;
          _os_log_impl(&dword_182FBE000, v27, receiver, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed", (uint8_t *)type, 0x16u);
        }
      }
      else if (v61)
      {
        v30 = __nw_create_backtrace_string();
        if (v30)
        {
          v31 = (char *)v30;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v32 = (id)gLogObj;
          v33 = (os_log_type_t)v62.receiver;
          if (os_log_type_enabled(v32, (os_log_type_t)v62.receiver))
          {
            *(_DWORD *)type = 136446723;
            v64 = "nw_endpoint_create_host_with_numeric_port";
            v65 = 2085;
            v66 = (void *)a1;
            v67 = 2082;
            v68 = v31;
            _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x20u);
          }

          free(v31);
          if (!v26)
            goto LABEL_72;
          goto LABEL_71;
        }
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v36 = (os_log_type_t)v62.receiver;
        if (os_log_type_enabled(v27, (os_log_type_t)v62.receiver))
        {
          *(_DWORD *)type = 136446467;
          v64 = "nw_endpoint_create_host_with_numeric_port";
          v65 = 2085;
          v66 = (void *)a1;
          _os_log_impl(&dword_182FBE000, v27, v36, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed, no backtrace", (uint8_t *)type, 0x16u);
        }
      }
      else
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v35 = (os_log_type_t)v62.receiver;
        if (os_log_type_enabled(v27, (os_log_type_t)v62.receiver))
        {
          *(_DWORD *)type = 136446467;
          v64 = "nw_endpoint_create_host_with_numeric_port";
          v65 = 2085;
          v66 = (void *)a1;
          _os_log_impl(&dword_182FBE000, v27, v35, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed, backtrace limit exceeded", (uint8_t *)type, 0x16u);
        }
      }

    }
    if (!v26)
    {
LABEL_72:
      address = 0;
      goto LABEL_73;
    }
LABEL_71:
    free(v26);
    goto LABEL_72;
  }
LABEL_13:
  v10 = [NWConcrete_nw_host_endpoint alloc];
  if (!v10)
  {
LABEL_113:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v53 = (id)gLogObj;
    *(_DWORD *)type = 136446210;
    v64 = "nw_endpoint_create_host_with_numeric_port";
    v7 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v62.receiver) = 16;
    v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, &v62, &v61))
      goto LABEL_60;
    if (LOBYTE(v62.receiver) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v54 = (id)gLogObj;
      v55 = (os_log_type_t)v62.receiver;
      if (os_log_type_enabled(v54, (os_log_type_t)v62.receiver))
      {
        *(_DWORD *)type = 136446210;
        v64 = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s NWOSHostEndpoint alloc/init failed", (uint8_t *)type, 0xCu);
      }
LABEL_128:

      goto LABEL_60;
    }
    if (v61 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v58 = (os_log_type_t)v62.receiver;
      if (os_log_type_enabled(v54, (os_log_type_t)v62.receiver))
      {
        *(_DWORD *)type = 136446210;
        v64 = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_182FBE000, v54, v58, "%{public}s NWOSHostEndpoint alloc/init failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
      }
      goto LABEL_128;
    }
    v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v54 = objc_claimAutoreleasedReturnValue();
    v56 = (os_log_type_t)v62.receiver;
    v57 = os_log_type_enabled(v54, (os_log_type_t)v62.receiver);
    if (!v16)
    {
      if (v57)
      {
        *(_DWORD *)type = 136446210;
        v64 = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_182FBE000, v54, v56, "%{public}s NWOSHostEndpoint alloc/init failed, no backtrace", (uint8_t *)type, 0xCu);
      }
      goto LABEL_128;
    }
    if (v57)
    {
      *(_DWORD *)type = 136446466;
      v64 = "nw_endpoint_create_host_with_numeric_port";
      v65 = 2082;
      v66 = v16;
      _os_log_impl(&dword_182FBE000, v54, v56, "%{public}s NWOSHostEndpoint alloc/init failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
    }

LABEL_26:
    free(v16);
    if (!v7)
      return 0;
    goto LABEL_61;
  }
  v62.receiver = v10;
  v62.super_class = (Class)NWConcrete_nw_host_endpoint;
  address = objc_msgSendSuper2(&v62, sel_init);
  if (!address)
  {
    __nwlog_obj();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)type = 136446210;
    v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
    v43 = (char *)_os_log_send_and_compose_impl();

    v61 = OS_LOG_TYPE_ERROR;
    v60 = 0;
    if ((__nwlog_fault(v43, &v61, &v60) & 1) != 0)
    {
      if (v61 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v45 = v61;
        if (os_log_type_enabled(v44, v61))
        {
          *(_DWORD *)type = 136446210;
          v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
          _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s [super init] failed", (uint8_t *)type, 0xCu);
        }
      }
      else if (v60)
      {
        v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v50 = v61;
        v51 = os_log_type_enabled(v44, v61);
        if (v49)
        {
          if (v51)
          {
            *(_DWORD *)type = 136446466;
            v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
            v65 = 2082;
            v66 = v49;
            _os_log_impl(&dword_182FBE000, v44, v50, "%{public}s [super init] failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }

          free(v49);
          goto LABEL_111;
        }
        if (v51)
        {
          *(_DWORD *)type = 136446210;
          v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
          _os_log_impl(&dword_182FBE000, v44, v50, "%{public}s [super init] failed, no backtrace", (uint8_t *)type, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v52 = v61;
        if (os_log_type_enabled(v44, v61))
        {
          *(_DWORD *)type = 136446210;
          v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
          _os_log_impl(&dword_182FBE000, v44, v52, "%{public}s [super init] failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
        }
      }

    }
LABEL_111:
    if (v43)
      free(v43);
    goto LABEL_113;
  }
  v12 = strdup(a1);
  if (v12)
  {
LABEL_16:
    *((_QWORD *)address + 29) = v12;
    *((_WORD *)address + 120) = __rev16(a2);
    v13 = (const char *)*((_QWORD *)address + 29);
    v14 = strlen(v13);
    if (v14 >= 7)
    {
      v15 = v14;
      if (!strcmp(&v13[v14 - 6], ".local") || v15 >= 8 && !strcmp(&v13[v15 - 7], ".local."))
        *((_BYTE *)address + 231) |= 1u;
    }
    return (BOOL)address;
  }
  __nwlog_obj();
  v46 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
  *(_DWORD *)type = 136446210;
  v64 = "strict_strdup";
  v47 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v47);
  if (!result)
  {
    free(v47);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

void sub_1830DF4C4(_Unwind_Exception *a1)
{

  _Unwind_Resume(a1);
}

void type metadata accessor for os_unfair_lock_s(uint64_t a1)
{
  sub_183191AE4(a1, (unint64_t *)&unk_1ECD841E0);
}

void nw_protocol_definition_set_options_allocator(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  void *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  os_log_type_t v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_options_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v36 = "nw_protocol_definition_set_options_allocator";
          v37 = 2082;
          v38 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_72:
        if (!v10)
          goto LABEL_6;
LABEL_73:
        free(v10);
        goto LABEL_6;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v29, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_71:

    goto LABEL_72;
  }
  if (!a2)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_options_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v30, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_definition_set_options_allocator";
      v37 = 2082;
      v38 = v22;
      _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a3)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_options_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null copy_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v31, "%{public}s called with null copy_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null copy_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_definition_set_options_allocator";
      v37 = 2082;
      v38 = v22;
      _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null copy_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (!a4)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_definition_set_options_allocator";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v10, &type, &v33))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v33)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v32, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v11, type);
    if (!v22)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_definition_set_options_allocator";
        _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_definition_set_options_allocator";
      v37 = 2082;
      v38 = v22;
      _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_46:

    free(v22);
    if (!v10)
      goto LABEL_6;
    goto LABEL_73;
  }
  v7[11] = a2;
  v7[12] = a3;
  v7[13] = a4;
LABEL_6:

}

void nw_protocol_definition_set_options_equality_check(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_options_equality_check";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_options_equality_check";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_equality_check";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    *((_QWORD *)v3 + 14) = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_options_equality_check";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_equality_check";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null check_equality_function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_equality_check";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null check_equality_function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_equality_check";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null check_equality_function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_options_equality_check";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null check_equality_function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void nw_protocol_definition_set_metadata_allocator(void *a1, uint64_t a2, uint64_t a3)
{
  id v5;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_metadata_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_definition_set_metadata_allocator";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8)
          goto LABEL_5;
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_metadata_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null allocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null allocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_metadata_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null allocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_set_metadata_allocator";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null deallocate_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v25, "%{public}s called with null deallocate_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_set_metadata_allocator";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_set_metadata_allocator";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null deallocate_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8)
      goto LABEL_5;
    goto LABEL_56;
  }
  *((_QWORD *)v5 + 18) = a2;
  *((_QWORD *)v5 + 19) = a3;
LABEL_5:

}

NWConcrete_nw_protocol_definition *nw_protocol_definition_create_named(int a1, unsigned __int8 *a2)
{
  id v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  NWConcrete_nw_protocol_definition *v7;
  NWConcrete_nw_protocol_definition *v9;
  char *name;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  char *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  id v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  int v49;
  NWConcrete_nw_protocol_definition *v50;
  os_log_type_t v52;
  char *backtrace_string;
  os_log_type_t v54;
  _BOOL4 v55;
  os_log_type_t v56;
  char v57;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v60;
  __int16 v61;
  _WORD v62[17];

  *(_QWORD *)&v62[13] = *MEMORY[0x1E0C80C00];
  if ((a1 - 4) > 0xFFFFFFFC)
  {
    v9 = objc_alloc_init(NWConcrete_nw_protocol_definition);
    v7 = v9;
    if (v9)
    {
      uuid_generate_random(v9->unique_identifier);
      name = v7->identifier.name;
      if (a2)
      {
        v11 = *a2;
        *name = v11;
        if (v11)
        {
          v12 = a2[1];
          v7->identifier.name[1] = v12;
          if (v12)
          {
            v13 = a2[2];
            v7->identifier.name[2] = v13;
            if (v13)
            {
              v14 = a2[3];
              v7->identifier.name[3] = v14;
              if (v14)
              {
                v15 = a2[4];
                v7->identifier.name[4] = v15;
                if (v15)
                {
                  v16 = a2[5];
                  v7->identifier.name[5] = v16;
                  if (v16)
                  {
                    v17 = a2[6];
                    v7->identifier.name[6] = v17;
                    if (v17)
                    {
                      v18 = a2[7];
                      v7->identifier.name[7] = v18;
                      if (v18)
                      {
                        v19 = a2[8];
                        v7->identifier.name[8] = v19;
                        if (v19)
                        {
                          v20 = a2[9];
                          v7->identifier.name[9] = v20;
                          if (v20)
                          {
                            v21 = a2[10];
                            v7->identifier.name[10] = v21;
                            if (v21)
                            {
                              v22 = a2[11];
                              v7->identifier.name[11] = v22;
                              if (v22)
                              {
                                v23 = a2[12];
                                v7->identifier.name[12] = v23;
                                if (v23)
                                {
                                  v24 = a2[13];
                                  v7->identifier.name[13] = v24;
                                  if (v24)
                                  {
                                    v25 = a2[14];
                                    v7->identifier.name[14] = v25;
                                    if (v25)
                                    {
                                      v26 = a2[15];
                                      v7->identifier.name[15] = v26;
                                      if (v26)
                                      {
                                        v27 = a2[16];
                                        v7->identifier.name[16] = v27;
                                        if (v27)
                                        {
                                          v28 = a2[17];
                                          v7->identifier.name[17] = v28;
                                          if (v28)
                                          {
                                            v29 = a2[18];
                                            v7->identifier.name[18] = v29;
                                            if (v29)
                                            {
                                              v30 = a2[19];
                                              v7->identifier.name[19] = v30;
                                              if (v30)
                                              {
                                                v31 = a2[20];
                                                v7->identifier.name[20] = v31;
                                                if (v31)
                                                {
                                                  v32 = a2[21];
                                                  v7->identifier.name[21] = v32;
                                                  if (v32)
                                                  {
                                                    v33 = a2[22];
                                                    v7->identifier.name[22] = v33;
                                                    if (v33)
                                                    {
                                                      v34 = a2[23];
                                                      v7->identifier.name[23] = v34;
                                                      if (v34)
                                                      {
                                                        v35 = a2[24];
                                                        v7->identifier.name[24] = v35;
                                                        if (v35)
                                                        {
                                                          v36 = a2[25];
                                                          v7->identifier.name[25] = v36;
                                                          if (v36)
                                                          {
                                                            v37 = a2[26];
                                                            v7->identifier.name[26] = v37;
                                                            if (v37)
                                                            {
                                                              v38 = a2[27];
                                                              v7->identifier.name[27] = v38;
                                                              if (v38)
                                                              {
                                                                v39 = a2[28];
                                                                v7->identifier.name[28] = v39;
                                                                if (v39)
                                                                {
                                                                  v40 = a2[29];
                                                                  v7->identifier.name[29] = v40;
                                                                  if (v40)
                                                                  {
                                                                    v41 = a2[30];
                                                                    v7->identifier.name[30] = v41;
                                                                    if (v41)
                                                                      v7->identifier.name[31] = 0;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        uuid_unparse(v7->unique_identifier, name);
      }
      if (a1 == 3)
        v49 = 2;
      else
        v49 = 1;
      v7->identifier.level = 0;
      v7->identifier.mapping = v49;
      v7->variant = a1;
      v50 = v7;
      goto LABEL_62;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v45 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v60 = "nw_protocol_definition_create_named";
    v46 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v57 = 0;
    if (__nwlog_fault(v46, &type, &v57))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v47 = (id)gLogObj;
        v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          v60 = "nw_protocol_definition_create_named";
          _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s [nw_protocol_definition init] failed", buf, 0xCu);
        }
      }
      else if (v57)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v47 = (id)gLogObj;
        v54 = type;
        v55 = os_log_type_enabled(v47, type);
        if (backtrace_string)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            v60 = "nw_protocol_definition_create_named";
            v61 = 2082;
            *(_QWORD *)v62 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v47, v54, "%{public}s [nw_protocol_definition init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v46)
            goto LABEL_62;
          goto LABEL_56;
        }
        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          v60 = "nw_protocol_definition_create_named";
          _os_log_impl(&dword_182FBE000, v47, v54, "%{public}s [nw_protocol_definition init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v47 = (id)gLogObj;
        v56 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          v60 = "nw_protocol_definition_create_named";
          _os_log_impl(&dword_182FBE000, v47, v56, "%{public}s [nw_protocol_definition init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v46)
    {
LABEL_62:

      return v7;
    }
LABEL_56:
    free(v46);
    goto LABEL_62;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v60 = "nw_protocol_definition_create_named";
  v61 = 1024;
  *(_DWORD *)v62 = a1;
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v57 = 0;
  if (__nwlog_fault(v4, &type, &v57))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_definition_create_named";
        v61 = 1024;
        *(_DWORD *)v62 = a1;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s Invalid protocol variant %u", buf, 0x12u);
      }
    }
    else if (v57)
    {
      v42 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v43 = type;
      v44 = os_log_type_enabled(v5, type);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446722;
          v60 = "nw_protocol_definition_create_named";
          v61 = 1024;
          *(_DWORD *)v62 = a1;
          v62[2] = 2082;
          *(_QWORD *)&v62[3] = v42;
          _os_log_impl(&dword_182FBE000, v5, v43, "%{public}s Invalid protocol variant %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v42);
        if (!v4)
          return 0;
        goto LABEL_8;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_definition_create_named";
        v61 = 1024;
        *(_DWORD *)v62 = a1;
        _os_log_impl(&dword_182FBE000, v5, v43, "%{public}s Invalid protocol variant %u, no backtrace", buf, 0x12u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v52 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446466;
        v60 = "nw_protocol_definition_create_named";
        v61 = 1024;
        *(_DWORD *)v62 = a1;
        _os_log_impl(&dword_182FBE000, v5, v52, "%{public}s Invalid protocol variant %u, backtrace limit exceeded", buf, 0x12u);
      }
    }

  }
  if (v4)
LABEL_8:
    free(v4);
  return 0;
}

void sub_1830E10A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_attach_socket_protocol(NWConcrete_nw_endpoint_handler *a1, nw_protocol *a2)
{
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_mode_handler *v4;
  nw_endpoint_t v5;
  uint64_t internal;
  NWConcrete_nw_protocol_definition *v7;
  NSObject *v8;
  NSObject *v9;
  nw_protocol_options_t v10;
  nw_protocol_options_t v11;
  char v12;
  char v13;
  const char *id_string;
  const char *v15;
  nw_endpoint_t v16;
  NSObject *p_super;
  const char *logging_description;
  const char *v19;
  const char *v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  NSObject *v25;
  void *v26;
  int v27;
  char v28;
  void *v29;
  uint64_t v30;
  int v31;
  const char *v32;
  NSObject *v33;
  os_log_type_t v34;
  uint32_t v35;
  uint64_t v36;
  int v37;
  void *v38;
  uint64_t v39;
  os_log_type_t v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  sockaddr *v44;
  NSObject *v45;
  os_log_type_t v46;
  uint32_t v47;
  void *v48;
  void *v49;
  _QWORD *v50;
  int v51;
  id v52;
  const char *v53;
  NSObject *v54;
  os_log_type_t v55;
  NSObject *v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  _BOOL4 v60;
  os_log_type_t v61;
  char *v62;
  void *v64;
  const char *v65;
  NSObject *v66;
  os_log_type_t v67;
  NSObject *v68;
  os_log_type_t v69;
  char *v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  char *v74;
  NSObject *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  char *v78;
  NSObject *v79;
  _BOOL4 v80;
  char *backtrace_string;
  NSObject *v82;
  _BOOL4 v83;
  NSObject *v84;
  os_log_type_t v85;
  NSObject *v86;
  char *v87;
  NSObject *v88;
  os_log_type_t v89;
  const char *v90;
  char *v91;
  _BOOL4 v92;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  NSObject *v96;
  NWConcrete_nw_protocol_definition *v97;
  char *parameters;
  char v99;
  os_log_type_t type;
  socklen_t v101;
  os_log_type_t v102[8];
  uint64_t v103;
  uint64_t (*v104)(uint64_t, int);
  void *v105;
  uint64_t v106;
  uint8_t v107[4];
  const char *v108;
  __int16 v109;
  int v110;
  __int16 v111;
  char *v112;
  sockaddr buf[4];
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = nw_endpoint_handler_copy_flow(v3);
  parameters = (char *)nw_endpoint_handler_copy_parameters(v3);
  if (nw_socket_protocol_identifier::onceToken != -1)
    dispatch_once(&nw_socket_protocol_identifier::onceToken, &__block_literal_global_63760);
  v5 = nw_endpoint_handler_copy_endpoint(v3);
  internal = nw_protocol_create_internal((uint64_t)&nw_socket_protocol_identifier::identifier, v5, parameters, 1);

  if (internal)
  {
    if (nw_socket_protocol_identifier::onceToken != -1)
      dispatch_once(&nw_socket_protocol_identifier::onceToken, &__block_literal_global_63760);
    v7 = nw_protocol_definition_create_with_identifier(&nw_socket_protocol_identifier::identifier);
    v8 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)parameters);
    v9 = v8;
    v96 = v8;
    v97 = v7;
    if (!*((_QWORD *)v4 + 90))
    {
      v10 = nw_protocol_stack_copy_transport_protocol(v8);
      nw_endpoint_handler_set_protocol_instance(v3, v10, v7, internal);

    }
    v11 = nw_protocol_stack_copy_internet_protocol(v9);
    nw_endpoint_handler_set_protocol_instance(v3, v11, v7, internal);
    *((_QWORD *)v4 + 114) = internal;
    os_unfair_lock_lock((os_unfair_lock_t)v4 + 220);
    if (!*((_QWORD *)v4 + 90))
    {
      if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
      {
        v23 = *(_QWORD *)(internal + 88);
        if (v23)
          *(_QWORD *)(internal + 88) = v23 + 1;
        v13 = 1;
        v12 = -1;
      }
      else
      {
        v12 = 0;
        v13 = 0;
      }
      *(_QWORD *)&buf[0].sa_len = internal;
      buf[0].sa_data[6] = v12;
      v24 = *((_BYTE *)v4 + 728);
      if ((v24 & 1) != 0)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)v4 + 90);
        v24 = *((_BYTE *)v4 + 728);
      }
      *((_QWORD *)v4 + 90) = internal;
      *((_BYTE *)v4 + 728) = v13 | v24 & 0xFE;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v4 + 220);
    if ((*((_DWORD *)v4 + 225) & 0x80000000) != 0)
      goto LABEL_74;
    if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
    {
      if (*(_DWORD *)(internal + 292) != -1)
      {
        if ((*(_WORD *)(internal + 429) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v25 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
LABEL_47:
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
            *(_WORD *)&buf[0].sa_data[10] = 2082;
            *(_QWORD *)&buf[0].sa_data[12] = internal + 436;
            _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Socket protocol already has valid fd", &buf[0].sa_len, 0x16u);
          }
        }
LABEL_74:
        v48 = (void *)*((_QWORD *)v4 + 119);
        if (!v48)
          goto LABEL_79;
        if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
        {
          v49 = *(void **)(internal + 232);
          if (v49)
          {
            xpc_release(v49);
            *(_QWORD *)(internal + 232) = 0;
          }
          *(_QWORD *)(internal + 232) = xpc_retain(v48);
          goto LABEL_79;
        }
        __nwlog_obj();
        *(_DWORD *)&buf[0].sa_len = 136446210;
        *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_flow_divert_token";
        v70 = (char *)_os_log_send_and_compose_impl();
        v102[0] = OS_LOG_TYPE_ERROR;
        v107[0] = 0;
        if (__nwlog_fault(v70, v102, v107))
        {
          if (v102[0] == OS_LOG_TYPE_FAULT)
          {
            v71 = __nwlog_obj();
            v72 = v102[0];
            if (!os_log_type_enabled(v71, v102[0]))
              goto LABEL_165;
            *(_DWORD *)&buf[0].sa_len = 136446210;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_flow_divert_token";
            v73 = "%{public}s called with null socket_handler";
LABEL_163:
            v86 = v71;
LABEL_164:
            _os_log_impl(&dword_182FBE000, v86, v72, v73, &buf[0].sa_len, 0xCu);
            goto LABEL_165;
          }
          if (!v107[0])
          {
            v71 = __nwlog_obj();
            v72 = v102[0];
            if (!os_log_type_enabled(v71, v102[0]))
              goto LABEL_165;
            *(_DWORD *)&buf[0].sa_len = 136446210;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_flow_divert_token";
            v73 = "%{public}s called with null socket_handler, backtrace limit exceeded";
            goto LABEL_163;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          v82 = __nwlog_obj();
          v72 = v102[0];
          logb = v82;
          v83 = os_log_type_enabled(v82, v102[0]);
          if (backtrace_string)
          {
            if (v83)
            {
              *(_DWORD *)&buf[0].sa_len = 136446466;
              *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_flow_divert_token";
              *(_WORD *)&buf[0].sa_data[10] = 2082;
              *(_QWORD *)&buf[0].sa_data[12] = backtrace_string;
              _os_log_impl(&dword_182FBE000, logb, v72, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", &buf[0].sa_len, 0x16u);
            }
            free(backtrace_string);
            goto LABEL_165;
          }
          if (v83)
          {
            *(_DWORD *)&buf[0].sa_len = 136446210;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_flow_divert_token";
            v73 = "%{public}s called with null socket_handler, no backtrace";
            v86 = logb;
            goto LABEL_164;
          }
        }
LABEL_165:
        if (v70)
          free(v70);
LABEL_79:
        if (!a2)
        {
          __nwlog_obj();
          v64 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)&buf[0].sa_len = 136446210;
          *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
          v65 = (const char *)_os_log_send_and_compose_impl();

          v7 = v97;
          v102[0] = OS_LOG_TYPE_ERROR;
          v107[0] = 0;
          if (__nwlog_fault(v65, v102, v107))
          {
            if (v102[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v66 = objc_claimAutoreleasedReturnValue();
              v67 = v102[0];
              if (os_log_type_enabled(v66, v102[0]))
              {
                *(_DWORD *)&buf[0].sa_len = 136446210;
                *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                _os_log_impl(&dword_182FBE000, v66, v67, "%{public}s called with null input_protocol", &buf[0].sa_len, 0xCu);
              }

            }
            else if (v107[0])
            {
              v74 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v75 = objc_claimAutoreleasedReturnValue();
              v76 = v102[0];
              v77 = os_log_type_enabled(v75, v102[0]);
              if (v74)
              {
                if (v77)
                {
                  *(_DWORD *)&buf[0].sa_len = 136446466;
                  *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                  *(_WORD *)&buf[0].sa_data[10] = 2082;
                  *(_QWORD *)&buf[0].sa_data[12] = v74;
                  _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", &buf[0].sa_len, 0x16u);
                }

                v7 = v97;
                free(v74);
              }
              else
              {
                if (v77)
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                  _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s called with null input_protocol, no backtrace", &buf[0].sa_len, 0xCu);
                }

                v7 = v97;
              }
            }
            else
            {
              __nwlog_obj();
              v84 = objc_claimAutoreleasedReturnValue();
              v85 = v102[0];
              if (os_log_type_enabled(v84, v102[0]))
              {
                *(_DWORD *)&buf[0].sa_len = 136446210;
                *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                _os_log_impl(&dword_182FBE000, v84, v85, "%{public}s called with null input_protocol, backtrace limit exceeded", &buf[0].sa_len, 0xCu);
              }

              v7 = v97;
            }
          }
          if (!v65)
            goto LABEL_114;
          v62 = (char *)v65;
          goto LABEL_113;
        }
        if ((nw_protocol *)internal != a2)
        {
          v50 = *(_QWORD **)(internal + 24);
          if (v50 && *v50)
          {
            if (!nw_protocol_add_input_handler(internal, (uint64_t)a2))
            {
              v22 = 0;
              goto LABEL_115;
            }
            v51 = *((char *)v4 + 33);
            if ((v51 & 0x80000000) == 0)
            {
              v22 = 1;
LABEL_115:

              goto LABEL_116;
            }
            if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
            {
              if (((*(unsigned __int16 *)(internal + 429) | (*(unsigned __int8 *)(internal + 431) << 16)) & 0x20000) != 0)
              {
LABEL_104:
                v22 = 1;
                goto LABEL_115;
              }
LABEL_103:
              *((_BYTE *)v4 + 33) = v51 & 0x7F;
              goto LABEL_104;
            }
            __nwlog_obj();
            *(_DWORD *)&buf[0].sa_len = 136446210;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
            v87 = (char *)_os_log_send_and_compose_impl();
            v102[0] = OS_LOG_TYPE_ERROR;
            v107[0] = 0;
            if (__nwlog_fault(v87, v102, v107))
            {
              if (v102[0] == OS_LOG_TYPE_FAULT)
              {
                v88 = __nwlog_obj();
                v89 = v102[0];
                if (os_log_type_enabled(v88, v102[0]))
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                  v90 = "%{public}s called with null socket_handler";
LABEL_184:
                  _os_log_impl(&dword_182FBE000, v88, v89, v90, &buf[0].sa_len, 0xCu);
                }
              }
              else if (v107[0])
              {
                v91 = (char *)__nw_create_backtrace_string();
                v88 = __nwlog_obj();
                v89 = v102[0];
                v92 = os_log_type_enabled(v88, v102[0]);
                if (v91)
                {
                  if (v92)
                  {
                    *(_DWORD *)&buf[0].sa_len = 136446466;
                    *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                    *(_WORD *)&buf[0].sa_data[10] = 2082;
                    *(_QWORD *)&buf[0].sa_data[12] = v91;
                    _os_log_impl(&dword_182FBE000, v88, v89, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", &buf[0].sa_len, 0x16u);
                  }
                  free(v91);
                  goto LABEL_185;
                }
                if (v92)
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                  v90 = "%{public}s called with null socket_handler, no backtrace";
                  goto LABEL_184;
                }
              }
              else
              {
                v88 = __nwlog_obj();
                v89 = v102[0];
                if (os_log_type_enabled(v88, v102[0]))
                {
                  *(_DWORD *)&buf[0].sa_len = 136446210;
                  *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_is_multipath";
                  v90 = "%{public}s called with null socket_handler, backtrace limit exceeded";
                  goto LABEL_184;
                }
              }
            }
LABEL_185:
            if (v87)
              free(v87);
            LOBYTE(v51) = *((_BYTE *)v4 + 33);
            goto LABEL_103;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v56 = (id)gLogObj;
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
            *(_WORD *)&buf[0].sa_data[10] = 2048;
            *(_QWORD *)&buf[0].sa_data[12] = internal;
            _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", &buf[0].sa_len, 0x16u);
          }

LABEL_114:
          v22 = 0;
          goto LABEL_115;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v52 = (id)gLogObj;
        *(_DWORD *)&buf[0].sa_len = 136446466;
        *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
        *(_WORD *)&buf[0].sa_data[10] = 2048;
        *(_QWORD *)&buf[0].sa_data[12] = a2;
        v53 = (const char *)_os_log_send_and_compose_impl();

        v7 = v97;
        v102[0] = OS_LOG_TYPE_ERROR;
        v107[0] = 0;
        if (!__nwlog_fault(v53, v102, v107))
          goto LABEL_111;
        if (v102[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = (id)gLogObj;
          v55 = v102[0];
          if (os_log_type_enabled(v54, v102[0]))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
            *(_WORD *)&buf[0].sa_data[10] = 2048;
            *(_QWORD *)&buf[0].sa_data[12] = a2;
            _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s Cannot add input handler %p to itself", &buf[0].sa_len, 0x16u);
          }
        }
        else
        {
          if (v107[0])
          {
            v57 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v58 = (id)gLogObj;
            v59 = v102[0];
            v60 = os_log_type_enabled(v58, v102[0]);
            if (v57)
            {
              if (v60)
              {
                *(_DWORD *)&buf[0].sa_len = 136446722;
                *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
                *(_WORD *)&buf[0].sa_data[10] = 2048;
                *(_QWORD *)&buf[0].sa_data[12] = a2;
                *(_WORD *)&buf[1].sa_data[4] = 2082;
                *(_QWORD *)&buf[1].sa_data[6] = v57;
                _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", &buf[0].sa_len, 0x20u);
              }

              free(v57);
              if (!v53)
                goto LABEL_114;
LABEL_112:
              v62 = (char *)v53;
LABEL_113:
              free(v62);
              goto LABEL_114;
            }
            if (v60)
            {
              *(_DWORD *)&buf[0].sa_len = 136446466;
              *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
              *(_WORD *)&buf[0].sa_data[10] = 2048;
              *(_QWORD *)&buf[0].sa_data[12] = a2;
              _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s Cannot add input handler %p to itself, no backtrace", &buf[0].sa_len, 0x16u);
            }

LABEL_111:
            if (!v53)
              goto LABEL_114;
            goto LABEL_112;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = (id)gLogObj;
          v61 = v102[0];
          if (os_log_type_enabled(v54, v102[0]))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_protocol_utilities_add_input_handler";
            *(_WORD *)&buf[0].sa_data[10] = 2048;
            *(_QWORD *)&buf[0].sa_data[12] = a2;
            _os_log_impl(&dword_182FBE000, v54, v61, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", &buf[0].sa_len, 0x16u);
          }
        }

        goto LABEL_111;
      }
      v26 = (void *)*((_QWORD *)v4 + 111);
      v27 = *((char *)v4 + 35);
      *(_QWORD *)v102 = MEMORY[0x1E0C809B0];
      v103 = 0x40000000;
      v104 = __nw_socket_set_connected_fd_block_invoke;
      v105 = &__block_descriptor_tmp_63709;
      v106 = internal + 96;
      if ((nw_fd_wrapper_get_fd(v26, v102) & 1) == 0)
      {
        if ((*(_WORD *)(internal + 429) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v25 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
            goto LABEL_47;
        }
        goto LABEL_74;
      }
      if (v26)
        v26 = os_retain(v26);
      v28 = *(_BYTE *)(internal + 168);
      if ((v28 & 1) != 0)
      {
        v29 = *(void **)(internal + 160);
        if (v29)
        {
          os_release(v29);
          v28 = *(_BYTE *)(internal + 168);
        }
      }
      *(_QWORD *)(internal + 160) = v26;
      *(_BYTE *)(internal + 168) = v28 | 1;
      *(_DWORD *)(internal + 300) &= ~0x800u;
      if (v27 < 0)
      {
        if ((nw_fd_wrapper_guard(v26) & 1) == 0 && (*(_WORD *)(internal + 429) & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v36 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
            *(_WORD *)&buf[0].sa_data[10] = 2082;
            *(_QWORD *)&buf[0].sa_data[12] = internal + 436;
            v32 = "%{public}s %{public}s Failed to guard socket fd";
            v33 = v36;
            v34 = OS_LOG_TYPE_ERROR;
            v35 = 22;
            goto LABEL_54;
          }
        }
      }
      else if ((*(_WORD *)(internal + 429) & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v30 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
        {
          v31 = *(_DWORD *)(internal + 292);
          *(_DWORD *)&buf[0].sa_len = 136446722;
          *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
          *(_WORD *)&buf[0].sa_data[10] = 2082;
          *(_QWORD *)&buf[0].sa_data[12] = internal + 436;
          *(_WORD *)&buf[1].sa_data[4] = 1024;
          *(_DWORD *)&buf[1].sa_data[6] = v31;
          v32 = "%{public}s %{public}s Not guarding connected fd %d";
          v33 = v30;
          v34 = OS_LOG_TYPE_DEFAULT;
          v35 = 28;
LABEL_54:
          _os_log_impl(&dword_182FBE000, v33, v34, v32, &buf[0].sa_len, v35);
        }
      }
      *(_WORD *)(internal + 429) |= 4u;
      v116 = 0u;
      v117 = 0u;
      v114 = 0u;
      v115 = 0u;
      memset(buf, 0, sizeof(buf));
      v101 = 128;
      if (!getsockname(*(_DWORD *)(internal + 292), buf, &v101))
      {
        *(_BYTE *)(internal + 432) = buf[0].sa_family;
        goto LABEL_74;
      }
      v37 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)v107 = 136446466;
      v108 = "nw_socket_set_connected_fd";
      v109 = 1024;
      v110 = v37;
      v38 = (void *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v99 = 0;
      if (__nwlog_fault((const char *)v38, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v39 = gLogObj;
          v40 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_72;
          *(_DWORD *)v107 = 136446466;
          v108 = "nw_socket_set_connected_fd";
          v109 = 1024;
          v110 = v37;
          v41 = "%{public}s getsockname failed %{darwin.errno}d";
LABEL_69:
          v44 = (sockaddr *)v107;
          v45 = v39;
LABEL_70:
          v46 = v40;
          v47 = 18;
LABEL_71:
          _os_log_impl(&dword_182FBE000, v45, v46, v41, &v44->sa_len, v47);
          goto LABEL_72;
        }
        if (!v99)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v39 = gLogObj;
          v40 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_72;
          *(_DWORD *)v107 = 136446466;
          v108 = "nw_socket_set_connected_fd";
          v109 = 1024;
          v110 = v37;
          v41 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_69;
        }
        v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = type;
        log = gLogObj;
        v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)v107 = 136446722;
            v108 = "nw_socket_set_connected_fd";
            v109 = 1024;
            v110 = v37;
            v111 = 2082;
            v112 = v42;
            _os_log_impl(&dword_182FBE000, log, v40, "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s", v107, 0x1Cu);
          }
          free(v42);
          if (!v38)
            goto LABEL_74;
LABEL_73:
          free(v38);
          goto LABEL_74;
        }
        if (v43)
        {
          *(_DWORD *)v107 = 136446466;
          v108 = "nw_socket_set_connected_fd";
          v109 = 1024;
          v110 = v37;
          v41 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
          v44 = (sockaddr *)v107;
          v45 = log;
          goto LABEL_70;
        }
      }
LABEL_72:
      if (!v38)
        goto LABEL_74;
      goto LABEL_73;
    }
    __nwlog_obj();
    *(_DWORD *)&buf[0].sa_len = 136446210;
    *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
    v38 = (void *)_os_log_send_and_compose_impl();
    v102[0] = OS_LOG_TYPE_ERROR;
    v107[0] = 0;
    if (!__nwlog_fault((const char *)v38, v102, v107))
      goto LABEL_72;
    if (v102[0] == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = v102[0];
      if (!os_log_type_enabled(v68, v102[0]))
        goto LABEL_72;
      *(_DWORD *)&buf[0].sa_len = 136446210;
      *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
      v41 = "%{public}s called with null socket_handler";
    }
    else
    {
      if (v107[0])
      {
        v78 = (char *)__nw_create_backtrace_string();
        v79 = __nwlog_obj();
        v69 = v102[0];
        loga = v79;
        v80 = os_log_type_enabled(v79, v102[0]);
        if (v78)
        {
          if (v80)
          {
            *(_DWORD *)&buf[0].sa_len = 136446466;
            *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
            *(_WORD *)&buf[0].sa_data[10] = 2082;
            *(_QWORD *)&buf[0].sa_data[12] = v78;
            _os_log_impl(&dword_182FBE000, loga, v69, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", &buf[0].sa_len, 0x16u);
          }
          free(v78);
          goto LABEL_72;
        }
        if (!v80)
          goto LABEL_72;
        *(_DWORD *)&buf[0].sa_len = 136446210;
        *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
        v41 = "%{public}s called with null socket_handler, no backtrace";
        v44 = buf;
        v45 = loga;
LABEL_160:
        v46 = v69;
        v47 = 12;
        goto LABEL_71;
      }
      v68 = __nwlog_obj();
      v69 = v102[0];
      if (!os_log_type_enabled(v68, v102[0]))
        goto LABEL_72;
      *(_DWORD *)&buf[0].sa_len = 136446210;
      *(_QWORD *)&buf[0].sa_data[2] = "nw_socket_set_connected_fd";
      v41 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    }
    v44 = buf;
    v45 = v68;
    goto LABEL_160;
  }
  if ((nw_endpoint_handler_get_logging_disabled(v3) & 1) != 0)
  {
    v22 = 0;
    goto LABEL_117;
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v7 = (NWConcrete_nw_protocol_definition *)(id)gconnectionLogObj;
  if (os_log_type_enabled(&v7->super, OS_LOG_TYPE_ERROR))
  {
    id_string = nw_endpoint_handler_get_id_string(v3);
    v15 = nw_endpoint_handler_dry_run_string(v3);
    v16 = nw_endpoint_handler_copy_endpoint(v3);
    p_super = &v7->super;
    logging_description = nw_endpoint_get_logging_description(v16);
    v19 = nw_endpoint_handler_state_string(v3);
    v20 = nw_endpoint_handler_mode_string(v3);
    v21 = nw_endpoint_handler_copy_current_path(v3);
    *(_DWORD *)&buf[0].sa_len = 136447746;
    *(_QWORD *)&buf[0].sa_data[2] = "nw_endpoint_flow_attach_socket_protocol";
    *(_WORD *)&buf[0].sa_data[10] = 2082;
    *(_QWORD *)&buf[0].sa_data[12] = id_string;
    *(_WORD *)&buf[1].sa_data[4] = 2082;
    *(_QWORD *)&buf[1].sa_data[6] = v15;
    *(_WORD *)&buf[2].sa_len = 2082;
    *(_QWORD *)buf[2].sa_data = logging_description;
    *(_WORD *)&buf[2].sa_data[8] = 2082;
    *(_QWORD *)&buf[2].sa_data[10] = v19;
    *(_WORD *)&buf[3].sa_data[2] = 2082;
    *(_QWORD *)&buf[3].sa_data[4] = v20;
    *(_WORD *)&buf[3].sa_data[12] = 2114;
    *(_QWORD *)&v114 = v21;
    v7 = (NWConcrete_nw_protocol_definition *)p_super;
    _os_log_impl(&dword_182FBE000, p_super, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Could not create socket protocol", &buf[0].sa_len, 0x48u);

  }
  v22 = 0;
LABEL_116:

LABEL_117:
  return v22;
}

nw_protocol_stack_t nw_parameters_copy_default_protocol_stack(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = v1[19].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_copy_default_protocol_stack";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_default_protocol_stack";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_copy_default_protocol_stack";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_default_protocol_stack";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_copy_default_protocol_stack";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

nw_protocol_options_t nw_protocol_stack_copy_internet_protocol(nw_protocol_stack_t stack)
{
  nw_protocol_stack_t v1;
  nw_protocol_stack_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = stack;
  v2 = v1;
  if (v1)
  {
    v3 = v1[6].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_stack_copy_internet_protocol";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_internet_protocol";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_stack_copy_internet_protocol";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_internet_protocol";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_internet_protocol";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

NWConcrete_nw_protocol_options *nw_parameters_create_protocol_parameters(__int128 *a1)
{
  NWConcrete_nw_protocol_definition *v1;
  NWConcrete_nw_protocol_options *options;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = nw_protocol_definition_create_with_identifier(a1);
    options = nw_protocol_create_options(v1);

    return options;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_parameters_create_protocol_parameters";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_parameters_create_protocol_parameters";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol_identifier", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_parameters_create_protocol_parameters";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_parameters_create_protocol_parameters";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null protocol_identifier, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_parameters_create_protocol_parameters";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null protocol_identifier, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  return 0;
}

void sub_1830E2E00(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_definition *nw_protocol_definition_create_with_identifier(__int128 *a1)
{
  NWConcrete_nw_protocol_definition *v2;
  NWConcrete_nw_protocol_definition *v3;
  __int128 v4;
  __int128 v5;
  int v6;
  NWConcrete_nw_protocol_definition *v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = objc_alloc_init(NWConcrete_nw_protocol_definition);
    v3 = v2;
    if (v2)
    {
      v4 = *a1;
      v5 = a1[1];
      *(_QWORD *)&v2->identifier.level = *((_QWORD *)a1 + 4);
      *(_OWORD *)&v2->identifier.name[16] = v5;
      *(_OWORD *)v2->identifier.name = v4;
      if (*((_DWORD *)a1 + 9) == 2)
        v6 = 3;
      else
        v6 = 2;
      v2->variant = v6;
      v7 = v2;
      goto LABEL_14;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_definition_create_with_identifier";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_protocol_definition_create_with_identifier";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s [nw_protocol_definition init] failed", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v14 = type;
        v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v28 = "nw_protocol_definition_create_with_identifier";
            v29 = 2082;
            v30 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s [nw_protocol_definition init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v9)
            goto LABEL_14;
          goto LABEL_13;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_protocol_definition_create_with_identifier";
          _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s [nw_protocol_definition init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v16 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_protocol_definition_create_with_identifier";
          _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s [nw_protocol_definition init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
    {
LABEL_14:

      return v3;
    }
LABEL_13:
    free(v9);
    goto LABEL_14;
  }
  __nwlog_obj();
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_protocol_definition_create_with_identifier";
  v18 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v18, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_definition_create_with_identifier";
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null identifier", buf, 0xCu);
      }
    }
    else if (v25)
    {
      v21 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      v23 = os_log_type_enabled(v19, type);
      if (v21)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_protocol_definition_create_with_identifier";
          v29 = 2082;
          v30 = v21;
          _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v21);
        goto LABEL_44;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_definition_create_with_identifier";
        _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_definition_create_with_identifier";
        _os_log_impl(&dword_182FBE000, v19, v24, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_44:
  if (v18)
    free(v18);
  return 0;
}

_DWORD *nw_fd_wrapper_create(int a1)
{
  _DWORD *v2;
  NSObject *v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  _WORD v18[17];

  *(_QWORD *)&v18[13] = *MEMORY[0x1E0C80C00];
  if (a1 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v16 = "nw_fd_wrapper_create";
    v17 = 1024;
    *(_DWORD *)v18 = a1;
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_fd_wrapper_create";
          v17 = 1024;
          *(_DWORD *)v18 = a1;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with invalid fd %d", buf, 0x12u);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v10 = type;
        v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446722;
            v16 = "nw_fd_wrapper_create";
            v17 = 1024;
            *(_DWORD *)v18 = a1;
            v18[2] = 2082;
            *(_QWORD *)&v18[3] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with invalid fd %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          if (!v5)
            return 0;
          goto LABEL_11;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_fd_wrapper_create";
          v17 = 1024;
          *(_DWORD *)v18 = a1;
          _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with invalid fd %d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_fd_wrapper_create";
          v17 = 1024;
          *(_DWORD *)v18 = a1;
          _os_log_impl(&dword_182FBE000, v6, v12, "%{public}s called with invalid fd %d, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
    if (!v5)
      return 0;
LABEL_11:
    free(v5);
    return 0;
  }
  v2 = -[NWConcrete_nw_fd_wrapper initWithFileDescriptor:]([NWConcrete_nw_fd_wrapper alloc], a1);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_fd_wrapper_create";
    v17 = 2114;
    *(_QWORD *)v18 = v2;
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s Created %{public}@", buf, 0x16u);
  }

  return v2;
}

uint64_t nw_fd_wrapper_guard(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  char os_unfair_lock_opaque;
  int v4;
  id v5;
  uint32_t v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  uint32_t v10;
  NSObject *v11;
  uint32_t v12;
  uint64_t v13;
  const char *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  uint32_t v19;
  os_log_type_t v20;
  uint32_t v21;
  os_log_type_t v22;
  uint32_t v23;
  void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  char v32;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  _BYTE v37[10];
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_fd_wrapper_guard";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v25, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_fd_wrapper_guard";
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null wrapper", buf, 0xCu);
        }
      }
      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        v30 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "nw_fd_wrapper_guard";
            v36 = 2082;
            *(_QWORD *)v37 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_fd_wrapper_guard";
          _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_fd_wrapper_guard";
          _os_log_impl(&dword_182FBE000, v26, v31, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_47:
    if (v25)
      free(v25);
    v13 = 0;
    goto LABEL_18;
  }
  os_unfair_lock_lock(v1 + 3);
  if ((v2[2]._os_unfair_lock_opaque & 0x80000000) == 0)
  {
    os_unfair_lock_opaque = v2[6]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 3) != 0)
    {
LABEL_17:
      v13 = os_unfair_lock_opaque & 1;
      os_unfair_lock_unlock(v2 + 3);
      goto LABEL_18;
    }
    if (!change_fdguard_np())
    {
      os_unfair_lock_opaque = LOBYTE(v2[6]._os_unfair_lock_opaque) | 1;
      LOBYTE(v2[6]._os_unfair_lock_opaque) = os_unfair_lock_opaque;
      goto LABEL_17;
    }
    v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    v6 = v2[2]._os_unfair_lock_opaque;
    *(_DWORD *)buf = 136446722;
    v35 = "nw_fd_wrapper_guard";
    v36 = 1024;
    *(_DWORD *)v37 = v6;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)&v37[6] = v4;
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v7, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          v10 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v35 = "nw_fd_wrapper_guard";
          v36 = 1024;
          *(_DWORD *)v37 = v10;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s Failed to guard fd %d %{darwin.errno}d", buf, 0x18u);
        }
      }
      else if (v32)
      {
        v15 = __nw_create_backtrace_string();
        if (v15)
        {
          v16 = (char *)v15;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = (id)gLogObj;
          v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            v19 = v2[2]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446978;
            v35 = "nw_fd_wrapper_guard";
            v36 = 1024;
            *(_DWORD *)v37 = v19;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = v4;
            v38 = 2082;
            v39 = v16;
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s Failed to guard fd %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(v16);
          if (!v7)
            goto LABEL_12;
          goto LABEL_11;
        }
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v8, type))
        {
          v23 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v35 = "nw_fd_wrapper_guard";
          v36 = 1024;
          *(_DWORD *)v37 = v23;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl(&dword_182FBE000, v8, v22, "%{public}s Failed to guard fd %d %{darwin.errno}d, no backtrace", buf, 0x18u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          v21 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v35 = "nw_fd_wrapper_guard";
          v36 = 1024;
          *(_DWORD *)v37 = v21;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl(&dword_182FBE000, v8, v20, "%{public}s Failed to guard fd %d %{darwin.errno}d, backtrace limit exceeded", buf, 0x18u);
        }
      }

    }
    if (!v7)
    {
LABEL_12:
      os_unfair_lock_opaque = v2[6]._os_unfair_lock_opaque;
      goto LABEL_17;
    }
LABEL_11:
    free(v7);
    goto LABEL_12;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v11 = (id)gLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    v12 = v2[2]._os_unfair_lock_opaque;
    *(_DWORD *)buf = 136446466;
    v35 = "nw_fd_wrapper_guard";
    v36 = 1024;
    *(_DWORD *)v37 = v12;
    _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s Cannot guard invalid fd %d", buf, 0x12u);
  }

  os_unfair_lock_unlock(v2 + 3);
  v13 = 0;
LABEL_18:

  return v13;
}

void sub_1830E4014(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_registration_get_partial_checksum_offload(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[148] >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_flow_registration_get_partial_checksum_offload";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_flow_registration_get_partial_checksum_offload";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_registration_get_partial_checksum_offload";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_socket_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v7;
  void (**v8)(_QWORD);
  const void *v9;
  _WORD *v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  void *output_handler_context;
  uint64_t v16;
  nw_protocol *output_handler;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  char *backtrace_string;
  _BOOL4 v27;
  const char *v28;
  _BOOL4 v29;
  char *v30;
  _BOOL4 v31;
  char v32;
  os_log_type_t type[8];
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  char *v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_socket_remove_input_handler";
    v18 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v18, type, &v32))
      goto LABEL_72;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        v19 = __nwlog_obj();
        v20 = type[0];
        if (!os_log_type_enabled(v19, type[0]))
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        v35 = "nw_socket_remove_input_handler";
        v21 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_71;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type[0];
      v27 = os_log_type_enabled(v19, type[0]);
      if (!backtrace_string)
      {
        if (!v27)
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        v35 = "nw_socket_remove_input_handler";
        v21 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_71;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_socket_remove_input_handler";
        v36 = 2082;
        v37 = backtrace_string;
        v28 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_54:
        _os_log_impl(&dword_182FBE000, v19, v20, v28, buf, 0x16u);
      }
LABEL_55:
      free(backtrace_string);
      goto LABEL_72;
    }
    v19 = __nwlog_obj();
    v20 = type[0];
    if (!os_log_type_enabled(v19, type[0]))
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    v35 = "nw_socket_remove_input_handler";
    v21 = "%{public}s called with null protocol";
LABEL_71:
    _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
LABEL_72:
    if (v18)
      free(v18);
    return 0;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_socket_remove_input_handler";
    v18 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v18, type, &v32))
      goto LABEL_72;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type[0];
      if (!os_log_type_enabled(v19, type[0]))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_socket_remove_input_handler";
      v21 = "%{public}s called with null socket_handler";
      goto LABEL_71;
    }
    if (!v32)
    {
      v19 = __nwlog_obj();
      v20 = type[0];
      if (!os_log_type_enabled(v19, type[0]))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_socket_remove_input_handler";
      v21 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_71;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type[0];
    v29 = os_log_type_enabled(v19, type[0]);
    if (backtrace_string)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_socket_remove_input_handler";
        v36 = 2082;
        v37 = backtrace_string;
        v28 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    if (!v29)
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    v35 = "nw_socket_remove_input_handler";
    v21 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_71;
  }
  if (a2)
  {
    if (a2->output_handler == a1)
    {
      callbacks = a1[1].callbacks;
      if (callbacks)
      {
        v7 = (nw_protocol_callbacks *)((char *)callbacks - 1);
        a1[1].callbacks = v7;
        if (!v7)
        {
          v8 = *(void (***)(_QWORD))a1[1].flow_id;
          if (v8)
          {
            *(_QWORD *)a1[1].flow_id = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if ((a1[1].flow_id[8] & 1) != 0)
          {
            v9 = *(const void **)a1[1].flow_id;
            if (v9)
              _Block_release(v9);
          }
          free(a1);
        }
      }
      a2->output_handler = 0;
    }
    goto LABEL_14;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v35 = "__nw_protocol_get_output_handler";
  v22 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v32 = 0;
  if (__nwlog_fault(v22, type, &v32))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type[0];
      if (!os_log_type_enabled(v23, type[0]))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      v35 = "__nw_protocol_get_output_handler";
      v25 = "%{public}s called with null protocol";
      goto LABEL_76;
    }
    if (!v32)
    {
      v23 = __nwlog_obj();
      v24 = type[0];
      if (!os_log_type_enabled(v23, type[0]))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      v35 = "__nw_protocol_get_output_handler";
      v25 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_76;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type[0];
    v31 = os_log_type_enabled(v23, type[0]);
    if (v30)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        v35 = "__nw_protocol_get_output_handler";
        v36 = 2082;
        v37 = v30;
        _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v30);
      goto LABEL_77;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446210;
      v35 = "__nw_protocol_get_output_handler";
      v25 = "%{public}s called with null protocol, no backtrace";
LABEL_76:
      _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0xCu);
    }
  }
LABEL_77:
  if (v22)
    free(v22);
LABEL_14:
  if ((nw_protocol *)a1[2].identifier != a2)
    return 0;
  v11 = (_WORD *)((char *)&a1[6].handle + 5);
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x44) == 4 && LODWORD(a1[4].handle) == 2)
  {
    *(_QWORD *)type = 1;
    if (setsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 128, type, 8u) < 0)
    {
      v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "nw_protocol_socket_reset_linger";
        v36 = 2080;
        v37 = (char *)&a1[6].default_input_handler + 4;
        v38 = 1024;
        v39 = v12;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_LINGER failed %{darwin.errno}d", buf, 0x1Cu);
      }
    }
  }
  nw_socket_cancel_input_source((uint64_t)&a1[1].output_handler, (uint64_t)a2);
  output_handler_context = a1[3].output_handler_context;
  if (output_handler_context)
  {
    nw_queue_cancel_source((uint64_t)a1[3].output_handler_context, v14);
    a1[3].output_handler_context = 0;
    if ((*v11 & 0x800) == 0)
    {
      nw_queue_resume_source((uint64_t)output_handler_context, v14);
      *v11 |= 0x800u;
    }
  }
  v16 = *(_QWORD *)&a1[3].flow_id[8];
  if (v16)
  {
    nw_queue_cancel_source(v16, v14);
    *(_QWORD *)&a1[3].flow_id[8] = 0;
  }
  a1[2].identifier = 0;
  if (a3)
  {
    nw_protocol_socket_cancel((uint64_t)&a1[1].output_handler);
    if (((uint64_t)a1[2].handle & 1) != 0)
    {
      output_handler = a1[2].output_handler;
      if (output_handler)
        os_release(output_handler);
    }
    a1[2].output_handler = 0;
    nw_protocol_destroy((uint64_t)&a1[1].output_handler, 0);
  }
  return 1;
}

void nw_queue_cancel_source(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  void *v4;
  void *v5;
  NSObject *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  uint64_t v19;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _QWORD v23[5];
  char v24;
  os_log_type_t v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(NSObject **)a1;
    if (v3)
    {
      dispatch_set_context(v3, 0);
      dispatch_source_cancel(*(dispatch_source_t *)a1);
    }
    else
    {
      v4 = *(void **)(a1 + 8);
      if (v4 && (v5 = *(void **)(a1 + 16)) != 0)
      {
        if (*(_BYTE *)(a1 + 48))
          nw_context_reset_timer_block_with_time(v4, a1, -1, v5);
        else
          nw_context_dequeue_source_block(v4, *(void **)(a1 + 16));
        v7 = *(id *)(a1 + 8);
        v8 = _Block_copy(*(const void **)(a1 + 24));
        v9 = *(void **)(a1 + 8);
        *(_QWORD *)(a1 + 8) = 0;

        v10 = *(void **)(a1 + 16);
        *(_QWORD *)(a1 + 16) = 0;

        v11 = *(void **)(a1 + 24);
        *(_QWORD *)(a1 + 24) = 0;

        if (v8)
          nw_context_queue_block(v7, v8);
        v23[0] = MEMORY[0x1E0C809B0];
        v23[1] = 3221225472;
        v23[2] = __nw_queue_cancel_source_block_invoke;
        v23[3] = &__block_descriptor_40_e5_v8__0l;
        v23[4] = a1;
        nw_context_queue_block(v7, v23);

      }
      else if (gLogDatapath)
      {
        __nwlog_obj(v4, a2);
        v6 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_queue_cancel_source";
          _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not cancelling again", buf, 0xCu);
        }

      }
    }
    return;
  }
  __nwlog_obj(0, a2);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v27 = "nw_queue_cancel_source";
  v13 = (char *)_os_log_send_and_compose_impl();

  v25 = OS_LOG_TYPE_ERROR;
  v24 = 0;
  v14 = __nwlog_fault(v13, &v25, &v24);
  if ((_DWORD)v14)
  {
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = v25;
      if (os_log_type_enabled(v16, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_queue_cancel_source";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null source", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj(backtrace_string, v19);
      v16 = objc_claimAutoreleasedReturnValue();
      v20 = v25;
      v21 = os_log_type_enabled(v16, v25);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_queue_cancel_source";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v20, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_33;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_queue_cancel_source";
        _os_log_impl(&dword_182FBE000, v16, v20, "%{public}s called with null source, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj(v14, v15);
      v16 = objc_claimAutoreleasedReturnValue();
      v22 = v25;
      if (os_log_type_enabled(v16, v25))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_queue_cancel_source";
        _os_log_impl(&dword_182FBE000, v16, v22, "%{public}s called with null source, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_33:
  if (v13)
    free(v13);
}

void sub_1830E4E08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_socket_cancel_input_source(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  _WORD *v5;
  int v6;
  unsigned int v7;

  v2 = *(_QWORD *)(a1 + 144);
  if (v2)
  {
    nw_queue_cancel_source(*(_QWORD *)(a1 + 144), a2);
    *(_QWORD *)(a1 + 144) = 0;
    v5 = (_WORD *)(a1 + 333);
    if ((*(_WORD *)(a1 + 333) & 0x400) != 0)
    {
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
      if (_nw_signposts_enabled)
      {
        if (kdebug_is_enabled())
          kdebug_trace();
      }
      nw_queue_resume_source(v2, v4);
      v6 = (unsigned __int16)*v5;
      v7 = v6 & 0xFFFFFBFF | (*(unsigned __int8 *)(a1 + 335) << 16);
      *v5 = v6 & 0xFBFF;
      *(_BYTE *)(a1 + 335) = BYTE2(v7);
    }
  }
}

uint64_t nw_socket_connect(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol **p_output_handler;
  __int16 *v5;
  char v6;
  NSObject *v7;
  const char *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t sae_srcif;
  const char *v12;
  char *v13;
  _BOOL4 v14;
  const char *v15;
  nw_protocol *v16;
  nw_protocol_callbacks *callbacks;
  void *output_handler;
  void *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  _BOOL8 v23;
  int v24;
  unsigned int v25;
  nw_protocol *output_handler_context;
  char *v27;
  uint64_t v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  nw_protocol_callbacks *v32;
  void *v33;
  void *v34;
  int v35;
  _BOOL8 v36;
  int v37;
  unsigned int v38;
  NSObject *remote;
  const sockaddr *address;
  const sockaddr *v41;
  uint64_t v42;
  uint64_t v43;
  int sa_family;
  NSObject *local;
  char *address_with_port;
  BOOL v47;
  int v48;
  sockaddr *v49;
  NSObject *v50;
  nw_protocol_callbacks *v51;
  void (*connected)(nw_protocol *, nw_protocol *);
  uint64_t v53;
  NSObject *v54;
  char *v55;
  _BOOL4 v56;
  int v57;
  uint64_t v58;
  const char *v59;
  const sockaddr *v60;
  _BOOL4 v61;
  char *v62;
  uint64_t v63;
  NSObject *v64;
  os_log_type_t v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void (**v74)(_QWORD);
  const void *v75;
  char *v76;
  _BOOL4 v77;
  NSObject *parameters;
  void *path;
  _DWORD *v80;
  unsigned int v81;
  NSObject *v82;
  nw_protocol_options_t v83;
  NSObject *v84;
  unsigned int v85;
  _BOOL4 is_connection_flow;
  __int16 v87;
  int v88;
  int v90;
  unsigned int v91;
  socklen_t sa_len;
  void *v93;
  uint64_t v94;
  int v95;
  NSObject *v96;
  os_log_type_t v97;
  uint64_t v98;
  int v99;
  nw_protocol *v100;
  int fd;
  int is_guarded;
  const char *v103;
  const char *v104;
  const char *v105;
  NSObject *v106;
  int v107;
  char v108;
  int handle_high;
  int v110;
  int v111;
  uint64_t v112;
  const char *v113;
  NSObject *v114;
  int v115;
  NSObject *v116;
  int v117;
  const char *v118;
  NSObject *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  const char *v123;
  char *v124;
  NSObject *v125;
  os_log_type_t v126;
  const char *v127;
  const char *v128;
  uint64_t v129;
  uint64_t v130;
  char v131;
  void *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  void (**v136)(_QWORD);
  const void *v137;
  char *v138;
  _BOOL4 v139;
  const char *v140;
  char *backtrace_string;
  _BOOL4 v142;
  _BOOL4 v143;
  const char *v144;
  const char *v145;
  NSObject *v146;
  int output_handler_high;
  int v148;
  int v149;
  char v150;
  char *v151;
  void *v152;
  nw_protocol **v153;
  nw_protocol **v154;
  _QWORD v155[5];
  char v156;
  os_log_type_t v157;
  sa_endpoints_t type;
  uint64_t *v159;
  uint64_t v160;
  uint64_t v161;
  void (*v162)(uint64_t);
  void *v163;
  nw_protocol **v164;
  uint64_t v165;
  uint64_t *v166;
  uint64_t v167;
  nw_protocol *v168;
  _BYTE buf[24];
  __int128 v170;
  _BYTE object[10];
  __int128 v172;
  __int16 v173;
  const sockaddr *sae_dstaddr;
  __int16 v175;
  unsigned int v176;
  __int16 v177;
  int v178;
  uint8_t v179[4];
  const char *v180;
  __int16 v181;
  char *v182;
  uint64_t v183;

  v183 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socket_connect";
    v9 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type.sae_srcif) = 16;
    LOBYTE(v160) = 0;
    if (__nwlog_fault(v9, &type, &v160))
    {
      if (LOBYTE(type.sae_srcif) == 17)
      {
        v10 = __nwlog_obj();
        sae_srcif = type.sae_srcif;
        if (os_log_type_enabled(v10, type.sae_srcif))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          v12 = "%{public}s called with null protocol";
          goto LABEL_183;
        }
      }
      else if ((_BYTE)v160)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v10 = __nwlog_obj();
        sae_srcif = type.sae_srcif;
        v142 = os_log_type_enabled(v10, type.sae_srcif);
        if (backtrace_string)
        {
          if (v142)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_socket_connect";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, sae_srcif, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v142)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          v12 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_183;
        }
      }
      else
      {
        v10 = __nwlog_obj();
        sae_srcif = type.sae_srcif;
        if (os_log_type_enabled(v10, type.sae_srcif))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          v12 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_183;
        }
      }
    }
LABEL_184:
    if (!v9)
      return 0;
LABEL_185:
    free(v9);
    return 0;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socket_connect";
    v9 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type.sae_srcif) = 16;
    LOBYTE(v160) = 0;
    if (__nwlog_fault(v9, &type, &v160))
    {
      if (LOBYTE(type.sae_srcif) == 17)
      {
        v10 = __nwlog_obj();
        sae_srcif = type.sae_srcif;
        if (os_log_type_enabled(v10, type.sae_srcif))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          v12 = "%{public}s called with null socket_handler";
          goto LABEL_183;
        }
      }
      else if ((_BYTE)v160)
      {
        v13 = (char *)__nw_create_backtrace_string();
        v10 = __nwlog_obj();
        sae_srcif = type.sae_srcif;
        v143 = os_log_type_enabled(v10, type.sae_srcif);
        if (v13)
        {
          if (v143)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_socket_connect";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v13;
            v15 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
            goto LABEL_20;
          }
LABEL_21:
          free(v13);
          if (!v9)
            return 0;
          goto LABEL_185;
        }
        if (v143)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          v12 = "%{public}s called with null socket_handler, no backtrace";
          goto LABEL_183;
        }
      }
      else
      {
        v10 = __nwlog_obj();
        sae_srcif = type.sae_srcif;
        if (os_log_type_enabled(v10, type.sae_srcif))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          v12 = "%{public}s called with null socket_handler, backtrace limit exceeded";
          goto LABEL_183;
        }
      }
    }
    goto LABEL_184;
  }
  if ((HIDWORD(a1[4].output_handler) & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socket_connect";
    v9 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type.sae_srcif) = 16;
    LOBYTE(v160) = 0;
    if (!__nwlog_fault(v9, &type, &v160))
      goto LABEL_184;
    if (LOBYTE(type.sae_srcif) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      sae_srcif = type.sae_srcif;
      if (!os_log_type_enabled((os_log_t)gLogObj, type.sae_srcif))
        goto LABEL_184;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      v12 = "%{public}s called with null socket_handler->fd";
    }
    else if ((_BYTE)v160)
    {
      v13 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      sae_srcif = type.sae_srcif;
      v14 = os_log_type_enabled((os_log_t)gLogObj, type.sae_srcif);
      if (v13)
      {
        if (!v14)
          goto LABEL_21;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v13;
        v15 = "%{public}s called with null socket_handler->fd, dumping backtrace:%{public}s";
        goto LABEL_20;
      }
      if (!v14)
        goto LABEL_184;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      v12 = "%{public}s called with null socket_handler->fd, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      sae_srcif = type.sae_srcif;
      if (!os_log_type_enabled((os_log_t)gLogObj, type.sae_srcif))
        goto LABEL_184;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      v12 = "%{public}s called with null socket_handler->fd, backtrace limit exceeded";
    }
LABEL_183:
    _os_log_impl(&dword_182FBE000, v10, sae_srcif, v12, buf, 0xCu);
    goto LABEL_184;
  }
  p_output_handler = &a1[1].output_handler;
  v5 = (__int16 *)((char *)&a1[6].handle + 5);
  v6 = *(_WORD *)((char *)&a1[6].handle + 5);
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 1) != 0)
    goto LABEL_68;
  if (a1[3].default_input_handler)
  {
    if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) != 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_socket_setup_input_events";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = (char *)a1 + 436;
    v8 = "%{public}s %{public}s Already set up input event notification";
    goto LABEL_11;
  }
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v146 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      output_handler_high = HIDWORD(a1[4].output_handler);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_socket_setup_input_events";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)a1 + 436;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v170) = output_handler_high;
      _os_log_impl(&dword_182FBE000, v146, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Setting up read events on %d", buf, 0x1Cu);
    }
  }
  v16 = 0;
  v165 = 0;
  v166 = &v165;
  v167 = 0x2000000000;
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = a1[1].callbacks;
    v16 = a1;
    if (callbacks)
    {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      v16 = a1;
    }
  }
  v168 = v16;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3802000000;
  *(_QWORD *)&v170 = __Block_byref_object_copy__63801;
  *((_QWORD *)&v170 + 1) = __Block_byref_object_dispose__63802;
  output_handler = a1[2].output_handler;
  if (output_handler)
    output_handler = os_retain(output_handler);
  *(_QWORD *)object = output_handler;
  object[8] |= 1u;
  v19 = *(void **)a1[4].flow_id;
  v20 = HIDWORD(a1[4].output_handler);
  v21 = MEMORY[0x1E0C809B0];
  v160 = MEMORY[0x1E0C809B0];
  v161 = 0x40000000;
  v162 = ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke;
  v163 = &__block_descriptor_tmp_34_64689;
  v164 = &a1[1].output_handler;
  *(_QWORD *)&type.sae_srcif = MEMORY[0x1E0C809B0];
  type.sae_srcaddr = (const sockaddr *)0x40000000;
  *(_QWORD *)&type.sae_srcaddrlen = ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke_2;
  type.sae_dstaddr = (const sockaddr *)&unk_1E14A8B70;
  *(_QWORD *)&type.sae_dstaddrlen = buf;
  v159 = &v165;
  v23 = nw_queue_context_create_source(v19, v20, 1, 0, &v160, &type);
  a1[3].default_input_handler = (nw_protocol *)v23;
  if (v23)
  {
    if (_nw_signposts_once != -1)
      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
    if (_nw_signposts_enabled && kdebug_is_enabled())
      kdebug_trace();
    v24 = (unsigned __int16)*v5;
    v25 = v24 & 0xFFFFFBFF | (HIBYTE(a1[6].handle) << 16);
    *v5 = v24 & 0xFBFF;
    HIBYTE(a1[6].handle) = BYTE2(v25);
    nw_queue_resume_source((uint64_t)a1[3].default_input_handler, v22);
    goto LABEL_37;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)v179 = 136446210;
  v180 = "nw_socket_setup_input_events";
  v27 = (char *)_os_log_send_and_compose_impl();
  v157 = OS_LOG_TYPE_ERROR;
  v156 = 0;
  if (__nwlog_fault(v27, &v157, &v156))
  {
    if (v157 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v29 = gLogObj;
      v30 = v157;
      if (os_log_type_enabled((os_log_t)gLogObj, v157))
      {
        *(_DWORD *)v179 = 136446210;
        v180 = "nw_socket_setup_input_events";
        v31 = "%{public}s nw_queue_context_create_source input_source failed";
LABEL_136:
        _os_log_impl(&dword_182FBE000, v29, v30, v31, v179, 0xCu);
      }
    }
    else if (v156)
    {
      v55 = (char *)__nw_create_backtrace_string();
      v29 = __nwlog_obj();
      v30 = v157;
      v56 = os_log_type_enabled(v29, v157);
      if (v55)
      {
        if (v56)
        {
          *(_DWORD *)v179 = 136446466;
          v180 = "nw_socket_setup_input_events";
          v181 = 2082;
          v182 = v55;
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s nw_queue_context_create_source input_source failed, dumping backtrace:%{public}s", v179, 0x16u);
        }
        free(v55);
        goto LABEL_137;
      }
      if (v56)
      {
        *(_DWORD *)v179 = 136446210;
        v180 = "nw_socket_setup_input_events";
        v31 = "%{public}s nw_queue_context_create_source input_source failed, no backtrace";
        goto LABEL_136;
      }
    }
    else
    {
      v29 = __nwlog_obj();
      v30 = v157;
      if (os_log_type_enabled(v29, v157))
      {
        *(_DWORD *)v179 = 136446210;
        v180 = "nw_socket_setup_input_events";
        v31 = "%{public}s nw_queue_context_create_source input_source failed, backtrace limit exceeded";
        goto LABEL_136;
      }
    }
  }
LABEL_137:
  if (v27)
    free(v27);
  v67 = *(_QWORD *)&a1[3].flow_id[8];
  p_output_handler = &a1[1].output_handler;
  if (v67)
  {
    nw_queue_cancel_source(v67, v28);
    *(_QWORD *)&a1[3].flow_id[8] = 0;
  }
  v68 = *(_QWORD *)&buf[8];
  v69 = *(_BYTE *)(*(_QWORD *)&buf[8] + 48);
  if ((v69 & 1) != 0)
  {
    v70 = *(void **)(*(_QWORD *)&buf[8] + 40);
    if (v70)
    {
      os_release(v70);
      v69 = *(_BYTE *)(v68 + 48);
    }
  }
  *(_QWORD *)(v68 + 40) = 0;
  *(_BYTE *)(v68 + 48) = v69 | 1;
  v71 = v166[3];
  if (v71)
  {
    if (*(_UNKNOWN **)(v71 + 40) == &nw_protocol_ref_counted_handle)
    {
      v72 = *(_QWORD *)(v71 + 88);
      if (v72)
      {
        v73 = v72 - 1;
        *(_QWORD *)(v71 + 88) = v73;
        if (!v73)
        {
          v74 = *(void (***)(_QWORD))(v71 + 64);
          if (v74)
          {
            *(_QWORD *)(v71 + 64) = 0;
            v74[2](v74);
            _Block_release(v74);
          }
          if ((*(_BYTE *)(v71 + 72) & 1) != 0)
          {
            v75 = *(const void **)(v71 + 64);
            if (v75)
              _Block_release(v75);
          }
          free((void *)v71);
        }
      }
    }
  }
LABEL_37:
  _Block_object_dispose(buf, 8);
  if ((object[8] & 1) != 0 && *(_QWORD *)object)
    os_release(*(void **)object);
  _Block_object_dispose(&v165, 8);
  if (!v23)
    return 0;
  output_handler_context = (nw_protocol *)a1[3].output_handler_context;
  if (output_handler_context)
  {
    if ((*v5 & 0x80) != 0)
      return 0;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_socket_setup_output_events";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = (char *)a1 + 436;
    v8 = "%{public}s %{public}s Already set up output event notification";
LABEL_11:
    _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0x16u);
    return 0;
  }
  v165 = 0;
  v166 = &v165;
  v167 = 0x2000000000;
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v32 = a1[1].callbacks;
    output_handler_context = a1;
    if (v32)
    {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
      output_handler_context = a1;
    }
  }
  v168 = output_handler_context;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3802000000;
  *(_QWORD *)&v170 = __Block_byref_object_copy__63801;
  *((_QWORD *)&v170 + 1) = __Block_byref_object_dispose__63802;
  v33 = a1[2].output_handler;
  if (v33)
    v33 = os_retain(v33);
  *(_QWORD *)object = v33;
  object[8] |= 1u;
  v34 = *(void **)a1[4].flow_id;
  v35 = HIDWORD(a1[4].output_handler);
  v160 = v21;
  v161 = 0x40000000;
  v162 = ___ZL29nw_socket_setup_output_eventsP9nw_socket_block_invoke;
  v163 = &__block_descriptor_tmp_36_64697;
  v164 = p_output_handler;
  *(_QWORD *)&type.sae_srcif = v21;
  type.sae_srcaddr = (const sockaddr *)0x40000000;
  *(_QWORD *)&type.sae_srcaddrlen = ___ZL29nw_socket_setup_output_eventsP9nw_socket_block_invoke_2;
  type.sae_dstaddr = (const sockaddr *)&unk_1E14A8BB8;
  *(_QWORD *)&type.sae_dstaddrlen = buf;
  v159 = &v165;
  v36 = nw_queue_context_create_source(v34, v35, 2, 0, &v160, &type);
  a1[3].output_handler_context = (void *)v36;
  if (!v36)
  {
    v154 = p_output_handler;
    __nwlog_obj();
    *(_DWORD *)v179 = 136446210;
    v180 = "nw_socket_setup_output_events";
    v62 = (char *)_os_log_send_and_compose_impl();
    v157 = OS_LOG_TYPE_ERROR;
    v156 = 0;
    if (__nwlog_fault(v62, &v157, &v156))
    {
      if (v157 == OS_LOG_TYPE_FAULT)
      {
        v64 = __nwlog_obj();
        v65 = v157;
        if (os_log_type_enabled(v64, v157))
        {
          *(_DWORD *)v179 = 136446210;
          v180 = "nw_socket_setup_output_events";
          v66 = "%{public}s nw_queue_context_create_source output_source failed";
LABEL_276:
          _os_log_impl(&dword_182FBE000, v64, v65, v66, v179, 0xCu);
        }
      }
      else if (v156)
      {
        v76 = (char *)__nw_create_backtrace_string();
        v64 = __nwlog_obj();
        v65 = v157;
        v77 = os_log_type_enabled(v64, v157);
        if (v76)
        {
          if (v77)
          {
            *(_DWORD *)v179 = 136446466;
            v180 = "nw_socket_setup_output_events";
            v181 = 2082;
            v182 = v76;
            _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s nw_queue_context_create_source output_source failed, dumping backtrace:%{public}s", v179, 0x16u);
          }
          free(v76);
          goto LABEL_277;
        }
        if (v77)
        {
          *(_DWORD *)v179 = 136446210;
          v180 = "nw_socket_setup_output_events";
          v66 = "%{public}s nw_queue_context_create_source output_source failed, no backtrace";
          goto LABEL_276;
        }
      }
      else
      {
        v64 = __nwlog_obj();
        v65 = v157;
        if (os_log_type_enabled(v64, v157))
        {
          *(_DWORD *)v179 = 136446210;
          v180 = "nw_socket_setup_output_events";
          v66 = "%{public}s nw_queue_context_create_source output_source failed, backtrace limit exceeded";
          goto LABEL_276;
        }
      }
    }
LABEL_277:
    if (v62)
      free(v62);
    v129 = *(_QWORD *)&a1[3].flow_id[8];
    if (v129)
    {
      nw_queue_cancel_source(v129, v63);
      *(_QWORD *)&a1[3].flow_id[8] = 0;
    }
    v130 = *(_QWORD *)&buf[8];
    v131 = *(_BYTE *)(*(_QWORD *)&buf[8] + 48);
    if ((v131 & 1) != 0)
    {
      v132 = *(void **)(*(_QWORD *)&buf[8] + 40);
      p_output_handler = v154;
      if (v132)
      {
        os_release(v132);
        v131 = *(_BYTE *)(v130 + 48);
      }
    }
    else
    {
      p_output_handler = v154;
    }
    *(_QWORD *)(v130 + 40) = 0;
    *(_BYTE *)(v130 + 48) = v131 | 1;
    v133 = v166[3];
    if (v133)
    {
      if (*(_UNKNOWN **)(v133 + 40) == &nw_protocol_ref_counted_handle)
      {
        v134 = *(_QWORD *)(v133 + 88);
        if (v134)
        {
          v135 = v134 - 1;
          *(_QWORD *)(v133 + 88) = v135;
          if (!v135)
          {
            v136 = *(void (***)(_QWORD))(v133 + 64);
            if (v136)
            {
              *(_QWORD *)(v133 + 64) = 0;
              v136[2](v136);
              _Block_release(v136);
            }
            if ((*(_BYTE *)(v133 + 72) & 1) != 0)
            {
              v137 = *(const void **)(v133 + 64);
              if (v137)
                _Block_release(v137);
            }
            free((void *)v133);
          }
        }
      }
    }
    goto LABEL_62;
  }
  v37 = (unsigned __int16)*v5;
  v38 = v37 & 0xFFFFF7FF | (HIBYTE(a1[6].handle) << 16);
  *v5 = v37 & 0xF7FF;
  HIBYTE(a1[6].handle) = BYTE2(v38);
LABEL_62:
  _Block_object_dispose(buf, 8);
  if ((object[8] & 1) != 0 && *(_QWORD *)object)
    os_release(*(void **)object);
  _Block_object_dispose(&v165, 8);
  if (!v36 || !nw_socket_add_socket_events((uint64_t)p_output_handler, 1, HIDWORD(a1[4].handle), 1))
    return 0;
  v6 = *v5 | 1;
  *v5 |= 1u;
LABEL_68:
  if ((v6 & 4) != 0)
  {
    if (!a2)
      return 1;
    v51 = a2->callbacks;
    if (!v51)
      return 1;
    connected = (void (*)(nw_protocol *, nw_protocol *))v51->connected;
    if (!connected)
      return 1;
    connected(a2, a1);
    return 1;
  }
  if ((v6 & 2) != 0)
  {
    v53 = 1;
    if ((v6 & 0x80) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v54 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)a1 + 436;
        _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Suppressing duplicate connect call", buf, 0x16u);
      }
    }
    return v53;
  }
  v153 = p_output_handler;
  remote = nw_socket_get_remote(a1);
  address = nw_endpoint_get_address(remote);
  if (!address)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socket_connect";
    v9 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type.sae_srcif) = 16;
    LOBYTE(v160) = 0;
    if (!__nwlog_fault(v9, &type, &v160))
      goto LABEL_184;
    if (LOBYTE(type.sae_srcif) == 17)
    {
      v10 = __nwlog_obj();
      sae_srcif = type.sae_srcif;
      if (!os_log_type_enabled(v10, type.sae_srcif))
        goto LABEL_184;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      v12 = "%{public}s called with null remote";
      goto LABEL_183;
    }
    if (!(_BYTE)v160)
    {
      v10 = __nwlog_obj();
      sae_srcif = type.sae_srcif;
      if (!os_log_type_enabled(v10, type.sae_srcif))
        goto LABEL_184;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      v12 = "%{public}s called with null remote, backtrace limit exceeded";
      goto LABEL_183;
    }
    v13 = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    sae_srcif = type.sae_srcif;
    v61 = os_log_type_enabled(v10, type.sae_srcif);
    if (!v13)
    {
      if (!v61)
        goto LABEL_184;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      v12 = "%{public}s called with null remote, no backtrace";
      goto LABEL_183;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v13;
      v15 = "%{public}s called with null remote, dumping backtrace:%{public}s";
LABEL_20:
      _os_log_impl(&dword_182FBE000, v10, sae_srcif, v15, buf, 0x16u);
      goto LABEL_21;
    }
    goto LABEL_21;
  }
  v41 = address;
  v42 = mach_continuous_time();
  if (v42 <= 1)
    v43 = 1;
  else
    v43 = v42;
  *(_QWORD *)a1[2].flow_id = v43;
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  sa_family = v41->sa_family;
  if (sa_family == 30 || sa_family == 2)
  {
    if ((*v5 & 0x20) != 0)
    {
      v149 = 0;
      v48 = 0;
      address_with_port = 0;
      goto LABEL_120;
    }
    local = nw_socket_get_local(a1);
    address_with_port = (char *)local;
    v47 = ((unsigned __int16)*v5 | (SHIBYTE(a1[6].handle) << 16)) >= 0 || local == 0;
    v48 = !v47;
    if (!v47)
    {
      if (nw_endpoint_get_type(local) != nw_endpoint_type_address)
      {
        v48 = 0;
        goto LABEL_160;
      }
      v49 = (sockaddr *)nw_endpoint_get_address((nw_endpoint_t)address_with_port);
      if ((*v5 & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v50 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = (char *)a1 + 436;
          *(_WORD *)&buf[22] = 2112;
          *(_QWORD *)&v170 = address_with_port;
          _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_INFO, "%{public}s %{public}s resetting local port for local endpoint %@", buf, 0x20u);
        }
      }
      address_with_port = nw_endpoint_create_address_with_port(&v49->sa_len, "0");
    }
    if (!address_with_port)
    {
      v149 = 0;
LABEL_120:
      v60 = 0;
LABEL_161:
      parameters = nw_socket_get_parameters(a1);
      path = (void *)nw_socket_get_path(a1);
      v80 = nw_path_copy_scoped_interface(path);
      v151 = address_with_port;
      if (v80
        || (v80 = nw_parameters_copy_required_interface(parameters)) != 0
        || (v80 = nw_endpoint_copy_interface(remote)) != 0)
      {
        v150 = 0;
        v152 = v80;
        v81 = v80[2];
      }
      else
      {
        v152 = 0;
        v81 = 0;
        v150 = 1;
      }
      v82 = nw_parameters_copy_default_protocol_stack(parameters);
      v83 = nw_protocol_stack_copy_transport_protocol(v82);
      if (!v83)
      {
        v85 = 0;
        goto LABEL_190;
      }
      v148 = v48;
      v84 = v83;
      if (nw_protocol_setup_tcp_definition(void)::onceToken != -1)
        dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_62963);
      v85 = nw_protocol_options_matches_definition(v84, (void *)g_tcp_definition);

      if (v85)
      {
        if (nw_parameters_get_fast_open_enabled(parameters))
        {
          *v5 |= 0x8000u;
LABEL_171:
          if (nw_tcp_options_get_no_fast_open_cookie(v84))
            v85 = 7;
          else
            v85 = 3;
          goto LABEL_189;
        }
        if (nw_tcp_options_get_enable_fast_open(v84))
        {
          is_connection_flow = nw_protocol_input_handler_is_connection_flow((uint64_t)a2);
          v85 = 0;
          if (is_connection_flow)
            v87 = 0;
          else
            v87 = 0x8000;
          v88 = *(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x7FFF | (HIBYTE(a1[6].handle) << 16);
          *v5 = *(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x7FFF | v87;
          HIBYTE(a1[6].handle) = BYTE2(v88);
          if (is_connection_flow)
            goto LABEL_189;
          goto LABEL_171;
        }
        v85 = 0;
        v90 = (unsigned __int16)*v5;
        v91 = v90 & 0xFFFF7FFF | (HIBYTE(a1[6].handle) << 16);
        *v5 = v90 & 0x7FFF;
        HIBYTE(a1[6].handle) = BYTE2(v91);
      }
LABEL_189:
      os_release(v84);
      v48 = v148;
LABEL_190:
      if (v82)
        os_release(v82);
      *(&type.sae_srcif + 1) = 0;
      memset(&type.sae_srcaddrlen, 0, 24);
      type.sae_srcif = v81;
      type.sae_srcaddr = v60;
      if (v60)
        sa_len = v60->sa_len;
      else
        sa_len = 0;
      v93 = v152;
      type.sae_srcaddrlen = sa_len;
      type.sae_dstaddr = v41;
      type.sae_dstaddrlen = v41->sa_len;
      if ((*v5 & 0x100) != 0)
      {
        if ((*v5 & 0x80) != 0)
          goto LABEL_207;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v98 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
          goto LABEL_207;
        v99 = HIDWORD(a1[4].output_handler);
        *(_DWORD *)buf = 136448258;
        *(_QWORD *)&buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)a1 + 436;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v170) = v99;
        WORD2(v170) = 1024;
        *(_DWORD *)((char *)&v170 + 6) = type.sae_srcif;
        WORD5(v170) = 1040;
        HIDWORD(v170) = type.sae_srcaddrlen;
        *(_WORD *)object = 2096;
        *(_QWORD *)&object[2] = type.sae_srcaddr;
        LOWORD(v172) = 1040;
        *(_DWORD *)((char *)&v172 + 2) = type.sae_dstaddrlen;
        WORD3(v172) = 2096;
        *((_QWORD *)&v172 + 1) = type.sae_dstaddr;
        v173 = 1024;
        LODWORD(sae_dstaddr) = v85;
        v96 = v98;
        v97 = OS_LOG_TYPE_DEFAULT;
      }
      else
      {
        if ((*v5 & 0x80) != 0)
          goto LABEL_207;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v94 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          goto LABEL_207;
        v95 = HIDWORD(a1[4].output_handler);
        *(_DWORD *)buf = 136448258;
        *(_QWORD *)&buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)a1 + 436;
        *(_WORD *)&buf[22] = 1024;
        LODWORD(v170) = v95;
        WORD2(v170) = 1024;
        *(_DWORD *)((char *)&v170 + 6) = type.sae_srcif;
        WORD5(v170) = 1040;
        HIDWORD(v170) = type.sae_srcaddrlen;
        *(_WORD *)object = 2096;
        *(_QWORD *)&object[2] = type.sae_srcaddr;
        LOWORD(v172) = 1040;
        *(_DWORD *)((char *)&v172 + 2) = type.sae_dstaddrlen;
        WORD3(v172) = 2096;
        *((_QWORD *)&v172 + 1) = type.sae_dstaddr;
        v173 = 1024;
        LODWORD(sae_dstaddr) = v85;
        v96 = v94;
        v97 = OS_LOG_TYPE_DEBUG;
      }
      _os_log_impl(&dword_182FBE000, v96, v97, "%{public}s %{public}s Calling connectx(%d, [srcif=%d, srcaddr=%{network:sockaddr}.*P, dstaddr=%{network:sockaddr}.*P], SAE_ASSOCID_ANY, %#x, NULL, 0, NULL, SAE_CONNID_ANY)", buf, 0x48u);
LABEL_207:
      v57 = connectx(HIDWORD(a1[4].output_handler), &type, 0, v85, 0, 0, 0, 0);
      v58 = 0;
      if (v57 < 0)
      {
        v58 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if ((_DWORD)v58 != 36)
        {
          v100 = a1[2].output_handler;
          v155[0] = MEMORY[0x1E0C809B0];
          v155[1] = 0x40000000;
          v155[2] = ___ZL17nw_socket_connectP11nw_protocolS0__block_invoke;
          v155[3] = &__block_descriptor_tmp_26_64714;
          v155[4] = v153;
          fd = nw_fd_wrapper_get_fd(v100, v155);
          is_guarded = nw_fd_wrapper_is_guarded(a1[2].output_handler);
          v103 = " (guarded, corrupt)";
          if (fd)
            v103 = " (guarded)";
          v104 = " (corrupt)";
          if (fd)
            v104 = "";
          if (is_guarded)
            v105 = v103;
          else
            v105 = v104;
          if ((*v5 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v106 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
            {
              v107 = HIDWORD(a1[4].output_handler);
              *(_DWORD *)buf = 136448771;
              *(_QWORD *)&buf[4] = "nw_socket_connect";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = (char *)a1 + 436;
              *(_WORD *)&buf[22] = 1024;
              LODWORD(v170) = v107;
              WORD2(v170) = 2082;
              *(_QWORD *)((char *)&v170 + 6) = v105;
              HIWORD(v170) = 1024;
              *(_DWORD *)object = type.sae_srcif;
              *(_WORD *)&object[4] = 1040;
              *(_DWORD *)&object[6] = type.sae_srcaddrlen;
              LOWORD(v172) = 2101;
              *(_QWORD *)((char *)&v172 + 2) = type.sae_srcaddr;
              WORD5(v172) = 1040;
              HIDWORD(v172) = type.sae_dstaddrlen;
              v173 = 2101;
              sae_dstaddr = type.sae_dstaddr;
              v175 = 1024;
              v176 = v85;
              v177 = 1024;
              v178 = v58;
              _os_log_impl(&dword_182FBE000, v106, OS_LOG_TYPE_ERROR, "%{public}s %{public}s connectx(%d%{public}s, [srcif=%d, srcaddr=%{sensitive,network:sockaddr}.*P, dstaddr=%{sensitive,network:sockaddr}.*P], SAE_ASSOCID_ANY, %#x, NULL, 0, NULL, SAE_CONNID_ANY) failed: %{darwin.errno}d", buf, 0x58u);
            }
          }
          v93 = v152;
        }
      }
      v108 = v150;
      if (!v93)
        v108 = 1;
      if ((v108 & 1) == 0)
        os_release(v93);
      if (v151 && (v149 & v48) != 0)
        os_release(v151);
      v59 = "connectx";
LABEL_230:
      handle_high = HIBYTE(a1[6].handle);
      v110 = (unsigned __int16)*v5;
      *v5 = v110 | 2;
      if (!v57)
      {
        v115 = v110 | (handle_high << 16);
        if ((v115 & 0x8000) == 0)
        {
          HIBYTE(a1[6].handle) = BYTE2(v115);
          *v5 = v115 | 6;
        }
        v53 = 1;
        nw_socket_add_socket_events((uint64_t)v153, 1, HIDWORD(a1[4].handle), 1);
        nw_socket_fillout_socket_properties(a1);
        nw_socket_internal_connect(v153);
        return v53;
      }
      goto LABEL_231;
    }
LABEL_160:
    v60 = nw_endpoint_get_address((nw_endpoint_t)address_with_port);
    v149 = 1;
    goto LABEL_161;
  }
  v57 = connect(HIDWORD(a1[4].output_handler), v41, v41->sa_len);
  if ((v57 & 0x80000000) == 0)
  {
    v58 = 0;
    v59 = "connect";
    goto LABEL_230;
  }
  v58 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  *v5 |= 2u;
  v59 = "connect";
LABEL_231:
  v53 = 1;
  if (v57 < 0 && (_DWORD)v58 != 36)
  {
    if ((_DWORD)v58 == 47 && LODWORD(a1[4].handle) == 2)
    {
      v111 = v41->sa_family;
      if (v111 == 30)
      {
        if (v41->sa_data[6] == 255)
          goto LABEL_238;
      }
      else if (v111 == 2 && (*(_DWORD *)&v41->sa_data[2] & 0xF0) == 0xE0)
      {
LABEL_238:
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v112 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = (char *)a1 + 436;
          *(_WORD *)&buf[22] = 2082;
          *(_QWORD *)&v170 = v59;
          WORD4(v170) = 1024;
          *(_DWORD *)((char *)&v170 + 10) = 47;
          v113 = "%{public}s %s %{public}s failed: multicast addresses not supported on stream sockets %{darwin.errno}d";
          v114 = v112;
LABEL_262:
          _os_log_impl(&dword_182FBE000, v114, OS_LOG_TYPE_ERROR, v113, buf, 0x26u);
        }
        goto LABEL_263;
      }
    }
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v116 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      v117 = HIDWORD(a1[4].output_handler);
      v47 = (*v5 & 0x8000) == 0;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "nw_socket_connect";
      if (v47)
        v118 = "";
      else
        v118 = ", tfo";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = (char *)a1 + 436;
      *(_WORD *)&buf[22] = 2082;
      *(_QWORD *)&v170 = v59;
      WORD4(v170) = 1024;
      *(_DWORD *)((char *)&v170 + 10) = v117;
      HIWORD(v170) = 2082;
      *(_QWORD *)object = v118;
      *(_WORD *)&object[8] = 1024;
      LODWORD(v172) = v58;
      _os_log_impl(&dword_182FBE000, v116, OS_LOG_TYPE_ERROR, "%{public}s %s %{public}s failed (fd %d%{public}s) %{darwin.errno}d", buf, 0x36u);
    }
    switch((int)v58)
    {
      case 1:
      case 6:
      case 13:
      case 49:
      case 50:
      case 51:
      case 60:
      case 61:
      case 64:
      case 65:
      case 102:
        v119 = __nwlog_obj();
        if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
        {
          v120 = *v5;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          *(_DWORD *)buf = 136446978;
          *(_WORD *)&buf[12] = 2082;
          if (v120 < 0)
            v121 = " (tfo)";
          else
            v121 = "";
          *(_QWORD *)&buf[14] = v59;
          *(_WORD *)&buf[22] = 2082;
          *(_QWORD *)&v170 = v121;
          WORD4(v170) = 1024;
          *(_DWORD *)((char *)&v170 + 10) = v58;
          v113 = "%{public}s %{public}s failed%{public}s %{darwin.errno}d";
          v114 = v119;
          goto LABEL_262;
        }
        goto LABEL_263;
      default:
        __nwlog_obj();
        v122 = *(_WORD *)((char *)&a1[6].handle + 5);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_socket_connect";
        *(_WORD *)&buf[12] = 2082;
        if (v122 < 0)
          v123 = " (tfo)";
        else
          v123 = "";
        *(_QWORD *)&buf[14] = v59;
        *(_WORD *)&buf[22] = 2082;
        *(_QWORD *)&v170 = v123;
        WORD4(v170) = 1024;
        *(_DWORD *)((char *)&v170 + 10) = v58;
        v124 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(type.sae_srcif) = 16;
        LOBYTE(v160) = 0;
        if ((__nwlog_fault(v124, &type, &v160) & 1) == 0)
          goto LABEL_332;
        if (LOBYTE(type.sae_srcif) == 17)
        {
          v125 = __nwlog_obj();
          v126 = type.sae_srcif;
          if (!os_log_type_enabled(v125, type.sae_srcif))
            goto LABEL_332;
          if (*v5 < 0)
            v127 = " (tfo)";
          else
            v127 = "";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v59;
          *(_WORD *)&buf[22] = 2082;
          *(_QWORD *)&v170 = v127;
          WORD4(v170) = 1024;
          *(_DWORD *)((char *)&v170 + 10) = v58;
          v128 = "%{public}s %{public}s failed%{public}s %{darwin.errno}d";
        }
        else if ((_BYTE)v160)
        {
          v138 = (char *)__nw_create_backtrace_string();
          v125 = __nwlog_obj();
          v126 = type.sae_srcif;
          v139 = os_log_type_enabled(v125, type.sae_srcif);
          if (v138)
          {
            if (v139)
            {
              if (*v5 < 0)
                v140 = " (tfo)";
              else
                v140 = "";
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_socket_connect";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v59;
              *(_WORD *)&buf[22] = 2082;
              *(_QWORD *)&v170 = v140;
              WORD4(v170) = 1024;
              *(_DWORD *)((char *)&v170 + 10) = v58;
              HIWORD(v170) = 2082;
              *(_QWORD *)object = v138;
              _os_log_impl(&dword_182FBE000, v125, v126, "%{public}s %{public}s failed%{public}s %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x30u);
            }
            free(v138);
            goto LABEL_332;
          }
          if (!v139)
          {
LABEL_332:
            if (v124)
              free(v124);
LABEL_263:
            nw_socket_internal_error((uint64_t)v153, v58);
            return 0;
          }
          if (*v5 < 0)
            v145 = " (tfo)";
          else
            v145 = "";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v59;
          *(_WORD *)&buf[22] = 2082;
          *(_QWORD *)&v170 = v145;
          WORD4(v170) = 1024;
          *(_DWORD *)((char *)&v170 + 10) = v58;
          v128 = "%{public}s %{public}s failed%{public}s %{darwin.errno}d, no backtrace";
        }
        else
        {
          v125 = __nwlog_obj();
          v126 = type.sae_srcif;
          if (!os_log_type_enabled(v125, type.sae_srcif))
            goto LABEL_332;
          if (*v5 < 0)
            v144 = " (tfo)";
          else
            v144 = "";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_socket_connect";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v59;
          *(_WORD *)&buf[22] = 2082;
          *(_QWORD *)&v170 = v144;
          WORD4(v170) = 1024;
          *(_DWORD *)((char *)&v170 + 10) = v58;
          v128 = "%{public}s %{public}s failed%{public}s %{darwin.errno}d, backtrace limit exceeded";
        }
        _os_log_impl(&dword_182FBE000, v125, v126, v128, buf, 0x26u);
        goto LABEL_332;
    }
  }
  return v53;
}

void sub_1830E6F1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_queue_resume_source(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  NSObject *v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_queue_resume_source";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v6, &type, &v13))
      goto LABEL_28;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_queue_resume_source";
        v9 = "%{public}s called with null source";
LABEL_26:
        _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_queue_resume_source";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (!v11)
          goto LABEL_27;
        *(_DWORD *)buf = 136446210;
        v16 = "nw_queue_resume_source";
        v9 = "%{public}s called with null source, no backtrace";
        goto LABEL_26;
      }
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_queue_resume_source";
        v9 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_26;
      }
    }
LABEL_27:

LABEL_28:
    if (v6)
      free(v6);
    return;
  }
  v3 = *(NSObject **)a1;
  if (v3)
  {
    dispatch_resume(v3);
    return;
  }
  if (*(_BYTE *)(a1 + 48))
  {
    if (!*(_BYTE *)(a1 + 49))
    {
      nw_queue_source_run_timer(a1, a2);
LABEL_10:
      *(_BYTE *)(a1 + 49) = 1;
    }
  }
  else
  {
    v4 = *(void **)(a1 + 16);
    if (v4)
    {
      if (!*(_BYTE *)(a1 + 49))
      {
        nw_context_queue_source_block(*(void **)(a1 + 8), v4);
        goto LABEL_10;
      }
    }
    else if (gLogDatapath)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_queue_resume_source";
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not resuming source", buf, 0xCu);
      }

    }
  }
}

uint64_t nw_socket_add_socket_events(uint64_t a1, int a2, int a3, char a4)
{
  __int16 v4;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, uint64_t);
  void *v15;
  void *v16;
  int v17;
  _BOOL8 source;
  uint64_t v19;
  _BOOL8 v20;
  uint64_t v21;
  char v22;
  void *v23;
  uint64_t v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  uint64_t v31;
  uint64_t v32;
  void (**v33)(_QWORD);
  const void *v34;
  uint64_t v35;
  int v36;
  int v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t result;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  char *v46;
  _BOOL4 v47;
  int v48;
  int v49;
  NSObject *v50;
  NSObject *v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  char *v56;
  _BOOL4 v57;
  char v58;
  os_log_type_t type;
  _QWORD v60[6];
  os_log_type_t v61[8];
  uint64_t v62;
  void (*v63)(uint64_t);
  void *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  uint8_t buf[4];
  const char *v71;
  __int16 v72;
  char *v73;
  _BYTE v74[32];
  void (*v75)(uint64_t);
  void *v76;
  char v77;
  uint64_t v78;

  v4 = a3;
  v78 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a1 + 104);
  v8 = *(_DWORD *)(a1 + 204);
  v9 = v8 | a3;
  v10 = v8 & ~a3;
  if (a2)
    v11 = v9;
  else
    v11 = v10;
  *(_DWORD *)(a1 + 204) = v11;
  if ((a4 & 1) == 0 && (*(_WORD *)(a1 + 333) & 4) == 0 || *(_DWORD *)(a1 + 208) == v11)
    return 1;
  v12 = 0;
  v66 = 0;
  v67 = &v66;
  v68 = 0x2000000000;
  if (*(_UNKNOWN **)(a1 - 56) == &nw_protocol_ref_counted_handle)
  {
    v12 = a1 - 96;
    v13 = *(_QWORD *)(a1 - 8);
    if (v13)
      *(_QWORD *)(a1 - 8) = v13 + 1;
  }
  v69 = v12;
  *(_QWORD *)v74 = 0;
  *(_QWORD *)&v74[8] = v74;
  v14 = __Block_byref_object_copy__63801;
  *(_QWORD *)&v74[16] = 0x3802000000;
  *(_QWORD *)&v74[24] = __Block_byref_object_copy__63801;
  v75 = __Block_byref_object_dispose__63802;
  v15 = *(void **)(a1 + 64);
  if (v15)
  {
    v15 = os_retain(v15);
    LOBYTE(v14) = v77;
  }
  v76 = v15;
  v77 = v14 | 1;
  v16 = *(void **)(a1 + 160);
  v17 = *(_DWORD *)(a1 + 196);
  *(_QWORD *)v61 = MEMORY[0x1E0C809B0];
  v62 = 0x40000000;
  v63 = ___ZL34nw_socket_init_socket_event_sourceP9nw_socketj_block_invoke;
  v64 = &__block_descriptor_tmp_38_63803;
  v65 = a1;
  v60[0] = MEMORY[0x1E0C809B0];
  v60[1] = 0x40000000;
  v60[2] = ___ZL34nw_socket_init_socket_event_sourceP9nw_socketj_block_invoke_2;
  v60[3] = &unk_1E14A8C00;
  v60[4] = v74;
  v60[5] = &v66;
  source = nw_queue_context_create_source(v16, v17, 4, v11, v61, v60);
  v20 = source;
  *(_QWORD *)(a1 + 104) = source;
  if (source)
  {
    nw_queue_activate_source(source, v19);
    goto LABEL_43;
  }
  v21 = *(_QWORD *)&v74[8];
  v22 = *(_BYTE *)(*(_QWORD *)&v74[8] + 48);
  if ((v22 & 1) != 0)
  {
    v23 = *(void **)(*(_QWORD *)&v74[8] + 40);
    if (v23)
    {
      os_release(v23);
      v22 = *(_BYTE *)(v21 + 48);
    }
  }
  *(_QWORD *)(v21 + 40) = 0;
  *(_BYTE *)(v21 + 48) = v22 | 1;
  v24 = v67[3];
  if (v24)
  {
    if (*(_UNKNOWN **)(v24 + 40) == &nw_protocol_ref_counted_handle)
    {
      v31 = *(_QWORD *)(v24 + 88);
      if (v31)
      {
        v32 = v31 - 1;
        *(_QWORD *)(v24 + 88) = v32;
        if (!v32)
        {
          v33 = *(void (***)(_QWORD))(v24 + 64);
          if (v33)
          {
            *(_QWORD *)(v24 + 64) = 0;
            v33[2](v33);
            _Block_release(v33);
          }
          if ((*(_BYTE *)(v24 + 72) & 1) != 0)
          {
            v34 = *(const void **)(v24 + 64);
            if (v34)
              _Block_release(v34);
          }
          free((void *)v24);
        }
      }
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v71 = "nw_socket_init_socket_event_source";
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v58 = 0;
  if (__nwlog_fault(v25, &type, &v58))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      v27 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_socket_init_socket_event_source";
      v28 = "%{public}s nw_queue_context_create_source failed";
      goto LABEL_40;
    }
    if (!v58)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      v27 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_socket_init_socket_event_source";
      v28 = "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded";
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = gLogObj;
    v27 = type;
    v30 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        v71 = "nw_socket_init_socket_event_source";
        v72 = 2082;
        v73 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_41;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446210;
      v71 = "nw_socket_init_socket_event_source";
      v28 = "%{public}s nw_queue_context_create_source failed, no backtrace";
LABEL_40:
      _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
    }
  }
LABEL_41:
  if (v25)
    free(v25);
LABEL_43:
  _Block_object_dispose(v74, 8);
  if ((v77 & 1) != 0 && v76)
    os_release(v76);
  _Block_object_dispose(&v66, 8);
  if (v20)
  {
    if (v7)
      nw_queue_cancel_source(v7, v35);
    *(_DWORD *)(a1 + 208) = v11;
    if ((v4 & 0x400) == 0)
      goto LABEL_82;
    v36 = *(_DWORD *)(a1 + 224);
    if (!a2)
      v36 = 0;
    LODWORD(v60[0]) = v36;
    if (!setsockopt(*(_DWORD *)(a1 + 196), 6, 517, v60, 4u))
    {
LABEL_82:
      if ((v4 & 0x200) == 0)
        return 1;
      v48 = *(_DWORD *)(a1 + 228);
      if (!a2)
        v48 = 0;
      LODWORD(v60[0]) = v48;
      if (!setsockopt(*(_DWORD *)(a1 + 196), 6, 519, v60, 4u))
        return 1;
      v49 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v50 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v74 = 136446722;
        *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_write_timeout";
        *(_WORD *)&v74[12] = 2080;
        *(_QWORD *)&v74[14] = a1 + 340;
        *(_WORD *)&v74[22] = 1024;
        *(_DWORD *)&v74[24] = v49;
        _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_ADAPTIVE_WRITE_TIMEOUT failed %{darwin.errno}d", v74, 0x1Cu);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = gLogObj;
      if (v49 == 22)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v74 = 136446466;
          *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_write_timeout";
          *(_WORD *)&v74[12] = 1024;
          *(_DWORD *)&v74[14] = 22;
          _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ADAPTIVE_WRITE_TIMEOUT failed %{darwin.errno}d", v74, 0x12u);
        }
        return 1;
      }
      *(_DWORD *)v74 = 136446466;
      *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_write_timeout";
      *(_WORD *)&v74[12] = 1024;
      *(_DWORD *)&v74[14] = v49;
      v52 = (char *)_os_log_send_and_compose_impl();
      v61[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v66) = 0;
      if (__nwlog_fault(v52, v61, &v66))
      {
        if (v61[0] == OS_LOG_TYPE_FAULT)
        {
          v53 = __nwlog_obj();
          v54 = v61[0];
          if (!os_log_type_enabled(v53, v61[0]))
            goto LABEL_107;
          *(_DWORD *)v74 = 136446466;
          *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_write_timeout";
          *(_WORD *)&v74[12] = 1024;
          *(_DWORD *)&v74[14] = v49;
          v55 = "%{public}s setsockopt TCP_ADAPTIVE_WRITE_TIMEOUT failed %{darwin.errno}d";
          goto LABEL_106;
        }
        if (!(_BYTE)v66)
        {
          v53 = __nwlog_obj();
          v54 = v61[0];
          if (!os_log_type_enabled(v53, v61[0]))
            goto LABEL_107;
          *(_DWORD *)v74 = 136446466;
          *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_write_timeout";
          *(_WORD *)&v74[12] = 1024;
          *(_DWORD *)&v74[14] = v49;
          v55 = "%{public}s setsockopt TCP_ADAPTIVE_WRITE_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_106;
        }
        v56 = (char *)__nw_create_backtrace_string();
        v53 = __nwlog_obj();
        v54 = v61[0];
        v57 = os_log_type_enabled(v53, v61[0]);
        if (v56)
        {
          if (v57)
          {
            *(_DWORD *)v74 = 136446722;
            *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_write_timeout";
            *(_WORD *)&v74[12] = 1024;
            *(_DWORD *)&v74[14] = v49;
            *(_WORD *)&v74[18] = 2082;
            *(_QWORD *)&v74[20] = v56;
            _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s setsockopt TCP_ADAPTIVE_WRITE_TIMEOUT failed %{darwin.errno}d, dumping backtrace:%{public}s", v74, 0x1Cu);
          }
          free(v56);
          goto LABEL_107;
        }
        if (v57)
        {
          *(_DWORD *)v74 = 136446466;
          *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_write_timeout";
          *(_WORD *)&v74[12] = 1024;
          *(_DWORD *)&v74[14] = v49;
          v55 = "%{public}s setsockopt TCP_ADAPTIVE_WRITE_TIMEOUT failed %{darwin.errno}d, no backtrace";
LABEL_106:
          _os_log_impl(&dword_182FBE000, v53, v54, v55, v74, 0x12u);
        }
      }
LABEL_107:
      if (v52)
        free(v52);
      return 1;
    }
    v37 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v38 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v74 = 136446722;
      *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
      *(_WORD *)&v74[12] = 2080;
      *(_QWORD *)&v74[14] = a1 + 340;
      *(_WORD *)&v74[22] = 1024;
      *(_DWORD *)&v74[24] = v37;
      _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d", v74, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = gLogObj;
    if (v37 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v74 = 136446466;
        *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = 22;
        _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d", v74, 0x12u);
      }
      goto LABEL_82;
    }
    *(_DWORD *)v74 = 136446466;
    *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
    *(_WORD *)&v74[12] = 1024;
    *(_DWORD *)&v74[14] = v37;
    v42 = (char *)_os_log_send_and_compose_impl();
    v61[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v66) = 0;
    if (__nwlog_fault(v42, v61, &v66))
    {
      if (v61[0] == OS_LOG_TYPE_FAULT)
      {
        v43 = __nwlog_obj();
        v44 = v61[0];
        if (!os_log_type_enabled(v43, v61[0]))
          goto LABEL_80;
        *(_DWORD *)v74 = 136446466;
        *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = v37;
        v45 = "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d";
        goto LABEL_79;
      }
      if (!(_BYTE)v66)
      {
        v43 = __nwlog_obj();
        v44 = v61[0];
        if (!os_log_type_enabled(v43, v61[0]))
          goto LABEL_80;
        *(_DWORD *)v74 = 136446466;
        *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = v37;
        v45 = "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_79;
      }
      v46 = (char *)__nw_create_backtrace_string();
      v43 = __nwlog_obj();
      v44 = v61[0];
      v47 = os_log_type_enabled(v43, v61[0]);
      if (v46)
      {
        if (v47)
        {
          *(_DWORD *)v74 = 136446722;
          *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
          *(_WORD *)&v74[12] = 1024;
          *(_DWORD *)&v74[14] = v37;
          *(_WORD *)&v74[18] = 2082;
          *(_QWORD *)&v74[20] = v46;
          _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d, dumping backtrace:%{public}s", v74, 0x1Cu);
        }
        free(v46);
        goto LABEL_80;
      }
      if (v47)
      {
        *(_DWORD *)v74 = 136446466;
        *(_QWORD *)&v74[4] = "nw_socket_set_adaptive_read_timeout";
        *(_WORD *)&v74[12] = 1024;
        *(_DWORD *)&v74[14] = v37;
        v45 = "%{public}s setsockopt TCP_ADAPTIVE_READ_TIMEOUT failed %{darwin.errno}d, no backtrace";
LABEL_79:
        _os_log_impl(&dword_182FBE000, v43, v44, v45, v74, 0x12u);
      }
    }
LABEL_80:
    if (v42)
      free(v42);
    goto LABEL_82;
  }
  if ((*(_WORD *)(a1 + 333) & 0x80) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v40 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v74 = 136446466;
      *(_QWORD *)&v74[4] = "nw_socket_add_socket_events";
      *(_WORD *)&v74[12] = 2082;
      *(_QWORD *)&v74[14] = a1 + 340;
      _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s error in adding socket event source", v74, 0x16u);
    }
  }
  result = 0;
  *(_QWORD *)(a1 + 104) = v7;
  return result;
}

BOOL nw_parameters_get_fast_open_enabled(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  _BOOL4 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = (LOBYTE(v1[12].isa) >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_fast_open_enabled";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_fast_open_enabled";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_fast_open_enabled";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_fast_open_enabled";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_fast_open_enabled";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

uint64_t nw_socket_get_path(nw_protocol *a1)
{
  nw_protocol_identifier *identifier;
  uint64_t v3;
  uint64_t (*v4)(nw_protocol_identifier *);
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (**v11)(_QWORD);
  const void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_path";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_path";
      v16 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v21)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_socket_get_path";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_socket_get_path";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v13)
          return 0;
        goto LABEL_55;
      }
      if (!v18)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_path";
      v16 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_53:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_54;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_path";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_path";
      v16 = "%{public}s called with null socket_handler";
      goto LABEL_53;
    }
    if (!v21)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_path";
      v16 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_53;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v20 = os_log_type_enabled(v14, type);
    if (!v19)
    {
      if (!v20)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_path";
      v16 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_53;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_socket_get_path";
      v25 = 2082;
      v26 = v19;
      _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v19);
LABEL_54:
    if (!v13)
      return 0;
LABEL_55:
    free(v13);
    return 0;
  }
  identifier = a1[2].identifier;
  if (!identifier)
  {
    if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_socket_get_path";
        v25 = 2082;
        v26 = (char *)&a1[6].default_input_handler + 4;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
      }
    }
    return 0;
  }
  v3 = *(_QWORD *)&identifier->name[24];
  if (!v3)
    return 0;
  v4 = *(uint64_t (**)(nw_protocol_identifier *))(v3 + 120);
  if (!v4)
    return 0;
  if (*(_UNKNOWN **)identifier[1].name != &nw_protocol_ref_counted_handle)
    return v4(a1[2].identifier);
  v8 = *(_QWORD *)&identifier[2].name[8];
  if (v8)
    *(_QWORD *)&identifier[2].name[8] = v8 + 1;
  v7 = v4(identifier);
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    v9 = *(_QWORD *)&identifier[2].name[8];
    if (v9)
    {
      v10 = v9 - 1;
      *(_QWORD *)&identifier[2].name[8] = v10;
      if (!v10)
      {
        v11 = *(void (***)(_QWORD))&identifier[1].name[24];
        if (v11)
        {
          *(_QWORD *)&identifier[1].name[24] = 0;
          v11[2](v11);
          _Block_release(v11);
        }
        if ((identifier[1].level & 1) != 0)
        {
          v12 = *(const void **)&identifier[1].name[24];
          if (v12)
            _Block_release(v12);
        }
        free(identifier);
      }
    }
  }
  return v7;
}

uint64_t nw_socket_get_parameters(nw_protocol *a1)
{
  nw_protocol_identifier *identifier;
  uint64_t v3;
  uint64_t (*v4)(nw_protocol_identifier *);
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (**v11)(_QWORD);
  const void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_parameters";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_parameters";
      v16 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v21)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_socket_get_parameters";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_socket_get_parameters";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v13)
          return 0;
        goto LABEL_55;
      }
      if (!v18)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_parameters";
      v16 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_53:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_54;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_parameters";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_parameters";
      v16 = "%{public}s called with null socket_handler";
      goto LABEL_53;
    }
    if (!v21)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_parameters";
      v16 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_53;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v20 = os_log_type_enabled(v14, type);
    if (!v19)
    {
      if (!v20)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_parameters";
      v16 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_53;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_socket_get_parameters";
      v25 = 2082;
      v26 = v19;
      _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v19);
LABEL_54:
    if (!v13)
      return 0;
LABEL_55:
    free(v13);
    return 0;
  }
  identifier = a1[2].identifier;
  if (!identifier)
  {
    if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_socket_get_parameters";
        v25 = 2082;
        v26 = (char *)&a1[6].default_input_handler + 4;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
      }
    }
    return 0;
  }
  v3 = *(_QWORD *)&identifier->name[24];
  if (!v3)
    return 0;
  v4 = *(uint64_t (**)(nw_protocol_identifier *))(v3 + 112);
  if (!v4)
    return 0;
  if (*(_UNKNOWN **)identifier[1].name != &nw_protocol_ref_counted_handle)
    return v4(a1[2].identifier);
  v8 = *(_QWORD *)&identifier[2].name[8];
  if (v8)
    *(_QWORD *)&identifier[2].name[8] = v8 + 1;
  v7 = v4(identifier);
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    v9 = *(_QWORD *)&identifier[2].name[8];
    if (v9)
    {
      v10 = v9 - 1;
      *(_QWORD *)&identifier[2].name[8] = v10;
      if (!v10)
      {
        v11 = *(void (***)(_QWORD))&identifier[1].name[24];
        if (v11)
        {
          *(_QWORD *)&identifier[1].name[24] = 0;
          v11[2](v11);
          _Block_release(v11);
        }
        if ((identifier[1].level & 1) != 0)
        {
          v12 = *(const void **)&identifier[1].name[24];
          if (v12)
            _Block_release(v12);
        }
        free(identifier);
      }
    }
  }
  return v7;
}

uint64_t nw_socket_get_local(nw_protocol *a1)
{
  nw_protocol_identifier *identifier;
  uint64_t v3;
  uint64_t (*v4)(nw_protocol_identifier *);
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (**v11)(_QWORD);
  const void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_local";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_local";
      v16 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v21)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_socket_get_local";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_socket_get_local";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v13)
          return 0;
        goto LABEL_55;
      }
      if (!v18)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_local";
      v16 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_53:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_54;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_socket_get_local";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_local";
      v16 = "%{public}s called with null socket_handler";
      goto LABEL_53;
    }
    if (!v21)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_local";
      v16 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_53;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v20 = os_log_type_enabled(v14, type);
    if (!v19)
    {
      if (!v20)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_socket_get_local";
      v16 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_53;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_socket_get_local";
      v25 = 2082;
      v26 = v19;
      _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v19);
LABEL_54:
    if (!v13)
      return 0;
LABEL_55:
    free(v13);
    return 0;
  }
  identifier = a1[2].identifier;
  if (!identifier)
  {
    if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_socket_get_local";
        v25 = 2082;
        v26 = (char *)&a1[6].default_input_handler + 4;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler", buf, 0x16u);
      }
    }
    return 0;
  }
  v3 = *(_QWORD *)&identifier->name[24];
  if (!v3)
    return 0;
  v4 = *(uint64_t (**)(nw_protocol_identifier *))(v3 + 128);
  if (!v4)
    return 0;
  if (*(_UNKNOWN **)identifier[1].name != &nw_protocol_ref_counted_handle)
    return v4(a1[2].identifier);
  v8 = *(_QWORD *)&identifier[2].name[8];
  if (v8)
    *(_QWORD *)&identifier[2].name[8] = v8 + 1;
  v7 = v4(identifier);
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    v9 = *(_QWORD *)&identifier[2].name[8];
    if (v9)
    {
      v10 = v9 - 1;
      *(_QWORD *)&identifier[2].name[8] = v10;
      if (!v10)
      {
        v11 = *(void (***)(_QWORD))&identifier[1].name[24];
        if (v11)
        {
          *(_QWORD *)&identifier[1].name[24] = 0;
          v11[2](v11);
          _Block_release(v11);
        }
        if ((identifier[1].level & 1) != 0)
        {
          v12 = *(const void **)&identifier[1].name[24];
          if (v12)
            _Block_release(v12);
        }
        free(identifier);
      }
    }
  }
  return v7;
}

void nw_endpoint_enumerate_cnames(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  unsigned __int8 *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD v21[4];
  id v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_endpoint_enumerate_cnames";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_enumerate_cnames";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_endpoint_enumerate_cnames";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v8)
          goto LABEL_5;
LABEL_40:
        free(v8);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_enumerate_cnames";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_endpoint_enumerate_cnames";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v4)
  {
    v6 = (unsigned __int8 *)v3[15];
    if (v6)
    {
      v21[0] = MEMORY[0x1E0C809B0];
      v21[1] = 3221225472;
      v21[2] = __nw_endpoint_enumerate_cnames_block_invoke;
      v21[3] = &unk_1E14AC278;
      v22 = v4;
      nw_array_apply(v6, (uint64_t)v21);

    }
    goto LABEL_5;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_endpoint_enumerate_cnames";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_endpoint_enumerate_cnames";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v23)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_endpoint_enumerate_cnames";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_endpoint_enumerate_cnames";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_endpoint_enumerate_cnames";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_40;
LABEL_5:

}

void nw_log_ring_append(uint64_t a1, unint64_t a2, char *__src)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  os_log_type_t v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v20;
  size_t v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  char *backtrace_string;
  _BOOL4 v26;
  uint64_t v27;
  char *v28;
  _BOOL4 v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char v33;
  os_log_type_t type;
  int __srca;
  const char *v36;
  __int16 v37;
  unint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)a1;
  if (a2 + 1 > *(_QWORD *)a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = *(_QWORD *)a1;
    __srca = 136446722;
    v36 = "nw_log_ring_append";
    v37 = 2048;
    v38 = a2;
    v39 = 2048;
    v40 = v6;
    v7 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v7, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v10 = *(_QWORD *)a1;
          __srca = 136446722;
          v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = v10;
          v11 = "%{public}s Trying to insert %zu bytes in ring of %zu bytes";
LABEL_34:
          _os_log_impl(&dword_182FBE000, v8, v9, v11, (uint8_t *)&__srca, 0x20u);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        v26 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v26)
          {
            v27 = *(_QWORD *)a1;
            __srca = 136446978;
            v36 = "nw_log_ring_append";
            v37 = 2048;
            v38 = a2;
            v39 = 2048;
            v40 = v27;
            v41 = 2082;
            v42 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s Trying to insert %zu bytes in ring of %zu bytes, dumping backtrace:%{public}s", (uint8_t *)&__srca, 0x2Au);
          }
          free(backtrace_string);
          goto LABEL_35;
        }
        if (v26)
        {
          v31 = *(_QWORD *)a1;
          __srca = 136446722;
          v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = v31;
          v11 = "%{public}s Trying to insert %zu bytes in ring of %zu bytes, no backtrace";
          goto LABEL_34;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v30 = *(_QWORD *)a1;
          __srca = 136446722;
          v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = v30;
          v11 = "%{public}s Trying to insert %zu bytes in ring of %zu bytes, backtrace limit exceeded";
          goto LABEL_34;
        }
      }
    }
LABEL_35:
    if (!v7)
      return;
    v32 = (char *)v7;
LABEL_44:
    free(v32);
    return;
  }
  if (a2 >= 0x100)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __srca = 136446722;
    v36 = "nw_log_ring_append";
    v37 = 2048;
    v38 = a2;
    v39 = 2048;
    v40 = 255;
    v12 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v12, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          __srca = 136446722;
          v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = 255;
          v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu";
LABEL_41:
          _os_log_impl(&dword_182FBE000, v13, v14, v15, (uint8_t *)&__srca, 0x20u);
        }
      }
      else if (v33)
      {
        v28 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type;
        v29 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v28)
        {
          if (v29)
          {
            __srca = 136446978;
            v36 = "nw_log_ring_append";
            v37 = 2048;
            v38 = a2;
            v39 = 2048;
            v40 = 255;
            v41 = 2082;
            v42 = v28;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, dumping backtrace:%{public}s", (uint8_t *)&__srca, 0x2Au);
          }
          free(v28);
          goto LABEL_42;
        }
        if (v29)
        {
          __srca = 136446722;
          v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = 255;
          v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, no backtrace";
          goto LABEL_41;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          __srca = 136446722;
          v36 = "nw_log_ring_append";
          v37 = 2048;
          v38 = a2;
          v39 = 2048;
          v40 = 255;
          v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
    }
LABEL_42:
    if (!v12)
      return;
    v32 = (char *)v12;
    goto LABEL_44;
  }
  LOBYTE(__srca) = a2;
  v17 = a1 + 17;
  v18 = *(_QWORD *)(a1 + 8);
  v19 = (void *)(a1 + 17 + v18);
  v20 = v5 - v18;
  if (v5 - v18 >= a2)
    v21 = a2;
  else
    v21 = v5 - v18;
  memcpy(v19, __src, v21);
  v22 = *(_QWORD *)(a1 + 8) + v21;
  *(_QWORD *)(a1 + 8) = v22;
  if (v20 < a2)
  {
    v22 = a2 - v21;
    memcpy((void *)(a1 + 17), &__src[v21], a2 - v21);
    *(_QWORD *)(a1 + 8) = a2 - v21;
    *(_BYTE *)(a1 + 16) = 1;
  }
  v23 = *(_QWORD *)a1;
  memcpy((void *)(v17 + v22), &__srca, *(_QWORD *)a1 != v22);
  v24 = *(_QWORD *)(a1 + 8);
  if (v23 != v22)
    ++v24;
  *(_QWORD *)(a1 + 8) = v24;
  if (v23 == v22)
  {
    *(_BYTE *)(a1 + 17) = a2;
    *(_QWORD *)(a1 + 8) = 1;
    *(_BYTE *)(a1 + 16) = 1;
  }
}

uint64_t getEnumTagSinglePayload for NWActivity.CompletionReason(uint64_t a1, int a2)
{
  if (a2 && *(_BYTE *)(a1 + 17))
    return (*(_DWORD *)a1 + 1);
  else
    return 0;
}

void nw_connection_increment_estimated_bytes(void *a1, char a2, uint64_t a3)
{
  id v5;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_connection_increment_estimated_bytes";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_connection_increment_estimated_bytes";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_connection_increment_estimated_bytes";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_connection_increment_estimated_bytes";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_connection_increment_estimated_bytes";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a3)
  {
    nw_connection_modify_estimated_bytes(v5, a2, 1, a3);
    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_connection_increment_estimated_bytes";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v8, &type, &v21))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_connection_increment_estimated_bytes";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null estimated_bytes", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v21)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_connection_increment_estimated_bytes";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null estimated_bytes, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_connection_increment_estimated_bytes";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null estimated_bytes, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_connection_increment_estimated_bytes";
    v25 = 2082;
    v26 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null estimated_bytes, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

void sub_1830EA10C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_connection_modify_estimated_bytes(void *a1, char a2, char a3, uint64_t a4)
{
  id v7;
  id v8;
  _QWORD v9[4];
  id v10;
  uint64_t v11;
  char v12;
  char v13;

  v7 = a1;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __nw_connection_modify_estimated_bytes_block_invoke;
  v9[3] = &unk_1E14AAEA0;
  v12 = a2;
  v8 = v7;
  v13 = a3;
  v10 = v8;
  v11 = a4;
  nw_connection_async_if_needed(v8, v9);

}

void sub_1830EA1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void __nw_connection_modify_estimated_bytes_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const char *v14;
  BOOL v15;
  int *v16;
  uint64_t v17;
  const char *v18;
  unint64_t int64_with_default;
  unint64_t v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  BOOL v24;
  BOOL v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  const char *v48;
  __int16 v49;
  _BYTE v50[34];
  __int16 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 48))
  {
    v4 = *(_QWORD *)(v2 + 304);
    if (*(_BYTE *)(a1 + 49))
    {
      *(_QWORD *)(v2 + 304) = v4 + v3;
      if (!__CFADD__(v4, v3))
        goto LABEL_22;
      if (!gLogDatapath)
      {
        v5 = -1;
LABEL_20:
        v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
        goto LABEL_21;
      }
      __nwlog_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v41 = *(_QWORD *)(a1 + 40);
        v42 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 304);
        v47 = 136446978;
        v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        v49 = 2082;
        *(_QWORD *)v50 = "connection->estimated_bytes_upload";
        *(_WORD *)&v50[8] = 2048;
        *(_QWORD *)&v50[10] = v41;
        *(_WORD *)&v50[18] = 2048;
        *(_QWORD *)&v50[20] = v42;
        _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", (uint8_t *)&v47, 0x2Au);
      }
      v5 = -1;
    }
    else
    {
      *(_QWORD *)(v2 + 304) = v4 - v3;
      if (v4 >= v3)
      {
LABEL_22:
        v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
        goto LABEL_23;
      }
      if (!gLogDatapath)
      {
        v5 = 0;
        goto LABEL_20;
      }
      __nwlog_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v45 = *(_QWORD *)(a1 + 40);
        v46 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 304);
        v47 = 136446978;
        v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        v49 = 2082;
        *(_QWORD *)v50 = "connection->estimated_bytes_upload";
        *(_WORD *)&v50[8] = 2048;
        *(_QWORD *)&v50[10] = v45;
        *(_WORD *)&v50[18] = 2048;
        *(_QWORD *)&v50[20] = v46;
        _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", (uint8_t *)&v47, 0x2Au);
      }
      v5 = 0;
    }
    v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
    goto LABEL_87;
  }
  v4 = *(_QWORD *)(v2 + 296);
  if (*(_BYTE *)(a1 + 49))
  {
    *(_QWORD *)(v2 + 296) = v4 + v3;
    if (!__CFADD__(v4, v3))
      goto LABEL_16;
    if (!gLogDatapath)
    {
      v5 = -1;
LABEL_15:
      v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
LABEL_21:
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + *v6) = v5;
      goto LABEL_23;
    }
    __nwlog_obj();
    v38 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      v39 = *(_QWORD *)(a1 + 40);
      v40 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 296);
      v47 = 136446978;
      v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      v49 = 2082;
      *(_QWORD *)v50 = "connection->estimated_bytes_download";
      *(_WORD *)&v50[8] = 2048;
      *(_QWORD *)&v50[10] = v39;
      *(_WORD *)&v50[18] = 2048;
      *(_QWORD *)&v50[20] = v40;
      _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", (uint8_t *)&v47, 0x2Au);
    }
    v5 = -1;
LABEL_82:
    v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
LABEL_87:

    goto LABEL_21;
  }
  *(_QWORD *)(v2 + 296) = v4 - v3;
  if (v4 < v3)
  {
    if (!gLogDatapath)
    {
      v5 = 0;
      goto LABEL_15;
    }
    __nwlog_obj();
    v38 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      v43 = *(_QWORD *)(a1 + 40);
      v44 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 296);
      v47 = 136446978;
      v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      v49 = 2082;
      *(_QWORD *)v50 = "connection->estimated_bytes_download";
      *(_WORD *)&v50[8] = 2048;
      *(_QWORD *)&v50[10] = v43;
      *(_WORD *)&v50[18] = 2048;
      *(_QWORD *)&v50[20] = v44;
      _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", (uint8_t *)&v47, 0x2Au);
    }
    v5 = 0;
    goto LABEL_82;
  }
LABEL_16:
  v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
LABEL_23:
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(v7 + *v6);
  v9 = *(_QWORD *)(v7 + 16);
  if (v9 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v9 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v10 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v11 = *(_QWORD *)(a1 + 32);
      v12 = *(_QWORD *)(a1 + 40);
      v13 = *(_DWORD *)(v11 + 448);
      if (*(_BYTE *)(a1 + 49))
        v14 = "Incremented";
      else
        v14 = "Decremented";
      v15 = *(_BYTE *)(a1 + 48) == 0;
      v16 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
      if (!*(_BYTE *)(a1 + 48))
        v16 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
      v17 = *(_QWORD *)(v11 + *v16);
      v18 = "receive";
      v47 = 136447490;
      v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      v49 = 1024;
      if (v15)
        v18 = "send";
      *(_DWORD *)v50 = v13;
      *(_WORD *)&v50[4] = 2080;
      *(_QWORD *)&v50[6] = v14;
      *(_WORD *)&v50[14] = 2080;
      *(_QWORD *)&v50[16] = v18;
      *(_WORD *)&v50[24] = 2048;
      *(_QWORD *)&v50[26] = v12;
      v51 = 2048;
      v52 = v17;
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] %s estimated bytes to %s by %llu, total now %llu", (uint8_t *)&v47, 0x3Au);
    }

  }
  int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_estimated_byte_threshold_lower, 12582912);
  v20 = networkd_settings_get_int64_with_default((const char *)nw_setting_estimated_byte_threshold_upper, 31457280);
  v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  if (v21 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v21 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v22 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      v23 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
      v47 = 136446978;
      v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      v49 = 1024;
      *(_DWORD *)v50 = v23;
      *(_WORD *)&v50[4] = 2048;
      *(_QWORD *)&v50[6] = int64_with_default;
      *(_WORD *)&v50[14] = 2048;
      *(_QWORD *)&v50[16] = v20;
      _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Using lower threshold %llu, upper threshold %llu", (uint8_t *)&v47, 0x26u);
    }

  }
  v24 = v4 < int64_with_default && v8 > int64_with_default;
  if (v24 || (v4 > int64_with_default ? (v25 = v8 >= int64_with_default) : (v25 = 1), !v25))
  {
    v26 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
    if (v26 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v26 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v27 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        v28 = *(_QWORD *)(a1 + 32);
        v29 = *(_DWORD *)(v28 + 448);
        v31 = *(_QWORD *)(v28 + 296);
        v30 = *(_QWORD *)(v28 + 304);
        v47 = 136446978;
        v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        v49 = 1024;
        *(_DWORD *)v50 = v29;
        *(_WORD *)&v50[4] = 2048;
        *(_QWORD *)&v50[6] = v31;
        *(_WORD *)&v50[14] = 2048;
        *(_QWORD *)&v50[16] = v30;
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_INFO, "%{public}s [C%u] Crossed lower estimated byte threshold, sending notification (down: %llu, up: %llu)", (uint8_t *)&v47, 0x26u);
      }

    }
    nw_connection_report_estimated_byte_threshold_change_on_queue(*(NWConcrete_nw_connection **)(a1 + 32), v8, *(unsigned __int8 *)(a1 + 48), v8 > int64_with_default, 0);
  }
  if (v4 < v20 && v8 > v20 || v4 > v20 && v8 < v20)
  {
    v32 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
    if (v32 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v32 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v33 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        v34 = *(_QWORD *)(a1 + 32);
        v35 = *(_DWORD *)(v34 + 448);
        v37 = *(_QWORD *)(v34 + 296);
        v36 = *(_QWORD *)(v34 + 304);
        v47 = 136446978;
        v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        v49 = 1024;
        *(_DWORD *)v50 = v35;
        *(_WORD *)&v50[4] = 2048;
        *(_QWORD *)&v50[6] = v37;
        *(_WORD *)&v50[14] = 2048;
        *(_QWORD *)&v50[16] = v36;
        _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_INFO, "%{public}s [C%u] Crossed upper estimated byte threshold, sending notification (down: %llu, up: %llu)", (uint8_t *)&v47, 0x26u);
      }

    }
    nw_connection_report_estimated_byte_threshold_change_on_queue(*(NWConcrete_nw_connection **)(a1 + 32), v8, *(unsigned __int8 *)(a1 + 48), v8 > v20, 1);
  }
}

uint64_t nw_interface_supports_ack_priority(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 4) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_supports_ack_priority";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_ack_priority";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_supports_ack_priority";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_ack_priority";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_ack_priority";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_supports_tx_start(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 3) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_supports_tx_start";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_tx_start";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_supports_tx_start";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_tx_start";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_tx_start";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_interface_supports_carrier_aggregation(void *a1)
{
  char *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(v1 + 85) >> 5) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_supports_carrier_aggregation";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_carrier_aggregation";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_supports_carrier_aggregation";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_carrier_aggregation";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_supports_carrier_aggregation";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_connection_get_uuid(void *a1, unsigned __int8 *a2)
{
  char *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  void *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  char *v13;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_connection_get_uuid";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v5, &type, &v18))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_connection_get_uuid";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null out_uuid", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_connection_get_uuid";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null out_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5)
          goto LABEL_4;
LABEL_39:
        free(v5);
        goto LABEL_4;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_connection_get_uuid";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null out_uuid, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_connection_get_uuid";
        _os_log_impl(&dword_182FBE000, v6, v16, "%{public}s called with null out_uuid, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  uuid_clear(a2);
  if (v3)
  {
    *(_OWORD *)a2 = *(_OWORD *)(v3 + 452);
    goto LABEL_4;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_connection_get_uuid";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v5, &type, &v18))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v9 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      v21 = "nw_connection_get_uuid";
      _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null connection", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v18)
  {
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      v21 = "nw_connection_get_uuid";
      _os_log_impl(&dword_182FBE000, v6, v17, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v13 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v6 = objc_claimAutoreleasedReturnValue();
  v14 = type;
  v15 = os_log_type_enabled(v6, type);
  if (!v13)
  {
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      v21 = "nw_connection_get_uuid";
      _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "nw_connection_get_uuid";
    v22 = 2082;
    v23 = v13;
    _os_log_impl(&dword_182FBE000, v6, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v5)
    goto LABEL_39;
LABEL_4:

}

void sub_1830EB5C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_establishment_report_enumerate_resolution_reports(nw_establishment_report_t report, nw_report_resolution_report_enumerator_t enumerate_block)
{
  nw_establishment_report_t v3;
  nw_report_resolution_report_enumerator_t v4;
  void *v5;
  unsigned __int8 *isa;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD v21[4];
  id v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = report;
  v4 = enumerate_block;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_establishment_report_enumerate_resolution_reports";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_establishment_report_enumerate_resolution_reports";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_establishment_report_enumerate_resolution_reports";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8)
          goto LABEL_4;
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_establishment_report_enumerate_resolution_reports";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_establishment_report_enumerate_resolution_reports";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    isa = (unsigned __int8 *)v3[9].isa;
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = __nw_establishment_report_enumerate_resolution_reports_block_invoke;
    v21[3] = &unk_1E14AC278;
    v22 = v4;
    nw_array_apply(isa, (uint64_t)v21);

    goto LABEL_4;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_establishment_report_enumerate_resolution_reports";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_establishment_report_enumerate_resolution_reports";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_establishment_report_enumerate_resolution_reports";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_establishment_report_enumerate_resolution_reports";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_establishment_report_enumerate_resolution_reports";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_39;
LABEL_4:

}

void sub_1830EBB80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  unsigned int mode;
  id *v4;
  id v5;
  int pid_to_uuid_mapping_failed;
  int bundle_id_to_uuid_mapping_failed;
  pid_t v8;
  uint64_t v9;
  int v10;
  id *v11;
  char v12;
  id v13;
  id *v14;
  id *v15;
  char v16;
  const char *v17;
  nw_endpoint_t v18;
  const char *logging_description;
  unsigned int *v20;
  unsigned int *v21;
  uint64_t v22;
  const char *v23;
  int v24;
  id *v25;
  char v26;
  id v27;
  id *v28;
  id *v29;
  char v30;
  const char *v31;
  nw_endpoint_t v32;
  const char *v33;
  char *v34;
  unsigned int *v35;
  unsigned int *v36;
  uint64_t v37;
  const char *v38;
  int v39;
  char logging_disabled;
  const char *v41;
  const char *v42;
  nw_endpoint_t v43;
  const char *v44;
  const char *v45;
  const char *v46;
  id v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  const char *v51;
  const char *v52;
  nw_endpoint_t v53;
  const char *v54;
  const char *v55;
  const char *v56;
  id v57;
  int v58;
  NSObject *v59;
  id *v60;
  id *v61;
  char v62;
  const char *v63;
  nw_endpoint_t v64;
  const char *v65;
  char *v66;
  unsigned int *v67;
  unsigned int *v68;
  uint64_t v69;
  const char *v70;
  int v71;
  id *v72;
  BOOL v73;
  id v74;
  id *v75;
  id *v76;
  _BOOL4 v77;
  const char *v78;
  nw_endpoint_t v79;
  const char *v80;
  unsigned int *v81;
  unsigned int *v82;
  uint64_t v83;
  const char *v84;
  const char *v85;
  const char *v86;
  nw_endpoint_t v87;
  const char *v88;
  const char *v89;
  const char *v90;
  id v91;
  void **v92;
  void **v93;
  const char *v94;
  const char *v95;
  const char *v96;
  nw_endpoint_t v97;
  const char *v98;
  const char *v99;
  const char *v100;
  id v101;
  void **v102;
  void **v103;
  const char *v104;
  void **v105;
  void **v106;
  const char *v107;
  nw_endpoint_t v108;
  _BOOL8 domain_for_policy;
  _BOOL8 v110;
  void *v111;
  id *v112;
  void **v113;
  void **v114;
  const char *v115;
  void **v116;
  id v117;
  id v118;
  char *v119;
  NSObject *v120;
  os_log_type_t v121;
  const char *id_string;
  const char *v123;
  nw_endpoint_t v124;
  const char *v125;
  const char *v126;
  const char *v127;
  id v128;
  int pid;
  uint64_t effective_bundle_id;
  const char *v131;
  char *v132;
  NSObject *v133;
  os_log_type_t v134;
  const char *v135;
  const char *v136;
  const char *v137;
  const char *v138;
  const char *v139;
  id v140;
  int v141;
  uint64_t v142;
  os_log_type_t v143;
  const char *v144;
  const char *v145;
  nw_endpoint_t v146;
  const char *v147;
  const char *v148;
  const char *v149;
  id v150;
  int v151;
  uint64_t v152;
  const char *v153;
  char *v154;
  NSObject *v155;
  os_log_type_t v156;
  const char *v157;
  const char *v158;
  const char *v159;
  const char *v160;
  const char *v161;
  id v162;
  int v163;
  os_log_type_t v164;
  const char *v165;
  const char *v166;
  nw_endpoint_t v167;
  const char *v168;
  const char *v169;
  const char *v170;
  id v171;
  int v172;
  uint64_t v173;
  NSObject *v174;
  const char *v175;
  const char *v176;
  nw_endpoint_t v177;
  const char *v178;
  const char *v179;
  const char *v180;
  id v181;
  void **v182;
  id v183;
  id v184;
  NSObject *v185;
  os_log_type_t v186;
  const char *v187;
  const char *v188;
  nw_endpoint_t v189;
  const char *v190;
  const char *v191;
  const char *v192;
  id v193;
  uint64_t v194;
  const char *v195;
  char *v196;
  NSObject *v197;
  os_log_type_t v198;
  const char *v199;
  const char *v200;
  const char *v201;
  const char *v202;
  const char *v203;
  const char *v204;
  id v205;
  uint64_t v206;
  os_log_type_t v207;
  const char *v208;
  const char *v209;
  nw_endpoint_t v210;
  const char *v211;
  const char *v212;
  const char *v213;
  id v214;
  uint64_t v215;
  void **v216;
  id v217;
  id v218;
  id *v219;
  _BOOL4 v220;
  NSObject *v221;
  id *v222;
  id *v223;
  _BOOL4 v224;
  const char *v225;
  nw_endpoint_t v226;
  const char *v227;
  unsigned int *v228;
  unsigned int *v229;
  uint64_t v230;
  const char *v231;
  void **v232;
  const char *v233;
  nw_endpoint_t v234;
  const char *v235;
  const char *v236;
  void **v237;
  id v238;
  void **v239;
  id v240;
  id v241;
  const char *description;
  char *v243;
  NSObject *v244;
  os_log_type_t v245;
  const char *v246;
  const char *v247;
  nw_endpoint_t v248;
  const char *v249;
  const char *v250;
  const char *v251;
  const char *v252;
  id v253;
  const char *v254;
  const char *v255;
  char *v256;
  NSObject *v257;
  os_log_type_t v258;
  const char *v259;
  const char *v260;
  const char *v261;
  const char *v262;
  const char *v263;
  id v264;
  const char *v265;
  os_log_type_t v266;
  const char *v267;
  const char *v268;
  nw_endpoint_t v269;
  const char *v270;
  const char *v271;
  const char *v272;
  id v273;
  const char *v274;
  os_log_type_t v275;
  const char *v276;
  const char *v277;
  nw_endpoint_t v278;
  const char *v279;
  const char *v280;
  const char *v281;
  id v282;
  uint64_t v283;
  NSObject *v284;
  const char *v285;
  const char *v286;
  nw_endpoint_t v287;
  const char *v288;
  const char *v289;
  const char *v290;
  id v291;
  os_log_type_t v292;
  const char *v293;
  const char *v294;
  nw_endpoint_t v295;
  const char *v296;
  const char *v297;
  const char *v298;
  id v299;
  const char *v300;
  os_log_type_t v301;
  const char *v302;
  const char *v303;
  nw_endpoint_t v304;
  const char *v305;
  const char *v306;
  const char *v307;
  id v308;
  int v309;
  os_log_type_t v310;
  const char *v311;
  const char *v312;
  nw_endpoint_t v313;
  const char *v314;
  const char *v315;
  const char *v316;
  id v317;
  int v318;
  void *v319;
  char *v320;
  NSObject *v321;
  os_log_type_t v322;
  char *backtrace_string;
  os_log_type_t v324;
  _BOOL4 v325;
  os_log_type_t v326;
  id v327;
  const char *v328;
  char *v329;
  NSObject *v330;
  os_log_type_t v331;
  const char *v332;
  char *v333;
  os_log_type_t v334;
  _BOOL4 v335;
  const char *v336;
  os_log_type_t v337;
  const char *v338;
  const char *v339;
  const char *v341;
  nw_endpoint_t v342;
  NSObject *v343;
  NSObject *v344;
  NSObject *v345;
  char v346;
  nw_endpoint_t v347;
  const char *log;
  _BOOL8 loga;
  NSObject *logb;
  NSObject *logc;
  NSObject *logd;
  char *v353;
  id v354;
  nw_endpoint_t v355;
  const char *v356;
  nw_endpoint_t v357;
  nw_endpoint_t v358;
  const char *v359;
  void *v360;
  id *v361;
  id *v362;
  id *v363;
  NWConcrete_nw_endpoint_handler *v364;
  _QWORD applier[4];
  id *v366;
  os_log_type_t *v367;
  size_t v368;
  _BOOL8 v369;
  os_log_type_t type[8];
  os_log_type_t *v371;
  uint64_t v372;
  char v373;
  char v374;
  uint8_t buf[4];
  const char *v376;
  __int16 v377;
  char *v378;
  __int16 v379;
  const char *v380;
  __int16 v381;
  void *v382;
  __int16 v383;
  const char *v384;
  __int16 v385;
  const char *v386;
  __int16 v387;
  id v388;
  __int16 v389;
  _BYTE v390[34];
  uint64_t v391;

  v391 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v364 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v319 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v376 = "nw_endpoint_handler_get_mode";
    v320 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v374 = 0;
    if (__nwlog_fault(v320, type, &v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v321 = objc_claimAutoreleasedReturnValue();
        v322 = type[0];
        if (os_log_type_enabled(v321, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v376 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v321, v322, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v374)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v321 = objc_claimAutoreleasedReturnValue();
        v324 = type[0];
        v325 = os_log_type_enabled(v321, type[0]);
        if (backtrace_string)
        {
          if (v325)
          {
            *(_DWORD *)buf = 136446466;
            v376 = "nw_endpoint_handler_get_mode";
            v377 = 2082;
            v378 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v321, v324, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_265;
        }
        if (v325)
        {
          *(_DWORD *)buf = 136446210;
          v376 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v321, v324, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v321 = objc_claimAutoreleasedReturnValue();
        v326 = type[0];
        if (os_log_type_enabled(v321, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v376 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v321, v326, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_265:
    if (v320)
      free(v320);
    mode = 0;
LABEL_268:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v327 = (id)gLogObj;
    if (mode > 5)
      v328 = "unknown-mode";
    else
      v328 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v376 = "nw_endpoint_flow_validate_delegation";
    v377 = 2082;
    v378 = (char *)v328;
    v379 = 2082;
    v380 = "flow";
    v329 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v374 = 0;
    if (__nwlog_fault(v329, type, &v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v330 = (id)gLogObj;
        v331 = type[0];
        if (os_log_type_enabled(v330, type[0]))
        {
          if (mode > 5)
            v332 = "unknown-mode";
          else
            v332 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v332;
          v379 = 2082;
          v380 = "flow";
          _os_log_impl(&dword_182FBE000, v330, v331, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v374)
      {
        v333 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v330 = (id)gLogObj;
        v334 = type[0];
        v335 = os_log_type_enabled(v330, type[0]);
        if (v333)
        {
          if (v335)
          {
            if (mode > 5)
              v336 = "unknown-mode";
            else
              v336 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446978;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)v336;
            v379 = 2082;
            v380 = "flow";
            v381 = 2082;
            v382 = v333;
            _os_log_impl(&dword_182FBE000, v330, v334, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v333);
          if (!v329)
            goto LABEL_302;
          goto LABEL_301;
        }
        if (v335)
        {
          if (mode > 5)
            v339 = "unknown-mode";
          else
            v339 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v339;
          v379 = 2082;
          v380 = "flow";
          _os_log_impl(&dword_182FBE000, v330, v334, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v330 = (id)gLogObj;
        v337 = type[0];
        if (os_log_type_enabled(v330, type[0]))
        {
          if (mode > 5)
            v338 = "unknown-mode";
          else
            v338 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v338;
          v379 = 2082;
          v380 = "flow";
          _os_log_impl(&dword_182FBE000, v330, v337, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
    if (!v329)
    {
LABEL_302:
      v9 = 0;
      goto LABEL_303;
    }
LABEL_301:
    free(v329);
    goto LABEL_302;
  }
  v2 = v1;
  mode = v1->mode;

  if (mode != 2)
    goto LABEL_268;
  v4 = v2;
  v5 = v4[4];

  if (nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::onceToken != -1)
    dispatch_once(&nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::onceToken, &__block_literal_global_209);
  pid_to_uuid_mapping_failed = nw_parameters_get_pid_to_uuid_mapping_failed(v5);
  bundle_id_to_uuid_mapping_failed = nw_parameters_get_bundle_id_to_uuid_mapping_failed(v5);
  if ((pid_to_uuid_mapping_failed & 1) != 0 || bundle_id_to_uuid_mapping_failed)
  {
    v360 = v5;
    if ((pid_to_uuid_mapping_failed & bundle_id_to_uuid_mapping_failed) == 1)
    {
      v10 = _os_feature_enabled_impl();
      v11 = v4;
      v12 = *((_BYTE *)v11 + 268);

      v361 = v4;
      if (v10)
      {
        if ((v12 & 0x20) != 0)
          goto LABEL_168;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v13 = (id)gconnectionLogObj;
        v14 = v11;

        v15 = v14;
        v16 = *((_BYTE *)v11 + 268);

        if ((v16 & 1) != 0)
          v17 = "dry-run ";
        else
          v17 = "";
        v18 = nw_endpoint_handler_copy_endpoint(v15);
        logging_description = nw_endpoint_get_logging_description(v18);
        v353 = (char *)(v14 + 21);
        v20 = v15;
        v21 = v20;
        v22 = v20[30];
        if (v22 > 5)
          v23 = "unknown-state";
        else
          v23 = off_1E149FC48[v22];

        v92 = v21;
        v93 = v92;
        v94 = "path";
        switch(v364->mode)
        {
          case 0:
            break;
          case 1:
            v94 = "resolver";
            break;
          case 2:
            v94 = nw_endpoint_flow_mode_string(v92[31]);
            break;
          case 3:
            v94 = "proxy";
            break;
          case 4:
            v94 = "fallback";
            break;
          case 5:
            v94 = "transform";
            break;
          default:
            v94 = "unknown-mode";
            break;
        }

        v116 = v93;
        os_unfair_lock_lock((os_unfair_lock_t)v116 + 28);
        v117 = v116[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v116 + 28);

        v118 = v117;
        *(_DWORD *)buf = 136448514;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = v353;
        v379 = 2082;
        v380 = v17;
        v381 = 2082;
        v382 = (void *)logging_description;
        v383 = 2082;
        v384 = v23;
        v385 = 2082;
        v386 = v94;
        v387 = 2114;
        v388 = v118;
        v389 = 1024;
        *(_DWORD *)v390 = nw_parameters_get_pid(v360);
        *(_WORD *)&v390[4] = 2082;
        *(_QWORD *)&v390[6] = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[14] = 2082;
        *(_QWORD *)&v390[16] = "I";
        v356 = (const char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v374 = 0;
        v119 = (char *)v356;
        if (!__nwlog_fault(v356, type, &v374))
          goto LABEL_129;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v120 = (id)gconnectionLogObj;
          v121 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            id_string = nw_endpoint_handler_get_id_string(v116);
            v123 = nw_endpoint_handler_dry_run_string(v116);
            logb = v120;
            v124 = nw_endpoint_handler_copy_endpoint(v116);
            v125 = nw_endpoint_get_logging_description(v124);
            v126 = nw_endpoint_handler_state_string(v116);
            v127 = nw_endpoint_handler_mode_string(v116);
            v128 = nw_endpoint_handler_copy_current_path(v116);
            pid = nw_parameters_get_pid(v360);
            effective_bundle_id = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)id_string;
            v379 = 2082;
            v380 = v123;
            v381 = 2082;
            v382 = (void *)v125;
            v383 = 2082;
            v384 = v126;
            v385 = 2082;
            v386 = v127;
            v387 = 2114;
            v388 = v128;
            v389 = 1024;
            *(_DWORD *)v390 = pid;
            *(_WORD *)&v390[4] = 2082;
            *(_QWORD *)&v390[6] = effective_bundle_id;
            *(_WORD *)&v390[14] = 2082;
            *(_QWORD *)&v390[16] = "I";
            _os_log_impl(&dword_182FBE000, logb, v121, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d and Invalid Bundle ID \"%{public}s\" [%{public}s]", buf, 0x62u);

            v120 = logb;
          }
        }
        else if (v374)
        {
          v131 = __nw_create_backtrace_string();
          if (v131)
          {
            v132 = (char *)v131;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v133 = (id)gconnectionLogObj;
            v134 = type[0];
            if (os_log_type_enabled(v133, type[0]))
            {
              v135 = nw_endpoint_handler_get_id_string(v116);
              v136 = nw_endpoint_handler_dry_run_string(v116);
              v347 = nw_endpoint_handler_copy_endpoint(v116);
              v137 = nw_endpoint_get_logging_description(v347);
              v138 = nw_endpoint_handler_state_string(v116);
              v139 = nw_endpoint_handler_mode_string(v116);
              v140 = nw_endpoint_handler_copy_current_path(v116);
              v141 = nw_parameters_get_pid(v360);
              v142 = nw_parameters_get_effective_bundle_id(v360);
              *(_DWORD *)buf = 136448770;
              v376 = "nw_endpoint_flow_validate_delegation";
              v377 = 2082;
              v378 = (char *)v135;
              v379 = 2082;
              v380 = v136;
              v381 = 2082;
              v382 = (void *)v137;
              v383 = 2082;
              v384 = v138;
              v385 = 2082;
              v386 = v139;
              v387 = 2114;
              v388 = v140;
              v389 = 1024;
              *(_DWORD *)v390 = v141;
              *(_WORD *)&v390[4] = 2082;
              *(_QWORD *)&v390[6] = v142;
              *(_WORD *)&v390[14] = 2082;
              *(_QWORD *)&v390[16] = "I";
              *(_WORD *)&v390[24] = 2082;
              *(_QWORD *)&v390[26] = v132;
              _os_log_impl(&dword_182FBE000, v133, v134, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d and Invalid Bundle ID \"%{public}s\" [%{public}s], dumping backtrace:%{public}s", buf, 0x6Cu);

            }
            free(v132);
            goto LABEL_128;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v120 = (id)gconnectionLogObj;
          v164 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            v165 = nw_endpoint_handler_get_id_string(v116);
            v166 = nw_endpoint_handler_dry_run_string(v116);
            logd = v120;
            v167 = nw_endpoint_handler_copy_endpoint(v116);
            v168 = nw_endpoint_get_logging_description(v167);
            v169 = nw_endpoint_handler_state_string(v116);
            v170 = nw_endpoint_handler_mode_string(v116);
            v171 = nw_endpoint_handler_copy_current_path(v116);
            v172 = nw_parameters_get_pid(v360);
            v173 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)v165;
            v379 = 2082;
            v380 = v166;
            v381 = 2082;
            v382 = (void *)v168;
            v383 = 2082;
            v384 = v169;
            v385 = 2082;
            v386 = v170;
            v387 = 2114;
            v388 = v171;
            v389 = 1024;
            *(_DWORD *)v390 = v172;
            *(_WORD *)&v390[4] = 2082;
            *(_QWORD *)&v390[6] = v173;
            *(_WORD *)&v390[14] = 2082;
            *(_QWORD *)&v390[16] = "I";
            _os_log_impl(&dword_182FBE000, logd, v164, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d and Invalid Bundle ID \"%{public}s\" [%{public}s], no backtrace", buf, 0x62u);

            v120 = logd;
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v120 = (id)gconnectionLogObj;
          v143 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            v144 = nw_endpoint_handler_get_id_string(v116);
            v145 = nw_endpoint_handler_dry_run_string(v116);
            logc = v120;
            v146 = nw_endpoint_handler_copy_endpoint(v116);
            v147 = nw_endpoint_get_logging_description(v146);
            v148 = nw_endpoint_handler_state_string(v116);
            v149 = nw_endpoint_handler_mode_string(v116);
            v150 = nw_endpoint_handler_copy_current_path(v116);
            v151 = nw_parameters_get_pid(v360);
            v152 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)v144;
            v379 = 2082;
            v380 = v145;
            v381 = 2082;
            v382 = (void *)v147;
            v383 = 2082;
            v384 = v148;
            v385 = 2082;
            v386 = v149;
            v387 = 2114;
            v388 = v150;
            v389 = 1024;
            *(_DWORD *)v390 = v151;
            *(_WORD *)&v390[4] = 2082;
            *(_QWORD *)&v390[6] = v152;
            *(_WORD *)&v390[14] = 2082;
            *(_QWORD *)&v390[16] = "I";
            _os_log_impl(&dword_182FBE000, logc, v143, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d and Invalid Bundle ID \"%{public}s\" [%{public}s], backtrace limit exceeded", buf, 0x62u);

            v120 = logc;
          }
        }

LABEL_128:
        v119 = (char *)v356;
        goto LABEL_129;
      }
      if ((v12 & 0x20) != 0)
        goto LABEL_168;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v59 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        v60 = v11;

        v61 = v60;
        v62 = *((_BYTE *)v11 + 268);

        if ((v62 & 1) != 0)
          v63 = "dry-run ";
        else
          v63 = "";
        v64 = nw_endpoint_handler_copy_endpoint(v61);
        v65 = nw_endpoint_get_logging_description(v64);
        v66 = (char *)(v60 + 21);
        v67 = v61;
        v68 = v67;
        v69 = v67[30];
        if (v69 > 5)
          v70 = "unknown-state";
        else
          v70 = off_1E149FC48[v69];

        v105 = v68;
        v106 = v105;
        v107 = "path";
        switch(v364->mode)
        {
          case 0:
            break;
          case 1:
            v107 = "resolver";
            break;
          case 2:
            v107 = nw_endpoint_flow_mode_string(v105[31]);
            break;
          case 3:
            v107 = "proxy";
            break;
          case 4:
            v107 = "fallback";
            break;
          case 5:
            v107 = "transform";
            break;
          default:
            v107 = "unknown-mode";
            break;
        }

        v216 = v106;
        os_unfair_lock_lock((os_unfair_lock_t)v216 + 28);
        v217 = v216[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v216 + 28);

        v218 = v217;
        *(_DWORD *)buf = 136448514;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = v66;
        v379 = 2082;
        v380 = v63;
        v381 = 2082;
        v382 = (void *)v65;
        v383 = 2082;
        v384 = v70;
        v385 = 2082;
        v386 = v107;
        v387 = 2114;
        v388 = v218;
        v389 = 1024;
        *(_DWORD *)v390 = nw_parameters_get_pid(v360);
        *(_WORD *)&v390[4] = 2082;
        *(_QWORD *)&v390[6] = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[14] = 2082;
        *(_QWORD *)&v390[16] = "I";
        _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d and Invalid Bundle ID \"%{public}s\" [%{public}s]", buf, 0x62u);

      }
LABEL_167:

      v4 = v361;
      goto LABEL_168;
    }
    if (bundle_id_to_uuid_mapping_failed)
    {
      v24 = _os_feature_enabled_impl();
      v25 = v4;
      v26 = *((_BYTE *)v25 + 268);

      v361 = v4;
      if (v24)
      {
        if ((v26 & 0x20) != 0)
          goto LABEL_168;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v27 = (id)gconnectionLogObj;
        v28 = v25;

        v29 = v28;
        v30 = *((_BYTE *)v25 + 268);

        if ((v30 & 1) != 0)
          v31 = "dry-run ";
        else
          v31 = "";
        v32 = nw_endpoint_handler_copy_endpoint(v29);
        v33 = nw_endpoint_get_logging_description(v32);
        v34 = (char *)(v28 + 21);
        v35 = v29;
        v36 = v35;
        v37 = v35[30];
        if (v37 > 5)
          v38 = "unknown-state";
        else
          v38 = off_1E149FC48[v37];

        v102 = v36;
        v103 = v102;
        v104 = "path";
        switch(v364->mode)
        {
          case 0:
            break;
          case 1:
            v104 = "resolver";
            break;
          case 2:
            v104 = nw_endpoint_flow_mode_string(v102[31]);
            break;
          case 3:
            v104 = "proxy";
            break;
          case 4:
            v104 = "fallback";
            break;
          case 5:
            v104 = "transform";
            break;
          default:
            v104 = "unknown-mode";
            break;
        }

        v182 = v103;
        os_unfair_lock_lock((os_unfair_lock_t)v182 + 28);
        v183 = v182[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v182 + 28);

        v184 = v183;
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = v34;
        v379 = 2082;
        v380 = v31;
        v381 = 2082;
        v382 = (void *)v33;
        v383 = 2082;
        v384 = v38;
        v385 = 2082;
        v386 = v104;
        v387 = 2114;
        v388 = v184;
        v389 = 2082;
        *(_QWORD *)v390 = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[8] = 2082;
        *(_QWORD *)&v390[10] = "I";
        v119 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v374 = 0;
        if (!__nwlog_fault(v119, type, &v374))
          goto LABEL_129;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v185 = (id)gconnectionLogObj;
          v186 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            v187 = nw_endpoint_handler_get_id_string(v182);
            v188 = nw_endpoint_handler_dry_run_string(v182);
            v189 = nw_endpoint_handler_copy_endpoint(v182);
            v190 = nw_endpoint_get_logging_description(v189);
            v191 = nw_endpoint_handler_state_string(v182);
            v192 = nw_endpoint_handler_mode_string(v182);
            v193 = nw_endpoint_handler_copy_current_path(v182);
            v194 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448258;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)v187;
            v379 = 2082;
            v380 = v188;
            v381 = 2082;
            v382 = (void *)v190;
            v383 = 2082;
            v384 = v191;
            v385 = 2082;
            v386 = v192;
            v387 = 2114;
            v388 = v193;
            v389 = 2082;
            *(_QWORD *)v390 = v194;
            *(_WORD *)&v390[8] = 2082;
            *(_QWORD *)&v390[10] = "I";
            _os_log_impl(&dword_182FBE000, v185, v186, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid Bundle ID \"%{public}s\" [%{public}s]", buf, 0x5Cu);

          }
        }
        else if (v374)
        {
          v195 = __nw_create_backtrace_string();
          if (v195)
          {
            v196 = (char *)v195;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v197 = (id)gconnectionLogObj;
            v198 = type[0];
            if (os_log_type_enabled(v197, type[0]))
            {
              v199 = nw_endpoint_handler_get_id_string(v182);
              v200 = nw_endpoint_handler_dry_run_string(v182);
              v201 = v199;
              v358 = nw_endpoint_handler_copy_endpoint(v182);
              v202 = nw_endpoint_get_logging_description(v358);
              v203 = nw_endpoint_handler_state_string(v182);
              v204 = nw_endpoint_handler_mode_string(v182);
              v205 = nw_endpoint_handler_copy_current_path(v182);
              v206 = nw_parameters_get_effective_bundle_id(v360);
              *(_DWORD *)buf = 136448514;
              v376 = "nw_endpoint_flow_validate_delegation";
              v377 = 2082;
              v378 = (char *)v201;
              v379 = 2082;
              v380 = v200;
              v381 = 2082;
              v382 = (void *)v202;
              v383 = 2082;
              v384 = v203;
              v385 = 2082;
              v386 = v204;
              v387 = 2114;
              v388 = v205;
              v389 = 2082;
              *(_QWORD *)v390 = v206;
              *(_WORD *)&v390[8] = 2082;
              *(_QWORD *)&v390[10] = "I";
              *(_WORD *)&v390[18] = 2082;
              *(_QWORD *)&v390[20] = v196;
              _os_log_impl(&dword_182FBE000, v197, v198, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid Bundle ID \"%{public}s\" [%{public}s], dumping backtrace:%{public}s", buf, 0x66u);

            }
            free(v196);
            goto LABEL_129;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v185 = (id)gconnectionLogObj;
          v275 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            v276 = nw_endpoint_handler_get_id_string(v182);
            v277 = nw_endpoint_handler_dry_run_string(v182);
            v278 = nw_endpoint_handler_copy_endpoint(v182);
            v279 = nw_endpoint_get_logging_description(v278);
            v280 = nw_endpoint_handler_state_string(v182);
            v281 = nw_endpoint_handler_mode_string(v182);
            v282 = nw_endpoint_handler_copy_current_path(v182);
            v283 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448258;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)v276;
            v379 = 2082;
            v380 = v277;
            v381 = 2082;
            v382 = (void *)v279;
            v383 = 2082;
            v384 = v280;
            v385 = 2082;
            v386 = v281;
            v387 = 2114;
            v388 = v282;
            v389 = 2082;
            *(_QWORD *)v390 = v283;
            *(_WORD *)&v390[8] = 2082;
            *(_QWORD *)&v390[10] = "I";
            _os_log_impl(&dword_182FBE000, v185, v275, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid Bundle ID \"%{public}s\" [%{public}s], no backtrace", buf, 0x5Cu);

          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v185 = (id)gconnectionLogObj;
          v207 = type[0];
          if (os_log_type_enabled(v185, type[0]))
          {
            v208 = nw_endpoint_handler_get_id_string(v182);
            v209 = nw_endpoint_handler_dry_run_string(v182);
            v210 = nw_endpoint_handler_copy_endpoint(v182);
            v211 = nw_endpoint_get_logging_description(v210);
            v212 = nw_endpoint_handler_state_string(v182);
            v213 = nw_endpoint_handler_mode_string(v182);
            v214 = nw_endpoint_handler_copy_current_path(v182);
            v215 = nw_parameters_get_effective_bundle_id(v360);
            *(_DWORD *)buf = 136448258;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)v208;
            v379 = 2082;
            v380 = v209;
            v381 = 2082;
            v382 = (void *)v211;
            v383 = 2082;
            v384 = v212;
            v385 = 2082;
            v386 = v213;
            v387 = 2114;
            v388 = v214;
            v389 = 2082;
            *(_QWORD *)v390 = v215;
            *(_WORD *)&v390[8] = 2082;
            *(_QWORD *)&v390[10] = "I";
            _os_log_impl(&dword_182FBE000, v185, v207, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid Bundle ID \"%{public}s\" [%{public}s], backtrace limit exceeded", buf, 0x5Cu);

          }
        }

LABEL_129:
        v4 = v361;
        if (v119)
          free(v119);
        goto LABEL_168;
      }
      if ((v26 & 0x20) != 0)
        goto LABEL_168;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v59 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        v85 = nw_endpoint_handler_get_id_string(v25);
        v86 = nw_endpoint_handler_dry_run_string(v25);
        v87 = nw_endpoint_handler_copy_endpoint(v25);
        v88 = nw_endpoint_get_logging_description(v87);
        v89 = nw_endpoint_handler_state_string(v25);
        v90 = nw_endpoint_handler_mode_string(v25);
        v91 = nw_endpoint_handler_copy_current_path(v25);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = (char *)v85;
        v379 = 2082;
        v380 = v86;
        v381 = 2082;
        v382 = (void *)v88;
        v383 = 2082;
        v384 = v89;
        v385 = 2082;
        v386 = v90;
        v387 = 2114;
        v388 = v91;
        v389 = 2082;
        *(_QWORD *)v390 = nw_parameters_get_effective_bundle_id(v360);
        *(_WORD *)&v390[8] = 2082;
        *(_QWORD *)&v390[10] = "I";
        _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid Bundle ID \"%{public}s\" [%{public}s]", buf, 0x5Cu);

      }
      goto LABEL_167;
    }
    if (!pid_to_uuid_mapping_failed)
      goto LABEL_168;
    v39 = _os_feature_enabled_impl();
    logging_disabled = nw_endpoint_handler_get_logging_disabled(v4);
    v361 = v4;
    if (!v39)
    {
      if ((logging_disabled & 1) != 0)
        goto LABEL_168;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v59 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      {
        v95 = nw_endpoint_handler_get_id_string(v4);
        v96 = nw_endpoint_handler_dry_run_string(v4);
        v97 = nw_endpoint_handler_copy_endpoint(v4);
        v98 = nw_endpoint_get_logging_description(v97);
        v99 = nw_endpoint_handler_state_string(v4);
        v100 = nw_endpoint_handler_mode_string(v4);
        v101 = nw_endpoint_handler_copy_current_path(v4);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = (char *)v95;
        v379 = 2082;
        v380 = v96;
        v381 = 2082;
        v382 = (void *)v98;
        v383 = 2082;
        v384 = v99;
        v385 = 2082;
        v386 = v100;
        v387 = 2114;
        v388 = v101;
        v389 = 1024;
        *(_DWORD *)v390 = nw_parameters_get_pid(v5);
        *(_WORD *)&v390[4] = 2082;
        *(_QWORD *)&v390[6] = "I";
        _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d [%{public}s]", buf, 0x58u);

      }
      goto LABEL_167;
    }
    if ((logging_disabled & 1) != 0)
      goto LABEL_168;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v354 = (id)gconnectionLogObj;
    v41 = nw_endpoint_handler_get_id_string(v4);
    v42 = nw_endpoint_handler_dry_run_string(v4);
    v43 = nw_endpoint_handler_copy_endpoint(v4);
    v44 = nw_endpoint_get_logging_description(v43);
    v45 = nw_endpoint_handler_state_string(v4);
    v46 = nw_endpoint_handler_mode_string(v4);
    v47 = nw_endpoint_handler_copy_current_path(v4);
    *(_DWORD *)buf = 136448258;
    v376 = "nw_endpoint_flow_validate_delegation";
    v377 = 2082;
    v378 = (char *)v41;
    v379 = 2082;
    v380 = v42;
    v381 = 2082;
    v382 = (void *)v44;
    v383 = 2082;
    v384 = v45;
    v385 = 2082;
    v386 = v46;
    v387 = 2114;
    v388 = v47;
    v389 = 1024;
    *(_DWORD *)v390 = nw_parameters_get_pid(v5);
    *(_WORD *)&v390[4] = 2082;
    *(_QWORD *)&v390[6] = "I";
    log = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v374 = 0;
    v48 = (char *)log;
    if ((__nwlog_fault(log, type, &v374) & 1) == 0)
    {
LABEL_247:
      v4 = v361;
      if (v48)
        free(v48);
LABEL_168:
      if (nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist)
        goto LABEL_169;
LABEL_234:
      v9 = 1;
      v5 = v360;
      goto LABEL_235;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v49 = (id)gconnectionLogObj;
      v50 = type[0];
      if (os_log_type_enabled(v49, type[0]))
      {
        v51 = nw_endpoint_handler_get_id_string(v4);
        v52 = nw_endpoint_handler_dry_run_string(v361);
        v53 = nw_endpoint_handler_copy_endpoint(v361);
        v54 = nw_endpoint_get_logging_description(v53);
        v55 = nw_endpoint_handler_state_string(v361);
        v56 = nw_endpoint_handler_mode_string(v361);
        v57 = nw_endpoint_handler_copy_current_path(v361);
        v58 = nw_parameters_get_pid(v5);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = (char *)v51;
        v379 = 2082;
        v380 = v52;
        v381 = 2082;
        v382 = (void *)v54;
        v383 = 2082;
        v384 = v55;
        v385 = 2082;
        v386 = v56;
        v387 = 2114;
        v388 = v57;
        v389 = 1024;
        *(_DWORD *)v390 = v58;
        *(_WORD *)&v390[4] = 2082;
        *(_QWORD *)&v390[6] = "I";
        _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d [%{public}s]", buf, 0x58u);

      }
    }
    else if (v374)
    {
      v153 = __nw_create_backtrace_string();
      if (v153)
      {
        v154 = (char *)v153;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v155 = (id)gconnectionLogObj;
        v156 = type[0];
        if (os_log_type_enabled(v155, type[0]))
        {
          v157 = nw_endpoint_handler_get_id_string(v4);
          v158 = nw_endpoint_handler_dry_run_string(v4);
          v357 = nw_endpoint_handler_copy_endpoint(v361);
          v159 = nw_endpoint_get_logging_description(v357);
          v160 = nw_endpoint_handler_state_string(v361);
          v161 = nw_endpoint_handler_mode_string(v361);
          v162 = nw_endpoint_handler_copy_current_path(v361);
          v163 = nw_parameters_get_pid(v5);
          *(_DWORD *)buf = 136448514;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v157;
          v379 = 2082;
          v380 = v158;
          v381 = 2082;
          v382 = (void *)v159;
          v383 = 2082;
          v384 = v160;
          v385 = 2082;
          v386 = v161;
          v387 = 2114;
          v388 = v162;
          v389 = 1024;
          *(_DWORD *)v390 = v163;
          *(_WORD *)&v390[4] = 2082;
          *(_QWORD *)&v390[6] = "I";
          *(_WORD *)&v390[14] = 2082;
          *(_QWORD *)&v390[16] = v154;
          _os_log_impl(&dword_182FBE000, v155, v156, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d [%{public}s], dumping backtrace:%{public}s", buf, 0x62u);

        }
        free(v154);
        goto LABEL_246;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v49 = (id)gconnectionLogObj;
      v310 = type[0];
      if (os_log_type_enabled(v49, type[0]))
      {
        v311 = nw_endpoint_handler_get_id_string(v4);
        v312 = nw_endpoint_handler_dry_run_string(v361);
        v313 = nw_endpoint_handler_copy_endpoint(v361);
        v314 = nw_endpoint_get_logging_description(v313);
        v315 = nw_endpoint_handler_state_string(v361);
        v316 = nw_endpoint_handler_mode_string(v361);
        v317 = nw_endpoint_handler_copy_current_path(v361);
        v318 = nw_parameters_get_pid(v5);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = (char *)v311;
        v379 = 2082;
        v380 = v312;
        v381 = 2082;
        v382 = (void *)v314;
        v383 = 2082;
        v384 = v315;
        v385 = 2082;
        v386 = v316;
        v387 = 2114;
        v388 = v317;
        v389 = 1024;
        *(_DWORD *)v390 = v318;
        *(_WORD *)&v390[4] = 2082;
        *(_QWORD *)&v390[6] = "I";
        _os_log_impl(&dword_182FBE000, v49, v310, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d [%{public}s], no backtrace", buf, 0x58u);

      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v49 = (id)gconnectionLogObj;
      v301 = type[0];
      if (os_log_type_enabled(v49, type[0]))
      {
        v302 = nw_endpoint_handler_get_id_string(v4);
        v303 = nw_endpoint_handler_dry_run_string(v361);
        v304 = nw_endpoint_handler_copy_endpoint(v361);
        v305 = nw_endpoint_get_logging_description(v304);
        v306 = nw_endpoint_handler_state_string(v361);
        v307 = nw_endpoint_handler_mode_string(v361);
        v308 = nw_endpoint_handler_copy_current_path(v361);
        v309 = nw_parameters_get_pid(v5);
        *(_DWORD *)buf = 136448258;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = (char *)v302;
        v379 = 2082;
        v380 = v303;
        v381 = 2082;
        v382 = (void *)v305;
        v383 = 2082;
        v384 = v306;
        v385 = 2082;
        v386 = v307;
        v387 = 2114;
        v388 = v308;
        v389 = 1024;
        *(_DWORD *)v390 = v309;
        *(_WORD *)&v390[4] = 2082;
        *(_QWORD *)&v390[6] = "I";
        _os_log_impl(&dword_182FBE000, v49, v301, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Network Delegation Failure: Invalid PID %d [%{public}s], backtrace limit exceeded", buf, 0x58u);

      }
    }

LABEL_246:
    v48 = (char *)log;
    goto LABEL_247;
  }
  v8 = getpid();
  if (!nw_parameters_has_delegated_proc_pid(v5, v8) && !nw_parameters_has_delegated_proc_uuid(v5))
  {
    v360 = v5;
    if (!nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist
      || object_getClass((id)nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist) != (Class)MEMORY[0x1E0C812C8])
    {
      v71 = 0;
      goto LABEL_54;
    }
    v363 = v4;
    v108 = nw_endpoint_handler_copy_endpoint(v4);
    domain_for_policy = nw_endpoint_get_domain_for_policy(v108);
    v110 = domain_for_policy;
    if (domain_for_policy)
    {
      *(_QWORD *)type = 0;
      v371 = type;
      v372 = 0x2020000000;
      v373 = 0;
      v111 = (void *)nw_endpoint_flow_validate_delegation(NWConcrete_nw_endpoint_handler *)::delegation_allowlist;
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = ___ZL36nw_endpoint_flow_validate_delegationP30NWConcrete_nw_endpoint_handler_block_invoke_215;
      applier[3] = &unk_1E14AB688;
      v368 = strlen((const char *)domain_for_policy);
      v369 = v110;
      v112 = v4;
      v366 = v112;
      v367 = type;
      xpc_array_apply(v111, applier);
      if (*((_BYTE *)v371 + 24))
      {

        _Block_object_dispose(type, 8);
        goto LABEL_234;
      }
      if ((nw_endpoint_handler_get_logging_disabled(v112) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v284 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v284, OS_LOG_TYPE_ERROR))
        {
          v285 = nw_endpoint_handler_get_id_string(v112);
          v286 = nw_endpoint_handler_dry_run_string(v112);
          v287 = nw_endpoint_handler_copy_endpoint(v112);
          v288 = nw_endpoint_get_logging_description(v287);
          v289 = nw_endpoint_handler_state_string(v112);
          v290 = nw_endpoint_handler_mode_string(v112);
          v291 = nw_endpoint_handler_copy_current_path(v112);
          *(_DWORD *)buf = 136448002;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v285;
          v379 = 2082;
          v380 = v286;
          v381 = 2082;
          v382 = (void *)v288;
          v383 = 2082;
          v384 = v289;
          v385 = 2082;
          v386 = v290;
          v387 = 2114;
          v388 = v291;
          v389 = 2082;
          *(_QWORD *)v390 = v110;
          _os_log_impl(&dword_182FBE000, v284, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Domain \"%{public}s\" was not found within allowlist for non-delegated connections", buf, 0x52u);

        }
      }

      _Block_object_dispose(type, 8);
    }
    else if ((nw_endpoint_handler_get_logging_disabled(v4) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v174 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v174, OS_LOG_TYPE_ERROR))
      {
        v175 = nw_endpoint_handler_get_id_string(v4);
        v176 = nw_endpoint_handler_dry_run_string(v4);
        v177 = nw_endpoint_handler_copy_endpoint(v363);
        v178 = nw_endpoint_get_logging_description(v177);
        v179 = nw_endpoint_handler_state_string(v363);
        v180 = nw_endpoint_handler_mode_string(v363);
        v181 = nw_endpoint_handler_copy_current_path(v363);
        *(_DWORD *)buf = 136447746;
        v376 = "nw_endpoint_flow_validate_delegation";
        v377 = 2082;
        v378 = (char *)v175;
        v379 = 2082;
        v380 = v176;
        v381 = 2082;
        v382 = (void *)v178;
        v383 = 2082;
        v384 = v179;
        v385 = 2082;
        v386 = v180;
        v387 = 2114;
        v388 = v181;
        _os_log_impl(&dword_182FBE000, v174, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No domain found for connection to allowlist non-delegated connections", buf, 0x48u);

      }
    }

    v71 = 1;
    v4 = v363;
LABEL_54:
    if (!_os_feature_enabled_impl())
    {
      if (!v71)
        goto LABEL_234;
      goto LABEL_169;
    }
    v362 = v4;
    v346 = v71;
    v355 = nw_endpoint_handler_copy_endpoint(v4);
    loga = nw_endpoint_get_domain_for_policy(v355);
    v72 = v4;
    v73 = (*((_BYTE *)v72 + 268) & 0x20) == 0;

    if (!v73)
    {
LABEL_233:

      v4 = v362;
      if ((v346 & 1) == 0)
        goto LABEL_234;
LABEL_169:
      v219 = v4;
      v220 = (*((_BYTE *)v219 + 268) & 0x20) == 0;

      if (v220)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v221 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v221, OS_LOG_TYPE_ERROR))
        {
          v222 = v219;

          v223 = v222;
          v224 = (*((_BYTE *)v219 + 268) & 1) == 0;

          if (v224)
            v225 = "";
          else
            v225 = "dry-run ";
          v226 = nw_endpoint_handler_copy_endpoint(v223);
          v227 = nw_endpoint_get_logging_description(v226);
          v228 = v223;
          v229 = v228;
          v230 = v228[30];
          if (v230 > 5)
            v231 = "unknown-state";
          else
            v231 = off_1E149FC48[v230];

          v232 = v229;
          v233 = "path";
          switch(v364->mode)
          {
            case 0:
              break;
            case 1:
              v233 = "resolver";
              break;
            case 2:
              v233 = nw_endpoint_flow_mode_string(v232[31]);
              break;
            case 3:
              v233 = "proxy";
              break;
            case 4:
              v233 = "fallback";
              break;
            case 5:
              v233 = "transform";
              break;
            default:
              v233 = "unknown-mode";
              break;
          }
          v359 = v233;

          v234 = v226;
          v235 = v231;
          v236 = v227;
          v237 = v232;
          os_unfair_lock_lock((os_unfair_lock_t)v237 + 28);
          v238 = v237[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v237 + 28);

          *(_DWORD *)buf = 136447746;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)(v222 + 21);
          v379 = 2082;
          v380 = v225;
          v381 = 2082;
          v382 = (void *)v236;
          v383 = 2082;
          v384 = v235;
          v385 = 2082;
          v386 = v359;
          v387 = 2114;
          v388 = v238;
          _os_log_impl(&dword_182FBE000, v221, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failing connection due to delegation errors", buf, 0x48u);

        }
      }
      v5 = v360;
      nw_endpoint_flow_failed_with_error(v219, 1, 0);
      v9 = 0;
      goto LABEL_235;
    }
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v74 = (id)gconnectionLogObj;
    v75 = v72;

    v76 = v75;
    v77 = (*((_BYTE *)v72 + 268) & 1) == 0;

    if (v77)
      v78 = "";
    else
      v78 = "dry-run ";
    v79 = nw_endpoint_handler_copy_endpoint(v76);
    v80 = nw_endpoint_get_logging_description(v79);
    v81 = v76;
    v82 = v81;
    v83 = v81[30];
    if (v83 > 5)
      v84 = "unknown-state";
    else
      v84 = off_1E149FC48[v83];

    v113 = v82;
    v114 = v113;
    v115 = "path";
    switch(v364->mode)
    {
      case 0:
        break;
      case 1:
        v115 = "resolver";
        break;
      case 2:
        v115 = nw_endpoint_flow_mode_string(v113[31]);
        break;
      case 3:
        v115 = "proxy";
        break;
      case 4:
        v115 = "fallback";
        break;
      case 5:
        v115 = "transform";
        break;
      default:
        v115 = "unknown-mode";
        break;
    }

    v239 = v114;
    os_unfair_lock_lock((os_unfair_lock_t)v239 + 28);
    v240 = v239[8];
    os_unfair_lock_unlock((os_unfair_lock_t)v239 + 28);

    v241 = v240;
    description = nw_endpoint_get_description(v355);
    *(_DWORD *)buf = 136448258;
    v376 = "nw_endpoint_flow_validate_delegation";
    v377 = 2082;
    v378 = (char *)(v75 + 21);
    v379 = 2082;
    v380 = v78;
    v381 = 2082;
    v382 = (void *)v80;
    v383 = 2082;
    v384 = v84;
    v385 = 2082;
    v386 = v115;
    v387 = 2114;
    v388 = v241;
    v389 = 2080;
    *(_QWORD *)v390 = loga;
    *(_WORD *)&v390[8] = 2080;
    *(_QWORD *)&v390[10] = description;
    v243 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v374 = 0;
    if (__nwlog_fault(v243, type, &v374))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v244 = (id)gconnectionLogObj;
        v245 = type[0];
        if (os_log_type_enabled(v244, type[0]))
        {
          v246 = nw_endpoint_handler_get_id_string(v239);
          v247 = nw_endpoint_handler_dry_run_string(v239);
          v343 = v244;
          v248 = nw_endpoint_handler_copy_endpoint(v239);
          v249 = v246;
          v250 = nw_endpoint_get_logging_description(v248);
          v251 = nw_endpoint_handler_state_string(v239);
          v252 = nw_endpoint_handler_mode_string(v239);
          v253 = nw_endpoint_handler_copy_current_path(v239);
          v254 = nw_endpoint_get_description(v355);
          *(_DWORD *)buf = 136448258;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v249;
          v379 = 2082;
          v380 = v247;
          v381 = 2082;
          v382 = (void *)v250;
          v383 = 2082;
          v384 = v251;
          v385 = 2082;
          v386 = v252;
          v387 = 2114;
          v388 = v253;
          v389 = 2080;
          *(_QWORD *)v390 = loga;
          *(_WORD *)&v390[8] = 2080;
          *(_QWORD *)&v390[10] = v254;
          _os_log_impl(&dword_182FBE000, v343, v245, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traffic: Connection to %s (%s)", buf, 0x5Cu);

          v244 = v343;
        }
      }
      else if (v374)
      {
        v255 = __nw_create_backtrace_string();
        if (v255)
        {
          v256 = (char *)v255;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v257 = (id)gconnectionLogObj;
          v258 = type[0];
          if (os_log_type_enabled(v257, type[0]))
          {
            v259 = nw_endpoint_handler_get_id_string(v239);
            v341 = nw_endpoint_handler_dry_run_string(v239);
            v342 = nw_endpoint_handler_copy_endpoint(v239);
            v260 = v259;
            v261 = nw_endpoint_get_logging_description(v342);
            v262 = nw_endpoint_handler_state_string(v239);
            v263 = nw_endpoint_handler_mode_string(v239);
            v264 = nw_endpoint_handler_copy_current_path(v239);
            v265 = nw_endpoint_get_description(v355);
            *(_DWORD *)buf = 136448514;
            v376 = "nw_endpoint_flow_validate_delegation";
            v377 = 2082;
            v378 = (char *)v260;
            v379 = 2082;
            v380 = v341;
            v381 = 2082;
            v382 = (void *)v261;
            v383 = 2082;
            v384 = v262;
            v385 = 2082;
            v386 = v263;
            v387 = 2114;
            v388 = v264;
            v389 = 2080;
            *(_QWORD *)v390 = loga;
            *(_WORD *)&v390[8] = 2080;
            *(_QWORD *)&v390[10] = v265;
            *(_WORD *)&v390[18] = 2082;
            *(_QWORD *)&v390[20] = v256;
            _os_log_impl(&dword_182FBE000, v257, v258, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traffic: Connection to %s (%s), dumping backtrace:%{public}s", buf, 0x66u);

          }
          free(v256);
          goto LABEL_231;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v244 = (id)gconnectionLogObj;
        v292 = type[0];
        if (os_log_type_enabled(v244, type[0]))
        {
          v293 = nw_endpoint_handler_get_id_string(v239);
          v294 = nw_endpoint_handler_dry_run_string(v239);
          v345 = v244;
          v295 = nw_endpoint_handler_copy_endpoint(v239);
          v296 = nw_endpoint_get_logging_description(v295);
          v297 = nw_endpoint_handler_state_string(v239);
          v298 = nw_endpoint_handler_mode_string(v239);
          v299 = nw_endpoint_handler_copy_current_path(v239);
          v300 = nw_endpoint_get_description(v355);
          *(_DWORD *)buf = 136448258;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v293;
          v379 = 2082;
          v380 = v294;
          v381 = 2082;
          v382 = (void *)v296;
          v383 = 2082;
          v384 = v297;
          v385 = 2082;
          v386 = v298;
          v387 = 2114;
          v388 = v299;
          v389 = 2080;
          *(_QWORD *)v390 = loga;
          *(_WORD *)&v390[8] = 2080;
          *(_QWORD *)&v390[10] = v300;
          _os_log_impl(&dword_182FBE000, v345, v292, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traffic: Connection to %s (%s), no backtrace", buf, 0x5Cu);

          v244 = v345;
        }
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v244 = (id)gconnectionLogObj;
        v266 = type[0];
        if (os_log_type_enabled(v244, type[0]))
        {
          v267 = nw_endpoint_handler_get_id_string(v239);
          v268 = nw_endpoint_handler_dry_run_string(v239);
          v344 = v244;
          v269 = nw_endpoint_handler_copy_endpoint(v239);
          v270 = nw_endpoint_get_logging_description(v269);
          v271 = nw_endpoint_handler_state_string(v239);
          v272 = nw_endpoint_handler_mode_string(v239);
          v273 = nw_endpoint_handler_copy_current_path(v239);
          v274 = nw_endpoint_get_description(v355);
          *(_DWORD *)buf = 136448258;
          v376 = "nw_endpoint_flow_validate_delegation";
          v377 = 2082;
          v378 = (char *)v267;
          v379 = 2082;
          v380 = v268;
          v381 = 2082;
          v382 = (void *)v270;
          v383 = 2082;
          v384 = v271;
          v385 = 2082;
          v386 = v272;
          v387 = 2114;
          v388 = v273;
          v389 = 2080;
          *(_QWORD *)v390 = loga;
          *(_WORD *)&v390[8] = 2080;
          *(_QWORD *)&v390[10] = v274;
          _os_log_impl(&dword_182FBE000, v344, v266, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Undelegated Network Traffic: Connection to %s (%s), backtrace limit exceeded", buf, 0x5Cu);

          v244 = v344;
        }
      }

    }
LABEL_231:
    if (v243)
      free(v243);
    goto LABEL_233;
  }
  v9 = 1;
LABEL_235:

LABEL_303:
  return v9;
}

void sub_1830EED30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25)
{
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_delegated_proc_pid(void *a1, int a2)
{
  id v3;
  void *v4;
  int v5;
  _BOOL8 v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = *(_DWORD *)(*((_QWORD *)v3 + 13) + 64);
    v7 = v5 > 0 && v5 != a2;
    goto LABEL_8;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_parameters_has_delegated_proc_pid";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_parameters_has_delegated_proc_pid";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_parameters_has_delegated_proc_pid";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_parameters_has_delegated_proc_pid";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_parameters_has_delegated_proc_pid";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_25:
  if (v10)
    free(v10);
  v7 = 0;
LABEL_8:

  return v7;
}

BOOL nw_parameters_has_delegated_proc_uuid(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_parameters_has_delegated_proc_uuid";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v6, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_has_delegated_proc_uuid";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_parameters_has_delegated_proc_uuid";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_has_delegated_proc_uuid";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_has_delegated_proc_uuid";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_22:
    if (v6)
      free(v6);
    goto LABEL_3;
  }
  if (!uuid_is_null((const unsigned __int8 *)(v1[13] + 24)))
  {
    v3 = uuid_compare((const unsigned __int8 *)(v2[13] + 24), (const unsigned __int8 *)(v2[13] + 8)) != 0;
    goto LABEL_5;
  }
LABEL_3:
  v3 = 0;
LABEL_5:

  return v3;
}

void sub_1830EF578(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_pid_to_uuid_mapping_failed(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[97] >> 5) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_pid_to_uuid_mapping_failed";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_bundle_id_to_uuid_mapping_failed(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[97] >> 4) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_bundle_id_to_uuid_mapping_failed";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_context_get_identifier(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_context_get_identifier";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_identifier";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_context_get_identifier";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_identifier";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_identifier";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_parameters_add_proxy_options(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  uint64_t v6;
  _BOOL8 v7;
  void *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_parameters_add_proxy_options";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_add_proxy_options";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_parameters_add_proxy_options";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v10)
          goto LABEL_6;
LABEL_41:
        free(v10);
        goto LABEL_6;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_add_proxy_options";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_add_proxy_options";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (v4)
  {
    v6 = v3[21];
    if (!v6)
    {
      v7 = nw_array_create();
      v8 = (void *)v3[21];
      v3[21] = v7;

      v6 = v3[21];
    }
    nw_array_append(v6, v5);
    goto LABEL_6;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_parameters_add_proxy_options";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_parameters_add_proxy_options";
      _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null proxy_options", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v23)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_parameters_add_proxy_options";
      _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s called with null proxy_options, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v18 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  v19 = type;
  v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_parameters_add_proxy_options";
      _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null proxy_options, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_parameters_add_proxy_options";
    v27 = 2082;
    v28 = v18;
    _os_log_impl(&dword_182FBE000, v11, v19, "%{public}s called with null proxy_options, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10)
    goto LABEL_41;
LABEL_6:

}

uint64_t __nw_endpoint_get_connected_flow_count_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3;

  v3 = (id)nw_hash_node_get_object(a2);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += nw_association_get_connected_flow_count(v3);

  return 1;
}

void sub_1830F0268(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_association_get_connected_flow_count(void *a1)
{
  id v1;
  _QWORD *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_association_get_connected_flow_count";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_association_get_connected_flow_count";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_association_get_connected_flow_count";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_association_get_connected_flow_count";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_association_get_connected_flow_count";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v7)
      free(v7);
    goto LABEL_22;
  }
  v3 = nw_path_parameters_copy_context(*((void **)v1 + 2));
  nw_context_assert_queue(v3);

  v4 = v2[6];
  if (!v4)
  {
LABEL_22:
    v5 = 0;
    goto LABEL_23;
  }
  v5 = *(unsigned int *)(v4 + 40);
LABEL_23:

  return v5;
}

void sub_1830F0524(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_path_get_flow_divert_unit(void *a1)
{
  _DWORD *v1;
  uint64_t v2;

  v1 = a1;
  if (v1 && v1[66] == 4)
    v2 = v1[67];
  else
    v2 = 0;

  return v2;
}

uint64_t nw_path_get_tso_max_segment_size_v6(void *a1)
{
  NWConcrete_nw_path *v1;
  NWConcrete_nw_path *v2;
  OS_nw_interface *direct;
  OS_nw_interface *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_path_get_tso_max_segment_size_v6";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_path_get_tso_max_segment_size_v6";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_path_get_tso_max_segment_size_v6";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_path_get_tso_max_segment_size_v6";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_path_get_tso_max_segment_size_v6";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_21:
    if (v7)
      free(v7);
    goto LABEL_23;
  }
  if (!nw_path_network_is_satisfied_update_reason(v1, 0) || (direct = v2->direct) == 0)
  {
LABEL_23:
    v5 = 0;
    goto LABEL_24;
  }
  v4 = direct;
  v5 = *((unsigned int *)v4 + 17);

LABEL_24:
  return v5;
}

void sub_1830F082C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

const char *nw_connection_server_accurate_ecn_state_to_string(unsigned int a1)
{
  if (a1 > 0xA)
    return "Unknown";
  else
    return off_1E149B448[a1];
}

const char *nw_connection_client_accurate_ecn_state_to_string(unsigned int a1)
{
  if (a1 > 9)
    return "Unknown";
  else
    return off_1E149B3F8[a1];
}

id nw_path_copy_delegate_interface(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[13];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_copy_delegate_interface";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_delegate_interface";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_copy_delegate_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_delegate_interface";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_delegate_interface";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

NWConcrete_nw_link_info *nw_link_info_create(int a1)
{
  NWConcrete_nw_link_info *v2;
  NWConcrete_nw_link_info *v3;
  NWConcrete_nw_link_info *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = objc_alloc_init(NWConcrete_nw_link_info);
  v3 = v2;
  if (v2)
  {
    v2->flow_control_status = a1;
    v2->link_quality = 0;
    v4 = v2;
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v17 = "nw_link_info_create";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
    goto LABEL_8;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_link_info_create";
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s [nw_link_info init] failed", buf, 0xCu);
    }
LABEL_7:

LABEL_8:
    if (!v6)
      goto LABEL_10;
LABEL_9:
    free(v6);
    goto LABEL_10;
  }
  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v13 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_link_info_create";
      _os_log_impl(&dword_182FBE000, v7, v13, "%{public}s [nw_link_info init] failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_7;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  v11 = type;
  v12 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_link_info_create";
      _os_log_impl(&dword_182FBE000, v7, v11, "%{public}s [nw_link_info init] failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_7;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v17 = "nw_link_info_create";
    v18 = 2082;
    v19 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v7, v11, "%{public}s [nw_link_info init] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v6)
    goto LABEL_9;
LABEL_10:

  return v3;
}

uint64_t NWActivity.__allocating_init(domain:label:)(unint64_t a1, unint64_t a2)
{
  uint64_t v4;

  v4 = swift_allocObject();
  NWActivity.init(domain:label:)(a1, a2);
  return v4;
}

uint64_t NWActivity.init(domain:label:)(unint64_t a1, unint64_t a2)
{
  _QWORD *v2;
  uint64_t result;

  if ((a1 & 0x8000000000000000) != 0 || HIDWORD(a1) || (a2 & 0x8000000000000000) != 0 || HIDWORD(a2))
  {
    result = sub_183B91F50();
    __break(1u);
  }
  else
  {
    v2[2] = nw_activity_create(a1, a2);
    v2[3] = a1;
    v2[4] = a2;
    return (uint64_t)v2;
  }
  return result;
}

id nw_protocol_stack_copy_original_proxied_transport_protocol(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[5];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_stack_copy_original_proxied_transport_protocol";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_instance_enumerate_flows(void *a1, void *a2)
{
  char *v3;
  id v4;
  uint64_t v5;
  NSObject *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  _QWORD v15[4];
  char *v16;
  id v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v5 = *((_QWORD *)v3 + 29);
    if (v5 && *(_DWORD *)(v5 + 40))
    {
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 3221225472;
      v15[2] = __nw_protocol_instance_enumerate_flows_block_invoke;
      v15[3] = &unk_1E149B990;
      v16 = v3;
      v17 = v4;
      nw_hash_table_apply((char *)v5, (uint64_t)v15);

    }
    else if ((v3[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v21 = "nw_protocol_instance_enumerate_flows";
        v22 = 2082;
        v23 = v3 + 407;
        v24 = 2080;
        v25 = " ";
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sNo flows to enumerate", buf, 0x20u);
      }

    }
    goto LABEL_9;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_protocol_instance_enumerate_flows";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v8, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_instance_enumerate_flows";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_protocol_instance_enumerate_flows";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_instance_enumerate_flows";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_protocol_instance_enumerate_flows";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_26:
  if (v8)
    free(v8);
LABEL_9:

}

BOOL nw_endpoint_flow_attach_channel_protocol(void *a1, uint64_t a2, int a3)
{
  NWConcrete_nw_endpoint_handler *v5;
  NWConcrete_nw_endpoint_mode_handler *v6;
  NSObject *v7;
  const char *v8;
  const char *v9;
  nw_endpoint_t v10;
  const char *v11;
  const char *v12;
  const char *v13;
  id v14;
  _BOOL8 v15;
  NWConcrete_nw_path *v16;
  id v17;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  NSObject *v21;
  const char *id_string;
  const char *v23;
  nw_endpoint_t v24;
  const char *logging_description;
  const char *v26;
  const char *v27;
  id v28;
  char v29;
  _DWORD *v30;
  _BOOL8 v31;
  void *v32;
  int minimize_logging;
  char logging_disabled;
  NSObject *v35;
  const char *v36;
  const char *v37;
  nw_endpoint_t v38;
  int v39;
  const char *v40;
  const char *v41;
  const char *v42;
  id v43;
  NSObject *v44;
  const char *v45;
  const char *v46;
  nw_endpoint_t v47;
  const char *v48;
  const char *v49;
  const char *v50;
  id v51;
  _QWORD *v52;
  nw_endpoint_t v53;
  int address_family;
  void *v55;
  int v56;
  uint64_t stats_region;
  _QWORD *v58;
  void *v59;
  __int128 *v60;
  int v61;
  uint64_t v62;
  uint64_t protocol_handler;
  uint64_t v64;
  _QWORD *v65;
  uint64_t v66;
  id v67;
  char *v68;
  NSObject *v69;
  os_log_type_t v70;
  NSObject *v71;
  uint64_t v72;
  char *backtrace_string;
  NSObject *v74;
  os_log_type_t v75;
  _BOOL4 v76;
  __int128 *upper_transport_protocol_identifier;
  void *v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  os_log_type_t v82;
  uint64_t v84;
  NSObject *v85;
  nw_endpoint_t v86;
  const char *v87;
  const char *v88;
  const char *v89;
  id v90;
  void *v91;
  void *v92;
  NSObject *v93;
  os_log_type_t v94;
  void *v95;
  os_log_type_t v96;
  char *v97;
  NSObject *v98;
  os_log_type_t v99;
  _BOOL4 v100;
  os_log_type_t v101;
  _BOOL4 v102;
  os_log_type_t v103;
  os_log_type_t v104;
  uint64_t v105;
  const char *v106;
  NSObject *log;
  const char *loga;
  id v109;
  NWConcrete_nw_path *v110;
  uint64_t v111;
  uint64_t v112;
  unsigned int v113;
  char v114;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v117;
  __int16 v118;
  uint64_t v119;
  __int16 v120;
  void *v121;
  __int16 v122;
  const char *v123;
  __int16 v124;
  const char *v125;
  __int16 v126;
  const char *v127;
  __int16 v128;
  id v129;
  __int16 v130;
  int v131;
  __int128 uu;
  uint64_t v133;

  v133 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = nw_endpoint_handler_copy_flow(v5);
  if ((*((_BYTE *)v6 + 33) & 0x40) != 0)
  {
    uu = 0uLL;
    v113 = 0;
    v16 = (NWConcrete_nw_path *)nw_endpoint_flow_copy_path(v5);
    v110 = v16;
    if (!nw_path_flow_registration_get_nexus_instance(v16, *((NWConcrete_nw_path_flow_registration **)v6 + 104), &uu, &v113))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) != 0)
      {
        v15 = 0;
        goto LABEL_102;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v21 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_endpoint_handler_get_id_string(v5);
        v23 = nw_endpoint_handler_dry_run_string(v5);
        v24 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v24);
        v26 = nw_endpoint_handler_state_string(v5);
        v27 = nw_endpoint_handler_mode_string(v5);
        v28 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136447746;
        v117 = "nw_endpoint_flow_attach_channel_protocol";
        v118 = 2082;
        v119 = (uint64_t)id_string;
        v120 = 2082;
        v121 = (void *)v23;
        v122 = 2082;
        v123 = logging_description;
        v124 = 2082;
        v125 = v26;
        v126 = 2082;
        v127 = v27;
        v128 = 2114;
        v129 = v28;
        _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] nexus is not ready", buf, 0x48u);

      }
      v15 = 0;
LABEL_101:
      v16 = v110;
LABEL_102:

      goto LABEL_103;
    }
    v17 = nw_path_copy_flow_for_registration(v16, *((NWConcrete_nw_path_flow_registration **)v6 + 104));
    v18 = v17;
    if (v17)
    {
      v19 = v17;
      v20 = v19[1];
      if (!v20 || !*((_DWORD *)v19 + 40))
        v20 = 0;

    }
    else
    {
      v20 = 0;
    }

    v111 = 0;
    v112 = 0;
    HIDWORD(v112) = nw_path_flow_registration_can_support_user_packet_pool(v110, *((void **)v6 + 104));
    if (nw_path_flow_registration_should_use_event_ring(v110, *((void **)v6 + 104)))
      v29 = 2;
    else
      v29 = 0;
    BYTE4(v112) = BYTE4(v112) & 0xFD | v29;
    v111 = v20;
    LODWORD(v112) = 16;
    v109 = nw_endpoint_handler_copy_parameters(v5);
    v30 = nw_parameters_copy_context(v109);
    v31 = nw_channel_create_with_attributes(v30, (unsigned __int8 *)&uu, v113, (uint64_t)&v111);
    v32 = (void *)*((_QWORD *)v6 + 113);
    *((_QWORD *)v6 + 113) = v31;

    if (!*((_QWORD *)v6 + 113))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v44 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          v45 = nw_endpoint_handler_get_id_string(v5);
          v46 = nw_endpoint_handler_dry_run_string(v5);
          v47 = nw_endpoint_handler_copy_endpoint(v5);
          v48 = nw_endpoint_get_logging_description(v47);
          v49 = nw_endpoint_handler_state_string(v5);
          v50 = nw_endpoint_handler_mode_string(v5);
          v51 = nw_endpoint_handler_copy_current_path(v5);
          *(_DWORD *)buf = 136447746;
          v117 = "nw_endpoint_flow_attach_channel_protocol";
          v118 = 2082;
          v119 = (uint64_t)v45;
          v120 = 2082;
          v121 = (void *)v46;
          v122 = 2082;
          v123 = v48;
          v124 = 2082;
          v125 = v49;
          v126 = 2082;
          v127 = v50;
          v128 = 2114;
          v129 = v51;
          _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to open channel", buf, 0x48u);

        }
      }
      goto LABEL_99;
    }
    minimize_logging = nw_endpoint_handler_get_minimize_logging(v5);
    logging_disabled = nw_endpoint_handler_get_logging_disabled(v5);
    if (minimize_logging)
    {
      if ((logging_disabled & 1) != 0)
      {
LABEL_33:
        nw_channel_set_close_automatically(*((_QWORD *)v6 + 113), 1);
        nw_channel_set_defer_input_available(*((_QWORD *)v6 + 113), 1);
        nw_channel_set_protocol_level(*((_QWORD *)v6 + 113), a3);
        if (a3 == 2)
        {
          if (nw_protocol_ip_identifier::onceToken != -1)
            dispatch_once(&nw_protocol_ip_identifier::onceToken, &__block_literal_global_85105);
          if (nw_parameters_has_protocol_in_stack(v109, &nw_protocol_ip_identifier::identifier))
            goto LABEL_49;
          v52 = (_QWORD *)*((_QWORD *)v6 + 95);
          if (v52)
          {
            if (nw_protocol_ip_identifier::onceToken != -1)
              dispatch_once(&nw_protocol_ip_identifier::onceToken, &__block_literal_global_85105);
            if (nw_protocols_are_equal(v52, &nw_protocol_ip_identifier::identifier))
            {
LABEL_49:
              v53 = nw_endpoint_handler_copy_endpoint(v5);
              address_family = nw_endpoint_get_address_family(v53);

              v55 = (void *)*((_QWORD *)v6 + 104);
              if (nw_protocol_ip_identifier::onceToken != -1)
                dispatch_once(&nw_protocol_ip_identifier::onceToken, &__block_literal_global_85105);
              if (address_family == 2)
                v56 = 1;
              else
                v56 = 2;
              stats_region = nw_channel_get_stats_region(*((_QWORD *)v6 + 113), v56);
              nw_path_flow_registration_set_stats_region(v55, 2, (__int128 *)&nw_protocol_ip_identifier::identifier, stats_region);
            }
          }
        }
        else
        {
          if (a3 == 1)
          {
            nw_channel_set_no_close_delay(*((_QWORD *)v6 + 113));
            goto LABEL_65;
          }
          if ((a3 & 0xFFFFFFFE) != 2)
            goto LABEL_65;
        }
        v58 = (_QWORD *)nw_protocol_tcp_identifier();
        if (nw_parameters_has_protocol_in_stack(v109, v58))
        {
          v59 = (void *)*((_QWORD *)v6 + 104);
          v60 = (__int128 *)nw_protocol_tcp_identifier();
          v61 = 3;
LABEL_64:
          v62 = nw_channel_get_stats_region(*((_QWORD *)v6 + 113), v61);
          nw_path_flow_registration_set_stats_region(v59, 3, v60, v62);
          goto LABEL_65;
        }
        if (nw_protocol_udp_identifier::onceToken != -1)
          dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
        if (nw_parameters_has_protocol_in_stack(v109, &nw_protocol_udp_identifier::identifier))
        {
          v59 = (void *)*((_QWORD *)v6 + 104);
          if (nw_protocol_udp_identifier::onceToken != -1)
            dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
          v60 = (__int128 *)&nw_protocol_udp_identifier::identifier;
          v61 = 4;
          goto LABEL_64;
        }
        if (nw_parameters_get_upper_transport_protocol(v109) == 253)
        {
          upper_transport_protocol_identifier = (__int128 *)nw_parameters_get_upper_transport_protocol_identifier(v109);
          v78 = (void *)*((_QWORD *)v6 + 104);
          v79 = nw_channel_get_stats_region(*((_QWORD *)v6 + 113), 5);
          nw_path_flow_registration_set_stats_region(v78, 3, upper_transport_protocol_identifier, v79);
          v80 = (void *)*((_QWORD *)v6 + 104);
          if (nw_protocol_udp_identifier::onceToken != -1)
            dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
          v81 = nw_channel_get_stats_region(*((_QWORD *)v6 + 113), 4);
          nw_path_flow_registration_set_stats_region(v80, 3, (__int128 *)&nw_protocol_udp_identifier::identifier, v81);
        }
LABEL_65:
        protocol_handler = nw_channel_get_protocol_handler(*((_QWORD *)v6 + 113));
        if (protocol_handler)
        {
          if (a2)
          {
            v64 = protocol_handler;
            if (protocol_handler != a2)
            {
              v65 = *(_QWORD **)(protocol_handler + 24);
              if (v65 && *v65)
              {
                v66 = nw_protocol_add_input_handler(protocol_handler, a2);
                v15 = v66;
                if (a3 != 1 && (_DWORD)v66)
                  v15 = nw_channel_set_path_flow_registration(*((_QWORD *)v6 + 113), v110, *((void **)v6 + 104));
                goto LABEL_100;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v71 = (id)gLogObj;
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v117 = "nw_protocol_utilities_add_input_handler";
                v118 = 2048;
                v119 = v64;
                _os_log_impl(&dword_182FBE000, v71, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
              }

LABEL_99:
              v15 = 0;
LABEL_100:

              goto LABEL_101;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v67 = (id)gLogObj;
            *(_DWORD *)buf = 136446466;
            v117 = "nw_protocol_utilities_add_input_handler";
            v118 = 2048;
            v119 = a2;
            v68 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v114 = 0;
            if (!__nwlog_fault(v68, &type, &v114))
              goto LABEL_97;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v69 = (id)gLogObj;
              v70 = type;
              if (os_log_type_enabled(v69, type))
              {
                *(_DWORD *)buf = 136446466;
                v117 = "nw_protocol_utilities_add_input_handler";
                v118 = 2048;
                v119 = a2;
                _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
              }
            }
            else
            {
              if (v114)
              {
                v72 = a2;
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v74 = objc_claimAutoreleasedReturnValue();
                v75 = type;
                v76 = os_log_type_enabled(v74, type);
                if (backtrace_string)
                {
                  if (v76)
                  {
                    *(_DWORD *)buf = 136446722;
                    v117 = "nw_protocol_utilities_add_input_handler";
                    v118 = 2048;
                    v119 = v72;
                    v120 = 2082;
                    v121 = backtrace_string;
                    _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                  }

                  free(backtrace_string);
                  if (!v68)
                    goto LABEL_99;
                  goto LABEL_98;
                }
                if (v76)
                {
                  *(_DWORD *)buf = 136446466;
                  v117 = "nw_protocol_utilities_add_input_handler";
                  v118 = 2048;
                  v119 = v72;
                  _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
                }

LABEL_97:
                if (!v68)
                  goto LABEL_99;
LABEL_98:
                free(v68);
                goto LABEL_99;
              }
              __nwlog_obj();
              v69 = objc_claimAutoreleasedReturnValue();
              v82 = type;
              if (os_log_type_enabled(v69, type))
              {
                *(_DWORD *)buf = 136446466;
                v117 = "nw_protocol_utilities_add_input_handler";
                v118 = 2048;
                v119 = a2;
                _os_log_impl(&dword_182FBE000, v69, v82, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
              }
            }

            goto LABEL_97;
          }
          __nwlog_obj();
          v95 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v117 = "nw_protocol_utilities_add_input_handler";
          v92 = (void *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v114 = 0;
          if (!__nwlog_fault((const char *)v92, &type, &v114))
          {
LABEL_143:
            if (v92)
              free(v92);
            goto LABEL_99;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v93 = objc_claimAutoreleasedReturnValue();
            v96 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              v117 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_182FBE000, v93, v96, "%{public}s called with null input_protocol", buf, 0xCu);
            }
LABEL_136:

            goto LABEL_143;
          }
          if (!v114)
          {
            __nwlog_obj();
            v93 = objc_claimAutoreleasedReturnValue();
            v104 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              v117 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_182FBE000, v93, v104, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_136;
          }
          v97 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v98 = objc_claimAutoreleasedReturnValue();
          v101 = type;
          v102 = os_log_type_enabled(v98, type);
          if (v97)
          {
            if (v102)
            {
              *(_DWORD *)buf = 136446466;
              v117 = "nw_protocol_utilities_add_input_handler";
              v118 = 2082;
              v119 = (uint64_t)v97;
              _os_log_impl(&dword_182FBE000, v98, v101, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
LABEL_130:

            free(v97);
            goto LABEL_143;
          }
          if (v102)
          {
            *(_DWORD *)buf = 136446210;
            v117 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v98, v101, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v91 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v117 = "nw_protocol_utilities_add_input_handler";
          v92 = (void *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v114 = 0;
          if (!__nwlog_fault((const char *)v92, &type, &v114))
            goto LABEL_143;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v93 = objc_claimAutoreleasedReturnValue();
            v94 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              v117 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_182FBE000, v93, v94, "%{public}s called with null protocol", buf, 0xCu);
            }
            goto LABEL_136;
          }
          if (!v114)
          {
            __nwlog_obj();
            v93 = objc_claimAutoreleasedReturnValue();
            v103 = type;
            if (os_log_type_enabled(v93, type))
            {
              *(_DWORD *)buf = 136446210;
              v117 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_182FBE000, v93, v103, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_136;
          }
          v97 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v98 = objc_claimAutoreleasedReturnValue();
          v99 = type;
          v100 = os_log_type_enabled(v98, type);
          if (v97)
          {
            if (v100)
            {
              *(_DWORD *)buf = 136446466;
              v117 = "nw_protocol_utilities_add_input_handler";
              v118 = 2082;
              v119 = (uint64_t)v97;
              _os_log_impl(&dword_182FBE000, v98, v99, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            goto LABEL_130;
          }
          if (v100)
          {
            *(_DWORD *)buf = 136446210;
            v117 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v98, v99, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }
        }

        goto LABEL_143;
      }
      v84 = a2;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v85 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
      {
        loga = nw_endpoint_handler_get_id_string(v5);
        v106 = nw_endpoint_handler_dry_run_string(v5);
        v86 = nw_endpoint_handler_copy_endpoint(v5);
        v87 = nw_endpoint_get_logging_description(v86);
        v88 = nw_endpoint_handler_state_string(v5);
        v89 = nw_endpoint_handler_mode_string(v5);
        v90 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136448002;
        v117 = "nw_endpoint_flow_attach_channel_protocol";
        v118 = 2082;
        v119 = (uint64_t)loga;
        v120 = 2082;
        v121 = (void *)v106;
        v122 = 2082;
        v123 = v87;
        v124 = 2082;
        v125 = v88;
        v126 = 2082;
        v127 = v89;
        v128 = 2114;
        v129 = v90;
        v130 = 1024;
        v131 = a3;
        v35 = v85;
        _os_log_impl(&dword_182FBE000, v85, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] opened channel at level %u", buf, 0x4Eu);

        a2 = v84;
      }
      else
      {
        v35 = v85;
      }
    }
    else
    {
      if ((logging_disabled & 1) != 0)
        goto LABEL_33;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v35 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
      {
        v105 = a2;
        log = v35;
        v36 = nw_endpoint_handler_get_id_string(v5);
        v37 = nw_endpoint_handler_dry_run_string(v5);
        v38 = nw_endpoint_handler_copy_endpoint(v5);
        v39 = a3;
        v40 = nw_endpoint_get_logging_description(v38);
        v41 = nw_endpoint_handler_state_string(v5);
        v42 = nw_endpoint_handler_mode_string(v5);
        v43 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136448002;
        v117 = "nw_endpoint_flow_attach_channel_protocol";
        v118 = 2082;
        v119 = (uint64_t)v36;
        v120 = 2082;
        v121 = (void *)v37;
        v122 = 2082;
        v123 = v40;
        v124 = 2082;
        v125 = v41;
        v126 = 2082;
        v127 = v42;
        v128 = 2114;
        v129 = v43;
        v130 = 1024;
        a3 = v39;
        v131 = v39;
        v35 = log;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] opened channel at level %u", buf, 0x4Eu);

        a2 = v105;
      }
    }

    goto LABEL_33;
  }
  if ((nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = nw_endpoint_handler_get_id_string(v5);
      v9 = nw_endpoint_handler_dry_run_string(v5);
      v10 = nw_endpoint_handler_copy_endpoint(v5);
      v11 = nw_endpoint_get_logging_description(v10);
      v12 = nw_endpoint_handler_state_string(v5);
      v13 = nw_endpoint_handler_mode_string(v5);
      v14 = nw_endpoint_handler_copy_current_path(v5);
      *(_DWORD *)buf = 136447746;
      v117 = "nw_endpoint_flow_attach_channel_protocol";
      v118 = 2082;
      v119 = (uint64_t)v8;
      v120 = 2082;
      v121 = (void *)v9;
      v122 = 2082;
      v123 = v11;
      v124 = 2082;
      v125 = v12;
      v126 = 2082;
      v127 = v13;
      v128 = 2114;
      v129 = v14;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow does not use channels", buf, 0x48u);

    }
  }
  v15 = 0;
LABEL_103:

  return v15;
}

void sub_1830F29CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void nw_path_flow_registration_set_stats_region(void *a1, int a2, __int128 *a3, uint64_t a4)
{
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_flow_registration_set_stats_region";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_flow_registration_set_stats_region";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v10)
          goto LABEL_11;
LABEL_62:
        free(v10);
        goto LABEL_11;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_60:

    goto LABEL_61;
  }
  if (!a3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_flow_registration_set_stats_region";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null protocol_identifier", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v26, "%{public}s called with null protocol_identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_60;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null protocol_identifier, no backtrace", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_path_flow_registration_set_stats_region";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_41;
  }
  if ((a2 & 0xFFFFFFFE) != 2)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_flow_registration_set_stats_region";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null (level == nw_protocol_level_internet || level == nw_protocol_level_transport)", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null (level == nw_protocol_level_internet || level == nw_protocol_level_transport), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_60;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_flow_registration_set_stats_region";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null (level == nw_protocol_level_internet || level == nw_protocol_level_transport), no backtrace", buf, 0xCu);
      }
      goto LABEL_60;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_path_flow_registration_set_stats_region";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null (level == nw_protocol_level_internet || level == nw_protocol_level_transport), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_41:

    free(v20);
    if (!v10)
      goto LABEL_11;
    goto LABEL_62;
  }
  if (a2 == 3)
  {
    if (nw_protocol_get_quic_connection_protocol_identifier() == a3
      || nw_protocol_get_quic_stream_protocol_identifier() == (int *)a3)
    {
      v8[11] = a3;
      v8[14] = a4;
    }
    else
    {
      v8[12] = a3;
      v8[15] = a4;
    }
  }
  else if (a2 == 2)
  {
    v7[13] = a3;
    v7[16] = a4;
  }
LABEL_11:

}

void sub_1830F31A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_channel_get_stats_region(uint64_t a1, int a2)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  uint32_t v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  _WORD v22[17];

  *(_QWORD *)&v22[13] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_channel_get_stats_region";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v4, &type, &v17))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_channel_get_stats_region";
      v7 = "%{public}s called with null channel";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v16 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_channel_get_stats_region";
          v21 = 2082;
          *(_QWORD *)v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (!v16)
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_channel_get_stats_region";
      v7 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_channel_get_stats_region";
      v7 = "%{public}s called with null channel, backtrace limit exceeded";
    }
    v10 = v13;
    v11 = v14;
    v12 = 12;
LABEL_20:
    _os_log_impl(&dword_182FBE000, v10, v11, v7, buf, v12);
    goto LABEL_21;
  }
  if (!*(_QWORD *)(a1 + 136))
    return 0;
  if ((a2 - 1) < 5)
    return os_channel_get_stats_region();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v20 = "nw_channel_get_stats_region";
  v21 = 1024;
  *(_DWORD *)v22 = a2;
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v4, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446466;
      v20 = "nw_channel_get_stats_region";
      v21 = 1024;
      *(_DWORD *)v22 = a2;
      v7 = "%{public}s Unknown stats type %u";
    }
    else if (v17)
    {
      v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v8)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          v20 = "nw_channel_get_stats_region";
          v21 = 1024;
          *(_DWORD *)v22 = a2;
          v22[2] = 2082;
          *(_QWORD *)&v22[3] = v8;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s Unknown stats type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v8);
        if (!v4)
          return 0;
        goto LABEL_22;
      }
      if (!v9)
        goto LABEL_21;
      *(_DWORD *)buf = 136446466;
      v20 = "nw_channel_get_stats_region";
      v21 = 1024;
      *(_DWORD *)v22 = a2;
      v7 = "%{public}s Unknown stats type %u, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      v6 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446466;
      v20 = "nw_channel_get_stats_region";
      v21 = 1024;
      *(_DWORD *)v22 = a2;
      v7 = "%{public}s Unknown stats type %u, backtrace limit exceeded";
    }
    v10 = v5;
    v11 = v6;
    v12 = 18;
    goto LABEL_20;
  }
LABEL_21:
  if (v4)
LABEL_22:
    free(v4);
  return 0;
}

__int128 *nw_protocol_get_quic_connection_protocol_identifier()
{
  __int128 *result;
  id v1;
  id v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  result = (__int128 *)nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier;
  if (nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier)
    return result;
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  v1 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (v1)
  {
    v2 = v1;

    nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier = (uint64_t)v2 + 8;
    return (__int128 *)nw_protocol_get_quic_connection_protocol_identifier::quic_connection_protocol_identifier;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_get_quic_connection_protocol_identifier";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_get_quic_connection_protocol_identifier";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null quic_connection_definition", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_protocol_get_quic_connection_protocol_identifier";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null quic_connection_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_get_quic_connection_protocol_identifier";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null quic_connection_definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_get_quic_connection_protocol_identifier";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null quic_connection_definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v4)
    free(v4);
  if (nw_protocol_dummy_quic_connection_identifier(void)::onceToken != -1)
    dispatch_once(&nw_protocol_dummy_quic_connection_identifier(void)::onceToken, &__block_literal_global_60_55303);
  return &nw_protocol_dummy_quic_connection_identifier(void)::dummy_quic_connection_identifier;
}

void nw_channel_set_defer_input_available(uint64_t a1, int a2)
{
  __int16 v2;
  int v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
      v2 = 128;
    else
      v2 = 0;
    v3 = *(_WORD *)(a1 + 444) & 0xFF7F | (*(unsigned __int8 *)(a1 + 446) << 16);
    *(_WORD *)(a1 + 444) = *(_WORD *)(a1 + 444) & 0xFF7F | v2;
    *(_BYTE *)(a1 + 446) = BYTE2(v3);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_channel_set_defer_input_available";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_set_defer_input_available";
      v7 = "%{public}s called with null channel";
      goto LABEL_20;
    }
    if (!v10)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_set_defer_input_available";
      v7 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v13 = "nw_channel_set_defer_input_available";
        v14 = 2082;
        v15 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_set_defer_input_available";
      v7 = "%{public}s called with null channel, no backtrace";
LABEL_20:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_21:
  if (v4)
    free(v4);
}

void nw_channel_set_protocol_level(uint64_t a1, int a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_DWORD *)(a1 + 264) = a2;
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_channel_set_protocol_level";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v11 = "nw_channel_set_protocol_level";
      v5 = "%{public}s called with null channel";
      goto LABEL_16;
    }
    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v11 = "nw_channel_set_protocol_level";
      v5 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = type;
    v7 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        v11 = "nw_channel_set_protocol_level";
        v12 = 2082;
        v13 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_17;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      v11 = "nw_channel_set_protocol_level";
      v5 = "%{public}s called with null channel, no backtrace";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_17:
  if (v2)
    free(v2);
}

void nw_channel_set_close_automatically(uint64_t a1, int a2)
{
  __int16 v2;
  int v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
      v2 = 32;
    else
      v2 = 0;
    v3 = *(_WORD *)(a1 + 444) & 0xFFDF | (*(unsigned __int8 *)(a1 + 446) << 16);
    *(_WORD *)(a1 + 444) = *(_WORD *)(a1 + 444) & 0xFFDF | v2;
    *(_BYTE *)(a1 + 446) = BYTE2(v3);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_channel_set_close_automatically";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_set_close_automatically";
      v7 = "%{public}s called with null channel";
      goto LABEL_20;
    }
    if (!v10)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_set_close_automatically";
      v7 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        v13 = "nw_channel_set_close_automatically";
        v14 = 2082;
        v15 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      v13 = "nw_channel_set_close_automatically";
      v7 = "%{public}s called with null channel, no backtrace";
LABEL_20:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_21:
  if (v4)
    free(v4);
}

uint64_t nw_channel_get_protocol_handler(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return a1 + 24;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_channel_get_protocol_handler";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_channel_get_protocol_handler";
        v5 = "%{public}s called with null channel";
LABEL_16:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      v7 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_channel_get_protocol_handler";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_17;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_channel_get_protocol_handler";
        v5 = "%{public}s called with null channel, no backtrace";
        goto LABEL_16;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_channel_get_protocol_handler";
        v5 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }
LABEL_17:
  if (v2)
    free(v2);
  return 0;
}

int *nw_protocol_get_quic_stream_protocol_identifier()
{
  int *result;
  id v1;
  id v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  result = (int *)nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier;
  if (nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier)
    return result;
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  v1 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  if (v1)
  {
    v2 = v1;

    nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier = (uint64_t)v2 + 8;
    return (int *)nw_protocol_get_quic_stream_protocol_identifier::quic_stream_protocol_identifier;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_get_quic_stream_protocol_identifier";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_get_quic_stream_protocol_identifier";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null quic_stream_definition", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_protocol_get_quic_stream_protocol_identifier";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null quic_stream_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_get_quic_stream_protocol_identifier";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null quic_stream_definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_get_quic_stream_protocol_identifier";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null quic_stream_definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v4)
    free(v4);
  if (nw_protocol_dummy_quic_stream_identifier(void)::onceToken != -1)
    dispatch_once(&nw_protocol_dummy_quic_stream_identifier(void)::onceToken, &__block_literal_global_61_55311);
  return &nw_protocol_dummy_quic_stream_identifier(void)::dummy_quic_stream_identifier;
}

uint64_t nw_path_flow_registration_should_use_event_ring(void *a1, void *a2)
{
  NWConcrete_nw_path *v3;
  NWConcrete_nw_path_flow_registration *v4;
  id v5;
  void *v6;
  uint64_t should_use_event_ring;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v5 = nw_path_copy_flow_for_registration(v3, v4);
    v6 = v5;
    if (v5)
      should_use_event_ring = nw_path_flow_nexus_should_use_event_ring(v5);
    else
      should_use_event_ring = 0;

    goto LABEL_6;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_path_flow_registration_should_use_event_ring";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_flow_registration_should_use_event_ring";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_path_flow_registration_should_use_event_ring";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_flow_registration_should_use_event_ring";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_flow_registration_should_use_event_ring";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v10)
    free(v10);
  should_use_event_ring = 0;
LABEL_6:

  return should_use_event_ring;
}

uint64_t nw_path_flow_nexus_should_use_event_ring(void *a1)
{
  id v1;
  void *v2;
  _QWORD *v3;
  void *v4;
  _DWORD *data;
  _DWORD *v6;
  BOOL v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  _BYTE length[12];
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(_QWORD *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null flow", length, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)length = 136446466;
            *(_QWORD *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null flow, dumping backtrace:%{public}s", length, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v16)
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null flow, no backtrace", length, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_nexus_should_use_event_ring";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null flow, backtrace limit exceeded", length, 0xCu);
        }
      }

    }
LABEL_32:
    if (v11)
      free(v11);
    goto LABEL_12;
  }
  v3 = v1;
  v4 = (void *)v3[3];
  if (v4
    && (*(_QWORD *)length = 0, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) != 0)
    && *(_QWORD *)length >= 0xD8uLL
    && (v6 = data, *(_QWORD *)length == data[53] + 216)
    && ((data[52] & 0xE080) != 0 ? (v7 = (data[52] & 0x13) == 1) : (v7 = 1), !v7))
  {

    if (v6[53] >= 0xCCu)
    {
      v8 = (*((unsigned __int8 *)v6 + 416) >> 2) & 1;
      goto LABEL_13;
    }
  }
  else
  {

  }
LABEL_12:
  v8 = 0;
LABEL_13:

  return v8;
}

uint64_t nw_path_flow_registration_can_support_user_packet_pool(void *a1, void *a2)
{
  NWConcrete_nw_path *v3;
  NWConcrete_nw_path_flow_registration *v4;
  id v5;
  void *v6;
  uint64_t can_support_user_packet_pool;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v5 = nw_path_copy_flow_for_registration(v3, v4);
    v6 = v5;
    if (v5)
      can_support_user_packet_pool = nw_path_flow_nexus_can_support_user_packet_pool(v5);
    else
      can_support_user_packet_pool = 0;

    goto LABEL_6;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_path_flow_registration_can_support_user_packet_pool";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_path_flow_registration_can_support_user_packet_pool";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_path_flow_registration_can_support_user_packet_pool";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v10)
    free(v10);
  can_support_user_packet_pool = 0;
LABEL_6:

  return can_support_user_packet_pool;
}

uint64_t nw_path_flow_nexus_can_support_user_packet_pool(void *a1)
{
  id v1;
  void *v2;
  _QWORD *v3;
  void *v4;
  _DWORD *data;
  _DWORD *v6;
  BOOL v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  _BYTE length[12];
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(_QWORD *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null flow", length, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)length = 136446466;
            *(_QWORD *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null flow, dumping backtrace:%{public}s", length, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v16)
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null flow, no backtrace", length, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_nexus_can_support_user_packet_pool";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null flow, backtrace limit exceeded", length, 0xCu);
        }
      }

    }
LABEL_32:
    if (v11)
      free(v11);
    goto LABEL_12;
  }
  v3 = v1;
  v4 = (void *)v3[3];
  if (v4
    && (*(_QWORD *)length = 0, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) != 0)
    && *(_QWORD *)length >= 0xD8uLL
    && (v6 = data, *(_QWORD *)length == data[53] + 216)
    && ((data[52] & 0xE080) != 0 ? (v7 = (data[52] & 0x13) == 1) : (v7 = 1), !v7))
  {

    if (v6[53] >= 0xCCu)
    {
      v8 = v6[104] & 1;
      goto LABEL_13;
    }
  }
  else
  {

  }
LABEL_12:
  v8 = 0;
LABEL_13:

  return v8;
}

BOOL nw_channel_set_path_flow_registration(uint64_t a1, void *a2, void *a3)
{
  unsigned __int8 *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  uint64_t node;
  uint64_t v11;
  void *v12;
  unsigned __int8 *v13;
  uint64_t advisory_region;
  unsigned __int8 *v15;
  _BOOL8 result;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  NSObject *v20;
  _BOOL4 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  char v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  _QWORD v28[2];
  os_log_type_t type[24];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_channel_set_path_flow_registration";
    v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, type, &v24))
      goto LABEL_26;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type[0];
        v21 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (!v21)
            goto LABEL_18;
          *(_DWORD *)buf = 136446466;
          v26 = "nw_channel_set_path_flow_registration";
          v27 = 2082;
          v28[0] = backtrace_string;
          v19 = "%{public}s called with null channel, dumping backtrace:%{public}s";
          goto LABEL_17;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_channel_set_path_flow_registration";
          v9 = "%{public}s called with null channel, no backtrace";
          goto LABEL_25;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_channel_set_path_flow_registration";
          v9 = "%{public}s called with null channel, backtrace limit exceeded";
          goto LABEL_25;
        }
      }
      goto LABEL_26;
    }
    v7 = __nwlog_obj();
    v8 = type[0];
    if (!os_log_type_enabled(v7, type[0]))
      goto LABEL_26;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_channel_set_path_flow_registration";
    v9 = "%{public}s called with null channel";
LABEL_25:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_26;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_channel_set_path_flow_registration";
    v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, type, &v24))
      goto LABEL_26;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type[0];
        v22 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (!v22)
            goto LABEL_18;
          *(_DWORD *)buf = 136446466;
          v26 = "nw_channel_set_path_flow_registration";
          v27 = 2082;
          v28[0] = backtrace_string;
          v19 = "%{public}s called with null path, dumping backtrace:%{public}s";
          goto LABEL_17;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_channel_set_path_flow_registration";
          v9 = "%{public}s called with null path, no backtrace";
          goto LABEL_25;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_channel_set_path_flow_registration";
          v9 = "%{public}s called with null path, backtrace limit exceeded";
          goto LABEL_25;
        }
      }
      goto LABEL_26;
    }
    v7 = __nwlog_obj();
    v8 = type[0];
    if (!os_log_type_enabled(v7, type[0]))
      goto LABEL_26;
    *(_DWORD *)buf = 136446210;
    v26 = "nw_channel_set_path_flow_registration";
    v9 = "%{public}s called with null path";
    goto LABEL_25;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_channel_set_path_flow_registration";
    v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v6, type, &v24))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_channel_set_path_flow_registration";
          v9 = "%{public}s called with null flow_registration";
          goto LABEL_25;
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type[0];
        v23 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (!v23)
            goto LABEL_18;
          *(_DWORD *)buf = 136446466;
          v26 = "nw_channel_set_path_flow_registration";
          v27 = 2082;
          v28[0] = backtrace_string;
          v19 = "%{public}s called with null flow_registration, dumping backtrace:%{public}s";
          goto LABEL_17;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_channel_set_path_flow_registration";
          v9 = "%{public}s called with null flow_registration, no backtrace";
          goto LABEL_25;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_channel_set_path_flow_registration";
          v9 = "%{public}s called with null flow_registration, backtrace limit exceeded";
          goto LABEL_25;
        }
      }
    }
LABEL_26:
    if (v6)
      free(v6);
    return 0;
  }
  v5 = a3;
  if (uuid_is_null(v5 + 32))
  {

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_channel_set_path_flow_registration";
    v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, type, &v24))
      goto LABEL_26;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_channel_set_path_flow_registration";
      v9 = "%{public}s nw_path_flow_registration_get_id failed";
      goto LABEL_25;
    }
    if (!v24)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_channel_set_path_flow_registration";
      v9 = "%{public}s nw_path_flow_registration_get_id failed, backtrace limit exceeded";
      goto LABEL_25;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = type[0];
    v18 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_channel_set_path_flow_registration";
      v9 = "%{public}s nw_path_flow_registration_get_id failed, no backtrace";
      goto LABEL_25;
    }
    if (!v18)
    {
LABEL_18:
      free(backtrace_string);
      goto LABEL_26;
    }
    *(_DWORD *)buf = 136446466;
    v26 = "nw_channel_set_path_flow_registration";
    v27 = 2082;
    v28[0] = backtrace_string;
    v19 = "%{public}s nw_path_flow_registration_get_id failed, dumping backtrace:%{public}s";
LABEL_17:
    _os_log_impl(&dword_182FBE000, v7, v8, v19, buf, 0x16u);
    goto LABEL_18;
  }
  *(_OWORD *)type = *((_OWORD *)v5 + 2);

  node = nw_hash_table_get_node(*(_QWORD *)(a1 + 280), (uint64_t)type, 16);
  if (!node)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446722;
    v26 = "nw_channel_set_path_flow_registration";
    v27 = 1042;
    LODWORD(v28[0]) = 16;
    WORD2(v28[0]) = 2098;
    *(_QWORD *)((char *)v28 + 6) = type;
    _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s Node not found for flow id %{public,uuid_t}.16P", buf, 0x1Cu);
    return 0;
  }
  v11 = node;
  v12 = *(void **)(node + 48);
  *(_QWORD *)(node + 48) = os_retain(v5);
  nw_path_flow_registration_get_nexus_flow_index(a2, v5, (_DWORD *)(v11 + 112));
  LODWORD(v11) = *(unsigned __int16 *)(a1 + 444);
  v13 = v5;
  v13[148] = v13[148] & 0xFD | (v11 >> 10) & 2;

  advisory_region = nw_channel_get_advisory_region(a1);
  v15 = v13;
  *((_QWORD *)v15 + 10) = advisory_region;

  if (v12)
    os_release(v12);
  return 1;
}

void sub_1830F59F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_channel_get_advisory_region(uint64_t a1)
{
  NSObject *v1;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  os_log_type_t v9[15];
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)v9 = 0;
    if (*(_QWORD *)(a1 + 144))
    {
      os_channel_attr_get();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v1 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_channel_get_advisory_region";
        _os_log_impl(&dword_182FBE000, v1, OS_LOG_TYPE_DEFAULT, "%{public}s advisory region not supported by this channel", buf, 0xCu);
      }
    }
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_channel_get_advisory_region";
  v3 = (char *)_os_log_send_and_compose_impl();
  v9[0] = OS_LOG_TYPE_ERROR;
  type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v3, v9, &type))
    goto LABEL_5;
  if (v9[0] == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = v9[0];
    if (!os_log_type_enabled(v4, v9[0]))
      goto LABEL_5;
    *(_DWORD *)buf = 136446210;
    v12 = "nw_channel_get_advisory_region";
    v6 = "%{public}s called with null channel";
    goto LABEL_22;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    v4 = __nwlog_obj();
    v5 = v9[0];
    if (!os_log_type_enabled(v4, v9[0]))
      goto LABEL_5;
    *(_DWORD *)buf = 136446210;
    v12 = "nw_channel_get_advisory_region";
    v6 = "%{public}s called with null channel, backtrace limit exceeded";
    goto LABEL_22;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = v9[0];
  v8 = os_log_type_enabled(v4, v9[0]);
  if (!backtrace_string)
  {
    if (!v8)
      goto LABEL_5;
    *(_DWORD *)buf = 136446210;
    v12 = "nw_channel_get_advisory_region";
    v6 = "%{public}s called with null channel, no backtrace";
LABEL_22:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
LABEL_5:
    if (!v3)
      return 0;
LABEL_6:
    free(v3);
    return 0;
  }
  if (v8)
  {
    *(_DWORD *)buf = 136446466;
    v12 = "nw_channel_get_advisory_region";
    v13 = 2082;
    v14 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null channel, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(backtrace_string);
  if (v3)
    goto LABEL_6;
  return 0;
}

void *nw_parameters_get_upper_transport_protocol_identifier(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  id v5;
  _BOOL4 v6;
  void *quic_stream_protocol_identifier;
  nw_protocol_definition_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_parameters_get_upper_transport_protocol_identifier";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_parameters_get_upper_transport_protocol_identifier";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v21 = "nw_parameters_get_upper_transport_protocol_identifier";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_parameters_get_upper_transport_protocol_identifier";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_parameters_get_upper_transport_protocol_identifier";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v10)
      free(v10);
    goto LABEL_28;
  }
  v3 = v1[19];
  if (!v3 || (v4 = *(void **)(v3 + 24)) == 0)
  {
LABEL_28:
    quic_stream_protocol_identifier = 0;
    goto LABEL_29;
  }
  v5 = v4;
  if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1)
    dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45078);
  v6 = nw_protocol_options_matches_definition(v5, (void *)g_udp_definition);

  if (v6 && nw_udp_options_get_use_quic_stats(*(void **)(v2[19] + 24)))
  {
    quic_stream_protocol_identifier = nw_protocol_get_quic_stream_protocol_identifier();
  }
  else
  {
    v8 = nw_protocol_options_copy_definition(*(nw_protocol_options_t *)(v2[19] + 24));
    quic_stream_protocol_identifier = nw_protocol_definition_get_identifier(v8);

  }
LABEL_29:

  return quic_stream_protocol_identifier;
}

void sub_1830F631C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_options *nw_quic_create_stream_options()
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  return nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
}

uint64_t __nw_path_copy_inactive_agent_uuids_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  const unsigned __int8 *data;
  const unsigned __int8 *v7;
  int v8;
  void *v9;
  xpc_object_t v10;
  uint64_t v11;
  void *v12;
  size_t length;

  v4 = a3;
  v5 = v4;
  length = 0;
  if (v4)
  {
    data = (const unsigned __int8 *)xpc_dictionary_get_data(v4, "data", &length);
    if (data)
    {
      if (length >= 0xD8)
      {
        v7 = data;
        if (length == *((unsigned int *)data + 53) + 216)
        {
          v8 = *((_DWORD *)data + 52);
          if ((v8 & 2) == 0 && ((v8 & 0x10) != 0 || !*(_BYTE *)(a1 + 40)))
          {
            v9 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
            if (!v9)
            {
              v10 = xpc_array_create(0, 0);
              v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
              v12 = *(void **)(v11 + 40);
              *(_QWORD *)(v11 + 40) = v10;

              v9 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
            }
            xpc_array_set_uuid(v9, 0xFFFFFFFFFFFFFFFFLL, v7);
          }
        }
      }
    }
  }

  return 1;
}

void sub_1830F6450(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void NWActivity.complete(reason:)(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  char v4;
  void *v5;
  uint64_t v6;

  v3 = *(_QWORD *)a1;
  v4 = *(_BYTE *)(a1 + 16);
  v5 = *(void **)(v1 + 16);
  if ((v4 & 1) != 0)
  {
    nw_activity_complete_with_reason(v5, v3 + 1);
    return;
  }
  if (v3 > 0x7FFFFFFF)
  {
    __break(1u);
LABEL_11:
    __break(1u);
    goto LABEL_12;
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v3 < (uint64_t)0xFFFFFFFF80000000 || v6 < (uint64_t)0xFFFFFFFF80000000)
    goto LABEL_11;
  if (v6 <= 0x7FFFFFFF)
  {
    nw_activity_complete_with_reason_and_underlying_error(v5, 3u, v3, v6);
    return;
  }
LABEL_12:
  __break(1u);
}

uint64_t nw_frame_array_insert_after(uint64_t result, int a2, _QWORD *a3, uint64_t a4)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;

  v4 = (_QWORD *)(result + 8);
  if (a2)
  {
    v6 = *(_QWORD *)(a4 + 32);
    v5 = (_QWORD *)(a4 + 32);
    a3[4] = v6;
    v7 = (_QWORD *)(v6 + 40);
    if (v6)
      v4 = v7;
    *v4 = a3 + 4;
    *v5 = a3;
    a3[5] = v5;
  }
  else
  {
    v9 = *(_QWORD *)(a4 + 16);
    v8 = (_QWORD *)(a4 + 16);
    a3[2] = v9;
    v10 = (_QWORD *)(v9 + 24);
    if (v9)
      v4 = v10;
    *v4 = a3 + 2;
    *v8 = a3;
    a3[3] = v8;
  }
  return result;
}

uint64_t nw_path_flow_registration_get_advisory_region(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 10);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_flow_registration_get_advisory_region";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null flow_registration", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_flow_registration_get_advisory_region";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_flow_registration_get_advisory_region";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_endpoint_transform_start_next_child(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  NWConcrete_nw_endpoint_handler *v3;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v5;
  NWConcrete_nw_endpoint_mode_handler *v6;
  uint64_t v7;
  unint64_t v8;
  NWConcrete_nw_endpoint_handler *v9;
  uint64_t v10;
  NWConcrete_nw_endpoint_mode_handler *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  _DWORD *v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int64_t int64;
  int v23;
  int v24;
  NWConcrete_nw_endpoint_handler *v25;
  BOOL v26;
  NSObject *v27;
  NWConcrete_nw_endpoint_handler *v28;
  NWConcrete_nw_endpoint_handler *v29;
  _BOOL4 v30;
  const char *v31;
  nw_endpoint_t v32;
  const char *v33;
  unsigned int *v34;
  unsigned int *v35;
  uint64_t v36;
  const char *v37;
  id *v38;
  id v39;
  int upper_transport_protocol;
  NWConcrete_nw_endpoint_handler *v41;
  int state;
  NWConcrete_nw_endpoint_handler *v43;
  _BOOL4 v44;
  const char *v45;
  const char *v46;
  nw_endpoint_t v47;
  const char *v48;
  const char *v49;
  const char *v50;
  id v51;
  NSObject *v52;
  void **v53;
  void **v54;
  int v55;
  const char *v56;
  NWConcrete_nw_endpoint_handler *v57;
  int v58;
  NWConcrete_nw_endpoint_handler *v59;
  int64_t v60;
  unsigned int v61;
  uint64_t v62;
  unint64_t v63;
  NWConcrete_nw_endpoint_handler *v64;
  unsigned int v65;
  NWConcrete_nw_endpoint_mode_handler *v66;
  uint64_t v67;
  uint64_t v68;
  NSObject *v69;
  int minimize_logging;
  char logging_disabled;
  const char *v72;
  const char *v73;
  nw_endpoint_t v74;
  const char *v75;
  const char *v76;
  const char *v77;
  id v78;
  void **v79;
  id v80;
  id v81;
  unsigned int v82;
  const char *v83;
  void *v84;
  char *v85;
  NSObject *v86;
  os_log_type_t v87;
  unsigned int v88;
  NSObject *v89;
  const char *v90;
  char *backtrace_string;
  os_log_type_t v92;
  _BOOL4 v93;
  os_log_type_t v94;
  id v95;
  void *v96;
  id v97;
  NSObject *v98;
  NSObject *v99;
  _BOOL4 is_speculative_attempt;
  const char *v101;
  const char *v102;
  const char *v103;
  id v104;
  NSObject *v105;
  const char *v106;
  nw_endpoint_t v107;
  id v108;
  const char *v109;
  NSObject *v110;
  nw_endpoint_t v111;
  id v112;
  const char *v113;
  const char *v114;
  unint64_t v115;
  NWConcrete_nw_endpoint_handler *v116;
  int v117;
  char v118;
  NWConcrete_nw_endpoint_mode_handler *v119;
  NSObject *v120;
  const char *v121;
  const char *v122;
  nw_endpoint_t v123;
  const char *v124;
  const char *v125;
  const char *v126;
  id v127;
  id v128;
  uint64_t v129;
  dispatch_time_t v130;
  uint64_t v131;
  void *v132;
  char *v133;
  NSObject *v134;
  os_log_type_t v135;
  char *v136;
  os_log_type_t v137;
  _BOOL4 v138;
  os_log_type_t v139;
  const char *v140;
  const char *v141;
  nw_endpoint_t v142;
  const char *v143;
  const char *v144;
  const char *v145;
  id v146;
  NSObject *v147;
  const char *id_string;
  nw_endpoint_t v149;
  const char *v150;
  const char *v151;
  id v152;
  const char *v153;
  const char *v154;
  nw_endpoint_t v155;
  const char *v156;
  const char *v157;
  const char *v158;
  id v159;
  const char *v160;
  nw_endpoint_t v161;
  const char *v162;
  const char *v163;
  const char *v164;
  id v165;
  void *v166;
  char *v167;
  NSObject *v168;
  os_log_type_t v169;
  void *v170;
  char *v171;
  NSObject *v172;
  os_log_type_t v173;
  char *v174;
  NSObject *v175;
  os_log_type_t v176;
  _BOOL4 v177;
  char *v178;
  NSObject *v179;
  os_log_type_t v180;
  _BOOL4 v181;
  void *v182;
  char *v183;
  NSObject *v184;
  os_log_type_t v185;
  void *v186;
  os_log_type_t v187;
  NSObject *v188;
  const char *v189;
  const char *v190;
  id v191;
  void *v192;
  char *v193;
  NSObject *v194;
  os_log_type_t v195;
  _BOOL4 v196;
  char *v197;
  os_log_type_t v198;
  _BOOL4 v199;
  os_log_type_t v200;
  os_log_type_t v201;
  os_log_type_t v202;
  os_log_type_t v203;
  const char *v204;
  const char *v205;
  const char *v206;
  const char *v207;
  const char *v208;
  const char *v209;
  const char *v210;
  const char *v211;
  const char *v212;
  const char *v213;
  const char *v214;
  const char *v215;
  const char *v216;
  const char *v217;
  unint64_t v218;
  id v219;
  const char *v220;
  NSObject *v221;
  void *v222;
  nw_endpoint_t v223;
  unint64_t v224;
  const char *logging_description;
  nw_endpoint_t v226;
  size_t v227;
  NWConcrete_nw_endpoint_handler *v228;
  NWConcrete_nw_endpoint_mode_handler *v229;
  id v230;
  const char *v231;
  _QWORD v232[4];
  NSObject *v233;
  _QWORD v234[4];
  NSObject *v235;
  char v236;
  os_log_type_t v237;
  uint8_t buf[4];
  const char *v239;
  __int16 v240;
  char *id_str;
  __int16 v242;
  const char *v243;
  __int16 v244;
  const char *v245;
  __int16 v246;
  const char *v247;
  __int16 v248;
  const char *v249;
  __int16 v250;
  id v251;
  __int16 v252;
  unint64_t v253;
  __int16 v254;
  const char *v255;
  uint64_t v256;

  v256 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v84 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v239 = "nw_endpoint_transform_start_next_child";
    v85 = (char *)_os_log_send_and_compose_impl();

    v237 = OS_LOG_TYPE_ERROR;
    v236 = 0;
    if (__nwlog_fault(v85, &v237, &v236))
    {
      if (v237 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v86 = objc_claimAutoreleasedReturnValue();
        v87 = v237;
        if (os_log_type_enabled(v86, v237))
        {
          *(_DWORD *)buf = 136446210;
          v239 = "nw_endpoint_transform_start_next_child";
          _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v236)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v86 = objc_claimAutoreleasedReturnValue();
        v92 = v237;
        v93 = os_log_type_enabled(v86, v237);
        if (backtrace_string)
        {
          if (v93)
          {
            *(_DWORD *)buf = 136446466;
            v239 = "nw_endpoint_transform_start_next_child";
            v240 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_182FBE000, v86, v92, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_186;
        }
        if (v93)
        {
          *(_DWORD *)buf = 136446210;
          v239 = "nw_endpoint_transform_start_next_child";
          _os_log_impl(&dword_182FBE000, v86, v92, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v86 = objc_claimAutoreleasedReturnValue();
        v94 = v237;
        if (os_log_type_enabled(v86, v237))
        {
          *(_DWORD *)buf = 136446210;
          v239 = "nw_endpoint_transform_start_next_child";
          _os_log_impl(&dword_182FBE000, v86, v94, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_186:
    if (v85)
      free(v85);
    goto LABEL_90;
  }
  v3 = v1;
  mode = v3->mode;

  if ((_DWORD)mode == 5)
  {
    v5 = nw_endpoint_handler_copy_transform(v3);
    v6 = v5;
    v7 = *((_QWORD *)v5 + 1);
    if (!v7 || *(_QWORD *)(v7 + 24) == *(_QWORD *)(v7 + 16))
    {
      nw_endpoint_handler_handle_failure(v3);
      v16 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
      v3->event = (nw_endpoint_handler_event_s)131079;
      nw_endpoint_handler_report(v3, 0, &v3->event.domain, v16);

LABEL_89:
      goto LABEL_90;
    }
    v8 = *((unsigned int *)v5 + 10);
    v9 = v3;
    v10 = v3->mode;

    v229 = v6;
    v227 = v8;
    if ((_DWORD)v10 != 5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (v10 > 5)
          v18 = "unknown-mode";
        else
          v18 = off_1E149FC18[v10];
        *(_DWORD *)buf = 136446722;
        v239 = "nw_endpoint_transform_get_child_at_index";
        v240 = 2082;
        id_str = (char *)v18;
        v242 = 2082;
        v243 = "transform";
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }

      goto LABEL_36;
    }
    v11 = nw_endpoint_handler_copy_transform(v9);
    v12 = *((_QWORD *)v11 + 1);
    if (v12)
    {
      v13 = *(_QWORD *)(v12 + 24) - *(_QWORD *)(v12 + 16);
      if (v13)
      {
        if (v8 < v13 >> 3)
        {
          nw_array_get_object_at_index(v12, v8);
          v230 = (id)objc_claimAutoreleasedReturnValue();
          goto LABEL_25;
        }
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v9) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v147 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v147, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v9);
            v231 = nw_endpoint_handler_dry_run_string(v9);
            v149 = nw_endpoint_handler_copy_endpoint(v9);
            logging_description = nw_endpoint_get_logging_description(v149);
            v150 = nw_endpoint_handler_state_string(v9);
            v151 = nw_endpoint_handler_mode_string(v9);
            v152 = nw_endpoint_handler_copy_current_path(v9);
            *(_DWORD *)buf = 136448002;
            v239 = "nw_endpoint_transform_get_child_at_index";
            v240 = 2082;
            id_str = (char *)id_string;
            v242 = 2082;
            v243 = v231;
            v244 = 2082;
            v245 = logging_description;
            v246 = 2082;
            v247 = v150;
            v248 = 2082;
            v249 = v151;
            v250 = 2114;
            v251 = v152;
            v252 = 1024;
            LODWORD(v253) = v227;
            _os_log_impl(&dword_182FBE000, v147, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no child at index %u", buf, 0x4Eu);

          }
        }
      }
    }
    v230 = 0;
LABEL_25:

    if (v230)
    {
      v20 = *((_QWORD *)v229 + 8);
      if (v20)
      {
        nw_queue_cancel_source(v20, v19);
        *((_QWORD *)v229 + 8) = 0;
      }
      v21 = (void *)*((_QWORD *)v229 + 3);
      if (v21 && xpc_array_get_count(v21) > v227)
      {
        int64 = xpc_array_get_int64(*((xpc_object_t *)v229 + 3), v227);
        if (int64 == 2)
          v23 = 2;
        else
          v23 = 1;
        if (int64 == 3)
          v24 = 3;
        else
          v24 = v23;
      }
      else
      {
        v24 = 1;
      }
      ++*((_DWORD *)v229 + 10);
      if (!(_DWORD)v227)
      {
        v38 = (id *)v230;
        v39 = v38[4];

        if (v39)
        {
          upper_transport_protocol = nw_parameters_get_upper_transport_protocol(v39);
          if (upper_transport_protocol != 253)
            upper_transport_protocol = nw_parameters_get_ip_protocol(v39);
          *((_DWORD *)v229 + 20) = upper_transport_protocol;
        }

      }
      nw_endpoint_handler_start(v230);
      v41 = v9;
      state = v41->state;

      if ((state & 0xFFFFFFFE) == 4)
      {
        if (nw_endpoint_handler_get_minimize_logging(v41))
        {
          if ((nw_endpoint_handler_get_logging_disabled(v41) & 1) != 0)
            goto LABEL_87;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v27 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            v140 = nw_endpoint_handler_get_id_string(v41);
            v141 = nw_endpoint_handler_dry_run_string(v41);
            v142 = nw_endpoint_handler_copy_endpoint(v41);
            v143 = nw_endpoint_get_logging_description(v142);
            v144 = nw_endpoint_handler_state_string(v41);
            v145 = nw_endpoint_handler_mode_string(v41);
            v146 = nw_endpoint_handler_copy_current_path(v41);
            *(_DWORD *)buf = 136447746;
            v239 = "nw_endpoint_transform_start_next_child";
            v240 = 2082;
            id_str = (char *)v140;
            v242 = 2082;
            v243 = v141;
            v244 = 2082;
            v245 = v143;
            v246 = 2082;
            v247 = v144;
            v248 = 2082;
            v249 = v145;
            v250 = 2114;
            v251 = v146;
            _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, handler cancelled or failed", buf, 0x48u);

          }
          goto LABEL_86;
        }
        v43 = v41;
        v44 = (*((_BYTE *)v43 + 268) & 0x20) == 0;

        if (v44)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v27 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
            goto LABEL_86;
          v45 = nw_endpoint_handler_get_id_string(v43);
          v46 = nw_endpoint_handler_dry_run_string(v43);
          v47 = nw_endpoint_handler_copy_endpoint(v43);
          v48 = nw_endpoint_get_logging_description(v47);
          v49 = nw_endpoint_handler_state_string(v43);
          v50 = nw_endpoint_handler_mode_string(v43);
          v51 = nw_endpoint_handler_copy_current_path(v43);
          *(_DWORD *)buf = 136447746;
          v239 = "nw_endpoint_transform_start_next_child";
          v240 = 2082;
          id_str = (char *)v45;
          v242 = 2082;
          v243 = v46;
          v244 = 2082;
          v245 = v48;
          v246 = 2082;
          v247 = v49;
          v248 = 2082;
          v249 = v50;
          v250 = 2114;
          v251 = v51;
          v52 = v27;
          _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, handler cancelled or failed", buf, 0x48u);

          goto LABEL_79;
        }
        goto LABEL_87;
      }
      v57 = v41;
      v58 = v3->mode;

      if (v58 != 5)
      {
        minimize_logging = nw_endpoint_handler_get_minimize_logging(v57);
        logging_disabled = nw_endpoint_handler_get_logging_disabled(v57);
        if (minimize_logging)
        {
          if ((logging_disabled & 1) != 0)
            goto LABEL_87;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v27 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            v153 = nw_endpoint_handler_get_id_string(v57);
            v154 = nw_endpoint_handler_dry_run_string(v57);
            v155 = nw_endpoint_handler_copy_endpoint(v57);
            v156 = nw_endpoint_get_logging_description(v155);
            v157 = nw_endpoint_handler_state_string(v57);
            v158 = nw_endpoint_handler_mode_string(v57);
            v159 = nw_endpoint_handler_copy_current_path(v57);
            *(_DWORD *)buf = 136447746;
            v239 = "nw_endpoint_transform_start_next_child";
            v240 = 2082;
            id_str = (char *)v153;
            v242 = 2082;
            v243 = v154;
            v244 = 2082;
            v245 = v156;
            v246 = 2082;
            v247 = v157;
            v248 = 2082;
            v249 = v158;
            v250 = 2114;
            v251 = v159;
            _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, no longer transform mode", buf, 0x48u);

          }
          goto LABEL_86;
        }
        if ((logging_disabled & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v27 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
            goto LABEL_86;
          v72 = nw_endpoint_handler_get_id_string(v57);
          v73 = nw_endpoint_handler_dry_run_string(v57);
          v74 = nw_endpoint_handler_copy_endpoint(v57);
          v75 = nw_endpoint_get_logging_description(v74);
          v76 = nw_endpoint_handler_state_string(v57);
          v77 = nw_endpoint_handler_mode_string(v57);
          v78 = nw_endpoint_handler_copy_current_path(v57);
          *(_DWORD *)buf = 136447746;
          v239 = "nw_endpoint_transform_start_next_child";
          v240 = 2082;
          id_str = (char *)v72;
          v242 = 2082;
          v243 = v73;
          v244 = 2082;
          v245 = v75;
          v246 = 2082;
          v247 = v76;
          v248 = 2082;
          v249 = v77;
          v250 = 2114;
          v251 = v78;
          v52 = v27;
          _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting next child timer, no longer transform mode", buf, 0x48u);

LABEL_79:
          v27 = v52;
LABEL_86:

        }
LABEL_87:

LABEL_88:
        v6 = v229;
        goto LABEL_89;
      }
      if (*((_QWORD *)v229 + 6))
        goto LABEL_87;
      if (v24 == 3)
      {
        v81 = nw_endpoint_handler_copy_context(v57);
        v232[0] = MEMORY[0x1E0C809B0];
        v232[1] = 3221225472;
        v232[2] = ___ZL38nw_endpoint_transform_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke_102;
        v232[3] = &unk_1E14ACFD0;
        v233 = v57;
        nw_queue_context_async(v81, v232);

        v27 = v233;
        goto LABEL_86;
      }
      if (v24 != 2)
        goto LABEL_87;
      v59 = v57;
      v230 = v230;
      v60 = 100 * networkd_settings_get_int64_with_default((const char *)nw_setting_transform_rtt_delay_factor, 2);
      v61 = nw_endpoint_handler_get_mode(v59);
      v228 = v59;
      if (v61 != 5)
      {
        v82 = v61;
        __nwlog_obj();
        v62 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled((os_log_t)v62, OS_LOG_TYPE_DEFAULT))
        {
          if (v82 > 5)
            v83 = "unknown-mode";
          else
            v83 = off_1E149FC18[v82];
          *(_DWORD *)buf = 136446722;
          v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
          v240 = 2082;
          id_str = (char *)v83;
          v242 = 2082;
          v243 = "transform";
          _os_log_impl(&dword_182FBE000, (os_log_t)v62, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
        goto LABEL_154;
      }
      v62 = (uint64_t)nw_endpoint_handler_copy_transform(v59);
      v63 = *(unsigned int *)(v62 + 40);
      v64 = v59;
      v65 = nw_endpoint_handler_get_mode(v64);
      if (v65 != 5)
      {
        v88 = v65;
        __nwlog_obj();
        v89 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          if (v88 > 5)
            v90 = "unknown-mode";
          else
            v90 = off_1E149FC18[v88];
          *(_DWORD *)buf = 136446722;
          v239 = "nw_endpoint_transform_get_child_at_index";
          v240 = 2082;
          id_str = (char *)v90;
          v242 = 2082;
          v243 = "transform";
          _os_log_impl(&dword_182FBE000, v89, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }

LABEL_126:
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v64) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v69 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
          {
            v215 = nw_endpoint_handler_get_id_string(v64);
            v210 = nw_endpoint_handler_dry_run_string(v64);
            v223 = nw_endpoint_handler_copy_endpoint(v64);
            v101 = nw_endpoint_get_logging_description(v223);
            v102 = nw_endpoint_handler_state_string(v64);
            v103 = nw_endpoint_handler_mode_string(v64);
            v104 = nw_endpoint_handler_copy_current_path(v64);
            *(_DWORD *)buf = 136448002;
            v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
            v240 = 2082;
            id_str = (char *)v215;
            v242 = 2082;
            v243 = v210;
            v244 = 2082;
            v245 = v101;
            v246 = 2082;
            v247 = v102;
            v248 = 2082;
            v249 = v103;
            v250 = 2114;
            v251 = v104;
            v252 = 1024;
            LODWORD(v253) = v63;
            _os_log_impl(&dword_182FBE000, v69, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no child at index %u", buf, 0x4Eu);

          }
          goto LABEL_153;
        }
LABEL_154:

        v115 = nw_endpoint_handler_get_child_timeout_nanos(v230) * v60;
        v116 = v228;
        v117 = nw_endpoint_handler_get_minimize_logging(v228);
        v118 = nw_endpoint_handler_get_logging_disabled(v228);
        v224 = v115 / 0x5F5E100;
        v119 = v229;
        v218 = v115;
        if (v117)
        {
          if ((v118 & 1) != 0)
          {
LABEL_161:
            *((_QWORD *)v119 + 9) = v224;
            v128 = nw_endpoint_handler_copy_context(v116);
            v234[0] = MEMORY[0x1E0C809B0];
            v234[1] = 3221225472;
            v234[2] = ___ZL38nw_endpoint_transform_start_next_childP30NWConcrete_nw_endpoint_handler_block_invoke;
            v234[3] = &unk_1E14ACFD0;
            v235 = v116;
            *((_QWORD *)v119 + 8) = nw_queue_context_create_source(v128, 2, 3, 0, v234, 0);

            v129 = *((_QWORD *)v119 + 8);
            if (v129)
            {
              v130 = dispatch_time(0x8000000000000000, v218 / 0x64);
              nw_queue_set_timer_values(v129, v130, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
              nw_queue_activate_source(*((_QWORD *)v229 + 8), v131);
LABEL_163:
              v27 = v235;
              goto LABEL_86;
            }
            __nwlog_obj();
            v132 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v239 = "nw_endpoint_transform_start_next_child";
            v133 = (char *)_os_log_send_and_compose_impl();

            v237 = OS_LOG_TYPE_ERROR;
            v236 = 0;
            if (__nwlog_fault(v133, &v237, &v236))
            {
              if (v237 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v134 = objc_claimAutoreleasedReturnValue();
                v135 = v237;
                if (os_log_type_enabled(v134, v237))
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_start_next_child";
                  _os_log_impl(&dword_182FBE000, v134, v135, "%{public}s nw_queue_context_create_source(timer) failed", buf, 0xCu);
                }
LABEL_179:

                goto LABEL_180;
              }
              if (!v236)
              {
                __nwlog_obj();
                v134 = objc_claimAutoreleasedReturnValue();
                v139 = v237;
                if (os_log_type_enabled(v134, v237))
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_start_next_child";
                  _os_log_impl(&dword_182FBE000, v134, v139, "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded", buf, 0xCu);
                }
                goto LABEL_179;
              }
              v136 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v134 = objc_claimAutoreleasedReturnValue();
              v137 = v237;
              v138 = os_log_type_enabled(v134, v237);
              if (!v136)
              {
                if (v138)
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_start_next_child";
                  _os_log_impl(&dword_182FBE000, v134, v137, "%{public}s nw_queue_context_create_source(timer) failed, no backtrace", buf, 0xCu);
                }
                goto LABEL_179;
              }
              if (v138)
              {
                *(_DWORD *)buf = 136446466;
                v239 = "nw_endpoint_transform_start_next_child";
                v240 = 2082;
                id_str = v136;
                _os_log_impl(&dword_182FBE000, v134, v137, "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v136);
            }
LABEL_180:
            if (v133)
            {
              free(v133);
              v27 = v235;
              goto LABEL_86;
            }
            goto LABEL_163;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v120 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
          {
            v213 = nw_endpoint_handler_get_id_string(v228);
            v160 = nw_endpoint_handler_dry_run_string(v228);
            v161 = nw_endpoint_handler_copy_endpoint(v228);
            v162 = nw_endpoint_get_logging_description(v161);
            v163 = nw_endpoint_handler_state_string(v228);
            v164 = nw_endpoint_handler_mode_string(v228);
            v165 = nw_endpoint_handler_copy_current_path(v228);
            *(_DWORD *)buf = 136448002;
            v239 = "nw_endpoint_transform_start_next_child";
            v240 = 2082;
            id_str = (char *)v213;
            v242 = 2082;
            v243 = v160;
            v244 = 2082;
            v245 = v162;
            v246 = 2082;
            v247 = v163;
            v248 = 2082;
            v249 = v164;
            v250 = 2114;
            v251 = v165;
            v252 = 2048;
            v253 = v224;
            _os_log_impl(&dword_182FBE000, v120, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums", buf, 0x52u);

          }
        }
        else
        {
          if ((v118 & 1) != 0)
            goto LABEL_161;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v120 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v120, OS_LOG_TYPE_INFO))
          {
            v121 = nw_endpoint_handler_get_id_string(v228);
            v122 = nw_endpoint_handler_dry_run_string(v228);
            v123 = nw_endpoint_handler_copy_endpoint(v228);
            v124 = nw_endpoint_get_logging_description(v123);
            v125 = nw_endpoint_handler_state_string(v228);
            v126 = nw_endpoint_handler_mode_string(v228);
            v127 = nw_endpoint_handler_copy_current_path(v228);
            *(_DWORD *)buf = 136448002;
            v239 = "nw_endpoint_transform_start_next_child";
            v240 = 2082;
            id_str = (char *)v121;
            v242 = 2082;
            v243 = v122;
            v244 = 2082;
            v245 = v124;
            v246 = 2082;
            v247 = v125;
            v248 = 2082;
            v249 = v126;
            v250 = 2114;
            v251 = v127;
            v252 = 2048;
            v253 = v224;
            _os_log_impl(&dword_182FBE000, v120, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting next child endpoint in %llums", buf, 0x52u);

          }
        }

        v119 = v229;
        v116 = v228;
        goto LABEL_161;
      }
      v66 = nw_endpoint_handler_copy_transform(v64);
      v67 = *((_QWORD *)v66 + 1);
      if (v67)
      {
        v68 = *(_QWORD *)(v67 + 24) - *(_QWORD *)(v67 + 16);
        if (v68)
        {
          if (v63 < v68 >> 3)
          {
            nw_array_get_object_at_index(v67, v63);
            v69 = objc_claimAutoreleasedReturnValue();
            goto LABEL_118;
          }
          if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v64) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v188 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v188, OS_LOG_TYPE_DEBUG))
            {
              v220 = nw_endpoint_handler_get_id_string(v64);
              v214 = nw_endpoint_handler_dry_run_string(v64);
              v226 = nw_endpoint_handler_copy_endpoint(v64);
              v209 = nw_endpoint_get_logging_description(v226);
              v189 = nw_endpoint_handler_state_string(v64);
              v190 = nw_endpoint_handler_mode_string(v64);
              v191 = nw_endpoint_handler_copy_current_path(v64);
              *(_DWORD *)buf = 136448002;
              v239 = "nw_endpoint_transform_get_child_at_index";
              v240 = 2082;
              id_str = (char *)v220;
              v242 = 2082;
              v243 = v214;
              v244 = 2082;
              v245 = v209;
              v246 = 2082;
              v247 = v189;
              v248 = 2082;
              v249 = v190;
              v250 = 2114;
              v192 = v191;
              v251 = v191;
              v252 = 1024;
              LODWORD(v253) = v63;
              _os_log_impl(&dword_182FBE000, v188, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no child at index %u", buf, 0x4Eu);

            }
          }
        }
      }
      v69 = 0;
LABEL_118:

      if (v69)
      {
        v95 = nw_endpoint_handler_copy_parameters(v230);
        v222 = v95;
        if (v95)
        {
          v96 = v95;
          v97 = nw_endpoint_handler_copy_parameters(v69);
          if (v97)
          {
            if (nw_parameters_get_upper_transport_protocol(v96) != 253)
            {
LABEL_151:

LABEL_152:
LABEL_153:

              goto LABEL_154;
            }
            nw_parameters_get_upper_transport_protocol_options(v96);
            v98 = objc_claimAutoreleasedReturnValue();
            v99 = v98;
            if (v98)
            {
              if (nw_protocol_options_is_quic(v98))
              {
                if (nw_protocol_options_is_quic_stream(v99))
                {
                  is_speculative_attempt = nw_quic_get_is_speculative_attempt(v99);
                }
                else
                {
                  if (!nw_protocol_options_is_quic_connection(v99))
                    goto LABEL_142;
                  is_speculative_attempt = nw_quic_connection_get_is_speculative_attempt(v99);
                }
                if (is_speculative_attempt)
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v64) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v105 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
                    {
                      v106 = nw_endpoint_handler_get_id_string(v64);
                      v216 = nw_endpoint_handler_dry_run_string(v64);
                      v107 = nw_endpoint_handler_copy_endpoint(v64);
                      v211 = nw_endpoint_get_logging_description(v107);
                      v207 = nw_endpoint_handler_state_string(v64);
                      v205 = nw_endpoint_handler_mode_string(v64);
                      v108 = nw_endpoint_handler_copy_current_path(v64);
                      v109 = nw_endpoint_handler_get_id_string(v230);
                      *(_DWORD *)buf = 136448002;
                      v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                      v240 = 2082;
                      id_str = (char *)v106;
                      v242 = 2082;
                      v243 = v216;
                      v244 = 2082;
                      v245 = v211;
                      v246 = 2082;
                      v247 = v207;
                      v248 = 2082;
                      v249 = v205;
                      v250 = 2114;
                      v251 = v108;
                      v252 = 2080;
                      v253 = (unint64_t)v109;
                      _os_log_impl(&dword_182FBE000, v105, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] quic [C%s] is speculative attempt, using shorter timeout percentage", buf, 0x52u);

                    }
                  }
                  *(_BYTE *)(v62 + 97) = 1;
                  v60 = 50;
LABEL_150:

                  goto LABEL_151;
                }
LABEL_142:
                if (nw_parameters_get_upper_transport_protocol(v97) != 253)
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v64) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v110 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
                    {
                      v217 = nw_endpoint_handler_get_id_string(v64);
                      v212 = nw_endpoint_handler_dry_run_string(v64);
                      v111 = nw_endpoint_handler_copy_endpoint(v64);
                      v208 = nw_endpoint_get_logging_description(v111);
                      v206 = nw_endpoint_handler_state_string(v64);
                      v204 = nw_endpoint_handler_mode_string(v64);
                      v112 = nw_endpoint_handler_copy_current_path(v64);
                      v113 = nw_endpoint_handler_get_id_string(v230);
                      v114 = nw_endpoint_handler_get_id_string(v69);
                      *(_DWORD *)buf = 136448258;
                      v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                      v240 = 2082;
                      id_str = (char *)v217;
                      v242 = 2082;
                      v243 = v212;
                      v244 = 2082;
                      v245 = v208;
                      v246 = 2082;
                      v247 = v206;
                      v248 = 2082;
                      v249 = v204;
                      v250 = 2114;
                      v251 = v112;
                      v252 = 2080;
                      v253 = (unint64_t)v113;
                      v254 = 2080;
                      v255 = v114;
                      _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] quic [C%s] is not speculative, using shorter timeout percentage for non-quic next child [C%s]", buf, 0x5Cu);

                    }
                  }
                  v60 = 100;
                }
                goto LABEL_150;
              }
              v219 = v97;
              __nwlog_obj();
              v186 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
              v183 = (char *)_os_log_send_and_compose_impl();

              v237 = OS_LOG_TYPE_ERROR;
              v236 = 0;
              if (__nwlog_fault(v183, &v237, &v236))
              {
                if (v237 == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v184 = objc_claimAutoreleasedReturnValue();
                  v187 = v237;
                  if (os_log_type_enabled(v184, v237))
                  {
                    *(_DWORD *)buf = 136446210;
                    v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                    _os_log_impl(&dword_182FBE000, v184, v187, "%{public}s called with null nw_protocol_options_is_quic(current_quic_options)", buf, 0xCu);
                  }
LABEL_277:

                  goto LABEL_284;
                }
                if (!v236)
                {
                  __nwlog_obj();
                  v184 = objc_claimAutoreleasedReturnValue();
                  v203 = v237;
                  if (os_log_type_enabled(v184, v237))
                  {
                    *(_DWORD *)buf = 136446210;
                    v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                    _os_log_impl(&dword_182FBE000, v184, v203, "%{public}s called with null nw_protocol_options_is_quic(current_quic_options), backtrace limit exceeded", buf, 0xCu);
                  }
                  goto LABEL_277;
                }
                v197 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v194 = objc_claimAutoreleasedReturnValue();
                v198 = v237;
                v199 = os_log_type_enabled(v194, v237);
                if (v197)
                {
                  if (v199)
                  {
                    *(_DWORD *)buf = 136446466;
                    v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                    v240 = 2082;
                    id_str = v197;
                    _os_log_impl(&dword_182FBE000, v194, v198, "%{public}s called with null nw_protocol_options_is_quic(current_quic_options), dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v197);
                  if (!v183)
                    goto LABEL_286;
                  goto LABEL_285;
                }
                if (v199)
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                  _os_log_impl(&dword_182FBE000, v194, v198, "%{public}s called with null nw_protocol_options_is_quic(current_quic_options), no backtrace", buf, 0xCu);
                }
                goto LABEL_283;
              }
            }
            else
            {
              v219 = v97;
              __nwlog_obj();
              v182 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
              v183 = (char *)_os_log_send_and_compose_impl();

              v237 = OS_LOG_TYPE_ERROR;
              v236 = 0;
              if (!__nwlog_fault(v183, &v237, &v236))
                goto LABEL_284;
              if (v237 == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v184 = objc_claimAutoreleasedReturnValue();
                v185 = v237;
                if (os_log_type_enabled(v184, v237))
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                  _os_log_impl(&dword_182FBE000, v184, v185, "%{public}s called with null current_quic_options", buf, 0xCu);
                }
                goto LABEL_277;
              }
              if (!v236)
              {
                __nwlog_obj();
                v184 = objc_claimAutoreleasedReturnValue();
                v202 = v237;
                if (os_log_type_enabled(v184, v237))
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                  _os_log_impl(&dword_182FBE000, v184, v202, "%{public}s called with null current_quic_options, backtrace limit exceeded", buf, 0xCu);
                }
                goto LABEL_277;
              }
              v193 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v194 = objc_claimAutoreleasedReturnValue();
              v195 = v237;
              v196 = os_log_type_enabled(v194, v237);
              if (!v193)
              {
                if (v196)
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                  _os_log_impl(&dword_182FBE000, v194, v195, "%{public}s called with null current_quic_options, no backtrace", buf, 0xCu);
                }
LABEL_283:

                goto LABEL_284;
              }
              if (v196)
              {
                *(_DWORD *)buf = 136446466;
                v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                v240 = 2082;
                id_str = v193;
                _os_log_impl(&dword_182FBE000, v194, v195, "%{public}s called with null current_quic_options, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v193);
            }
LABEL_284:
            if (!v183)
            {
LABEL_286:

LABEL_287:
              v97 = v219;
              goto LABEL_151;
            }
LABEL_285:
            free(v183);
            goto LABEL_286;
          }
          v219 = 0;
          __nwlog_obj();
          v170 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
          v171 = (char *)_os_log_send_and_compose_impl();

          v237 = OS_LOG_TYPE_ERROR;
          v236 = 0;
          if (__nwlog_fault(v171, &v237, &v236))
          {
            if (v237 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v172 = objc_claimAutoreleasedReturnValue();
              v173 = v237;
              if (os_log_type_enabled(v172, v237))
              {
                *(_DWORD *)buf = 136446210;
                v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                _os_log_impl(&dword_182FBE000, v172, v173, "%{public}s called with null next_parameters", buf, 0xCu);
              }
            }
            else
            {
              if (v236)
              {
                v178 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v179 = objc_claimAutoreleasedReturnValue();
                v180 = v237;
                v181 = os_log_type_enabled(v179, v237);
                if (v178)
                {
                  if (v181)
                  {
                    *(_DWORD *)buf = 136446466;
                    v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                    v240 = 2082;
                    id_str = v178;
                    _os_log_impl(&dword_182FBE000, v179, v180, "%{public}s called with null next_parameters, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v178);
                }
                else
                {
                  if (v181)
                  {
                    *(_DWORD *)buf = 136446210;
                    v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                    _os_log_impl(&dword_182FBE000, v179, v180, "%{public}s called with null next_parameters, no backtrace", buf, 0xCu);
                  }

                }
                goto LABEL_270;
              }
              __nwlog_obj();
              v172 = objc_claimAutoreleasedReturnValue();
              v201 = v237;
              if (os_log_type_enabled(v172, v237))
              {
                *(_DWORD *)buf = 136446210;
                v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                _os_log_impl(&dword_182FBE000, v172, v201, "%{public}s called with null next_parameters, backtrace limit exceeded", buf, 0xCu);
              }
            }

          }
LABEL_270:
          if (v171)
            free(v171);
          goto LABEL_287;
        }
        __nwlog_obj();
        v166 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
        v167 = (char *)_os_log_send_and_compose_impl();

        v237 = OS_LOG_TYPE_ERROR;
        v236 = 0;
        if (__nwlog_fault(v167, &v237, &v236))
        {
          if (v237 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v168 = objc_claimAutoreleasedReturnValue();
            v169 = v237;
            if (os_log_type_enabled(v168, v237))
            {
              *(_DWORD *)buf = 136446210;
              v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
              _os_log_impl(&dword_182FBE000, v168, v169, "%{public}s called with null current_parameters", buf, 0xCu);
            }
          }
          else
          {
            if (v236)
            {
              v174 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v175 = objc_claimAutoreleasedReturnValue();
              v176 = v237;
              v177 = os_log_type_enabled(v175, v237);
              if (v174)
              {
                if (v177)
                {
                  *(_DWORD *)buf = 136446466;
                  v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                  v240 = 2082;
                  id_str = v174;
                  _os_log_impl(&dword_182FBE000, v175, v176, "%{public}s called with null current_parameters, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v174);
              }
              else
              {
                if (v177)
                {
                  *(_DWORD *)buf = 136446210;
                  v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
                  _os_log_impl(&dword_182FBE000, v175, v176, "%{public}s called with null current_parameters, no backtrace", buf, 0xCu);
                }

              }
              goto LABEL_265;
            }
            __nwlog_obj();
            v168 = objc_claimAutoreleasedReturnValue();
            v200 = v237;
            if (os_log_type_enabled(v168, v237))
            {
              *(_DWORD *)buf = 136446210;
              v239 = "nw_endpoint_transform_get_next_child_scale_percentage";
              _os_log_impl(&dword_182FBE000, v168, v200, "%{public}s called with null current_parameters, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
LABEL_265:
        if (v167)
          free(v167);
        goto LABEL_152;
      }
      goto LABEL_126;
    }
LABEL_36:
    v25 = v9;
    v26 = (*((_BYTE *)v25 + 268) & 0x20) == 0;

    if (!v26)
    {

      goto LABEL_88;
    }
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v27 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v221 = v27;
      v28 = v25;

      v29 = v28;
      v30 = (*((_BYTE *)v25 + 268) & 1) == 0;

      if (v30)
        v31 = "";
      else
        v31 = "dry-run ";
      v32 = nw_endpoint_handler_copy_endpoint(v29);
      v33 = nw_endpoint_get_logging_description(v32);
      v34 = v29;
      v35 = v34;
      v36 = v34[30];
      if (v36 > 5)
        v37 = "unknown-state";
      else
        v37 = off_1E149FC48[v36];

      v53 = v35;
      v54 = v53;
      v55 = v3->mode;
      v56 = "path";
      switch(v55)
      {
        case 0:
          break;
        case 1:
          v56 = "resolver";
          break;
        case 2:
          v56 = nw_endpoint_flow_mode_string(v53[31]);
          break;
        case 3:
          v56 = "proxy";
          break;
        case 4:
          v56 = "fallback";
          break;
        case 5:
          v56 = "transform";
          break;
        default:
          v56 = "unknown-mode";
          break;
      }

      v79 = v54;
      os_unfair_lock_lock((os_unfair_lock_t)v79 + 28);
      v80 = v79[8];
      os_unfair_lock_unlock((os_unfair_lock_t)v79 + 28);

      *(_DWORD *)buf = 136448002;
      v239 = "nw_endpoint_transform_start_next_child";
      v240 = 2082;
      id_str = v28->id_str;
      v242 = 2082;
      v243 = v31;
      v244 = 2082;
      v245 = v33;
      v246 = 2082;
      v247 = v37;
      v248 = 2082;
      v249 = v56;
      v250 = 2114;
      v251 = v80;
      v252 = 1024;
      LODWORD(v253) = v227;
      _os_log_impl(&dword_182FBE000, v221, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] no child at index %u", buf, 0x4Eu);

      v230 = 0;
      v27 = v221;
    }
    else
    {
      v230 = 0;
    }
    goto LABEL_86;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = (id)gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5)
      v15 = "unknown-mode";
    else
      v15 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v239 = "nw_endpoint_transform_start_next_child";
    v240 = 2082;
    id_str = (char *)v15;
    v242 = 2082;
    v243 = "transform";
    _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_90:
}

void sub_1830F8C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,uint64_t a22,uint64_t a23,void *a24,void *a25)
{
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_transform_receive_report(void *a1, uint64_t a2, unsigned int a3, _WORD *a4, void *a5, void *a6)
{
  id v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int *v13;
  char v14;
  NSObject *v15;
  unsigned int *v16;
  char *v17;
  char v18;
  const char *v19;
  const char *logging_description;
  unsigned int *v21;
  unsigned int *v22;
  uint64_t v23;
  const char *v24;
  NSObject *v25;
  const char *v26;
  uint64_t v27;
  void **v28;
  const char *v29;
  void **v30;
  id v31;
  id v32;
  const char *v33;
  nw_endpoint_t v34;
  const char *v35;
  const char *v36;
  const char *v37;
  char *v38;
  const char *v39;
  const char *v40;
  id v41;
  void *v42;
  NWConcrete_nw_endpoint_mode_handler *v43;
  NWConcrete_nw_endpoint_mode_handler *v44;
  id v45;
  id *v46;
  uint64_t v47;
  id *v48;
  id *v49;
  BOOL v50;
  BOOL v51;
  unsigned int *v52;
  unsigned int *v53;
  uint64_t v54;
  uint64_t v55;
  id v56;
  id v57;
  id *v58;
  id v59;
  unsigned int *v60;
  id v61;
  id v62;
  nw_endpoint_t v63;
  id v64;
  NWConcrete_nw_endpoint_mode_handler *v65;
  NWConcrete_nw_endpoint_handler *v66;
  uint64_t v67;
  void **v68;
  void **v69;
  _BOOL8 v70;
  void *v71;
  id v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int8 *v75;
  uint64_t v77;
  uint64_t v78;
  int minimize_logging;
  char logging_disabled;
  NSObject *v81;
  const char *v82;
  const char *v83;
  nw_endpoint_t v84;
  const char *v85;
  const char *v86;
  const char *v87;
  id v88;
  NSObject *v89;
  const char *v90;
  const char *v91;
  nw_endpoint_t v92;
  const char *v93;
  const char *v94;
  const char *v95;
  id v96;
  void *v97;
  char *v98;
  NSObject *v99;
  os_log_type_t v100;
  char *backtrace_string;
  os_log_type_t v102;
  _BOOL4 v103;
  os_log_type_t v104;
  const char *v105;
  const char *v106;
  nw_endpoint_t v107;
  const char *v108;
  const char *v109;
  const char *v110;
  id v111;
  const char *v112;
  const char *v113;
  nw_endpoint_t v114;
  const char *v115;
  const char *v116;
  const char *v117;
  id v118;
  const char *id_string;
  const char *v120;
  const char *v121;
  nw_endpoint_t v122;
  NSObject *log;
  os_log_t loga;
  id obj;
  unsigned int v126;
  unsigned int *v127;
  id v129;
  id v130;
  void *v131;
  _QWORD v132[4];
  NWConcrete_nw_endpoint_mode_handler *v133;
  id v134;
  unsigned int *v135;
  _QWORD v136[4];
  NWConcrete_nw_endpoint_mode_handler *v137;
  NWConcrete_nw_endpoint_handler *v138;
  _BYTE *v139;
  char v140;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v143;
  __int16 v144;
  const char *v145;
  __int16 v146;
  const char *v147;
  __int16 v148;
  const char *v149;
  __int16 v150;
  id v151;
  __int16 v152;
  const char *v153;
  __int16 v154;
  const char *v155;
  __int16 v156;
  const char *v157;
  __int16 v158;
  const char *v159;
  __int16 v160;
  const char *v161;
  __int16 v162;
  id v163;
  uint64_t v164;

  v164 = *MEMORY[0x1E0C80C00];
  v130 = a1;
  v129 = a5;
  v10 = a6;
  v131 = v10;
  if (!v10)
  {
    __nwlog_obj();
    v97 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
    v98 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v140 = 0;
    if (__nwlog_fault(v98, &type, &v140))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v99 = objc_claimAutoreleasedReturnValue();
        v100 = type;
        if (os_log_type_enabled(v99, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
          _os_log_impl(&dword_182FBE000, v99, v100, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v140)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v99 = objc_claimAutoreleasedReturnValue();
        v102 = type;
        v103 = os_log_type_enabled(v99, type);
        if (backtrace_string)
        {
          if (v103)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v99, v102, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_124;
        }
        if (v103)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
          _os_log_impl(&dword_182FBE000, v99, v102, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v99 = objc_claimAutoreleasedReturnValue();
        v104 = type;
        if (os_log_type_enabled(v99, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
          _os_log_impl(&dword_182FBE000, v99, v104, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_124:
    if (v98)
      free(v98);
    goto LABEL_18;
  }
  v11 = (unsigned int *)v10;
  v12 = v11[29];

  if ((_DWORD)v12 == 5)
  {
    obj = a1;
    v126 = a3;
    v13 = v11;
    v14 = *((_BYTE *)v13 + 268);

    v127 = v13;
    if ((v14 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v15 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v16 = v13;

        v17 = v16;
        v18 = *((_BYTE *)v13 + 268);

        if ((v18 & 1) != 0)
          v19 = "dry-run ";
        else
          v19 = "";
        log = v15;
        v122 = nw_endpoint_handler_copy_endpoint(v17);
        logging_description = nw_endpoint_get_logging_description(v122);
        v21 = v17;
        v22 = v21;
        v23 = v21[30];
        if (v23 > 5)
          v24 = "unknown-state";
        else
          v24 = off_1E149FC48[v23];
        v121 = v24;

        v28 = v22;
        v29 = "path";
        switch(v11[29])
        {
          case 0u:
            break;
          case 1u:
            v29 = "resolver";
            break;
          case 2u:
            v29 = nw_endpoint_flow_mode_string(v28[31]);
            break;
          case 3u:
            v29 = "proxy";
            break;
          case 4u:
            v29 = "fallback";
            break;
          case 5u:
            v29 = "transform";
            break;
          default:
            v29 = "unknown-mode";
            break;
        }
        v120 = v29;

        v30 = v28;
        os_unfair_lock_lock((os_unfair_lock_t)v30 + 28);
        v31 = v30[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v30 + 28);

        v32 = v31;
        id_string = nw_endpoint_handler_get_id_string(v130);
        v33 = nw_endpoint_handler_dry_run_string(v130);
        v34 = nw_endpoint_handler_copy_endpoint(v130);
        v35 = logging_description;
        v36 = v19;
        v37 = nw_endpoint_get_logging_description(v34);
        v38 = (char *)(v16 + 42);
        v39 = nw_endpoint_handler_state_string(v130);
        v40 = nw_endpoint_handler_mode_string(v130);
        v41 = nw_endpoint_handler_copy_current_path(v130);
        *(_DWORD *)buf = 136449282;
        *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v38;
        *(_WORD *)&buf[22] = 2082;
        v143 = v36;
        v144 = 2082;
        v145 = v35;
        v146 = 2082;
        v147 = v121;
        v148 = 2082;
        v149 = v120;
        v150 = 2114;
        v151 = v32;
        v152 = 2082;
        v153 = id_string;
        v154 = 2082;
        v155 = v33;
        v156 = 2082;
        v157 = v37;
        v158 = 2082;
        v159 = v39;
        v160 = 2082;
        v161 = v40;
        v162 = 2114;
        v163 = v41;
        v15 = log;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received child report: [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

      }
      v13 = v127;
    }
    v42 = v130;
    nw_endpoint_handler_report(v13, v130, a4, v129);
    v43 = nw_endpoint_handler_copy_transform((NWConcrete_nw_endpoint_handler *)v13);
    v44 = v43;
    v46 = (id *)((char *)v43 + 48);
    v45 = (id)*((_QWORD *)v43 + 6);
    if (v45 == v130)
    {
      v60 = v13;
      v60[30] = v126;

      nw_endpoint_handler_report(v60, 0, a4, 0);
    }
    else
    {
      v47 = *((_QWORD *)v43 + 1);
      if (!v47 || !v130)
        goto LABEL_85;
      v49 = *(id **)(v47 + 16);
      v48 = *(id **)(v47 + 24);
      if (v49 != v48)
      {
        while (*v49 != v130)
        {
          if (++v49 == v48)
          {
            v49 = v48;
            break;
          }
        }
      }
      if (v49 == v48)
        goto LABEL_85;
      if (*((_QWORD *)v43 + 4))
        v50 = a4 == 0;
      else
        v50 = 1;
      v51 = !v50 && v45 == 0;
      if (v51 && *a4 == 2 && a4[1] == 8)
      {
        v62 = *((id *)v43 + 7);
        v63 = nw_endpoint_handler_copy_endpoint(v130);
        v64 = nw_endpoint_handler_copy_endpoint_for_alternatives(v130);
        if (v64 && nw_endpoint_is_equal(v62, v63, 8) && (nw_endpoint_is_equal(v62, v64, 8) & 1) == 0)
        {
          loga = v63;
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = buf;
          *(_QWORD *)&buf[16] = 0x2020000000;
          LOBYTE(v143) = 0;
          v136[0] = MEMORY[0x1E0C809B0];
          v136[1] = 3221225472;
          v136[2] = ___ZL36nw_endpoint_transform_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke;
          v136[3] = &unk_1E14AA9C8;
          v65 = v44;
          v137 = v65;
          v66 = v13;
          v138 = v66;
          v139 = buf;
          nw_endpoint_enumerate_alternatives(v64, v136);
          if (*(_BYTE *)(*(_QWORD *)&buf[8] + 24))
          {
            v66->event = (nw_endpoint_handler_event_s)196615;
            nw_endpoint_handler_report(v66, 0, &v66->event.domain, 0);
            -[NWConcrete_nw_endpoint_mode_handler cancelWithHandler:forced:](v65, "cancelWithHandler:forced:", v66, 1);
            objc_storeStrong((id *)v44 + 7, v64);
            nw_endpoint_transform_add_children(v66);
            nw_endpoint_transform_start_next_child(v66);
          }

          _Block_object_dispose(buf, 8);
          v63 = loga;
        }

        v42 = v130;
        v13 = v127;
      }
      if (v126 == 3)
      {
        objc_storeStrong(v46, obj);
        v52 = v127;
        v52[30] = 3;
LABEL_46:

        v53 = v127;
        nw_endpoint_handler_report(v127, 0, a4, 0);
        v55 = *((_QWORD *)v44 + 8);
        if (v55)
        {
          nw_queue_cancel_source(v55, v54);
          *((_QWORD *)v44 + 8) = 0;
        }
        v56 = nw_endpoint_handler_copy_parameters(v130);
        v57 = v56;
        if (v56)
        {
          if (nw_parameters_get_upper_transport_protocol(v56) == 253)
          {
            *((_DWORD *)v44 + 21) = 253;
            v58 = v127;
            v59 = v58[7];

            if (v59)
              nw_quic_report_race_result_on_queue(v59, 1, 0);

            v53 = v127;
          }
          else
          {
            *((_DWORD *)v44 + 21) = nw_parameters_get_ip_protocol(v57);
          }
        }
        v75 = (unsigned __int8 *)*((_QWORD *)v44 + 1);
        v132[0] = MEMORY[0x1E0C809B0];
        v132[1] = 3221225472;
        v132[2] = ___ZL36nw_endpoint_transform_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_100;
        v132[3] = &unk_1E14AA9F0;
        v133 = v44;
        v134 = v130;
        v135 = v53;
        nw_array_apply(v75, (uint64_t)v132);

        goto LABEL_84;
      }
      if (v126 == 2 && a4)
      {
        if (*a4 != 3 || a4[1] != 5)
          goto LABEL_85;
        v61 = v42;
        v52 = (unsigned int *)*v46;
        *v46 = v61;
        goto LABEL_46;
      }
      if (v126 == 4)
      {
        v67 = *((_QWORD *)v44 + 2);
        if (v67)
        {
          v69 = *(void ***)(v67 + 16);
          v68 = *(void ***)(v67 + 24);
          if (v69 != v68)
          {
            while (*v69 != v42)
            {
              if (++v69 == v68)
              {
                v69 = *(void ***)(v67 + 24);
                break;
              }
            }
          }
          if (v69 != v68)
          {
LABEL_78:
            v57 = nw_endpoint_handler_copy_parameters(v42);
            if (nw_parameters_get_upper_transport_protocol(v57) == 253)
            {
              v72 = nw_endpoint_handler_copy_association(v13, 0);
              nw_quic_report_race_result_on_queue(v72, 0, 0);

              v13 = v127;
            }
            v73 = *((_QWORD *)v44 + 2);
            if (v73)
              v74 = (uint64_t)(*(_QWORD *)(v73 + 24) - *(_QWORD *)(v73 + 16)) >> 3;
            else
              v74 = 0;
            v77 = *((_QWORD *)v44 + 1);
            if (v77)
              v78 = (uint64_t)(*(_QWORD *)(v77 + 24) - *(_QWORD *)(v77 + 16)) >> 3;
            else
              v78 = 0;
            minimize_logging = nw_endpoint_handler_get_minimize_logging(v13);
            logging_disabled = nw_endpoint_handler_get_logging_disabled(v13);
            if (v74 == v78)
            {
              if (minimize_logging)
              {
                if ((logging_disabled & 1) != 0)
                  goto LABEL_99;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v81 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
                {
                  v105 = nw_endpoint_handler_get_id_string(v127);
                  v106 = nw_endpoint_handler_dry_run_string(v127);
                  v107 = nw_endpoint_handler_copy_endpoint(v127);
                  v108 = nw_endpoint_get_logging_description(v107);
                  v109 = nw_endpoint_handler_state_string(v127);
                  v110 = nw_endpoint_handler_mode_string(v127);
                  v111 = nw_endpoint_handler_copy_current_path(v127);
                  *(_DWORD *)buf = 136447746;
                  *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v105;
                  *(_WORD *)&buf[22] = 2082;
                  v143 = v106;
                  v144 = 2082;
                  v145 = v108;
                  v146 = 2082;
                  v147 = v109;
                  v148 = 2082;
                  v149 = v110;
                  v150 = 2114;
                  v151 = v111;
                  _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed", buf, 0x48u);

                }
              }
              else
              {
                if ((logging_disabled & 1) != 0)
                {
LABEL_99:
                  nw_endpoint_handler_handle_failure(v13);
                  v13[20] = 131079;
                  nw_endpoint_handler_report(v13, 0, (_WORD *)v13 + 40, 0);
LABEL_84:

                  goto LABEL_85;
                }
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v81 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
                {
                  v82 = nw_endpoint_handler_get_id_string(v13);
                  v83 = nw_endpoint_handler_dry_run_string(v13);
                  v84 = nw_endpoint_handler_copy_endpoint(v13);
                  v85 = nw_endpoint_get_logging_description(v84);
                  v86 = nw_endpoint_handler_state_string(v13);
                  v87 = nw_endpoint_handler_mode_string(v13);
                  v88 = nw_endpoint_handler_copy_current_path(v13);
                  *(_DWORD *)buf = 136447746;
                  *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v82;
                  *(_WORD *)&buf[22] = 2082;
                  v143 = v83;
                  v144 = 2082;
                  v145 = v85;
                  v146 = 2082;
                  v147 = v86;
                  v148 = 2082;
                  v149 = v87;
                  v150 = 2114;
                  v151 = v88;
                  _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed", buf, 0x48u);

                }
              }

              v13 = v127;
              goto LABEL_99;
            }
            if (minimize_logging)
            {
              if ((logging_disabled & 1) != 0)
                goto LABEL_107;
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v89 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
              {
                v112 = nw_endpoint_handler_get_id_string(v127);
                v113 = nw_endpoint_handler_dry_run_string(v127);
                v114 = nw_endpoint_handler_copy_endpoint(v127);
                v115 = nw_endpoint_get_logging_description(v114);
                v116 = nw_endpoint_handler_state_string(v127);
                v117 = nw_endpoint_handler_mode_string(v127);
                v118 = nw_endpoint_handler_copy_current_path(v127);
                *(_DWORD *)buf = 136447746;
                *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v112;
                *(_WORD *)&buf[22] = 2082;
                v143 = v113;
                v144 = 2082;
                v145 = v115;
                v146 = 2082;
                v147 = v116;
                v148 = 2082;
                v149 = v117;
                v150 = 2114;
                v151 = v118;
                _os_log_impl(&dword_182FBE000, v89, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started children failed, start next child.", buf, 0x48u);

              }
            }
            else
            {
              if ((logging_disabled & 1) != 0)
              {
LABEL_107:
                nw_endpoint_transform_start_next_child((NWConcrete_nw_endpoint_handler *)v13);
                goto LABEL_84;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v89 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v89, OS_LOG_TYPE_INFO))
              {
                v90 = nw_endpoint_handler_get_id_string(v13);
                v91 = nw_endpoint_handler_dry_run_string(v13);
                v92 = nw_endpoint_handler_copy_endpoint(v13);
                v93 = nw_endpoint_get_logging_description(v92);
                v94 = nw_endpoint_handler_state_string(v13);
                v95 = nw_endpoint_handler_mode_string(v13);
                v96 = nw_endpoint_handler_copy_current_path(v13);
                *(_DWORD *)buf = 136447746;
                *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v90;
                *(_WORD *)&buf[22] = 2082;
                v143 = v91;
                v144 = 2082;
                v145 = v93;
                v146 = 2082;
                v147 = v94;
                v148 = 2082;
                v149 = v95;
                v150 = 2114;
                v151 = v96;
                _os_log_impl(&dword_182FBE000, v89, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started children failed, start next child.", buf, 0x48u);

              }
            }

            v13 = v127;
            goto LABEL_107;
          }
        }
        else
        {
          v70 = nw_array_create();
          v71 = (void *)*((_QWORD *)v44 + 2);
          *((_QWORD *)v44 + 2) = v70;

          v67 = *((_QWORD *)v44 + 2);
          v42 = v130;
          v13 = v127;
        }
        nw_array_append(v67, v42);
        goto LABEL_78;
      }
    }
LABEL_85:

    v27 = 1;
    goto LABEL_86;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = (id)gLogObj;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    if (v12 > 5)
      v26 = "unknown-mode";
    else
      v26 = off_1E149FC18[v12];
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_endpoint_transform_receive_report";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v26;
    *(_WORD *)&buf[22] = 2082;
    v143 = "transform";
    _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_18:
  v27 = 0;
LABEL_86:

  return v27;
}

void sub_1830F9F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_mode_handler *nw_endpoint_handler_copy_transform(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  NWConcrete_nw_endpoint_mode_handler *v3;
  NSObject *v4;
  const char *v5;
  nw_endpoint_t v6;
  const char *logging_description;
  uint64_t state;
  const char *v9;
  const char *v10;
  NWConcrete_nw_endpoint_handler *v11;
  os_unfair_lock_s *v12;
  const char *v13;
  os_unfair_lock_s *v14;
  id *v15;
  id v16;
  id v17;
  id *v18;
  id *v19;
  const char *v20;
  const char *v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *id_str;
  __int16 v27;
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  id v36;
  __int16 v37;
  const char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1->mode == 5)
  {
    v3 = v1->mode_handler;
  }
  else
  {
    if ((*((_BYTE *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)v2 + 268) & 1) != 0)
          v5 = "dry-run ";
        else
          v5 = "";
        v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        state = v2->state;
        v9 = logging_description;
        if (state > 5)
          v10 = "unknown-state";
        else
          v10 = off_1E149FC48[state];
        v22 = v10;
        v11 = v2;
        v12 = (os_unfair_lock_s *)v11;
        v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            v13 = "resolver";
            break;
          case 2:
            v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            v13 = "proxy";
            break;
          case 4:
            v13 = "fallback";
            break;
          case 5:
            v13 = "transform";
            break;
          default:
            v13 = "unknown-mode";
            break;
        }

        v14 = v12 + 28;
        v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        v16 = v15[8];
        os_unfair_lock_unlock(v14);

        v17 = v16;
        v18 = v15;
        v19 = v18;
        v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            v20 = "resolver";
            break;
          case 2:
            v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            v20 = "proxy";
            break;
          case 4:
            v20 = "fallback";
            break;
          case 5:
            v20 = "transform";
            break;
          default:
            v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        v24 = "nw_endpoint_handler_copy_transform";
        v25 = 2082;
        id_str = v2->id_str;
        v27 = 2082;
        v28 = v5;
        v29 = 2082;
        v30 = v9;
        v31 = 2082;
        v32 = v22;
        v33 = 2082;
        v34 = v13;
        v35 = 2114;
        v36 = v17;
        v37 = 2082;
        v38 = v20;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public}s, not transform", buf, 0x52u);

      }
    }
    v3 = 0;
  }

  return v3;
}

void sub_1830FA38C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_mode(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[29];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_get_mode";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_get_mode";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_get_mode";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_quic_connection_get_is_speculative_attempt(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_is_speculative_attempt_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_speculative_attempt";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_speculative_attempt";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_speculative_attempt";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_speculative_attempt";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_speculative_attempt";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FA944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void nw_quic_report_race_result_on_queue(void *a1, int a2, int a3)
{
  id v5;
  id v6;
  unsigned int *cached_content_for_protocol;
  uint64_t v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  id v26;
  uint64_t v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  uint64_t v31;
  char *v32;
  os_log_type_t v33;
  _BOOL4 v34;
  uint64_t v35;
  const char *v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  uint64_t v40;
  const char *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  uint64_t v45;
  os_log_type_t v46;
  uint64_t v47;
  uint64_t v48;
  os_log_type_t v49;
  uint64_t v50;
  os_log_type_t v51;
  uint64_t v52;
  os_log_type_t v53;
  uint64_t v54;
  os_log_type_t v55;
  uint64_t v56;
  int64_t int64_with_default;
  time_t v58;
  void *v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  void *v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  char *backtrace_string;
  os_log_type_t v68;
  _BOOL4 v69;
  char *v70;
  os_log_type_t v71;
  _BOOL4 v72;
  NSObject *v73;
  void *v74;
  void *v75;
  os_log_type_t v76;
  os_log_type_t v77;
  os_log_type_t v78;
  char *v79;
  os_log_type_t v80;
  _BOOL4 v81;
  os_log_type_t v82;
  char v83;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v86;
  __int16 v87;
  char *v88;
  __int16 v89;
  uint64_t v90;
  __int16 v91;
  uint64_t v92;
  __int16 v93;
  char *v94;
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (!v5)
  {
    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_quic_report_race_result_on_queue";
    v60 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (__nwlog_fault(v60, &type, &v83))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v61 = objc_claimAutoreleasedReturnValue();
        v62 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136446210;
          v86 = "nw_quic_report_race_result_on_queue";
          _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v83)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v61 = objc_claimAutoreleasedReturnValue();
        v68 = type;
        v69 = os_log_type_enabled(v61, type);
        if (backtrace_string)
        {
          if (v69)
          {
            *(_DWORD *)buf = 136446466;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v61, v68, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_119;
        }
        if (v69)
        {
          *(_DWORD *)buf = 136446210;
          v86 = "nw_quic_report_race_result_on_queue";
          _os_log_impl(&dword_182FBE000, v61, v68, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v61 = objc_claimAutoreleasedReturnValue();
        v77 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136446210;
          v86 = "nw_quic_report_race_result_on_queue";
          _os_log_impl(&dword_182FBE000, v61, v77, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_119:
    if (v60)
      free(v60);
    goto LABEL_77;
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  v6 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (!v6)
  {
    __nwlog_obj();
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_quic_report_race_result_on_queue";
    v64 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (!__nwlog_fault(v64, &type, &v83))
      goto LABEL_130;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v66 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_quic_report_race_result_on_queue";
        _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v83)
    {
      v70 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v71 = type;
      v72 = os_log_type_enabled(v65, type);
      if (v70)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446466;
          v86 = "nw_quic_report_race_result_on_queue";
          v87 = 2082;
          v88 = v70;
          _os_log_impl(&dword_182FBE000, v65, v71, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v70);
LABEL_130:
        if (!v64)
          goto LABEL_76;
LABEL_131:
        free(v64);
        goto LABEL_76;
      }
      if (v72)
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_quic_report_race_result_on_queue";
        _os_log_impl(&dword_182FBE000, v65, v71, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v78 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_quic_report_race_result_on_queue";
        _os_log_impl(&dword_182FBE000, v65, v78, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_129:

    goto LABEL_130;
  }
  cached_content_for_protocol = (unsigned int *)nw_association_get_cached_content_for_protocol(v5, v6);
  if (cached_content_for_protocol
    || (cached_content_for_protocol = (unsigned int *)malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL)) != 0)
  {
    if (a2)
    {
      v8 = cached_content_for_protocol[6] + 1;
      v9 = v8 << 31 >> 31;
      cached_content_for_protocol[6] = v8;
      if (v9 == v8 && (v9 & 0x8000000000000000) == 0)
        goto LABEL_75;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v11 = cached_content_for_protocol[6];
      *(_DWORD *)buf = 136446978;
      v86 = "nw_quic_report_race_result_on_queue";
      v87 = 2082;
      v88 = "association_cache->success_count";
      v89 = 2048;
      v90 = 1;
      v91 = 2048;
      v92 = v11;
      v12 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v83 = 0;
      if (__nwlog_fault(v12, &type, &v83))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = (id)gLogObj;
          v14 = type;
          if (os_log_type_enabled(v13, type))
          {
            v15 = cached_content_for_protocol[6];
            *(_DWORD *)buf = 136446978;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = "association_cache->success_count";
            v89 = 2048;
            v90 = 1;
            v91 = 2048;
            v92 = v15;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
          }
        }
        else if (v83)
        {
          v32 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = (id)gLogObj;
          v33 = type;
          v34 = os_log_type_enabled(v13, type);
          if (v32)
          {
            if (v34)
            {
              v35 = cached_content_for_protocol[6];
              *(_DWORD *)buf = 136447234;
              v86 = "nw_quic_report_race_result_on_queue";
              v87 = 2082;
              v88 = "association_cache->success_count";
              v89 = 2048;
              v90 = 1;
              v91 = 2048;
              v92 = v35;
              v93 = 2082;
              v94 = v32;
              _os_log_impl(&dword_182FBE000, v13, v33, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }

            free(v32);
            if (!v12)
              goto LABEL_56;
            goto LABEL_55;
          }
          if (v34)
          {
            v48 = cached_content_for_protocol[6];
            *(_DWORD *)buf = 136446978;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = "association_cache->success_count";
            v89 = 2048;
            v90 = 1;
            v91 = 2048;
            v92 = v48;
            _os_log_impl(&dword_182FBE000, v13, v33, "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace", buf, 0x2Au);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = (id)gLogObj;
          v46 = type;
          if (os_log_type_enabled(v13, type))
          {
            v47 = cached_content_for_protocol[6];
            *(_DWORD *)buf = 136446978;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = "association_cache->success_count";
            v89 = 2048;
            v90 = 1;
            v91 = 2048;
            v92 = v47;
            _os_log_impl(&dword_182FBE000, v13, v46, "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
          }
        }

      }
      if (!v12)
      {
LABEL_56:
        cached_content_for_protocol[6] = -1;
LABEL_75:
        int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_quic_failure_cache_seconds, 1800);
        v58 = time(0);
        nw_association_set_cached_content_for_protocol(v5, v6, (uint64_t)cached_content_for_protocol, v58 + int64_with_default);
LABEL_76:

LABEL_77:
        return;
      }
LABEL_55:
      free(v12);
      goto LABEL_56;
    }
    if (a3)
    {
      v16 = cached_content_for_protocol[8] + 1;
      v17 = v16 << 31 >> 31;
      cached_content_for_protocol[8] = v16;
      if (v17 == v16 && (v17 & 0x8000000000000000) == 0)
        goto LABEL_75;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (id)gLogObj;
      v19 = cached_content_for_protocol[8];
      *(_DWORD *)buf = 136446978;
      v86 = "nw_quic_report_race_result_on_queue";
      v87 = 2082;
      v88 = "association_cache->cancelled_count";
      v89 = 2048;
      v90 = 1;
      v91 = 2048;
      v92 = v19;
      v20 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v83 = 0;
      if (__nwlog_fault(v20, &type, &v83))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          v22 = type;
          if (os_log_type_enabled(v21, type))
          {
            v23 = cached_content_for_protocol[8];
            *(_DWORD *)buf = 136446978;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = "association_cache->cancelled_count";
            v89 = 2048;
            v90 = 1;
            v91 = 2048;
            v92 = v23;
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
          }
        }
        else if (v83)
        {
          v36 = __nw_create_backtrace_string();
          if (v36)
          {
            v37 = (char *)v36;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v38 = (id)gLogObj;
            v39 = type;
            if (os_log_type_enabled(v38, type))
            {
              v40 = cached_content_for_protocol[8];
              *(_DWORD *)buf = 136447234;
              v86 = "nw_quic_report_race_result_on_queue";
              v87 = 2082;
              v88 = "association_cache->cancelled_count";
              v89 = 2048;
              v90 = 1;
              v91 = 2048;
              v92 = v40;
              v93 = 2082;
              v94 = v37;
              _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }

            free(v37);
            if (!v20)
              goto LABEL_68;
            goto LABEL_67;
          }
          __nwlog_obj();
          v21 = objc_claimAutoreleasedReturnValue();
          v53 = type;
          if (os_log_type_enabled(v21, type))
          {
            v54 = cached_content_for_protocol[8];
            *(_DWORD *)buf = 136446978;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = "association_cache->cancelled_count";
            v89 = 2048;
            v90 = 1;
            v91 = 2048;
            v92 = v54;
            _os_log_impl(&dword_182FBE000, v21, v53, "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace", buf, 0x2Au);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          v49 = type;
          if (os_log_type_enabled(v21, type))
          {
            v50 = cached_content_for_protocol[8];
            *(_DWORD *)buf = 136446978;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = "association_cache->cancelled_count";
            v89 = 2048;
            v90 = 1;
            v91 = 2048;
            v92 = v50;
            _os_log_impl(&dword_182FBE000, v21, v49, "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
          }
        }

      }
      if (!v20)
      {
LABEL_68:
        cached_content_for_protocol[8] = -1;
        goto LABEL_75;
      }
LABEL_67:
      free(v20);
      goto LABEL_68;
    }
    v24 = cached_content_for_protocol[7] + 1;
    v25 = v24 << 31 >> 31;
    cached_content_for_protocol[7] = v24;
    if (v25 == v24 && (v25 & 0x8000000000000000) == 0)
      goto LABEL_75;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = (id)gLogObj;
    v27 = cached_content_for_protocol[7];
    *(_DWORD *)buf = 136446978;
    v86 = "nw_quic_report_race_result_on_queue";
    v87 = 2082;
    v88 = "association_cache->failure_count";
    v89 = 2048;
    v90 = 1;
    v91 = 2048;
    v92 = v27;
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (__nwlog_fault(v28, &type, &v83))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = (id)gLogObj;
        v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          v31 = cached_content_for_protocol[7];
          *(_DWORD *)buf = 136446978;
          v86 = "nw_quic_report_race_result_on_queue";
          v87 = 2082;
          v88 = "association_cache->failure_count";
          v89 = 2048;
          v90 = 1;
          v91 = 2048;
          v92 = v31;
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
        }
      }
      else if (v83)
      {
        v41 = __nw_create_backtrace_string();
        if (v41)
        {
          v42 = (char *)v41;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v43 = (id)gLogObj;
          v44 = type;
          if (os_log_type_enabled(v43, type))
          {
            v45 = cached_content_for_protocol[7];
            *(_DWORD *)buf = 136447234;
            v86 = "nw_quic_report_race_result_on_queue";
            v87 = 2082;
            v88 = "association_cache->failure_count";
            v89 = 2048;
            v90 = 1;
            v91 = 2048;
            v92 = v45;
            v93 = 2082;
            v94 = v42;
            _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(v42);
          if (!v28)
            goto LABEL_74;
          goto LABEL_73;
        }
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v55 = type;
        if (os_log_type_enabled(v29, type))
        {
          v56 = cached_content_for_protocol[7];
          *(_DWORD *)buf = 136446978;
          v86 = "nw_quic_report_race_result_on_queue";
          v87 = 2082;
          v88 = "association_cache->failure_count";
          v89 = 2048;
          v90 = 1;
          v91 = 2048;
          v92 = v56;
          _os_log_impl(&dword_182FBE000, v29, v55, "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace", buf, 0x2Au);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = (id)gLogObj;
        v51 = type;
        if (os_log_type_enabled(v29, type))
        {
          v52 = cached_content_for_protocol[7];
          *(_DWORD *)buf = 136446978;
          v86 = "nw_quic_report_race_result_on_queue";
          v87 = 2082;
          v88 = "association_cache->failure_count";
          v89 = 2048;
          v90 = 1;
          v91 = 2048;
          v92 = v52;
          _os_log_impl(&dword_182FBE000, v29, v51, "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded", buf, 0x2Au);
        }
      }

    }
    if (!v28)
    {
LABEL_74:
      cached_content_for_protocol[7] = -1;
      goto LABEL_75;
    }
LABEL_73:
    free(v28);
    goto LABEL_74;
  }
  __nwlog_obj();
  v73 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v86 = "strict_calloc";
  v87 = 2048;
  v88 = (char *)1;
  v89 = 2048;
  v90 = 48;
  v74 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v74))
  {
    free(v74);
    __nwlog_obj();
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v86 = "nw_quic_report_race_result_on_queue";
    v64 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v83 = 0;
    if (!__nwlog_fault(v64, &type, &v83))
      goto LABEL_130;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v76 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_quic_report_race_result_on_queue";
        _os_log_impl(&dword_182FBE000, v65, v76, "%{public}s called with null association_cache", buf, 0xCu);
      }
    }
    else if (v83)
    {
      v79 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v80 = type;
      v81 = os_log_type_enabled(v65, type);
      if (v79)
      {
        if (v81)
        {
          *(_DWORD *)buf = 136446466;
          v86 = "nw_quic_report_race_result_on_queue";
          v87 = 2082;
          v88 = v79;
          _os_log_impl(&dword_182FBE000, v65, v80, "%{public}s called with null association_cache, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v79);
        if (!v64)
          goto LABEL_76;
        goto LABEL_131;
      }
      if (v81)
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_quic_report_race_result_on_queue";
        _os_log_impl(&dword_182FBE000, v65, v80, "%{public}s called with null association_cache, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v65 = objc_claimAutoreleasedReturnValue();
      v82 = type;
      if (os_log_type_enabled(v65, type))
      {
        *(_DWORD *)buf = 136446210;
        v86 = "nw_quic_report_race_result_on_queue";
        _os_log_impl(&dword_182FBE000, v65, v82, "%{public}s called with null association_cache, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_129;
  }
  __break(1u);
}

void sub_1830FBBA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_endpoint_for_alternatives(void *a1)
{
  id v1;
  void *v2;
  NWConcrete_nw_endpoint_handler *v3;
  int mode;
  id *v5;
  id v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *v11;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  void *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (__nwlog_fault(v8, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null handler", buf, 0xCu);
        }
LABEL_20:

        goto LABEL_21;
      }
      if (!v22)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_20;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        v26 = 2082;
        v27 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_21:
    if (!v8)
    {
LABEL_23:
      v6 = 0;
      goto LABEL_24;
    }
LABEL_22:
    free(v8);
    goto LABEL_23;
  }
  v3 = (NWConcrete_nw_endpoint_handler *)v1;
  mode = v3->mode;

  if (mode != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
      }
    }
    else if (v22)
    {
      v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (v11)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
          v26 = 2082;
          v27 = v11;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v11);
        if (!v8)
          goto LABEL_23;
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_endpoint_handler_copy_endpoint_for_alternatives";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_20;
  }
  v5 = (id *)nw_endpoint_handler_copy_resolver(v3);
  v6 = v5[13];

LABEL_24:
  return v6;
}

void sub_1830FC0D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL29nw_flow_prepare_output_framesP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sjP30nw_protocol_message_properties_block_invoke(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v5;
  unint64_t v7;
  unint64_t v8;
  size_t v9;

  v5 = *(_DWORD *)(a1 + 56) - *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v5)
  {
    v7 = *(_QWORD *)(a1 + 40);
    if (a5 + a3 > v7)
    {
      v8 = v7 - a3;
      if (v7 < a3)
        v8 = 0;
      if (v5 >= (int)a5 - (int)v8)
        v9 = (a5 - v8);
      else
        v9 = v5;
      memcpy((void *)(*(_QWORD *)(a1 + 48) + a3 - v7 + v8), (const void *)(a4 + v8), v9);
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v9;
    }
  }
  return 1;
}

void nw_frame_set_compression_generation_count(uint64_t a1, int a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *v6;
  _BOOL4 v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_frame_set_compression_generation_count";
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10))
      goto LABEL_19;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_frame_set_compression_generation_count";
      v5 = "%{public}s called with null frame";
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_frame_set_compression_generation_count";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_19;
      }
      if (!v9)
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_frame_set_compression_generation_count";
      v5 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v13 = "nw_frame_set_compression_generation_count";
      v5 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_18:
    _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    goto LABEL_19;
  }
  if ((*(_WORD *)(a1 + 204) & 0x40) == 0)
  {
    *(_DWORD *)(a1 + 192) = a2;
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v13 = "__nw_frame_set_compression_generation_count";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10))
  {
LABEL_19:
    if (!v2)
      return;
    goto LABEL_20;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_set_compression_generation_count";
    v5 = "%{public}s Attempt to set generation-count on a chain-member";
    goto LABEL_18;
  }
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_set_compression_generation_count";
    v5 = "%{public}s Attempt to set generation-count on a chain-member, backtrace limit exceeded";
    goto LABEL_18;
  }
  v6 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = gLogObj;
  v4 = type;
  v7 = os_log_type_enabled((os_log_t)gLogObj, type);
  if (!v6)
  {
    if (!v7)
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v13 = "__nw_frame_set_compression_generation_count";
    v5 = "%{public}s Attempt to set generation-count on a chain-member, no backtrace";
    goto LABEL_18;
  }
  if (v7)
  {
    *(_DWORD *)buf = 136446466;
    v13 = "__nw_frame_set_compression_generation_count";
    v14 = 2082;
    v15 = v6;
    _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s Attempt to set generation-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v6);
  if (v2)
LABEL_20:
    free(v2);
}

void ____nwlog_connection_log_block_invoke()
{
  if ((gHasForked & 1) == 0)
    gconnectionLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "connection");
}

uint64_t __nw_association_is_empty_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t extra;
  uint64_t *v6;
  uint64_t v7;
  id v8;
  const char *logging_description;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  const char *backtrace_string;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  os_log_type_t v20;
  const char *v21;
  os_log_type_t v22;
  const char *v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  nw_hash_node_get_object(a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  extra = nw_hash_node_get_extra(a2);
  if (*(_QWORD *)(a1 + 48) <= *(_QWORD *)(extra + 32))
    goto LABEL_17;
  v6 = (uint64_t *)extra;
  v7 = *(_QWORD *)(extra + 40);
  if (v7)
    nw_protocol_definition_deallocate_cache_entry(v4, v7);
  nw_context_remove_cache_entry(*(void **)(a1 + 32), v6);
  if (nw_hash_table_remove_node(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 56), a2)
    || nw_path_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16)))
  {
    goto LABEL_17;
  }
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v8 = (id)gconnectionLogObj;
  logging_description = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
  *(_DWORD *)buf = 136446722;
  v27 = "nw_association_is_empty_block_invoke";
  v28 = 2082;
  v29 = logging_description;
  v30 = 2048;
  v31 = a2;
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (__nwlog_fault(v10, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        v13 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446722;
        v27 = "nw_association_is_empty_block_invoke";
        v28 = 2082;
        v29 = v13;
        v30 = 2048;
        v31 = a2;
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p", buf, 0x20u);
      }
    }
    else if (v24)
    {
      backtrace_string = __nw_create_backtrace_string();
      if (backtrace_string)
      {
        v16 = (char *)backtrace_string;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v17 = (id)gconnectionLogObj;
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          v19 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
          *(_DWORD *)buf = 136446978;
          v27 = "nw_association_is_empty_block_invoke";
          v28 = 2082;
          v29 = v19;
          v30 = 2048;
          v31 = a2;
          v32 = 2082;
          v33 = v16;
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v16);
        if (v10)
          goto LABEL_16;
        goto LABEL_17;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        v23 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446722;
        v27 = "nw_association_is_empty_block_invoke";
        v28 = 2082;
        v29 = v23;
        v30 = 2048;
        v31 = a2;
        _os_log_impl(&dword_182FBE000, v11, v22, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v11 = (id)gconnectionLogObj;
      v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        v21 = nw_endpoint_get_logging_description(*(void **)(*(_QWORD *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446722;
        v27 = "nw_association_is_empty_block_invoke";
        v28 = 2082;
        v29 = v21;
        v30 = 2048;
        v31 = a2;
        _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded", buf, 0x20u);
      }
    }

  }
  if (v10)
LABEL_16:
    free(v10);
LABEL_17:

  return 1;
}

void sub_1830FCA84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_context_remove_cache_entry(void *a1, uint64_t *a2)
{
  _QWORD *v3;
  void *v4;
  dispatch_queue_t *v5;
  dispatch_queue_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (v3)
  {
    v4 = v3;
    if (a2)
    {
      v5 = v3;
      v6 = v5;
      if (((_BYTE)v5[17] & 8) == 0)
        dispatch_assert_queue_V2(v5[1]);

      v4 = (void *)nw_context_copy_cache_context(v6);
      v7 = a2[2];
      if (v7 || a2[3])
      {
        v8 = *((_QWORD *)v4 + 3);
        v9 = *(_DWORD *)(v8 + 64);
        if (v9)
          *(_DWORD *)(v8 + 64) = v9 - 1;
        v10 = (_QWORD *)a2[3];
        if (v7)
        {
          *(_QWORD *)(v7 + 24) = v10;
          v10 = (_QWORD *)a2[3];
        }
        else
        {
          *(_QWORD *)(v8 + 24) = v10;
        }
        *v10 = v7;
        a2[2] = 0;
        a2[3] = 0;
      }
      v11 = *a2;
      v12 = (_QWORD *)a2[1];
      if (*a2)
      {
        *(_QWORD *)(v11 + 8) = v12;
        v12 = (_QWORD *)a2[1];
      }
      else
      {
        *(_QWORD *)(*((_QWORD *)v4 + 3) + 8) = v12;
      }
      *v12 = v11;
      *a2 = 0;
      a2[1] = 0;
      v13 = *((_QWORD *)v4 + 3);
      v14 = *(_DWORD *)(v13 + 68);
      if (v14)
        *(_DWORD *)(v13 + 68) = v14 - 1;
      goto LABEL_18;
    }
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_context_remove_cache_entry";
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v20, &type, &v31))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null cache_entry", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      v28 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_context_remove_cache_entry";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s called with null cache_entry, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_54;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s called with null cache_entry, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_182FBE000, v21, v30, "%{public}s called with null cache_entry, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_54:
    if (v20)
      free(v20);
    goto LABEL_18;
  }
  __nwlog_obj();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v34 = "nw_context_remove_cache_entry";
  v16 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (__nwlog_fault(v16, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v31)
    {
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v17, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_context_remove_cache_entry";
          v35 = 2082;
          v36 = v23;
          _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
        goto LABEL_48;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_182FBE000, v17, v24, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_context_remove_cache_entry";
        _os_log_impl(&dword_182FBE000, v17, v29, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_48:
  if (v16)
    free(v16);
  v4 = 0;
LABEL_18:

}

void sub_1830FD004(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_deallocate_cache_entry(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void (*v6)(id, uint64_t);
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_deallocate_cache_entry";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_definition_deallocate_cache_entry";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v8)
          goto LABEL_5;
LABEL_56:
        free(v8);
        goto LABEL_5;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v23, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  v5 = *((_QWORD *)v3 + 9);
  if (!v5)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_deallocate_cache_entry";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null definition->common_state", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v24, "%{public}s called with null definition->common_state, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null definition->common_state, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_deallocate_cache_entry";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null definition->common_state, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  v6 = *(void (**)(id, uint64_t))(v5 + 56);
  if (!v6)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_definition_deallocate_cache_entry";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null definition->common_state->deallocate_cache_entry", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v26)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v25, "%{public}s called with null definition->common_state->deallocate_cache_entry, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_definition_deallocate_cache_entry";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null definition->common_state->deallocate_cache_entry, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_definition_deallocate_cache_entry";
      v30 = 2082;
      v31 = v18;
      _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null definition->common_state->deallocate_cache_entry, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v18);
    if (!v8)
      goto LABEL_5;
    goto LABEL_56;
  }
  v6(v3, a2);
LABEL_5:

}

void sub_1830FD6DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_enable_multipath(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_enable_multipath_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_multipath";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_multipath";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_multipath";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_multipath";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_multipath";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FD9F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_idle_timeout(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_idle_timeout_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_idle_timeout";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_idle_timeout";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FDD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_datagram_variant_flow_id_enabled(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_datagram_variant_flow_id_enabled_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_variant_flow_id_enabled";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_variant_flow_id_enabled";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_variant_flow_id_enabled";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_variant_flow_id_enabled";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_datagram_variant_flow_id_enabled";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FE040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_force_version_negotiation(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_force_version_negotiation_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_force_version_negotiation";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_force_version_negotiation";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_force_version_negotiation";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_force_version_negotiation";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_force_version_negotiation";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FE36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

id nw_quic_connection_get_source_connection_id(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_source_connection_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FE6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_initial_packet_size(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_initial_packet_size_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_packet_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_packet_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_packet_size";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_packet_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_packet_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FE9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_remote_transport_parameters(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  id v13;
  uint64_t v14;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  void *v20;
  os_log_type_t v21;
  void *v22;
  os_log_type_t v23;
  void *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  void *v28;
  os_log_type_t v29;
  void *v30;
  os_log_type_t v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  _BOOL4 v36;
  os_log_type_t v37;
  _BOOL4 v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  _BOOL4 v46;
  os_log_type_t v47;
  os_log_type_t v48;
  os_log_type_t v49;
  os_log_type_t v50;
  os_log_type_t v51;
  os_log_type_t v52;
  os_log_type_t v53;
  _QWORD v54[10];
  char v55;
  os_log_type_t v56;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  if (!nw_protocol_options_is_quic_connection(v13))
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v17, &v56, &v55))
      goto LABEL_80;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v19 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (!v55)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v47 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v47, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_124;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v33 = v56;
    v34 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v33, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v18, v33, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_79:

    free(backtrace_string);
    goto LABEL_80;
  }
  if (!a2)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v17, &v56, &v55))
      goto LABEL_80;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v21 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v21, "%{public}s called with null max_stream_data_bidirectional_local", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (!v55)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v48 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v48, "%{public}s called with null max_stream_data_bidirectional_local, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_124;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v35 = v56;
    v36 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v35, "%{public}s called with null max_stream_data_bidirectional_local, no backtrace", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v18, v35, "%{public}s called with null max_stream_data_bidirectional_local, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_79;
  }
  if (!a3)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v17, &v56, &v55))
      goto LABEL_80;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v23 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v23, "%{public}s called with null max_stream_data_bidirectional_remote", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (!v55)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v49 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v49, "%{public}s called with null max_stream_data_bidirectional_remote, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_124;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v37 = v56;
    v38 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v37, "%{public}s called with null max_stream_data_bidirectional_remote, no backtrace", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v18, v37, "%{public}s called with null max_stream_data_bidirectional_remote, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_79;
  }
  if (!a4)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v17, &v56, &v55))
      goto LABEL_80;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v25 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v25, "%{public}s called with null max_data", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (!v55)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v50 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v50, "%{public}s called with null max_data, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_124;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v39 = v56;
    v40 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s called with null max_data, no backtrace", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v18, v39, "%{public}s called with null max_data, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_79;
  }
  if (!a5)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v17, &v56, &v55))
      goto LABEL_80;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v27 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s called with null max_data_unidirectional", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (!v55)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v51 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v51, "%{public}s called with null max_data_unidirectional, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_124;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v41 = v56;
    v42 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s called with null max_data_unidirectional, no backtrace", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v18, v41, "%{public}s called with null max_data_unidirectional, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_79;
  }
  if (!a6)
  {
    __nwlog_obj();
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "nw_quic_get_remote_transport_parameters";
    v17 = (char *)_os_log_send_and_compose_impl();

    v56 = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v17, &v56, &v55))
      goto LABEL_80;
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v29 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v29, "%{public}s called with null max_streams_bidirectional", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (!v55)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v52 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v52, "%{public}s called with null max_streams_bidirectional, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_124;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v43 = v56;
    v44 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v43, "%{public}s called with null max_streams_bidirectional, no backtrace", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (v44)
    {
      *(_DWORD *)buf = 136446466;
      v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v18, v43, "%{public}s called with null max_streams_bidirectional, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_79;
  }
  if (a7)
  {
    v54[0] = MEMORY[0x1E0C809B0];
    v54[1] = 3221225472;
    v54[2] = __nw_quic_get_remote_transport_parameters_block_invoke;
    v54[3] = &__block_descriptor_80_e9_B16__0_v8l;
    v54[4] = a2;
    v54[5] = a3;
    v54[6] = a4;
    v54[7] = a5;
    v54[8] = a6;
    v54[9] = a7;
    v14 = nw_protocol_options_access_handle(v13, v54);
    goto LABEL_9;
  }
  __nwlog_obj();
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v58 = "nw_quic_get_remote_transport_parameters";
  v17 = (char *)_os_log_send_and_compose_impl();

  v56 = OS_LOG_TYPE_ERROR;
  v55 = 0;
  if (__nwlog_fault(v17, &v56, &v55))
  {
    if (v56 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v31 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s called with null max_streams_unidirectional", buf, 0xCu);
      }
LABEL_124:

      goto LABEL_80;
    }
    if (!v55)
    {
      __nwlog_obj();
      v18 = objc_claimAutoreleasedReturnValue();
      v53 = v56;
      if (os_log_type_enabled(v18, v56))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v53, "%{public}s called with null max_streams_unidirectional, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_124;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v45 = v56;
    v46 = os_log_type_enabled(v18, v56);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_quic_get_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v18, v45, "%{public}s called with null max_streams_unidirectional, no backtrace", buf, 0xCu);
      }
      goto LABEL_124;
    }
    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      v58 = "nw_quic_get_remote_transport_parameters";
      v59 = 2082;
      v60 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v18, v45, "%{public}s called with null max_streams_unidirectional, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_79;
  }
LABEL_80:
  if (v17)
    free(v17);
  v14 = 0;
LABEL_9:

  return v14;
}

void sub_1830FF8C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_initial_max_stream_data_unidirectional(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_initial_max_stream_data_unidirectional_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_unidirectional";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_initial_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FFBD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_use_swift_tls(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_use_swift_tls_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_use_swift_tls";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_use_swift_tls";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_use_swift_tls";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_use_swift_tls";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_use_swift_tls";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1830FFEFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_disable_ecn_echo(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_disable_ecn_echo_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn_echo";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn_echo";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn_echo";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn_echo";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn_echo";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183100228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_get_disable_ecn(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_disable_ecn_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183100554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_execute_session_state_update_block(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _QWORD v18[4];
  id v19;
  id v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (nw_protocol_options_is_quic_connection(v5))
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = __nw_quic_connection_execute_session_state_update_block_block_invoke;
    v18[3] = &unk_1E14AA2D0;
    v19 = v6;
    v20 = v7;
    v8 = nw_protocol_options_access_handle(v5, v18);

    goto LABEL_3;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_quic_connection_execute_session_state_update_block";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v11, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_quic_connection_execute_session_state_update_block";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_quic_connection_execute_session_state_update_block";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_quic_connection_execute_session_state_update_block";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_quic_connection_execute_session_state_update_block";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v11)
    free(v11);
  v8 = 0;
LABEL_3:

  return v8;
}

void sub_183100898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_enable_l4s(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_enable_l4s_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_l4s";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_l4s";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183100BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

id nw_quic_connection_copy_sec_protocol_options(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_copy_sec_protocol_options_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_options";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_options";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_options";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_options";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_sec_protocol_options";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183100F0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_idle_timeout(void *a1, int a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  int v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_idle_timeout_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_idle_timeout";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_idle_timeout";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_idle_timeout";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_18310120C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_initial_max_streams_unidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_max_streams_unidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_initial_max_streams_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_initial_max_streams_unidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1831014E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_initial_max_streams_bidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_max_streams_bidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_initial_max_streams_bidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_initial_max_streams_bidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1831017C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_is_speculative_attempt(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_is_speculative_attempt_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_is_speculative_attempt";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_is_speculative_attempt";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_is_speculative_attempt";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_is_speculative_attempt";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_is_speculative_attempt";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_183101AA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_keepalive_count(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  __int16 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_keepalive_count_block_invoke;
    v12[3] = &__block_descriptor_34_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_keepalive_count";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_keepalive_count";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_183101D7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_streams_update_block(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _QWORD v16[4];
  id v17;
  id v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (nw_protocol_options_is_quic_connection(v5))
  {
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = __nw_quic_connection_set_max_streams_update_block_block_invoke;
    v16[3] = &unk_1E14AA370;
    v18 = v6;
    v17 = v7;
    nw_protocol_options_access_handle(v5, v16);

    goto LABEL_3;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_quic_connection_set_max_streams_update_block";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_max_streams_update_block";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_quic_connection_set_max_streams_update_block";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_max_streams_update_block";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_max_streams_update_block";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v9)
    free(v9);
LABEL_3:

}

void sub_183102098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_quic_connection(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  _BOOL8 is_equal_unsafe;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[1];

    if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_quic_connection_definition::quic_definition);

    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_options_is_quic_connection";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_quic_connection";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_options_is_quic_connection";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_quic_connection";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_quic_connection";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_1831023B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_protocol_instance_schedule_wakeup(void *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  dispatch_queue_t *v6;
  dispatch_queue_t *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  os_log_type_t v28;
  os_log_type_t v29;
  _QWORD aBlock[4];
  id v31;
  char v32;
  os_log_type_t type;
  _BYTE location[12];
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (uint64_t)v3;
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)location = 136446210;
    *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v12, &type, &v32))
      goto LABEL_59;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null instance", location, 0xCu);
      }
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)location = 136446466;
          *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null instance, dumping backtrace:%{public}s", location, 0x16u);
        }

        free(backtrace_string);
LABEL_59:
        if (!v12)
          goto LABEL_9;
LABEL_60:
        free(v12);
        goto LABEL_9;
      }
      if (v21)
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null instance, no backtrace", location, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v27, "%{public}s called with null instance, backtrace limit exceeded", location, 0xCu);
      }
    }
LABEL_58:

    goto LABEL_59;
  }
  if (!v3[33])
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)location = 136446210;
    *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v12, &type, &v32))
      goto LABEL_59;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null instance->wakeup", location, 0xCu);
      }
      goto LABEL_58;
    }
    if (!v32)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v28, "%{public}s called with null instance->wakeup, backtrace limit exceeded", location, 0xCu);
      }
      goto LABEL_58;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null instance->wakeup, no backtrace", location, 0xCu);
      }
      goto LABEL_58;
    }
    if (v24)
    {
      *(_DWORD *)location = 136446466;
      *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
      v35 = 2082;
      v36 = v22;
      _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null instance->wakeup, dumping backtrace:%{public}s", location, 0x16u);
    }
    goto LABEL_39;
  }
  v5 = (void *)v3[15];
  if (!v5)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)location = 136446210;
    *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v12, &type, &v32))
      goto LABEL_59;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null instance->context", location, 0xCu);
      }
      goto LABEL_58;
    }
    if (!v32)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v29, "%{public}s called with null instance->context, backtrace limit exceeded", location, 0xCu);
      }
      goto LABEL_58;
    }
    v22 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v13, type);
    if (!v22)
    {
      if (v26)
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
        _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null instance->context, no backtrace", location, 0xCu);
      }
      goto LABEL_58;
    }
    if (v26)
    {
      *(_DWORD *)location = 136446466;
      *(_QWORD *)&location[4] = "nw_protocol_instance_schedule_wakeup";
      v35 = 2082;
      v36 = v22;
      _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null instance->context, dumping backtrace:%{public}s", location, 0x16u);
    }
LABEL_39:

    free(v22);
    if (!v12)
      goto LABEL_9;
    goto LABEL_60;
  }
  v6 = v5;
  v7 = v6;
  if (((_BYTE)v6[17] & 8) == 0)
    dispatch_assert_queue_V2(v6[1]);

  v8 = *(void **)(v4 + 272);
  if (!v8)
  {
    objc_initWeak((id *)location, (id)v4);
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_instance_schedule_wakeup_block_invoke;
    aBlock[3] = &unk_1E14A49C0;
    objc_copyWeak(&v31, (id *)location);
    v9 = _Block_copy(aBlock);
    v10 = *(void **)(v4 + 272);
    *(_QWORD *)(v4 + 272) = v9;

    objc_destroyWeak(&v31);
    objc_destroyWeak((id *)location);
    v8 = *(void **)(v4 + 272);
  }
  *(_BYTE *)(v4 + 404) = *(_BYTE *)(v4 + 404) & 0xEF | (16 * (a2 != -1));
  nw_context_reset_timer_block(*(void **)(v4 + 120), v4, a2, v8);
LABEL_9:

}

void sub_183102B38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_context_reset_timer_block_with_time(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  id v8;
  uint64_t v9;
  void *v10;
  id v11;
  NWConcrete_nw_context *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  char v16;
  uint64_t v17;
  _BOOL8 v18;
  void *v19;
  uint64_t *v20;
  id v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t **v24;
  _QWORD *v25;
  _BOOL8 node;
  void *v27;
  _QWORD *v28;
  id v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  void *v33;
  void *v34;
  _QWORD *v35;
  uint64_t v36;
  _BOOL8 v37;
  uint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  id v43;
  char *v44;
  uint64_t v45;
  NSObject *v46;
  os_log_type_t v47;
  const char *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  NSObject *v52;
  os_log_type_t v53;
  uint64_t v54;
  os_log_type_t v55;
  os_log_type_t v56;
  uint64_t v57;
  _QWORD *v58;
  void *v59;
  void *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  NSObject *v64;
  os_log_type_t v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  NSObject *v69;
  os_log_type_t v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  os_log_type_t v74;
  char *backtrace_string;
  uint64_t v76;
  os_log_type_t v77;
  _BOOL4 v78;
  char *v79;
  uint64_t v80;
  os_log_type_t v81;
  _BOOL4 v82;
  NSObject *v83;
  void *v84;
  uint64_t v85;
  os_log_type_t v86;
  _BOOL4 v87;
  os_log_type_t v88;
  os_log_type_t v89;
  os_log_type_t v90;
  _QWORD v91[4];
  id v92;
  char v93;
  os_log_type_t type;
  os_log_type_t v95;
  uint8_t buf[4];
  const char *v97;
  __int16 v98;
  uint64_t v99;
  __int16 v100;
  uint64_t v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  v10 = v8;
  if (!v7)
  {
    __nwlog_obj(v8, v9);
    v60 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v97 = "nw_context_reset_timer_block_with_time";
    v61 = (char *)_os_log_send_and_compose_impl();

    v95 = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    v62 = __nwlog_fault(v61, &v95, &type);
    if ((_DWORD)v62)
    {
      if (v95 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj(v62, v63);
        v64 = objc_claimAutoreleasedReturnValue();
        v65 = v95;
        if (os_log_type_enabled(v64, v95))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl(&dword_182FBE000, v64, v65, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj(backtrace_string, v76);
        v64 = objc_claimAutoreleasedReturnValue();
        v77 = v95;
        v78 = os_log_type_enabled(v64, v95);
        if (backtrace_string)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            v97 = "nw_context_reset_timer_block_with_time";
            v98 = 2082;
            v99 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v64, v77, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_119;
        }
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl(&dword_182FBE000, v64, v77, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj(v62, v63);
        v64 = objc_claimAutoreleasedReturnValue();
        v88 = v95;
        if (os_log_type_enabled(v64, v95))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl(&dword_182FBE000, v64, v88, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_119:
    if (v61)
      free(v61);
    v7 = 0;
    goto LABEL_76;
  }
  if (!a2)
  {
    __nwlog_obj(v8, v9);
    v66 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v97 = "nw_context_reset_timer_block_with_time";
    v17 = _os_log_send_and_compose_impl();

    v95 = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    v67 = __nwlog_fault((const char *)v17, &v95, &type);
    if (!(_DWORD)v67)
      goto LABEL_131;
    if (v95 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v67, v68);
      v69 = objc_claimAutoreleasedReturnValue();
      v70 = v95;
      if (os_log_type_enabled(v69, v95))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s called with null handle", buf, 0xCu);
      }
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj(v67, v68);
      v69 = objc_claimAutoreleasedReturnValue();
      v89 = v95;
      if (os_log_type_enabled(v69, v95))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl(&dword_182FBE000, v69, v89, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_130;
    }
    v79 = (char *)__nw_create_backtrace_string();
    __nwlog_obj(v79, v80);
    v69 = objc_claimAutoreleasedReturnValue();
    v81 = v95;
    v82 = os_log_type_enabled(v69, v95);
    if (!v79)
    {
      if (v82)
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl(&dword_182FBE000, v69, v81, "%{public}s called with null handle, no backtrace", buf, 0xCu);
      }
      goto LABEL_130;
    }
    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      v97 = "nw_context_reset_timer_block_with_time";
      v98 = 2082;
      v99 = (uint64_t)v79;
      _os_log_impl(&dword_182FBE000, v69, v81, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_108;
  }
  v11 = v7;
  v12 = (NWConcrete_nw_context *)v11;
  if ((*((_BYTE *)v11 + 136) & 8) == 0)
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v11 + 1));

  v7 = (id)nw_context_copy_globals_context(v12);
  if (a3 == -1)
  {
    v25 = *(_QWORD **)(*((_QWORD *)v7 + 4) + 8);
    if (v25)
    {
      do
      {
        v28 = (_QWORD *)*v25;
        if (v25[3] == a2)
        {
          v29 = v7;
          if ((v25[5] & 1) == 0)
          {
            v30 = (_QWORD *)*v25;
            v31 = (_QWORD *)v25[1];
            if (*v25)
            {
              v30[1] = v31;
              v31 = (_QWORD *)v25[1];
            }
            else
            {
              *(_QWORD *)(*((_QWORD *)v7 + 4) + 16) = v31;
            }
            *v31 = v30;
            *v25 = 0;
            v25[1] = 0;
            node = nw_hash_table_get_node(*(_QWORD *)(*((_QWORD *)v7 + 4) + 24), v25[3], 0);
            nw_hash_table_remove_node(*(_QWORD *)(*((_QWORD *)v7 + 4) + 24), node);
            v27 = (void *)v25[4];
            v25[4] = 0;

            free(v25);
          }

        }
        v25 = v28;
      }
      while (v28);
    }
    nw_context_cleanup_timer((NWConcrete_nw_context *)v7);
LABEL_76:

    return;
  }
  if (!v10)
  {
    __nwlog_obj(v13, v14);
    v71 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v97 = "nw_context_reset_timer_block_with_time";
    v17 = _os_log_send_and_compose_impl();

    v95 = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    v72 = __nwlog_fault((const char *)v17, &v95, &type);
    if (!(_DWORD)v72)
      goto LABEL_131;
    if (v95 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v72, v73);
      v69 = objc_claimAutoreleasedReturnValue();
      v74 = v95;
      if (os_log_type_enabled(v69, v95))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl(&dword_182FBE000, v69, v74, "%{public}s called with null block", buf, 0xCu);
      }
LABEL_130:

LABEL_131:
      if (!v17)
        goto LABEL_76;
LABEL_75:
      free((void *)v17);
      goto LABEL_76;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj(v72, v73);
      v69 = objc_claimAutoreleasedReturnValue();
      v90 = v95;
      if (os_log_type_enabled(v69, v95))
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl(&dword_182FBE000, v69, v90, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_130;
    }
    v79 = (char *)__nw_create_backtrace_string();
    __nwlog_obj(v79, v85);
    v69 = objc_claimAutoreleasedReturnValue();
    v86 = v95;
    v87 = os_log_type_enabled(v69, v95);
    if (!v79)
    {
      if (v87)
      {
        *(_DWORD *)buf = 136446210;
        v97 = "nw_context_reset_timer_block_with_time";
        _os_log_impl(&dword_182FBE000, v69, v86, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }
      goto LABEL_130;
    }
    if (v87)
    {
      *(_DWORD *)buf = 136446466;
      v97 = "nw_context_reset_timer_block_with_time";
      v98 = 2082;
      v99 = (uint64_t)v79;
      _os_log_impl(&dword_182FBE000, v69, v86, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_108:

    free(v79);
    if (!v17)
      goto LABEL_76;
    goto LABEL_75;
  }
  v15 = *(uint64_t **)(*((_QWORD *)v7 + 4) + 8);
  if (v15)
  {
    v16 = 0;
    v17 = 0;
    do
    {
      v20 = v15;
      v15 = (uint64_t *)*v15;
      if (v20[3] == a2)
      {
        if (v17)
        {
          v21 = v7;
          if ((v20[5] & 1) == 0)
          {
            v22 = *v20;
            v23 = (_QWORD *)v20[1];
            if (*v20)
            {
              *(_QWORD *)(v22 + 8) = v23;
              v23 = (_QWORD *)v20[1];
            }
            else
            {
              *(_QWORD *)(*((_QWORD *)v7 + 4) + 16) = v23;
            }
            *v23 = v22;
            *v20 = 0;
            v20[1] = 0;
            v18 = nw_hash_table_get_node(*(_QWORD *)(*((_QWORD *)v7 + 4) + 24), v20[3], 0);
            nw_hash_table_remove_node(*(_QWORD *)(*((_QWORD *)v7 + 4) + 24), v18);
            v19 = (void *)v20[4];
            v20[4] = 0;

            free(v20);
          }

        }
        else
        {
          v24 = (uint64_t **)v20[1];
          if (v15)
          {
            v15[1] = (uint64_t)v24;
            v24 = (uint64_t **)v20[1];
          }
          else
          {
            *(_QWORD *)(*((_QWORD *)v7 + 4) + 16) = v24;
          }
          *v24 = v15;
          v16 = 1;
          v17 = (uint64_t)v20;
          *v20 = 0;
          v20[1] = 0;
        }
      }
    }
    while (v15);
    if (v17)
      goto LABEL_36;
  }
  else
  {
    v16 = 0;
  }
  v17 = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL);
  if (v17)
  {
LABEL_36:
    *(_QWORD *)(v17 + 16) = a3;
    *(_QWORD *)(v17 + 24) = a2;
    v33 = _Block_copy(v10);
    v34 = *(void **)(v17 + 32);
    *(_QWORD *)(v17 + 32) = v33;

    v35 = (_QWORD *)(*((_QWORD *)v7 + 4) + 8);
    do
    {
      v35 = (_QWORD *)*v35;
      if (!v35)
      {
        *(_QWORD *)v17 = 0;
        *(_QWORD *)(v17 + 8) = *(_QWORD *)(*((_QWORD *)v7 + 4) + 16);
        **(_QWORD **)(*((_QWORD *)v7 + 4) + 16) = v17;
        *(_QWORD *)(*((_QWORD *)v7 + 4) + 16) = v17;
        if ((v16 & 1) != 0)
          goto LABEL_44;
        goto LABEL_42;
      }
    }
    while (*(_QWORD *)(v17 + 16) >= v35[2]);
    v36 = v35[1];
    *(_QWORD *)v17 = v35;
    *(_QWORD *)(v17 + 8) = v36;
    *(_QWORD *)v35[1] = v17;
    v35[1] = v17;
    if ((v16 & 1) != 0)
    {
LABEL_44:
      v38 = (uint64_t *)*((_QWORD *)v7 + 4);
      if (v38[1] == v17)
      {
        v39 = v38[4];
        if (!v39 || v39 > *(_QWORD *)(v17 + 16))
        {
          v40 = *v38;
          if (!*v38)
          {
            v91[0] = MEMORY[0x1E0C809B0];
            v91[1] = 3221225472;
            v91[2] = __nw_context_reset_timer_block_with_time_block_invoke;
            v91[3] = &unk_1E14ACFD0;
            v92 = v7;
            **((_QWORD **)v7 + 4) = nw_queue_context_create_source(v92, 2, 7, 0, v91, 0);
            if (!networkd_settings_get_BOOL((const char *)nw_setting_context_timer_disable_qos_override))
              nw_queue_source_set_qos_class_fallback(**((_QWORD ***)v7 + 4), 25);

            v40 = **((_QWORD **)v7 + 4);
          }
          nw_queue_set_timer_values(v40, *(_QWORD *)(v17 + 16), 0xFFFFFFFFFFFFFFFFLL, 0);
          nw_queue_activate_source(**((_QWORD **)v7 + 4), v41);
          *(_QWORD *)(*((_QWORD *)v7 + 4) + 32) = *(_QWORD *)(v17 + 16);
        }
      }
      goto LABEL_76;
    }
LABEL_42:
    v95 = OS_LOG_TYPE_DEFAULT;
    v37 = nw_hash_table_add_object(*(_QWORD *)(*((_QWORD *)v7 + 4) + 24), v17, (char *)&v95);
    if (v95 && v37)
      goto LABEL_44;
    v42 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v42);
    v43 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v97 = "nw_context_reset_timer_block_with_time";
    v44 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v93 = 0;
    if (__nwlog_fault(v44, &type, &v93))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v45 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v45);
        v46 = (id)gLogObj;
        v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl(&dword_182FBE000, v46, v47, "%{public}s Failed to add timer to hash table", buf, 0xCu);
        }
      }
      else if (v93)
      {
        v48 = __nw_create_backtrace_string();
        if (v48)
        {
          v50 = (char *)v48;
          v51 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v51);
          v52 = (id)gLogObj;
          v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446466;
            v97 = "nw_context_reset_timer_block_with_time";
            v98 = 2082;
            v99 = (uint64_t)v50;
            _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s Failed to add timer to hash table, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v50);
          if (!v44)
            goto LABEL_71;
          goto LABEL_70;
        }
        __nwlog_obj(0, v49);
        v46 = objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl(&dword_182FBE000, v46, v56, "%{public}s Failed to add timer to hash table, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v54 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v54);
        v46 = (id)gLogObj;
        v55 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)buf = 136446210;
          v97 = "nw_context_reset_timer_block_with_time";
          _os_log_impl(&dword_182FBE000, v46, v55, "%{public}s Failed to add timer to hash table, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v44)
    {
LABEL_71:
      v57 = *(_QWORD *)v17;
      v58 = *(_QWORD **)(v17 + 8);
      if (*(_QWORD *)v17)
      {
        *(_QWORD *)(v57 + 8) = v58;
        v58 = *(_QWORD **)(v17 + 8);
      }
      else
      {
        *(_QWORD *)(*((_QWORD *)v7 + 4) + 16) = v58;
      }
      *v58 = v57;
      *(_QWORD *)v17 = 0;
      *(_QWORD *)(v17 + 8) = 0;
      v59 = *(void **)(v17 + 32);
      *(_QWORD *)(v17 + 32) = 0;

      goto LABEL_75;
    }
LABEL_70:
    free(v44);
    goto LABEL_71;
  }
  __nwlog_obj(0, v32);
  v83 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v83, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v97 = "strict_calloc";
  v98 = 2048;
  v99 = 1;
  v100 = 2048;
  v101 = 48;
  v84 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v84))
  {
    free(v84);
    v17 = 0;
    goto LABEL_36;
  }
  __break(1u);
}

void sub_1831038BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_remove_input_handler(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  void (**v14)(_QWORD);
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  void (**v18)(_QWORD);
  const void *v19;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  const char *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  char *backtrace_string;
  _BOOL4 v35;
  const char *v36;
  char *v37;
  _BOOL4 v38;
  char *v39;
  _BOOL4 v40;
  const char *v41;
  const char *v42;
  char v43;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  void *v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(void **)(a1 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      v5 = *(_QWORD *)(a1 + 88);
      if (v5)
        *(_QWORD *)(a1 + 88) = v5 + 1;
    }
    if (a2)
    {
      v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        v7 = *(_QWORD *)(a2 + 88);
        if (v7)
          *(_QWORD *)(a2 + 88) = v7 + 1;
      }
      v8 = *(_QWORD *)(a1 + 24);
      if (v8)
      {
        v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 8);
        if (v9)
        {
          v10 = v9(a1, a2);
          if (v6 != &nw_protocol_ref_counted_handle)
          {
LABEL_13:
            if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              v12 = *(_QWORD *)(a1 + 88);
              if (v12)
              {
                v13 = v12 - 1;
                *(_QWORD *)(a1 + 88) = v13;
                if (!v13)
                {
                  v14 = *(void (***)(_QWORD))(a1 + 64);
                  if (v14)
                  {
                    *(_QWORD *)(a1 + 64) = 0;
                    v14[2](v14);
                    _Block_release(v14);
                  }
                  if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                  {
                    v15 = *(const void **)(a1 + 64);
                    if (v15)
                      _Block_release(v15);
                  }
                  free((void *)a1);
                }
              }
            }
            return v10;
          }
LABEL_12:
          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            v16 = *(_QWORD *)(a2 + 88);
            if (v16)
            {
              v17 = v16 - 1;
              *(_QWORD *)(a2 + 88) = v17;
              if (!v17)
              {
                v18 = *(void (***)(_QWORD))(a2 + 64);
                if (v18)
                {
                  *(_QWORD *)(a2 + 64) = 0;
                  v18[2](v18);
                  _Block_release(v18);
                }
                if ((*(_BYTE *)(a2 + 72) & 1) != 0)
                {
                  v19 = *(const void **)(a2 + 64);
                  if (v19)
                    _Block_release(v19);
                }
                free((void *)a2);
              }
            }
          }
          goto LABEL_13;
        }
      }
      __nwlog_obj();
      v20 = *(const char **)(a1 + 16);
      *(_DWORD *)buf = 136446722;
      v46 = "__nw_protocol_remove_input_handler";
      if (!v20)
        v20 = "invalid";
      v47 = 2082;
      v48 = (void *)v20;
      v49 = 2048;
      v50 = a1;
      v21 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v43 = 0;
      if (__nwlog_fault(v21, &type, &v43))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v22 = __nwlog_obj();
          v23 = type;
          if (!os_log_type_enabled(v22, type))
            goto LABEL_74;
          v24 = *(const char **)(a1 + 16);
          if (!v24)
            v24 = "invalid";
          *(_DWORD *)buf = 136446722;
          v46 = "__nw_protocol_remove_input_handler";
          v47 = 2082;
          v48 = (void *)v24;
          v49 = 2048;
          v50 = a1;
          v25 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback";
LABEL_73:
          _os_log_impl(&dword_182FBE000, v22, v23, v25, buf, 0x20u);
          goto LABEL_74;
        }
        if (!v43)
        {
          v22 = __nwlog_obj();
          v23 = type;
          if (!os_log_type_enabled(v22, type))
            goto LABEL_74;
          v41 = *(const char **)(a1 + 16);
          if (!v41)
            v41 = "invalid";
          *(_DWORD *)buf = 136446722;
          v46 = "__nw_protocol_remove_input_handler";
          v47 = 2082;
          v48 = (void *)v41;
          v49 = 2048;
          v50 = a1;
          v25 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded";
          goto LABEL_73;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v22 = __nwlog_obj();
        v23 = type;
        v35 = os_log_type_enabled(v22, type);
        if (!backtrace_string)
        {
          if (!v35)
            goto LABEL_74;
          v42 = *(const char **)(a1 + 16);
          if (!v42)
            v42 = "invalid";
          *(_DWORD *)buf = 136446722;
          v46 = "__nw_protocol_remove_input_handler";
          v47 = 2082;
          v48 = (void *)v42;
          v49 = 2048;
          v50 = a1;
          v25 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace";
          goto LABEL_73;
        }
        if (v35)
        {
          v36 = *(const char **)(a1 + 16);
          if (!v36)
            v36 = "invalid";
          *(_DWORD *)buf = 136446978;
          v46 = "__nw_protocol_remove_input_handler";
          v47 = 2082;
          v48 = (void *)v36;
          v49 = 2048;
          v50 = a1;
          v51 = 2082;
          v52 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(backtrace_string);
      }
LABEL_74:
      if (v21)
        free(v21);
      v10 = 0;
      if (v6 != &nw_protocol_ref_counted_handle)
        goto LABEL_13;
      goto LABEL_12;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "__nw_protocol_remove_input_handler";
    v30 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (__nwlog_fault(v30, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v46 = "__nw_protocol_remove_input_handler";
          v33 = "%{public}s called with null input_protocol";
LABEL_90:
          _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0xCu);
        }
      }
      else if (v43)
      {
        v39 = (char *)__nw_create_backtrace_string();
        v31 = __nwlog_obj();
        v32 = type;
        v40 = os_log_type_enabled(v31, type);
        if (v39)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446466;
            v46 = "__nw_protocol_remove_input_handler";
            v47 = 2082;
            v48 = v39;
            _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v39);
          goto LABEL_91;
        }
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v46 = "__nw_protocol_remove_input_handler";
          v33 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_90;
        }
      }
      else
      {
        v31 = __nwlog_obj();
        v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          v46 = "__nw_protocol_remove_input_handler";
          v33 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_90;
        }
      }
    }
LABEL_91:
    if (v30)
      free(v30);
    v10 = 0;
    goto LABEL_13;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v46 = "__nw_protocol_remove_input_handler";
  v26 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v43 = 0;
  if (__nwlog_fault(v26, &type, &v43))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "__nw_protocol_remove_input_handler";
        v29 = "%{public}s called with null protocol";
LABEL_84:
        _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
      }
    }
    else if (v43)
    {
      v37 = (char *)__nw_create_backtrace_string();
      v27 = __nwlog_obj();
      v28 = type;
      v38 = os_log_type_enabled(v27, type);
      if (v37)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          v46 = "__nw_protocol_remove_input_handler";
          v47 = 2082;
          v48 = v37;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v37);
        goto LABEL_85;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v46 = "__nw_protocol_remove_input_handler";
        v29 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_84;
      }
    }
    else
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v46 = "__nw_protocol_remove_input_handler";
        v29 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_84;
      }
    }
  }
LABEL_85:
  if (v26)
    free(v26);
  return 0;
}

uint64_t nw_protocol_udp_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  nw_protocol_callbacks *callbacks;
  nw_protocol_callbacks *v7;
  void (**v8)(_QWORD);
  const void *v9;
  uint64_t output_handler;
  void *v12;
  uint64_t v13;
  void *handle;
  nw_protocol_callbacks *v15;
  uint64_t v16;
  void (*v17)(uint64_t, nw_protocol *, uint64_t);
  nw_protocol *default_input_handler;
  void *output_handler_context;
  nw_protocol_callbacks *v20;
  nw_protocol_callbacks *v21;
  void (**v22)(_QWORD);
  const void *v23;
  nw_protocol_callbacks *v24;
  nw_protocol_callbacks *v25;
  void (**v26)(_QWORD);
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  void (**v30)(_QWORD);
  const void *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  const char *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  const char *v44;
  const char *v45;
  char *backtrace_string;
  _BOOL4 v47;
  const char *v48;
  _BOOL4 v49;
  char *v50;
  _BOOL4 v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  char *v55;
  _BOOL4 v56;
  const char *v57;
  char *v58;
  _BOOL4 v59;
  const char *v60;
  const char *v61;
  char v62;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v65;
  __int16 v66;
  void *v67;
  __int16 v68;
  uint64_t v69;
  __int16 v70;
  char *v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v65 = "nw_protocol_udp_remove_input_handler";
    v32 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v32, &type, &v62))
      goto LABEL_130;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v62)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        v65 = "nw_protocol_udp_remove_input_handler";
        v35 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_129;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v47 = os_log_type_enabled(v33, type);
      if (!backtrace_string)
      {
        if (!v47)
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        v65 = "nw_protocol_udp_remove_input_handler";
        v35 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_129;
      }
      if (v47)
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_protocol_udp_remove_input_handler";
        v66 = 2082;
        v67 = backtrace_string;
        v48 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_91:
        _os_log_impl(&dword_182FBE000, v33, v34, v48, buf, 0x16u);
      }
LABEL_92:
      free(backtrace_string);
      goto LABEL_130;
    }
    v33 = __nwlog_obj();
    v34 = type;
    if (!os_log_type_enabled(v33, type))
      goto LABEL_130;
    *(_DWORD *)buf = 136446210;
    v65 = "nw_protocol_udp_remove_input_handler";
    v35 = "%{public}s called with null protocol";
LABEL_129:
    _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
LABEL_130:
    if (v32)
      free(v32);
    return 0;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v65 = "nw_protocol_udp_remove_input_handler";
    v32 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v32, &type, &v62))
      goto LABEL_130;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      v65 = "nw_protocol_udp_remove_input_handler";
      v35 = "%{public}s called with null udp";
      goto LABEL_129;
    }
    if (!v62)
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      v65 = "nw_protocol_udp_remove_input_handler";
      v35 = "%{public}s called with null udp, backtrace limit exceeded";
      goto LABEL_129;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v33 = __nwlog_obj();
    v34 = type;
    v49 = os_log_type_enabled(v33, type);
    if (backtrace_string)
    {
      if (v49)
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_protocol_udp_remove_input_handler";
        v66 = 2082;
        v67 = backtrace_string;
        v48 = "%{public}s called with null udp, dumping backtrace:%{public}s";
        goto LABEL_91;
      }
      goto LABEL_92;
    }
    if (!v49)
      goto LABEL_130;
    *(_DWORD *)buf = 136446210;
    v65 = "nw_protocol_udp_remove_input_handler";
    v35 = "%{public}s called with null udp, no backtrace";
    goto LABEL_129;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v65 = "__nw_protocol_get_output_handler";
    v36 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v36, &type, &v62))
      goto LABEL_135;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type))
        goto LABEL_135;
      *(_DWORD *)buf = 136446210;
      v65 = "__nw_protocol_get_output_handler";
      v39 = "%{public}s called with null protocol";
    }
    else if (v62)
    {
      v50 = (char *)__nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type;
      v51 = os_log_type_enabled(v37, type);
      if (v50)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          v65 = "__nw_protocol_get_output_handler";
          v66 = 2082;
          v67 = v50;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v50);
LABEL_135:
        if (v36)
          free(v36);
        if (a1->default_input_handler)
          return 0;
        goto LABEL_18;
      }
      if (!v51)
        goto LABEL_135;
      *(_DWORD *)buf = 136446210;
      v65 = "__nw_protocol_get_output_handler";
      v39 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type))
        goto LABEL_135;
      *(_DWORD *)buf = 136446210;
      v65 = "__nw_protocol_get_output_handler";
      v39 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v37, v38, v39, buf, 0xCu);
    goto LABEL_135;
  }
  if (a2->output_handler == a1)
  {
    callbacks = a1[1].callbacks;
    if (callbacks)
    {
      v7 = (nw_protocol_callbacks *)((char *)callbacks - 1);
      a1[1].callbacks = v7;
      if (!v7)
      {
        v8 = *(void (***)(_QWORD))a1[1].flow_id;
        if (v8)
        {
          *(_QWORD *)a1[1].flow_id = 0;
          v8[2](v8);
          _Block_release(v8);
        }
        if ((a1[1].flow_id[8] & 1) != 0)
        {
          v9 = *(const void **)a1[1].flow_id;
          if (v9)
            _Block_release(v9);
        }
        free(a1);
      }
    }
    a2->output_handler = 0;
  }
  if (a1->default_input_handler != a2)
    return 0;
  if (a2->handle == &nw_protocol_ref_counted_handle)
  {
    v20 = a2[1].callbacks;
    if (v20)
    {
      v21 = (nw_protocol_callbacks *)((char *)v20 - 1);
      a2[1].callbacks = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))a2[1].flow_id;
        if (v22)
        {
          *(_QWORD *)a2[1].flow_id = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((a2[1].flow_id[8] & 1) != 0)
        {
          v23 = *(const void **)a2[1].flow_id;
          if (v23)
            _Block_release(v23);
        }
        free(a2);
      }
    }
  }
  a1->default_input_handler = 0;
LABEL_18:
  output_handler = (uint64_t)a1->output_handler;
  if (output_handler)
  {
    v12 = *(void **)(output_handler + 40);
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      v13 = *(_QWORD *)(output_handler + 88);
      if (v13)
        *(_QWORD *)(output_handler + 88) = v13 + 1;
    }
    handle = a1->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      v15 = a1[1].callbacks;
      if (v15)
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v15->add_input_handler + 1);
    }
    v16 = *(_QWORD *)(output_handler + 24);
    if (v16)
    {
      v17 = *(void (**)(uint64_t, nw_protocol *, uint64_t))(v16 + 8);
      if (v17)
      {
        v17(output_handler, a1, a3);
LABEL_28:
        if (handle == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
        {
          v24 = a1[1].callbacks;
          if (v24)
          {
            v25 = (nw_protocol_callbacks *)((char *)v24 - 1);
            a1[1].callbacks = v25;
            if (!v25)
            {
              v26 = *(void (***)(_QWORD))a1[1].flow_id;
              if (v26)
              {
                *(_QWORD *)a1[1].flow_id = 0;
                v26[2](v26);
                _Block_release(v26);
              }
              if ((a1[1].flow_id[8] & 1) != 0)
              {
                v27 = *(const void **)a1[1].flow_id;
                if (v27)
                  _Block_release(v27);
              }
              free(a1);
            }
          }
        }
        if (v12 != &nw_protocol_ref_counted_handle)
          goto LABEL_32;
        if (*(_UNKNOWN **)(output_handler + 40) != &nw_protocol_ref_counted_handle)
          goto LABEL_32;
        v28 = *(_QWORD *)(output_handler + 88);
        if (!v28)
          goto LABEL_32;
        v29 = v28 - 1;
        *(_QWORD *)(output_handler + 88) = v29;
        if (v29)
          goto LABEL_32;
        v30 = *(void (***)(_QWORD))(output_handler + 64);
        if (v30)
        {
          *(_QWORD *)(output_handler + 64) = 0;
          v30[2](v30);
          _Block_release(v30);
        }
        if ((*(_BYTE *)(output_handler + 72) & 1) != 0)
        {
          v31 = *(const void **)(output_handler + 64);
          if (v31)
            _Block_release(v31);
        }
        goto LABEL_62;
      }
    }
    __nwlog_obj();
    v40 = *(const char **)(output_handler + 16);
    *(_DWORD *)buf = 136446722;
    v65 = "__nw_protocol_remove_input_handler";
    if (!v40)
      v40 = "invalid";
    v66 = 2082;
    v67 = (void *)v40;
    v68 = 2048;
    v69 = output_handler;
    v41 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (__nwlog_fault(v41, &type, &v62))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v42 = __nwlog_obj();
        v43 = type;
        if (!os_log_type_enabled(v42, type))
          goto LABEL_144;
        v44 = *(const char **)(output_handler + 16);
        if (!v44)
          v44 = "invalid";
        *(_DWORD *)buf = 136446722;
        v65 = "__nw_protocol_remove_input_handler";
        v66 = 2082;
        v67 = (void *)v44;
        v68 = 2048;
        v69 = output_handler;
        v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback";
        goto LABEL_143;
      }
      if (!v62)
      {
        v42 = __nwlog_obj();
        v43 = type;
        if (!os_log_type_enabled(v42, type))
          goto LABEL_144;
        v60 = *(const char **)(output_handler + 16);
        if (!v60)
          v60 = "invalid";
        *(_DWORD *)buf = 136446722;
        v65 = "__nw_protocol_remove_input_handler";
        v66 = 2082;
        v67 = (void *)v60;
        v68 = 2048;
        v69 = output_handler;
        v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded";
        goto LABEL_143;
      }
      v55 = (char *)__nw_create_backtrace_string();
      v42 = __nwlog_obj();
      v43 = type;
      v56 = os_log_type_enabled(v42, type);
      if (v55)
      {
        if (v56)
        {
          v57 = *(const char **)(output_handler + 16);
          if (!v57)
            v57 = "invalid";
          *(_DWORD *)buf = 136446978;
          v65 = "__nw_protocol_remove_input_handler";
          v66 = 2082;
          v67 = (void *)v57;
          v68 = 2048;
          v69 = output_handler;
          v70 = 2082;
          v71 = v55;
          _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v55);
        goto LABEL_144;
      }
      if (v56)
      {
        v61 = *(const char **)(output_handler + 16);
        if (!v61)
          v61 = "invalid";
        *(_DWORD *)buf = 136446722;
        v65 = "__nw_protocol_remove_input_handler";
        v66 = 2082;
        v67 = (void *)v61;
        v68 = 2048;
        v69 = output_handler;
        v45 = "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace";
LABEL_143:
        _os_log_impl(&dword_182FBE000, v42, v43, v45, buf, 0x20u);
      }
    }
LABEL_144:
    if (v41)
      free(v41);
    goto LABEL_28;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v65 = "__nw_protocol_remove_input_handler";
  output_handler = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v62 = 0;
  if (!__nwlog_fault((const char *)output_handler, &type, &v62))
  {
LABEL_151:
    if (!output_handler)
      goto LABEL_32;
    goto LABEL_62;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    v52 = __nwlog_obj();
    v53 = type;
    if (!os_log_type_enabled(v52, type))
      goto LABEL_151;
    *(_DWORD *)buf = 136446210;
    v65 = "__nw_protocol_remove_input_handler";
    v54 = "%{public}s called with null protocol";
LABEL_150:
    _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0xCu);
    goto LABEL_151;
  }
  if (!v62)
  {
    v52 = __nwlog_obj();
    v53 = type;
    if (!os_log_type_enabled(v52, type))
      goto LABEL_151;
    *(_DWORD *)buf = 136446210;
    v65 = "__nw_protocol_remove_input_handler";
    v54 = "%{public}s called with null protocol, backtrace limit exceeded";
    goto LABEL_150;
  }
  v58 = (char *)__nw_create_backtrace_string();
  v52 = __nwlog_obj();
  v53 = type;
  v59 = os_log_type_enabled(v52, type);
  if (!v58)
  {
    if (!v59)
      goto LABEL_151;
    *(_DWORD *)buf = 136446210;
    v65 = "__nw_protocol_remove_input_handler";
    v54 = "%{public}s called with null protocol, no backtrace";
    goto LABEL_150;
  }
  if (v59)
  {
    *(_DWORD *)buf = 136446466;
    v65 = "__nw_protocol_remove_input_handler";
    v66 = 2082;
    v67 = v58;
    _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v58);
  if (!output_handler)
    goto LABEL_32;
LABEL_62:
  free((void *)output_handler);
LABEL_32:
  if ((_DWORD)a3)
  {
    default_input_handler = a1[1].default_input_handler;
    if (default_input_handler)
    {
      os_release(default_input_handler);
      a1[1].default_input_handler = 0;
    }
    output_handler_context = a1[1].output_handler_context;
    if (output_handler_context)
    {
      os_release(output_handler_context);
      a1[1].output_handler_context = 0;
    }
    nw_protocol_destroy((uint64_t)&a1[1].output_handler, 0);
  }
  return 1;
}

uint64_t storeEnumTagSinglePayload for NWActivity.CompletionReason(uint64_t result, int a2, int a3)
{
  char v3;

  if (a2)
  {
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 8) = 0;
    *(_BYTE *)(result + 16) = 0;
    *(_DWORD *)result = a2 - 1;
    if (!a3)
      return result;
    v3 = 1;
  }
  else
  {
    if (!a3)
      return result;
    v3 = 0;
  }
  *(_BYTE *)(result + 17) = v3;
  return result;
}

BOOL nw_path_get_rtt_values(void *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  id v9;
  void *v10;
  _BOOL8 v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  os_log_type_t v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[32];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = v9;
  if (v9)
  {
    if (a5)
    {
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v29 = 0u;
      memset(buf, 0, sizeof(buf));
      v11 = nw_path_fillout_route_stats(v9, (uint64_t)buf, a5);
      if (v11)
      {
        if (a2)
          *a2 = DWORD1(v33);
        if (a3)
          *a3 = DWORD2(v33);
        if (a4)
          *a4 = HIDWORD(v33);
      }
      else
      {
        if (a2)
          *a2 = 0;
        if (a3)
          *a3 = 0;
        if (a4)
          *a4 = 0;
        *a5 = 0;
      }
      goto LABEL_17;
    }
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v14, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null route_flags", buf, 0xCu);
        }
LABEL_49:

        goto LABEL_50;
      }
      if (!v26)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
          _os_log_impl(&dword_182FBE000, v15, v25, "%{public}s called with null route_flags, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_49;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      v23 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
          _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null route_flags, no backtrace", buf, 0xCu);
        }
        goto LABEL_49;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v15, v22, "%{public}s called with null route_flags, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_37;
    }
  }
  else
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v14, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null path", buf, 0xCu);
        }
        goto LABEL_49;
      }
      if (!v26)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
          _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_49;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v15, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
          _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
        goto LABEL_49;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_path_get_rtt_values";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_37:

      free(backtrace_string);
    }
  }
LABEL_50:
  if (v14)
    free(v14);
  v11 = 0;
LABEL_17:

  return v11;
}

void sub_1831051E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_path_fillout_route_stats(void *a1, uint64_t a2, _DWORD *a3)
{
  void **v5;
  void **v6;
  id v7;
  int v8;
  int v9;
  _BOOL8 v10;
  int v11;
  NSObject *v13;
  __int128 v14;
  uint64_t v15;
  id v16;
  char *v17;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  os_log_type_t v25;
  os_log_type_t v26;
  void *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  void *v31;
  os_log_type_t v32;
  char *backtrace_string;
  os_log_type_t v34;
  _BOOL4 v35;
  os_log_type_t v36;
  _BOOL4 v37;
  os_log_type_t v38;
  os_log_type_t v39;
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  char *v48;
  uint8_t v49[32];
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v49 = 136446210;
    *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
    v28 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v28, buf, &type))
      goto LABEL_66;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v30 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v49 = 136446210;
        *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null path", v49, 0xCu);
      }
      goto LABEL_65;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v38 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v49 = 136446210;
        *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_182FBE000, v29, v38, "%{public}s called with null path, backtrace limit exceeded", v49, 0xCu);
      }
      goto LABEL_65;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = objc_claimAutoreleasedReturnValue();
    v34 = buf[0];
    v35 = os_log_type_enabled(v29, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)v49 = 136446210;
        *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null path, no backtrace", v49, 0xCu);
      }
      goto LABEL_65;
    }
    if (v35)
    {
      *(_DWORD *)v49 = 136446466;
      *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
      *(_WORD *)&v49[12] = 2082;
      *(_QWORD *)&v49[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null path, dumping backtrace:%{public}s", v49, 0x16u);
    }
    goto LABEL_53;
  }
  if (!a2)
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v49 = 136446210;
    *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
    v28 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v28, buf, &type))
      goto LABEL_66;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v32 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v49 = 136446210;
        *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null return_stats", v49, 0xCu);
      }
LABEL_65:

LABEL_66:
      if (v28)
        free(v28);
      goto LABEL_68;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v39 = buf[0];
      if (os_log_type_enabled(v29, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v49 = 136446210;
        *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_182FBE000, v29, v39, "%{public}s called with null return_stats, backtrace limit exceeded", v49, 0xCu);
      }
      goto LABEL_65;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v29 = objc_claimAutoreleasedReturnValue();
    v36 = buf[0];
    v37 = os_log_type_enabled(v29, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)v49 = 136446210;
        *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
        _os_log_impl(&dword_182FBE000, v29, v36, "%{public}s called with null return_stats, no backtrace", v49, 0xCu);
      }
      goto LABEL_65;
    }
    if (v37)
    {
      *(_DWORD *)v49 = 136446466;
      *(_QWORD *)&v49[4] = "nw_path_fillout_route_stats";
      *(_WORD *)&v49[12] = 2082;
      *(_QWORD *)&v49[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v29, v36, "%{public}s called with null return_stats, dumping backtrace:%{public}s", v49, 0x16u);
    }
LABEL_53:

    free(backtrace_string);
    goto LABEL_66;
  }
  v7 = nw_parameters_copy_context(v5[2]);
  v8 = nw_path_shared_necp_fd(v7);

  if (v8 < 0)
  {
LABEL_68:
    v10 = 0;
    goto LABEL_69;
  }
  v52 = 0;
  v50 = 0u;
  v51 = 0u;
  memset(v49, 0, sizeof(v49));
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  v9 = necp_client_action();
  v10 = v9 == 0;
  if (!v9)
  {
    v14 = *(_OWORD *)&v49[16];
    *(_OWORD *)a2 = *(_OWORD *)v49;
    *(_OWORD *)(a2 + 16) = v14;
    v15 = *(_QWORD *)((char *)&v51 + 4);
    *(_DWORD *)(a2 + 108) = HIDWORD(v51);
    *(_QWORD *)(a2 + 100) = v15;
    if (a3)
      *a3 = v52;
    goto LABEL_69;
  }
  v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v11 == 45 || v11 == 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v44 = "nw_path_fillout_route_stats";
      v45 = 1024;
      v46 = v11;
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s NECP_CLIENT_ACTION_COPY_ROUTE_STATISTICS %{darwin.errno}d", buf, 0x12u);
    }

    goto LABEL_69;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v44 = "nw_path_fillout_route_stats";
  v45 = 1024;
  v46 = v11;
  v17 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v17, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_path_fillout_route_stats";
        v45 = 1024;
        v46 = v11;
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s NECP_CLIENT_ACTION_COPY_ROUTE_STATISTICS %{darwin.errno}d", buf, 0x12u);
      }
    }
    else if (v41)
    {
      v21 = __nw_create_backtrace_string();
      if (v21)
      {
        v22 = (char *)v21;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)buf = 136446722;
          v44 = "nw_path_fillout_route_stats";
          v45 = 1024;
          v46 = v11;
          v47 = 2082;
          v48 = v22;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s NECP_CLIENT_ACTION_COPY_ROUTE_STATISTICS %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v22);
        if (v17)
          goto LABEL_33;
        goto LABEL_69;
      }
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_path_fillout_route_stats";
        v45 = 1024;
        v46 = v11;
        _os_log_impl(&dword_182FBE000, v19, v26, "%{public}s NECP_CLIENT_ACTION_COPY_ROUTE_STATISTICS %{darwin.errno}d, no backtrace", buf, 0x12u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = (id)gLogObj;
      v25 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_path_fillout_route_stats";
        v45 = 1024;
        v46 = v11;
        _os_log_impl(&dword_182FBE000, v19, v25, "%{public}s NECP_CLIENT_ACTION_COPY_ROUTE_STATISTICS %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
      }
    }

  }
  if (v17)
LABEL_33:
    free(v17);
LABEL_69:

  return v10;
}

void sub_183105A5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t type metadata accessor for NWPathMonitor()
{
  return objc_opt_self();
}

BOOL network_config_get_quic_l4s_enabled()
{
  void *v0;
  void *v1;
  BOOL value;

  v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_l4s, 0);
  v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1E0C812D0])
  {
    value = xpc_BOOL_get_value(v1);

    if (value)
      return 1;
  }
  else
  {

  }
  if (nw_settings_get_l4s_enabled_internal::onceToken != -1)
    dispatch_once(&nw_settings_get_l4s_enabled_internal::onceToken, &__block_literal_global_63599);
  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_183105B40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

ValueMetadata *type metadata accessor for NWPath.UnsatisfiedReason()
{
  return &type metadata for NWPath.UnsatisfiedReason;
}

ValueMetadata *type metadata accessor for NWInterface()
{
  return &type metadata for NWInterface;
}

void nw_endpoint_resolver_update(void *a1, void *a2, unsigned int a3)
{
  id v5;
  char *v6;
  unsigned int *v7;
  uint64_t v8;
  NWConcrete_nw_endpoint_handler *v9;
  int state;
  NWConcrete_nw_endpoint_handler *v11;
  char v12;
  NSObject *v13;
  NWConcrete_nw_endpoint_handler *v14;
  NWConcrete_nw_endpoint_handler *v15;
  char v16;
  const char *v17;
  nw_endpoint_t v18;
  const char *v19;
  char *v20;
  NWConcrete_nw_endpoint_handler *v21;
  NWConcrete_nw_endpoint_handler *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  NWConcrete_nw_endpoint_handler *v26;
  char v27;
  NSObject *v28;
  unsigned int *v29;
  NWConcrete_nw_endpoint_handler *v30;
  NWConcrete_nw_endpoint_handler *v31;
  char v32;
  const char *v33;
  nw_endpoint_t v34;
  const char *v35;
  char *id_str;
  NWConcrete_nw_endpoint_handler *v37;
  NWConcrete_nw_endpoint_handler *v38;
  uint64_t v39;
  const char *v40;
  NWConcrete_nw_endpoint_handler *v41;
  OS_nw_parameters *v42;
  NSObject *v43;
  Class isa;
  NWConcrete_nw_endpoint_handler *v45;
  _BOOL4 v46;
  NSObject *v47;
  const char *v48;
  const char *v49;
  nw_endpoint_t v50;
  const char *v51;
  const char *v52;
  const char *v53;
  OS_nw_path *v54;
  NSObject *v55;
  nw_endpoint_type_t type;
  __int16 v57;
  __int16 v58;
  _DWORD *v59;
  void **v60;
  void **v61;
  const char *v62;
  void **v63;
  void **v64;
  const char *v65;
  void **v66;
  OS_nw_path *v67;
  void **v68;
  OS_nw_path *v69;
  const char *v70;
  void *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  char *backtrace_string;
  os_log_type_t v76;
  _BOOL4 v77;
  const char *v78;
  const char *v79;
  nw_endpoint_t v80;
  const char *v81;
  const char *v82;
  const char *v83;
  OS_nw_path *v84;
  os_log_type_t v85;
  const char *id_string;
  const char *v87;
  nw_endpoint_t v88;
  const char *logging_description;
  const char *v90;
  const char *v91;
  OS_nw_path *v92;
  const char *v93;
  void *v94;
  char *v95;
  NSObject *v96;
  os_log_type_t v97;
  char *v98;
  os_log_type_t v99;
  _BOOL4 v100;
  const char *v101;
  const char *v102;
  nw_endpoint_t v103;
  const char *v104;
  const char *v105;
  const char *v106;
  OS_nw_path *v107;
  os_log_type_t v108;
  NWConcrete_nw_endpoint_handler *v109;
  _BOOL4 v110;
  NSObject *v111;
  NWConcrete_nw_endpoint_handler *v112;
  NWConcrete_nw_endpoint_handler *v113;
  _BOOL4 v114;
  const char *v115;
  nw_endpoint_t v116;
  const char *v117;
  NWConcrete_nw_endpoint_handler *v118;
  NWConcrete_nw_endpoint_handler *v119;
  uint64_t v120;
  const char *v121;
  NWConcrete_nw_endpoint_handler *v122;
  _BOOL4 v123;
  NSObject *v124;
  const char *v125;
  const char *v126;
  nw_endpoint_t v127;
  const char *v128;
  const char *v129;
  const char *v130;
  id v131;
  void *v132;
  const char *v133;
  void **v134;
  void **v135;
  const char *v136;
  NWConcrete_nw_endpoint_mode_handler *v137;
  _QWORD *v138;
  _QWORD *v139;
  void *v140;
  _QWORD *combined_array;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  unint64_t v145;
  uint64_t v146;
  NSObject *v147;
  NSObject *v148;
  char *v149;
  _BOOL4 v150;
  NSObject *v151;
  char *v152;
  char *v153;
  const char *v154;
  nw_endpoint_t v155;
  const char *v156;
  char *v157;
  char *v158;
  uint64_t v159;
  const char *v160;
  char *v161;
  const char *v162;
  unsigned __int8 *v163;
  NSObject *v164;
  NSObject *v165;
  _BOOL8 v166;
  id v167;
  void *v168;
  char *v169;
  BOOL v170;
  NSObject *v171;
  char *v172;
  char *v173;
  _BOOL4 v174;
  const char *v175;
  const char *v176;
  char *v177;
  char *v178;
  uint64_t v179;
  const char *v180;
  char *v181;
  const char *v182;
  NSObject *v183;
  const char *v184;
  char *v185;
  OS_nw_path *v186;
  const char *v187;
  OS_nw_path *v188;
  const char *v189;
  char *v190;
  OS_nw_path *v191;
  OS_nw_path *v192;
  const char *v193;
  const char *v194;
  const char *v195;
  const char *v196;
  const char *v197;
  const char *v198;
  OS_nw_path *v199;
  const char *v200;
  void *v201;
  char *v202;
  NSObject *v203;
  os_log_type_t v204;
  char *v205;
  os_log_type_t v206;
  _BOOL4 v207;
  os_log_type_t v208;
  uint64_t v209;
  NWConcrete_nw_endpoint_handler *v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  void *v214;
  _BOOL8 child_parameters;
  id *inner;
  char *v217;
  _BOOL4 v218;
  NSObject *v219;
  char *v220;
  char *v221;
  _BOOL4 v222;
  const char *v223;
  const char *v224;
  char *v225;
  char *v226;
  uint64_t v227;
  const char *v228;
  char *v229;
  const char *v230;
  char *v231;
  OS_nw_path *v232;
  OS_nw_path *v233;
  const char *v234;
  int is_known_tracker;
  const char *v236;
  const char *v237;
  const char *v238;
  const char *v239;
  OS_nw_path *v240;
  const char *v241;
  int v242;
  const char *v243;
  NSObject *v244;
  NWConcrete_nw_endpoint_handler *v245;
  _QWORD *v246;
  BOOL v247;
  unsigned __int8 *v248;
  NSObject *v249;
  const char *v250;
  const char *v251;
  nw_endpoint_t v252;
  const char *v253;
  const char *v254;
  const char *v255;
  OS_nw_path *v256;
  const char *v257;
  void *v258;
  NSObject *v259;
  nw_endpoint_type_t v260;
  __int16 v261;
  __int16 v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  NWConcrete_nw_endpoint_handler *v268;
  uint64_t v269;
  int minimize_logging;
  char logging_disabled;
  NSObject *v272;
  const char *v273;
  const char *v274;
  nw_endpoint_t v275;
  const char *v276;
  const char *v277;
  const char *v278;
  OS_nw_path *v279;
  NWConcrete_nw_endpoint_handler *v280;
  int v281;
  char v282;
  NSObject *v283;
  const char *v284;
  const char *v285;
  nw_endpoint_t v286;
  const char *v287;
  const char *v288;
  const char *v289;
  OS_nw_path *v290;
  void **v291;
  OS_nw_path *v292;
  uint64_t v293;
  id v294;
  _DWORD *dns_error;
  id v296;
  NWConcrete_nw_endpoint_handler *v297;
  char v298;
  NSObject *v299;
  const char *v300;
  const char *v301;
  nw_endpoint_t v302;
  const char *v303;
  const char *v304;
  const char *v305;
  OS_nw_path *v306;
  int error;
  const char *v308;
  const char *v309;
  nw_endpoint_t v310;
  const char *v311;
  const char *v312;
  const char *v313;
  OS_nw_path *v314;
  const char *v315;
  const char *v316;
  nw_endpoint_t v317;
  const char *v318;
  const char *v319;
  const char *v320;
  OS_nw_path *v321;
  const char *v322;
  const char *v323;
  nw_endpoint_t v324;
  const char *v325;
  const char *v326;
  const char *v327;
  OS_nw_path *v328;
  const char *v329;
  const char *v330;
  nw_endpoint_t v331;
  const char *v332;
  const char *v333;
  const char *v334;
  OS_nw_path *v335;
  _BYTE *v336;
  int v337;
  unsigned int v338;
  unsigned int v339;
  void *v340;
  nw_endpoint_t v341;
  nw_endpoint_t v342;
  const char *v343;
  os_unfair_lock_s *lock;
  os_unfair_lock_s *locka;
  NSObject *v346;
  unsigned int *v347;
  uint64_t v348;
  uint64_t v349;
  _BOOL8 obj;
  NWConcrete_nw_endpoint_handler *v351;
  NWConcrete_nw_endpoint_handler *v352;
  NWConcrete_nw_endpoint_handler *v353;
  NSObject *v354;
  const char *v355;
  const char *v356;
  uint64_t *location;
  void *v358;
  nw_endpoint_t v359;
  nw_endpoint_t v360;
  NSObject *log;
  NSObject *loga;
  NWConcrete_nw_endpoint_mode_handler *v363;
  unsigned __int8 *object;
  char *v365;
  const char *v366;
  NWConcrete_nw_endpoint_handler *v367;
  void *v368;
  _QWORD v369[4];
  char *v370;
  _QWORD v371[6];
  uint64_t v372;
  uint64_t *v373;
  uint64_t v374;
  char *v375;
  _QWORD v376[3];
  char v377;
  _BYTE buf[24];
  const char *v379;
  _BYTE v380[20];
  __int16 v381;
  const char *v382;
  __int16 v383;
  OS_nw_path *v384;
  __int16 v385;
  const char *v386;
  __int16 v387;
  const char *v388;
  uint64_t v389;

  v389 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v368 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v71 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
    v72 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v376[0]) = 16;
    LOBYTE(v372) = 0;
    if (__nwlog_fault(v72, v376, &v372))
    {
      if (LOBYTE(v376[0]) == 17)
      {
        __nwlog_obj();
        v73 = objc_claimAutoreleasedReturnValue();
        v74 = v376[0];
        if (os_log_type_enabled(v73, v376[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
          _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if ((_BYTE)v372)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v73 = objc_claimAutoreleasedReturnValue();
        v76 = v376[0];
        v77 = os_log_type_enabled(v73, v376[0]);
        if (backtrace_string)
        {
          if (v77)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v73, v76, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_94;
        }
        if (v77)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
          _os_log_impl(&dword_182FBE000, v73, v76, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v73 = objc_claimAutoreleasedReturnValue();
        v85 = v376[0];
        if (os_log_type_enabled(v73, v376[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
          _os_log_impl(&dword_182FBE000, v73, v85, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_94:
    if (v72)
      free(v72);
    goto LABEL_337;
  }
  v7 = (unsigned int *)v5;
  v8 = v7[29];

  if ((_DWORD)v8 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (v8 > 5)
        v25 = "unknown-mode";
      else
        v25 = off_1E149FC18[v8];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v25;
      *(_WORD *)&buf[22] = 2082;
      v379 = "resolver";
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
    goto LABEL_82;
  }
  v9 = v7;
  state = v9->state;

  if ((state & 0xFFFFFFFE) != 4)
  {
    v363 = nw_endpoint_handler_copy_resolver(v9);
    v366 = v6;
    if (*((char **)v363 + 1) != v6)
    {
      if (nw_endpoint_handler_get_minimize_logging(v9))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) == 0)
        {
          v353 = v9;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v28 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v9);
            v87 = nw_endpoint_handler_dry_run_string(v9);
            v88 = nw_endpoint_handler_copy_endpoint(v9);
            logging_description = nw_endpoint_get_logging_description(v88);
            v90 = nw_endpoint_handler_state_string(v9);
            v91 = nw_endpoint_handler_mode_string(v353);
            v92 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v353);
            v93 = (const char *)*((_QWORD *)v363 + 1);
            *(_DWORD *)buf = 136448258;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = id_string;
            *(_WORD *)&buf[22] = 2082;
            v379 = v87;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = logging_description;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v90;
            v381 = 2082;
            v382 = v91;
            v383 = 2114;
            v384 = v92;
            v385 = 2048;
            v386 = v93;
            v387 = 2048;
            v388 = v366;
            _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring update from old resolver object (%p != %p)", buf, 0x5Cu);

          }
          goto LABEL_335;
        }
      }
      else
      {
        v26 = v9;
        v27 = *((_BYTE *)v26 + 268);

        if ((v27 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v28 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v29 = v7;
            v30 = v26;

            v31 = v30;
            v32 = *((_BYTE *)v26 + 268);

            if ((v32 & 1) != 0)
              v33 = "dry-run ";
            else
              v33 = "";
            v34 = nw_endpoint_handler_copy_endpoint(v31);
            v35 = nw_endpoint_get_logging_description(v34);
            id_str = v30->id_str;
            v37 = v31;
            v38 = v37;
            v39 = v9->state;
            if (v39 > 5)
              v40 = "unknown-state";
            else
              v40 = off_1E149FC48[v39];

            v63 = v38;
            v64 = v63;
            v65 = "path";
            switch(v29[29])
            {
              case 0u:
                break;
              case 1u:
                v65 = "resolver";
                break;
              case 2u:
                v65 = nw_endpoint_flow_mode_string(v63[31]);
                break;
              case 3u:
                v65 = "proxy";
                break;
              case 4u:
                v65 = "fallback";
                break;
              case 5u:
                v65 = "transform";
                break;
              default:
                v65 = "unknown-mode";
                break;
            }

            v68 = v64;
            os_unfair_lock_lock((os_unfair_lock_t)v68 + 28);
            v69 = v68[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v68 + 28);

            v70 = (const char *)*((_QWORD *)v363 + 1);
            *(_DWORD *)buf = 136448258;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = id_str;
            *(_WORD *)&buf[22] = 2082;
            v379 = v33;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = v35;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v40;
            v381 = 2082;
            v382 = v65;
            v383 = 2114;
            v384 = v69;
            v385 = 2048;
            v386 = v70;
            v387 = 2048;
            v388 = v366;
            _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring update from old resolver object (%p != %p)", buf, 0x5Cu);

          }
          goto LABEL_335;
        }
      }
LABEL_336:

      v6 = (char *)v366;
      goto LABEL_337;
    }
    v41 = v9;
    v42 = v41->parameters;

    v43 = v42;
    v346 = v43;
    v351 = v9;
    if (v43)
    {
      isa = v43[12].isa;

      if (((unint64_t)isa & 0x400000000) != 0)
      {
        LOBYTE(v376[0]) = 0;
        nw_resolver_get_svcb_report(*((void **)v363 + 1), 0, (BOOL *)v376, 0);
        if (LOBYTE(v376[0]))
        {
          if (nw_endpoint_handler_get_minimize_logging(v41))
          {
            if ((nw_endpoint_handler_get_logging_disabled(v41) & 1) != 0)
              goto LABEL_41;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v47 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
            {
              v101 = nw_endpoint_handler_get_id_string(v41);
              v102 = nw_endpoint_handler_dry_run_string(v41);
              v103 = nw_endpoint_handler_copy_endpoint(v41);
              v104 = nw_endpoint_get_logging_description(v103);
              v105 = nw_endpoint_handler_state_string(v41);
              v106 = nw_endpoint_handler_mode_string(v41);
              v107 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v41);
              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v101;
              *(_WORD *)&buf[22] = 2082;
              v379 = v102;
              *(_WORD *)v380 = 2082;
              *(_QWORD *)&v380[2] = v104;
              *(_WORD *)&v380[10] = 2082;
              *(_QWORD *)&v380[12] = v105;
              v381 = 2082;
              v382 = v106;
              v383 = 2114;
              v384 = v107;
              _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received SVCB, and required to fail", buf, 0x48u);

            }
          }
          else
          {
            v45 = v41;
            v46 = (*((_BYTE *)v45 + 268) & 0x20) == 0;

            if (!v46)
            {
LABEL_41:
              v55 = nw_endpoint_handler_copy_endpoint(v41);
              type = nw_endpoint_get_type(v55);
              if (type == (nw_endpoint_type_url|nw_endpoint_type_address))
                v57 = 7;
              else
                v57 = 2;
              if (type == nw_endpoint_type_bonjour_service)
                v58 = 4;
              else
                v58 = v57;

              nw_endpoint_handler_handle_failure(v41);
              v59 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 2, -65571);
              v41->event.domain = 2;
              v41->event.event = v58;
              nw_endpoint_handler_report(v41, 0, &v41->event.domain, v59);

              goto LABEL_334;
            }
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v47 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              v48 = nw_endpoint_handler_get_id_string(v45);
              v49 = nw_endpoint_handler_dry_run_string(v45);
              v50 = nw_endpoint_handler_copy_endpoint(v45);
              v51 = nw_endpoint_get_logging_description(v50);
              v52 = nw_endpoint_handler_state_string(v45);
              v53 = nw_endpoint_handler_mode_string(v45);
              v54 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v45);
              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v48;
              *(_WORD *)&buf[22] = 2082;
              v379 = v49;
              *(_WORD *)v380 = 2082;
              *(_QWORD *)&v380[2] = v51;
              *(_WORD *)&v380[10] = 2082;
              *(_QWORD *)&v380[12] = v52;
              v381 = 2082;
              v382 = v53;
              v383 = 2114;
              v384 = v54;
              _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received SVCB, and required to fail", buf, 0x48u);

            }
          }

          goto LABEL_41;
        }
      }
LABEL_120:
      if (*((_QWORD *)v363 + 4))
      {
        if (nw_endpoint_handler_get_minimize_logging(v41))
        {
          if ((nw_endpoint_handler_get_logging_disabled(v41) & 1) != 0)
            goto LABEL_334;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v111 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
          {
            v308 = nw_endpoint_handler_get_id_string(v41);
            v309 = nw_endpoint_handler_dry_run_string(v41);
            v310 = nw_endpoint_handler_copy_endpoint(v41);
            v311 = nw_endpoint_get_logging_description(v310);
            v312 = nw_endpoint_handler_state_string(v41);
            v313 = nw_endpoint_handler_mode_string(v41);
            v314 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v41);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v308;
            *(_WORD *)&buf[22] = 2082;
            v379 = v309;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = v311;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v312;
            v381 = 2082;
            v382 = v313;
            v383 = 2114;
            v384 = v314;
            _os_log_impl(&dword_182FBE000, v111, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already connected, ignoring update from resolver", buf, 0x48u);

          }
        }
        else
        {
          v109 = v41;
          v110 = (*((_BYTE *)v109 + 268) & 0x20) == 0;

          if (!v110)
          {
LABEL_334:
            v28 = v346;
LABEL_335:

            goto LABEL_336;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v111 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
          {
            v112 = v109;

            v113 = v112;
            v114 = (*((_BYTE *)v109 + 268) & 1) == 0;

            if (v114)
              v115 = "";
            else
              v115 = "dry-run ";
            v116 = nw_endpoint_handler_copy_endpoint(v113);
            v117 = nw_endpoint_get_logging_description(v116);
            v118 = v113;
            v119 = v118;
            v120 = v9->state;
            if (v120 > 5)
              v121 = "unknown-state";
            else
              v121 = off_1E149FC48[v120];

            v134 = v119;
            v135 = v134;
            v136 = "path";
            switch(v7[29])
            {
              case 0u:
                break;
              case 1u:
                v136 = "resolver";
                break;
              case 2u:
                v136 = nw_endpoint_flow_mode_string(v134[31]);
                break;
              case 3u:
                v136 = "proxy";
                break;
              case 4u:
                v136 = "fallback";
                break;
              case 5u:
                v136 = "transform";
                break;
              default:
                v136 = "unknown-mode";
                break;
            }

            v291 = v135;
            os_unfair_lock_lock((os_unfair_lock_t)v291 + 28);
            v292 = v291[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v291 + 28);

            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v112->id_str;
            *(_WORD *)&buf[22] = 2082;
            v379 = v115;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = v117;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v121;
            v381 = 2082;
            v382 = v136;
            v383 = 2114;
            v384 = v292;
            _os_log_impl(&dword_182FBE000, v111, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already connected, ignoring update from resolver", buf, 0x48u);

          }
        }

        goto LABEL_334;
      }
      v347 = v7;
      v339 = a3;
      *((_DWORD *)v363 + 4) = a3;
      v122 = v41;
      v123 = (*((_BYTE *)v122 + 268) & 0x20) == 0;
      v367 = v122;

      if (v123)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v124 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v124, OS_LOG_TYPE_DEBUG))
        {
          v125 = nw_endpoint_handler_get_id_string(v367);
          v126 = nw_endpoint_handler_dry_run_string(v367);
          v127 = nw_endpoint_handler_copy_endpoint(v367);
          v128 = nw_endpoint_get_logging_description(v127);
          v129 = nw_endpoint_handler_state_string(v367);
          v130 = nw_endpoint_handler_mode_string(v367);
          v131 = nw_endpoint_handler_copy_current_path(v367);
          v132 = v131;
          if (v339 > 2)
            v133 = "unknown";
          else
            v133 = off_1E149FA90[v339];
          *(_DWORD *)buf = 136448002;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v125;
          *(_WORD *)&buf[22] = 2082;
          v379 = v126;
          *(_WORD *)v380 = 2082;
          *(_QWORD *)&v380[2] = v128;
          *(_WORD *)&v380[10] = 2082;
          *(_QWORD *)&v380[12] = v129;
          v381 = 2082;
          v382 = v130;
          v383 = 2114;
          v384 = (OS_nw_path *)v131;
          v385 = 2082;
          v386 = v133;
          _os_log_impl(&dword_182FBE000, v124, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolver is %{public}s", buf, 0x52u);

        }
      }
      v137 = v363;
      v138 = *((id *)v363 + 12);
      v139 = v138;
      v140 = (void *)*((_QWORD *)v363 + 11);
      if (v140)
      {
        combined_array = nw_array_create_combined_array(v138, v140);

        v139 = combined_array;
        v137 = v363;
      }
      v340 = v139;
      if (v139)
      {
        if (v139[3] != v139[2])
        {
          v142 = *((_QWORD *)v137 + 8);
          if (v142)
          {
            nw_queue_cancel_source(v142, (uint64_t)v140);
            *((_QWORD *)v137 + 8) = 0;
          }
        }
      }
      if (v339 - 1 > 1)
      {
LABEL_333:

        goto LABEL_334;
      }
      object = v139;
      obj = nw_array_create();
      v143 = *((_QWORD *)v363 + 5);
      location = (uint64_t *)((char *)v363 + 40);
      if (v143)
      {
        v144 = *((unsigned int *)v363 + 5);
        if (v144 > (uint64_t)(*(_QWORD *)(v143 + 24) - *(_QWORD *)(v143 + 16)) >> 3)
          v144 = (uint64_t)(*(_QWORD *)(v143 + 24) - *(_QWORD *)(v143 + 16)) >> 3;
      }
      else
      {
        LODWORD(v144) = *((_DWORD *)v363 + 5);
        if ((_DWORD)v144)
          LODWORD(v144) = 0;
      }
      if ((_DWORD)v144)
      {
        v145 = 0;
        v348 = v144;
        lock = &v367->lock;
        while (1)
        {
          nw_array_get_object_at_index(*location, v145);
          v146 = objc_claimAutoreleasedReturnValue();
          nw_array_append(obj, (void *)v146);
          v358 = (void *)v146;
          v147 = nw_endpoint_handler_copy_endpoint((void *)v146);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___ZL44nw_endpoint_resolver_array_contains_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke;
          v379 = (const char *)&unk_1E14AC200;
          *(_QWORD *)v380 = v147;
          v148 = v147;
          LOBYTE(v146) = nw_array_apply(object, (uint64_t)buf);

          if ((v146 & 1) == 0)
            break;
          if (nw_endpoint_handler_get_minimize_logging(v367))
          {
            if ((nw_endpoint_handler_get_logging_disabled(v367) & 1) != 0)
              goto LABEL_198;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            log = (id)gconnectionLogObj;
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
            {
              v194 = nw_endpoint_handler_get_id_string(v367);
              v195 = nw_endpoint_handler_dry_run_string(v367);
              v342 = nw_endpoint_handler_copy_endpoint(v367);
              v196 = nw_endpoint_get_logging_description(v342);
              v197 = nw_endpoint_handler_state_string(v367);
              v198 = nw_endpoint_handler_mode_string(v367);
              v199 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
              v200 = nw_endpoint_get_logging_description(v148);
              *(_DWORD *)buf = 136448002;
              *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v194;
              *(_WORD *)&buf[22] = 2082;
              v379 = v195;
              *(_WORD *)v380 = 2082;
              *(_QWORD *)&v380[2] = v196;
              *(_WORD *)&v380[10] = 2082;
              *(_QWORD *)&v380[12] = v197;
              v381 = 2082;
              v382 = v198;
              v383 = 2114;
              v384 = v199;
              v385 = 2082;
              v386 = v200;
              _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Started endpoint %{public}s is no longer resolved", buf, 0x52u);

              goto LABEL_196;
            }
            v151 = log;
            goto LABEL_197;
          }
          v149 = v367;
          v150 = (*((_BYTE *)v367 + 268) & 0x20) == 0;

          if (v150)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v151 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v151, OS_LOG_TYPE_INFO))
            {
              log = v151;
              v152 = v149;

              v153 = v152;
              LODWORD(v152) = (*((_BYTE *)v367 + 268) & 1) == 0;

              if ((_DWORD)v152)
                v154 = "";
              else
                v154 = "dry-run ";
              v155 = nw_endpoint_handler_copy_endpoint(v153);
              v156 = nw_endpoint_get_logging_description(v155);
              v157 = v153;
              v158 = v157;
              v159 = v351->state;
              v160 = "unknown-state";
              if (v159 <= 5)
                v160 = off_1E149FC48[v159];

              v161 = v158;
              v162 = "path";
              switch(v347[29])
              {
                case 0u:
                  break;
                case 1u:
                  v162 = "resolver";
                  break;
                case 2u:
                  v162 = nw_endpoint_flow_mode_string(v367->mode_handler);
                  break;
                case 3u:
                  v162 = "proxy";
                  break;
                case 4u:
                  v162 = "fallback";
                  break;
                case 5u:
                  v162 = "transform";
                  break;
                default:
                  v162 = "unknown-mode";
                  break;
              }

              v190 = v161;
              os_unfair_lock_lock(lock);
              v191 = v367->current_path;
              os_unfair_lock_unlock(lock);

              v192 = v191;
              v193 = nw_endpoint_get_logging_description(v148);
              *(_DWORD *)buf = 136448002;
              *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v367->id_str;
              *(_WORD *)&buf[22] = 2082;
              v379 = v154;
              *(_WORD *)v380 = 2082;
              *(_QWORD *)&v380[2] = v156;
              *(_WORD *)&v380[10] = 2082;
              *(_QWORD *)&v380[12] = v160;
              v381 = 2082;
              v382 = v162;
              v383 = 2114;
              v384 = v192;
              v385 = 2082;
              v386 = v193;
              _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Started endpoint %{public}s is no longer resolved", buf, 0x52u);

              goto LABEL_196;
            }
            goto LABEL_197;
          }
LABEL_198:

          if (v348 == ++v145)
            goto LABEL_226;
        }
        v163 = object;
        v164 = v148;
        log = v163;
        v354 = v164;
        if (v164)
        {
          v165 = v164;
          v166 = nw_array_create();
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___ZL53nw_endpoint_resolver_duplicate_array_without_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke;
          v379 = (const char *)&unk_1E14A8D20;
          *(_QWORD *)v380 = v165;
          v167 = (id)v166;
          *(_QWORD *)&v380[8] = v167;
          nw_array_apply(v163, (uint64_t)buf);
          v168 = *(void **)&v380[8];
          object = (unsigned __int8 *)v167;

          goto LABEL_172;
        }
        __nwlog_obj();
        v201 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_duplicate_array_without_endpoint";
        v337 = 12;
        v336 = buf;
        v202 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(v376[0]) = 16;
        LOBYTE(v372) = 0;
        if (__nwlog_fault(v202, v376, &v372))
        {
          if (LOBYTE(v376[0]) == 17)
          {
            __nwlog_obj();
            v203 = objc_claimAutoreleasedReturnValue();
            v204 = v376[0];
            if (os_log_type_enabled(v203, v376[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_resolver_duplicate_array_without_endpoint";
              _os_log_impl(&dword_182FBE000, v203, v204, "%{public}s called with null remove_endpoint", buf, 0xCu);
            }
          }
          else if ((_BYTE)v372)
          {
            v205 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v203 = objc_claimAutoreleasedReturnValue();
            v206 = v376[0];
            v207 = os_log_type_enabled(v203, v376[0]);
            if (v205)
            {
              if (v207)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_endpoint_resolver_duplicate_array_without_endpoint";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v205;
                _os_log_impl(&dword_182FBE000, v203, v206, "%{public}s called with null remove_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v205);
              goto LABEL_222;
            }
            if (v207)
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_resolver_duplicate_array_without_endpoint";
              _os_log_impl(&dword_182FBE000, v203, v206, "%{public}s called with null remove_endpoint, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v203 = objc_claimAutoreleasedReturnValue();
            v208 = v376[0];
            if (os_log_type_enabled(v203, v376[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_endpoint_resolver_duplicate_array_without_endpoint";
              _os_log_impl(&dword_182FBE000, v203, v208, "%{public}s called with null remove_endpoint, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
LABEL_222:
        if (v202)
          free(v202);
        object = 0;
LABEL_172:

        v169 = v367;
        v170 = (*((_BYTE *)v367 + 268) & 0x20) == 0;

        if (v170)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v171 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
          {
            v172 = v169;

            v173 = v172;
            v174 = (*((_BYTE *)v367 + 268) & 1) == 0;

            if (v174)
              v175 = "";
            else
              v175 = "dry-run ";
            v341 = nw_endpoint_handler_copy_endpoint(v173);
            v176 = nw_endpoint_get_logging_description(v341);
            v177 = v173;
            v178 = v177;
            v179 = v351->state;
            v180 = "unknown-state";
            if (v179 <= 5)
              v180 = off_1E149FC48[v179];

            v181 = v178;
            v182 = "path";
            switch(v347[29])
            {
              case 0u:
                break;
              case 1u:
                v182 = "resolver";
                break;
              case 2u:
                v182 = nw_endpoint_flow_mode_string(v367->mode_handler);
                break;
              case 3u:
                v182 = "proxy";
                break;
              case 4u:
                v182 = "fallback";
                break;
              case 5u:
                v182 = "transform";
                break;
              default:
                v182 = "unknown-mode";
                break;
            }

            v183 = v148;
            v184 = v180;
            v185 = v181;
            os_unfair_lock_lock(lock);
            v186 = v367->current_path;
            os_unfair_lock_unlock(lock);

            v187 = v184;
            v148 = v183;
            v188 = v186;
            v189 = nw_endpoint_get_logging_description(v354);
            *(_DWORD *)buf = 136448002;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v367->id_str;
            *(_WORD *)&buf[22] = 2082;
            v379 = v175;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = v176;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v187;
            v381 = 2082;
            v382 = v182;
            v383 = 2114;
            v384 = v188;
            v385 = 2082;
            v386 = v189;
            _os_log_impl(&dword_182FBE000, v171, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Keeping started endpoint %{public}s", buf, 0x52u);

          }
        }
LABEL_196:
        v151 = log;
LABEL_197:

        goto LABEL_198;
      }
LABEL_226:
      objc_storeStrong((id *)location, (id)obj);
      v209 = *location;
      if (*location)
        v209 = (uint64_t)(*(_QWORD *)(v209 + 24) - *(_QWORD *)(v209 + 16)) >> 3;
      v210 = v367;
      *((_DWORD *)v363 + 5) = v209;
      if (object)
      {
        v211 = *((_QWORD *)object + 3) - *((_QWORD *)object + 2);
        if (v211)
        {
          v212 = 0;
          v213 = v211 >> 3;
          locka = &v367->lock;
          v349 = v211 >> 3;
          while (1)
          {
            nw_array_get_object_at_index((uint64_t)object, v212);
            v214 = (void *)objc_claimAutoreleasedReturnValue();
            child_parameters = nw_endpoint_resolver_create_child_parameters(v210);
            if (nw_endpoint_get_is_approved_app_domain(v214))
              nw_parameters_set_is_approved_app_domain((void *)child_parameters);
            inner = nw_endpoint_handler_create_inner(v214, (void *)child_parameters, nw_endpoint_resolver_receive_report, v210, v210, 0, 0);
            if (!inner)
              goto LABEL_257;
            if (nw_endpoint_handler_get_minimize_logging(v210))
              break;
            v217 = v210;
            v218 = (*((_BYTE *)v210 + 268) & 0x20) == 0;

            if (v218)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v219 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT))
              {
                loga = v219;
                v220 = v217;

                v221 = v220;
                v222 = (*((_BYTE *)v367 + 268) & 1) == 0;

                if (v222)
                  v223 = "";
                else
                  v223 = "dry-run ";
                v359 = nw_endpoint_handler_copy_endpoint(v221);
                v224 = nw_endpoint_get_logging_description(v359);
                v355 = v223;
                v225 = v221;
                v226 = v225;
                v227 = v351->state;
                v228 = "unknown-state";
                if (v227 <= 5)
                  v228 = off_1E149FC48[v227];

                v229 = v226;
                v230 = "path";
                switch(v347[29])
                {
                  case 0u:
                    break;
                  case 1u:
                    v230 = "resolver";
                    break;
                  case 2u:
                    v230 = nw_endpoint_flow_mode_string(v367->mode_handler);
                    break;
                  case 3u:
                    v230 = "proxy";
                    break;
                  case 4u:
                    v230 = "fallback";
                    break;
                  case 5u:
                    v230 = "transform";
                    break;
                  default:
                    v230 = "unknown-mode";
                    break;
                }

                v231 = v229;
                os_unfair_lock_lock(locka);
                v232 = v367->current_path;
                v213 = v349;
                os_unfair_lock_unlock(locka);

                v233 = v232;
                v234 = nw_endpoint_get_logging_description(v214);
                is_known_tracker = nw_parameters_get_is_known_tracker((void *)child_parameters);
                *(_DWORD *)buf = 136448258;
                v236 = "";
                if (is_known_tracker)
                  v236 = ", tracker";
                *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v367->id_str;
                *(_WORD *)&buf[22] = 2082;
                v379 = v355;
                *(_WORD *)v380 = 2082;
                *(_QWORD *)&v380[2] = v224;
                *(_WORD *)&v380[10] = 2082;
                *(_QWORD *)&v380[12] = v228;
                v381 = 2082;
                v382 = v230;
                v383 = 2114;
                v384 = v233;
                v385 = 2082;
                v386 = v234;
                v387 = 2080;
                v388 = v236;
                _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding endpoint handler for %{public}s%s", buf, 0x5Cu);

                goto LABEL_254;
              }
              goto LABEL_255;
            }
LABEL_256:
            nw_array_append(*location, inner);
LABEL_257:

            ++v212;
            v210 = v367;
            if (v213 == v212)
              goto LABEL_267;
          }
          if ((nw_endpoint_handler_get_logging_disabled(v210) & 1) != 0)
            goto LABEL_256;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          loga = (id)gconnectionLogObj;
          if (os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG))
          {
            v237 = nw_endpoint_handler_get_id_string(v367);
            v356 = nw_endpoint_handler_dry_run_string(v367);
            v360 = nw_endpoint_handler_copy_endpoint(v367);
            v343 = nw_endpoint_get_logging_description(v360);
            v238 = nw_endpoint_handler_state_string(v367);
            v239 = nw_endpoint_handler_mode_string(v367);
            v240 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
            v241 = nw_endpoint_get_logging_description(v214);
            v242 = nw_parameters_get_is_known_tracker((void *)child_parameters);
            *(_DWORD *)buf = 136448258;
            v243 = "";
            if (v242)
              v243 = ", tracker";
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v237;
            *(_WORD *)&buf[22] = 2082;
            v379 = v356;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = v343;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v238;
            v381 = 2082;
            v382 = v239;
            v383 = 2114;
            v384 = v240;
            v385 = 2082;
            v386 = v241;
            v387 = 2080;
            v388 = v243;
            _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding endpoint handler for %{public}s%s", buf, 0x5Cu);

            v213 = v349;
          }
          else
          {
            v213 = v349;
          }
LABEL_254:
          v219 = loga;
LABEL_255:

          goto LABEL_256;
        }
      }
LABEL_267:
      __nwlog_obj();
      v244 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v244, OS_LOG_TYPE_DEBUG))
      {

        v245 = v367;
        v246 = (_QWORD *)&unk_183BA7000;
      }
      else
      {
        v247 = gLogFDOverride == -1;

        v245 = v367;
        v246 = &unk_183BA7000;
        if (v247)
          goto LABEL_279;
      }
      v376[0] = 0;
      v376[1] = v376;
      v376[2] = 0x2020000000;
      v377 = 1;
      v372 = 0;
      v373 = &v372;
      v374 = 0x2020000000;
      v375 = 0;
      asprintf(&v375, "", v336, v337);
      v248 = (unsigned __int8 *)*location;
      v371[0] = MEMORY[0x1E0C809B0];
      v371[1] = v246[190];
      v371[2] = ___ZL27nw_endpoint_resolver_updateP30NWConcrete_nw_endpoint_handlerPU25objcproto14OS_nw_resolver8NSObject20nw_resolver_status_t_block_invoke;
      v371[3] = &unk_1E14A8FF0;
      v371[4] = &v372;
      v371[5] = v376;
      nw_array_apply(v248, (uint64_t)v371);
      if ((nw_endpoint_handler_get_logging_disabled(v245) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v249 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v249, OS_LOG_TYPE_DEBUG))
        {
          v250 = nw_endpoint_handler_get_id_string(v367);
          v251 = nw_endpoint_handler_dry_run_string(v367);
          v252 = nw_endpoint_handler_copy_endpoint(v367);
          v253 = nw_endpoint_get_logging_description(v252);
          v254 = nw_endpoint_handler_state_string(v367);
          v255 = nw_endpoint_handler_mode_string(v367);
          v256 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
          v257 = (const char *)v373[3];
          *(_DWORD *)buf = 136448002;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v250;
          *(_WORD *)&buf[22] = 2082;
          v379 = v251;
          *(_WORD *)v380 = 2082;
          *(_QWORD *)&v380[2] = v253;
          *(_WORD *)&v380[10] = 2082;
          *(_QWORD *)&v380[12] = v254;
          v381 = 2082;
          v382 = v255;
          v383 = 2114;
          v384 = v256;
          v385 = 2082;
          v386 = v257;
          _os_log_impl(&dword_182FBE000, v249, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Updated endpoint list is (%{public}s)", buf, 0x52u);

        }
        v245 = v367;
      }
      v258 = (void *)v373[3];
      if (v258)
      {
        free(v258);
        v373[3] = 0;
      }
      _Block_object_dispose(&v372, 8);
      _Block_object_dispose(v376, 8);
LABEL_279:
      v259 = nw_endpoint_handler_copy_endpoint(v245);
      v260 = nw_endpoint_get_type(v259);
      if (v260 == (nw_endpoint_type_url|nw_endpoint_type_address))
        v261 = 7;
      else
        v261 = 2;
      if (v260 == nw_endpoint_type_bonjour_service)
        v262 = 4;
      else
        v262 = v261;

      v263 = *location;
      if (*location)
      {
        v266 = v263 + 16;
        v264 = *(_QWORD *)(v263 + 16);
        v265 = *(_QWORD *)(v266 + 8);
        v267 = v265 - v264;
        if (v265 != v264)
        {
          v268 = v367;
          v367->event.domain = 2;
          v367->event.event = v262;
          nw_endpoint_handler_report(v367, 0, &v367->event.domain, 0);
          v269 = *((_QWORD *)v363 + 6);
          if (v269)
            v269 = (uint64_t)(*(_QWORD *)(v269 + 24) - *(_QWORD *)(v269 + 16)) >> 3;
          if (v339 == 2 && v267 >> 3 == v269)
          {
            minimize_logging = nw_endpoint_handler_get_minimize_logging(v367);
            logging_disabled = nw_endpoint_handler_get_logging_disabled(v367);
            if (minimize_logging)
            {
              if ((logging_disabled & 1) != 0)
                goto LABEL_298;
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v272 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v272, OS_LOG_TYPE_DEBUG))
              {
                v315 = nw_endpoint_handler_get_id_string(v367);
                v316 = nw_endpoint_handler_dry_run_string(v367);
                v317 = nw_endpoint_handler_copy_endpoint(v367);
                v318 = nw_endpoint_get_logging_description(v317);
                v319 = nw_endpoint_handler_state_string(v367);
                v320 = nw_endpoint_handler_mode_string(v367);
                v321 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
                *(_DWORD *)buf = 136447746;
                *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v315;
                *(_WORD *)&buf[22] = 2082;
                v379 = v316;
                *(_WORD *)v380 = 2082;
                *(_QWORD *)&v380[2] = v318;
                *(_WORD *)&v380[10] = 2082;
                *(_QWORD *)&v380[12] = v319;
                v381 = 2082;
                v382 = v320;
                v383 = 2114;
                v384 = v321;
                _os_log_impl(&dword_182FBE000, v272, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolver complete, all children failed", buf, 0x48u);

              }
            }
            else
            {
              if ((logging_disabled & 1) != 0)
              {
LABEL_298:
                nw_endpoint_handler_handle_failure(v268);
                v268->event = (nw_endpoint_handler_event_s)327682;
                nw_endpoint_handler_report(v268, 0, &v367->event.domain, 0);
LABEL_332:

                goto LABEL_333;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v272 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v272, OS_LOG_TYPE_INFO))
              {
                v273 = nw_endpoint_handler_get_id_string(v367);
                v274 = nw_endpoint_handler_dry_run_string(v367);
                v275 = nw_endpoint_handler_copy_endpoint(v367);
                v276 = nw_endpoint_get_logging_description(v275);
                v277 = nw_endpoint_handler_state_string(v367);
                v278 = nw_endpoint_handler_mode_string(v367);
                v279 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
                *(_DWORD *)buf = 136447746;
                *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v273;
                *(_WORD *)&buf[22] = 2082;
                v379 = v274;
                *(_WORD *)v380 = 2082;
                *(_QWORD *)&v380[2] = v276;
                *(_WORD *)&v380[10] = 2082;
                *(_QWORD *)&v380[12] = v277;
                v381 = 2082;
                v382 = v278;
                v383 = 2114;
                v384 = v279;
                _os_log_impl(&dword_182FBE000, v272, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolver complete, all children failed", buf, 0x48u);

              }
            }

            v268 = v367;
            goto LABEL_298;
          }
          v293 = *((unsigned int *)v363 + 5);
          if ((_DWORD)v293 && v269 != v293 && (*((_BYTE *)v363 + 24) & 2) == 0)
            goto LABEL_332;
          v294 = nw_endpoint_handler_copy_context(v367);
          v369[0] = MEMORY[0x1E0C809B0];
          v369[1] = 3221225472;
          v369[2] = ___ZL27nw_endpoint_resolver_updateP30NWConcrete_nw_endpoint_handlerPU25objcproto14OS_nw_resolver8NSObject20nw_resolver_status_t_block_invoke_105;
          v369[3] = &unk_1E14ACFD0;
          v370 = v367;
          nw_queue_context_async(v294, v369);

          dns_error = v370;
LABEL_331:

          goto LABEL_332;
        }
      }
      v280 = v367;
      if (v339 != 2)
        goto LABEL_332;
      if (nw_endpoint_handler_trigger_agents(v367, 1))
      {
        v281 = nw_endpoint_handler_get_minimize_logging(v367);
        v282 = nw_endpoint_handler_get_logging_disabled(v367);
        if (v281)
        {
          if ((v282 & 1) != 0)
            goto LABEL_308;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v283 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v283, OS_LOG_TYPE_DEBUG))
          {
            v322 = nw_endpoint_handler_get_id_string(v367);
            v323 = nw_endpoint_handler_dry_run_string(v367);
            v324 = nw_endpoint_handler_copy_endpoint(v367);
            v325 = nw_endpoint_get_logging_description(v324);
            v326 = nw_endpoint_handler_state_string(v367);
            v327 = nw_endpoint_handler_mode_string(v367);
            v328 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v322;
            *(_WORD *)&buf[22] = 2082;
            v379 = v323;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = v325;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v326;
            v381 = 2082;
            v382 = v327;
            v383 = 2114;
            v384 = v328;
            _os_log_impl(&dword_182FBE000, v283, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolution failed, trying to trigger voluntary agents", buf, 0x48u);

          }
        }
        else
        {
          if ((v282 & 1) != 0)
          {
LABEL_308:
            nw_endpoint_handler_reset_mode(v280, 0);
            goto LABEL_332;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v283 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v283, OS_LOG_TYPE_INFO))
          {
            v284 = nw_endpoint_handler_get_id_string(v367);
            v285 = nw_endpoint_handler_dry_run_string(v367);
            v286 = nw_endpoint_handler_copy_endpoint(v367);
            v287 = nw_endpoint_get_logging_description(v286);
            v288 = nw_endpoint_handler_state_string(v367);
            v289 = nw_endpoint_handler_mode_string(v367);
            v290 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v284;
            *(_WORD *)&buf[22] = 2082;
            v379 = v285;
            *(_WORD *)v380 = 2082;
            *(_QWORD *)&v380[2] = v287;
            *(_WORD *)&v380[10] = 2082;
            *(_QWORD *)&v380[12] = v288;
            v381 = 2082;
            v382 = v289;
            v383 = 2114;
            v384 = v290;
            _os_log_impl(&dword_182FBE000, v283, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolution failed, trying to trigger voluntary agents", buf, 0x48u);

          }
        }

        v280 = v367;
        goto LABEL_308;
      }
      v296 = nw_endpoint_handler_copy_current_path(v367);
      nw_path_trigger_inactive_cellular_agent_if_necessary(v296);

      v297 = v367;
      LODWORD(v296) = nw_endpoint_handler_get_minimize_logging(v367);
      v298 = nw_endpoint_handler_get_logging_disabled(v367);
      if ((_DWORD)v296)
      {
        if ((v298 & 1) != 0)
          goto LABEL_327;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v299 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v299, OS_LOG_TYPE_DEBUG))
        {
          v329 = nw_endpoint_handler_get_id_string(v367);
          v330 = nw_endpoint_handler_dry_run_string(v367);
          v331 = nw_endpoint_handler_copy_endpoint(v367);
          v332 = nw_endpoint_get_logging_description(v331);
          v333 = nw_endpoint_handler_state_string(v367);
          v334 = nw_endpoint_handler_mode_string(v367);
          v335 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v329;
          *(_WORD *)&buf[22] = 2082;
          v379 = v330;
          *(_WORD *)v380 = 2082;
          *(_QWORD *)&v380[2] = v332;
          *(_WORD *)&v380[10] = 2082;
          *(_QWORD *)&v380[12] = v333;
          v381 = 2082;
          v382 = v334;
          v383 = 2114;
          v384 = v335;
          _os_log_impl(&dword_182FBE000, v299, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolution failed", buf, 0x48u);

        }
      }
      else
      {
        if ((v298 & 1) != 0)
        {
LABEL_327:
          error = nw_resolver_get_error(*((void **)v363 + 1));
          if (error)
            dns_error = nw_error_create_dns_error(error);
          else
            dns_error = 0;
          nw_endpoint_handler_handle_failure(v297);
          v297->event.domain = 2;
          v297->event.event = v262;
          nw_endpoint_handler_report(v297, 0, &v297->event.domain, dns_error);
          goto LABEL_331;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v299 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v299, OS_LOG_TYPE_INFO))
        {
          v300 = nw_endpoint_handler_get_id_string(v367);
          v301 = nw_endpoint_handler_dry_run_string(v367);
          v302 = nw_endpoint_handler_copy_endpoint(v367);
          v303 = nw_endpoint_get_logging_description(v302);
          v304 = nw_endpoint_handler_state_string(v367);
          v305 = nw_endpoint_handler_mode_string(v367);
          v306 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v367);
          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v300;
          *(_WORD *)&buf[22] = 2082;
          v379 = v301;
          *(_WORD *)v380 = 2082;
          *(_QWORD *)&v380[2] = v303;
          *(_WORD *)&v380[10] = 2082;
          *(_QWORD *)&v380[12] = v304;
          v381 = 2082;
          v382 = v305;
          v383 = 2114;
          v384 = v306;
          _os_log_impl(&dword_182FBE000, v299, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] resolution failed", buf, 0x48u);

        }
      }

      v297 = v367;
      goto LABEL_327;
    }
    v338 = a3;
    __nwlog_obj();
    v94 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_parameters_get_fail_if_svcb_received";
    v337 = 12;
    v336 = buf;
    v95 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v376[0]) = 16;
    LOBYTE(v372) = 0;
    if (__nwlog_fault(v95, v376, &v372))
    {
      if (LOBYTE(v376[0]) == 17)
      {
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v97 = v376[0];
        if (os_log_type_enabled(v96, v376[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_get_fail_if_svcb_received";
          _os_log_impl(&dword_182FBE000, v96, v97, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if ((_BYTE)v372)
      {
        v98 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v99 = v376[0];
        v100 = os_log_type_enabled(v96, v376[0]);
        if (v98)
        {
          if (v100)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_parameters_get_fail_if_svcb_received";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v98;
            _os_log_impl(&dword_182FBE000, v96, v99, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v98);
          goto LABEL_117;
        }
        if (v100)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_get_fail_if_svcb_received";
          _os_log_impl(&dword_182FBE000, v96, v99, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v96 = objc_claimAutoreleasedReturnValue();
        v108 = v376[0];
        if (os_log_type_enabled(v96, v376[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_parameters_get_fail_if_svcb_received";
          _os_log_impl(&dword_182FBE000, v96, v108, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_117:
    if (v95)
      free(v95);
    a3 = v338;
    goto LABEL_120;
  }
  if (nw_endpoint_handler_get_minimize_logging(v9))
  {
    if ((nw_endpoint_handler_get_logging_disabled(v9) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v78 = nw_endpoint_handler_get_id_string(v9);
        v79 = nw_endpoint_handler_dry_run_string(v9);
        v352 = v9;
        v80 = nw_endpoint_handler_copy_endpoint(v9);
        v81 = nw_endpoint_get_logging_description(v80);
        v82 = nw_endpoint_handler_state_string(v352);
        v83 = nw_endpoint_handler_mode_string(v352);
        v84 = (OS_nw_path *)nw_endpoint_handler_copy_current_path(v352);
        *(_DWORD *)buf = 136447746;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v78;
        *(_WORD *)&buf[22] = 2082;
        v379 = v79;
        *(_WORD *)v380 = 2082;
        *(_QWORD *)&v380[2] = v81;
        *(_WORD *)&v380[10] = 2082;
        *(_QWORD *)&v380[12] = v82;
        v381 = 2082;
        v382 = v83;
        v383 = 2114;
        v384 = v84;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring resolver update", buf, 0x48u);

      }
      goto LABEL_82;
    }
  }
  else
  {
    v11 = v9;
    v12 = *((_BYTE *)v11 + 268);

    if ((v12 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v13 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v14 = v11;

        v15 = v14;
        v16 = *((_BYTE *)v11 + 268);

        if ((v16 & 1) != 0)
          v17 = "dry-run ";
        else
          v17 = "";
        v18 = nw_endpoint_handler_copy_endpoint(v15);
        v19 = nw_endpoint_get_logging_description(v18);
        v365 = v6;
        v20 = v14->id_str;
        v21 = v15;
        v22 = v21;
        v23 = v9->state;
        if (v23 > 5)
          v24 = "unknown-state";
        else
          v24 = off_1E149FC48[v23];

        v60 = v22;
        v61 = v60;
        v62 = "path";
        switch(v7[29])
        {
          case 0u:
            break;
          case 1u:
            v62 = "resolver";
            break;
          case 2u:
            v62 = nw_endpoint_flow_mode_string(v60[31]);
            break;
          case 3u:
            v62 = "proxy";
            break;
          case 4u:
            v62 = "fallback";
            break;
          case 5u:
            v62 = "transform";
            break;
          default:
            v62 = "unknown-mode";
            break;
        }

        v66 = v61;
        os_unfair_lock_lock((os_unfair_lock_t)v66 + 28);
        v67 = v66[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v66 + 28);

        *(_DWORD *)buf = 136447746;
        *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v20;
        *(_WORD *)&buf[22] = 2082;
        v379 = v17;
        *(_WORD *)v380 = 2082;
        *(_QWORD *)&v380[2] = v19;
        *(_WORD *)&v380[10] = 2082;
        *(_QWORD *)&v380[12] = v24;
        v381 = 2082;
        v382 = v62;
        v383 = 2114;
        v384 = v67;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ignoring resolver update", buf, 0x48u);

        v6 = v365;
      }
LABEL_82:

    }
  }
LABEL_337:

}

void sub_183108B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,_Unwind_Exception *exception_object,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  void *v49;
  void *v50;
  void *v51;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_is_known_tracker(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 108) >> 14) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_is_known_tracker";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_is_known_tracker";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_is_known_tracker";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_is_known_tracker";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_is_known_tracker";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_endpoint_get_is_approved_app_domain(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[231] >> 6) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_get_is_approved_app_domain";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_is_approved_app_domain";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_get_is_approved_app_domain";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_is_approved_app_domain";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_get_is_approved_app_domain";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_endpoint_handler_copy_context(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[5];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_endpoint_handler_copy_context";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_endpoint_handler_copy_context";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_endpoint_handler_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_resolver_get_error(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t os_unfair_lock_opaque;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    os_unfair_lock_opaque = v2[21]._os_unfair_lock_opaque;
    if (!(_DWORD)os_unfair_lock_opaque)
    {
      if (v2[2]._os_unfair_lock_opaque == 2
        && nw_endpoint_get_type(*(nw_endpoint_t *)&v2[6]._os_unfair_lock_opaque) == nw_endpoint_type_host
        && ((v4 = *(_QWORD *)&v2[36]._os_unfair_lock_opaque) == 0 || *(_QWORD *)(v4 + 24) == *(_QWORD *)(v4 + 16))
        && (v2[86]._os_unfair_lock_opaque & 0x100000) == 0
        && (~LOWORD(v2[22]._os_unfair_lock_opaque) & 0xC00) != 0)
      {
        os_unfair_lock_opaque = 4294901742;
      }
      else
      {
        os_unfair_lock_opaque = 0;
      }
    }
    os_unfair_lock_unlock(v2 + 3);
    goto LABEL_11;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_resolver_get_error";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_resolver_get_error";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_resolver_get_error";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_resolver_get_error";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_resolver_get_error";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_29:
  if (v7)
    free(v7);
  os_unfair_lock_opaque = 0;
LABEL_11:

  return os_unfair_lock_opaque;
}

void sub_183109A6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_path_trigger_inactive_cellular_agent_if_necessary(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  _BOOL8 v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD applier[4];
  id v15;
  _BYTE *v16;
  char v17;
  os_log_type_t type;
  _BYTE buf[24];
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_path_trigger_inactive_cellular_agent_if_necessary";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_trigger_inactive_cellular_agent_if_necessary";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_path_trigger_inactive_cellular_agent_if_necessary";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_trigger_inactive_cellular_agent_if_necessary";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_trigger_inactive_cellular_agent_if_necessary";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_24:
    if (v6)
      free(v6);
    goto LABEL_26;
  }
  if (*((_DWORD *)v1 + 94) != 2 || *((_DWORD *)v1 + 95) != 3)
  {
LABEL_26:
    v4 = 0;
    goto LABEL_27;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2020000000;
  v20 = 0;
  v3 = (void *)*((_QWORD *)v1 + 28);
  if (v3)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = __nw_path_trigger_inactive_cellular_agent_if_necessary_block_invoke;
    applier[3] = &unk_1E14A8EB0;
    v15 = v1;
    v16 = buf;
    xpc_dictionary_apply(v3, applier);

    v4 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
  }
  else
  {
    v4 = 0;
  }
  _Block_object_dispose(buf, 8);
LABEL_27:

  return v4;
}

void sub_183109DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

_DWORD *nw_error_create_dns_error(int a1)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
    return -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 2, a1);
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_error_create_dns_error";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_error_create_dns_error";
        v6 = "%{public}s called with null dns_error";
LABEL_16:
        _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
      }
    }
    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v4 = objc_claimAutoreleasedReturnValue();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)buf = 136446466;
            v12 = "nw_error_create_dns_error";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null dns_error, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }
        if (!v8)
          goto LABEL_17;
        *(_DWORD *)buf = 136446210;
        v12 = "nw_error_create_dns_error";
        v6 = "%{public}s called with null dns_error, no backtrace";
        goto LABEL_16;
      }
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_error_create_dns_error";
        v6 = "%{public}s called with null dns_error, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
LABEL_17:

  }
LABEL_18:
  if (v3)
    free(v3);
  return 0;
}

uint64_t __nw_establishment_report_create_from_dictionary_block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  Class Class;
  objc_class *v6;
  NWConcrete_nw_resolution_report *v7;
  id v8;
  id v9;
  xpc_object_t value;
  void *v12;
  NSObject *v13;
  OS_nw_endpoint *successful_endpoint;
  xpc_object_t v15;
  void *v16;
  NSObject *v17;
  OS_nw_endpoint *preferred_endpoint;

  v4 = a3;
  Class = object_getClass(v4);
  v6 = (objc_class *)MEMORY[0x1E0C812F8];
  if (Class == (Class)MEMORY[0x1E0C812F8])
  {
    v7 = objc_alloc_init(NWConcrete_nw_resolution_report);
    v7->milliseconds = xpc_dictionary_get_uint64(v4, "milliseconds");
    if (!v4)
      goto LABEL_6;
    if (object_getClass(v4) == v6
      && (value = xpc_dictionary_get_value(v4, "successful_endpoint")) != 0
      && (v12 = value, object_getClass(value) == v6))
    {
      v8 = v12;
      v13 = nw_endpoint_create_from_dictionary(v8);
      successful_endpoint = v7->successful_endpoint;
      v7->successful_endpoint = (OS_nw_endpoint *)v13;

    }
    else
    {
      v8 = 0;
    }

    if (object_getClass(v4) == v6
      && (v15 = xpc_dictionary_get_value(v4, "preferred_endpoint")) != 0
      && (v16 = v15, object_getClass(v15) == v6))
    {
      v9 = v16;
      v17 = nw_endpoint_create_from_dictionary(v9);
      preferred_endpoint = v7->preferred_endpoint;
      v7->preferred_endpoint = (OS_nw_endpoint *)v17;

    }
    else
    {
LABEL_6:
      v9 = 0;
    }

    v7->endpoint_count = xpc_dictionary_get_uint64(v4, "endpoint_count");
    v7->source = xpc_dictionary_get_uint64(v4, "source");
    nw_array_append(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 72), v7);

  }
  return 1;
}

void sub_18310AE2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_copy_dictionary_block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int *v4;
  xpc_object_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;

  v4 = a3;
  v5 = xpc_dictionary_create(0, 0, 0);
  v6 = v5;
  v7 = *((_QWORD *)v4 + 1);
  if (v7)
    xpc_dictionary_set_uint64(v5, "milliseconds", v7);
  v8 = (void *)objc_msgSend(*((id *)v4 + 4), "copyDictionary");
  if (v8)
    xpc_dictionary_set_value(v6, "successful_endpoint", v8);

  v9 = (void *)objc_msgSend(*((id *)v4 + 5), "copyDictionary");
  if (v9)
    xpc_dictionary_set_value(v6, "preferred_endpoint", v9);

  v10 = v4[14];
  if ((_DWORD)v10)
    xpc_dictionary_set_uint64(v6, "endpoint_count", v10);
  v11 = v4[15];
  if ((_DWORD)v11)
    xpc_dictionary_set_uint64(v6, "source", v11);
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), v6);

  return 1;
}

void sub_18310AF54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_18310AF84()
{
  JUMPOUT(0x18310AF74);
}

NSObject *nw_endpoint_create_from_dictionary(void *a1)
{
  id v1;
  void *v2;
  uint64_t uint64;
  const sockaddr *data;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *string;
  unsigned int v10;
  nw_endpoint_t address;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  nw_endpoint_t v17;
  const uint8_t *v18;
  Class Class;
  objc_class *v20;
  void *v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  xpc_object_t value;
  xpc_object_t v27;
  id v28;
  NWConcrete_nw_interface *v29;
  Class isa;
  uint64_t v31;
  Class v32;
  const char *v33;
  const uint8_t *v34;
  nw_txt_record_t v35;
  Class v36;
  void *v37;
  NSObject *v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  id v42;
  const char *v43;
  const char *v44;
  const uint8_t *uuid;
  const char *v46;
  const char *v47;
  int int64;
  int v49;
  const char *v50;
  _BOOL8 v51;
  NSObject *v52;
  id v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  NSObject *v57;
  os_log_type_t v58;
  os_log_type_t v59;
  id v60;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  const char *v64;
  char *v65;
  NSObject *v66;
  os_log_type_t v67;
  os_log_type_t v68;
  char *v69;
  os_log_type_t v70;
  _BOOL4 v71;
  os_log_type_t v72;
  os_log_type_t v73;
  os_log_type_t v75;
  os_log_type_t v76;
  void *v77;
  NSObject *v78;
  os_log_type_t v79;
  os_log_type_t v80;
  _BOOL4 v81;
  os_log_type_t v82;
  _QWORD applier[4];
  NSObject *v84;
  char v85;
  os_log_type_t type;
  _BYTE buf[12];
  __int16 v88;
  char *v89;
  __int16 v90;
  char *v91;
  size_t length[3];
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v77 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
    v23 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(length[0]) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v23, length, &type))
    {
      if (LOBYTE(length[0]) == 17)
      {
        __nwlog_obj();
        v78 = objc_claimAutoreleasedReturnValue();
        v79 = length[0];
        if (os_log_type_enabled(v78, length[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s called with null dictionary", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v78 = objc_claimAutoreleasedReturnValue();
        v80 = length[0];
        v81 = os_log_type_enabled(v78, length[0]);
        if (backtrace_string)
        {
          if (v81)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
            v88 = 2082;
            v89 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v78, v80, "%{public}s called with null dictionary, dumping backtrace:%{public}s", buf, 0x16u);
          }

          goto LABEL_55;
        }
        if (v81)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v78, v80, "%{public}s called with null dictionary, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v78 = objc_claimAutoreleasedReturnValue();
        v82 = length[0];
        if (os_log_type_enabled(v78, length[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v78, v82, "%{public}s called with null dictionary, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_90:
    if (!v23)
    {
LABEL_92:
      v38 = 0;
      goto LABEL_93;
    }
LABEL_91:
    free(v23);
    goto LABEL_92;
  }
  uint64 = xpc_dictionary_get_uint64(v1, "type");
  switch(uint64)
  {
    case 1uLL:
      length[0] = 0;
      data = (const sockaddr *)xpc_dictionary_get_data(v2, "address", length);
      if (data && length[0] >= 2 && length[0] >= data->sa_len)
      {
        address = nw_endpoint_create_address(data);
        goto LABEL_15;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v85 = 0;
      if (!__nwlog_fault(v6, &type, &v85))
        goto LABEL_97;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s invalid sockaddr in dictionary", buf, 0xCu);
        }
      }
      else if (v85)
      {
        v64 = __nw_create_backtrace_string();
        if (v64)
        {
          v65 = (char *)v64;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v66 = (id)gLogObj;
          v67 = type;
          if (os_log_type_enabled(v66, type))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
            v88 = 2082;
            v89 = v65;
            _os_log_impl(&dword_182FBE000, v66, v67, "%{public}s invalid sockaddr in dictionary, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v65);
          if (!v6)
            goto LABEL_99;
          goto LABEL_98;
        }
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v75 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v7, v75, "%{public}s invalid sockaddr in dictionary, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v72 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          _os_log_impl(&dword_182FBE000, v7, v72, "%{public}s invalid sockaddr in dictionary, backtrace limit exceeded", buf, 0xCu);
        }
      }

LABEL_97:
      if (!v6)
      {
LABEL_99:
        v17 = 0;
        goto LABEL_16;
      }
LABEL_98:
      free(v6);
      goto LABEL_99;
    case 2uLL:
      string = xpc_dictionary_get_string(v2, "hostname");
      v10 = xpc_dictionary_get_uint64(v2, "port");
      address = (nw_endpoint_t)nw_endpoint_create_host_with_numeric_port(string, bswap32(v10) >> 16);
      goto LABEL_15;
    case 3uLL:
      v12 = xpc_dictionary_get_string(v2, "bonjour_name");
      v13 = xpc_dictionary_get_string(v2, "bonjour_type");
      v14 = xpc_dictionary_get_string(v2, "bonjour_domain");
      address = nw_endpoint_create_bonjour_service(v12, v13, v14);
      goto LABEL_15;
    case 4uLL:
      v15 = xpc_dictionary_get_string(v2, "url");
      address = nw_endpoint_create_url(v15);
      goto LABEL_15;
    case 5uLL:
      v16 = xpc_dictionary_get_string(v2, "srv_name");
      address = (nw_endpoint_t)nw_endpoint_create_srv(v16);
LABEL_15:
      v17 = address;
      goto LABEL_16;
    case 6uLL:
      v42 = v2;
      v43 = xpc_dictionary_get_string(v42, "application_service_name");
      v44 = xpc_dictionary_get_string(v42, "application_service_alias");
      uuid = xpc_dictionary_get_uuid(v42, "service_identifier");
      length[0] = 0;
      length[1] = 0;
      if (uuid)
        *(_OWORD *)length = *(_OWORD *)uuid;
      v46 = xpc_dictionary_get_string(v42, "device_name");
      v47 = xpc_dictionary_get_string(v42, "device_model");
      int64 = xpc_dictionary_get_int64(v42, "device_color");
      v49 = xpc_dictionary_get_int64(v42, "route");
      v50 = xpc_dictionary_get_string(v42, "contact_id");
      v51 = -[NWConcrete_nw_application_service_endpoint initWithApplicationService:alias:serviceUUID:deviceName:deviceModel:contactID:]([NWConcrete_nw_application_service_endpoint alloc], v43, v44, (const unsigned __int8 *)length, v46, v47, v50);
      v17 = (nw_endpoint_t)v51;
      if (v51)
      {
        nw_endpoint_set_device_color((void *)v51, int64);
        nw_endpoint_set_advertised_route(v17, v49);
        v52 = v17;
        goto LABEL_108;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v60 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_endpoint_create_application_service_from_dictionary";
      v61 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v85 = 0;
      if ((__nwlog_fault(v61, &type, &v85) & 1) == 0)
        goto LABEL_106;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v62 = (id)gLogObj;
        v63 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_application_service_from_dictionary";
          _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s NWOSApplicationServiceEndpoint alloc/init failed", buf, 0xCu);
        }
LABEL_105:

LABEL_106:
        if (v61)
          goto LABEL_107;
        goto LABEL_108;
      }
      if (!v85)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v62 = (id)gLogObj;
        v76 = type;
        if (os_log_type_enabled(v62, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_application_service_from_dictionary";
          _os_log_impl(&dword_182FBE000, v62, v76, "%{public}s NWOSApplicationServiceEndpoint alloc/init failed, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_105;
      }
      v69 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v62 = (id)gLogObj;
      v70 = type;
      v71 = os_log_type_enabled(v62, type);
      if (!v69)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_application_service_from_dictionary";
          _os_log_impl(&dword_182FBE000, v62, v70, "%{public}s NWOSApplicationServiceEndpoint alloc/init failed, no backtrace", buf, 0xCu);
        }
        goto LABEL_105;
      }
      if (v71)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_endpoint_create_application_service_from_dictionary";
        v88 = 2082;
        v89 = v69;
        _os_log_impl(&dword_182FBE000, v62, v70, "%{public}s NWOSApplicationServiceEndpoint alloc/init failed, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v69);
      if (v61)
LABEL_107:
        free(v61);
LABEL_108:

LABEL_16:
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
        v23 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(length[0]) = 16;
        type = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v23, length, &type))
          goto LABEL_90;
        if (LOBYTE(length[0]) == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = (id)gLogObj;
          v25 = length[0];
          if (os_log_type_enabled(v24, length[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
            _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s invalid dictionary", buf, 0xCu);
          }
LABEL_73:

          goto LABEL_90;
        }
        if (type == OS_LOG_TYPE_DEFAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = (id)gLogObj;
          v59 = length[0];
          if (os_log_type_enabled(v24, length[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
            _os_log_impl(&dword_182FBE000, v24, v59, "%{public}s invalid dictionary, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_73;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v40 = length[0];
        v41 = os_log_type_enabled(v24, length[0]);
        if (!backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
            _os_log_impl(&dword_182FBE000, v24, v40, "%{public}s invalid dictionary, no backtrace", buf, 0xCu);
          }
          goto LABEL_73;
        }
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          v88 = 2082;
          v89 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v24, v40, "%{public}s invalid dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }

LABEL_55:
        free(backtrace_string);
        if (!v23)
          goto LABEL_92;
        goto LABEL_91;
      }
      HIBYTE(v17[28].isa) = HIBYTE(v17[28].isa) & 0xFE | xpc_dictionary_get_BOOL(v2, "is_local_domain");
      v18 = xpc_dictionary_get_uuid(v2, "agent_identifier");
      if (v18)
        *(_OWORD *)((char *)&v17[3].isa + 4) = *(_OWORD *)v18;
      Class = object_getClass(v2);
      v20 = (objc_class *)MEMORY[0x1E0C812F8];
      if (Class == (Class)MEMORY[0x1E0C812F8] && (value = xpc_dictionary_get_value(v2, "interface")) != 0)
      {
        v27 = value;
        if (object_getClass(value) == v20)
          v21 = v27;
        else
          v21 = 0;
      }
      else
      {
        v21 = 0;
      }
      v28 = v21;
      v29 = nw_interface_create_from_dictionary(v28);
      isa = v17[2].isa;
      v17[2].isa = (Class)v29;

      WORD2(v17[28].isa) = xpc_dictionary_get_uint64(v2, "alternate_port");
      xpc_dictionary_get_value(v2, "signature");
      v31 = objc_claimAutoreleasedReturnValue();
      v32 = v17[24].isa;
      v17[24].isa = (Class)v31;

      v33 = xpc_dictionary_get_string(v2, "device_id");
      nw_endpoint_set_device_id(v17, v33);
      *(_QWORD *)buf = 0;
      v34 = (const uint8_t *)xpc_dictionary_get_data(v2, "txt_record", (size_t *)buf);
      if (v34 && *(_QWORD *)buf)
      {
        v35 = nw_txt_record_create_with_bytes(v34, *(size_t *)buf);
        v36 = v17[23].isa;
        v17[23].isa = (Class)v35;

      }
      xpc_dictionary_get_array(v2, "public_keys");
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      if (v37)
      {
        applier[0] = MEMORY[0x1E0C809B0];
        applier[1] = 3221225472;
        applier[2] = __nw_endpoint_create_from_dictionary_block_invoke;
        applier[3] = &unk_1E14AC908;
        v84 = v17;
        xpc_array_apply(v37, applier);

      }
      v38 = v17;

LABEL_93:
      return v38;
    default:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v53 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
      v88 = 2048;
      v89 = (char *)uint64;
      v23 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(length[0]) = 16;
      type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v23, length, &type))
        goto LABEL_90;
      if (LOBYTE(length[0]) == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v54 = (id)gLogObj;
        v55 = length[0];
        if (os_log_type_enabled(v54, length[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          v88 = 2048;
          v89 = (char *)uint64;
          _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s incorrect endpoint type %llu", buf, 0x16u);
        }
      }
      else if (type)
      {
        v56 = __nw_create_backtrace_string();
        if (v56)
        {
          backtrace_string = (char *)v56;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v57 = (id)gLogObj;
          v58 = length[0];
          if (os_log_type_enabled(v57, length[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
            v88 = 2048;
            v89 = (char *)uint64;
            v90 = 2082;
            v91 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s incorrect endpoint type %llu, dumping backtrace:%{public}s", buf, 0x20u);
          }

          goto LABEL_55;
        }
        __nwlog_obj();
        v54 = objc_claimAutoreleasedReturnValue();
        v73 = length[0];
        if (os_log_type_enabled(v54, length[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          v88 = 2048;
          v89 = (char *)uint64;
          _os_log_impl(&dword_182FBE000, v54, v73, "%{public}s incorrect endpoint type %llu, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v54 = (id)gLogObj;
        v68 = length[0];
        if (os_log_type_enabled(v54, length[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_endpoint_create_from_dictionary";
          v88 = 2048;
          v89 = (char *)uint64;
          _os_log_impl(&dword_182FBE000, v54, v68, "%{public}s incorrect endpoint type %llu, backtrace limit exceeded", buf, 0x16u);
        }
      }

      goto LABEL_90;
  }
}

void sub_18310CA48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_interface_create_from_dictionary(void *a1)
{
  id v1;
  NWConcrete_nw_interface *v2;
  unsigned __int8 *string;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _OWORD *data;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  size_t length;

  v1 = a1;
  if (v1)
  {
    v2 = objc_alloc_init(NWConcrete_nw_interface);
    if (v2)
    {
      v2->type = xpc_dictionary_get_uint64(v1, "type");
      v2->subtype = xpc_dictionary_get_uint64(v1, "subtype");
      v2->index = xpc_dictionary_get_uint64(v1, "index");
      v2->generation = xpc_dictionary_get_uint64(v1, "generation");
      v2->delegate_index = xpc_dictionary_get_uint64(v1, "delegate_index");
      string = (unsigned __int8 *)xpc_dictionary_get_string(v1, "name");
      if (string)
      {
        v4 = *string;
        v2->name[0] = v4;
        if (v4)
        {
          v5 = string[1];
          v2->name[1] = v5;
          if (v5)
          {
            v6 = string[2];
            v2->name[2] = v6;
            if (v6)
            {
              v7 = string[3];
              v2->name[3] = v7;
              if (v7)
              {
                v8 = string[4];
                v2->name[4] = v8;
                if (v8)
                {
                  v9 = string[5];
                  v2->name[5] = v9;
                  if (v9)
                  {
                    v10 = string[6];
                    v2->name[6] = v10;
                    if (v10)
                    {
                      v11 = string[7];
                      v2->name[7] = v11;
                      if (v11)
                      {
                        v12 = string[8];
                        v2->name[8] = v12;
                        if (v12)
                        {
                          v13 = string[9];
                          v2->name[9] = v13;
                          if (v13)
                          {
                            v14 = string[10];
                            v2->name[10] = v14;
                            if (v14)
                            {
                              v15 = string[11];
                              v2->name[11] = v15;
                              if (v15)
                              {
                                v16 = string[12];
                                v2->name[12] = v16;
                                if (v16)
                                {
                                  v17 = string[13];
                                  v2->name[13] = v17;
                                  if (v17)
                                  {
                                    v18 = string[14];
                                    v2->name[14] = v18;
                                    if (v18)
                                    {
                                      v19 = string[15];
                                      v2->name[15] = v19;
                                      if (v19)
                                      {
                                        v20 = string[16];
                                        v2->name[16] = v20;
                                        if (v20)
                                        {
                                          v21 = string[17];
                                          v2->name[17] = v21;
                                          if (v21)
                                          {
                                            v22 = string[18];
                                            v2->name[18] = v22;
                                            if (v22)
                                            {
                                              v23 = string[19];
                                              v2->name[19] = v23;
                                              if (v23)
                                              {
                                                v24 = string[20];
                                                v2->name[20] = v24;
                                                if (v24)
                                                {
                                                  v25 = string[21];
                                                  v2->name[21] = v25;
                                                  if (v25)
                                                  {
                                                    v26 = string[22];
                                                    v2->name[22] = v26;
                                                    if (v26)
                                                    {
                                                      v27 = string[23];
                                                      v2->name[23] = v27;
                                                      if (v27)
                                                        v2->name[24] = 0;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      length = 0;
      data = xpc_dictionary_get_data(v1, "details", &length);
      if (data && length == 76)
      {
        *(_OWORD *)v2->details.ipv4_signature.signature = *data;
        v29 = data[1];
        v30 = data[2];
        v31 = data[3];
        *(_OWORD *)&v2->details.ipv4_netmask = *(_OWORD *)((char *)data + 60);
        *(_OWORD *)&v2->details.mtu = v31;
        *(_OWORD *)&v2->details.ipv6_signature.signature[8] = v30;
        *(_OWORD *)&v2->details.ipv4_signature.signature[16] = v29;
      }
    }
  }
  else
  {
    v2 = 0;
  }

  return v2;
}

void sub_18310CD3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

xpc_object_t NWUtilsCreateXPCDictionaryFromNSDictionary(void *a1)
{
  id v1;
  id v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  const __CFString *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t i;
  id v10;
  __CFString *v11;
  id v12;
  void *v13;
  void *v14;
  xpc_object_t XPCArrayFromNSArray;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  unint64_t v20;
  id v21;
  char isKindOfClass;
  uint64_t XPCDictionaryFromNSDictionary;
  NSObject *v24;
  NSObject *v25;
  const char *v26;
  uint32_t v27;
  __int128 v29;
  xpc_object_t xdict;
  void *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  void *v39;
  __int16 v40;
  void *v41;
  _BYTE v42[128];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  xdict = xpc_dictionary_create(0, 0, 0);
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  v2 = v1;
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v32, v42, 16);
  if (v3)
  {
    v5 = v3;
    v6 = CFSTR("INT64-");
    v7 = *(_QWORD *)v33;
    v8 = 0x1E0C99000uLL;
    *(_QWORD *)&v4 = 136446722;
    v29 = v4;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v33 != v7)
          objc_enumerationMutation(v2);
        v10 = *(id *)(*((_QWORD *)&v32 + 1) + 8 * i);
        if (objc_msgSend(v10, "hasPrefix:", v6))
        {
          v11 = (__CFString *)v6;
LABEL_18:
          objc_msgSend(v10, "substringFromIndex:", -[__CFString length](v11, "length", v29));
          v12 = (id)objc_claimAutoreleasedReturnValue();
          goto LABEL_19;
        }
        if (objc_msgSend(v10, "hasPrefix:", CFSTR("DOUBLE-")))
        {
          v11 = CFSTR("DOUBLE-");
          goto LABEL_18;
        }
        if (objc_msgSend(v10, "hasPrefix:", CFSTR("UINT64-")))
        {
          v11 = CFSTR("UINT64-");
          goto LABEL_18;
        }
        if (objc_msgSend(v10, "hasPrefix:", CFSTR("BOOL-")))
        {
          v11 = CFSTR("BOOL-");
          goto LABEL_18;
        }
        v12 = v10;
LABEL_19:
        v13 = v12;

        objc_msgSend(v2, "objectForKeyedSubscript:", v10);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          XPCArrayFromNSArray = NWUtilsCreateXPCArrayFromNSArray(v10, v14);
          if (!XPCArrayFromNSArray)
            goto LABEL_27;
        }
        else
        {
          v31 = v13;
          v17 = v5;
          v18 = v7;
          v19 = v6;
          v20 = v8;
          v21 = v14;
          objc_opt_class();
          isKindOfClass = objc_opt_isKindOfClass();

          if ((isKindOfClass & 1) != 0)
            XPCDictionaryFromNSDictionary = NWUtilsCreateXPCDictionaryFromNSDictionary(v21);
          else
            XPCDictionaryFromNSDictionary = NWUtilsCreateXPCObjectFromSimpleNSObject(v10, v21);
          XPCArrayFromNSArray = (xpc_object_t)XPCDictionaryFromNSDictionary;
          v8 = v20;
          v6 = v19;
          v7 = v18;
          v5 = v17;
          v13 = v31;
          if (!XPCDictionaryFromNSDictionary)
          {
LABEL_27:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v37 = "NWUtilsCreateXPCDictionaryFromNSDictionary";
              v38 = 2114;
              v39 = v14;
              v25 = v24;
              v26 = "%{public}s Could not create xpc object for %{public}@";
              v27 = 22;
              goto LABEL_5;
            }
LABEL_6:

            goto LABEL_7;
          }
        }
        v16 = (const char *)objc_msgSend(v13, "UTF8String", v29);
        if (!v16)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = (id)gLogObj;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v29;
            v37 = "NWUtilsCreateXPCDictionaryFromNSDictionary";
            v38 = 2114;
            v39 = v13;
            v40 = 2114;
            v41 = v14;
            v25 = v24;
            v26 = "%{public}s Could not parse trimmed key %{public}@ for %{public}@";
            v27 = 32;
LABEL_5:
            _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, v26, buf, v27);
          }
          goto LABEL_6;
        }
        xpc_dictionary_set_value(xdict, v16, XPCArrayFromNSArray);
LABEL_7:

      }
      v5 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v32, v42, 16);
    }
    while (v5);
  }

  return xdict;
}

uint64_t NWUtilsCreateXPCObjectFromSimpleNSObject(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  char isKindOfClass;
  uint64_t v7;
  uint64_t v8;
  id v10;
  char v11;
  id v12;
  char v13;
  id v14;
  id v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  void *v19;
  id v20;
  const char *v21;
  double v22;
  char *backtrace_string;
  _BOOL4 v24;
  void *v25;
  id v26;
  void *v27;
  void *v28;
  char v29;
  os_log_type_t type;
  _BYTE uuid[22];
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    || (v5 = v4,
        objc_opt_class(),
        isKindOfClass = objc_opt_isKindOfClass(),
        v5,
        (isKindOfClass & 1) != 0))
  {
    v7 = _CFXPCCreateXPCObjectFromCFObject();
LABEL_4:
    v8 = v7;
    goto LABEL_5;
  }
  v10 = v5;
  objc_opt_class();
  v11 = objc_opt_isKindOfClass();

  if ((v11 & 1) != 0)
  {
    *(_QWORD *)uuid = 0;
    *(_QWORD *)&uuid[8] = 0;
    objc_msgSend(v10, "getUUIDBytes:", uuid);
    v7 = (uint64_t)xpc_uuid_create(uuid);
    goto LABEL_4;
  }
  v12 = v10;
  objc_opt_class();
  v13 = objc_opt_isKindOfClass();

  if ((v13 & 1) != 0)
  {
    if (objc_msgSend(v3, "hasPrefix:", CFSTR("INT64-")))
    {
      v7 = (uint64_t)xpc_int64_create(objc_msgSend(v12, "longLongValue"));
    }
    else if (objc_msgSend(v3, "hasPrefix:", CFSTR("DOUBLE-")))
    {
      objc_msgSend(v12, "doubleValue");
      v7 = (uint64_t)xpc_double_create(v22);
    }
    else if (objc_msgSend(v3, "hasPrefix:", CFSTR("BOOL-")))
    {
      v7 = (uint64_t)xpc_BOOL_create(objc_msgSend(v12, "BOOLValue"));
    }
    else
    {
      v7 = (uint64_t)xpc_uint64_create(objc_msgSend(v12, "unsignedLongLongValue"));
    }
    goto LABEL_4;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = (id)gLogObj;
  *(_DWORD *)uuid = 136446466;
  *(_QWORD *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
  *(_WORD *)&uuid[12] = 2114;
  *(_QWORD *)&uuid[14] = objc_opt_class();
  v15 = *(id *)&uuid[14];
  v16 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v29 = 0;
  if (__nwlog_fault(v16, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        v19 = (void *)objc_opt_class();
        *(_DWORD *)uuid = 136446466;
        *(_QWORD *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
        *(_WORD *)&uuid[12] = 2114;
        *(_QWORD *)&uuid[14] = v19;
        v20 = v19;
        v21 = "%{public}s Unknown NSObject type %{public}@";
LABEL_29:
        _os_log_impl(&dword_182FBE000, v17, v18, v21, uuid, 0x16u);

      }
    }
    else
    {
      if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        v24 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v24)
          {
            v25 = (void *)objc_opt_class();
            *(_DWORD *)uuid = 136446722;
            *(_QWORD *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
            *(_WORD *)&uuid[12] = 2114;
            *(_QWORD *)&uuid[14] = v25;
            v32 = 2082;
            v33 = backtrace_string;
            v26 = v25;
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s Unknown NSObject type %{public}@, dumping backtrace:%{public}s", uuid, 0x20u);

          }
          free(backtrace_string);
          goto LABEL_31;
        }
        if (!v24)
          goto LABEL_30;
        v28 = (void *)objc_opt_class();
        *(_DWORD *)uuid = 136446466;
        *(_QWORD *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
        *(_WORD *)&uuid[12] = 2114;
        *(_QWORD *)&uuid[14] = v28;
        v20 = v28;
        v21 = "%{public}s Unknown NSObject type %{public}@, no backtrace";
        goto LABEL_29;
      }
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        v27 = (void *)objc_opt_class();
        *(_DWORD *)uuid = 136446466;
        *(_QWORD *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
        *(_WORD *)&uuid[12] = 2114;
        *(_QWORD *)&uuid[14] = v27;
        v20 = v27;
        v21 = "%{public}s Unknown NSObject type %{public}@, backtrace limit exceeded";
        goto LABEL_29;
      }
    }
LABEL_30:

  }
LABEL_31:
  if (v16)
    free(v16);
  v8 = 0;
LABEL_5:

  return v8;
}

void sub_18310DC2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18310E118(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_18310E218(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_endpoint_get_parent_endpoint_domain(uint64_t a1)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  char *backtrace_string;
  os_log_type_t v7;
  _BOOL4 v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
    return nw_endpoint_get_domain_for_policy(*(void **)(a1 + 112));
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_endpoint_get_parent_endpoint_domain";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_endpoint_get_parent_endpoint_domain";
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          v13 = "nw_endpoint_get_parent_endpoint_domain";
          v14 = 2082;
          v15 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_endpoint_get_parent_endpoint_domain";
        _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_endpoint_get_parent_endpoint_domain";
        _os_log_impl(&dword_182FBE000, v4, v9, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_socket_set_bidirectional_tcp_sockopts(uint64_t a1, void *a2)
{
  NSObject *v3;
  __int16 v6;
  int v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *v15;
  _BOOL4 v16;
  int v17;
  NSObject *v18;
  NSObject *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  _BOOL4 v25;
  int v26;
  NSObject *v27;
  NSObject *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  int v35;
  NSObject *v36;
  NSObject *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  int v44;
  NSObject *v45;
  NSObject *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  char *v51;
  _BOOL4 v52;
  int v53;
  NSObject *v54;
  NSObject *v55;
  char *v56;
  NSObject *v57;
  os_log_type_t v58;
  const char *v59;
  char *v60;
  _BOOL4 v61;
  int v62;
  NSObject *v63;
  NSObject *v64;
  char *v65;
  NSObject *v66;
  os_log_type_t v67;
  const char *v68;
  char *v69;
  _BOOL4 v70;
  int v71;
  NSObject *v72;
  NSObject *v73;
  char *v74;
  NSObject *v75;
  os_log_type_t v76;
  const char *v77;
  char *v78;
  _BOOL4 v79;
  uint64_t v80;
  NSObject *v81;
  NSObject *v82;
  const char *v83;
  NSObject *v84;
  char *v85;
  NSObject *v86;
  os_log_type_t v87;
  const char *v88;
  NSObject *v89;
  NSObject *v90;
  char *v91;
  _BOOL4 v92;
  const char *v93;
  NSObject *v94;
  char *v95;
  _BOOL4 v96;
  _BOOL4 v97;
  _BOOL4 v98;
  _BOOL4 v99;
  char *v100;
  NSObject *v101;
  os_log_type_t v102;
  const char *v103;
  char *backtrace_string;
  _BOOL4 v105;
  char v106;
  os_log_type_t v107[7];
  os_log_type_t v108;
  os_log_type_t v109[4];
  os_log_type_t v110[4];
  os_log_type_t v111[4];
  os_log_type_t v112[4];
  os_log_type_t type[4];
  os_log_type_t v114[4];
  uint8_t buf[4];
  const char *v116;
  __int16 v117;
  _BYTE v118[14];
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v100 = (char *)_os_log_send_and_compose_impl();
    v114[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v100, v114, type))
      goto LABEL_345;
    if (v114[0] == OS_LOG_TYPE_FAULT)
    {
      v101 = __nwlog_obj();
      v102 = v114[0];
      if (!os_log_type_enabled(v101, v114[0]))
        goto LABEL_345;
      *(_DWORD *)buf = 136446210;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v103 = "%{public}s called with null socket_handler";
    }
    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v101 = __nwlog_obj();
      v102 = v114[0];
      v105 = os_log_type_enabled(v101, v114[0]);
      if (backtrace_string)
      {
        if (v105)
        {
          *(_DWORD *)buf = 136446466;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 2082;
          *(_QWORD *)v118 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v101, v102, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_345;
      }
      if (!v105)
      {
LABEL_345:
        if (v100)
          free(v100);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v103 = "%{public}s called with null socket_handler, no backtrace";
    }
    else
    {
      v101 = __nwlog_obj();
      v102 = v114[0];
      if (!os_log_type_enabled(v101, v114[0]))
        goto LABEL_345;
      *(_DWORD *)buf = 136446210;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v103 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v101, v102, v103, buf, 0xCu);
    goto LABEL_345;
  }
  if (*(_BYTE *)(a1 + 336) == 1)
  {
    if ((*(_WORD *)(a1 + 333) & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v3 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 2082;
        *(_QWORD *)v118 = a1 + 340;
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Ignoring TCP options for UNIX socket", buf, 0x16u);
        return 1;
      }
    }
    return 1;
  }
  *(_DWORD *)v114 = 1;
  if (nw_tcp_options_get_reduce_buffering(a2))
    v6 = 0x2000;
  else
    v6 = 0;
  v7 = *(_WORD *)(a1 + 333) & 0xDFFF | (*(unsigned __int8 *)(a1 + 335) << 16);
  *(_WORD *)(a1 + 333) = *(_WORD *)(a1 + 333) & 0xDFFF | v6;
  *(_BYTE *)(a1 + 335) = BYTE2(v7);
  if (nw_tcp_options_get_no_delay(a2))
    nw_socket_set_no_delay(a1, 1);
  if (nw_tcp_options_get_no_push(a2))
    nw_socket_set_no_push(a1, 1);
  if (nw_tcp_options_get_disable_ack_stretching(a2) && setsockopt(*(_DWORD *)(a1 + 196), 6, 259, v114, 4u))
  {
    v8 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v9 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 2080;
      *(_QWORD *)v118 = a1 + 340;
      *(_WORD *)&v118[8] = 1024;
      *(_DWORD *)&v118[10] = v8;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d", buf, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (v8 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = 22;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_40;
    }
    *(_DWORD *)buf = 136446466;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 1024;
    *(_DWORD *)v118 = v8;
    v11 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v112[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v11, type, v112))
      goto LABEL_38;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_38;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v8;
      v14 = "%{public}s setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d";
    }
    else if (v112[0])
    {
      v15 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type[0];
      v16 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v15)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446722;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = v8;
          *(_WORD *)&v118[4] = 2082;
          *(_QWORD *)&v118[6] = v15;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v15);
        goto LABEL_38;
      }
      if (!v16)
      {
LABEL_38:
        if (v11)
          free(v11);
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v8;
      v14 = "%{public}s setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v12 = __nwlog_obj();
      v13 = type[0];
      if (!os_log_type_enabled(v12, type[0]))
        goto LABEL_38;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v8;
      v14 = "%{public}s setsockopt TCP_SENDMOREACKS failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0x12u);
    goto LABEL_38;
  }
LABEL_40:
  if (!nw_tcp_options_get_no_options(a2) || !setsockopt(*(_DWORD *)(a1 + 196), 6, 8, v114, 4u))
    goto LABEL_65;
  v17 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v18 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v17;
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_NOOPT failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v19 = gLogObj;
  if (v17 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = 22;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_NOOPT failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_65;
  }
  *(_DWORD *)buf = 136446466;
  v116 = "nw_socket_set_bidirectional_tcp_sockopts";
  v117 = 1024;
  *(_DWORD *)v118 = v17;
  v20 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v112[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v20, type, v112))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      v22 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_63;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v17;
      v23 = "%{public}s setsockopt TCP_NOOPT failed %{darwin.errno}d";
      goto LABEL_62;
    }
    if (v112[0] == OS_LOG_TYPE_DEFAULT)
    {
      v21 = __nwlog_obj();
      v22 = type[0];
      if (!os_log_type_enabled(v21, type[0]))
        goto LABEL_63;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v17;
      v23 = "%{public}s setsockopt TCP_NOOPT failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_62;
    }
    v24 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    v22 = type[0];
    v25 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v17;
        *(_WORD *)&v118[4] = 2082;
        *(_QWORD *)&v118[6] = v24;
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s setsockopt TCP_NOOPT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v24);
      goto LABEL_63;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v17;
      v23 = "%{public}s setsockopt TCP_NOOPT failed %{darwin.errno}d, no backtrace";
LABEL_62:
      _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0x12u);
    }
  }
LABEL_63:
  if (v20)
    free(v20);
LABEL_65:
  if (!nw_tcp_options_get_no_timewait(a2) || !setsockopt(*(_DWORD *)(a1 + 196), 6, 520, v114, 4u))
    goto LABEL_90;
  v26 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v27 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v26;
    _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v28 = gLogObj;
  if (v26 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = 22;
      _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_90;
  }
  *(_DWORD *)buf = 136446466;
  v116 = "nw_socket_set_bidirectional_tcp_sockopts";
  v117 = 1024;
  *(_DWORD *)v118 = v26;
  v29 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v112[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v29, type, v112))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = gLogObj;
      v31 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v26;
      v32 = "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d";
      goto LABEL_87;
    }
    if (v112[0] == OS_LOG_TYPE_DEFAULT)
    {
      v30 = __nwlog_obj();
      v31 = type[0];
      if (!os_log_type_enabled(v30, type[0]))
        goto LABEL_88;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v26;
      v32 = "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_87;
    }
    v33 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = gLogObj;
    v31 = type[0];
    v34 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v33)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v26;
        *(_WORD *)&v118[4] = 2082;
        *(_QWORD *)&v118[6] = v33;
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v33);
      goto LABEL_88;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v26;
      v32 = "%{public}s setsockopt TCP_NOTIMEWAIT failed %{darwin.errno}d, no backtrace";
LABEL_87:
      _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0x12u);
    }
  }
LABEL_88:
  if (v29)
    free(v29);
LABEL_90:
  *(_DWORD *)type = 0;
  *(_DWORD *)type = nw_tcp_options_get_maximum_segment_size(a2);
  if (!*(_DWORD *)type || !setsockopt(*(_DWORD *)(a1 + 196), 6, 2, type, 4u))
    goto LABEL_115;
  v35 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v36 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v35;
    _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_MAXSEG failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v37 = gLogObj;
  if (v35 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = 22;
      _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_115;
  }
  *(_DWORD *)buf = 136446466;
  v116 = "nw_socket_set_bidirectional_tcp_sockopts";
  v117 = 1024;
  *(_DWORD *)v118 = v35;
  v38 = (char *)_os_log_send_and_compose_impl();
  v112[0] = OS_LOG_TYPE_ERROR;
  v111[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v38, v112, v111))
  {
    if (v112[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v39 = gLogObj;
      v40 = v112[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v112[0]))
        goto LABEL_113;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v35;
      v41 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d";
      goto LABEL_112;
    }
    if (v111[0] == OS_LOG_TYPE_DEFAULT)
    {
      v39 = __nwlog_obj();
      v40 = v112[0];
      if (!os_log_type_enabled(v39, v112[0]))
        goto LABEL_113;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v35;
      v41 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_112;
    }
    v42 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = gLogObj;
    v40 = v112[0];
    v43 = os_log_type_enabled((os_log_t)gLogObj, v112[0]);
    if (v42)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v35;
        *(_WORD *)&v118[4] = 2082;
        *(_QWORD *)&v118[6] = v42;
        _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v42);
      goto LABEL_113;
    }
    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v35;
      v41 = "%{public}s setsockopt TCP_MAXSEG failed %{darwin.errno}d, no backtrace";
LABEL_112:
      _os_log_impl(&dword_182FBE000, v39, v40, v41, buf, 0x12u);
    }
  }
LABEL_113:
  if (v38)
    free(v38);
LABEL_115:
  *(_DWORD *)v112 = 0;
  *(_DWORD *)v112 = nw_tcp_options_get_retransmit_connection_drop_time(a2);
  if (!*(_DWORD *)v112 || !setsockopt(*(_DWORD *)(a1 + 196), 6, 128, v112, 4u))
    goto LABEL_140;
  v44 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v45 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v44;
    _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v46 = gLogObj;
  if (v44 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = 22;
      _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_140;
  }
  *(_DWORD *)buf = 136446466;
  v116 = "nw_socket_set_bidirectional_tcp_sockopts";
  v117 = 1024;
  *(_DWORD *)v118 = v44;
  v47 = (char *)_os_log_send_and_compose_impl();
  v111[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v47, v111, v110))
  {
    if (v111[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v48 = gLogObj;
      v49 = v111[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v111[0]))
        goto LABEL_138;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v44;
      v50 = "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d";
      goto LABEL_137;
    }
    if (v110[0] == OS_LOG_TYPE_DEFAULT)
    {
      v48 = __nwlog_obj();
      v49 = v111[0];
      if (!os_log_type_enabled(v48, v111[0]))
        goto LABEL_138;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v44;
      v50 = "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_137;
    }
    v51 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v48 = gLogObj;
    v49 = v111[0];
    v52 = os_log_type_enabled((os_log_t)gLogObj, v111[0]);
    if (v51)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v44;
        *(_WORD *)&v118[4] = 2082;
        *(_QWORD *)&v118[6] = v51;
        _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v51);
      goto LABEL_138;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v44;
      v50 = "%{public}s setsockopt TCP_RXT_CONNDROPTIME failed %{darwin.errno}d, no backtrace";
LABEL_137:
      _os_log_impl(&dword_182FBE000, v48, v49, v50, buf, 0x12u);
    }
  }
LABEL_138:
  if (v47)
    free(v47);
LABEL_140:
  if (!nw_tcp_options_get_retransmit_fin_drop(a2) || !setsockopt(*(_DWORD *)(a1 + 196), 6, 256, v114, 4u))
    goto LABEL_165;
  v53 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v54 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v53;
    _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v55 = gLogObj;
  if (v53 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = 22;
      _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_165;
  }
  *(_DWORD *)buf = 136446466;
  v116 = "nw_socket_set_bidirectional_tcp_sockopts";
  v117 = 1024;
  *(_DWORD *)v118 = v53;
  v56 = (char *)_os_log_send_and_compose_impl();
  v111[0] = OS_LOG_TYPE_ERROR;
  v110[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v56, v111, v110))
  {
    if (v111[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v57 = gLogObj;
      v58 = v111[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v111[0]))
        goto LABEL_163;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v53;
      v59 = "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d";
      goto LABEL_162;
    }
    if (v110[0] == OS_LOG_TYPE_DEFAULT)
    {
      v57 = __nwlog_obj();
      v58 = v111[0];
      if (!os_log_type_enabled(v57, v111[0]))
        goto LABEL_163;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v53;
      v59 = "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_162;
    }
    v60 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v57 = gLogObj;
    v58 = v111[0];
    v61 = os_log_type_enabled((os_log_t)gLogObj, v111[0]);
    if (v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v53;
        *(_WORD *)&v118[4] = 2082;
        *(_QWORD *)&v118[6] = v60;
        _os_log_impl(&dword_182FBE000, v57, v58, "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v60);
      goto LABEL_163;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v53;
      v59 = "%{public}s setsockopt TCP_RXT_FINDROP failed %{darwin.errno}d, no backtrace";
LABEL_162:
      _os_log_impl(&dword_182FBE000, v57, v58, v59, buf, 0x12u);
    }
  }
LABEL_163:
  if (v56)
    free(v56);
LABEL_165:
  *(_DWORD *)v111 = 0;
  *(_DWORD *)v111 = nw_tcp_options_get_persist_timeout(a2);
  if (!*(_DWORD *)v111 || !setsockopt(*(_DWORD *)(a1 + 196), 6, 64, v111, 4u))
    goto LABEL_190;
  v62 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v63 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v62;
    _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v64 = gLogObj;
  if (v62 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = 22;
      _os_log_impl(&dword_182FBE000, v64, OS_LOG_TYPE_ERROR, "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_190;
  }
  *(_DWORD *)buf = 136446466;
  v116 = "nw_socket_set_bidirectional_tcp_sockopts";
  v117 = 1024;
  *(_DWORD *)v118 = v62;
  v65 = (char *)_os_log_send_and_compose_impl();
  v110[0] = OS_LOG_TYPE_ERROR;
  v109[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v65, v110, v109))
  {
    if (v110[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v66 = gLogObj;
      v67 = v110[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v110[0]))
        goto LABEL_188;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v62;
      v68 = "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d";
      goto LABEL_187;
    }
    if (v109[0] == OS_LOG_TYPE_DEFAULT)
    {
      v66 = __nwlog_obj();
      v67 = v110[0];
      if (!os_log_type_enabled(v66, v110[0]))
        goto LABEL_188;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v62;
      v68 = "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_187;
    }
    v69 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v66 = gLogObj;
    v67 = v110[0];
    v70 = os_log_type_enabled((os_log_t)gLogObj, v110[0]);
    if (v69)
    {
      if (v70)
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v62;
        *(_WORD *)&v118[4] = 2082;
        *(_QWORD *)&v118[6] = v69;
        _os_log_impl(&dword_182FBE000, v66, v67, "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v69);
      goto LABEL_188;
    }
    if (v70)
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v62;
      v68 = "%{public}s setsockopt PERSIST_TIMEOUT failed %{darwin.errno}d, no backtrace";
LABEL_187:
      _os_log_impl(&dword_182FBE000, v66, v67, v68, buf, 0x12u);
    }
  }
LABEL_188:
  if (v65)
    free(v65);
LABEL_190:
  if (!nw_tcp_options_get_enable_background_traffic_management(a2)
    || !setsockopt(*(_DWORD *)(a1 + 196), 0xFFFF, 4357, v114, 4u))
  {
    goto LABEL_215;
  }
  v71 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v72 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v71;
    _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v73 = gLogObj;
  if (v71 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = 22;
      _os_log_impl(&dword_182FBE000, v73, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d", buf, 0x12u);
    }
    goto LABEL_215;
  }
  *(_DWORD *)buf = 136446466;
  v116 = "nw_socket_set_bidirectional_tcp_sockopts";
  v117 = 1024;
  *(_DWORD *)v118 = v71;
  v74 = (char *)_os_log_send_and_compose_impl();
  v110[0] = OS_LOG_TYPE_ERROR;
  v109[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v74, v110, v109))
  {
    if (v110[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v75 = gLogObj;
      v76 = v110[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v110[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v71;
      v77 = "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d";
      goto LABEL_212;
    }
    if (v109[0] == OS_LOG_TYPE_DEFAULT)
    {
      v75 = __nwlog_obj();
      v76 = v110[0];
      if (!os_log_type_enabled(v75, v110[0]))
        goto LABEL_213;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v71;
      v77 = "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_212;
    }
    v78 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v75 = gLogObj;
    v76 = v110[0];
    v79 = os_log_type_enabled((os_log_t)gLogObj, v110[0]);
    if (v78)
    {
      if (v79)
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v71;
        *(_WORD *)&v118[4] = 2082;
        *(_QWORD *)&v118[6] = v78;
        _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v78);
      goto LABEL_213;
    }
    if (v79)
    {
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v71;
      v77 = "%{public}s setsockopt SO_TRAFFIC_MGT_BACKGROUND failed %{darwin.errno}d, no backtrace";
LABEL_212:
      _os_log_impl(&dword_182FBE000, v75, v76, v77, buf, 0x12u);
    }
  }
LABEL_213:
  if (v74)
    free(v74);
LABEL_215:
  if (!nw_tcp_options_get_enable_keepalive(a2))
    goto LABEL_223;
  if ((setsockopt(*(_DWORD *)(a1 + 196), 0xFFFF, 8, v114, 4u) & 0x80000000) == 0)
  {
    *(_DWORD *)v110 = 0;
    *(_DWORD *)v110 = nw_tcp_options_get_keepalive_idle_time(a2);
    if (*(_DWORD *)v110 && setsockopt(*(_DWORD *)(a1 + 196), 6, 16, v110, 4u) < 0)
    {
      v80 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v89 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 2080;
        *(_QWORD *)v118 = a1 + 340;
        *(_WORD *)&v118[8] = 1024;
        *(_DWORD *)&v118[10] = v80;
        _os_log_impl(&dword_182FBE000, v89, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d", buf, 0x1Cu);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v82 = gLogObj;
      if ((_DWORD)v80 == 22)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = 22;
          v83 = "%{public}s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d";
          goto LABEL_273;
        }
        goto LABEL_329;
      }
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v80;
      v85 = (char *)_os_log_send_and_compose_impl();
      v109[0] = OS_LOG_TYPE_ERROR;
      v107[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v85, v109, v107))
        goto LABEL_327;
      if (v109[0] == OS_LOG_TYPE_FAULT)
      {
        v86 = __nwlog_obj();
        v87 = v109[0];
        if (!os_log_type_enabled(v86, v109[0]))
          goto LABEL_327;
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v80;
        v88 = "%{public}s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d";
        goto LABEL_326;
      }
      if (v107[0] == OS_LOG_TYPE_DEFAULT)
      {
        v86 = __nwlog_obj();
        v87 = v109[0];
        if (!os_log_type_enabled(v86, v109[0]))
          goto LABEL_327;
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v80;
        v88 = "%{public}s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_326;
      }
      v91 = (char *)__nw_create_backtrace_string();
      v86 = __nwlog_obj();
      v87 = v109[0];
      v97 = os_log_type_enabled(v86, v109[0]);
      if (!v91)
      {
        if (!v97)
          goto LABEL_327;
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v80;
        v88 = "%{public}s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d, no backtrace";
        goto LABEL_326;
      }
      if (!v97)
        goto LABEL_310;
      *(_DWORD *)buf = 136446722;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v80;
      *(_WORD *)&v118[4] = 2082;
      *(_QWORD *)&v118[6] = v91;
      v93 = "%{public}s setsockopt TCP_KEEPALIVE failed %{darwin.errno}d, dumping backtrace:%{public}s";
    }
    else
    {
      *(_DWORD *)v109 = 0;
      *(_DWORD *)v109 = nw_tcp_options_get_keepalive_interval(a2);
      if (!*(_DWORD *)v109 || (setsockopt(*(_DWORD *)(a1 + 196), 6, 257, v109, 4u) & 0x80000000) == 0)
      {
        *(_DWORD *)v107 = nw_tcp_options_get_keepalive_count(a2);
        if (!*(_DWORD *)v107 || (setsockopt(*(_DWORD *)(a1 + 196), 6, 258, v107, 4u) & 0x80000000) == 0)
        {
LABEL_223:
          if (!nw_tcp_options_get_enable_keepalive_offload(a2)
            || (setsockopt(*(_DWORD *)(a1 + 196), 6, 529, v114, 4u) & 0x80000000) == 0)
          {
            return 1;
          }
          v80 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v84 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            v116 = "nw_socket_set_bidirectional_tcp_sockopts";
            v117 = 2080;
            *(_QWORD *)v118 = a1 + 340;
            *(_WORD *)&v118[8] = 1024;
            *(_DWORD *)&v118[10] = v80;
            _os_log_impl(&dword_182FBE000, v84, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_KEEPALIVE_OFFLOAD failed %{darwin.errno}d", buf, 0x1Cu);
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v82 = gLogObj;
          if ((_DWORD)v80 == 22)
          {
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v116 = "nw_socket_set_bidirectional_tcp_sockopts";
              v117 = 1024;
              *(_DWORD *)v118 = 22;
              v83 = "%{public}s setsockopt TCP_KEEPALIVE_OFFLOAD failed %{darwin.errno}d";
              goto LABEL_273;
            }
            goto LABEL_329;
          }
          *(_DWORD *)buf = 136446466;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = v80;
          v85 = (char *)_os_log_send_and_compose_impl();
          v110[0] = OS_LOG_TYPE_ERROR;
          v109[0] = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v85, v110, v109))
            goto LABEL_327;
          if (v110[0] == OS_LOG_TYPE_FAULT)
          {
            v86 = __nwlog_obj();
            v87 = v110[0];
            if (!os_log_type_enabled(v86, v110[0]))
              goto LABEL_327;
            *(_DWORD *)buf = 136446466;
            v116 = "nw_socket_set_bidirectional_tcp_sockopts";
            v117 = 1024;
            *(_DWORD *)v118 = v80;
            v88 = "%{public}s setsockopt TCP_KEEPALIVE_OFFLOAD failed %{darwin.errno}d";
          }
          else if (v109[0])
          {
            v95 = (char *)__nw_create_backtrace_string();
            v86 = __nwlog_obj();
            v87 = v110[0];
            v96 = os_log_type_enabled(v86, v110[0]);
            if (v95)
            {
              if (v96)
              {
                *(_DWORD *)buf = 136446722;
                v116 = "nw_socket_set_bidirectional_tcp_sockopts";
                v117 = 1024;
                *(_DWORD *)v118 = v80;
                *(_WORD *)&v118[4] = 2082;
                *(_QWORD *)&v118[6] = v95;
                _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s setsockopt TCP_KEEPALIVE_OFFLOAD failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(v95);
LABEL_327:
              if (!v85)
                goto LABEL_329;
LABEL_328:
              free(v85);
              goto LABEL_329;
            }
            if (!v96)
              goto LABEL_327;
            *(_DWORD *)buf = 136446466;
            v116 = "nw_socket_set_bidirectional_tcp_sockopts";
            v117 = 1024;
            *(_DWORD *)v118 = v80;
            v88 = "%{public}s setsockopt TCP_KEEPALIVE_OFFLOAD failed %{darwin.errno}d, no backtrace";
          }
          else
          {
            v86 = __nwlog_obj();
            v87 = v110[0];
            if (!os_log_type_enabled(v86, v110[0]))
              goto LABEL_327;
            *(_DWORD *)buf = 136446466;
            v116 = "nw_socket_set_bidirectional_tcp_sockopts";
            v117 = 1024;
            *(_DWORD *)v118 = v80;
            v88 = "%{public}s setsockopt TCP_KEEPALIVE_OFFLOAD failed %{darwin.errno}d, backtrace limit exceeded";
          }
LABEL_326:
          _os_log_impl(&dword_182FBE000, v86, v87, v88, buf, 0x12u);
          goto LABEL_327;
        }
        v80 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v94 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 2080;
          *(_QWORD *)v118 = a1 + 340;
          *(_WORD *)&v118[8] = 1024;
          *(_DWORD *)&v118[10] = v80;
          _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_KEEPCNT failed %{darwin.errno}d", buf, 0x1Cu);
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v82 = gLogObj;
        if ((_DWORD)v80 == 22)
        {
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v116 = "nw_socket_set_bidirectional_tcp_sockopts";
            v117 = 1024;
            *(_DWORD *)v118 = 22;
            v83 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
            goto LABEL_273;
          }
          goto LABEL_329;
        }
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v80;
        v85 = (char *)_os_log_send_and_compose_impl();
        v108 = OS_LOG_TYPE_ERROR;
        v106 = 0;
        if (!__nwlog_fault(v85, &v108, &v106))
          goto LABEL_327;
        if (v108 == OS_LOG_TYPE_FAULT)
        {
          v86 = __nwlog_obj();
          v87 = v108;
          if (!os_log_type_enabled(v86, v108))
            goto LABEL_327;
          *(_DWORD *)buf = 136446466;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = v80;
          v88 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d";
          goto LABEL_326;
        }
        if (!v106)
        {
          v86 = __nwlog_obj();
          v87 = v108;
          if (!os_log_type_enabled(v86, v108))
            goto LABEL_327;
          *(_DWORD *)buf = 136446466;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = v80;
          v88 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_326;
        }
        v91 = (char *)__nw_create_backtrace_string();
        v86 = __nwlog_obj();
        v87 = v108;
        v99 = os_log_type_enabled(v86, v108);
        if (!v91)
        {
          if (!v99)
            goto LABEL_327;
          *(_DWORD *)buf = 136446466;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = v80;
          v88 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d, no backtrace";
          goto LABEL_326;
        }
        if (v99)
        {
          *(_DWORD *)buf = 136446722;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = v80;
          *(_WORD *)&v118[4] = 2082;
          *(_QWORD *)&v118[6] = v91;
          v93 = "%{public}s setsockopt TCP_KEEPCNT failed %{darwin.errno}d, dumping backtrace:%{public}s";
          goto LABEL_309;
        }
LABEL_310:
        free(v91);
        if (!v85)
          goto LABEL_329;
        goto LABEL_328;
      }
      v80 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v90 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 2080;
        *(_QWORD *)v118 = a1 + 340;
        *(_WORD *)&v118[8] = 1024;
        *(_DWORD *)&v118[10] = v80;
        _os_log_impl(&dword_182FBE000, v90, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d", buf, 0x1Cu);
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v82 = gLogObj;
      if ((_DWORD)v80 == 22)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v116 = "nw_socket_set_bidirectional_tcp_sockopts";
          v117 = 1024;
          *(_DWORD *)v118 = 22;
          v83 = "%{public}s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d";
          goto LABEL_273;
        }
        goto LABEL_329;
      }
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v80;
      v85 = (char *)_os_log_send_and_compose_impl();
      v107[0] = OS_LOG_TYPE_ERROR;
      v108 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v85, v107, &v108))
        goto LABEL_327;
      if (v107[0] == OS_LOG_TYPE_FAULT)
      {
        v86 = __nwlog_obj();
        v87 = v107[0];
        if (!os_log_type_enabled(v86, v107[0]))
          goto LABEL_327;
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v80;
        v88 = "%{public}s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d";
        goto LABEL_326;
      }
      if (v108 == OS_LOG_TYPE_DEFAULT)
      {
        v86 = __nwlog_obj();
        v87 = v107[0];
        if (!os_log_type_enabled(v86, v107[0]))
          goto LABEL_327;
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v80;
        v88 = "%{public}s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_326;
      }
      v91 = (char *)__nw_create_backtrace_string();
      v86 = __nwlog_obj();
      v87 = v107[0];
      v98 = os_log_type_enabled(v86, v107[0]);
      if (!v91)
      {
        if (!v98)
          goto LABEL_327;
        *(_DWORD *)buf = 136446466;
        v116 = "nw_socket_set_bidirectional_tcp_sockopts";
        v117 = 1024;
        *(_DWORD *)v118 = v80;
        v88 = "%{public}s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d, no backtrace";
        goto LABEL_326;
      }
      if (!v98)
        goto LABEL_310;
      *(_DWORD *)buf = 136446722;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v80;
      *(_WORD *)&v118[4] = 2082;
      *(_QWORD *)&v118[6] = v91;
      v93 = "%{public}s setsockopt TCP_KEEPINTVL failed %{darwin.errno}d, dumping backtrace:%{public}s";
    }
LABEL_309:
    _os_log_impl(&dword_182FBE000, v86, v87, v93, buf, 0x1Cu);
    goto LABEL_310;
  }
  v80 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v81 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 2080;
    *(_QWORD *)v118 = a1 + 340;
    *(_WORD *)&v118[8] = 1024;
    *(_DWORD *)&v118[10] = v80;
    _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_KEEPALIVE failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v82 = gLogObj;
  if ((_DWORD)v80 != 22)
  {
    *(_DWORD *)buf = 136446466;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 1024;
    *(_DWORD *)v118 = v80;
    v85 = (char *)_os_log_send_and_compose_impl();
    v110[0] = OS_LOG_TYPE_ERROR;
    v109[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v85, v110, v109))
      goto LABEL_327;
    if (v110[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v86 = gLogObj;
      v87 = v110[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v110[0]))
        goto LABEL_327;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v80;
      v88 = "%{public}s setsockopt SO_KEEPALIVE failed %{darwin.errno}d";
      goto LABEL_326;
    }
    if (v109[0] == OS_LOG_TYPE_DEFAULT)
    {
      v86 = __nwlog_obj();
      v87 = v110[0];
      if (!os_log_type_enabled(v86, v110[0]))
        goto LABEL_327;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v80;
      v88 = "%{public}s setsockopt SO_KEEPALIVE failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_326;
    }
    v91 = (char *)__nw_create_backtrace_string();
    v86 = __nwlog_obj();
    v87 = v110[0];
    v92 = os_log_type_enabled(v86, v110[0]);
    if (!v91)
    {
      if (!v92)
        goto LABEL_327;
      *(_DWORD *)buf = 136446466;
      v116 = "nw_socket_set_bidirectional_tcp_sockopts";
      v117 = 1024;
      *(_DWORD *)v118 = v80;
      v88 = "%{public}s setsockopt SO_KEEPALIVE failed %{darwin.errno}d, no backtrace";
      goto LABEL_326;
    }
    if (!v92)
      goto LABEL_310;
    *(_DWORD *)buf = 136446722;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 1024;
    *(_DWORD *)v118 = v80;
    *(_WORD *)&v118[4] = 2082;
    *(_QWORD *)&v118[6] = v91;
    v93 = "%{public}s setsockopt SO_KEEPALIVE failed %{darwin.errno}d, dumping backtrace:%{public}s";
    goto LABEL_309;
  }
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v116 = "nw_socket_set_bidirectional_tcp_sockopts";
    v117 = 1024;
    *(_DWORD *)v118 = 22;
    v83 = "%{public}s setsockopt SO_KEEPALIVE failed %{darwin.errno}d";
LABEL_273:
    _os_log_impl(&dword_182FBE000, v82, OS_LOG_TYPE_ERROR, v83, buf, 0x12u);
  }
LABEL_329:
  nw_socket_internal_error(a1, v80);
  return 0;
}

BOOL nw_tcp_options_get_retransmit_fin_drop(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_retransmit_fin_drop_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_fin_drop";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183111648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_retransmit_connection_drop_time(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_retransmit_connection_drop_time_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_18311196C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_reduce_buffering(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_reduce_buffering_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_reduce_buffering";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_reduce_buffering";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_reduce_buffering";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_reduce_buffering";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_reduce_buffering";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183111C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_persist_timeout(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_persist_timeout_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_persist_timeout";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_persist_timeout";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_persist_timeout";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_persist_timeout";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_persist_timeout";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183111FBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_no_timewait(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_no_timewait_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_timewait";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_timewait";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_timewait";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_timewait";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_timewait";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831122E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_no_push(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_no_push_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_push";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_push";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_push";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_push";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_push";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183112614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_no_options(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_no_options_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_options";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_options";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183112940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_no_delay(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_no_delay_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_delay";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_delay";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_delay";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_delay";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_no_delay";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183112C6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_maximum_segment_size(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_maximum_segment_size_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_maximum_segment_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_maximum_segment_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_maximum_segment_size";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_maximum_segment_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_maximum_segment_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183112F90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_enable_keepalive(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_enable_keepalive_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831132BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_enable_background_traffic_management(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_enable_background_traffic_management_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_background_traffic_management";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831135E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_disable_ack_stretching(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_disable_ack_stretching_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ack_stretching";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ack_stretching";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ack_stretching";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ack_stretching";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_disable_ack_stretching";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183113914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_tcp_options_get_enable_keepalive_offload(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_enable_keepalive_offload_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive_offload";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive_offload";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive_offload";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive_offload";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_enable_keepalive_offload";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183113C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_socket_set_no_delay(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v13;
  os_log_type_t type;
  int v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  _BYTE v19[14];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 200) != 2)
    return 22;
  v15 = a2;
  if (!setsockopt(*(_DWORD *)(a1 + 196), 6, 1, &v15, 4u))
    return 0;
  v3 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1)
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
  v4 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446722;
    v17 = "nw_socket_set_no_delay";
    v18 = 2080;
    *(_QWORD *)v19 = a1 + 340;
    *(_WORD *)&v19[8] = 1024;
    *(_DWORD *)&v19[10] = v3;
    _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt TCP_NODELAY failed %{darwin.errno}d", buf, 0x1Cu);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = gLogObj;
  if ((_DWORD)v3 == 22)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_socket_set_no_delay";
      v18 = 1024;
      *(_DWORD *)v19 = 22;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s setsockopt TCP_NODELAY failed %{darwin.errno}d", buf, 0x12u);
    }
    return v3;
  }
  *(_DWORD *)buf = 136446466;
  v17 = "nw_socket_set_no_delay";
  v18 = 1024;
  *(_DWORD *)v19 = v3;
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446466;
      v17 = "nw_socket_set_no_delay";
      v18 = 1024;
      *(_DWORD *)v19 = v3;
      v9 = "%{public}s setsockopt TCP_NODELAY failed %{darwin.errno}d";
      goto LABEL_25;
    }
    if (!v13)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446466;
      v17 = "nw_socket_set_no_delay";
      v18 = 1024;
      *(_DWORD *)v19 = v3;
      v9 = "%{public}s setsockopt TCP_NODELAY failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_25;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    v8 = type;
    v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446722;
        v17 = "nw_socket_set_no_delay";
        v18 = 1024;
        *(_DWORD *)v19 = v3;
        *(_WORD *)&v19[4] = 2082;
        *(_QWORD *)&v19[6] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s setsockopt TCP_NODELAY failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(backtrace_string);
      goto LABEL_26;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_socket_set_no_delay";
      v18 = 1024;
      *(_DWORD *)v19 = v3;
      v9 = "%{public}s setsockopt TCP_NODELAY failed %{darwin.errno}d, no backtrace";
LABEL_25:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0x12u);
    }
  }
LABEL_26:
  if (v6)
    free(v6);
  return v3;
}

uint64_t nw_tcp_options_get_keepalive_interval(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_keepalive_interval_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_interval";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_interval";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_interval";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_18311434C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_keepalive_idle_time(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_keepalive_idle_time_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_idle_time";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_idle_time";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_idle_time";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_idle_time";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_idle_time";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183114670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_keepalive_count(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v16 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_keepalive_count_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_count";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_count";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_tcp_options_get_keepalive_count";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183114994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_context_get_privacy_level(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t os_unfair_lock_opaque;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((v1[34]._os_unfair_lock_opaque & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      os_unfair_lock_lock(v2 + 20);
      os_unfair_lock_opaque = v2[31]._os_unfair_lock_opaque;
      os_unfair_lock_unlock(v2 + 20);
    }
    else
    {
      os_unfair_lock_opaque = v2[31]._os_unfair_lock_opaque;
    }
    goto LABEL_6;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_context_get_privacy_level";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_privacy_level";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_context_get_privacy_level";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_privacy_level";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_context_get_privacy_level";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v6)
    free(v6);
  os_unfair_lock_opaque = 1;
LABEL_6:

  return os_unfair_lock_opaque;
}

BOOL nw_flow_listener_new_flow(uint64_t a1, void *a2, void *a3)
{
  id v5;
  NWConcrete_nw_endpoint_handler *v6;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v8;
  char *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t, char *);
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  int minimize_logging;
  char logging_disabled;
  NSObject *v25;
  const char *v26;
  const char *v27;
  nw_endpoint_t v28;
  const char *v29;
  const char *v30;
  NWConcrete_nw_endpoint_handler *v31;
  const char *v32;
  id v33;
  uint64_t v34;
  NSObject *v35;
  const char *v36;
  NWConcrete_nw_endpoint_handler *v37;
  char v38;
  NWConcrete_nw_endpoint_handler *v39;
  NSObject *v40;
  NWConcrete_nw_endpoint_handler *v41;
  NWConcrete_nw_endpoint_handler *v42;
  char v43;
  const char *v44;
  nw_endpoint_t v45;
  const char *logging_description;
  char *id_str;
  unsigned int *v48;
  unsigned int *v49;
  uint64_t v50;
  const char *v51;
  id v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  NSObject *v56;
  const char *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  void **v61;
  void **v62;
  const char *v63;
  id v64;
  const char *v65;
  const char *v66;
  nw_endpoint_t v67;
  const char *v68;
  const char *v69;
  NWConcrete_nw_endpoint_handler *v70;
  const char *v71;
  id v72;
  char *v73;
  NSObject *v74;
  os_log_type_t v75;
  const char *v76;
  const char *v77;
  nw_endpoint_t v78;
  const char *v79;
  const char *v80;
  const char *v81;
  id v82;
  os_log_type_t v83;
  id v84;
  const char *v85;
  const char *v86;
  nw_endpoint_t v87;
  const char *v88;
  const char *v89;
  NWConcrete_nw_endpoint_handler *v90;
  const char *v91;
  id v92;
  char *v93;
  NSObject *v94;
  os_log_type_t v95;
  const char *v96;
  const char *v97;
  nw_endpoint_t v98;
  const char *v99;
  const char *v100;
  const char *v101;
  id v102;
  os_log_type_t v103;
  NWConcrete_nw_endpoint_handler *v104;
  BOOL v105;
  NSObject *v106;
  NWConcrete_nw_endpoint_handler *v107;
  NWConcrete_nw_endpoint_handler *v108;
  _BOOL4 v109;
  const char *v110;
  nw_endpoint_t v111;
  const char *v112;
  unsigned int *v113;
  unsigned int *v114;
  uint64_t v115;
  const char *v116;
  void **v117;
  const char *v118;
  NSObject *v119;
  const char *v120;
  void **v121;
  id v122;
  const char *v123;
  char *v124;
  uint64_t v125;
  void *v126;
  void **v127;
  id v128;
  void *v129;
  _BOOL8 result;
  const char *v131;
  char *v132;
  NSObject *v133;
  os_log_type_t v134;
  const char *v135;
  const char *v136;
  const char *v137;
  const char *v138;
  const char *v139;
  id v140;
  const char *v141;
  char *v142;
  NSObject *v143;
  os_log_type_t v144;
  const char *v145;
  const char *v146;
  const char *v147;
  const char *v148;
  const char *v149;
  const char *v150;
  id v151;
  os_log_type_t v152;
  const char *v153;
  const char *v154;
  nw_endpoint_t v155;
  const char *v156;
  const char *v157;
  const char *v158;
  id v159;
  NSObject *v160;
  os_log_type_t v161;
  const char *v162;
  nw_endpoint_t v163;
  char *v164;
  const char *v165;
  const char *v166;
  const char *v167;
  id v168;
  os_log_type_t v169;
  const char *v170;
  const char *v171;
  nw_endpoint_t v172;
  const char *v173;
  const char *v174;
  const char *v175;
  id v176;
  void *v177;
  os_log_type_t v178;
  const char *v179;
  nw_endpoint_t v180;
  char *v181;
  const char *v182;
  const char *v183;
  const char *v184;
  id v185;
  void *v186;
  void *v187;
  char *v188;
  NSObject *v189;
  os_log_type_t v190;
  char *backtrace_string;
  os_log_type_t v192;
  _BOOL4 v193;
  NWConcrete_nw_endpoint_mode_handler *v194;
  NSObject *v195;
  void *v196;
  void *v197;
  os_log_type_t v198;
  void *v199;
  os_log_type_t v200;
  os_log_type_t v201;
  char *v202;
  os_log_type_t v203;
  _BOOL4 v204;
  char *v205;
  os_log_type_t v206;
  _BOOL4 v207;
  os_log_type_t v208;
  os_log_type_t v209;
  NWConcrete_nw_endpoint_handler *v210;
  const char *id_string;
  const char *v212;
  nw_endpoint_t v213;
  const char *v214;
  const char *v215;
  const char *v216;
  id v217;
  uint64_t v218;
  char *v219;
  const char *v220;
  char *v221;
  const char *v222;
  const char *v223;
  char *v224;
  const char *v225;
  char *v226;
  nw_endpoint_t v227;
  char *v228;
  char *v229;
  uint64_t log;
  NSObject *loga;
  nw_endpoint_t logb;
  NSObject *logc;
  NSObject *logd;
  NSObject *loge;
  uint64_t *v236;
  char *v237;
  id v238;
  id v239;
  id v240;
  char v241;
  os_log_type_t v242;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v245;
  __int16 v246;
  uint64_t v247;
  __int16 v248;
  uint64_t v249;
  __int16 v250;
  const char *v251;
  __int16 v252;
  const char *v253;
  __int16 v254;
  const char *v255;
  __int16 v256;
  id v257;
  __int16 v258;
  char *v259;
  __int16 v260;
  uint64_t v261;
  uint64_t v262;

  v262 = *MEMORY[0x1E0C80C00];
  v239 = a2;
  v240 = a3;
  v5 = *(id *)(*(_QWORD *)(a1 + 24) + 160);
  if (!v5)
  {
    v129 = 0;
    __nwlog_obj();
    v187 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v245 = "nw_flow_listener_new_flow";
    v188 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v242 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v188, &type, &v242))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v189 = objc_claimAutoreleasedReturnValue();
        v190 = type;
        if (os_log_type_enabled(v189, type))
        {
          *(_DWORD *)buf = 136446210;
          v245 = "nw_flow_listener_new_flow";
          _os_log_impl(&dword_182FBE000, v189, v190, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v242)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v189 = objc_claimAutoreleasedReturnValue();
        v192 = type;
        v193 = os_log_type_enabled(v189, type);
        if (backtrace_string)
        {
          if (v193)
          {
            *(_DWORD *)buf = 136446466;
            v245 = "nw_flow_listener_new_flow";
            v246 = 2082;
            v247 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v189, v192, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_204;
        }
        if (v193)
        {
          *(_DWORD *)buf = 136446210;
          v245 = "nw_flow_listener_new_flow";
          _os_log_impl(&dword_182FBE000, v189, v192, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v189 = objc_claimAutoreleasedReturnValue();
        v201 = type;
        if (os_log_type_enabled(v189, type))
        {
          *(_DWORD *)buf = 136446210;
          v245 = "nw_flow_listener_new_flow";
          _os_log_impl(&dword_182FBE000, v189, v201, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_204:
    if (v188)
      free(v188);
    v22 = 0;
    goto LABEL_124;
  }
  v238 = v5;
  v6 = (NWConcrete_nw_endpoint_handler *)v5;
  mode = v6->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v35 = (id)gLogObj;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      if (mode > 5)
        v36 = "unknown-mode";
      else
        v36 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v245 = "nw_flow_listener_new_flow";
      v246 = 2082;
      v247 = (uint64_t)v36;
      v248 = 2082;
      v249 = (uint64_t)"flow";
      _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }

    v22 = 0;
    goto LABEL_123;
  }
  v8 = nw_endpoint_handler_copy_flow(v6);
  v236 = (uint64_t *)v8;
  if (!*((_QWORD *)v8 + 96))
  {
    v37 = v6;
    v38 = *((_BYTE *)v37 + 268);

    if ((v38 & 0x20) == 0)
    {
      v39 = v6;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v40 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        v41 = v37;

        v42 = v41;
        v43 = *((_BYTE *)v37 + 268);

        if ((v43 & 1) != 0)
          v44 = "dry-run ";
        else
          v44 = "";
        v45 = nw_endpoint_handler_copy_endpoint(v42);
        logging_description = nw_endpoint_get_logging_description(v45);
        id_str = v41->id_str;
        v48 = v42;
        v49 = v48;
        v50 = v48[30];
        if (v50 > 5)
          v51 = "unknown-state";
        else
          v51 = off_1E149FC48[v50];

        v61 = v49;
        v62 = v61;
        v63 = "path";
        switch(v39->mode)
        {
          case 0:
            break;
          case 1:
            v63 = "resolver";
            break;
          case 2:
            v63 = nw_endpoint_flow_mode_string(v61[31]);
            break;
          case 3:
            v63 = "proxy";
            break;
          case 4:
            v63 = "fallback";
            break;
          case 5:
            v63 = "transform";
            break;
          default:
            v63 = "unknown-mode";
            break;
        }

        v127 = v62;
        os_unfair_lock_lock((os_unfair_lock_t)v127 + 28);
        v128 = v127[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v127 + 28);

        *(_DWORD *)buf = 136447746;
        v245 = "nw_flow_listener_new_flow";
        v246 = 2082;
        v247 = (uint64_t)id_str;
        v248 = 2082;
        v249 = (uint64_t)v44;
        v250 = 2082;
        v251 = logging_description;
        v252 = 2082;
        v253 = v51;
        v254 = 2082;
        v255 = v63;
        v256 = 2114;
        v257 = v128;
        _os_log_impl(&dword_182FBE000, v40, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot receive new flows on non-multiplexed protocols", buf, 0x48u);

      }
    }
    goto LABEL_120;
  }
  v9 = (char *)malloc_type_calloc(1uLL, 0x150uLL, 0xEAFB8F1AuLL);
  v237 = v9;
  if (v9)
  {
LABEL_5:
    nw_endpoint_flow_initialize_protocol(v6, v9, 1);
    v10 = *((_QWORD *)v8 + 97);
    log = v10;
    if (v10)
    {
      if (v9)
      {
        if ((char *)v10 != v9)
        {
          v11 = *(_QWORD **)(v10 + 24);
          if (v11 && *v11)
          {
            if ((nw_protocol_add_input_handler(v10, (uint64_t)v9) & 1) != 0)
            {
              v12 = v10;
              v13 = *(uint64_t (**)(uint64_t, uint64_t, char *))(*(_QWORD *)(v10 + 24) + 224);
              if (v13)
              {
                v14 = v13(v10, 255, v237);
                v15 = (void *)v14;
                if (v14)
                {
                  v16 = *(_QWORD *)(v14 + 24) - *(_QWORD *)(v14 + 16);
                  if (v16)
                  {
                    nw_array_get_object_at_index(v14, (v16 >> 3) - 1);
                    v17 = objc_claimAutoreleasedReturnValue();
                    v18 = (void *)*((_QWORD *)v237 + 30);
                    *((_QWORD *)v237 + 30) = v17;

                  }
                }

                v12 = v10;
              }
              v20 = v236;
              v19 = (uint64_t)v237;
              if (*((_QWORD *)v237 + 30))
              {
                type = OS_LOG_TYPE_DEFAULT;
                v21 = !nw_hash_table_add_object(v236[108], (uint64_t)v237, (char *)&type) || type == OS_LOG_TYPE_DEFAULT;
                v22 = !v21;
                if (!v21)
                {
                  minimize_logging = nw_endpoint_handler_get_minimize_logging(v6);
                  logging_disabled = nw_endpoint_handler_get_logging_disabled(v6);
                  if (minimize_logging)
                  {
                    if ((logging_disabled & 1) != 0)
                      goto LABEL_31;
                    v210 = v6;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v25 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v6);
                      v212 = nw_endpoint_handler_dry_run_string(v6);
                      v213 = nw_endpoint_handler_copy_endpoint(v6);
                      v214 = nw_endpoint_get_logging_description(v213);
                      v215 = nw_endpoint_handler_state_string(v6);
                      v216 = nw_endpoint_handler_mode_string(v6);
                      v217 = nw_endpoint_handler_copy_current_path(v210);
                      v218 = *(_QWORD *)(log + 16);
                      *(_DWORD *)buf = 136448258;
                      v245 = "nw_flow_listener_new_flow";
                      v246 = 2082;
                      v247 = (uint64_t)id_string;
                      v248 = 2082;
                      v249 = (uint64_t)v212;
                      v250 = 2082;
                      v251 = v214;
                      v252 = 2082;
                      v253 = v215;
                      v254 = 2082;
                      v255 = v216;
                      v256 = 2114;
                      v257 = v217;
                      v258 = 2048;
                      v259 = v237;
                      v260 = 2080;
                      v261 = v218;
                      _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added inbound per-message protocol %p to %s", buf, 0x5Cu);

                    }
                  }
                  else
                  {
                    if ((logging_disabled & 1) != 0)
                    {
LABEL_31:
                      (*(void (**)(uint64_t, char *))(*(_QWORD *)(v12 + 24) + 24))(v12, v237);
                      *((_WORD *)v237 + 166) |= 0x400u;
LABEL_122:

LABEL_123:
                      v129 = v238;
LABEL_124:

                      return v22;
                    }
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v25 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
                    {
                      v26 = nw_endpoint_handler_get_id_string(v6);
                      v27 = nw_endpoint_handler_dry_run_string(v6);
                      v28 = nw_endpoint_handler_copy_endpoint(v6);
                      v29 = nw_endpoint_get_logging_description(v28);
                      v30 = nw_endpoint_handler_state_string(v6);
                      v31 = v6;
                      v32 = nw_endpoint_handler_mode_string(v6);
                      v33 = nw_endpoint_handler_copy_current_path(v31);
                      v34 = *(_QWORD *)(log + 16);
                      *(_DWORD *)buf = 136448258;
                      v245 = "nw_flow_listener_new_flow";
                      v246 = 2082;
                      v247 = (uint64_t)v26;
                      v248 = 2082;
                      v249 = (uint64_t)v27;
                      v250 = 2082;
                      v251 = v29;
                      v252 = 2082;
                      v253 = v30;
                      v254 = 2082;
                      v255 = v32;
                      v256 = 2114;
                      v257 = v33;
                      v258 = 2048;
                      v259 = v237;
                      v260 = 2080;
                      v261 = v34;
                      _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added inbound per-message protocol %p to %s", buf, 0x5Cu);

                    }
                  }

                  v20 = v236;
                  v12 = log;
                  goto LABEL_31;
                }
                if ((nw_endpoint_handler_get_logging_disabled(v6) & 1) != 0)
                  goto LABEL_164;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v84 = (id)gconnectionLogObj;
                v85 = nw_endpoint_handler_get_id_string(v6);
                v86 = nw_endpoint_handler_dry_run_string(v6);
                v87 = nw_endpoint_handler_copy_endpoint(v6);
                v88 = nw_endpoint_get_logging_description(v87);
                v89 = nw_endpoint_handler_state_string(v6);
                v90 = v6;
                v91 = nw_endpoint_handler_mode_string(v6);
                v92 = nw_endpoint_handler_copy_current_path(v90);
                *(_DWORD *)buf = 136447746;
                v245 = "nw_flow_listener_new_flow";
                v246 = 2082;
                v247 = (uint64_t)v85;
                v248 = 2082;
                v249 = (uint64_t)v86;
                v250 = 2082;
                v251 = v88;
                v252 = 2082;
                v253 = v89;
                v254 = 2082;
                v255 = v91;
                v6 = v90;
                v256 = 2114;
                v257 = v92;
                v93 = (char *)_os_log_send_and_compose_impl();

                v242 = OS_LOG_TYPE_ERROR;
                v241 = 0;
                if ((__nwlog_fault(v93, &v242, &v241) & 1) != 0)
                {
                  if (v242 == OS_LOG_TYPE_FAULT)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v94 = (id)gconnectionLogObj;
                    v95 = v242;
                    if (os_log_type_enabled(v94, v242))
                    {
                      loga = v94;
                      v96 = nw_endpoint_handler_get_id_string(v90);
                      v97 = nw_endpoint_handler_dry_run_string(v90);
                      v98 = nw_endpoint_handler_copy_endpoint(v90);
                      v219 = v93;
                      v99 = nw_endpoint_get_logging_description(v98);
                      v100 = nw_endpoint_handler_state_string(v90);
                      v101 = nw_endpoint_handler_mode_string(v90);
                      v102 = nw_endpoint_handler_copy_current_path(v90);
                      *(_DWORD *)buf = 136447746;
                      v245 = "nw_flow_listener_new_flow";
                      v246 = 2082;
                      v247 = (uint64_t)v96;
                      v248 = 2082;
                      v249 = (uint64_t)v97;
                      v250 = 2082;
                      v251 = v99;
                      v252 = 2082;
                      v253 = v100;
                      v254 = 2082;
                      v255 = v101;
                      v6 = v90;
                      v256 = 2114;
                      v257 = v102;
                      _os_log_impl(&dword_182FBE000, loga, v95, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table", buf, 0x48u);

                      v93 = v219;
                      v94 = loga;
                    }

                  }
                  else
                  {
                    if (v241)
                    {
                      v141 = __nw_create_backtrace_string();
                      if (v141)
                      {
                        v142 = (char *)v141;
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v143 = (id)gconnectionLogObj;
                        v144 = v242;
                        if (os_log_type_enabled(v143, v242))
                        {
                          logc = v143;
                          v145 = nw_endpoint_handler_get_id_string(v90);
                          v146 = nw_endpoint_handler_dry_run_string(v90);
                          v147 = v145;
                          v221 = v93;
                          v227 = nw_endpoint_handler_copy_endpoint(v90);
                          v148 = nw_endpoint_get_logging_description(v227);
                          v149 = nw_endpoint_handler_state_string(v90);
                          v150 = nw_endpoint_handler_mode_string(v90);
                          v151 = nw_endpoint_handler_copy_current_path(v90);
                          *(_DWORD *)buf = 136448002;
                          v245 = "nw_flow_listener_new_flow";
                          v246 = 2082;
                          v247 = (uint64_t)v147;
                          v248 = 2082;
                          v249 = (uint64_t)v146;
                          v250 = 2082;
                          v251 = v148;
                          v252 = 2082;
                          v253 = v149;
                          v254 = 2082;
                          v255 = v150;
                          v6 = v90;
                          v256 = 2114;
                          v257 = v151;
                          v258 = 2082;
                          v259 = v142;
                          _os_log_impl(&dword_182FBE000, logc, v144, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table, dumping backtrace:%{public}s", buf, 0x52u);

                          v93 = v221;
                          v143 = logc;
                        }

                        free(v142);
                        goto LABEL_162;
                      }
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v160 = (id)gconnectionLogObj;
                      v178 = v242;
                      if (os_log_type_enabled(v160, v242))
                      {
                        v223 = nw_endpoint_handler_get_id_string(v90);
                        v179 = nw_endpoint_handler_dry_run_string(v90);
                        loge = v160;
                        v180 = nw_endpoint_handler_copy_endpoint(v90);
                        v181 = v93;
                        v182 = nw_endpoint_get_logging_description(v180);
                        v183 = nw_endpoint_handler_state_string(v90);
                        v184 = nw_endpoint_handler_mode_string(v90);
                        v185 = nw_endpoint_handler_copy_current_path(v90);
                        *(_DWORD *)buf = 136447746;
                        v245 = "nw_flow_listener_new_flow";
                        v246 = 2082;
                        v247 = (uint64_t)v223;
                        v248 = 2082;
                        v249 = (uint64_t)v179;
                        v250 = 2082;
                        v251 = v182;
                        v252 = 2082;
                        v253 = v183;
                        v254 = 2082;
                        v255 = v184;
                        v6 = v90;
                        v256 = 2114;
                        v257 = v185;
                        _os_log_impl(&dword_182FBE000, loge, v178, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table, no backtrace", buf, 0x48u);

                        v93 = v181;
                        v160 = loge;
                      }
                    }
                    else
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v160 = (id)gconnectionLogObj;
                      v161 = v242;
                      if (os_log_type_enabled(v160, v242))
                      {
                        v222 = nw_endpoint_handler_get_id_string(v90);
                        v162 = nw_endpoint_handler_dry_run_string(v90);
                        logd = v160;
                        v163 = nw_endpoint_handler_copy_endpoint(v90);
                        v164 = v93;
                        v165 = nw_endpoint_get_logging_description(v163);
                        v166 = nw_endpoint_handler_state_string(v90);
                        v167 = nw_endpoint_handler_mode_string(v90);
                        v168 = nw_endpoint_handler_copy_current_path(v90);
                        *(_DWORD *)buf = 136447746;
                        v245 = "nw_flow_listener_new_flow";
                        v246 = 2082;
                        v247 = (uint64_t)v222;
                        v248 = 2082;
                        v249 = (uint64_t)v162;
                        v250 = 2082;
                        v251 = v165;
                        v252 = 2082;
                        v253 = v166;
                        v254 = 2082;
                        v255 = v167;
                        v6 = v90;
                        v256 = 2114;
                        v257 = v168;
                        _os_log_impl(&dword_182FBE000, logd, v161, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound flow protocol to hash table, backtrace limit exceeded", buf, 0x48u);

                        v93 = v164;
                        v160 = logd;
                      }
                    }

                  }
                }
LABEL_162:
                if (v93)
                  free(v93);
LABEL_164:
                nw_endpoint_flow_cleanup_protocol(v6, (uint64_t)v237, 1);
                v186 = (void *)*((_QWORD *)v237 + 23);
                *((_QWORD *)v237 + 23) = 0;

                free(v237);
                goto LABEL_121;
              }
              if ((nw_endpoint_handler_get_logging_disabled(v6) & 1) != 0)
                goto LABEL_156;
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v64 = (id)gconnectionLogObj;
              v65 = nw_endpoint_handler_get_id_string(v6);
              v66 = nw_endpoint_handler_dry_run_string(v6);
              v67 = nw_endpoint_handler_copy_endpoint(v6);
              v68 = nw_endpoint_get_logging_description(v67);
              v69 = nw_endpoint_handler_state_string(v6);
              v70 = v6;
              v71 = nw_endpoint_handler_mode_string(v6);
              v72 = nw_endpoint_handler_copy_current_path(v70);
              *(_DWORD *)buf = 136447746;
              v245 = "nw_flow_listener_new_flow";
              v246 = 2082;
              v247 = (uint64_t)v65;
              v248 = 2082;
              v249 = (uint64_t)v66;
              v250 = 2082;
              v251 = v68;
              v252 = 2082;
              v253 = v69;
              v254 = 2082;
              v255 = v71;
              v6 = v70;
              v256 = 2114;
              v257 = v72;
              v73 = (char *)_os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v242 = OS_LOG_TYPE_DEFAULT;
              if ((__nwlog_fault(v73, &type, &v242) & 1) != 0)
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v74 = (id)gconnectionLogObj;
                  v75 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    v76 = nw_endpoint_handler_get_id_string(v70);
                    v77 = nw_endpoint_handler_dry_run_string(v70);
                    v78 = nw_endpoint_handler_copy_endpoint(v70);
                    v224 = v73;
                    v79 = nw_endpoint_get_logging_description(v78);
                    v80 = nw_endpoint_handler_state_string(v70);
                    v81 = nw_endpoint_handler_mode_string(v70);
                    v82 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    v245 = "nw_flow_listener_new_flow";
                    v246 = 2082;
                    v247 = (uint64_t)v76;
                    v248 = 2082;
                    v249 = (uint64_t)v77;
                    v250 = 2082;
                    v251 = v79;
                    v252 = 2082;
                    v253 = v80;
                    v254 = 2082;
                    v255 = v81;
                    v6 = v70;
                    v256 = 2114;
                    v257 = v82;
                    _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata", buf, 0x48u);

                    v73 = v224;
                  }
                }
                else if (v242)
                {
                  v131 = __nw_create_backtrace_string();
                  if (v131)
                  {
                    v132 = (char *)v131;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v133 = (id)gconnectionLogObj;
                    v134 = type;
                    if (os_log_type_enabled(v133, type))
                    {
                      v135 = nw_endpoint_handler_get_id_string(v70);
                      v136 = nw_endpoint_handler_dry_run_string(v70);
                      v226 = v73;
                      logb = nw_endpoint_handler_copy_endpoint(v70);
                      v137 = nw_endpoint_get_logging_description(logb);
                      v138 = nw_endpoint_handler_state_string(v70);
                      v139 = nw_endpoint_handler_mode_string(v70);
                      v140 = nw_endpoint_handler_copy_current_path(v70);
                      *(_DWORD *)buf = 136448002;
                      v245 = "nw_flow_listener_new_flow";
                      v246 = 2082;
                      v247 = (uint64_t)v135;
                      v248 = 2082;
                      v249 = (uint64_t)v136;
                      v250 = 2082;
                      v251 = v137;
                      v252 = 2082;
                      v253 = v138;
                      v254 = 2082;
                      v255 = v139;
                      v6 = v70;
                      v256 = 2114;
                      v257 = v140;
                      v258 = 2082;
                      v259 = v132;
                      _os_log_impl(&dword_182FBE000, v133, v134, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata, dumping backtrace:%{public}s", buf, 0x52u);

                      v73 = v226;
                    }

                    free(v132);
                    goto LABEL_154;
                  }
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v74 = (id)gconnectionLogObj;
                  v169 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    v170 = nw_endpoint_handler_get_id_string(v70);
                    v171 = nw_endpoint_handler_dry_run_string(v70);
                    v172 = nw_endpoint_handler_copy_endpoint(v70);
                    v229 = v73;
                    v173 = nw_endpoint_get_logging_description(v172);
                    v174 = nw_endpoint_handler_state_string(v70);
                    v175 = nw_endpoint_handler_mode_string(v70);
                    v176 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    v245 = "nw_flow_listener_new_flow";
                    v246 = 2082;
                    v247 = (uint64_t)v170;
                    v248 = 2082;
                    v249 = (uint64_t)v171;
                    v250 = 2082;
                    v251 = v173;
                    v252 = 2082;
                    v253 = v174;
                    v254 = 2082;
                    v255 = v175;
                    v6 = v70;
                    v256 = 2114;
                    v257 = v176;
                    _os_log_impl(&dword_182FBE000, v74, v169, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata, no backtrace", buf, 0x48u);

                    v73 = v229;
                  }
                }
                else
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v74 = (id)gconnectionLogObj;
                  v152 = type;
                  if (os_log_type_enabled(v74, type))
                  {
                    v153 = nw_endpoint_handler_get_id_string(v70);
                    v154 = nw_endpoint_handler_dry_run_string(v70);
                    v155 = nw_endpoint_handler_copy_endpoint(v70);
                    v228 = v73;
                    v156 = nw_endpoint_get_logging_description(v155);
                    v157 = nw_endpoint_handler_state_string(v70);
                    v158 = nw_endpoint_handler_mode_string(v70);
                    v159 = nw_endpoint_handler_copy_current_path(v70);
                    *(_DWORD *)buf = 136447746;
                    v245 = "nw_flow_listener_new_flow";
                    v246 = 2082;
                    v247 = (uint64_t)v153;
                    v248 = 2082;
                    v249 = (uint64_t)v154;
                    v250 = 2082;
                    v251 = v156;
                    v252 = 2082;
                    v253 = v157;
                    v254 = 2082;
                    v255 = v158;
                    v6 = v70;
                    v256 = 2114;
                    v257 = v159;
                    _os_log_impl(&dword_182FBE000, v74, v152, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find inbound flow metadata, backtrace limit exceeded", buf, 0x48u);

                    v73 = v228;
                  }
                }

              }
LABEL_154:
              v19 = (uint64_t)v237;
              if (v73)
                free(v73);
LABEL_156:
              nw_endpoint_flow_cleanup_protocol(v6, v19, 1);
              v177 = *(void **)(v19 + 184);
              *(_QWORD *)(v19 + 184) = 0;

LABEL_112:
              free(v237);
LABEL_120:
              v22 = 0;
LABEL_121:
              v20 = v236;
              goto LABEL_122;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v56 = (id)gLogObj;
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v245 = "nw_protocol_utilities_add_input_handler";
              v246 = 2048;
              v247 = v10;
              _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
            }

          }
LABEL_92:
          v104 = v6;
          v105 = (*((_BYTE *)v104 + 268) & 0x20) == 0;

          if (v105)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v106 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
            {
              v107 = v104;

              v108 = v107;
              v109 = (*((_BYTE *)v104 + 268) & 1) == 0;

              if (v109)
                v110 = "";
              else
                v110 = "dry-run ";
              v111 = nw_endpoint_handler_copy_endpoint(v108);
              v112 = nw_endpoint_get_logging_description(v111);
              v113 = v108;
              v114 = v113;
              v115 = v113[30];
              if (v115 > 5)
                v116 = "unknown-state";
              else
                v116 = off_1E149FC48[v115];
              v225 = v116;

              v117 = v114;
              v118 = "path";
              switch(v6->mode)
              {
                case 0:
                  break;
                case 1:
                  v118 = "resolver";
                  break;
                case 2:
                  v118 = nw_endpoint_flow_mode_string(v117[31]);
                  break;
                case 3:
                  v118 = "proxy";
                  break;
                case 4:
                  v118 = "fallback";
                  break;
                case 5:
                  v118 = "transform";
                  break;
                default:
                  v118 = "unknown-mode";
                  break;
              }
              v220 = v118;

              v119 = v106;
              v120 = v112;
              v121 = v117;
              os_unfair_lock_lock((os_unfair_lock_t)v121 + 28);
              v122 = v121[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v121 + 28);

              v123 = v120;
              v106 = v119;
              v124 = (char *)*((_QWORD *)v237 + 2);
              v125 = *(_QWORD *)(log + 16);
              *(_DWORD *)buf = 136448258;
              v245 = "nw_flow_listener_new_flow";
              v246 = 2082;
              v247 = (uint64_t)v107->id_str;
              v248 = 2082;
              v249 = (uint64_t)v110;
              v250 = 2082;
              v251 = v123;
              v252 = 2082;
              v253 = v225;
              v254 = 2082;
              v255 = v220;
              v256 = 2114;
              v257 = v122;
              v258 = 2082;
              v259 = v124;
              v260 = 2082;
              v261 = v125;
              _os_log_impl(&dword_182FBE000, v119, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add inbound protocol %{public}s to %{public}s", buf, 0x5Cu);

            }
          }
          nw_endpoint_flow_cleanup_protocol(v104, (uint64_t)v237, 1);
          v126 = (void *)*((_QWORD *)v237 + 23);
          *((_QWORD *)v237 + 23) = 0;

          goto LABEL_112;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v52 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v245 = "nw_protocol_utilities_add_input_handler";
        v246 = 2048;
        v247 = (uint64_t)v9;
        v53 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v242 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v53, &type, &v242))
          goto LABEL_90;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = (id)gLogObj;
          v55 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            v245 = "nw_protocol_utilities_add_input_handler";
            v246 = 2048;
            v247 = (uint64_t)v237;
            _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
          }
        }
        else if (v242)
        {
          v57 = __nw_create_backtrace_string();
          if (v57)
          {
            v58 = (char *)v57;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v59 = (id)gLogObj;
            v60 = type;
            if (os_log_type_enabled(v59, type))
            {
              *(_DWORD *)buf = 136446722;
              v245 = "nw_protocol_utilities_add_input_handler";
              v246 = 2048;
              v247 = (uint64_t)v237;
              v248 = 2082;
              v249 = (uint64_t)v58;
              _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v58);
            if (!v53)
              goto LABEL_92;
            goto LABEL_91;
          }
          __nwlog_obj();
          v54 = objc_claimAutoreleasedReturnValue();
          v103 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            v245 = "nw_protocol_utilities_add_input_handler";
            v246 = 2048;
            v247 = (uint64_t)v237;
            _os_log_impl(&dword_182FBE000, v54, v103, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v54 = (id)gLogObj;
          v83 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446466;
            v245 = "nw_protocol_utilities_add_input_handler";
            v246 = 2048;
            v247 = (uint64_t)v237;
            _os_log_impl(&dword_182FBE000, v54, v83, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
          }
        }
        goto LABEL_89;
      }
      __nwlog_obj();
      v199 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v245 = "nw_protocol_utilities_add_input_handler";
      v53 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v242 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v53, &type, &v242))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v54 = objc_claimAutoreleasedReturnValue();
          v200 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v54, v200, "%{public}s called with null input_protocol", buf, 0xCu);
          }
        }
        else if (v242)
        {
          v205 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v54 = objc_claimAutoreleasedReturnValue();
          v206 = type;
          v207 = os_log_type_enabled(v54, type);
          if (v205)
          {
            if (v207)
            {
              *(_DWORD *)buf = 136446466;
              v245 = "nw_protocol_utilities_add_input_handler";
              v246 = 2082;
              v247 = (uint64_t)v205;
              _os_log_impl(&dword_182FBE000, v54, v206, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v205);
            if (!v53)
              goto LABEL_92;
            goto LABEL_91;
          }
          if (v207)
          {
            *(_DWORD *)buf = 136446210;
            v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v54, v206, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v54 = objc_claimAutoreleasedReturnValue();
          v209 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            v245 = "nw_protocol_utilities_add_input_handler";
            _os_log_impl(&dword_182FBE000, v54, v209, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_89;
      }
LABEL_90:
      if (!v53)
        goto LABEL_92;
LABEL_91:
      free(v53);
      goto LABEL_92;
    }
    __nwlog_obj();
    v197 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v245 = "nw_protocol_utilities_add_input_handler";
    v53 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v242 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v53, &type, &v242))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v198 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446210;
        v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_182FBE000, v54, v198, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v242)
    {
      v202 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v203 = type;
      v204 = os_log_type_enabled(v54, type);
      if (v202)
      {
        if (v204)
        {
          *(_DWORD *)buf = 136446466;
          v245 = "nw_protocol_utilities_add_input_handler";
          v246 = 2082;
          v247 = (uint64_t)v202;
          _os_log_impl(&dword_182FBE000, v54, v203, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v202);
        goto LABEL_90;
      }
      if (v204)
      {
        *(_DWORD *)buf = 136446210;
        v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_182FBE000, v54, v203, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v208 = type;
      if (os_log_type_enabled(v54, type))
      {
        *(_DWORD *)buf = 136446210;
        v245 = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_182FBE000, v54, v208, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_89:

    goto LABEL_90;
  }
  v194 = v8;
  __nwlog_obj();
  v195 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v195, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v245 = "strict_calloc";
  v246 = 2048;
  v247 = 1;
  v248 = 2048;
  v249 = 336;
  v196 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v196);
  if (!result)
  {
    free(v196);
    v8 = v194;
    v9 = 0;
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

void sub_183116D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23)
{
  void *v23;
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_udp_copy_info(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, _QWORD *);
  void *v9;
  uint64_t v10;
  _QWORD *v11;
  _BOOL8 result;
  uint64_t v13;
  uint64_t v14;
  void (**v15)(_QWORD);
  const void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  char *v29;
  _BOOL4 v30;
  NSObject *v31;
  void *v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_udp_copy_info";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v17, &type, &v33))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_udp_copy_info";
        v20 = "%{public}s called with null protocol";
LABEL_66:
        _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
      }
LABEL_67:
      if (v17)
        free(v17);
      return 0;
    }
    if (!v33)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_udp_copy_info";
        v20 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v26 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_udp_copy_info";
        v20 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_udp_copy_info";
      v37 = 2082;
      v38 = (uint64_t)backtrace_string;
      v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_47:
      _os_log_impl(&dword_182FBE000, v18, v19, v27, buf, 0x16u);
    }
LABEL_48:
    free(backtrace_string);
    goto LABEL_67;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_udp_copy_info";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v17, &type, &v33))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_udp_copy_info";
        v20 = "%{public}s called with null udp";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    if (!v33)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_udp_copy_info";
        v20 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v28 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_udp_copy_info";
        v20 = "%{public}s called with null udp, no backtrace";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "nw_protocol_udp_copy_info";
      v37 = 2082;
      v38 = (uint64_t)backtrace_string;
      v27 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_47;
    }
    goto LABEL_48;
  }
  v5 = a2;
  v6 = *(_QWORD *)(a1 + 32);
  if (!v6
    || (v7 = *(_QWORD *)(v6 + 24)) == 0
    || (v8 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD *))(v7 + 224)) == 0)
  {
    v11 = 0;
    goto LABEL_12;
  }
  v9 = *(void **)(v6 + 40);
  if (v9 == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v6 + 88);
    if (v10)
      *(_QWORD *)(v6 + 88) = v10 + 1;
  }
  if ((_DWORD)a2)
  {
    v11 = (_QWORD *)v8(v6, a2, a3);
    if (v9 != &nw_protocol_ref_counted_handle)
      goto LABEL_12;
    goto LABEL_11;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v36 = "__nw_protocol_copy_info";
  v21 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v21, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_73;
      *(_DWORD *)buf = 136446210;
      v36 = "__nw_protocol_copy_info";
      v24 = "%{public}s called with null type";
LABEL_72:
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
      goto LABEL_73;
    }
    if (!v33)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_73;
      *(_DWORD *)buf = 136446210;
      v36 = "__nw_protocol_copy_info";
      v24 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_72;
    }
    v29 = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v30 = os_log_type_enabled(v22, type);
    if (!v29)
    {
      if (!v30)
        goto LABEL_73;
      *(_DWORD *)buf = 136446210;
      v36 = "__nw_protocol_copy_info";
      v24 = "%{public}s called with null type, no backtrace";
      goto LABEL_72;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "__nw_protocol_copy_info";
      v37 = 2082;
      v38 = (uint64_t)v29;
      _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null type, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v29);
  }
LABEL_73:
  if (v21)
    free(v21);
  v11 = 0;
  if (v9 == &nw_protocol_ref_counted_handle)
  {
LABEL_11:
    if (*(_UNKNOWN **)(v6 + 40) == &nw_protocol_ref_counted_handle)
    {
      v13 = *(_QWORD *)(v6 + 88);
      if (v13)
      {
        v14 = v13 - 1;
        *(_QWORD *)(v6 + 88) = v14;
        if (!v14)
        {
          v15 = *(void (***)(_QWORD))(v6 + 64);
          if (v15)
          {
            *(_QWORD *)(v6 + 64) = 0;
            v15[2](v15);
            _Block_release(v15);
          }
          if ((*(_BYTE *)(v6 + 72) & 1) != 0)
          {
            v16 = *(const void **)(v6 + 64);
            if (v16)
              _Block_release(v16);
          }
          free((void *)v6);
        }
      }
    }
  }
LABEL_12:
  if (v5 != 5)
    return (BOOL)v11;
  if (v11 || (v11 = malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL)) != 0)
  {
LABEL_15:
    v11[6] = *(_QWORD *)(a1 + 104);
    v11[9] = *(_QWORD *)(a1 + 96);
    if (a3)
      *a3 = 184;
    return (BOOL)v11;
  }
  v31 = __nwlog_obj();
  os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v36 = "strict_calloc";
  v37 = 2048;
  v38 = 1;
  v39 = 2048;
  v40 = 184;
  v32 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v32);
  if (!result)
  {
    free(v32);
    v11 = 0;
    goto LABEL_15;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_ipv4_copy_info(uint64_t a1, int a2, _QWORD *a3)
{
  char *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  NSObject *v13;
  void *v14;
  _BOOL8 result;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv4_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_36;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_36;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_ipv4_copy_info";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v11)
          goto LABEL_36;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_ipv4_copy_info";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_ipv4_copy_info";
        v21 = 2082;
        v22 = (uint64_t)backtrace_string;
        v12 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
        _os_log_impl(&dword_182FBE000, v7, v8, v12, buf, 0x16u);
      }
LABEL_26:
      free(backtrace_string);
      goto LABEL_36;
    }
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv4_copy_info";
    v9 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
LABEL_36:
    if (v6)
      free(v6);
    return 0;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv4_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv4_copy_info";
      v9 = "%{public}s called with null ipv4";
      goto LABEL_35;
    }
    if (!v17)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_ipv4_copy_info";
      v9 = "%{public}s called with null ipv4, backtrace limit exceeded";
      goto LABEL_35;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v16 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_ipv4_copy_info";
        v21 = 2082;
        v22 = (uint64_t)backtrace_string;
        v12 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
        goto LABEL_25;
      }
      goto LABEL_26;
    }
    if (!v16)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_ipv4_copy_info";
    v9 = "%{public}s called with null ipv4, no backtrace";
    goto LABEL_35;
  }
  if (a2 != 5)
    return 0;
  v5 = (char *)malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
  if (v5)
    goto LABEL_5;
  v13 = __nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v20 = "strict_calloc";
  v21 = 2048;
  v22 = 1;
  v23 = 2048;
  v24 = 184;
  v14 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
LABEL_5:
    *(_OWORD *)(v5 + 8) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(v5 + 24) = *(_OWORD *)(a1 + 120);
    *((_QWORD *)v5 + 5) = *(_QWORD *)(a1 + 96);
    if (a3)
      *a3 = 184;
    return (BOOL)v5;
  }
  __break(1u);
  return result;
}

void ____nwlog_tcp_log_block_invoke()
{
  if ((gHasForked & 1) == 0)
    gtcpLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "tcp");
}

id *nw_protocol_instance_copy_association(void *a1)
{
  void **v1;
  void **v2;
  void *v3;
  id *v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[5];
    if (v3)
    {
      v4 = nw_endpoint_copy_association_with_evaluator(v3, v2[6], 0);
      goto LABEL_4;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_instance_copy_association";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null instance->endpoint", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v19)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null instance->endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null instance->endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_protocol_instance_copy_association";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null instance->endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_instance_copy_association";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v19)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_protocol_instance_copy_association";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_protocol_instance_copy_association";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_183117FCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_path_is_equal(nw_path_t path, nw_path_t other_path)
{
  return nw_path_is_equal_inner(path, other_path, 0);
}

uint64_t destroy for NWInterface()
{
  return swift_unknownObjectRelease();
}

BOOL nw_endpoint_flow_pre_attach_protocols(void *a1, nw_protocol *a2)
{
  id v3;
  void *v4;
  NWConcrete_nw_endpoint_handler *v5;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v7;
  nw_endpoint_t v8;
  void *v9;
  _BOOL8 v10;
  id v11;
  const char *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  const char *v20;
  NWConcrete_nw_endpoint_handler *v21;
  NWConcrete_nw_path *v22;
  NWConcrete_nw_endpoint_handler *v23;
  OS_nw_parameters *v24;
  double v25;
  double Helper_x8__ne_filter_protocol_identifier;
  uint64_t v27;
  uint64_t inited;
  os_log_type_t v29;
  const char *v30;
  _BOOL4 v31;
  const char *v32;
  int v33;
  uint64_t v34;
  void *v36;
  os_log_type_t v37;
  void *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  char *backtrace_string;
  os_log_type_t v43;
  _BOOL4 v44;
  char *v45;
  os_log_type_t v46;
  _BOOL4 v47;
  os_log_type_t v48;
  os_log_type_t v49;
  char v50;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  void *v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_endpoint_flow_pre_attach_protocols";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v13, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          _os_log_impl(&dword_182FBE000, v14, v37, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v50)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v43 = type;
        v44 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            v53 = "nw_endpoint_flow_pre_attach_protocols";
            v54 = 2082;
            v55 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v43, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v13)
            goto LABEL_56;
          goto LABEL_55;
        }
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          _os_log_impl(&dword_182FBE000, v14, v43, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          _os_log_impl(&dword_182FBE000, v14, v48, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_53;
    }
LABEL_54:
    if (!v13)
    {
LABEL_56:
      v10 = 0;
      goto LABEL_57;
    }
LABEL_55:
    free(v13);
    goto LABEL_56;
  }
  v5 = (NWConcrete_nw_endpoint_handler *)v3;
  mode = v5->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (mode > 5)
      v12 = "unknown-mode";
    else
      v12 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v53 = "nw_endpoint_flow_pre_attach_protocols";
    v54 = 2082;
    v55 = (void *)v12;
    v56 = 2082;
    v57 = "flow";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v13, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          if (mode > 5)
            v16 = "unknown-mode";
          else
            v16 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          v54 = 2082;
          v55 = (void *)v16;
          v56 = 2082;
          v57 = "flow";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v50)
      {
        v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v18 = type;
        v19 = os_log_type_enabled(v14, type);
        if (v17)
        {
          if (v19)
          {
            if (mode > 5)
              v20 = "unknown-mode";
            else
              v20 = off_1E149FC18[mode];
            *(_DWORD *)buf = 136446978;
            v53 = "nw_endpoint_flow_pre_attach_protocols";
            v54 = 2082;
            v55 = (void *)v20;
            v56 = 2082;
            v57 = "flow";
            v58 = 2082;
            v59 = v17;
            _os_log_impl(&dword_182FBE000, v14, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v17);
          if (!v13)
            goto LABEL_56;
          goto LABEL_55;
        }
        if (v19)
        {
          if (mode > 5)
            v32 = "unknown-mode";
          else
            v32 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          v54 = 2082;
          v55 = (void *)v32;
          v56 = 2082;
          v57 = "flow";
          _os_log_impl(&dword_182FBE000, v14, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v14, type))
        {
          if (mode > 5)
            v30 = "unknown-mode";
          else
            v30 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          v54 = 2082;
          v55 = (void *)v30;
          v56 = 2082;
          v57 = "flow";
          _os_log_impl(&dword_182FBE000, v14, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
LABEL_53:

      goto LABEL_54;
    }
    goto LABEL_54;
  }
  v7 = nw_endpoint_handler_copy_flow(v5);
  if ((*((_BYTE *)v7 + 32) & 2) == 0)
  {
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_endpoint_flow_pre_attach_protocols";
    v39 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (__nwlog_fault(v39, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s called with null endpoint_flow->is_leaf_flow_handler", buf, 0xCu);
        }
      }
      else if (v50)
      {
        v45 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        v47 = os_log_type_enabled(v40, type);
        if (v45)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            v53 = "nw_endpoint_flow_pre_attach_protocols";
            v54 = 2082;
            v55 = v45;
            _os_log_impl(&dword_182FBE000, v40, v46, "%{public}s called with null endpoint_flow->is_leaf_flow_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v45);
          goto LABEL_91;
        }
        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          _os_log_impl(&dword_182FBE000, v40, v46, "%{public}s called with null endpoint_flow->is_leaf_flow_handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v49 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)buf = 136446210;
          v53 = "nw_endpoint_flow_pre_attach_protocols";
          _os_log_impl(&dword_182FBE000, v40, v49, "%{public}s called with null endpoint_flow->is_leaf_flow_handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_91:
    if (v39)
      free(v39);
    v10 = 0;
    goto LABEL_43;
  }
  nw_endpoint_handler_initialize_association(v5);
  nw_endpoint_flow_initialize_protocol(v5, (uint64_t)v7 + 376, *((_BYTE *)v7 + 32) & 1);
  if (!a2)
  {
    v21 = v5;
    os_unfair_lock_lock(&v21->lock);
    v22 = v21->current_path;
    os_unfair_lock_unlock(&v21->lock);

    v23 = v21;
    v24 = v23->parameters;

    if (nw_endpoint_flow_should_add_filter(v24, v22))
    {
      Helper_x8__ne_filter_protocol_identifier = gotLoadHelper_x8__ne_filter_protocol_identifier(v25);
      if (*(_QWORD *)(v27 + 1960))
        inited = ne_filter_protocol_identifier_delayInitStub(Helper_x8__ne_filter_protocol_identifier);
      else
        inited = 0;
      v31 = inited != 0;
      if ((*((_DWORD *)v7 + 225) & 0x80000000) == 0)
        goto LABEL_40;
    }
    else
    {
      v31 = 1;
      if ((*((_DWORD *)v7 + 225) & 0x80000000) == 0)
        goto LABEL_40;
    }
    if (v31 && v22 && nw_path_uses_nexus_internal(v22, 0))
    {
      v33 = *((unsigned __int8 *)v7 + 34);
      *((_BYTE *)v7 + 33) = ~(32 * v33) & 0x40 | *((_BYTE *)v7 + 33) & 0xBF;
      if ((~(32 * v33) & 0x40) != 0)
      {
        v34 = nw_endpoint_flow_setup_channel(v23);
LABEL_42:
        v10 = v34;

        goto LABEL_43;
      }
LABEL_41:
      v34 = nw_endpoint_flow_setup_protocols(v23, 0, 0, 0, 0);
      goto LABEL_42;
    }
LABEL_40:
    *((_BYTE *)v7 + 33) &= ~0x40u;
    goto LABEL_41;
  }
  *((_BYTE *)v7 + 34) |= 0x40u;
  v8 = nw_endpoint_handler_copy_endpoint(v5);
  v9 = (void *)*((_QWORD *)v7 + 121);
  *((_QWORD *)v7 + 121) = v8;

  v10 = nw_endpoint_flow_setup_protocols(v5, 0, a2, 0, 1);
LABEL_43:

LABEL_57:
  return v10;
}

void sub_183118988(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_path_flow_registration *nw_path_flow_registration_create_internal()
{
  NWConcrete_nw_path_flow_registration *v0;
  NWConcrete_nw_path_flow_registration *v1;
  NWConcrete_nw_path_flow_registration *v2;
  id v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v0 = objc_alloc_init(NWConcrete_nw_path_flow_registration);
  v1 = v0;
  if (v0)
  {
    v2 = v0;
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "nw_path_flow_registration_create_internal";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12))
    goto LABEL_8;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      v15 = "nw_path_flow_registration_create_internal";
      _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow_registration) alloc] init] failed", buf, 0xCu);
    }
LABEL_7:

LABEL_8:
    if (!v4)
      goto LABEL_10;
LABEL_9:
    free(v4);
    goto LABEL_10;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    v11 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      v15 = "nw_path_flow_registration_create_internal";
      _os_log_impl(&dword_182FBE000, v5, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow_registration) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_7;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  v9 = type;
  v10 = os_log_type_enabled(v5, type);
  if (!backtrace_string)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      v15 = "nw_path_flow_registration_create_internal";
      _os_log_impl(&dword_182FBE000, v5, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow_registration) alloc] init] failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_7;
  }
  if (v10)
  {
    *(_DWORD *)buf = 136446466;
    v15 = "nw_path_flow_registration_create_internal";
    v16 = 2082;
    v17 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v5, v9, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path_flow_registration) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v4)
    goto LABEL_9;
LABEL_10:

  return v1;
}

uint64_t ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v8;
  id v9;
  int minimize_logging;
  char logging_disabled;
  NSObject *v12;
  const char *v13;
  const char *v14;
  nw_endpoint_t v15;
  const char *v16;
  const char *v17;
  const char *v18;
  id v19;
  uint64_t v20;
  uint64_t protocol_handle;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  const char *v28;
  id v29;
  char *v30;
  void *v31;
  const char *v32;
  void *v33;
  char v34;
  uint64_t v35;
  void *v36;
  id v37;
  void *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(const char *);
  void *v43;
  id v44;
  uint64_t v45;
  void *v46;
  char *identifier;
  uint64_t registered_endpoint;
  int v49;
  void *v50;
  void *v51;
  void *v52;
  id v53;
  unsigned int *v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v61;
  id v62;
  void *v63;
  id v64;
  const char *v65;
  NSObject *v66;
  nw_endpoint_t v67;
  const char *v68;
  const char *v69;
  id v70;
  char *v71;
  NSObject *v72;
  os_log_type_t v73;
  const char *v74;
  char *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  const char *v78;
  os_log_type_t v79;
  const char *v80;
  NSObject *v81;
  const char *v82;
  const char *v83;
  nw_endpoint_t v84;
  const char *v85;
  const char *v86;
  const char *v87;
  id v88;
  char *v89;
  const char *v90;
  uint64_t v91;
  uint64_t protocol_for_definition;
  void *v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  id v98;
  uint64_t v99;
  NSObject *v100;
  const char *v101;
  const char *v102;
  nw_endpoint_t v103;
  const char *v104;
  const char *v105;
  const char *v106;
  id v107;
  id v108;
  char *v109;
  NSObject *v110;
  os_log_type_t v111;
  NSObject *v112;
  char v113;
  char *v114;
  NSObject *v115;
  os_log_type_t v116;
  _BOOL4 v117;
  uint64_t v118;
  os_log_type_t v119;
  const char *v120;
  const char *v121;
  nw_endpoint_t v122;
  const char *v123;
  const char *v124;
  const char *v125;
  id v126;
  char v128;
  uint64_t v129;
  NSObject *v130;
  const char *v131;
  const char *v132;
  nw_endpoint_t v133;
  const char *v134;
  const char *v135;
  const char *v136;
  id v137;
  uint64_t v138;
  char v139;
  NSObject *v140;
  const char *v141;
  const char *v142;
  nw_endpoint_t v143;
  const char *v144;
  const char *v145;
  const char *v146;
  id v147;
  id v148;
  const char *v149;
  const char *v150;
  nw_endpoint_t v151;
  const char *v152;
  const char *v153;
  const char *v154;
  id v155;
  char *v156;
  NSObject *v157;
  os_log_type_t v158;
  const char *v159;
  const char *v160;
  nw_endpoint_t v161;
  const char *v162;
  const char *v163;
  const char *v164;
  id v165;
  const char *v166;
  char *v167;
  NSObject *v168;
  os_log_type_t v169;
  const char *v170;
  const char *v171;
  const char *v172;
  const char *v173;
  const char *v174;
  id v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t (*v178)(uint64_t, uint64_t, _QWORD);
  uint64_t v179;
  void *v180;
  char v181;
  os_log_type_t v182;
  const char *v183;
  const char *v184;
  nw_endpoint_t v185;
  const char *v186;
  const char *v187;
  const char *v188;
  id v189;
  uint64_t v190;
  char v191;
  NSObject *v192;
  const char *v193;
  const char *v194;
  const char *v195;
  const char *v196;
  const char *v197;
  id v198;
  void *v199;
  const char *v200;
  const char *v201;
  os_log_type_t v202;
  const char *v203;
  const char *v204;
  nw_endpoint_t v205;
  const char *v206;
  const char *v207;
  const char *v208;
  id v209;
  const char *id_string;
  const char *v211;
  nw_endpoint_t v212;
  const char *logging_description;
  const char *v214;
  const char *v215;
  id v216;
  void *v217;
  const char *v218;
  char *v219;
  NSObject *v220;
  os_log_type_t v221;
  const char *v222;
  void *v223;
  char *v224;
  NSObject *v225;
  os_log_type_t v226;
  char *backtrace_string;
  NSObject *v228;
  os_log_type_t v229;
  _BOOL4 v230;
  const char *v231;
  void *v232;
  NSObject *v233;
  os_log_type_t v234;
  void *v235;
  char *v236;
  NSObject *v237;
  os_log_type_t v238;
  char *v239;
  NSObject *v240;
  os_log_type_t v241;
  _BOOL4 v242;
  os_log_type_t v243;
  const char *v244;
  void *v245;
  os_log_type_t v246;
  char *v247;
  os_log_type_t v248;
  _BOOL4 v249;
  void *v250;
  os_log_type_t v251;
  void *v252;
  os_log_type_t v253;
  char *v254;
  NSObject *v255;
  os_log_type_t v256;
  _BOOL4 v257;
  const char *v258;
  os_log_type_t v259;
  os_log_type_t v260;
  _BOOL4 v261;
  os_log_type_t v262;
  _BOOL4 v263;
  os_log_type_t v264;
  _BOOL4 v265;
  os_log_type_t v266;
  os_log_type_t v267;
  os_log_type_t v268;
  os_log_type_t v269;
  os_log_type_t v270;
  NSObject *v271;
  const char *v272;
  const char *v273;
  id v274;
  void *v275;
  const char *v276;
  const char *v277;
  const char *v278;
  const char *v279;
  const char *v280;
  const char *v281;
  const char *v282;
  const char *v283;
  nw_endpoint_t v284;
  void *v285;
  id v286;
  id v287;
  nw_endpoint_t v288;
  nw_endpoint_t v289;
  id v290;
  const char *v291;
  nw_endpoint_t v292;
  void *v293;
  void *v294;
  char v295;
  os_log_type_t type[8];
  char v297;
  os_log_type_t v298;
  _BYTE buf[12];
  __int16 v300;
  uint64_t v301;
  __int16 v302;
  const char *v303;
  __int16 v304;
  void *v305;
  __int16 v306;
  const char *v307;
  __int16 v308;
  const char *v309;
  __int16 v310;
  id v311;
  __int16 v312;
  char *v313;
  __int16 v314;
  uint64_t v315;
  uint64_t v316;

  v316 = *MEMORY[0x1E0C80C00];
  v8 = a3;
  v9 = a4;
  v293 = v9;
  v294 = v8;
  if (nw_protocol_options_is_custom_ip(v9))
  {
    minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 32));
    logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
    if (minimize_logging)
    {
      if ((logging_disabled & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          v211 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          v212 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          logging_description = nw_endpoint_get_logging_description(v212);
          v214 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          v215 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          v216 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          *(_DWORD *)buf = 136448002;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
          v300 = 2082;
          v301 = (uint64_t)id_string;
          v302 = 2082;
          v303 = v211;
          v304 = 2082;
          v305 = (void *)logging_description;
          v306 = 2082;
          v307 = v214;
          v308 = 2082;
          v309 = v215;
          v310 = 2114;
          v311 = v216;
          v312 = 1024;
          LODWORD(v313) = nw_custom_ip_options_get_protocol(v293);
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Using custom IP protocol %u as a proxied protocol, not attaching any proxied transport", buf, 0x4Eu);

        }
        goto LABEL_8;
      }
    }
    else if ((logging_disabled & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v12 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        v13 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        v14 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        v15 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        v16 = nw_endpoint_get_logging_description(v15);
        v17 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        v18 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        v19 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136448002;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
        v300 = 2082;
        v301 = (uint64_t)v13;
        v302 = 2082;
        v303 = v14;
        v304 = 2082;
        v305 = (void *)v16;
        v306 = 2082;
        v307 = v17;
        v308 = 2082;
        v309 = v18;
        v310 = 2114;
        v311 = v19;
        v312 = 1024;
        LODWORD(v313) = nw_custom_ip_options_get_protocol(v293);
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Using custom IP protocol %u as a proxied protocol, not attaching any proxied transport", buf, 0x4Eu);

      }
LABEL_8:

LABEL_9:
      v20 = 1;
      v9 = v293;
      goto LABEL_193;
    }
LABEL_12:
    v20 = 1;
    goto LABEL_193;
  }
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24))
  {
    protocol_handle = nw_protocol_options_get_protocol_handle(v9);
    if (protocol_handle != *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24))
      goto LABEL_12;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) = protocol_handle;
    v32 = *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24);
    if (v32)
    {
      v33 = (void *)*((_QWORD *)v32 + 5);
      if (v33 == &nw_protocol_ref_counted_handle)
      {
        v40 = *((_QWORD *)v32 + 11);
        if (v40)
          *((_QWORD *)v32 + 11) = v40 + 1;
        v34 = -1;
      }
      else
      {
        v34 = 0;
      }
      *(_QWORD *)type = v32;
      v297 = v34;
      v41 = *((_QWORD *)v32 + 3);
      if (v41)
      {
        v42 = *(void (**)(const char *))(v41 + 136);
        if (v42)
        {
          v42(v32);
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          if (v33 != &nw_protocol_ref_counted_handle)
            goto LABEL_40;
          goto LABEL_39;
        }
      }
      __nwlog_obj();
      v217 = (void *)objc_claimAutoreleasedReturnValue();
      v218 = (const char *)*((_QWORD *)v32 + 2);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
      if (!v218)
        v218 = "invalid";
      v300 = 2082;
      v301 = (uint64_t)v218;
      v302 = 2048;
      v303 = v32;
      v219 = (char *)_os_log_send_and_compose_impl();

      v298 = OS_LOG_TYPE_ERROR;
      v295 = 0;
      if (__nwlog_fault(v219, &v298, &v295))
      {
        if (v298 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v220 = objc_claimAutoreleasedReturnValue();
          v221 = v298;
          if (os_log_type_enabled(v220, v298))
          {
            v222 = (const char *)*((_QWORD *)v32 + 2);
            if (!v222)
              v222 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
            v300 = 2082;
            v301 = (uint64_t)v222;
            v302 = 2048;
            v303 = v32;
            _os_log_impl(&dword_182FBE000, v220, v221, "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback", buf, 0x20u);
          }
LABEL_285:

          goto LABEL_348;
        }
        if (!v295)
        {
          __nwlog_obj();
          v220 = objc_claimAutoreleasedReturnValue();
          v243 = v298;
          if (os_log_type_enabled(v220, v298))
          {
            v244 = (const char *)*((_QWORD *)v32 + 2);
            if (!v244)
              v244 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
            v300 = 2082;
            v301 = (uint64_t)v244;
            v302 = 2048;
            v303 = v32;
            _os_log_impl(&dword_182FBE000, v220, v243, "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded", buf, 0x20u);
          }
          goto LABEL_285;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v228 = objc_claimAutoreleasedReturnValue();
        v229 = v298;
        v230 = os_log_type_enabled(v228, v298);
        if (backtrace_string)
        {
          if (v230)
          {
            v231 = (const char *)*((_QWORD *)v32 + 2);
            if (!v231)
              v231 = "invalid";
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
            v300 = 2082;
            v301 = (uint64_t)v231;
            v302 = 2048;
            v303 = v32;
            v304 = 2082;
            v305 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v228, v229, "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(backtrace_string);
        }
        else
        {
          if (v230)
          {
            v258 = (const char *)*((_QWORD *)v32 + 2);
            if (!v258)
              v258 = "invalid";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
            v300 = 2082;
            v301 = (uint64_t)v258;
            v302 = 2048;
            v303 = v32;
            _os_log_impl(&dword_182FBE000, v228, v229, "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace", buf, 0x20u);
          }

        }
      }
LABEL_348:
      if (v219)
        free(v219);
      v43 = 0;
      if (v33 != &nw_protocol_ref_counted_handle)
        goto LABEL_40;
LABEL_39:
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
LABEL_40:
      if (v43)
        objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40), v43);
LABEL_42:
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = 0;

      goto LABEL_9;
    }
    __nwlog_obj();
    v223 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
    v224 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v224, type, &v298))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v225 = objc_claimAutoreleasedReturnValue();
        v226 = type[0];
        if (os_log_type_enabled(v225, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
          _os_log_impl(&dword_182FBE000, v225, v226, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else
      {
        if (v298)
        {
          v239 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v240 = objc_claimAutoreleasedReturnValue();
          v241 = type[0];
          v242 = os_log_type_enabled(v240, type[0]);
          if (v239)
          {
            if (v242)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
              v300 = 2082;
              v301 = (uint64_t)v239;
              _os_log_impl(&dword_182FBE000, v240, v241, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v239);
          }
          else
          {
            if (v242)
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
              _os_log_impl(&dword_182FBE000, v240, v241, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
            }

          }
          goto LABEL_374;
        }
        __nwlog_obj();
        v225 = objc_claimAutoreleasedReturnValue();
        v259 = type[0];
        if (os_log_type_enabled(v225, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_protocol_get_remote_endpoint";
          _os_log_impl(&dword_182FBE000, v225, v259, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_374:
    if (v224)
      free(v224);
    v43 = 0;
    goto LABEL_42;
  }
  if (nw_protocol_definition_is_proxy(v8))
  {
    if (a2 && *(_BYTE *)(a1 + 136) && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 24))
    {
      v22 = nw_endpoint_flow_add_one_protocol(*(void **)(a1 + 32), *(__int128 **)(a1 + 120), 0, 0, *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40), *(void **)(a1 + 40), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24));
      if (!v22)
      {
        if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) != 0)
          goto LABEL_192;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v81 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
        {
          v82 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          v83 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          v84 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          v85 = nw_endpoint_get_logging_description(v84);
          v86 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          v87 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          v88 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          v89 = *(char **)(a1 + 120);
          *(_DWORD *)buf = 136448002;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
          v300 = 2082;
          v301 = (uint64_t)v82;
          v302 = 2082;
          v303 = v83;
          v304 = 2082;
          v305 = (void *)v85;
          v306 = 2082;
          v307 = v86;
          v308 = 2082;
          v309 = v87;
          v310 = 2114;
          v311 = v88;
          v312 = 2082;
          v313 = v89;
          _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach filter protocol %{public}s", buf, 0x52u);

        }
LABEL_191:
        v9 = v293;
        goto LABEL_192;
      }
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) = v22;
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v23 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          v24 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
          v25 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
          v289 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
          v26 = nw_endpoint_get_logging_description(v289);
          v27 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
          v28 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
          v29 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
          v30 = *(char **)(a1 + 120);
          *(_DWORD *)buf = 136448002;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
          v300 = 2082;
          v301 = (uint64_t)v24;
          v302 = 2082;
          v303 = v25;
          v304 = 2082;
          v305 = (void *)v26;
          v306 = 2082;
          v307 = v27;
          v308 = 2082;
          v309 = v28;
          v310 = 2114;
          v311 = v29;
          v312 = 2082;
          v313 = v30;
          _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached filter protocol: %{public}s", buf, 0x52u);

        }
        v9 = v293;
      }
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 24) = 1;
    }
    if (nw_protocol_options_proxy_endpoint_should_override_stack(v9))
      v31 = nw_protocol_options_copy_proxy_endpoint_for_stack(v9);
    else
      v31 = nw_endpoint_copy_without_proxy_parent(*(void **)(a1 + 48));
    v35 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8);
    v36 = *(void **)(v35 + 40);
    *(_QWORD *)(v35 + 40) = v31;

    v37 = nw_endpoint_handler_copy_context(*(void **)(a1 + 32));
    v38 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40);
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 24))
      v39 = 1;
    else
      v39 = nw_parameters_get_use_enhanced_privacy_mode(*(void **)(a1 + 40)) ^ 1;
    v44 = nw_context_copy_registered_endpoint_internal(v37, v38, v39);
    v45 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8);
    v46 = *(void **)(v45 + 40);
    *(_QWORD *)(v45 + 40) = v44;

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 24) = 1;
    *(_BYTE *)(*(_QWORD *)(a1 + 56) + 35) |= 0x40u;

    v8 = v294;
  }
  identifier = nw_protocol_definition_get_identifier(v8);
  registered_endpoint = *(_QWORD *)(a1 + 128);
  if (registered_endpoint)
    goto LABEL_123;
  v49 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 24);
  v51 = *(void **)(a1 + 40);
  v50 = *(void **)(a1 + 48);
  v52 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40);
  v53 = *(id *)(a1 + 32);
  v287 = v50;
  v286 = v52;
  v290 = v51;
  v285 = v53;
  if (!v53)
  {
    __nwlog_obj();
    v232 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v71, type, &v298))
      goto LABEL_119;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v234 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v234, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_399;
    }
    if (v298 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v266 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v266, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_399;
    }
    v247 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v72 = objc_claimAutoreleasedReturnValue();
    v248 = type[0];
    v249 = os_log_type_enabled(v72, type[0]);
    if (!v247)
    {
      if (v249)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v72, v248, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_118;
    }
    if (v249)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v300 = 2082;
      v301 = (uint64_t)v247;
      _os_log_impl(&dword_182FBE000, v72, v248, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_369;
  }
  v54 = (unsigned int *)v53;
  v55 = v54[29];

  if ((_DWORD)v55 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v64 = (id)gLogObj;
    if (v55 > 5)
      v65 = "unknown-mode";
    else
      v65 = off_1E149FC18[v55];
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v300 = 2082;
    v301 = (uint64_t)v65;
    v302 = 2082;
    v303 = "flow";
    v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v71, type, &v298))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v72 = objc_claimAutoreleasedReturnValue();
        v73 = type[0];
        if (os_log_type_enabled(v72, type[0]))
        {
          if (v55 > 5)
            v74 = "unknown-mode";
          else
            v74 = off_1E149FC18[v55];
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v300 = 2082;
          v301 = (uint64_t)v74;
          v302 = 2082;
          v303 = "flow";
          _os_log_impl(&dword_182FBE000, v72, v73, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
        goto LABEL_118;
      }
      if (v298 == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v72 = objc_claimAutoreleasedReturnValue();
        v79 = type[0];
        if (os_log_type_enabled(v72, type[0]))
        {
          if (v55 > 5)
            v80 = "unknown-mode";
          else
            v80 = off_1E149FC18[v55];
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v300 = 2082;
          v301 = (uint64_t)v80;
          v302 = 2082;
          v303 = "flow";
          _os_log_impl(&dword_182FBE000, v72, v79, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
        goto LABEL_118;
      }
      v75 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v72 = objc_claimAutoreleasedReturnValue();
      v76 = type[0];
      v77 = os_log_type_enabled(v72, type[0]);
      if (!v75)
      {
        if (v77)
        {
          if (v55 > 5)
            v90 = "unknown-mode";
          else
            v90 = off_1E149FC18[v55];
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          v300 = 2082;
          v301 = (uint64_t)v90;
          v302 = 2082;
          v303 = "flow";
          _os_log_impl(&dword_182FBE000, v72, v76, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
        goto LABEL_118;
      }
      if (v77)
      {
        if (v55 > 5)
          v78 = "unknown-mode";
        else
          v78 = off_1E149FC18[v55];
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        v300 = 2082;
        v301 = (uint64_t)v78;
        v302 = 2082;
        v303 = "flow";
        v304 = 2082;
        v305 = v75;
        _os_log_impl(&dword_182FBE000, v72, v76, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v75);
    }
LABEL_119:
    if (!v71)
    {
LABEL_121:
      registered_endpoint = 0;
      goto LABEL_122;
    }
LABEL_120:
    free(v71);
    goto LABEL_121;
  }
  if (!identifier)
  {
    __nwlog_obj();
    v245 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v71, type, &v298))
      goto LABEL_119;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v246 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v246, "%{public}s called with null identifier", buf, 0xCu);
      }
      goto LABEL_399;
    }
    if (v298 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v268 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v268, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_399;
    }
    v247 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v72 = objc_claimAutoreleasedReturnValue();
    v260 = type[0];
    v261 = os_log_type_enabled(v72, type[0]);
    if (!v247)
    {
      if (v261)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v72, v260, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }
      goto LABEL_118;
    }
    if (v261)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v300 = 2082;
      v301 = (uint64_t)v247;
      _os_log_impl(&dword_182FBE000, v72, v260, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_369;
  }
  if (!v286)
  {
    __nwlog_obj();
    v250 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v71, type, &v298))
      goto LABEL_119;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v251 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v251, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_399;
    }
    if (v298 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v269 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v269, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_399;
    }
    v247 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v72 = objc_claimAutoreleasedReturnValue();
    v262 = type[0];
    v263 = os_log_type_enabled(v72, type[0]);
    if (!v247)
    {
      if (v263)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v72, v262, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_118;
    }
    if (v263)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v300 = 2082;
      v301 = (uint64_t)v247;
      _os_log_impl(&dword_182FBE000, v72, v262, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_369:

    free(v247);
    if (!v71)
      goto LABEL_121;
    goto LABEL_120;
  }
  if (!v290)
  {
    __nwlog_obj();
    v252 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    v71 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v71, type, &v298))
      goto LABEL_119;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v253 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v253, "%{public}s called with null parameters", buf, 0xCu);
      }
LABEL_399:

      goto LABEL_119;
    }
    if (v298 == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      v233 = objc_claimAutoreleasedReturnValue();
      v270 = type[0];
      if (os_log_type_enabled(v233, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_182FBE000, v233, v270, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_399;
    }
    v247 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v72 = objc_claimAutoreleasedReturnValue();
    v264 = type[0];
    v265 = os_log_type_enabled(v72, type[0]);
    if (v247)
    {
      if (v265)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        v300 = 2082;
        v301 = (uint64_t)v247;
        _os_log_impl(&dword_182FBE000, v72, v264, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_369;
    }
    if (v265)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      _os_log_impl(&dword_182FBE000, v72, v264, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
    }
LABEL_118:

    goto LABEL_119;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  v56 = &g_registration_list;
  do
  {
    v56 = (uint64_t *)*v56;
    if (!v56)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      goto LABEL_75;
    }
  }
  while (*(_QWORD *)identifier != v56[4]
       || *((_QWORD *)identifier + 1) != v56[5]
       || *((_QWORD *)identifier + 2) != v56[6]
       || *((_QWORD *)identifier + 3) != v56[7]
       || *((_QWORD *)identifier + 4) != v56[8]);
  v61 = v56[13];
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  if (!v61)
  {
LABEL_75:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v54) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v66 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
      {
        v283 = nw_endpoint_handler_get_id_string(v54);
        v281 = nw_endpoint_handler_dry_run_string(v54);
        v67 = nw_endpoint_handler_copy_endpoint(v54);
        v279 = nw_endpoint_get_logging_description(v67);
        v68 = nw_endpoint_handler_state_string(v54);
        v69 = nw_endpoint_handler_mode_string(v54);
        v70 = nw_endpoint_handler_copy_current_path(v54);
        *(_DWORD *)buf = 136448258;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        v300 = 2082;
        v301 = (uint64_t)v283;
        v302 = 2082;
        v303 = v281;
        v304 = 2082;
        v305 = (void *)v279;
        v306 = 2082;
        v307 = v68;
        v308 = 2082;
        v309 = v69;
        v310 = 2114;
        v311 = v70;
        v312 = 2080;
        v313 = identifier;
        v314 = 2048;
        v315 = (uint64_t)identifier;
        _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x5Cu);

      }
    }
    goto LABEL_121;
  }
  v62 = v286;
  v63 = v62;
  while (1)
  {
    registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join((uint64_t)identifier, a2, v287, v63, v62, v290, v49 != 0);
    if (registered_endpoint)
      break;
    registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v63, v49 != 0);

    v63 = (void *)registered_endpoint;
    if (!registered_endpoint)
      goto LABEL_97;
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v54) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v271 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v271, OS_LOG_TYPE_DEBUG))
    {
      v282 = nw_endpoint_handler_get_id_string(v54);
      v280 = nw_endpoint_handler_dry_run_string(v54);
      v284 = nw_endpoint_handler_copy_endpoint(v54);
      v278 = nw_endpoint_get_logging_description(v284);
      v272 = nw_endpoint_handler_state_string(v54);
      v273 = nw_endpoint_handler_mode_string(v54);
      v274 = nw_endpoint_handler_copy_current_path(v54);
      v275 = v274;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      v276 = "invalid";
      v277 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v277)
        v276 = v277;
      v300 = 2082;
      v301 = (uint64_t)v282;
      v302 = 2082;
      v303 = v280;
      v304 = 2082;
      v305 = (void *)v278;
      v306 = 2082;
      v307 = v272;
      v308 = 2082;
      v309 = v273;
      v310 = 2114;
      v311 = v274;
      v312 = 2080;
      v313 = (char *)v276;
      v314 = 2048;
      v315 = registered_endpoint;
      _os_log_impl(&dword_182FBE000, v271, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)", buf, 0x5Cu);

    }
  }
LABEL_97:

LABEL_122:
  if (!registered_endpoint)
  {
LABEL_129:
    v9 = v293;
    protocol_for_definition = nw_endpoint_handler_create_protocol_for_definition((uint64_t)identifier, v294, *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40), *(void **)(a1 + 40));
    v93 = *(void **)(a1 + 32);
    if (!protocol_for_definition)
    {
      if ((nw_endpoint_handler_get_logging_disabled(v93) & 1) != 0)
        goto LABEL_192;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v100 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
      {
        v101 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        v102 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        v103 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        v104 = nw_endpoint_get_logging_description(v103);
        v105 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        v106 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        v107 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136448002;
        *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
        v300 = 2082;
        v301 = (uint64_t)v101;
        v302 = 2082;
        v303 = v102;
        v304 = 2082;
        v305 = (void *)v104;
        v306 = 2082;
        v307 = v105;
        v308 = 2082;
        v309 = v106;
        v310 = 2114;
        v311 = v107;
        v312 = 2082;
        v313 = identifier;
        _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create application protocol handler: %{public}s", buf, 0x52u);

      }
      goto LABEL_190;
    }
    nw_endpoint_handler_set_protocol_instance(v93, v293, v294, protocol_for_definition);
    v94 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24);
    if (v94)
    {
      if (protocol_for_definition != v94)
      {
        v95 = *(_QWORD **)(protocol_for_definition + 24);
        if (v95 && *v95)
        {
          if ((nw_protocol_add_input_handler(protocol_for_definition, v94) & 1) != 0)
          {
            if (nw_protocol_definition_get_message_is_stream(v294))
            {
              v96 = *(_QWORD *)(a1 + 56);
              if (!*(_QWORD *)(v96 + 768))
              {
                objc_storeStrong((id *)(v96 + 768), a3);
                if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
                {
                  v176 = *(_QWORD *)(protocol_for_definition + 88);
                  v9 = v293;
                  if (v176)
                    *(_QWORD *)(protocol_for_definition + 88) = v176 + 1;
                  *(_QWORD *)buf = protocol_for_definition;
                  buf[8] |= 1u;
                }
                else
                {
                  *(_QWORD *)buf = protocol_for_definition;
                  buf[8] &= ~1u;
                  v9 = v293;
                }
                nw::retained_ptr<nw_protocol *>::operator=(*(_QWORD *)(a1 + 56) + 776, (uint64_t)buf);
                if ((buf[8] & 1) != 0)
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                v177 = *(_QWORD *)(protocol_for_definition + 24);
                if (v177)
                {
                  v178 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(v177 + 232);
                  if (v178)
                  {
                    v179 = *(_QWORD *)(a1 + 56) + 440;
                    v180 = *(void **)(protocol_for_definition + 40);
                    if (v180 == &nw_protocol_ref_counted_handle)
                    {
                      v190 = *(_QWORD *)(protocol_for_definition + 88);
                      if (v190)
                        *(_QWORD *)(protocol_for_definition + 88) = v190 + 1;
                      *(_QWORD *)buf = protocol_for_definition;
                      v181 = buf[8] | 1;
                    }
                    else
                    {
                      *(_QWORD *)buf = protocol_for_definition;
                      v181 = buf[8] & 0xFE;
                    }
                    buf[8] = v181;
                    v191 = v178(protocol_for_definition, v179, 0);
                    if (v180 == &nw_protocol_ref_counted_handle)
                      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                    if ((v191 & 1) == 0 && (nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v192 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
                      {
                        v193 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                        v194 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                        v292 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                        v195 = nw_endpoint_get_logging_description(v292);
                        v196 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                        v197 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                        v198 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                        v199 = v198;
                        v200 = "invalid";
                        v201 = *(const char **)(*(_QWORD *)(a1 + 56) + 392);
                        if (!v201)
                          v201 = "invalid";
                        if (*(_QWORD *)(protocol_for_definition + 16))
                          v200 = *(const char **)(protocol_for_definition + 16);
                        *(_DWORD *)buf = 136448258;
                        *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                        v300 = 2082;
                        v301 = (uint64_t)v193;
                        v302 = 2082;
                        v303 = v194;
                        v304 = 2082;
                        v305 = (void *)v195;
                        v306 = 2082;
                        v307 = v196;
                        v308 = 2082;
                        v309 = v197;
                        v310 = 2114;
                        v311 = v198;
                        v312 = 2082;
                        v313 = (char *)v201;
                        v314 = 2082;
                        v315 = (uint64_t)v200;
                        _os_log_impl(&dword_182FBE000, v192, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s as a listener to %{public}s", buf, 0x5Cu);

                      }
                      v9 = v293;
                    }
                  }
                }
              }
            }
            if (*((_DWORD *)identifier + 9) == 2
              && nw_protocol_registrar_get_accept_function_for_identifier(identifier))
            {
              *(_QWORD *)(*(_QWORD *)(a1 + 56) + 736) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8)
                                                                                + 24)
                                                                    + 32);
            }
            v97 = *(_QWORD *)(a1 + 56);
            if (!*(_QWORD *)(v97 + 744) && *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 24))
              *(_QWORD *)(v97 + 744) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) + 32);
            v98 = *(id *)(a1 + 64);
            if (v98 && v98 == v9)
            {
              os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 880));
              v99 = *(_QWORD *)(a1 + 56);
              if (*(_QWORD *)(v99 + 720))
              {
                os_unfair_lock_unlock((os_unfair_lock_t)(v99 + 880));
              }
              else
              {
                if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
                {
                  v129 = *(_QWORD *)(protocol_for_definition + 88);
                  if (v129)
                  {
                    *(_QWORD *)(protocol_for_definition + 88) = v129 + 1;
                    v99 = *(_QWORD *)(a1 + 56);
                  }
                  *(_QWORD *)buf = protocol_for_definition;
                  v128 = buf[8] | 1;
                }
                else
                {
                  *(_QWORD *)buf = protocol_for_definition;
                  v128 = buf[8] & 0xFE;
                }
                buf[8] = v128;
                nw::retained_ptr<nw_protocol *>::operator=(v99 + 720, (uint64_t)buf);
                if ((buf[8] & 1) != 0)
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 880));
                if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v130 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v130, OS_LOG_TYPE_DEBUG))
                  {
                    v131 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                    v132 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                    v133 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                    v134 = nw_endpoint_get_logging_description(v133);
                    v135 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                    v136 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                    v137 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                    *(_DWORD *)buf = 136448002;
                    *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                    v300 = 2082;
                    v301 = (uint64_t)v131;
                    v302 = 2082;
                    v303 = v132;
                    v304 = 2082;
                    v305 = (void *)v134;
                    v306 = 2082;
                    v307 = v135;
                    v308 = 2082;
                    v309 = v136;
                    v310 = 2114;
                    v311 = v137;
                    v312 = 2082;
                    v313 = identifier;
                    _os_log_impl(&dword_182FBE000, v130, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Saved effective transport protocol: %{public}s", buf, 0x52u);

                  }
                  v9 = v293;
                }
              }
            }
            *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8)
                                                                                                + 24)
                                                                                    + 32);
            v138 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24);
            v139 = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
            if (v138)
            {
              if ((v139 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v140 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v140, OS_LOG_TYPE_DEBUG))
                {
                  v141 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  v142 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  v143 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  v144 = nw_endpoint_get_logging_description(v143);
                  v145 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  v146 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  v147 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136448002;
                  *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  v300 = 2082;
                  v301 = (uint64_t)v141;
                  v302 = 2082;
                  v303 = v142;
                  v304 = 2082;
                  v305 = (void *)v144;
                  v306 = 2082;
                  v307 = v145;
                  v308 = 2082;
                  v309 = v146;
                  v310 = 2114;
                  v311 = v147;
                  v312 = 2082;
                  v313 = identifier;
                  _os_log_impl(&dword_182FBE000, v140, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached application protocol: %{public}s", buf, 0x52u);

                }
                goto LABEL_9;
              }
              goto LABEL_12;
            }
            if ((v139 & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v148 = (id)gconnectionLogObj;
              v149 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
              v150 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
              v151 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
              v152 = nw_endpoint_get_logging_description(v151);
              v153 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
              v154 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
              v155 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
              v300 = 2082;
              v301 = (uint64_t)v149;
              v302 = 2082;
              v303 = v150;
              v304 = 2082;
              v305 = (void *)v152;
              v306 = 2082;
              v307 = v153;
              v308 = 2082;
              v309 = v154;
              v310 = 2114;
              v311 = v155;
              v291 = (const char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              v298 = OS_LOG_TYPE_DEFAULT;
              v156 = (char *)v291;
              if ((__nwlog_fault(v291, type, &v298) & 1) == 0)
                goto LABEL_269;
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v157 = (id)gconnectionLogObj;
                v158 = type[0];
                if (os_log_type_enabled(v157, type[0]))
                {
                  v159 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  v160 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  v161 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  v162 = nw_endpoint_get_logging_description(v161);
                  v163 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  v164 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  v165 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136447746;
                  *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  v300 = 2082;
                  v301 = (uint64_t)v159;
                  v302 = 2082;
                  v303 = v160;
                  v304 = 2082;
                  v305 = (void *)v162;
                  v306 = 2082;
                  v307 = v163;
                  v308 = 2082;
                  v309 = v164;
                  v310 = 2114;
                  v311 = v165;
                  _os_log_impl(&dword_182FBE000, v157, v158, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NULL", buf, 0x48u);

                }
              }
              else if (v298)
              {
                v166 = __nw_create_backtrace_string();
                if (v166)
                {
                  v167 = (char *)v166;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v168 = (id)gconnectionLogObj;
                  v169 = type[0];
                  if (os_log_type_enabled(v168, type[0]))
                  {
                    v170 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                    v171 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                    v288 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                    v172 = nw_endpoint_get_logging_description(v288);
                    v173 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                    v174 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                    v175 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                    *(_DWORD *)buf = 136448002;
                    *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                    v300 = 2082;
                    v301 = (uint64_t)v170;
                    v302 = 2082;
                    v303 = v171;
                    v304 = 2082;
                    v305 = (void *)v172;
                    v306 = 2082;
                    v307 = v173;
                    v308 = 2082;
                    v309 = v174;
                    v310 = 2114;
                    v311 = v175;
                    v312 = 2082;
                    v313 = v167;
                    _os_log_impl(&dword_182FBE000, v168, v169, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NULL, dumping backtrace:%{public}s", buf, 0x52u);

                  }
                  free(v167);
                  goto LABEL_268;
                }
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v157 = (id)gconnectionLogObj;
                v202 = type[0];
                if (os_log_type_enabled(v157, type[0]))
                {
                  v203 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  v204 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  v205 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  v206 = nw_endpoint_get_logging_description(v205);
                  v207 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  v208 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  v209 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136447746;
                  *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  v300 = 2082;
                  v301 = (uint64_t)v203;
                  v302 = 2082;
                  v303 = v204;
                  v304 = 2082;
                  v305 = (void *)v206;
                  v306 = 2082;
                  v307 = v207;
                  v308 = 2082;
                  v309 = v208;
                  v310 = 2114;
                  v311 = v209;
                  _os_log_impl(&dword_182FBE000, v157, v202, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NULL, no backtrace", buf, 0x48u);

                }
              }
              else
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v157 = (id)gconnectionLogObj;
                v182 = type[0];
                if (os_log_type_enabled(v157, type[0]))
                {
                  v183 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
                  v184 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
                  v185 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
                  v186 = nw_endpoint_get_logging_description(v185);
                  v187 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
                  v188 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
                  v189 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
                  *(_DWORD *)buf = 136447746;
                  *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
                  v300 = 2082;
                  v301 = (uint64_t)v183;
                  v302 = 2082;
                  v303 = v184;
                  v304 = 2082;
                  v305 = (void *)v186;
                  v306 = 2082;
                  v307 = v187;
                  v308 = 2082;
                  v309 = v188;
                  v310 = 2114;
                  v311 = v189;
                  _os_log_impl(&dword_182FBE000, v157, v182, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Next protocol is NULL, backtrace limit exceeded", buf, 0x48u);

                }
              }

LABEL_268:
              v156 = (char *)v291;
LABEL_269:
              v9 = v293;
              if (v156)
                free(v156);
            }
LABEL_192:
            v20 = 0;
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 24) = 1;
            goto LABEL_193;
          }
          goto LABEL_185;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v112 = (id)gLogObj;
        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
          v300 = 2048;
          v301 = protocol_for_definition;
          _os_log_impl(&dword_182FBE000, v112, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
        }

        goto LABEL_162;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v108 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
      v300 = 2048;
      v301 = protocol_for_definition;
      v109 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v298 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v109, type, &v298))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v110 = objc_claimAutoreleasedReturnValue();
          v111 = type[0];
          if (os_log_type_enabled(v110, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
            v300 = 2048;
            v301 = protocol_for_definition;
            _os_log_impl(&dword_182FBE000, v110, v111, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
          }
        }
        else
        {
          if (v298)
          {
            v114 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v115 = objc_claimAutoreleasedReturnValue();
            v116 = type[0];
            v117 = os_log_type_enabled(v115, type[0]);
            if (v114)
            {
              if (v117)
              {
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
                v300 = 2048;
                v301 = protocol_for_definition;
                v302 = 2082;
                v303 = v114;
                _os_log_impl(&dword_182FBE000, v115, v116, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v114);
            }
            else
            {
              if (v117)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
                v300 = 2048;
                v301 = protocol_for_definition;
                _os_log_impl(&dword_182FBE000, v115, v116, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
              }

            }
            goto LABEL_183;
          }
          __nwlog_obj();
          v110 = objc_claimAutoreleasedReturnValue();
          v119 = type[0];
          if (os_log_type_enabled(v110, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
            v300 = 2048;
            v301 = protocol_for_definition;
            _os_log_impl(&dword_182FBE000, v110, v119, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
          }
        }

      }
LABEL_183:
      v9 = v293;
      if (v109)
        free(v109);
      goto LABEL_185;
    }
    __nwlog_obj();
    v235 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
    v236 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v298 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v236, type, &v298))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v237 = objc_claimAutoreleasedReturnValue();
        v238 = type[0];
        if (os_log_type_enabled(v237, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
          _os_log_impl(&dword_182FBE000, v237, v238, "%{public}s called with null input_protocol", buf, 0xCu);
        }
      }
      else
      {
        if (v298)
        {
          v254 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v255 = objc_claimAutoreleasedReturnValue();
          v256 = type[0];
          v257 = os_log_type_enabled(v255, type[0]);
          if (v254)
          {
            if (v257)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
              v300 = 2082;
              v301 = (uint64_t)v254;
              _os_log_impl(&dword_182FBE000, v255, v256, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v254);
          }
          else
          {
            if (v257)
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_182FBE000, v255, v256, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
            }

          }
          goto LABEL_389;
        }
        __nwlog_obj();
        v237 = objc_claimAutoreleasedReturnValue();
        v267 = type[0];
        if (os_log_type_enabled(v237, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_utilities_add_input_handler";
          _os_log_impl(&dword_182FBE000, v237, v267, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_389:
    if (v236)
      free(v236);
LABEL_162:
    v9 = v293;
LABEL_185:
    if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) != 0)
      goto LABEL_192;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v100 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
    {
      v120 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
      v121 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
      v122 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
      v123 = nw_endpoint_get_logging_description(v122);
      v124 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
      v125 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
      v126 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
      *(_DWORD *)buf = 136448002;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_attach_protocols_block_invoke";
      v300 = 2082;
      v301 = (uint64_t)v120;
      v302 = 2082;
      v303 = v121;
      v304 = 2082;
      v305 = (void *)v123;
      v306 = 2082;
      v307 = v124;
      v308 = 2082;
      v309 = v125;
      v310 = 2114;
      v311 = v126;
      v312 = 2082;
      v313 = identifier;
      _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach application protocol %{public}s", buf, 0x52u);

    }
LABEL_190:

    goto LABEL_191;
  }
LABEL_123:
  if (!nw_endpoint_flow_join_protocol(*(void **)(a1 + 32), *(void **)(a1 + 40), v293, v294, identifier, a2, registered_endpoint, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24), *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 24), (_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 24)))goto LABEL_129;
  *(_QWORD *)(*(_QWORD *)(a1 + 56) + 736) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24)
                                                        + 32);
  *(_BYTE *)(*(_QWORD *)(a1 + 56) + 33) |= 1u;
  do
  {
    registered_endpoint = *(_QWORD *)(registered_endpoint + 32);
    if (!registered_endpoint)
    {
      v20 = 0;
      v9 = v293;
      goto LABEL_193;
    }
  }
  while (*(_DWORD *)(*(_QWORD *)(registered_endpoint + 16) + 32) != 3);
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 880));
  v91 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v91 + 720))
  {
    v9 = v293;
  }
  else
  {
    if (*(_UNKNOWN **)(registered_endpoint + 40) == &nw_protocol_ref_counted_handle)
    {
      v118 = *(_QWORD *)(registered_endpoint + 88);
      if (v118)
      {
        *(_QWORD *)(registered_endpoint + 88) = v118 + 1;
        v91 = *(_QWORD *)(a1 + 56);
      }
      *(_QWORD *)buf = registered_endpoint;
      v113 = buf[8] | 1;
    }
    else
    {
      *(_QWORD *)buf = registered_endpoint;
      v113 = buf[8] & 0xFE;
    }
    buf[8] = v113;
    v9 = v293;
    nw::retained_ptr<nw_protocol *>::operator=(v91 + 720, (uint64_t)buf);
    if ((buf[8] & 1) != 0)
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    v91 = *(_QWORD *)(a1 + 56);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v91 + 880));
  v20 = 0;
LABEL_193:

  return v20;
}

void sub_18311C064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,void *a21,uint64_t a22,void *a23,void *a24)
{
  void *v24;
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

void nw_endpoint_handler_set_protocol_instance(void *a1, void *a2, void *a3, uint64_t a4)
{
  id v7;
  id v8;
  id v9;
  NWConcrete_nw_endpoint_handler *v10;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v12;
  unsigned __int16 *v13;
  int v14;
  char *v15;
  int v16;
  char *v17;
  char *v18;
  char *v19;
  int v20;
  char *v21;
  char *v22;
  id v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  const char *v32;
  os_log_type_t v33;
  const char *v34;
  const char *v35;
  void *v36;
  os_log_type_t v37;
  void *v38;
  os_log_type_t v39;
  char *backtrace_string;
  os_log_type_t v41;
  _BOOL4 v42;
  char *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  os_log_type_t v46;
  os_log_type_t v47;
  char v48;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  void *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  char *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  if (!v7)
  {
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_endpoint_handler_set_protocol_instance";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v25, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v37 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_endpoint_handler_set_protocol_instance";
          _os_log_impl(&dword_182FBE000, v26, v37, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_40;
      }
      if (!v48)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_endpoint_handler_set_protocol_instance";
          _os_log_impl(&dword_182FBE000, v26, v46, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_40;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v41 = type;
      v42 = os_log_type_enabled(v26, type);
      if (!backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v51 = "nw_endpoint_handler_set_protocol_instance";
          _os_log_impl(&dword_182FBE000, v26, v41, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_40;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "nw_endpoint_handler_set_protocol_instance";
        v52 = 2082;
        v53 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v26, v41, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    goto LABEL_41;
  }
  v10 = (NWConcrete_nw_endpoint_handler *)v7;
  mode = v10->mode;

  if ((_DWORD)mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (id)gLogObj;
    if (mode > 5)
      v24 = "unknown-mode";
    else
      v24 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v51 = "nw_endpoint_handler_set_protocol_instance";
    v52 = 2082;
    v53 = (void *)v24;
    v54 = 2082;
    v55 = "flow";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v25, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = (id)gLogObj;
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          if (mode > 5)
            v28 = "unknown-mode";
          else
            v28 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v51 = "nw_endpoint_handler_set_protocol_instance";
          v52 = 2082;
          v53 = (void *)v28;
          v54 = 2082;
          v55 = "flow";
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
        goto LABEL_40;
      }
      if (!v48)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = (id)gLogObj;
        v33 = type;
        if (os_log_type_enabled(v26, type))
        {
          if (mode > 5)
            v34 = "unknown-mode";
          else
            v34 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v51 = "nw_endpoint_handler_set_protocol_instance";
          v52 = 2082;
          v53 = (void *)v34;
          v54 = 2082;
          v55 = "flow";
          _os_log_impl(&dword_182FBE000, v26, v33, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
        goto LABEL_40;
      }
      v29 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = (id)gLogObj;
      v30 = type;
      v31 = os_log_type_enabled(v26, type);
      if (!v29)
      {
        if (v31)
        {
          if (mode > 5)
            v35 = "unknown-mode";
          else
            v35 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v51 = "nw_endpoint_handler_set_protocol_instance";
          v52 = 2082;
          v53 = (void *)v35;
          v54 = 2082;
          v55 = "flow";
          _os_log_impl(&dword_182FBE000, v26, v30, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
        goto LABEL_40;
      }
      if (v31)
      {
        if (mode > 5)
          v32 = "unknown-mode";
        else
          v32 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446978;
        v51 = "nw_endpoint_handler_set_protocol_instance";
        v52 = 2082;
        v53 = (void *)v32;
        v54 = 2082;
        v55 = "flow";
        v56 = 2082;
        v57 = v29;
        _os_log_impl(&dword_182FBE000, v26, v30, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v29);
      if (v25)
        goto LABEL_42;
      goto LABEL_43;
    }
LABEL_41:
    if (!v25)
      goto LABEL_43;
LABEL_42:
    free(v25);
    goto LABEL_43;
  }
  if (v8)
  {
    v12 = nw_endpoint_handler_copy_flow(v10);
    v13 = (unsigned __int16 *)v12;
    v14 = *((unsigned __int16 *)v12 + 488);
    if (v14 != 0xFFFF)
      *((_WORD *)v12 + 488) = v14 + 1;
    v15 = v10;

    v16 = v13[488];
    v17 = (char *)v8;
    v18 = v17;
    if (v15[168])
    {
      *((_WORD *)v17 + 68) = v16;
      snprintf(v17 + 48, 0x54uLL, "[%s%s:%u]", "C", v15 + 168, v16);
    }

    v19 = v15;
    v20 = *((_DWORD *)v19 + 36);

    v21 = v18;
    *((_DWORD *)v21 + 33) = v20;

    v22 = v21;
    *((_QWORD *)v22 + 2) = a4;

    goto LABEL_43;
  }
  __nwlog_obj();
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v51 = "nw_endpoint_handler_set_protocol_instance";
  v25 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v48 = 0;
  if (!__nwlog_fault(v25, &type, &v48))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    v39 = type;
    if (os_log_type_enabled(v26, type))
    {
      *(_DWORD *)buf = 136446210;
      v51 = "nw_endpoint_handler_set_protocol_instance";
      _os_log_impl(&dword_182FBE000, v26, v39, "%{public}s called with null protocol_parameters", buf, 0xCu);
    }
LABEL_40:

    goto LABEL_41;
  }
  if (!v48)
  {
    __nwlog_obj();
    v26 = objc_claimAutoreleasedReturnValue();
    v47 = type;
    if (os_log_type_enabled(v26, type))
    {
      *(_DWORD *)buf = 136446210;
      v51 = "nw_endpoint_handler_set_protocol_instance";
      _os_log_impl(&dword_182FBE000, v26, v47, "%{public}s called with null protocol_parameters, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_40;
  }
  v43 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v26 = objc_claimAutoreleasedReturnValue();
  v44 = type;
  v45 = os_log_type_enabled(v26, type);
  if (!v43)
  {
    if (v45)
    {
      *(_DWORD *)buf = 136446210;
      v51 = "nw_endpoint_handler_set_protocol_instance";
      _os_log_impl(&dword_182FBE000, v26, v44, "%{public}s called with null protocol_parameters, no backtrace", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (v45)
  {
    *(_DWORD *)buf = 136446466;
    v51 = "nw_endpoint_handler_set_protocol_instance";
    v52 = 2082;
    v53 = v43;
    _os_log_impl(&dword_182FBE000, v26, v44, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v43);
  if (v25)
    goto LABEL_42;
LABEL_43:

}

void sub_18311CB50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_create_protocol_for_definition(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  char *v9;
  _BYTE *v10;
  char v11;
  uint64_t internal;
  uint64_t (*v13)(uint64_t, _BYTE *, id, char *);
  uint64_t v14;

  v7 = a2;
  v8 = a3;
  v9 = a4;
  if (v7 && (v10 = v7, v11 = v10[184], v10, (v11 & 1) != 0))
  {
    v13 = (uint64_t (*)(uint64_t, _BYTE *, id, char *))nw_protocol_definition_get_framer_create(v10);
    if (!v13)
    {
      v14 = 0;
      goto LABEL_7;
    }
    internal = v13(a1, v10, v8, v9);
  }
  else
  {
    internal = nw_protocol_create_internal(a1, v8, v9, 1);
  }
  v14 = internal;
LABEL_7:

  return v14;
}

void sub_18311CC28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_create_internal(uint64_t a1, void *a2, const char *a3, int a4)
{
  uint64_t *v8;
  uint64_t (*v13)(uint64_t, uint64_t, void *, const char *);
  uint64_t v14;
  uint64_t (*v15)(uint64_t, void *, const char *);
  _BYTE *v16;
  _BOOL4 v17;
  const char *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  const char *v23;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  id v28;
  void *v29;
  char *backtrace_string;
  _BOOL4 v31;
  const char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *v36;
  _BOOL4 v37;
  const char *v38;
  NSObject *v39;
  os_log_type_t v40;
  uint32_t v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  NSObject *v46;
  NSObject *v47;
  char *v48;
  _BOOL4 v49;
  NSObject *v50;
  const char *v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  const char *v55;
  char v56;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  uint64_t v61;
  __int16 v62;
  const char *logging_description;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  uint64_t v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_allow_use_of_dispatch_internal();
    if (gLogDatapath)
    {
      v46 = __nwlog_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v59 = "nw_protocol_create_internal";
        v60 = 2080;
        v61 = a1;
        v62 = 2080;
        logging_description = nw_endpoint_get_logging_description(a2);
        v64 = 2112;
        v65 = a3;
        _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s creating protocol %s (endpoint: %s, parameters: %@)", buf, 0x2Au);
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
    v8 = &g_registration_list;
    do
    {
      v8 = (uint64_t *)*v8;
      if (!v8)
      {
        if (gLogDatapath)
        {
          v47 = __nwlog_obj();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v59 = "nw_protocol_create_internal";
            v60 = 2080;
            v61 = a1;
            v62 = 2048;
            logging_description = (const char *)a1;
            _os_log_impl(&dword_182FBE000, v47, OS_LOG_TYPE_DEBUG, "%{public}s failed to find registration for identifier %s (%p)", buf, 0x20u);
          }
        }
        v14 = 0;
        goto LABEL_38;
      }
    }
    while (*(_QWORD *)a1 != v8[4]
         || *(_QWORD *)(a1 + 8) != v8[5]
         || *(_QWORD *)(a1 + 16) != v8[6]
         || *(_QWORD *)(a1 + 24) != v8[7]
         || *(_QWORD *)(a1 + 32) != v8[8]);
    v13 = (uint64_t (*)(uint64_t, uint64_t, void *, const char *))v8[12];
    if (v13)
    {
      v14 = v13(a1, v8[14], a2, a3);
      if (!a3)
        goto LABEL_37;
LABEL_28:
      if (!a2 || !a4 || !v14 || !v8[13])
        goto LABEL_37;
      v16 = a2;
      v17 = (v16[231] & 4) == 0;

      if (v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = nw_endpoint_get_logging_description(v16);
        *(_DWORD *)buf = 136446466;
        v59 = "nw_protocol_create_internal";
        v60 = 2080;
        v61 = (uint64_t)v18;
        v19 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v56 = 0;
        if (!__nwlog_fault(v19, &type, &v56))
          goto LABEL_76;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = gLogObj;
          v21 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            v22 = nw_endpoint_get_logging_description(v16);
            *(_DWORD *)buf = 136446466;
            v59 = "nw_protocol_create_internal";
            v60 = 2080;
            v61 = (uint64_t)v22;
            v23 = "%{public}s endpoint %s is not registered, cannot add instance for joining";
            goto LABEL_69;
          }
          goto LABEL_76;
        }
        if (v56)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = gLogObj;
          v21 = type;
          v31 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v31)
            {
              v32 = nw_endpoint_get_logging_description(v16);
              *(_DWORD *)buf = 136446722;
              v59 = "nw_protocol_create_internal";
              v60 = 2080;
              v61 = (uint64_t)v32;
              v62 = 2082;
              logging_description = backtrace_string;
              _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s endpoint %s is not registered, cannot add instance for joining, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_76;
          }
          if (v31)
          {
            v38 = nw_endpoint_get_logging_description(v16);
            *(_DWORD *)buf = 136446466;
            v59 = "nw_protocol_create_internal";
            v60 = 2080;
            v61 = (uint64_t)v38;
            v23 = "%{public}s endpoint %s is not registered, cannot add instance for joining, no backtrace";
            goto LABEL_69;
          }
LABEL_76:
          if (!v19)
            goto LABEL_38;
LABEL_77:
          free(v19);
          goto LABEL_38;
        }
        v20 = __nwlog_obj();
        v21 = type;
        if (!os_log_type_enabled(v20, type))
          goto LABEL_76;
        v35 = nw_endpoint_get_logging_description(v16);
        *(_DWORD *)buf = 136446466;
        v59 = "nw_protocol_create_internal";
        v60 = 2080;
        v61 = (uint64_t)v35;
        v23 = "%{public}s endpoint %s is not registered, cannot add instance for joining, backtrace limit exceeded";
LABEL_69:
        v39 = v20;
        v40 = v21;
        v41 = 22;
LABEL_75:
        _os_log_impl(&dword_182FBE000, v39, v40, v23, buf, v41);
        goto LABEL_76;
      }
      if (gLogDatapath)
      {
        v53 = __nwlog_obj();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        {
          v54 = v8[13];
          v55 = nw_endpoint_get_logging_description(v16);
          *(_DWORD *)buf = 136447234;
          v59 = "nw_protocol_create_internal";
          v60 = 2048;
          v61 = v14;
          v62 = 2080;
          logging_description = (const char *)a1;
          v64 = 2048;
          v65 = (const char *)v54;
          v66 = 2080;
          v67 = v55;
          _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_DEBUG, "%{public}s created protocol instance %p of %s with accept function %p to endpoint %s", buf, 0x34u);
        }
      }
      v25 = v8[9];
      if (!v25)
        goto LABEL_47;
      v27 = *(_QWORD **)(v25 + 16);
      v26 = *(_QWORD **)(v25 + 24);
      if (v27 != v26)
      {
        while ((_BYTE *)*v27 != v16)
        {
          if (++v27 == v26)
          {
            v27 = *(_QWORD **)(v25 + 24);
            break;
          }
        }
      }
      if (v27 == v26)
LABEL_47:
        nw_array_append(v25, v16);
      v28 = nw_endpoint_copy_registrar_for_identifier(v16, (__int128 *)a1, 1);
      if (v28)
      {
        v29 = v28;
        nw_protocol_instance_registrar_add_instance(v28, v14);
        os_release(v29);
        goto LABEL_38;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v59 = "nw_protocol_create_internal";
      v19 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v56 = 0;
      if (!__nwlog_fault(v19, &type, &v56))
        goto LABEL_76;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_76;
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v23 = "%{public}s nw_endpoint_get_registrar(endpoint, true) failed";
        goto LABEL_74;
      }
      if (v56)
      {
        v36 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = type;
        v37 = os_log_type_enabled(v33, type);
        if (v36)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446466;
            v59 = "nw_protocol_create_internal";
            v60 = 2082;
            v61 = (uint64_t)v36;
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s nw_endpoint_get_registrar(endpoint, true) failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v36);
          if (v19)
            goto LABEL_77;
          goto LABEL_38;
        }
        if (!v37)
          goto LABEL_76;
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v23 = "%{public}s nw_endpoint_get_registrar(endpoint, true) failed, no backtrace";
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_76;
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v23 = "%{public}s nw_endpoint_get_registrar(endpoint, true) failed, backtrace limit exceeded";
      }
LABEL_74:
      v39 = v33;
      v40 = v34;
      v41 = 12;
      goto LABEL_75;
    }
    v15 = (uint64_t (*)(uint64_t, void *, const char *))v8[11];
    if (!v15)
    {
      v14 = ((uint64_t (*)(uint64_t))v8[10])(a1);
      if (!a3)
        goto LABEL_37;
      goto LABEL_28;
    }
    v14 = v15(a1, a2, a3);
    if (a3)
      goto LABEL_28;
LABEL_37:
    if (gLogDatapath)
    {
      v50 = __nwlog_obj();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      {
        v51 = nw_endpoint_get_logging_description(a2);
        v52 = v8[13];
        *(_DWORD *)buf = 136447490;
        v59 = "nw_protocol_create_internal";
        v60 = 2080;
        v61 = a1;
        v62 = 2048;
        logging_description = (const char *)v14;
        v64 = 2080;
        v65 = v51;
        v66 = 2048;
        v67 = a3;
        v68 = 2048;
        v69 = v52;
        _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_DEBUG, "%{public}s protocol %s (%p) not eligible, endpoint %s, parameters %p, accept function %p", buf, 0x3Eu);
      }
    }
LABEL_38:
    os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
    return v14;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v59 = "nw_protocol_create_internal";
  v42 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v56 = 0;
  if (__nwlog_fault(v42, &type, &v56))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v43 = __nwlog_obj();
      v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v45 = "%{public}s called with null identifier";
LABEL_97:
        _os_log_impl(&dword_182FBE000, v43, v44, v45, buf, 0xCu);
      }
    }
    else if (v56)
    {
      v48 = (char *)__nw_create_backtrace_string();
      v43 = __nwlog_obj();
      v44 = type;
      v49 = os_log_type_enabled(v43, type);
      if (v48)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          v59 = "nw_protocol_create_internal";
          v60 = 2082;
          v61 = (uint64_t)v48;
          _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v48);
        goto LABEL_98;
      }
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v45 = "%{public}s called with null identifier, no backtrace";
        goto LABEL_97;
      }
    }
    else
    {
      v43 = __nwlog_obj();
      v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        v59 = "nw_protocol_create_internal";
        v45 = "%{public}s called with null identifier, backtrace limit exceeded";
        goto LABEL_97;
      }
    }
  }
LABEL_98:
  if (v42)
    free(v42);
  return 0;
}

uint64_t nw_protocol_ip_create(const nw_protocol_identifier *a1, nw_endpoint *a2, nw_parameters *a3)
{
  BOOL logging_disabled;
  int address_family;
  int v7;
  uint64_t v8;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  logging_disabled = nw_parameters_get_logging_disabled((uint64_t)a3);
  address_family = nw_endpoint_get_address_family(a2);
  if (address_family == 30)
  {
    if (nw_protocol_ip_identifier::onceToken != -1)
      dispatch_once(&nw_protocol_ip_identifier::onceToken, &__block_literal_global_85105);
    if (nw_protocol_ipv6_callbacks(void)::onceToken != -1)
      dispatch_once(&nw_protocol_ipv6_callbacks(void)::onceToken, &__block_literal_global_34_85110);
    v8 = nw_protocol_new(248, (uint64_t)a3, (uint64_t)&nw_protocol_ip_identifier::identifier, nw_protocol_ipv6_callbacks(void)::callbacks);
    *(_QWORD *)(v8 + 88) = 0;
    *(_QWORD *)(v8 + 96) = v8 + 88;
    *(_QWORD *)(v8 + 104) = 0;
    *(_QWORD *)(v8 + 112) = v8 + 104;
    *(_QWORD *)(v8 + 120) = 0;
    *(_QWORD *)(v8 + 128) = v8 + 120;
    *(_DWORD *)(v8 + 152) = 4000;
    *(_BYTE *)(v8 + 158) = *(_BYTE *)(v8 + 158) & 0xFE | logging_disabled;
    goto LABEL_13;
  }
  v7 = address_family;
  if (address_family == 2)
  {
    if (nw_protocol_ip_identifier::onceToken != -1)
      dispatch_once(&nw_protocol_ip_identifier::onceToken, &__block_literal_global_85105);
    if (nw_protocol_ipv4_callbacks(void)::onceToken[0] != -1)
      dispatch_once(nw_protocol_ipv4_callbacks(void)::onceToken, &__block_literal_global_11_85109);
    v8 = nw_protocol_new(224, (uint64_t)a3, (uint64_t)&nw_protocol_ip_identifier::identifier, nw_protocol_ipv4_callbacks(void)::callbacks);
    *(_QWORD *)(v8 + 64) = 0;
    *(_QWORD *)(v8 + 72) = v8 + 64;
    *(_QWORD *)(v8 + 80) = 0;
    *(_QWORD *)(v8 + 88) = v8 + 80;
    *(_QWORD *)(v8 + 96) = 0;
    *(_QWORD *)(v8 + 104) = v8 + 96;
    *(_DWORD *)(v8 + 112) = 4000;
    *(_BYTE *)(v8 + 136) = *(_BYTE *)(v8 + 136) & 0xFE | logging_disabled;
LABEL_13:
    if (v8)
      return v8 - 96;
    else
      return 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  v19 = "nw_protocol_ip_create";
  v20 = 1024;
  v21 = v7;
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_protocol_ip_create";
        v20 = 1024;
        v21 = v7;
        v13 = "%{public}s Invalid address family %u";
LABEL_29:
        _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0x12u);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446722;
          v19 = "nw_protocol_ip_create";
          v20 = 1024;
          v21 = v7;
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s Invalid address family %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_30;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_protocol_ip_create";
        v20 = 1024;
        v21 = v7;
        v13 = "%{public}s Invalid address family %u, no backtrace";
        goto LABEL_29;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_protocol_ip_create";
        v20 = 1024;
        v21 = v7;
        v13 = "%{public}s Invalid address family %u, backtrace limit exceeded";
        goto LABEL_29;
      }
    }
  }
LABEL_30:
  if (v10)
    free(v10);
  return 0;
}

uint64_t nw_protocol_udp_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  if (nw_protocol_udp_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
  if (nw_protocol_udp_callbacks(void)::onceToken != -1)
    dispatch_once(&nw_protocol_udp_callbacks(void)::onceToken, &__block_literal_global_11);
  v5 = nw_protocol_new(184, a4, (uint64_t)&nw_protocol_udp_identifier::identifier, nw_protocol_udp_callbacks(void)::callbacks);
  if (v5)
    return v5 - 96;
  else
    return 0;
}

void nw_protocol_instance_registrar_add_instance(void *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  void (**v4)(_QWORD);
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  NSObject *v11;
  uint64_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD aBlock[4];
  os_unfair_lock_s *v22;
  _BYTE *v23;
  uint64_t v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v6, &type, &v25))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null registrar", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null registrar, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v6)
          goto LABEL_5;
LABEL_43:
        free(v6);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
        _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null registrar, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
        _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s called with null registrar, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (*(_QWORD *)(a2 + 16))
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v12 = *(_QWORD *)(a2 + 16);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v3;
        *(_WORD *)&buf[22] = 2048;
        v28 = a2;
        v29 = 2080;
        v30 = v12;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %@ adding instance %p (%s)", buf, 0x2Au);
      }

    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v28 = 0;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_instance_registrar_add_instance_block_invoke;
    aBlock[3] = &unk_1E14AAE00;
    v23 = buf;
    v24 = a2;
    v22 = v3;
    v4 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v3 + 2);
    v4[2](v4);
    os_unfair_lock_unlock(v3 + 2);

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v6, &type, &v25))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protocol->identifier", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v25)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
      _os_log_impl(&dword_182FBE000, v7, v20, "%{public}s called with null protocol->identifier, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v7, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
      _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null protocol->identifier, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_instance_registrar_add_instance";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v16;
    _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v6)
    goto LABEL_43;
LABEL_5:

}

void sub_18311E0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_protocol_instance_registrar_add_instance_block_invoke(_QWORD *a1, __n128 a2)
{
  _QWORD *v3;
  char v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  uint64_t v26;
  const char *v27;
  char *backtrace_string;
  _BOOL4 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  void *v34;
  __n128 v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  char *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD **)(a1[4] + 16);
  if (!v3)
    goto LABEL_15;
  v4 = 0;
  a2.n128_u64[0] = 136447234;
  do
  {
    v5 = v3;
    v3 = (_QWORD *)*v3;
    if (v5[2] == a1[6])
    {
      *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = v5;
      if (gLogDatapath)
      {
        v35 = a2;
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        {
          v7 = a1[4];
          v8 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
          v9 = a1[6];
          v10 = *(char **)(v9 + 16);
          *(_DWORD *)buf = v35.n128_u32[0];
          v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
          v40 = 2112;
          v41 = v7;
          v42 = 2048;
          v43 = v8;
          v44 = 2048;
          v45 = v9;
          v46 = 2080;
          v47 = v10;
          _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %@ had existing entry %p for instance %p (%s)", buf, 0x34u);
        }

        v4 = 1;
        a2 = v35;
      }
      else
      {
        v4 = 1;
      }
    }
  }
  while (v3);
  if ((v4 & 1) == 0)
  {
LABEL_15:
    v14 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
    if (!v14)
    {
      __nwlog_obj();
      v33 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v39 = "strict_calloc";
      v40 = 2048;
      v41 = 1;
      v42 = 2048;
      v43 = 32;
      v34 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v34))
      {
        __break(1u);
        return;
      }
      free(v34);
    }
    v14[2] = a1[6];
    v15 = *(_QWORD *)(a1[4] + 16);
    *v14 = v15;
    if (v15)
      *(_QWORD *)(*(_QWORD *)(a1[4] + 16) + 8) = v14;
    *(_QWORD *)(a1[4] + 16) = v14;
    v16 = a1[4];
    v14[1] = v16 + 16;
    v17 = *(_QWORD *)(v16 + 64);
    v18 = v17 + 1;
    v19 = v17 == -1;
    v20 = v19 << 63 >> 63;
    *(_QWORD *)(v16 + 64) = v18;
    if (v20 == v19 && (v20 & 0x8000000000000000) == 0)
      goto LABEL_32;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = (id)gLogObj;
    v22 = *(_QWORD *)(a1[4] + 64);
    *(_DWORD *)buf = 136446978;
    v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
    v40 = 2082;
    v41 = (uint64_t)"registrar->instance_count";
    v42 = 2048;
    v43 = 1;
    v44 = 2048;
    v45 = v22;
    v23 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v23, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v25 = type;
        if (!os_log_type_enabled(v24, type))
          goto LABEL_39;
        v26 = *(_QWORD *)(a1[4] + 64);
        *(_DWORD *)buf = 136446978;
        v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        v40 = 2082;
        v41 = (uint64_t)"registrar->instance_count";
        v42 = 2048;
        v43 = 1;
        v44 = 2048;
        v45 = v26;
        v27 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
        goto LABEL_38;
      }
      if (!v36)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = (id)gLogObj;
        v25 = type;
        if (!os_log_type_enabled(v24, type))
          goto LABEL_39;
        v31 = *(_QWORD *)(a1[4] + 64);
        *(_DWORD *)buf = 136446978;
        v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        v40 = 2082;
        v41 = (uint64_t)"registrar->instance_count";
        v42 = 2048;
        v43 = 1;
        v44 = 2048;
        v45 = v31;
        v27 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (id)gLogObj;
      v25 = type;
      v29 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (!v29)
          goto LABEL_39;
        v32 = *(_QWORD *)(a1[4] + 64);
        *(_DWORD *)buf = 136446978;
        v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        v40 = 2082;
        v41 = (uint64_t)"registrar->instance_count";
        v42 = 2048;
        v43 = 1;
        v44 = 2048;
        v45 = v32;
        v27 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
LABEL_38:
        _os_log_impl(&dword_182FBE000, v24, v25, v27, buf, 0x2Au);
LABEL_39:

        if (!v23)
          goto LABEL_31;
        goto LABEL_30;
      }
      if (v29)
      {
        v30 = *(_QWORD *)(a1[4] + 64);
        *(_DWORD *)buf = 136447234;
        v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
        v40 = 2082;
        v41 = (uint64_t)"registrar->instance_count";
        v42 = 2048;
        v43 = 1;
        v44 = 2048;
        v45 = v30;
        v46 = 2082;
        v47 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
      }

      free(backtrace_string);
    }
    if (!v23)
    {
LABEL_31:
      *(_QWORD *)(a1[4] + 64) = -1;
LABEL_32:
      *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = v14;
      return;
    }
LABEL_30:
    free(v23);
    goto LABEL_31;
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v12 = a1[4];
      v13 = a1[6];
      *(_DWORD *)buf = 136446722;
      v39 = "nw_protocol_instance_registrar_add_instance_block_invoke";
      v40 = 2112;
      v41 = v12;
      v42 = 2048;
      v43 = v13;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Registrar %@ already has instance for protocol %p", buf, 0x20u);
    }

  }
}

void sub_18311EA14(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void nw_endpoint_handler_handle_failure(void *a1)
{
  void **v1;
  id *v2;
  id v3;
  unsigned int v4;
  unsigned int *v5;
  unsigned int *v6;
  void *v7;
  _QWORD *v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  nw_endpoint_t v12;
  const char *v13;
  unsigned int *v14;
  uint64_t v15;
  const char *v16;
  unsigned int *v17;
  os_unfair_lock_s *v18;
  const char *v19;
  const char *v20;
  os_unfair_lock_s *v21;
  id *v22;
  id v23;
  void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  unsigned int v31;
  const char *id_string;
  const char *v33;
  nw_endpoint_t v34;
  const char *logging_description;
  const char *v36;
  const char *v37;
  id v38;
  os_log_type_t v39;
  const char *v40;
  nw_endpoint_t v41;
  char v42;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  void *v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  id v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (v1[9])
    {
LABEL_3:
      if (*((_DWORD *)v2 + 29) == 2)
      {
        v3 = v2[31];
        objc_msgSend(v3, "cancelWithHandler:forced:", v2, 0);

      }
      *((_DWORD *)v2 + 30) = 4;
      goto LABEL_33;
    }
    v4 = *((unsigned __int8 *)v1 + 268);
    if ((v4 & 8) != 0)
    {
      v5 = v1;
      v6 = v5;
      v7 = (void *)*((_QWORD *)v5 + 4);
      if (v7)
      {
        v8 = v7;
        v9 = v8[12];

        if ((v9 & 0x4000000000) != 0)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v6) & 1) != 0)
            goto LABEL_32;
          v31 = v4;
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v10 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v6);
            v33 = nw_endpoint_handler_dry_run_string(v6);
            v34 = nw_endpoint_handler_copy_endpoint(v6);
            logging_description = nw_endpoint_get_logging_description(v34);
            v36 = nw_endpoint_handler_state_string(v6);
            v37 = nw_endpoint_handler_mode_string(v6);
            v38 = nw_endpoint_handler_copy_current_path(v6);
            *(_DWORD *)buf = 136447746;
            v45 = "nw_endpoint_handler_handle_failure";
            v46 = 2082;
            v47 = (void *)id_string;
            v48 = 2082;
            v49 = v33;
            v50 = 2082;
            v51 = logging_description;
            v52 = 2082;
            v53 = v36;
            v54 = 2082;
            v55 = v37;
            v56 = 2114;
            v57 = v38;
            _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] detected better path on parent handler, restarting evaluation", buf, 0x48u);

            v4 = v31;
          }
          goto LABEL_31;
        }
        if ((*((_BYTE *)v2 + 268) & 0x20) != 0)
          goto LABEL_32;
LABEL_14:
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v10 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          if ((*((_BYTE *)v2 + 268) & 1) != 0)
            v11 = "dry-run ";
          else
            v11 = "";
          v12 = nw_endpoint_handler_copy_endpoint(v6);
          v13 = nw_endpoint_get_logging_description(v12);
          v14 = v6 + 42;
          v15 = v6[30];
          if (v15 > 5)
            v16 = "unknown-state";
          else
            v16 = off_1E149FC48[v15];
          v17 = v6;
          v18 = (os_unfair_lock_s *)v17;
          v40 = v16;
          v41 = v12;
          v19 = v13;
          v20 = "path";
          switch(v17[29])
          {
            case 0u:
              break;
            case 1u:
              v20 = "resolver";
              break;
            case 2u:
              v20 = nw_endpoint_flow_mode_string(*((void **)v17 + 31));
              break;
            case 3u:
              v20 = "proxy";
              break;
            case 4u:
              v20 = "fallback";
              break;
            case 5u:
              v20 = "transform";
              break;
            default:
              v20 = "unknown-mode";
              break;
          }

          v21 = v18 + 28;
          v22 = v18;
          os_unfair_lock_lock(v18 + 28);
          v23 = v22[8];
          os_unfair_lock_unlock(v21);

          *(_DWORD *)buf = 136447746;
          v45 = "nw_endpoint_handler_handle_failure";
          v46 = 2082;
          v47 = v14;
          v48 = 2082;
          v49 = v11;
          v50 = 2082;
          v51 = v19;
          v52 = 2082;
          v53 = v40;
          v54 = 2082;
          v55 = v20;
          v56 = 2114;
          v57 = v23;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] detected better path on parent handler, restarting evaluation", buf, 0x48u);

        }
LABEL_31:

        goto LABEL_32;
      }

      if ((*((_BYTE *)v2 + 268) & 0x20) == 0)
        goto LABEL_14;
    }
    else if (!nw_parameters_get_indefinite(v1[4]))
    {
      goto LABEL_3;
    }
LABEL_32:
    nw_endpoint_handler_reset_mode(v2, (v4 >> 3) & 1);
    goto LABEL_33;
  }
  __nwlog_obj();
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v45 = "nw_endpoint_handler_handle_failure";
  v25 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v25, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      v30 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_endpoint_handler_handle_failure";
          v46 = 2082;
          v47 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_55;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_182FBE000, v26, v29, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_182FBE000, v26, v39, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_55:
  if (v25)
    free(v25);
LABEL_33:

}

void sub_18311F050(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_flow_passthrough_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  id *handle;
  id v6;
  void *v7;
  NWConcrete_nw_endpoint_handler *v8;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v10;
  NWConcrete_nw_endpoint_mode_handler *v11;
  NWConcrete_nw_endpoint_handler *v12;
  NSObject *v13;
  const char *v14;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  void (*remove_input_handler)(void);
  _QWORD *v18;
  void *v19;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  const char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_flow_passthrough_remove_input_handler";
    v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v21, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_flow_passthrough_remove_input_handler";
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        v26 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            v31 = "nw_flow_passthrough_remove_input_handler";
            v32 = 2082;
            v33 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_flow_passthrough_remove_input_handler";
          _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_flow_passthrough_remove_input_handler";
          _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_47:
    if (v21)
      free(v21);
    return 0;
  }
  if (a2 && a2->output_handler == a1)
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  if (a1->default_input_handler != a2)
    return 0;
  nw_protocol_set_input_handler((uint64_t)a1, 0);
  handle = (id *)a1->handle;
  if (!handle)
  {
    v12 = 0;
    goto LABEL_24;
  }
  v6 = handle[20];
  v7 = v6;
  if (v6)
  {
    v8 = (NWConcrete_nw_endpoint_handler *)v6;
    mode = v8->mode;

    if ((_DWORD)mode == 2)
    {
      v10 = nw_endpoint_handler_copy_flow(v8);
      v11 = v10;
      if (v10 && (*((_BYTE *)v10 + 36) & 1) != 0)
      {
        nw_endpoint_flow_failed_with_error(v8, 1, handle[40]);
        v12 = v8;
      }
      else
      {
        v12 = 0;
      }

      goto LABEL_23;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (mode > 5)
        v14 = "unknown-mode";
      else
        v14 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v31 = "nw_flow_passthrough_fail_if_needed";
      v32 = 2082;
      v33 = (void *)v14;
      v34 = 2082;
      v35 = "flow";
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }

  }
  v12 = 0;
LABEL_23:

LABEL_24:
  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      remove_input_handler = (void (*)(void))callbacks->remove_input_handler;
      if (remove_input_handler)
        remove_input_handler();
    }
  }
  v18 = a1->handle;
  if (v18)
  {
    v19 = (void *)v18[21];
    v18[21] = 0;

  }
  return 1;
}

void sub_18311F514(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_18311F530(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1831204BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183121004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,objc_super a22)
{
  void *v22;
  void *v23;

  a22.receiver = a12;
  a22.super_class = (Class)NWConcrete_nw_endpoint_handler;
  -[_Unwind_Exception dealloc](&a22, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_socket_internal_disconnect(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void (*v3)(_QWORD, uint64_t);
  const char *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  const char *v13;
  const char *v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 48);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 24);
    if (v2)
    {
      v3 = *(void (**)(_QWORD, uint64_t))(v2 + 48);
      if (v3)
      {
        v3(*(_QWORD *)(a1 + 48), a1 - 96);
        return;
      }
    }
    __nwlog_obj();
    v4 = *(const char **)(v1 + 16);
    if (!v4)
      v4 = "invalid";
  }
  else
  {
    __nwlog_obj();
    v4 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  v18 = "nw_socket_internal_disconnect";
  v19 = 2082;
  v20 = v4;
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v5, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      v8 = "invalid";
      if (v1 && *(_QWORD *)(v1 + 16))
        v8 = *(const char **)(v1 + 16);
      *(_DWORD *)buf = 136446466;
      v18 = "nw_socket_internal_disconnect";
      v19 = 2082;
      v20 = v8;
      v9 = "%{public}s protocol %{public}s has invalid disconnected callback";
      goto LABEL_34;
    }
    if (!v15)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      v13 = "invalid";
      if (v1 && *(_QWORD *)(v1 + 16))
        v13 = *(const char **)(v1 + 16);
      *(_DWORD *)buf = 136446466;
      v18 = "nw_socket_internal_disconnect";
      v19 = 2082;
      v20 = v13;
      v9 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_34;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v11 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v11)
      {
        v12 = "invalid";
        if (v1 && *(_QWORD *)(v1 + 16))
          v12 = *(const char **)(v1 + 16);
        *(_DWORD *)buf = 136446722;
        v18 = "nw_socket_internal_disconnect";
        v19 = 2082;
        v20 = v12;
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_35;
    }
    if (v11)
    {
      v14 = "invalid";
      if (v1 && *(_QWORD *)(v1 + 16))
        v14 = *(const char **)(v1 + 16);
      *(_DWORD *)buf = 136446466;
      v18 = "nw_socket_internal_disconnect";
      v19 = 2082;
      v20 = v14;
      v9 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
LABEL_34:
      _os_log_impl(&dword_182FBE000, v6, v7, v9, buf, 0x16u);
    }
  }
LABEL_35:
  if (v5)
    free(v5);
}

void nw_socket_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  char v3;
  NSObject *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_socket_disconnect";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_socket_disconnect";
      v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_socket_disconnect";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_42:
        if (!v5)
          return;
LABEL_43:
        free(v5);
        return;
      }
      if (!v10)
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_socket_disconnect";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_socket_disconnect";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_41:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_42;
  }
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_WORD *)((char *)&a1[6].handle + 5);
    *(_WORD *)((char *)&a1[6].handle + 5) |= 0x40u;
    if ((v3 & 8) != 0 || a1[5].handle)
    {
      if (v3 < 0)
      {
        nw_socket_update_output_source((char *)&a1[1].output_handler);
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v4 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_socket_disconnect";
          v17 = 2082;
          v18 = (char *)&a1[6].default_input_handler + 4;
          _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s Outstanding bytes to send, deferring socket disconnect", buf, 0x16u);
        }
        nw_socket_update_output_source((char *)&a1[1].output_handler);
      }
    }
    else
    {
      nw_socket_internal_disconnect((uint64_t)&a1[1].output_handler);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_socket_disconnect";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_socket_disconnect";
    v8 = "%{public}s called with null socket_handler";
    goto LABEL_41;
  }
  if (!v13)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_socket_disconnect";
    v8 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_41;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_socket_disconnect";
    v8 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_41;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_socket_disconnect";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5)
    goto LABEL_43;
}

void nw_protocol_default_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*disconnected)(void);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        disconnected = (void (*)(void))callbacks->disconnected;
        if (disconnected)
          disconnected();
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_default_disconnected";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_disconnected";
      v8 = "%{public}s called with null protocol";
      goto LABEL_19;
    }
    if (!v11)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_disconnected";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_19;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v10 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v14 = "nw_protocol_default_disconnected";
        v15 = 2082;
        v16 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_20;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_disconnected";
      v8 = "%{public}s called with null protocol, no backtrace";
LABEL_19:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    }
  }
LABEL_20:
  if (v5)
    free(v5);
}

void nw_protocol_default_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  void (*disconnect)(void);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    output_handler = a1->output_handler;
    if (output_handler)
    {
      callbacks = output_handler->callbacks;
      if (callbacks)
      {
        disconnect = (void (*)(void))callbacks->disconnect;
        if (disconnect)
          disconnect();
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_default_disconnect";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_disconnect";
      v8 = "%{public}s called with null protocol";
      goto LABEL_19;
    }
    if (!v11)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_disconnect";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_19;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v10 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v14 = "nw_protocol_default_disconnect";
        v15 = 2082;
        v16 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_20;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_default_disconnect";
      v8 = "%{public}s called with null protocol, no backtrace";
LABEL_19:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    }
  }
LABEL_20:
  if (v5)
    free(v5);
}

void nw_flow_passthrough_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  id *handle;
  id v4;
  void *v5;
  NWConcrete_nw_endpoint_handler *v6;
  uint64_t mode;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*disconnected)(void);
  NWConcrete_nw_endpoint_mode_handler *v11;
  NWConcrete_nw_endpoint_mode_handler *v12;
  NWConcrete_nw_endpoint_mode_handler *v13;
  uint64_t v14;
  NWConcrete_nw_endpoint_handler *v15;
  _BOOL4 v16;
  NSObject *v17;
  NWConcrete_nw_endpoint_handler *v18;
  NWConcrete_nw_endpoint_handler *v19;
  _BOOL4 v20;
  const char *v21;
  nw_endpoint_t v22;
  const char *v23;
  unsigned int *v24;
  unsigned int *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  const char *v29;
  id v30;
  _DWORD *v31;
  int v32;
  nw_protocol *v33;
  const char *name;
  uint64_t v35;
  int minimize_logging;
  char logging_disabled;
  NSObject *v38;
  const char *v39;
  const char *v40;
  nw_endpoint_t v41;
  const char *v42;
  const char *v43;
  const char *v44;
  id v45;
  NWConcrete_nw_endpoint_mode_handler *v46;
  id v47;
  id v48;
  id v49;
  void **v50;
  const char *v51;
  os_unfair_lock_s *v52;
  NWConcrete_nw_endpoint_mode_handler *v53;
  const char *v54;
  id *v55;
  NSObject *v56;
  NWConcrete_nw_endpoint_handler *v57;
  void *v58;
  nw_endpoint_t v59;
  const char *v60;
  const char *v61;
  os_unfair_lock_s *v62;
  id v63;
  os_unfair_lock_s *v64;
  const char *v65;
  const char *v66;
  nw_endpoint_t v67;
  NWConcrete_nw_endpoint_handler *v68;
  void *v69;
  const char *v70;
  void *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  void *v75;
  char *v76;
  NSObject *v77;
  os_log_type_t v78;
  char *v79;
  os_log_type_t v80;
  _BOOL4 v81;
  char *v82;
  os_log_type_t v83;
  _BOOL4 v84;
  void *v85;
  char *v86;
  NSObject *v87;
  os_log_type_t v88;
  char *backtrace_string;
  os_log_type_t v90;
  _BOOL4 v91;
  os_log_type_t v92;
  os_log_type_t v93;
  os_log_type_t v94;
  const char *id_string;
  nw_endpoint_t v96;
  const char *logging_description;
  const char *v98;
  const char *v99;
  id v100;
  NSObject *log;
  const char *loga;
  const char *logb;
  NWConcrete_nw_endpoint_mode_handler *v104;
  _QWORD v105[4];
  NWConcrete_nw_endpoint_handler *v106;
  NWConcrete_nw_endpoint_mode_handler *v107;
  id v108;
  id *v109;
  char v110;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v113;
  __int16 v114;
  void *id_str;
  __int16 v116;
  const char *v117;
  __int16 v118;
  const char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  const char *v123;
  __int16 v124;
  id v125;
  uint64_t v126;

  v126 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = (id *)a1->handle;
    v4 = handle[20];
    v5 = v4;
    if (v4)
    {
      v6 = (NWConcrete_nw_endpoint_handler *)v4;
      mode = v6->mode;

      if ((_DWORD)mode != 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v28 = (id)gLogObj;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          if (mode > 5)
            v29 = "unknown-mode";
          else
            v29 = off_1E149FC18[mode];
          *(_DWORD *)buf = 136446722;
          v113 = "nw_flow_passthrough_disconnected";
          v114 = 2082;
          id_str = (void *)v29;
          v116 = 2082;
          v117 = "flow";
          _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }

        goto LABEL_55;
      }
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        callbacks = default_input_handler->callbacks;
        if (callbacks)
        {
          disconnected = (void (*)(void))callbacks->disconnected;
          if (disconnected)
            disconnected();
        }
      }
      *((_WORD *)handle + 166) |= 0x210u;
      v11 = nw_endpoint_handler_copy_flow(v6);
      v104 = v11;
      if (handle == (id *)((char *)v11 + 376))
      {
        v30 = handle[40];
        if (v30)
        {
          v31 = v30;
          v32 = v31[3];

          if (v32 == 35)
          {
            v33 = a1->default_input_handler;
            if (v33)
            {
              name = v33->identifier->name;
              if (name)
              {
                if (!strcmp(name, "flow_replay"))
                {
                  v35 = (uint64_t)v33->default_input_handler;
                  if (v35)
                  {
                    if (!nw_protocol_input_handler_is_connection_flow(v35))
                    {
                      minimize_logging = nw_endpoint_handler_get_minimize_logging(v6);
                      logging_disabled = nw_endpoint_handler_get_logging_disabled(v6);
                      if (minimize_logging)
                      {
                        if ((logging_disabled & 1) != 0)
                          goto LABEL_37;
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v38 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
                        {
                          id_string = nw_endpoint_handler_get_id_string(v6);
                          logb = nw_endpoint_handler_dry_run_string(v6);
                          v96 = nw_endpoint_handler_copy_endpoint(v6);
                          logging_description = nw_endpoint_get_logging_description(v96);
                          v98 = nw_endpoint_handler_state_string(v6);
                          v99 = nw_endpoint_handler_mode_string(v6);
                          v100 = nw_endpoint_handler_copy_current_path(v6);
                          *(_DWORD *)buf = 136447746;
                          v113 = "nw_flow_passthrough_disconnected";
                          v114 = 2082;
                          id_str = (void *)id_string;
                          v116 = 2082;
                          v117 = logb;
                          v118 = 2082;
                          v119 = logging_description;
                          v120 = 2082;
                          v121 = v98;
                          v122 = 2082;
                          v123 = v99;
                          v124 = 2114;
                          v125 = v100;
                          _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received EAGAIN, rebuilding stack", buf, 0x48u);

                        }
                      }
                      else
                      {
                        if ((logging_disabled & 1) != 0)
                        {
LABEL_37:
                          v46 = v104;
                          nw_endpoint_flow_rebuild_stack(v6, a1);
                          v6->event = (nw_endpoint_handler_event_s)262147;
                          nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
LABEL_54:

LABEL_55:
                          return;
                        }
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v38 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
                        {
                          log = v38;
                          v39 = nw_endpoint_handler_get_id_string(v6);
                          v40 = nw_endpoint_handler_dry_run_string(v6);
                          v41 = nw_endpoint_handler_copy_endpoint(v6);
                          v42 = nw_endpoint_get_logging_description(v41);
                          v43 = nw_endpoint_handler_state_string(v6);
                          v44 = nw_endpoint_handler_mode_string(v6);
                          v45 = nw_endpoint_handler_copy_current_path(v6);
                          *(_DWORD *)buf = 136447746;
                          v113 = "nw_flow_passthrough_disconnected";
                          v114 = 2082;
                          id_str = (void *)v39;
                          v116 = 2082;
                          v117 = v40;
                          v118 = 2082;
                          v119 = v42;
                          v120 = 2082;
                          v121 = v43;
                          v122 = 2082;
                          v123 = v44;
                          v124 = 2114;
                          v125 = v45;
                          v38 = log;
                          _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received EAGAIN, rebuilding stack", buf, 0x48u);

                        }
                      }

                      goto LABEL_37;
                    }
                  }
                }
              }
            }
          }
        }
      }
      v12 = v11;
      v13 = v12;
      if (v12)
      {
        v14 = *((_QWORD *)v12 + 53);

        if (!v14)
        {
          v47 = handle[40];
          v48 = handle[23];
          v105[0] = MEMORY[0x1E0C809B0];
          v105[1] = 3221225472;
          v105[2] = ___ZL32nw_flow_passthrough_disconnectedP11nw_protocolS0__block_invoke;
          v105[3] = &unk_1E149C928;
          v106 = v6;
          v109 = handle;
          v107 = v13;
          v108 = v47;
          v49 = v47;
          nw_queue_context_async(v48, v105);

LABEL_53:
          v46 = v104;
          goto LABEL_54;
        }
LABEL_11:
        v15 = v6;
        v16 = (*((_BYTE *)v15 + 268) & 0x20) == 0;

        if (v16)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v17 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            v18 = v15;

            v19 = v18;
            v20 = (*((_BYTE *)v15 + 268) & 1) == 0;

            if (v20)
              v21 = "";
            else
              v21 = "dry-run ";
            v22 = nw_endpoint_handler_copy_endpoint(v19);
            v23 = nw_endpoint_get_logging_description(v22);
            v24 = v19;
            v25 = v24;
            v26 = v24[30];
            if (v26 > 5)
              v27 = "unknown-state";
            else
              v27 = off_1E149FC48[v26];

            v50 = v25;
            v51 = "path";
            switch(v6->mode)
            {
              case 0:
                break;
              case 1:
                v51 = "resolver";
                break;
              case 2:
                v51 = nw_endpoint_flow_mode_string(v50[31]);
                break;
              case 3:
                v51 = "proxy";
                break;
              case 4:
                v51 = "fallback";
                break;
              case 5:
                v51 = "transform";
                break;
              default:
                v51 = "unknown-mode";
                break;
            }
            loga = v51;

            v52 = v50;
            v53 = v13;
            v54 = v27;
            v55 = (id *)v52;
            v56 = v17;
            v57 = v18;
            v58 = v5;
            v59 = v22;
            v60 = v23;
            v61 = v21;
            v62 = v52 + 28;
            os_unfair_lock_lock(v52 + 28);
            v63 = v55[8];
            v64 = v62;
            v65 = v61;
            v66 = v60;
            v67 = v59;
            v5 = v58;
            v68 = v57;
            v17 = v56;
            v69 = v63;
            os_unfair_lock_unlock(v64);

            v70 = v54;
            v13 = v53;
            *(_DWORD *)buf = 136447746;
            v113 = "nw_flow_passthrough_disconnected";
            v114 = 2082;
            id_str = v68->id_str;
            v116 = 2082;
            v117 = v65;
            v118 = 2082;
            v119 = v66;
            v120 = 2082;
            v121 = v70;
            v122 = 2082;
            v123 = loga;
            v124 = 2114;
            v125 = v69;
            _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] deferring fail on disconnected", buf, 0x48u);

          }
        }
        *((_BYTE *)v13 + 36) |= 1u;
        goto LABEL_53;
      }
      __nwlog_obj();
      v85 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v113 = "nw_flow_passthrough_should_fail_on_disconnected";
      v86 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v110 = 0;
      if (__nwlog_fault(v86, &type, &v110))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v87 = objc_claimAutoreleasedReturnValue();
          v88 = type;
          if (os_log_type_enabled(v87, type))
          {
            *(_DWORD *)buf = 136446210;
            v113 = "nw_flow_passthrough_should_fail_on_disconnected";
            _os_log_impl(&dword_182FBE000, v87, v88, "%{public}s called with null endpoint_flow", buf, 0xCu);
          }
        }
        else if (v110)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v87 = objc_claimAutoreleasedReturnValue();
          v90 = type;
          v91 = os_log_type_enabled(v87, type);
          if (backtrace_string)
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446466;
              v113 = "nw_flow_passthrough_should_fail_on_disconnected";
              v114 = 2082;
              id_str = backtrace_string;
              _os_log_impl(&dword_182FBE000, v87, v90, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_109;
          }
          if (v91)
          {
            *(_DWORD *)buf = 136446210;
            v113 = "nw_flow_passthrough_should_fail_on_disconnected";
            _os_log_impl(&dword_182FBE000, v87, v90, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v87 = objc_claimAutoreleasedReturnValue();
          v94 = type;
          if (os_log_type_enabled(v87, type))
          {
            *(_DWORD *)buf = 136446210;
            v113 = "nw_flow_passthrough_should_fail_on_disconnected";
            _os_log_impl(&dword_182FBE000, v87, v94, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_109:
      if (v86)
        free(v86);
      goto LABEL_11;
    }
    __nwlog_obj();
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v113 = "nw_flow_passthrough_disconnected";
    v76 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v110 = 0;
    if (__nwlog_fault(v76, &type, &v110))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v77 = objc_claimAutoreleasedReturnValue();
        v78 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_182FBE000, v77, v78, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v110)
      {
        v82 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v77 = objc_claimAutoreleasedReturnValue();
        v83 = type;
        v84 = os_log_type_enabled(v77, type);
        if (v82)
        {
          if (v84)
          {
            *(_DWORD *)buf = 136446466;
            v113 = "nw_flow_passthrough_disconnected";
            v114 = 2082;
            id_str = v82;
            _os_log_impl(&dword_182FBE000, v77, v83, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v82);
          goto LABEL_101;
        }
        if (v84)
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_182FBE000, v77, v83, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v77 = objc_claimAutoreleasedReturnValue();
        v93 = type;
        if (os_log_type_enabled(v77, type))
        {
          *(_DWORD *)buf = 136446210;
          v113 = "nw_flow_passthrough_disconnected";
          _os_log_impl(&dword_182FBE000, v77, v93, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_101:
    if (v76)
      free(v76);
    goto LABEL_55;
  }
  __nwlog_obj();
  v71 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v113 = "nw_flow_passthrough_disconnected";
  v72 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v110 = 0;
  if (__nwlog_fault(v72, &type, &v110))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v73 = objc_claimAutoreleasedReturnValue();
      v74 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v110)
    {
      v79 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v73 = objc_claimAutoreleasedReturnValue();
      v80 = type;
      v81 = os_log_type_enabled(v73, type);
      if (v79)
      {
        if (v81)
        {
          *(_DWORD *)buf = 136446466;
          v113 = "nw_flow_passthrough_disconnected";
          v114 = 2082;
          id_str = v79;
          _os_log_impl(&dword_182FBE000, v73, v80, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v79);
        goto LABEL_96;
      }
      if (v81)
      {
        *(_DWORD *)buf = 136446210;
        v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_182FBE000, v73, v80, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v73 = objc_claimAutoreleasedReturnValue();
      v92 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        v113 = "nw_flow_passthrough_disconnected";
        _os_log_impl(&dword_182FBE000, v73, v92, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_96:
  if (v72)
    free(v72);
}

void sub_183122B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_indefinite(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[96] >> 6) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_indefinite";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_indefinite";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_indefinite";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_indefinite";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_indefinite";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

_QWORD *initializeBufferWithCopyOfBuffer for NWPath(uint64_t a1, uint64_t *a2, int *a3)
{
  _QWORD *v4;
  int v5;
  uint64_t v7;
  void *v8;
  char *v9;
  uint64_t v10;
  unsigned int (*v11)(char *, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  char *v19;

  v4 = (_QWORD *)a1;
  v5 = *(_DWORD *)(*((_QWORD *)a3 - 1) + 80);
  if ((v5 & 0x20000) != 0)
  {
    v13 = *a2;
    *v4 = *a2;
    v4 = (_QWORD *)(v13 + ((v5 + 16) & ~(unint64_t)v5));
    swift_retain();
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
    *(_QWORD *)(a1 + 8) = a2[1];
    *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
    *(_QWORD *)(a1 + 24) = a2[3];
    v7 = a3[11];
    v8 = (void *)(a1 + v7);
    v9 = (char *)a2 + v7;
    v10 = type metadata accessor for NWEndpoint();
    v11 = *(unsigned int (**)(char *, uint64_t, uint64_t))(*(_QWORD *)(v10 - 8) + 48);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    if (!v11(v9, 1, v10))
    {
      v14 = (char *)&loc_183122F64 + 4 * byte_183BA1640[swift_getEnumCaseMultiPayload()];
      __asm { BR              X10 }
    }
    v12 = __swift_instantiateConcreteTypeFromMangledName(qword_1ECD84160);
    memcpy(v8, v9, *(_QWORD *)(*(_QWORD *)(v12 - 8) + 64));
    v15 = a3[12];
    v16 = (char *)v4 + v15;
    v17 = (char *)a2 + v15;
    if (!v11((char *)a2 + v15, 1, v10))
    {
      v19 = (char *)&loc_1831230C8 + 4 * byte_183BA1645[swift_getEnumCaseMultiPayload()];
      __asm { BR              X10 }
    }
    v18 = __swift_instantiateConcreteTypeFromMangledName(qword_1ECD84160);
    memcpy(v16, v17, *(_QWORD *)(*(_QWORD *)(v18 - 8) + 64));
    *(_QWORD *)((char *)v4 + a3[13]) = *(uint64_t *)((char *)a2 + a3[13]);
    swift_unknownObjectRetain();
  }
  return v4;
}

void __tcp_connection_start_block_invoke(uint64_t a1, unsigned int a2, void *a3)
{
  id v6;
  uint64_t v7;
  int v8;
  int v9;
  id v10;
  NSObject *v11;
  void *v12;
  dispatch_source_t v13;
  void *v14;
  NSObject *v15;
  _QWORD *v16;
  unint64_t v17;
  NSObject *v18;
  dispatch_time_t v19;
  NSObject *v20;
  uint64_t v21;
  _BOOL4 v22;
  uint64_t v23;
  int v24;
  _BYTE *v25;
  void **v26;
  void *v27;
  void **v28;
  void *v29;
  void **v30;
  void *v31;
  void **v32;
  NSObject *v33;
  void **v34;
  NSObject *v35;
  void **v36;
  _DWORD *v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  char *v41;
  const char *v42;
  _BOOL4 v43;
  NSObject *v44;
  uint64_t v45;
  char *v46;
  const char *v47;
  uint64_t v48;
  void *v49;
  unsigned __int8 *v50;
  id v51;
  void *v52;
  void *v53;
  unsigned __int8 *v54;
  id v55;
  void *v56;
  void *v57;
  void *v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  char *backtrace_string;
  os_log_type_t v63;
  _BOOL4 v64;
  os_log_type_t v65;
  unsigned int v66;
  _QWORD v67[4];
  void **v68;
  void *v69;
  uint64_t v70;
  void (*v71)(uint64_t, int);
  void *v72;
  void **v73;
  _BYTE handler[24];
  char *v75;
  _BYTE v76[10];
  __int16 v77;
  id v78;
  _BYTE buf[24];
  unint64_t v80;
  void **v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v6 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 120));
  v7 = *(_QWORD *)(a1 + 32);
  if (*(unsigned __int8 *)(v7 + 156) != 255)
  {
    v66 = a2;
    switch(a2)
    {
      case 1u:
        v8 = 0;
        v9 = (*(unsigned __int8 *)(v7 + 159) << 29 >> 31) & 7;
        if (v6)
          goto LABEL_29;
        goto LABEL_30;
      case 2u:
        v10 = (id)v7;
        v11 = *((_QWORD *)v10 + 10);
        if (v11)
        {
          dispatch_source_cancel(v11);
          v12 = (void *)*((_QWORD *)v10 + 10);
          *((_QWORD *)v10 + 10) = 0;

        }
        if ((*((_BYTE *)v10 + 158) & 0x40) == 0)
          goto LABEL_84;
        v13 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *((dispatch_queue_t *)v10 + 7));
        v14 = (void *)*((_QWORD *)v10 + 10);
        *((_QWORD *)v10 + 10) = v13;

        v15 = *((_QWORD *)v10 + 10);
        if (v15)
        {
          *(_QWORD *)handler = MEMORY[0x1E0C809B0];
          *(_QWORD *)&handler[8] = 3221225472;
          *(_QWORD *)&handler[16] = __tcp_connection_start_attempt_timer_locked_block_invoke;
          v75 = (char *)&unk_1E14ACFD0;
          v16 = v10;
          *(_QWORD *)v76 = v16;
          dispatch_source_set_event_handler(v15, handler);
          if (v16[13])
            v17 = v16[13];
          else
            v17 = 180000000000;
          v18 = *((_QWORD *)v10 + 10);
          v19 = dispatch_time(0, v17);
          dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          dispatch_resume(*((dispatch_object_t *)v10 + 10));
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = (id)gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            v21 = v16[12];
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "tcp_connection_start_attempt_timer_locked";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v21;
            *(_WORD *)&buf[22] = 2048;
            v80 = v17 / 0x3B9ACA00;
            _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %llu scheduling connection attempt timer for %llus", buf, 0x20u);
          }

          goto LABEL_84;
        }
        __nwlog_obj();
        v58 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)handler = 136446210;
        *(_QWORD *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
        v59 = (char *)_os_log_send_and_compose_impl();

        buf[0] = 16;
        LOBYTE(v69) = 0;
        if (!__nwlog_fault(v59, buf, &v69))
          goto LABEL_82;
        if (buf[0] == 17)
        {
          __nwlog_obj();
          v60 = objc_claimAutoreleasedReturnValue();
          v61 = buf[0];
          if (os_log_type_enabled(v60, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(_QWORD *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s dispatch_source_create failed", handler, 0xCu);
          }
        }
        else if ((_BYTE)v69)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v60 = objc_claimAutoreleasedReturnValue();
          v63 = buf[0];
          v64 = os_log_type_enabled(v60, (os_log_type_t)buf[0]);
          if (backtrace_string)
          {
            if (v64)
            {
              *(_DWORD *)handler = 136446466;
              *(_QWORD *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
              *(_WORD *)&handler[12] = 2082;
              *(_QWORD *)&handler[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v60, v63, "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s", handler, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_82;
          }
          if (v64)
          {
            *(_DWORD *)handler = 136446210;
            *(_QWORD *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl(&dword_182FBE000, v60, v63, "%{public}s dispatch_source_create failed, no backtrace", handler, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v60 = objc_claimAutoreleasedReturnValue();
          v65 = buf[0];
          if (os_log_type_enabled(v60, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(_QWORD *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl(&dword_182FBE000, v60, v65, "%{public}s dispatch_source_create failed, backtrace limit exceeded", handler, 0xCu);
          }
        }

LABEL_82:
        if (v59)
          free(v59);
LABEL_84:

        v8 = 0;
        v9 = 0;
        *(_BYTE *)(*(_QWORD *)(a1 + 32) + 159) |= 4u;
        if (v6)
          goto LABEL_29;
        goto LABEL_30;
      case 3u:
        v22 = nw_connection_used_tls(*(void **)(v7 + 16));
        v23 = *(_QWORD *)(a1 + 32);
        v25 = (_BYTE *)(v23 + 159);
        v24 = *(unsigned __int8 *)(v23 + 159);
        if ((~v24 & 3) == 0)
        {
          v8 = 0;
          v9 = 0;
          goto LABEL_28;
        }
        v8 = 0;
        if ((v24 & v22 & 1) != 0)
        {
          v9 = 8;
        }
        else
        {
          *v25 = v24 | 1;
          v23 = *(_QWORD *)(a1 + 32);
          v9 = 1;
          if ((v24 & 1) != 0 || !v22)
          {
LABEL_28:
            *(_DWORD *)(v23 + 112) = 0;
            objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 24), a3);
            *(_QWORD *)(*(_QWORD *)(a1 + 32) + 128) = tcp_connection_quality_from_path(*(void **)(a1 + 32), *(void **)(*(_QWORD *)(a1 + 32) + 32));
            v26 = (void **)*(id *)(a1 + 32);
            v28 = v26 + 2;
            v27 = v26[2];
            v29 = (void *)MEMORY[0x1E0C809B0];
            *(_QWORD *)handler = MEMORY[0x1E0C809B0];
            *(_QWORD *)&handler[8] = 3221225472;
            *(_QWORD *)&handler[16] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke;
            v75 = (char *)&unk_1E14ACFD0;
            v30 = v26;
            *(_QWORD *)v76 = v30;
            nw_connection_set_read_close_handler(v27, handler);
            v31 = *v28;
            *(_QWORD *)buf = v29;
            *(_QWORD *)&buf[8] = 3221225472;
            *(_QWORD *)&buf[16] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_2;
            v80 = (unint64_t)&unk_1E14ACFD0;
            v32 = v30;
            v81 = v32;
            nw_connection_set_write_close_handler(v31, buf);
            v33 = *v28;
            v69 = v29;
            v70 = 3221225472;
            v71 = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_3;
            v72 = &unk_1E149FE40;
            v34 = v32;
            v73 = v34;
            nw_connection_set_viability_changed_handler(v33, &v69);
            v35 = *v28;
            v67[0] = v29;
            v67[1] = 3221225472;
            v67[2] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_4;
            v67[3] = &unk_1E149FE40;
            v68 = v34;
            v36 = v34;
            nw_connection_set_better_path_available_handler(v35, v67);

            if (v6)
              goto LABEL_29;
LABEL_30:
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = 0;
            v69 = 0;
            v70 = 0;
            if (v9)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v39 = (id)gLogObj;
              if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
              {
                v40 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96);
                v41 = off_1E149FE60[v9 - 1];
                if (v66 > 5)
                  v42 = "unknown";
                else
                  v42 = off_1E149DE10[v66];
                *(_DWORD *)handler = 136447234;
                *(_QWORD *)&handler[4] = "tcp_connection_start_block_invoke";
                *(_WORD *)&handler[12] = 2048;
                *(_QWORD *)&handler[14] = v40;
                *(_WORD *)&handler[22] = 2082;
                v75 = v41;
                *(_WORD *)v76 = 2082;
                *(_QWORD *)&v76[2] = v42;
                v77 = 2114;
                v78 = v6;
                _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s %llu sending event %{public}s in response to state %{public}s and error %{public}@", handler, 0x34u);
              }

              v43 = tcp_connection_fillout_event_locked(*(void **)(a1 + 32), (uint64_t)buf, v9, 0, 0, (uint64_t)"nw_connection event");
              if (!v8)
              {
LABEL_45:
                v48 = *(_QWORD *)(a1 + 32);
                if ((v43 | v8) == 1)
                {
                  v49 = _Block_copy(*(const void **)(v48 + 64));
                  v48 = *(_QWORD *)(a1 + 32);
                }
                else
                {
                  v49 = 0;
                }
                os_unfair_lock_unlock((os_unfair_lock_t)(v48 + 120));
                if (!v43)
                {
LABEL_54:
                  if (!v8)
                  {
LABEL_60:

                    goto LABEL_61;
                  }
                  v54 = (unsigned __int8 *)*(id *)(a1 + 32);
                  v55 = v49;
                  v56 = v55;
                  if (!v55 || v54[156] == 255)
                  {
                    v57 = v69;
                    if (!v69)
                      goto LABEL_59;
                  }
                  else
                  {
                    v57 = v69;
                    (*((void (**)(id, _QWORD, void *))v55 + 2))(v55, v70, v69);
                    if (!v57)
                    {
LABEL_59:

                      goto LABEL_60;
                    }
                  }
                  free(v57);
                  goto LABEL_59;
                }
                v50 = (unsigned __int8 *)*(id *)(a1 + 32);
                v51 = v49;
                v52 = v51;
                if (!v51 || v50[156] == 255)
                {
                  v53 = *(void **)buf;
                  if (!*(_QWORD *)buf)
                    goto LABEL_53;
                }
                else
                {
                  v53 = *(void **)buf;
                  (*((void (**)(id, _QWORD, _QWORD))v51 + 2))(v51, *(unsigned int *)&buf[8], *(_QWORD *)buf);
                  if (!v53)
                  {
LABEL_53:

                    goto LABEL_54;
                  }
                }
                free(v53);
                goto LABEL_53;
              }
            }
            else
            {
              v43 = 0;
              if (!v8)
                goto LABEL_45;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v44 = (id)gLogObj;
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              v45 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96);
              v46 = off_1E149FE60[v8 - 1];
              if (v66 > 5)
                v47 = "unknown";
              else
                v47 = off_1E149DE10[v66];
              *(_DWORD *)handler = 136447234;
              *(_QWORD *)&handler[4] = "tcp_connection_start_block_invoke";
              *(_WORD *)&handler[12] = 2048;
              *(_QWORD *)&handler[14] = v45;
              *(_WORD *)&handler[22] = 2082;
              v75 = v46;
              *(_WORD *)v76 = 2082;
              *(_QWORD *)&v76[2] = v47;
              v77 = 2114;
              v78 = v6;
              _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %llu sending secondary event %{public}s in response to state %{public}s and error %{public}@", handler, 0x34u);
            }

            v8 = tcp_connection_fillout_event_locked(*(void **)(a1 + 32), (uint64_t)&v69, v8, 0, 0, (uint64_t)"nw_connection secondary event");
            goto LABEL_45;
          }
          LOBYTE(v24) = *(_BYTE *)(v23 + 159);
          v8 = 8;
          v25 = (_BYTE *)(v23 + 159);
        }
        *v25 = v24 | 2;
        v23 = *(_QWORD *)(a1 + 32);
        goto LABEL_28;
      case 4u:
      case 5u:
        v8 = 0;
        v9 = 3;
        if (v6)
          goto LABEL_29;
        goto LABEL_30;
      default:
        v8 = 0;
        v9 = 0;
        if (v6)
        {
LABEL_29:
          objc_storeStrong((id *)(*(_QWORD *)(a1 + 32) + 24), a3);
          v37 = v6;
          v38 = v37[3];

          *(_DWORD *)(*(_QWORD *)(a1 + 32) + 112) = v38;
        }
        goto LABEL_30;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 120));
LABEL_61:

}

void nw_connection_set_write_close_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  id v15;
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_set_write_close_handler_block_invoke;
    v13[3] = &unk_1E14ACE18;
    v14 = v3;
    v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_connection_set_write_close_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_write_close_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = v17;
      v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_connection_set_write_close_handler";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_write_close_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_write_close_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183123EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void __nw_connection_set_write_close_handler_block_invoke(uint64_t a1)
{
  void *v1;
  id v2;
  id v3;
  NWConcrete_nw_endpoint_handler *v4;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v6;
  void *v7;
  void *v8;
  id v9;
  const char *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  const char *v18;
  os_log_type_t v19;
  const char *v20;
  const char *v21;
  id v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v1 = *(void **)(a1 + 40);
  v2 = *(id *)(*(_QWORD *)(a1 + 32) + 144);
  v3 = v1;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v31 = "nw_endpoint_handler_set_write_close_handler";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v27 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_182FBE000, v12, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v25 = type;
      v26 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_182FBE000, v12, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_endpoint_handler_set_write_close_handler";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_36:
    if (!v11)
      goto LABEL_38;
LABEL_37:
    free(v11);
    goto LABEL_38;
  }
  v4 = (NWConcrete_nw_endpoint_handler *)v2;
  mode = v4->mode;

  if ((_DWORD)mode == 2)
  {
    v6 = nw_endpoint_handler_copy_flow(v4);
    v7 = _Block_copy(v3);
    v8 = (void *)*((_QWORD *)v6 + 107);
    *((_QWORD *)v6 + 107) = v7;

    goto LABEL_38;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  if (mode > 5)
    v10 = "unknown-mode";
  else
    v10 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  v31 = "nw_endpoint_handler_set_write_close_handler";
  v32 = 2082;
  v33 = (void *)v10;
  v34 = 2082;
  v35 = "flow";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (!__nwlog_fault(v11, &type, &v28))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v13 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5)
        v14 = "unknown-mode";
      else
        v14 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_write_close_handler";
      v32 = 2082;
      v33 = (void *)v14;
      v34 = 2082;
      v35 = "flow";
      _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v19 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5)
        v20 = "unknown-mode";
      else
        v20 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_write_close_handler";
      v32 = 2082;
      v33 = (void *)v20;
      v34 = 2082;
      v35 = "flow";
      _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_35;
  }
  v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = (id)gLogObj;
  v16 = type;
  v17 = os_log_type_enabled(v12, type);
  if (!v15)
  {
    if (v17)
    {
      if (mode > 5)
        v21 = "unknown-mode";
      else
        v21 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_write_close_handler";
      v32 = 2082;
      v33 = (void *)v21;
      v34 = 2082;
      v35 = "flow";
      _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_35;
  }
  if (v17)
  {
    if (mode > 5)
      v18 = "unknown-mode";
    else
      v18 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    v31 = "nw_endpoint_handler_set_write_close_handler";
    v32 = 2082;
    v33 = (void *)v18;
    v34 = 2082;
    v35 = "flow";
    v36 = 2082;
    v37 = v15;
    _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v15);
  if (v11)
    goto LABEL_37;
LABEL_38:

}

void sub_183124594(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_connection_set_viability_changed_handler(nw_connection_t connection, nw_connection_BOOLean_event_handler_t handler)
{
  NSObject *v3;
  nw_connection_BOOLean_event_handler_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  NSObject *v14;
  id v15;
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = connection;
  v4 = handler;
  if (v3)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_set_viability_changed_handler_block_invoke;
    v13[3] = &unk_1E14ACE18;
    v14 = v3;
    v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_connection_set_viability_changed_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_viability_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = v17;
      v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_connection_set_viability_changed_handler";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_viability_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_viability_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1831248A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void __nw_connection_set_viability_changed_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 232);
  *(_QWORD *)(v3 + 232) = v2;

}

void nw_connection_set_read_close_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  id v15;
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_set_read_close_handler_block_invoke;
    v13[3] = &unk_1E14ACE18;
    v14 = v3;
    v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_connection_set_read_close_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_read_close_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = v17;
      v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_connection_set_read_close_handler";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_read_close_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_read_close_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183124BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void __nw_connection_set_read_close_handler_block_invoke(uint64_t a1)
{
  void *v1;
  id v2;
  id v3;
  NWConcrete_nw_endpoint_handler *v4;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v6;
  void *v7;
  void *v8;
  id v9;
  const char *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  const char *v18;
  os_log_type_t v19;
  const char *v20;
  const char *v21;
  id v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v1 = *(void **)(a1 + 40);
  v2 = *(id *)(*(_QWORD *)(a1 + 32) + 144);
  v3 = v1;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v31 = "nw_endpoint_handler_set_read_close_handler";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v27 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_182FBE000, v12, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v25 = type;
      v26 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_182FBE000, v12, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_endpoint_handler_set_read_close_handler";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_36:
    if (!v11)
      goto LABEL_38;
LABEL_37:
    free(v11);
    goto LABEL_38;
  }
  v4 = (NWConcrete_nw_endpoint_handler *)v2;
  mode = v4->mode;

  if ((_DWORD)mode == 2)
  {
    v6 = nw_endpoint_handler_copy_flow(v4);
    v7 = _Block_copy(v3);
    v8 = (void *)*((_QWORD *)v6 + 106);
    *((_QWORD *)v6 + 106) = v7;

    goto LABEL_38;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v9 = (id)gLogObj;
  if (mode > 5)
    v10 = "unknown-mode";
  else
    v10 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  v31 = "nw_endpoint_handler_set_read_close_handler";
  v32 = 2082;
  v33 = (void *)v10;
  v34 = 2082;
  v35 = "flow";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (!__nwlog_fault(v11, &type, &v28))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v13 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5)
        v14 = "unknown-mode";
      else
        v14 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_read_close_handler";
      v32 = 2082;
      v33 = (void *)v14;
      v34 = 2082;
      v35 = "flow";
      _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v19 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5)
        v20 = "unknown-mode";
      else
        v20 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_read_close_handler";
      v32 = 2082;
      v33 = (void *)v20;
      v34 = 2082;
      v35 = "flow";
      _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_35;
  }
  v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = (id)gLogObj;
  v16 = type;
  v17 = os_log_type_enabled(v12, type);
  if (!v15)
  {
    if (v17)
    {
      if (mode > 5)
        v21 = "unknown-mode";
      else
        v21 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v31 = "nw_endpoint_handler_set_read_close_handler";
      v32 = 2082;
      v33 = (void *)v21;
      v34 = 2082;
      v35 = "flow";
      _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_35;
  }
  if (v17)
  {
    if (mode > 5)
      v18 = "unknown-mode";
    else
      v18 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    v31 = "nw_endpoint_handler_set_read_close_handler";
    v32 = 2082;
    v33 = (void *)v18;
    v34 = 2082;
    v35 = "flow";
    v36 = 2082;
    v37 = v15;
    _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v15);
  if (v11)
    goto LABEL_37;
LABEL_38:

}

void sub_1831252C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t tcp_connection_quality_from_path(void *a1, void *a2)
{
  id v3;
  _QWORD *v4;
  void **v5;
  void **v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v10;

  v3 = a1;
  v4 = a2;
  if (v4)
  {
    v5 = (void **)v3;
    v6 = v5;
    v7 = v4[14];
    if (v7
      && *(_DWORD *)(v7 + 8)
      && (nw_parameters_get_pid(v5[6]),
          nw_parameters_get_effective_bundle_id(v6[6]),
          (_symptoms_is_daemon_fallback_blacklisted() & 1) == 0))
    {
      if (*((_DWORD *)v6 + 31) != 1)
        goto LABEL_12;
      if (tcp_connection_is_first_party_onceToken != -1)
        dispatch_once(&tcp_connection_is_first_party_onceToken, &__block_literal_global_31943);
      if (tcp_connection_is_first_party_is_first_party == 1)
      {
LABEL_12:

        v8 = 1;
        goto LABEL_7;
      }
      v10 = nw_parameters_multipath_fallback_allowed(v6[6]);

      if (v10)
      {
        v8 = 1;
        goto LABEL_7;
      }
    }
    else
    {

    }
  }
  v8 = 2;
LABEL_7:

  return v8;
}

BOOL tcp_connection_fillout_event_locked(void *a1, uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  _QWORD *v11;
  _QWORD *v12;
  _BYTE *v13;
  char v14;
  int v15;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  size_t v19;
  const char *v20;
  void *v21;
  uint64_t v22;
  _BOOL8 result;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  size_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = v11;
  if (*((unsigned __int8 *)v11 + 156) == 255)
  {
LABEL_50:
    v22 = 0;
LABEL_53:

    return v22;
  }
  if (a3 == 3)
  {
    *((_BYTE *)v11 + 156) = 3;
    *((_BYTE *)v11 + 158) |= 0x30u;
  }
  if (v11[8])
  {
    v13 = v11;
    switch(a3)
    {
      case 1:
        if ((v13[158] & 4) != 0)
          goto LABEL_18;
        v14 = v13[158] | 4;
        goto LABEL_16;
      case 2:
        if ((v13[158] & 1) != 0)
          goto LABEL_18;
        v14 = v13[158] | 1;
        goto LABEL_16;
      case 3:
        if ((v13[158] & 8) != 0)
          goto LABEL_18;
        v14 = v13[158] | 8;
        goto LABEL_16;
      case 4:
        if ((v13[158] & 2) != 0)
        {
LABEL_18:
          v15 = 0;
        }
        else
        {
          v14 = v13[158] | 2;
LABEL_16:
          v13[158] = v14;
LABEL_17:
          v15 = 1;
        }

        if (a3 != 7)
          goto LABEL_20;
        goto LABEL_21;
      default:
        goto LABEL_17;
    }
  }
  v15 = 0;
  if (a3 != 7)
  {
LABEL_20:
    if (a3 != 1)
      goto LABEL_23;
  }
LABEL_21:
  v16 = v12[10];
  if (v16)
  {
    dispatch_source_cancel(v16);
    v17 = (void *)v12[10];
    v12[10] = 0;

  }
LABEL_23:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    v19 = v12[12];
    switch(a3)
    {
      case 1073741825:
        v20 = "TCP_CONNECTION_EVENT_KEEPALIVE";
        break;
      case 1073741826:
        v20 = "TCP_CONNECTION_EVENT_CONDITIONS_CHANGED";
        break;
      case 1073741827:
        v20 = "TCP_CONNECTION_EVENT_DNSSEC";
        break;
      case 1073741828:
        v20 = "TCP_CONNECTION_EVENT_ADAPTIVE_READ_TIMEOUT";
        break;
      case 1073741829:
        v20 = "TCP_CONNECTION_EVENT_ADAPTIVE_WRITE_TIMEOUT";
        break;
      case 1073741830:
        v20 = "TCP_CONNECTION_EVENT_LOW_THROUGHPUT";
        break;
      case 1073741831:
        v20 = "TCP_CONNECTION_EVENT_BETTER_ROUTE_CHANGED";
        break;
      case 1073741832:
        v20 = "TCP_CONNECTION_EVENT_CONNECTION_ATTEMPT_TIMEOUT";
        break;
      case 1073741833:
        v20 = "TCP_CONNECTION_EVENT_CONNECTION_QUALITY_CHANGED";
        break;
      default:
        v20 = "TCP_CONNECTION_EVENT_CONNECTED";
        switch(a3)
        {
          case 1:
            goto LABEL_44;
          case 2:
            v20 = "TCP_CONNECTION_EVENT_READ_CLOSE";
            break;
          case 3:
            v20 = "TCP_CONNECTION_EVENT_DISCONNECTED";
            break;
          case 4:
            v20 = "TCP_CONNECTION_EVENT_WRITE_CLOSE";
            break;
          case 5:
            v20 = "TCP_CONNECTION_EVENT_BETTER_ROUTE";
            break;
          case 6:
            v20 = "TCP_CONNECTION_EVENT_VIABILITY_CHANGED";
            break;
          case 7:
            v20 = "TCP_CONNECTION_EVENT_WAITING";
            break;
          case 8:
            v20 = "TCP_CONNECTION_EVENT_TLS_HANDSHAKE_COMPLETE";
            break;
          default:
            v20 = "UNKNOWN";
            break;
        }
        break;
    }
LABEL_44:
    *(_DWORD *)buf = 136447234;
    v29 = "tcp_connection_fillout_event_locked";
    v30 = 2048;
    v31 = v19;
    v32 = 2082;
    v33 = v20;
    v34 = 2082;
    v35 = a6;
    v36 = 1024;
    v37 = v15;
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %llu event: %{public}s, reason: %{public}s, should deliver: %{BOOL}d", buf, 0x30u);
  }

  if (!v15)
    goto LABEL_50;
  if (!a4)
  {
    v21 = 0;
    goto LABEL_52;
  }
  if (!a5)
  {
    __nwlog_obj();
    v24 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v29 = "strict_malloc";
    v25 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v25);
    if (result)
      goto LABEL_58;
    free(v25);
  }
  v21 = malloc_type_malloc(a5, 0xF2B69DE5uLL);
  if (v21)
  {
LABEL_49:
    memcpy(v21, a4, a5);
LABEL_52:
    *(_DWORD *)(a2 + 8) = a3;
    *(_QWORD *)a2 = v21;
    v22 = 1;
    goto LABEL_53;
  }
  __nwlog_obj();
  v26 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v29 = "strict_malloc";
  v30 = 2048;
  v31 = a5;
  v27 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v27);
  if (!result)
  {
    free(v27);
    goto LABEL_49;
  }
LABEL_58:
  __break(1u);
  return result;
}

BOOL nw_connection_used_tls(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v19 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_used_tls_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_used_tls_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_used_tls";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_used_tls";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_used_tls";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_used_tls";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_used_tls";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_connection_set_better_path_available_handler(nw_connection_t connection, nw_connection_BOOLean_event_handler_t handler)
{
  NSObject *v3;
  nw_connection_BOOLean_event_handler_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  NSObject *v14;
  id v15;
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = connection;
  v4 = handler;
  if (v3)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_set_better_path_available_handler_block_invoke;
    v13[3] = &unk_1E14ACE18;
    v14 = v3;
    v15 = v4;
    nw_connection_async_if_needed(v14, v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_connection_set_better_path_available_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_better_path_available_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = v17;
      v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_connection_set_better_path_available_handler";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_better_path_available_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_connection_set_better_path_available_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183125E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void __nw_connection_used_tls_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = nw_endpoint_handler_stack_uses_tls(*(void **)(v2 + 144));
  }
  else
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        v6 = 136446466;
        v7 = "nw_connection_used_tls_block_invoke";
        v8 = 1024;
        v9 = v5;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Connection is not ready", (uint8_t *)&v6, 0x12u);
      }

    }
  }
}

uint64_t nw_endpoint_handler_stack_uses_tls(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  NWConcrete_nw_endpoint_handler *v3;
  uint64_t os_unfair_lock_opaque;
  NWConcrete_nw_endpoint_mode_handler *v5;
  uint64_t tls;
  NSObject *v7;
  const char *v8;
  nw_endpoint_t v9;
  const char *logging_description;
  uint64_t v11;
  const char *v12;
  const char *v13;
  id v14;
  const char *v15;
  id *v16;
  id v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  const char *v25;
  void **v26;
  void **v27;
  const char *v28;
  os_log_type_t v29;
  const char *v30;
  id *v31;
  id v32;
  const char *v33;
  void *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  const char *v43;
  char v44;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  os_unfair_lock_s *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  id v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v47 = "nw_endpoint_handler_stack_uses_tls";
    v36 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (__nwlog_fault(v36, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_endpoint_handler_stack_uses_tls";
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v44)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v40 = type;
        v41 = os_log_type_enabled(v37, type);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            v47 = "nw_endpoint_handler_stack_uses_tls";
            v48 = 2082;
            v49 = (os_unfair_lock_s *)backtrace_string;
            _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_87;
        }
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_endpoint_handler_stack_uses_tls";
          _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v37 = objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v47 = "nw_endpoint_handler_stack_uses_tls";
          _os_log_impl(&dword_182FBE000, v37, v42, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_87:
    if (v36)
      free(v36);
    goto LABEL_48;
  }
  os_unfair_lock_lock(v1 + 28);
  if (v2[29]._os_unfair_lock_opaque == 2)
  {
    v3 = v2;
    os_unfair_lock_opaque = v2[29]._os_unfair_lock_opaque;

    if ((_DWORD)os_unfair_lock_opaque == 2)
    {
      v5 = nw_endpoint_handler_copy_flow(v3);
      os_unfair_lock_lock((os_unfair_lock_t)v5 + 220);
      if ((*((_BYTE *)v5 + 32) & 2) != 0 || (*((_BYTE *)v5 + 33) & 1) != 0)
      {
        v16 = v3;
        v17 = v16[4];

        if (v17)
          tls = nw_parameters_get_tls(v17);
        else
          tls = 0;

      }
      else if (*((_QWORD *)v5 + 117))
      {
        tls = nw_endpoint_handler_stack_uses_tls();
      }
      else
      {
        tls = 0;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)v5 + 220);

      goto LABEL_69;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    if (os_unfair_lock_opaque > 5)
      v15 = "unknown-mode";
    else
      v15 = off_1E149FC18[os_unfair_lock_opaque];
    *(_DWORD *)buf = 136446722;
    v47 = "nw_endpoint_flow_stack_uses_tls";
    v48 = 2082;
    v49 = (os_unfair_lock_s *)v15;
    v50 = 2082;
    v51 = "flow";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (__nwlog_fault(v18, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          if (os_unfair_lock_opaque > 5)
            v21 = "unknown-mode";
          else
            v21 = off_1E149FC18[os_unfair_lock_opaque];
          *(_DWORD *)buf = 136446722;
          v47 = "nw_endpoint_flow_stack_uses_tls";
          v48 = 2082;
          v49 = (os_unfair_lock_s *)v21;
          v50 = 2082;
          v51 = "flow";
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v44)
      {
        v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v23 = type;
        v24 = os_log_type_enabled(v19, type);
        if (v22)
        {
          if (v24)
          {
            if (os_unfair_lock_opaque > 5)
              v25 = "unknown-mode";
            else
              v25 = off_1E149FC18[os_unfair_lock_opaque];
            *(_DWORD *)buf = 136446978;
            v47 = "nw_endpoint_flow_stack_uses_tls";
            v48 = 2082;
            v49 = (os_unfair_lock_s *)v25;
            v50 = 2082;
            v51 = "flow";
            v52 = 2082;
            v53 = v22;
            _os_log_impl(&dword_182FBE000, v19, v23, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v22);
          if (!v18)
            goto LABEL_68;
          goto LABEL_67;
        }
        if (v24)
        {
          if (os_unfair_lock_opaque > 5)
            v33 = "unknown-mode";
          else
            v33 = off_1E149FC18[os_unfair_lock_opaque];
          *(_DWORD *)buf = 136446722;
          v47 = "nw_endpoint_flow_stack_uses_tls";
          v48 = 2082;
          v49 = (os_unfair_lock_s *)v33;
          v50 = 2082;
          v51 = "flow";
          _os_log_impl(&dword_182FBE000, v19, v23, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v19, type))
        {
          if (os_unfair_lock_opaque > 5)
            v30 = "unknown-mode";
          else
            v30 = off_1E149FC18[os_unfair_lock_opaque];
          *(_DWORD *)buf = 136446722;
          v47 = "nw_endpoint_flow_stack_uses_tls";
          v48 = 2082;
          v49 = (os_unfair_lock_s *)v30;
          v50 = 2082;
          v51 = "flow";
          _os_log_impl(&dword_182FBE000, v19, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }

    }
    if (!v18)
    {
LABEL_68:
      tls = 0;
LABEL_69:

      os_unfair_lock_unlock(v2 + 28);
      goto LABEL_70;
    }
LABEL_67:
    free(v18);
    goto LABEL_68;
  }
  os_unfair_lock_unlock(v2 + 28);
  if ((v2[67]._os_unfair_lock_opaque & 0x20) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if ((v2[67]._os_unfair_lock_opaque & 1) != 0)
        v8 = "dry-run ";
      else
        v8 = "";
      v9 = nw_endpoint_handler_copy_endpoint(v2);
      logging_description = nw_endpoint_get_logging_description(v9);
      v11 = v2[30]._os_unfair_lock_opaque;
      v12 = logging_description;
      if (v11 > 5)
        v13 = "unknown-state";
      else
        v13 = off_1E149FC48[v11];
      v43 = v13;
      v26 = v2;
      v27 = v26;
      v28 = "path";
      switch(v2[29]._os_unfair_lock_opaque)
      {
        case 0u:
          break;
        case 1u:
          v28 = "resolver";
          break;
        case 2u:
          v28 = nw_endpoint_flow_mode_string(v26[31]);
          break;
        case 3u:
          v28 = "proxy";
          break;
        case 4u:
          v28 = "fallback";
          break;
        case 5u:
          v28 = "transform";
          break;
        default:
          v28 = "unknown-mode";
          break;
      }

      v31 = v27;
      os_unfair_lock_lock(v2 + 28);
      v32 = v31[8];
      os_unfair_lock_unlock(v2 + 28);

      *(_DWORD *)buf = 136447746;
      v47 = "nw_endpoint_handler_stack_uses_tls";
      v48 = 2082;
      v49 = v2 + 42;
      v50 = 2082;
      v51 = v8;
      v52 = 2082;
      v53 = (char *)v12;
      v54 = 2082;
      v55 = v43;
      v56 = 2082;
      v57 = v28;
      v58 = 2114;
      v59 = v32;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is not flow", buf, 0x48u);

    }
  }
LABEL_48:
  tls = 0;
LABEL_70:

  return tls;
}

void sub_1831268B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_tls(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)*((_QWORD *)v1 + 19);
    v4 = (void *)nw_protocol_boringssl_copy_definition();
    v5 = nw_protocol_stack_includes_protocol(v3, v4);

    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_parameters_get_tls";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_parameters_get_tls";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
  v5 = 0;
LABEL_3:

  return v5;
}

void sub_183126BA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_data_copy_outbound_subdata(void *a1, void *a2, uint64_t a3)
{
  id v5;
  id v6;
  void *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  uint64_t external;
  void *v19;
  uint64_t v20;
  uint64_t buffer_manager_with_context;
  _BOOL8 v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  _BOOL8 result;
  void *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  void *v31;
  os_log_type_t v32;
  char *backtrace_string;
  os_log_type_t v34;
  _BOOL4 v35;
  void *v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  void *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  os_log_type_t v44;
  _BOOL4 v45;
  char *v46;
  os_log_type_t v47;
  _BOOL4 v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  os_log_type_t v52;
  os_log_type_t v53;
  NSObject *v54;
  void *v55;
  os_log_type_t v56;
  os_log_type_t v57;
  char v58;
  os_log_type_t v59;
  os_log_type_t type[8];
  uint8_t buf[4];
  const char *v62;
  __int16 v63;
  size_t v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = v6;
  if (!v6)
  {
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_protocol_data_copy_outbound_subdata";
    v28 = (char *)_os_log_send_and_compose_impl();

    type[4] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v28, &type[4], type))
    {
      if (type[4] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v30 = type[4];
        if (os_log_type_enabled(v29, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null data", buf, 0xCu);
        }
        goto LABEL_87;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v52 = type[4];
        if (os_log_type_enabled(v29, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v29, v52, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_87;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v34 = type[4];
      v35 = os_log_type_enabled(v29, type[4]);
      if (!backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null data, no backtrace", buf, 0xCu);
        }
        goto LABEL_87;
      }
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        v62 = "nw_protocol_data_copy_outbound_subdata";
        v63 = 2082;
        v64 = (size_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_62:

      free(backtrace_string);
    }
LABEL_88:
    if (v28)
      free(v28);
    v24 = 0;
    goto LABEL_32;
  }
  if (!*((_QWORD *)v5 + 15))
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_protocol_data_copy_outbound_subdata";
    v28 = (char *)_os_log_send_and_compose_impl();

    type[4] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v28, &type[4], type))
    {
      if (type[4] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v32 = type[4];
        if (os_log_type_enabled(v29, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null instance->context", buf, 0xCu);
        }
LABEL_87:

        goto LABEL_88;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v53 = type[4];
        if (os_log_type_enabled(v29, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v29, v53, "%{public}s called with null instance->context, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_87;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v29 = objc_claimAutoreleasedReturnValue();
      v44 = type[4];
      v45 = os_log_type_enabled(v29, type[4]);
      if (!backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v29, v44, "%{public}s called with null instance->context, no backtrace", buf, 0xCu);
        }
        goto LABEL_87;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        v62 = "nw_protocol_data_copy_outbound_subdata";
        v63 = 2082;
        v64 = (size_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v29, v44, "%{public}s called with null instance->context, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_62;
    }
    goto LABEL_88;
  }
  v8 = (unsigned int *)v6;
  v9 = v8;
  if ((v8[51] & 2) != 0)
  {
    *(_QWORD *)type = 0;
    v16 = nw_frame_copy_external_data((uint64_t)v8, &type[4], type);
    if ((v9[51] & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v9, *((_QWORD *)v9 + 11)))
    {
      v17 = 0;
    }
    else
    {
      v17 = v9[12];
    }
    external = nw_frame_create_external(16, v17, (uint64_t)nw_protocol_outbound_data_finalizer, (uint64_t)v5);
    if (external)
    {
      v19 = (void *)external;
      nw_frame_set_external_data(external, v16, 0);
      nw_frame_claim((uint64_t)v19, v20, *(_DWORD *)&type[4] + a3, 0);

LABEL_30:
      v24 = v19;
      v24[2] = 0;
      v25 = (_QWORD *)*((_QWORD *)v5 + 19);
      v24[3] = v25;
      *v25 = v24;
      *((_QWORD *)v5 + 19) = v24 + 2;
LABEL_31:

LABEL_32:
      return (BOOL)v24;
    }
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v62 = "nw_protocol_data_copy_outbound_subdata";
    v37 = (char *)_os_log_send_and_compose_impl();

    v59 = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (!__nwlog_fault(v37, &v59, &v58))
      goto LABEL_100;
    if (v59 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      v39 = v59;
      if (os_log_type_enabled(v38, v59))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_data_copy_outbound_subdata";
        _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s nw_frame_create_external failed", buf, 0xCu);
      }
    }
    else if (v58)
    {
      v46 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      v47 = v59;
      v48 = os_log_type_enabled(v38, v59);
      if (v46)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          v63 = 2082;
          v64 = (size_t)v46;
          _os_log_impl(&dword_182FBE000, v38, v47, "%{public}s nw_frame_create_external failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v46);
        goto LABEL_100;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_data_copy_outbound_subdata";
        _os_log_impl(&dword_182FBE000, v38, v47, "%{public}s nw_frame_create_external failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v38 = objc_claimAutoreleasedReturnValue();
      v56 = v59;
      if (os_log_type_enabled(v38, v59))
      {
        *(_DWORD *)buf = 136446210;
        v62 = "nw_protocol_data_copy_outbound_subdata";
        _os_log_impl(&dword_182FBE000, v38, v56, "%{public}s nw_frame_create_external failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_100:
    if (v37)
      free(v37);

    goto LABEL_108;
  }
  if (!*((_QWORD *)v8 + 14)
    || (v8[51] & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(v8, *((_QWORD *)v8 + 11)))
  {
    v12 = 0;
    v13 = -(int)a3;
    if (!(_DWORD)a3)
    {
LABEL_11:
      v14 = 0;
      v15 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    v10 = v9[13];
    v11 = v9[14];
    if (v10)
      v10 -= v11 + v9[15];
    v12 = *((_QWORD *)v9 + 14) + v11;
    v13 = v10 - a3;
    if (v10 == (_DWORD)a3)
      goto LABEL_11;
  }
  buffer_manager_with_context = nw_frame_get_buffer_manager_with_context(*((void **)v5 + 15), v13);
  if (buffer_manager_with_context)
  {
    v15 = buffer_manager_with_context;
    v22 = nw_mem_buffer_allocate(buffer_manager_with_context);
    if (v22)
    {
      v14 = (void *)v22;
LABEL_24:
      memcpy(v14, (const void *)(v12 + a3), v13);
LABEL_25:
      v23 = nw_frame_create(16, (uint64_t)v14, v13, (uint64_t)nw_protocol_outbound_data_finalizer, (uint64_t)v5);
      if (v23)
      {
        v19 = (void *)v23;
        if (v15)
        {
          *(_QWORD *)(v23 + 104) = v15;
        }
        else if (v14)
        {
          *(_WORD *)(v23 + 204) |= 1u;
        }
        goto LABEL_30;
      }
      __nwlog_obj();
      v40 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v62 = "nw_protocol_data_copy_outbound_subdata";
      v41 = (char *)_os_log_send_and_compose_impl();

      type[4] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v41, &type[4], type))
        goto LABEL_106;
      if (type[4] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v42 = objc_claimAutoreleasedReturnValue();
        v43 = type[4];
        if (os_log_type_enabled(v42, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s nw_frame_create failed", buf, 0xCu);
        }
      }
      else if (type[0])
      {
        v49 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v42 = objc_claimAutoreleasedReturnValue();
        v50 = type[4];
        v51 = os_log_type_enabled(v42, type[4]);
        if (v49)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_protocol_data_copy_outbound_subdata";
            v63 = 2082;
            v64 = (size_t)v49;
            _os_log_impl(&dword_182FBE000, v42, v50, "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v49);
          goto LABEL_106;
        }
        if (v51)
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v42, v50, "%{public}s nw_frame_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v42 = objc_claimAutoreleasedReturnValue();
        v57 = type[4];
        if (os_log_type_enabled(v42, type[4]))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_protocol_data_copy_outbound_subdata";
          _os_log_impl(&dword_182FBE000, v42, v57, "%{public}s nw_frame_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

LABEL_106:
      if (v41)
        free(v41);
LABEL_108:
      v24 = 0;
      goto LABEL_31;
    }
  }
  v14 = malloc_type_malloc(v13, 0xF2B69DE5uLL);
  if (v14)
  {
    v15 = 0;
    goto LABEL_24;
  }
  __nwlog_obj();
  v54 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v54, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v62 = "strict_malloc";
  v63 = 2048;
  v64 = v13;
  v55 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v55);
  if (!result)
  {
    free(v55);
    v15 = 0;
    v14 = 0;
    goto LABEL_24;
  }
  __break(1u);
  return result;
}

void sub_183127700(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_socket_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  void *handle;
  nw_protocol **p_output_handler;
  _WORD *v10;
  int v11;
  uint64_t v12;
  NSObject *v14;
  int v16;
  unsigned int i;
  size_t v19;
  uint64_t output_frame;
  nw_protocol *output_handler;
  nw_frame **tqh_last;
  int v23;
  int v25;
  NSObject *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  int v31;
  char *v32;
  NSObject *v33;
  _BOOL4 v34;
  NSObject *v35;
  int v36;
  NSObject *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  int v42;
  char *v43;
  NSObject *v44;
  _BOOL4 v45;
  NSObject *v46;
  unsigned int v47;
  size_t v49;
  uint64_t v50;
  nw_protocol *v51;
  nw_frame **v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  char *v56;
  char *backtrace_string;
  _BOOL4 v59;
  char *v60;
  _BOOL4 v61;
  NSObject *log;
  NSObject *loga;
  char v64;
  os_log_type_t v65;
  socklen_t v66;
  os_log_type_t type[4];
  socklen_t v68;
  os_log_type_t v69[4];
  uint8_t buf[4];
  const char *v71;
  __int16 v72;
  _BYTE v73[14];
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_socket_get_output_frames";
    v56 = (char *)_os_log_send_and_compose_impl();
    v69[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v68) = 0;
    if (!__nwlog_fault(v56, v69, &v68))
      goto LABEL_130;
    if (v69[0] == OS_LOG_TYPE_FAULT)
    {
      v53 = __nwlog_obj();
      v54 = v69[0];
      if (!os_log_type_enabled(v53, v69[0]))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_socket_get_output_frames";
      v55 = "%{public}s called with null protocol";
    }
    else
    {
      if ((_BYTE)v68)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v53 = __nwlog_obj();
        v54 = v69[0];
        v59 = os_log_type_enabled(v53, v69[0]);
        if (!backtrace_string)
        {
          if (!v59)
            goto LABEL_130;
          *(_DWORD *)buf = 136446210;
          v71 = "nw_socket_get_output_frames";
          v55 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_129;
        }
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          v71 = "nw_socket_get_output_frames";
          v72 = 2082;
          *(_QWORD *)v73 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_130;
      }
      v53 = __nwlog_obj();
      v54 = v69[0];
      if (!os_log_type_enabled(v53, v69[0]))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_socket_get_output_frames";
      v55 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_129:
    _os_log_impl(&dword_182FBE000, v53, v54, v55, buf, 0xCu);
    goto LABEL_130;
  }
  handle = a1->handle;
  if (handle == &nw_protocol_ref_counted_handle)
    p_output_handler = &a1[1].output_handler;
  else
    p_output_handler = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_socket_get_output_frames";
    v56 = (char *)_os_log_send_and_compose_impl();
    v69[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v68) = 0;
    if (__nwlog_fault(v56, v69, &v68))
    {
      if (v69[0] == OS_LOG_TYPE_FAULT)
      {
        v53 = __nwlog_obj();
        v54 = v69[0];
        if (!os_log_type_enabled(v53, v69[0]))
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        v71 = "nw_socket_get_output_frames";
        v55 = "%{public}s called with null socket_handler";
      }
      else if ((_BYTE)v68)
      {
        v60 = (char *)__nw_create_backtrace_string();
        v53 = __nwlog_obj();
        v54 = v69[0];
        v61 = os_log_type_enabled(v53, v69[0]);
        if (v60)
        {
          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_socket_get_output_frames";
            v72 = 2082;
            *(_QWORD *)v73 = v60;
            _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v60);
          if (!v56)
            return 0;
          goto LABEL_131;
        }
        if (!v61)
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        v71 = "nw_socket_get_output_frames";
        v55 = "%{public}s called with null socket_handler, no backtrace";
      }
      else
      {
        v53 = __nwlog_obj();
        v54 = v69[0];
        if (!os_log_type_enabled(v53, v69[0]))
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        v71 = "nw_socket_get_output_frames";
        v55 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      }
      goto LABEL_129;
    }
LABEL_130:
    if (v56)
LABEL_131:
      free(v56);
    return 0;
  }
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  v10 = (_WORD *)((char *)&a1[6].handle + 5);
  v11 = *(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16);
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x4800) != 0)
    return 0;
  if ((~v11 & 0x18000) != 0)
  {
    v16 = (int)a1[4].handle;
    if (v16 != 2)
    {
      if (v16 != 1 || !a5 || !a4)
      {
LABEL_42:
        if ((v11 & 0x800) == 0)
        {
          HIBYTE(a1[6].handle) = BYTE2(v11);
          *v10 = v11 | 0x800;
          nw_queue_resume_source((uint64_t)p_output_handler[19], (uint64_t)a2);
        }
        nw_socket_set_send_low_water_mark((uint64_t)p_output_handler, 1u);
        return 0;
      }
      v12 = 0;
      for (i = 0; i < a4; i += v19)
      {
        if (a4 - i >= 0x2400)
          v19 = 9216;
        else
          v19 = a4 - i;
        output_frame = nw_socket_allocate_output_frame((uint64_t)p_output_handler, v19);
        if (!output_frame)
          break;
        *(_QWORD *)(output_frame + 16) = 0;
        output_handler = a1[5].output_handler;
        *(_QWORD *)(output_frame + 24) = output_handler;
        *(_QWORD *)output_handler->flow_id = output_frame;
        a1[5].output_handler = (nw_protocol *)(output_frame + 16);
        *(_QWORD *)(output_frame + 32) = 0;
        tqh_last = a6->tqh_last;
        *(_QWORD *)(output_frame + 40) = tqh_last;
        *tqh_last = (nw_frame *)output_frame;
        a6->tqh_last = (nw_frame **)(output_frame + 32);
        v12 = (v12 + 1);
        if (v12 >= a5)
          break;
      }
LABEL_28:
      v23 = (unsigned __int16)*v10;
      v11 = v23 | (HIBYTE(a1[6].handle) << 16);
      if ((v23 & 0x8000) != 0 && (_DWORD)v12)
      {
        *v10 = v23;
        HIBYTE(a1[6].handle) = (v11 | 0x10000u) >> 16;
        return v12;
      }
      if ((_DWORD)v12)
        return v12;
      goto LABEL_42;
    }
    if (a4 <= 0x10000)
    {
      v31 = 0x10000;
      goto LABEL_81;
    }
    v68 = 4;
    *(_DWORD *)v69 = 0;
    if (!getsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4132, v69, &v68))
    {
LABEL_58:
      v66 = 4;
      *(_DWORD *)type = 0x10000;
      if (!getsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4097, type, &v66))
      {
        v42 = *(_DWORD *)type;
LABEL_80:
        v31 = v42 - *(_DWORD *)v69;
LABEL_81:
        v12 = 0;
        v47 = 0;
        if (a3)
          goto LABEL_84;
LABEL_82:
        if (!(_DWORD)v12)
        {
          do
          {
            if (v31 == v47)
              break;
            v49 = a4 - v47 >= v31 - v47 ? v31 - v47 : a4 - v47;
            if (!(_DWORD)v49 && (_DWORD)v12)
              break;
            v50 = nw_socket_allocate_output_frame((uint64_t)p_output_handler, v49);
            if (!v50)
              break;
            *(_QWORD *)(v50 + 16) = 0;
            v51 = a1[5].output_handler;
            *(_QWORD *)(v50 + 24) = v51;
            *(_QWORD *)v51->flow_id = v50;
            a1[5].output_handler = (nw_protocol *)(v50 + 16);
            *(_QWORD *)(v50 + 32) = 0;
            v52 = a6->tqh_last;
            *(_QWORD *)(v50 + 40) = v52;
            *v52 = (nw_frame *)v50;
            a6->tqh_last = (nw_frame **)(v50 + 32);
            v12 = (v12 + 1);
            v47 += v49;
            if (v47 >= a3)
              goto LABEL_82;
LABEL_84:
            ;
          }
          while (!(_DWORD)v12 || a4 > v47);
        }
        goto LABEL_28;
      }
      v36 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v37 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v71 = "nw_socket_get_output_frames";
        v72 = 2080;
        *(_QWORD *)v73 = (char *)a1 + 436;
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v36;
        _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_SNDBUF failed %{darwin.errno}d", buf, 0x1Cu);
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v71 = "nw_socket_get_output_frames";
      v72 = 1024;
      *(_DWORD *)v73 = v36;
      v38 = (char *)_os_log_send_and_compose_impl();
      v65 = OS_LOG_TYPE_ERROR;
      v64 = 0;
      if (__nwlog_fault(v38, &v65, &v64))
      {
        if (v65 == OS_LOG_TYPE_FAULT)
        {
          v39 = __nwlog_obj();
          v40 = v65;
          if (os_log_type_enabled(v39, v65))
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_socket_get_output_frames";
            v72 = 1024;
            *(_DWORD *)v73 = v36;
            v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d";
LABEL_75:
            v46 = v39;
LABEL_76:
            _os_log_impl(&dword_182FBE000, v46, v40, v41, buf, 0x12u);
          }
        }
        else if (v64)
        {
          v43 = (char *)__nw_create_backtrace_string();
          v44 = __nwlog_obj();
          v40 = v65;
          loga = v44;
          v45 = os_log_type_enabled(v44, v65);
          if (v43)
          {
            if (v45)
            {
              *(_DWORD *)buf = 136446722;
              v71 = "nw_socket_get_output_frames";
              v72 = 1024;
              *(_DWORD *)v73 = v36;
              *(_WORD *)&v73[4] = 2082;
              *(_QWORD *)&v73[6] = v43;
              _os_log_impl(&dword_182FBE000, loga, v40, "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v43);
            goto LABEL_77;
          }
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_socket_get_output_frames";
            v72 = 1024;
            *(_DWORD *)v73 = v36;
            v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, no backtrace";
            v46 = loga;
            goto LABEL_76;
          }
        }
        else
        {
          v39 = __nwlog_obj();
          v40 = v65;
          if (os_log_type_enabled(v39, v65))
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_socket_get_output_frames";
            v72 = 1024;
            *(_DWORD *)v73 = v36;
            v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_75;
          }
        }
      }
LABEL_77:
      if (v38)
        free(v38);
      v42 = 0x10000;
      goto LABEL_80;
    }
    v25 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v26 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v71 = "nw_socket_get_output_frames";
      v72 = 2080;
      *(_QWORD *)v73 = (char *)a1 + 436;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v25;
      _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_NWRITE failed %{darwin.errno}d", buf, 0x1Cu);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v71 = "nw_socket_get_output_frames";
    v72 = 1024;
    *(_DWORD *)v73 = v25;
    v27 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v66) = 0;
    if (__nwlog_fault(v27, type, &v66))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v28 = __nwlog_obj();
        v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v71 = "nw_socket_get_output_frames";
          v72 = 1024;
          *(_DWORD *)v73 = v25;
          v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d";
LABEL_53:
          v35 = v28;
LABEL_54:
          _os_log_impl(&dword_182FBE000, v35, v29, v30, buf, 0x12u);
        }
      }
      else if ((_BYTE)v66)
      {
        v32 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v29 = type[0];
        log = v33;
        v34 = os_log_type_enabled(v33, type[0]);
        if (v32)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446722;
            v71 = "nw_socket_get_output_frames";
            v72 = 1024;
            *(_DWORD *)v73 = v25;
            *(_WORD *)&v73[4] = 2082;
            *(_QWORD *)&v73[6] = v32;
            _os_log_impl(&dword_182FBE000, log, v29, "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v32);
          goto LABEL_55;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v71 = "nw_socket_get_output_frames";
          v72 = 1024;
          *(_DWORD *)v73 = v25;
          v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, no backtrace";
          v35 = log;
          goto LABEL_54;
        }
      }
      else
      {
        v28 = __nwlog_obj();
        v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          v71 = "nw_socket_get_output_frames";
          v72 = 1024;
          *(_DWORD *)v73 = v25;
          v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_53;
        }
      }
    }
LABEL_55:
    if (v27)
      free(v27);
    *(_DWORD *)v69 = 0;
    goto LABEL_58;
  }
  v12 = 0;
  if ((*(_WORD *)((_BYTE *)&a1[6].handle + 5) & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v14 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v71 = "nw_socket_get_output_frames";
      v72 = 2082;
      *(_QWORD *)v73 = (char *)a1 + 436;
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Ignoring write while waiting for TFO", buf, 0x16u);
    }
    return 0;
  }
  return v12;
}

uint64_t nw_socket_allocate_output_frame(uint64_t a1, size_t count)
{
  unsigned int v2;
  uint64_t external;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  _BOOL8 v9;
  uint64_t v10;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  _BOOL4 v20;
  char *backtrace_string;
  _BOOL4 v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v2 = count;
  v29 = *MEMORY[0x1E0C80C00];
  external = *(_QWORD *)(a1 + 232);
  if (external)
  {
    v5 = *(_QWORD *)(external + 16);
    v6 = *(_QWORD **)(external + 24);
    if (v5)
    {
      *(_QWORD *)(v5 + 24) = v6;
      v6 = *(_QWORD **)(external + 24);
    }
    else
    {
      *(_QWORD *)(a1 + 240) = v6;
    }
    *v6 = v5;
    *(_QWORD *)(external + 16) = 0;
    *(_QWORD *)(external + 24) = 0;
    v8 = nw_frame_uses_external_data(external);
    if (!v2 || v8)
    {
      v10 = external;
      v9 = 0;
    }
    else
    {
      v9 = nw_calloc_type<unsigned char>(v2);
      v10 = external;
    }
    nw_frame_reset(v10, v9, v2, (uint64_t)nw_socket_frame_output_finalizer, a1);
    return external;
  }
  if ((*(_WORD *)(a1 + 333) & 0x1000) == 0)
  {
    if ((_DWORD)count)
    {
      v7 = nw_calloc_type<unsigned char>(count);
      external = nw_frame_create(0, v7, v2, (uint64_t)nw_socket_frame_output_finalizer, a1);
      if (external)
        return external;
    }
    else
    {
      external = nw_frame_create(0, 0, 0, (uint64_t)nw_socket_frame_output_finalizer, a1);
      v7 = 0;
      if (external)
        return external;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_socket_allocate_output_frame";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v15, &type, &v23))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_socket_allocate_output_frame";
      v18 = "%{public}s nw_frame_create failed";
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      v22 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_socket_allocate_output_frame";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_45;
      }
      if (!v22)
      {
LABEL_45:
        if (v15)
          free(v15);
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      v26 = "nw_socket_allocate_output_frame";
      v18 = "%{public}s nw_frame_create failed, no backtrace";
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v26 = "nw_socket_allocate_output_frame";
      v18 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
    goto LABEL_45;
  }
  external = nw_frame_create_external(0, count, (uint64_t)nw_socket_frame_output_finalizer, a1);
  if (external)
    return external;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_socket_allocate_output_frame";
  v7 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault((const char *)v7, &type, &v23))
    goto LABEL_47;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_socket_allocate_output_frame";
      v14 = "%{public}s nw_frame_create_external failed";
LABEL_41:
      _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
    }
  }
  else if (v23)
  {
    v19 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v19)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v26 = "nw_socket_allocate_output_frame";
        v27 = 2082;
        v28 = v19;
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s nw_frame_create_external failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v19);
      goto LABEL_47;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_socket_allocate_output_frame";
      v14 = "%{public}s nw_frame_create_external failed, no backtrace";
      goto LABEL_41;
    }
  }
  else
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_socket_allocate_output_frame";
      v14 = "%{public}s nw_frame_create_external failed, backtrace limit exceeded";
      goto LABEL_41;
    }
  }
LABEL_47:
  if (v7)
    free((void *)v7);
  return 0;
}

uint64_t nw_frame_create_external(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  objc_opt_class();
  v8 = _os_object_alloc();
  v9 = v8;
  if (v8)
  {
    v10 = *(unsigned __int16 *)(v8 + 204) | (*(unsigned __int8 *)(v8 + 206) << 16);
    if (a1)
      v10 |= 4u;
    *(_WORD *)(v8 + 204) = v10 | 2;
    *(_BYTE *)(v8 + 206) = BYTE2(v10);
    nw_frame_reset(v8, 0, a2, a3, a4);
    return v9;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_frame_create_external";
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_frame_create_external";
      v14 = "%{public}s nw_frame_obj_alloc failed";
      goto LABEL_18;
    }
    if (!v18)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_19;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_frame_create_external";
      v14 = "%{public}s nw_frame_obj_alloc failed, backtrace limit exceeded";
      goto LABEL_18;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v21 = "nw_frame_create_external";
        v22 = 2082;
        v23 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s nw_frame_obj_alloc failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_19;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v21 = "nw_frame_create_external";
      v14 = "%{public}s nw_frame_obj_alloc failed, no backtrace";
LABEL_18:
      _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
    }
  }
LABEL_19:
  if (v11)
    free(v11);
  return v9;
}

uint64_t nw_frame_copy_external_data(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "__nw_frame_get_external_data";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v7, &type, &v13))
      goto LABEL_29;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_29;
      *(_DWORD *)buf = 136446210;
      v16 = "__nw_frame_get_external_data";
      v10 = "%{public}s called with null frame";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "__nw_frame_get_external_data";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_29;
      }
      if (!v12)
      {
LABEL_29:
        if (v7)
          free(v7);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v16 = "__nw_frame_get_external_data";
      v10 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_29;
      *(_DWORD *)buf = 136446210;
      v16 = "__nw_frame_get_external_data";
      v10 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_29;
  }
  if ((*(_WORD *)(a1 + 204) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v16 = "__nw_frame_get_external_data";
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
    }
    return 0;
  }
  if (a2)
    *a2 = *(_DWORD *)(a1 + 56);
  if (a3)
  {
    v5 = *(_DWORD *)(a1 + 52);
    if (v5)
      v5 -= *(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60);
    *a3 = v5;
  }
  v4 = *(_QWORD *)(a1 + 96);
  if (v4)
    dispatch_retain(*(dispatch_object_t *)(a1 + 96));
  return v4;
}

uint64_t __nw_copy_current_audit_token_block_invoke()
{
  uint64_t result;
  mach_msg_type_number_t task_info_outCnt;

  task_info_outCnt = 8;
  result = task_info(*MEMORY[0x1E0C83DA0], 0xFu, (task_info_t)&nw_copy_current_audit_token::my_audit_token, &task_info_outCnt);
  nw_copy_current_audit_token::valid = (_DWORD)result == 0;
  return result;
}

uint64_t nw_protocol_instance_get_level(void *a1)
{
  unsigned int *v1;
  unsigned int *v2;
  void *v3;
  dispatch_queue_t *v4;
  dispatch_queue_t *v5;
  uint64_t v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)*((_QWORD *)v1 + 15);
    if (v3)
    {
      v4 = v3;
      v5 = v4;
      if (((_BYTE)v4[17] & 8) == 0)
        dispatch_assert_queue_V2(v4[1]);

    }
    v6 = v2[94];
    goto LABEL_7;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_instance_get_level";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_instance_get_level";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_instance_get_level";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_24:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_7:

  return v6;
}

void sub_183129690(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *nw_connection_create_with_connected_socket_and_parameters(int a1, void *a2)
{
  id v3;
  _DWORD *do_not_guard;
  id v5;
  _BOOL8 v6;
  _QWORD *v7;

  v3 = a2;
  do_not_guard = nw_fd_wrapper_create_do_not_guard(a1);
  v5 = v3;
  v6 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v5, 0, 0);

  v7 = nw_connection_create_with_connected_socket_internal(do_not_guard, (void *)v6, 0, 0, 0);
  if (!v7)
    nw_fd_wrapper_relinquish_fd(do_not_guard);

  return v7;
}

void sub_18312974C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void __33__nw_listener_inbox_socket_start__block_invoke(uint64_t a1)
{
  int v1;
  id *v2;
  _BOOL8 v3;
  int v4;
  int v5;
  nw_endpoint_t v6;
  _BOOL8 v7;
  int v8;
  nw_endpoint_t v9;
  BOOL v10;
  id v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  NSObject *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  NSObject *v20;
  uint8_t *v21;
  uint64_t v22;
  char v23;
  os_log_type_t type;
  socklen_t v25;
  int v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  socklen_t v30;
  __int16 v31;
  int sa_len;
  __int16 v33;
  char *v34;
  sockaddr address;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v1 = *(_DWORD *)(a1 + 40);
  v2 = (id *)*(id *)(a1 + 32);
  v3 = *((_BYTE *)v2 + 88) == 17 && nw_array_create();
  while ((objc_msgSend(v2[1], "canHandleNewConnection:", v2, v21, v22) & 1) != 0)
  {
    v41 = 0u;
    v42 = 0u;
    v40 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    address = (sockaddr)0;
    v25 = 128;
    v4 = *((unsigned __int8 *)v2 + 88);
    if (v4 == 17)
    {
      v26 = -1;
      *(_DWORD *)buf = 0;
      type = OS_LOG_TYPE_DEFAULT;
      v7 = nw_listener_inbox_accept_udp((uint64_t)v2);
      v8 = v26;
      if (v26 != -1)
      {
        v9 = nw_endpoint_create_address(&address);
        nw_listener_inbox_socket_handle_new_socket(v2, v8, v9, (void *)v7, *(int *)buf, (void *)v3);

      }
      v10 = type == OS_LOG_TYPE_DEFAULT;

      if (v10)
        goto LABEL_39;
    }
    else
    {
      if (v4 != 6)
        goto LABEL_39;
      v5 = accept(v1, &address, &v25);
      v26 = v5;
      if (v5 == -1)
        goto LABEL_39;
      if (v25 && v25 >= address.sa_len)
      {
        v6 = nw_endpoint_create_address(&address);
        nw_listener_inbox_socket_handle_new_socket(v2, v5, v6, 0, 0, (void *)v3);

      }
      else
      {
        if (!v25)
          goto LABEL_23;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        *(_DWORD *)buf = 136446722;
        v28 = "nw_listener_inbox_socket_handle_accept_event";
        v29 = 1024;
        v30 = v25;
        v31 = 1024;
        sa_len = address.sa_len;
        LODWORD(v22) = 24;
        v21 = buf;
        v12 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v23 = 0;
        if (!__nwlog_fault(v12, &type, &v23))
          goto LABEL_21;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = (id)gLogObj;
          v14 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446722;
            v28 = "nw_listener_inbox_socket_handle_accept_event";
            v29 = 1024;
            v30 = v25;
            v31 = 1024;
            sa_len = address.sa_len;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s Bad sockaddr length from kernel: slen = %u, ss.ss_len = %u", buf, 0x18u);
          }
          goto LABEL_20;
        }
        if (!v23)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = (id)gLogObj;
          v19 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446722;
            v28 = "nw_listener_inbox_socket_handle_accept_event";
            v29 = 1024;
            v30 = v25;
            v31 = 1024;
            sa_len = address.sa_len;
            _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s Bad sockaddr length from kernel: slen = %u, ss.ss_len = %u, backtrace limit exceeded", buf, 0x18u);
          }
LABEL_20:

LABEL_21:
          if (!v12)
            goto LABEL_23;
LABEL_22:
          free(v12);
          goto LABEL_23;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v16, type);
        if (!backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446722;
            v28 = "nw_listener_inbox_socket_handle_accept_event";
            v29 = 1024;
            v30 = v25;
            v31 = 1024;
            sa_len = address.sa_len;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s Bad sockaddr length from kernel: slen = %u, ss.ss_len = %u, no backtrace", buf, 0x18u);
          }

          goto LABEL_21;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446978;
          v28 = "nw_listener_inbox_socket_handle_accept_event";
          v29 = 1024;
          v30 = v25;
          v31 = 1024;
          sa_len = address.sa_len;
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s Bad sockaddr length from kernel: slen = %u, ss.ss_len = %u, dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(backtrace_string);
        if (v12)
          goto LABEL_22;
LABEL_23:
        close(v5);
        v26 = -1;
      }
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = (id)gLogObj;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)&address.sa_len = 136446210;
    *(_QWORD *)&address.sa_data[2] = "nw_listener_inbox_socket_handle_accept_event";
    _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_INFO, "%{public}s exceeded new connection limit", &address.sa_len, 0xCu);
  }

LABEL_39:
}

void sub_183129D08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183129F30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_parameters_set_server_mode(void *a1, char a2)
{
  unint64_t *v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if ((a2 & 1) != 0)
    {
      *(_DWORD *)(v3[13] + 84) = 0;
      v5 = v3[12] & 0xFFFFFFFFFFFFFF3FLL | 0x80;
      v6 = 0x8000;
    }
    else
    {
      v6 = 0;
      v5 = v3[12];
    }
    v3[12] = v5 & 0xFFFFFFFFFFFF7FFFLL | v6;
    goto LABEL_6;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_parameters_set_server_mode";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_server_mode";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_parameters_set_server_mode";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_server_mode";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_parameters_set_server_mode";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v8)
    free(v8);
LABEL_6:

}

void nw_parameters_set_local_endpoint(nw_parameters_t parameters, nw_endpoint_t local_endpoint)
{
  nw_parameters_t v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  Class isa;
  void *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = parameters;
  v4 = local_endpoint;
  v5 = v4;
  if (v3)
  {
    if (v4 && (v6 = v4, v7 = -[NSObject type](v6, "type"), v6, v7 == 1))
    {
      objc_storeStrong((id *)v3[13].isa + 20, local_endpoint);
    }
    else
    {
      isa = v3[13].isa;
      v9 = (void *)*((_QWORD *)isa + 20);
      *((_QWORD *)isa + 20) = 0;

    }
    goto LABEL_6;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_parameters_set_local_endpoint";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_parameters_set_local_endpoint";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_parameters_set_local_endpoint";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_parameters_set_local_endpoint";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_parameters_set_local_endpoint";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v11)
    free(v11);
LABEL_6:

}

void sub_18312A7D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_with_sock_name(int a1)
{
  socklen_t v1;
  NSObject *v2;
  id v4;
  void *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  id v9;
  os_log_type_t v10;
  char *v11;
  os_log_type_t v12;
  _BOOL4 v13;
  const char *v14;
  NSObject *v15;
  os_log_type_t v16;
  uint32_t v17;
  os_log_type_t v18;
  _BOOL4 v19;
  sockaddr *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint32_t v23;
  void *v24;
  os_log_type_t v25;
  char *backtrace_string;
  _BOOL4 v27;
  char v28;
  os_log_type_t type;
  socklen_t v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  socklen_t v34;
  __int16 v35;
  _QWORD v36[3];
  sockaddr address[8];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a1 < 0)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)&address[0].sa_len = 136446210;
    *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
    v5 = (void *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v30) = 0;
    if (!__nwlog_fault((const char *)v5, buf, &v30))
    {
LABEL_40:
      if (v5)
        free(v5);
      return 0;
    }
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v25 = buf[0];
      if (!os_log_type_enabled(v6, (os_log_type_t)buf[0]))
        goto LABEL_39;
      *(_DWORD *)&address[0].sa_len = 136446210;
      *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
      v8 = "%{public}s called with null (sockfd >= 0)";
    }
    else if ((_BYTE)v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v25 = buf[0];
      v27 = os_log_type_enabled(v6, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)&address[0].sa_len = 136446466;
          *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
          *(_WORD *)&address[0].sa_data[10] = 2082;
          *(_QWORD *)&address[0].sa_data[12] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v25, "%{public}s called with null (sockfd >= 0), dumping backtrace:%{public}s", &address[0].sa_len, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_40;
      }
      if (!v27)
        goto LABEL_39;
      *(_DWORD *)&address[0].sa_len = 136446210;
      *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
      v8 = "%{public}s called with null (sockfd >= 0), no backtrace";
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v25 = buf[0];
      if (!os_log_type_enabled(v6, (os_log_type_t)buf[0]))
        goto LABEL_39;
      *(_DWORD *)&address[0].sa_len = 136446210;
      *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_sock_name";
      v8 = "%{public}s called with null (sockfd >= 0), backtrace limit exceeded";
    }
    v20 = address;
    v21 = v6;
    v22 = v25;
    v23 = 12;
    goto LABEL_38;
  }
  memset(address, 0, sizeof(address));
  v30 = 128;
  if (!getsockname(a1, address, &v30))
  {
    if (v30 && v30 >= address[0].sa_len)
      return nw_endpoint_create_address(address);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    v32 = "nw_endpoint_create_with_sock_name";
    v33 = 1024;
    v34 = v30;
    v35 = 1024;
    LODWORD(v36[0]) = address[0].sa_len;
    v5 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault((const char *)v5, &type, &v28))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446722;
      v32 = "nw_endpoint_create_with_sock_name";
      v33 = 1024;
      v34 = v30;
      v35 = 1024;
      LODWORD(v36[0]) = address[0].sa_len;
      v8 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u";
    }
    else
    {
      if (v28)
      {
        v11 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(v6, type);
        if (v11)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446978;
            v32 = "nw_endpoint_create_with_sock_name";
            v33 = 1024;
            v34 = v30;
            v35 = 1024;
            LODWORD(v36[0]) = address[0].sa_len;
            WORD2(v36[0]) = 2082;
            *(_QWORD *)((char *)v36 + 6) = v11;
            v14 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u, dumping backtrace:%{public}s";
            v15 = v6;
            v16 = v12;
            v17 = 34;
LABEL_28:
            _os_log_impl(&dword_182FBE000, v15, v16, v14, buf, v17);
          }
LABEL_29:

          free(v11);
          goto LABEL_40;
        }
        if (!v13)
          goto LABEL_39;
        *(_DWORD *)buf = 136446722;
        v32 = "nw_endpoint_create_with_sock_name";
        v33 = 1024;
        v34 = v30;
        v35 = 1024;
        LODWORD(v36[0]) = address[0].sa_len;
        v8 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u, no backtrace";
        v20 = (sockaddr *)buf;
        v21 = v6;
        v22 = v12;
LABEL_33:
        v23 = 24;
LABEL_38:
        _os_log_impl(&dword_182FBE000, v21, v22, v8, &v20->sa_len, v23);
        goto LABEL_39;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446722;
      v32 = "nw_endpoint_create_with_sock_name";
      v33 = 1024;
      v34 = v30;
      v35 = 1024;
      LODWORD(v36[0]) = address[0].sa_len;
      v8 = "%{public}s getsockname provided invalid length: len: %u, ss.ss_len: %u, backtrace limit exceeded";
    }
    v20 = (sockaddr *)buf;
    v21 = v6;
    v22 = v7;
    goto LABEL_33;
  }
  v1 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v1 != 22 && v1 != 57 && v1 != 102)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v32 = "nw_endpoint_create_with_sock_name";
    v33 = 1024;
    v34 = v1;
    v5 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if ((__nwlog_fault((const char *)v5, &type, &v28) & 1) == 0)
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        v32 = "nw_endpoint_create_with_sock_name";
        v33 = 1024;
        v34 = v1;
        v8 = "%{public}s getsockname failed %{darwin.errno}d";
LABEL_36:
        v20 = (sockaddr *)buf;
        v21 = v6;
        v22 = v10;
LABEL_37:
        v23 = 18;
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        v32 = "nw_endpoint_create_with_sock_name";
        v33 = 1024;
        v34 = v1;
        v8 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_36;
      }
LABEL_39:

      goto LABEL_40;
    }
    v11 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    v18 = type;
    v19 = os_log_type_enabled(v6, type);
    if (!v11)
    {
      if (!v19)
        goto LABEL_39;
      *(_DWORD *)buf = 136446466;
      v32 = "nw_endpoint_create_with_sock_name";
      v33 = 1024;
      v34 = v1;
      v8 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
      v20 = (sockaddr *)buf;
      v21 = v6;
      v22 = v18;
      goto LABEL_37;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446722;
      v32 = "nw_endpoint_create_with_sock_name";
      v33 = 1024;
      v34 = v1;
      v35 = 2082;
      v36[0] = v11;
      v14 = "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s";
      v15 = v6;
      v16 = v18;
      v17 = 28;
      goto LABEL_28;
    }
    goto LABEL_29;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v32 = "nw_endpoint_create_with_sock_name";
    v33 = 1024;
    v34 = v1;
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s getsockname failed %{darwin.errno}d", buf, 0x12u);
  }

  return 0;
}

BOOL nw_parameters_get_local_only(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  _BOOL4 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = (BYTE1(v1[12].isa) >> 6) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_local_only";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_local_only";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_local_only";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_local_only";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_local_only";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_attach_protocol_listener(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[98] >> 6) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_attach_protocol_listener";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attach_protocol_listener";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_attach_protocol_listener";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attach_protocol_listener";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attach_protocol_listener";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void sub_18312B6AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26)
{
  void *v26;
  void *v27;

  _Block_object_dispose(&a21, 8);
  _Unwind_Resume(a1);
}

void sub_18312B7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_with_peer_name(int a1)
{
  socklen_t v2;
  NSObject *v3;
  nw_endpoint_t result;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  id v10;
  os_log_type_t v11;
  char *v12;
  os_log_type_t v13;
  _BOOL4 v14;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint32_t v18;
  os_log_type_t v19;
  _BOOL4 v20;
  sockaddr *v21;
  NSObject *v22;
  os_log_type_t v23;
  uint32_t v24;
  void *v25;
  os_log_type_t v26;
  char *backtrace_string;
  _BOOL4 v28;
  char v29;
  os_log_type_t type;
  socklen_t v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  socklen_t v35;
  __int16 v36;
  _QWORD v37[3];
  sockaddr address[8];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a1 < 0)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)&address[0].sa_len = 136446210;
    *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_peer_name";
    v6 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v31) = 0;
    if (__nwlog_fault(v6, buf, &v31))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v26 = buf[0];
        if (!os_log_type_enabled(v7, (os_log_type_t)buf[0]))
          goto LABEL_41;
        *(_DWORD *)&address[0].sa_len = 136446210;
        *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_peer_name";
        v9 = "%{public}s called with null (sockfd >= 0)";
      }
      else if ((_BYTE)v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v26 = buf[0];
        v28 = os_log_type_enabled(v7, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)&address[0].sa_len = 136446466;
            *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_peer_name";
            *(_WORD *)&address[0].sa_data[10] = 2082;
            *(_QWORD *)&address[0].sa_data[12] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v26, "%{public}s called with null (sockfd >= 0), dumping backtrace:%{public}s", &address[0].sa_len, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (!v28)
          goto LABEL_41;
        *(_DWORD *)&address[0].sa_len = 136446210;
        *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_peer_name";
        v9 = "%{public}s called with null (sockfd >= 0), no backtrace";
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v26 = buf[0];
        if (!os_log_type_enabled(v7, (os_log_type_t)buf[0]))
          goto LABEL_41;
        *(_DWORD *)&address[0].sa_len = 136446210;
        *(_QWORD *)&address[0].sa_data[2] = "nw_endpoint_create_with_peer_name";
        v9 = "%{public}s called with null (sockfd >= 0), backtrace limit exceeded";
      }
      v21 = address;
      v22 = v7;
      v23 = v26;
      v24 = 12;
      goto LABEL_40;
    }
    goto LABEL_42;
  }
  memset(address, 0, sizeof(address));
  v31 = 128;
  if (getpeername(a1, address, &v31))
  {
    v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v2 == 22 || v2 == 57 || v2 == 102)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = (id)gLogObj;
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v33 = "nw_endpoint_create_with_peer_name";
        v34 = 1024;
        v35 = v2;
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s getpeername failed %{darwin.errno}d", buf, 0x12u);
      }

      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v33 = "nw_endpoint_create_with_peer_name";
    v34 = 1024;
    v35 = v2;
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if ((__nwlog_fault(v6, &type, &v29) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446466;
          v33 = "nw_endpoint_create_with_peer_name";
          v34 = 1024;
          v35 = v2;
          v9 = "%{public}s getpeername failed %{darwin.errno}d";
LABEL_38:
          v21 = (sockaddr *)buf;
          v22 = v7;
          v23 = v11;
LABEL_39:
          v24 = 18;
          goto LABEL_40;
        }
        goto LABEL_41;
      }
      if (!v29)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446466;
          v33 = "nw_endpoint_create_with_peer_name";
          v34 = 1024;
          v35 = v2;
          v9 = "%{public}s getpeername failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_38;
        }
LABEL_41:

        goto LABEL_42;
      }
      v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v19 = type;
      v20 = os_log_type_enabled(v7, type);
      if (!v12)
      {
        if (!v20)
          goto LABEL_41;
        *(_DWORD *)buf = 136446466;
        v33 = "nw_endpoint_create_with_peer_name";
        v34 = 1024;
        v35 = v2;
        v9 = "%{public}s getpeername failed %{darwin.errno}d, no backtrace";
        v21 = (sockaddr *)buf;
        v22 = v7;
        v23 = v19;
        goto LABEL_39;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446722;
        v33 = "nw_endpoint_create_with_peer_name";
        v34 = 1024;
        v35 = v2;
        v36 = 2082;
        v37[0] = v12;
        v15 = "%{public}s getpeername failed %{darwin.errno}d, dumping backtrace:%{public}s";
        v16 = v7;
        v17 = v19;
        v18 = 28;
        goto LABEL_30;
      }
      goto LABEL_31;
    }
LABEL_42:
    if (v6)
      free(v6);
    return 0;
  }
  if (!v31 || v31 < address[0].sa_len)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    v33 = "nw_endpoint_create_with_peer_name";
    v34 = 1024;
    v35 = v31;
    v36 = 1024;
    LODWORD(v37[0]) = address[0].sa_len;
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v6, &type, &v29))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446722;
      v33 = "nw_endpoint_create_with_peer_name";
      v34 = 1024;
      v35 = v31;
      v36 = 1024;
      LODWORD(v37[0]) = address[0].sa_len;
      v9 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u";
    }
    else
    {
      if (v29)
      {
        v12 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v13 = type;
        v14 = os_log_type_enabled(v7, type);
        if (v12)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446978;
            v33 = "nw_endpoint_create_with_peer_name";
            v34 = 1024;
            v35 = v31;
            v36 = 1024;
            LODWORD(v37[0]) = address[0].sa_len;
            WORD2(v37[0]) = 2082;
            *(_QWORD *)((char *)v37 + 6) = v12;
            v15 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u, dumping backtrace:%{public}s";
            v16 = v7;
            v17 = v13;
            v18 = 34;
LABEL_30:
            _os_log_impl(&dword_182FBE000, v16, v17, v15, buf, v18);
          }
LABEL_31:

          free(v12);
          goto LABEL_42;
        }
        if (!v14)
          goto LABEL_41;
        *(_DWORD *)buf = 136446722;
        v33 = "nw_endpoint_create_with_peer_name";
        v34 = 1024;
        v35 = v31;
        v36 = 1024;
        LODWORD(v37[0]) = address[0].sa_len;
        v9 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u, no backtrace";
        v21 = (sockaddr *)buf;
        v22 = v7;
        v23 = v13;
LABEL_35:
        v24 = 24;
LABEL_40:
        _os_log_impl(&dword_182FBE000, v22, v23, v9, &v21->sa_len, v24);
        goto LABEL_41;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446722;
      v33 = "nw_endpoint_create_with_peer_name";
      v34 = 1024;
      v35 = v31;
      v36 = 1024;
      LODWORD(v37[0]) = address[0].sa_len;
      v9 = "%{public}s getpeername provided invalid length: len: %u, ss.ss_len: %u, backtrace limit exceeded";
    }
    v21 = (sockaddr *)buf;
    v22 = v7;
    v23 = v8;
    goto LABEL_35;
  }
  result = nw_endpoint_create_address(address);
  if (result && address[0].sa_family == 1)
    LODWORD(result[48].isa) = a1;
  return result;
}

uint64_t nw_path_get_sysctls_region()
{
  if (nw_path_get_sysctls_region::sSysctlsRegion != -1)
    dispatch_once(&nw_path_get_sysctls_region::sSysctlsRegion, &__block_literal_global_284);
  return nw_path_get_sysctls_region::sysctls_region;
}

BOOL nw_channel_create_with_attributes(_DWORD *a1, unsigned __int8 *uu, unsigned int a3, uint64_t a4)
{
  uint64_t globals_for_channel;
  os_unfair_lock_s *v9;
  char *v10;
  const void *v11;
  size_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  uint64_t extended;
  int fd;
  NSObject *v20;
  const char *v21;
  _WORD *v22;
  int v23;
  unsigned int v24;
  void *v25;
  unint64_t v26;
  NSObject *v27;
  void *v28;
  _BOOL8 result;
  BOOL is_inline;
  id v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  char *v40;
  _BOOL4 v41;
  int v42;
  _BOOL4 v43;
  NSObject *v44;
  char *v45;
  _BOOL4 v46;
  _BOOL8 v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  _BOOL8 source;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  char *v60;
  _BOOL4 v61;
  NSObject *v62;
  int v63;
  NSObject *v64;
  os_log_type_t v65;
  uint32_t v66;
  uint64_t v67;
  const char *v68;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  const char *v73;
  char *v74;
  _BOOL4 v75;
  const char *v76;
  const char *v77;
  const char *v78;
  void *v79;
  char *v80;
  NSObject *v81;
  os_log_type_t v82;
  const char *v83;
  char *backtrace_string;
  _BOOL4 v85;
  const char *v86;
  _BOOL4 v87;
  NSObject *v88;
  os_log_type_t v89;
  char *v90;
  _BOOL4 v91;
  NSObject *v92;
  char *v93;
  NSObject *v94;
  os_log_type_t v95;
  const char *v96;
  char *v97;
  _BOOL4 v98;
  int v99;
  void *v100;
  _QWORD v101[5];
  _QWORD v102[5];
  _QWORD v103[5];
  _QWORD v104[5];
  os_log_type_t v105[8];
  uint64_t v106;
  void (*v107)(uint64_t);
  void *v108;
  char *v109;
  BOOL v110;
  _QWORD v111[5];
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  void *v115;
  char *v116;
  BOOL v117;
  char v118;
  os_log_type_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  os_log_type_t type[8];
  char out[48];
  _BYTE block[24];
  const char *v126;
  __int128 v127;
  _BYTE buf[32];
  uint64_t v129;

  v129 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
    v80 = (char *)_os_log_send_and_compose_impl();
    out[0] = 16;
    LOBYTE(v112) = 0;
    if (!__nwlog_fault(v80, out, &v112))
      goto LABEL_190;
    if (out[0] == 17)
    {
      v81 = __nwlog_obj();
      v82 = out[0];
      if (os_log_type_enabled(v81, (os_log_type_t)out[0]))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        v83 = "%{public}s called with null context";
LABEL_189:
        _os_log_impl(&dword_182FBE000, v81, v82, v83, block, 0xCu);
      }
LABEL_190:
      if (v80)
        free(v80);
      return 0;
    }
    if (!(_BYTE)v112)
    {
      v81 = __nwlog_obj();
      v82 = out[0];
      if (os_log_type_enabled(v81, (os_log_type_t)out[0]))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        v83 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v81 = __nwlog_obj();
    v82 = out[0];
    v85 = os_log_type_enabled(v81, (os_log_type_t)out[0]);
    if (!backtrace_string)
    {
      if (v85)
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        v83 = "%{public}s called with null context, no backtrace";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (v85)
    {
      *(_DWORD *)block = 136446466;
      *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
      *(_WORD *)&block[12] = 2082;
      *(_QWORD *)&block[14] = backtrace_string;
      v86 = "%{public}s called with null context, dumping backtrace:%{public}s";
LABEL_175:
      _os_log_impl(&dword_182FBE000, v81, v82, v86, block, 0x16u);
    }
LABEL_176:
    free(backtrace_string);
    goto LABEL_190;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)block = 136446210;
    *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
    v80 = (char *)_os_log_send_and_compose_impl();
    out[0] = 16;
    LOBYTE(v112) = 0;
    if (!__nwlog_fault(v80, out, &v112))
      goto LABEL_190;
    if (out[0] == 17)
    {
      v81 = __nwlog_obj();
      v82 = out[0];
      if (os_log_type_enabled(v81, (os_log_type_t)out[0]))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        v83 = "%{public}s called with null attributes";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (!(_BYTE)v112)
    {
      v81 = __nwlog_obj();
      v82 = out[0];
      if (os_log_type_enabled(v81, (os_log_type_t)out[0]))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        v83 = "%{public}s called with null attributes, backtrace limit exceeded";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v81 = __nwlog_obj();
    v82 = out[0];
    v87 = os_log_type_enabled(v81, (os_log_type_t)out[0]);
    if (!backtrace_string)
    {
      if (v87)
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        v83 = "%{public}s called with null attributes, no backtrace";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (v87)
    {
      *(_DWORD *)block = 136446466;
      *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
      *(_WORD *)&block[12] = 2082;
      *(_QWORD *)&block[14] = backtrace_string;
      v86 = "%{public}s called with null attributes, dumping backtrace:%{public}s";
      goto LABEL_175;
    }
    goto LABEL_176;
  }
  memset(out, 0, sizeof(out));
  uuid_unparse(uu, out);
  snprintf(&out[36], 0xCuLL, "-%u", a3);
  globals_for_channel = nw_context_get_globals_for_channel(a1);
  v9 = (os_unfair_lock_s *)(globals_for_channel + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_channel + 16));
  v10 = (char *)nw_dictionary_copy_value(*(_QWORD *)globals_for_channel, (uint64_t)out);
  if (v10)
  {
LABEL_157:
    os_unfair_lock_unlock(v9);
    return (BOOL)v10;
  }
  v11 = *(const void **)a4;
  v12 = *(unsigned int *)(a4 + 8);
  v13 = *(_BYTE *)(a4 + 12);
  if (nw_channel_init(void)::onceToken != -1)
    dispatch_once(&nw_channel_init(void)::onceToken, &__block_literal_global_43_86472);
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  objc_opt_class();
  v14 = _os_object_alloc();
  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_create";
    v32 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v122) = 0;
    if (!__nwlog_fault(v32, type, &v122))
      goto LABEL_107;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v33 = gLogObj;
      v34 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v35 = "%{public}s nw_channel_obj_alloc failed";
    }
    else if ((_BYTE)v122)
    {
      v40 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v33 = gLogObj;
      v34 = type[0];
      v41 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v40)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v40;
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s nw_channel_obj_alloc failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v40);
        goto LABEL_107;
      }
      if (!v41)
      {
LABEL_107:
        if (v32)
          free(v32);
        goto LABEL_126;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v35 = "%{public}s nw_channel_obj_alloc failed, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v33 = gLogObj;
      v34 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v35 = "%{public}s nw_channel_obj_alloc failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
    goto LABEL_107;
  }
  v10 = (char *)v14;
  *(_OWORD *)(v14 + 88) = *(_OWORD *)uu;
  *(_DWORD *)(v14 + 428) = a3;
  v15 = os_channel_attr_create();
  *((_QWORD *)v10 + 18) = v15;
  if (!v15)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_create";
    v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v122) = 0;
    if (!__nwlog_fault(v36, type, &v122))
      goto LABEL_123;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = gLogObj;
      v38 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s os_channel_attr_create failed";
    }
    else if ((_BYTE)v122)
    {
      v45 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = gLogObj;
      v38 = type[0];
      v46 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v45)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v45;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s os_channel_attr_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v45);
        goto LABEL_123;
      }
      if (!v46)
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s os_channel_attr_create failed, no backtrace";
    }
    else
    {
      v37 = __nwlog_obj();
      v38 = type[0];
      if (!os_log_type_enabled(v37, type[0]))
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s os_channel_attr_create failed, backtrace limit exceeded";
    }
LABEL_121:
    v64 = v37;
    v65 = v38;
    v66 = 12;
LABEL_122:
    _os_log_impl(&dword_182FBE000, v64, v65, v39, buf, v66);
    goto LABEL_123;
  }
  if (v11)
    v16 = (_DWORD)v12 == 0;
  else
    v16 = 1;
  v17 = !v16;
  v99 = v17;
  if (!v16)
    os_channel_attr_set_key();
  os_channel_attr_set();
  if ((v13 & 1) != 0)
    os_channel_attr_set();
  if ((v13 & 2) != 0)
    os_channel_attr_set();
  os_channel_attr_set();
  if (a3 >= 0x10000)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v122) = 0;
    if (__nwlog_fault(v36, type, &v122))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v88 = __nwlog_obj();
        v89 = type[0];
        if (os_log_type_enabled(v88, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a3;
          v39 = "%{public}s port %u > NEXUS_PORT_MAX";
LABEL_211:
          v64 = v88;
          v65 = v89;
          v66 = 18;
          goto LABEL_122;
        }
      }
      else if ((_BYTE)v122)
      {
        v90 = (char *)__nw_create_backtrace_string();
        v88 = __nwlog_obj();
        v89 = type[0];
        v91 = os_log_type_enabled(v88, type[0]);
        if (v90)
        {
          if (v91)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_channel_create";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = a3;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v90;
            _os_log_impl(&dword_182FBE000, v88, v89, "%{public}s port %u > NEXUS_PORT_MAX, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v90);
          if (!v36)
            goto LABEL_125;
          goto LABEL_124;
        }
        if (v91)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a3;
          v39 = "%{public}s port %u > NEXUS_PORT_MAX, no backtrace";
          goto LABEL_211;
        }
      }
      else
      {
        v88 = __nwlog_obj();
        v89 = type[0];
        if (os_log_type_enabled(v88, type[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = a3;
          v39 = "%{public}s port %u > NEXUS_PORT_MAX, backtrace limit exceeded";
          goto LABEL_211;
        }
      }
    }
LABEL_123:
    if (!v36)
    {
LABEL_125:
      os_release(v10);
      goto LABEL_126;
    }
LABEL_124:
    free(v36);
    goto LABEL_125;
  }
  extended = os_channel_create_extended();
  *((_QWORD *)v10 + 17) = extended;
  if (!extended)
  {
    v42 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    v43 = v42 == 2;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v44 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v42;
      _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s os_channel_create %{darwin.errno}d", buf, 0x12u);
    }
LABEL_67:
    os_release(v10);
    if (v43)
    {
LABEL_156:
      v10 = 0;
      goto LABEL_157;
    }
LABEL_126:
    v112 = 0;
    v113 = (uint64_t)&v112;
    v114 = 0x2000000000;
    v115 = 0;
    v67 = *(_QWORD *)globals_for_channel;
    v101[0] = MEMORY[0x1E0C809B0];
    v101[1] = 0x40000000;
    v101[2] = __nw_channel_create_with_attributes_block_invoke;
    v101[3] = &unk_1E14ACA48;
    v101[4] = &v112;
    nw_dictionary_apply(v67, (uint64_t)v101);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v68 = *(const char **)(v113 + 24);
    if (!v68)
      v68 = "none";
    *(_DWORD *)block = 136446722;
    *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
    *(_WORD *)&block[12] = 2082;
    *(_QWORD *)&block[14] = out;
    *(_WORD *)&block[22] = 2082;
    v126 = v68;
    v69 = (char *)_os_log_send_and_compose_impl();
    v105[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v111[0]) = 0;
    if (!__nwlog_fault(v69, v105, v111))
      goto LABEL_150;
    if (v105[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = gLogObj;
      v71 = v105[0];
      if (os_log_type_enabled((os_log_t)gLogObj, v105[0]))
      {
        v72 = *(const char **)(v113 + 24);
        if (!v72)
          v72 = "none";
        *(_DWORD *)block = 136446722;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        *(_WORD *)&block[12] = 2082;
        *(_QWORD *)&block[14] = out;
        *(_WORD *)&block[22] = 2082;
        v126 = v72;
        v73 = "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s";
LABEL_149:
        _os_log_impl(&dword_182FBE000, v70, v71, v73, block, 0x20u);
      }
    }
    else if (LOBYTE(v111[0]))
    {
      v74 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = gLogObj;
      v71 = v105[0];
      v75 = os_log_type_enabled((os_log_t)gLogObj, v105[0]);
      if (v74)
      {
        if (v75)
        {
          v76 = *(const char **)(v113 + 24);
          if (!v76)
            v76 = "none";
          *(_DWORD *)block = 136446978;
          *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
          *(_WORD *)&block[12] = 2082;
          *(_QWORD *)&block[14] = out;
          *(_WORD *)&block[22] = 2082;
          v126 = v76;
          LOWORD(v127) = 2082;
          *(_QWORD *)((char *)&v127 + 2) = v74;
          _os_log_impl(&dword_182FBE000, v70, v71, "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s, dumping backtrace:%{public}s", block, 0x2Au);
        }
        free(v74);
        goto LABEL_150;
      }
      if (v75)
      {
        v78 = *(const char **)(v113 + 24);
        if (!v78)
          v78 = "none";
        *(_DWORD *)block = 136446722;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        *(_WORD *)&block[12] = 2082;
        *(_QWORD *)&block[14] = out;
        *(_WORD *)&block[22] = 2082;
        v126 = v78;
        v73 = "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s, no backtrace";
        goto LABEL_149;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = gLogObj;
      v71 = v105[0];
      if (os_log_type_enabled((os_log_t)gLogObj, v105[0]))
      {
        v77 = *(const char **)(v113 + 24);
        if (!v77)
          v77 = "none";
        *(_DWORD *)block = 136446722;
        *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
        *(_WORD *)&block[12] = 2082;
        *(_QWORD *)&block[14] = out;
        *(_WORD *)&block[22] = 2082;
        v126 = v77;
        v73 = "%{public}s Channel creation with attributes failed with key: %{public}s, existing channels %{public}s, bac"
              "ktrace limit exceeded";
        goto LABEL_149;
      }
    }
LABEL_150:
    if (v69)
      free(v69);
    v79 = *(void **)(v113 + 24);
    if (v79)
    {
      free(v79);
      *(_QWORD *)(v113 + 24) = 0;
    }
    v59 = &v112;
LABEL_155:
    _Block_object_dispose(v59, 8);
    goto LABEL_156;
  }
  fd = os_channel_get_fd();
  *((_DWORD *)v10 + 108) = fd;
  if (fd < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_create";
    v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v122) = 0;
    if (!__nwlog_fault(v36, type, &v122))
      goto LABEL_123;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type[0];
      if (!os_log_type_enabled(v37, type[0]))
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s failed to get fd for channel";
    }
    else if ((_BYTE)v122)
    {
      v60 = (char *)__nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type[0];
      v61 = os_log_type_enabled(v37, type[0]);
      if (v60)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v60;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s failed to get fd for channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v60);
        if (!v36)
          goto LABEL_125;
        goto LABEL_124;
      }
      if (!v61)
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s failed to get fd for channel, no backtrace";
    }
    else
    {
      v37 = __nwlog_obj();
      v38 = type[0];
      if (!os_log_type_enabled(v37, type[0]))
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_channel_create";
      v39 = "%{public}s failed to get fd for channel, backtrace limit exceeded";
    }
    goto LABEL_121;
  }
  if ((v13 & 1) != 0)
    *((_WORD *)v10 + 222) |= 0x1000u;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    if ((*((_WORD *)v10 + 222) & 0x1000) != 0)
      v21 = "enabled";
    else
      v21 = "disabled";
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_channel_create";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v21;
    _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Channel user packet pool %{public}s", buf, 0x16u);
  }
  os_channel_ring_id();
  os_channel_ring_id();
  *((_QWORD *)v10 + 27) = os_channel_tx_ring();
  *((_QWORD *)v10 + 28) = os_channel_rx_ring();
  os_channel_read_attr();
  *(_QWORD *)type = 0;
  os_channel_attr_get();
  *((_DWORD *)v10 + 109) = 0;
  if ((*((_WORD *)v10 + 222) & 0x1000) != 0)
  {
    *(_QWORD *)type = 0;
    os_channel_attr_get();
  }
  v22 = v10 + 444;
  *((_DWORD *)v10 + 110) = 0;
  v122 = 0;
  os_channel_attr_get();
  v121 = 0;
  if (!os_channel_attr_get())
  {
    v23 = (unsigned __int16)*v22;
    v24 = v23 & 0xFFFFF7FF | (v10[446] << 16);
    *v22 = ((v121 & 1) << 11) | v23 & 0xF7FF;
    v10[446] = BYTE2(v24);
  }
  v120 = 0;
  os_channel_attr_get();
  if (v99)
  {
    v25 = malloc_type_malloc(v12, 0xF2B69DE5uLL);
    if (!v25)
    {
      v92 = __nwlog_obj();
      os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "strict_malloc";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v12;
      v100 = (void *)_os_log_send_and_compose_impl();
      result = __nwlog_abort((uint64_t)v100);
      if (result)
        goto LABEL_225;
      free(v100);
    }
    *((_QWORD *)v10 + 2) = v25;
    memcpy(v25, v11, v12);
    *((_DWORD *)v10 + 106) = v12;
  }
  if (!*((_DWORD *)v10 + 109))
  {
    if ((nw_channel_check_defunct((uint64_t)v10) & 1) != 0)
    {
      v43 = 1;
      goto LABEL_67;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_channel_create";
    v93 = (char *)_os_log_send_and_compose_impl();
    v119 = OS_LOG_TYPE_ERROR;
    v118 = 0;
    if (!__nwlog_fault(v93, &v119, &v118))
      goto LABEL_222;
    if (v119 == OS_LOG_TYPE_FAULT)
    {
      v94 = __nwlog_obj();
      v95 = v119;
      if (os_log_type_enabled(v94, v119))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_create";
        v96 = "%{public}s Channel slot size is 0";
LABEL_221:
        _os_log_impl(&dword_182FBE000, v94, v95, v96, buf, 0xCu);
      }
    }
    else if (v118)
    {
      v97 = (char *)__nw_create_backtrace_string();
      v94 = __nwlog_obj();
      v95 = v119;
      v98 = os_log_type_enabled(v94, v119);
      if (v97)
      {
        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_channel_create";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v97;
          _os_log_impl(&dword_182FBE000, v94, v95, "%{public}s Channel slot size is 0, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v97);
        goto LABEL_222;
      }
      if (v98)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_create";
        v96 = "%{public}s Channel slot size is 0, no backtrace";
        goto LABEL_221;
      }
    }
    else
    {
      v94 = __nwlog_obj();
      v95 = v119;
      if (os_log_type_enabled(v94, v119))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_channel_create";
        v96 = "%{public}s Channel slot size is 0, backtrace limit exceeded";
        goto LABEL_221;
      }
    }
LABEL_222:
    if (v93)
      free(v93);
    v43 = 0;
    goto LABEL_67;
  }
  *((_QWORD *)v10 + 38) = 0;
  *((_QWORD *)v10 + 39) = v10 + 304;
  *((_QWORD *)v10 + 40) = 0;
  *((_QWORD *)v10 + 41) = v10 + 320;
  *((_QWORD *)v10 + 36) = 0;
  *((_QWORD *)v10 + 37) = v10 + 288;
  *((_QWORD *)v10 + 42) = 0;
  *((_QWORD *)v10 + 43) = v10 + 336;
  os_channel_attr_get();
  os_channel_attr_get();
  *((_QWORD *)v10 + 16) = 0;
  os_channel_attr_get();
  v26 = *((_QWORD *)v10 + 14) + *((_QWORD *)v10 + 13);
  if (*((_QWORD *)v10 + 16) < v26)
    *((_QWORD *)v10 + 16) = v26;
  nw_channel_allocate_frames(v10);
  *((_QWORD *)v10 + 29) = 0x6C656E6E616863;
  *((_QWORD *)v10 + 33) = 0x200000000;
  *((_QWORD *)v10 + 5) = v10 + 232;
  *((_QWORD *)v10 + 6) = &g_channel_protocol_callbacks;
  *((_QWORD *)v10 + 8) = v10;
  *((_QWORD *)v10 + 48) = 0;
  *((_QWORD *)v10 + 49) = v10 + 384;
  *((_QWORD *)v10 + 46) = 0;
  *((_QWORD *)v10 + 47) = v10 + 368;
  *((_QWORD *)v10 + 19) = os_retain(a1);
  v27 = dispatch_group_create();
  *((_QWORD *)v10 + 26) = v27;
  if (v27)
    goto LABEL_48;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_channel_create";
  v28 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    v27 = *((_QWORD *)v10 + 26);
LABEL_48:
    dispatch_group_enter(v27);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    *(_QWORD *)&buf[24] = 0;
    *(_QWORD *)&buf[24] = os_retain(v10);
    is_inline = nw_context_is_inline(a1);
    if (is_inline)
    {
      if (nw_context_copy_implicit_context::onceToken[0] != -1)
        dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      v31 = (id)nw_context_copy_implicit_context::implicit_context;
    }
    else
    {
      v31 = a1;
    }
    v47 = nw_context_copy_workloop(v31);
    v48 = *((_QWORD *)v10 + 17);
    v49 = *((_QWORD *)v10 + 26);
    v50 = MEMORY[0x1E0C809B0];
    *(_QWORD *)block = MEMORY[0x1E0C809B0];
    *(_QWORD *)&block[8] = 0x40000000;
    *(_QWORD *)&block[16] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke;
    v126 = (const char *)&unk_1E14ACB48;
    *(_QWORD *)&v127 = buf;
    *((_QWORD *)&v127 + 1) = v48;
    dispatch_group_notify(v49, (dispatch_queue_t)v47, block);
    if (v47)
      dispatch_release((dispatch_object_t)v47);
    dispatch_group_enter(*((dispatch_group_t *)v10 + 26));
    v51 = *((_DWORD *)v10 + 108);
    v111[4] = v10;
    v112 = v50;
    v113 = 0x40000000;
    v114 = (uint64_t)___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_35;
    v115 = &__block_descriptor_tmp_36_86506;
    v117 = is_inline;
    v116 = v10;
    v111[0] = v50;
    v111[1] = 0x40000000;
    v111[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_2;
    v111[3] = &__block_descriptor_tmp_37_86507;
    *((_QWORD *)v10 + 21) = nw_queue_context_create_source(a1, v51, 1, 0, &v112, v111);
    if (networkd_settings_get_BOOL((const char *)nw_setting_channel_enable_qos_override))
      v52 = 25;
    else
      v52 = 21;
    nw_queue_source_set_qos_class_fallback(*((_QWORD **)v10 + 21), v52);
    dispatch_group_enter(*((dispatch_group_t *)v10 + 26));
    v53 = *((_DWORD *)v10 + 108);
    v104[4] = v10;
    *(_QWORD *)v105 = v50;
    v106 = 0x40000000;
    v107 = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_3;
    v108 = &__block_descriptor_tmp_38_86508;
    v110 = is_inline;
    v109 = v10;
    v104[0] = v50;
    v104[1] = 0x40000000;
    v104[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_4;
    v104[3] = &__block_descriptor_tmp_39_86509;
    *((_QWORD *)v10 + 22) = nw_queue_context_create_source(a1, v53, 2, 0, v105, v104);
    if ((*v22 & 0x200) != 0)
    {
      dispatch_group_enter(*((dispatch_group_t *)v10 + 26));
      v55 = *((_DWORD *)v10 + 108);
      v102[4] = v10;
      v103[0] = v50;
      v103[1] = 0x40000000;
      v103[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_5;
      v103[3] = &__block_descriptor_tmp_40_86510;
      v103[4] = v10;
      v102[0] = v50;
      v102[1] = 0x40000000;
      v102[2] = ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_6;
      v102[3] = &__block_descriptor_tmp_41_86511;
      source = nw_queue_context_create_source(a1, v55, 5, 1u, v103, v102);
      *((_QWORD *)v10 + 23) = source;
      nw_queue_activate_source(source, v57);
    }
    nw_queue_activate_source(*((_QWORD *)v10 + 21), v54);
    nw_queue_activate_source(*((_QWORD *)v10 + 22), v58);
    if (*((_QWORD *)v10 + 17))
    {
      if ((((unsigned __int16)*v22 | (v10[446] << 16)) & 0x80000) == 0)
      {
        if (!os_channel_is_defunct())
        {
          _Block_object_dispose(buf, 8);
          nw_dictionary_set_value(*(_QWORD *)globals_for_channel, out, v10);
          *v22 |= 0x2000u;
          if (a1[31] != 4)
          {
            v62 = __nwlog_obj();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
            {
              v63 = *((_DWORD *)v10 + 108);
              *(_DWORD *)block = 136446722;
              *(_QWORD *)&block[4] = "nw_channel_create_with_attributes";
              *(_WORD *)&block[12] = 2082;
              *(_QWORD *)&block[14] = out;
              *(_WORD *)&block[22] = 1024;
              LODWORD(v126) = v63;
              _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_INFO, "%{public}s Channel created with key: %{public}s and fd: %d", block, 0x1Cu);
            }
          }
          goto LABEL_157;
        }
        nw_channel_handle_defunct((uint64_t)v10);
      }
    }
    else
    {
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_65);
      if (_nw_signposts_enabled && kdebug_is_enabled())
        kdebug_trace();
    }
    os_release(v10);
    v59 = (uint64_t *)buf;
    goto LABEL_155;
  }
LABEL_225:
  __break(1u);
  return result;
}

void nw_dictionary_set_value(uint64_t a1, const char *a2, void *a3)
{
  void *pointer;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_dictionary_set_value";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_dictionary_set_value";
      v10 = "%{public}s called with null dictionary";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_dictionary_set_value";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v7)
          return;
        goto LABEL_37;
      }
      if (!v12)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_dictionary_set_value";
      v10 = "%{public}s called with null dictionary, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_dictionary_set_value";
      v10 = "%{public}s called with null dictionary, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_36;
  }
  if (*(_QWORD *)(a1 + 16))
  {
    pointer = (void *)xpc_dictionary_get_pointer();
    if (a3)
    {
      os_retain(a3);
      xpc_dictionary_set_pointer();
      if (!pointer)
        return;
    }
    else
    {
      xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 16), a2, 0);
      if (!pointer)
        return;
    }
    os_release(pointer);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_dictionary_set_value";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_dictionary_set_value";
    v10 = "%{public}s called with null dictionary->xpc_object";
    goto LABEL_35;
  }
  if (!v15)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_dictionary_set_value";
    v10 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
    goto LABEL_35;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_dictionary_set_value";
    v10 = "%{public}s called with null dictionary->xpc_object, no backtrace";
    goto LABEL_35;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v18 = "nw_dictionary_set_value";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v7)
LABEL_37:
    free(v7);
}

BOOL nw_context_get_globals_for_channel(void *a1)
{
  NWConcrete_nw_context *v1;
  id v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  _BOOL8 result;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v16;
  void *v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = &__block_literal_global_29_86302;
  if (!v1)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_context_get_globals_for_channel";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_context_get_globals_for_channel";
            v23 = 2082;
            v24 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_25:
    if (v10)
      free(v10);
    v5 = 0;
    goto LABEL_6;
  }
  v3 = nw_context_copy_globals_context(v1);

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(v3 + 32) + 40));
  v4 = *(_QWORD *)(v3 + 32);
  v5 = *(_QWORD *)(v4 + 60);
  if (v5)
  {
LABEL_5:
    os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 40));

LABEL_6:
    return v5;
  }
  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_4:
    *(_QWORD *)(*(_QWORD *)(v3 + 32) + 60) = v6;
    v7 = *(_QWORD **)(*(_QWORD *)(v3 + 32) + 60);
    *v7 = nw_dictionary_create();
    v7[1] = nw_array_create();
    v7[2] = 0;
    v4 = *(_QWORD *)(v3 + 32);
    v5 = *(_QWORD *)(v4 + 60);
    goto LABEL_5;
  }
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v22 = "strict_calloc";
  v23 = 2048;
  v24 = 1;
  v25 = 2048;
  v26 = 24;
  v17 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

void sub_18312E45C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_endpoint_resolver_update_path_resolver_locked(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  unsigned int mode;
  NWConcrete_nw_endpoint_handler *v4;
  OS_nw_path *v5;
  void **v6;
  void *v7;
  _BYTE *v8;
  OS_nw_path *v9;
  OS_nw_path *v10;
  char v11;
  OS_nw_path *v12;
  char v13;
  OS_nw_path *v14;
  int v15;
  OS_nw_path *v16;
  char v17;
  OS_nw_path *v18;
  _QWORD *v19;
  uint64_t v20;
  void **v21;
  _QWORD *v22;
  NWConcrete_nw_endpoint_handler *v23;
  void *v24;
  id v25;
  void *v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  NSObject *v29;
  nw_endpoint_type_t v30;
  __int16 v31;
  void *v32;
  void *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  char *backtrace_string;
  os_log_type_t v38;
  _BOOL4 v39;
  void *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  os_log_type_t v44;
  char *v45;
  os_log_type_t v46;
  _BOOL4 v47;
  id v48;
  const char *v49;
  void *v50;
  NSObject *v51;
  os_log_type_t v52;
  const char *v53;
  char *v54;
  os_log_type_t v55;
  _BOOL4 v56;
  const char *v57;
  os_log_type_t v58;
  const char *v59;
  const char *v60;
  os_log_type_t v61;
  _QWORD v62[5];
  _QWORD v63[4];
  void **v64;
  id v65;
  NWConcrete_nw_endpoint_handler *v66;
  char v67;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v70)(uint64_t, uint64_t);
  __int128 v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
    v34 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (__nwlog_fault(v34, &type, &v67))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v67)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v38 = type;
        v39 = os_log_type_enabled(v35, type);
        if (backtrace_string)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v35, v38, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_54;
        }
        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v35, v38, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v35, v44, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_54:
    if (v34)
      free(v34);
    mode = 0;
    goto LABEL_57;
  }
  mode = v1->mode;

  if (mode == 1)
  {
    v4 = v2;
    os_unfair_lock_lock(&v4->lock);
    v5 = v4->current_path;
    os_unfair_lock_unlock(&v4->lock);

    v6 = (void **)nw_endpoint_handler_copy_resolver(v4);
    v7 = v6[1];
    if (!v7)
    {
LABEL_14:
      v19 = nw_dictionary_create();
      v20 = MEMORY[0x1E0C809B0];
      v63[0] = MEMORY[0x1E0C809B0];
      v63[1] = 3221225472;
      v63[2] = ___ZL48nw_endpoint_resolver_update_path_resolver_lockedP30NWConcrete_nw_endpoint_handler_block_invoke;
      v63[3] = &unk_1E149FA70;
      v21 = v6;
      v64 = v21;
      v22 = v19;
      v65 = v22;
      v23 = v4;
      v66 = v23;
      nw_path_enumerate_resolve_options(v5, v63);
      objc_storeStrong(v21 + 10, v19);
      v24 = v21[11];
      v25 = nw_path_copy_resolved_endpoints(v5);
      v26 = v21[11];
      v21[11] = v25;

      if (v24 || v21[11])
        goto LABEL_26;
      v27 = (unsigned __int8 *)nw_path_copy_flows(v5);
      v28 = v27;
      if (v27)
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x3032000000;
        v70 = __Block_byref_object_copy__30014;
        *(_QWORD *)&v71 = __Block_byref_object_dispose__30015;
        *((_QWORD *)&v71 + 1) = 0;
        v62[0] = v20;
        v62[1] = 3221225472;
        v62[2] = ___ZL48nw_endpoint_resolver_update_path_resolver_lockedP30NWConcrete_nw_endpoint_handler_block_invoke_97;
        v62[3] = &unk_1E14A8DC0;
        v62[4] = buf;
        nw_array_apply(v27, (uint64_t)v62);
        if (*(_QWORD *)(*(_QWORD *)&buf[8] + 40))
        {
          v29 = nw_endpoint_handler_copy_endpoint(v23);
          v30 = nw_endpoint_get_type(v29);

          nw_endpoint_handler_handle_failure(v23);
          if (v30 == (nw_endpoint_type_url|nw_endpoint_type_address))
            v31 = 7;
          else
            v31 = 2;
          if (v30 == nw_endpoint_type_bonjour_service)
            v31 = 4;
          v32 = *(void **)(*(_QWORD *)&buf[8] + 40);
          v23->event.domain = 2;
          v23->event.event = v31;
          nw_endpoint_handler_report(v23, 0, &v23->event.domain, v32);
        }
        _Block_object_dispose(buf, 8);

      }
      if (v21[11])
LABEL_26:
        nw_endpoint_resolver_update(v23, v6[1], 2u);

      goto LABEL_78;
    }
    v8 = v7;
    v9 = v5;
    v10 = v9;
    if (v9)
    {
      v11 = v8[346];
      if ((v11 & 0x40) == 0)
      {
        v12 = v9;
        v13 = *((_BYTE *)v12 + 473);

        if ((v13 & 0x40) != 0)
          *((_WORD *)v8 + 44) &= ~1u;
        v11 = v8[346];
      }
      if ((v11 & 0x80) == 0)
      {
        v14 = v10;
        v15 = *((char *)v14 + 473);

        if (v15 < 0)
          *((_WORD *)v8 + 44) &= ~2u;
      }
      v16 = v10;
      v17 = *((_BYTE *)v16 + 473) & 0x40;

      v8[346] = v8[346] & 0xBF | v17;
      v18 = v16;
      LOBYTE(v16) = *((_BYTE *)v16 + 473);

      v8[346] = v16 & 0x80 | v8[346] & 0x7F;
LABEL_13:

      goto LABEL_14;
    }
    __nwlog_obj();
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_resolver_update_path";
    v41 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (__nwlog_fault(v41, &type, &v67))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v42 = objc_claimAutoreleasedReturnValue();
        v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_resolver_update_path";
          _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v67)
      {
        v45 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v42 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        v47 = os_log_type_enabled(v42, type);
        if (v45)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_resolver_update_path";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v45;
            _os_log_impl(&dword_182FBE000, v42, v46, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v45);
          goto LABEL_98;
        }
        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_resolver_update_path";
          _os_log_impl(&dword_182FBE000, v42, v46, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v42 = objc_claimAutoreleasedReturnValue();
        v61 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_resolver_update_path";
          _os_log_impl(&dword_182FBE000, v42, v61, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_98:
    if (v41)
      free(v41);
    goto LABEL_13;
  }
LABEL_57:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v48 = (id)gLogObj;
  if (mode > 5)
    v49 = "unknown-mode";
  else
    v49 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
  *(_WORD *)&buf[12] = 2082;
  *(_QWORD *)&buf[14] = v49;
  *(_WORD *)&buf[22] = 2082;
  v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
  v50 = (void *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v67 = 0;
  if (!__nwlog_fault((const char *)v50, &type, &v67))
  {
LABEL_76:
    if (!v50)
      goto LABEL_78;
LABEL_77:
    free(v50);
    goto LABEL_78;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (id)gLogObj;
    v52 = type;
    if (os_log_type_enabled(v51, type))
    {
      if (mode > 5)
        v53 = "unknown-mode";
      else
        v53 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v53;
      *(_WORD *)&buf[22] = 2082;
      v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
      _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_75:

    goto LABEL_76;
  }
  if (!v67)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (id)gLogObj;
    v58 = type;
    if (os_log_type_enabled(v51, type))
    {
      if (mode > 5)
        v59 = "unknown-mode";
      else
        v59 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v59;
      *(_WORD *)&buf[22] = 2082;
      v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
      _os_log_impl(&dword_182FBE000, v51, v58, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_75;
  }
  v54 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v51 = (id)gLogObj;
  v55 = type;
  v56 = os_log_type_enabled(v51, type);
  if (!v54)
  {
    if (v56)
    {
      if (mode > 5)
        v60 = "unknown-mode";
      else
        v60 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v60;
      *(_WORD *)&buf[22] = 2082;
      v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
      _os_log_impl(&dword_182FBE000, v51, v55, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_75;
  }
  if (v56)
  {
    if (mode > 5)
      v57 = "unknown-mode";
    else
      v57 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_endpoint_resolver_update_path_resolver_locked";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v57;
    *(_WORD *)&buf[22] = 2082;
    v70 = (uint64_t (*)(uint64_t, uint64_t))"resolver";
    LOWORD(v71) = 2082;
    *(_QWORD *)((char *)&v71 + 2) = v54;
    _os_log_impl(&dword_182FBE000, v51, v55, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v54);
  if (v50)
    goto LABEL_77;
LABEL_78:

}

void sub_18312EF58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,void *a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;

  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

_QWORD *nw_dictionary_create()
{
  uint64_t v0;
  _QWORD *v1;
  xpc_object_t v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  objc_opt_class();
  v0 = _os_object_alloc();
  if (!v0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_dictionary_create";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &type, &v16))
      goto LABEL_26;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_dictionary_create";
      v10 = "%{public}s nw_dictionary_obj_alloc failed";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_dictionary_create";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s nw_dictionary_obj_alloc failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_26;
      }
      if (!v12)
      {
LABEL_26:
        if (v7)
          free(v7);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v19 = "nw_dictionary_create";
      v10 = "%{public}s nw_dictionary_obj_alloc failed, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_dictionary_create";
      v10 = "%{public}s nw_dictionary_obj_alloc failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_26;
  }
  v1 = (_QWORD *)v0;
  v2 = xpc_dictionary_create(0, 0, 0);
  v1[2] = v2;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_dictionary_create";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v3, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_dictionary_create";
          v6 = "%{public}s xpc_dictionary_create failed";
LABEL_32:
          _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
        }
      }
      else if (v16)
      {
        v13 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        v14 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v13)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_dictionary_create";
            v20 = 2082;
            v21 = v13;
            _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v13);
          goto LABEL_33;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_dictionary_create";
          v6 = "%{public}s xpc_dictionary_create failed, no backtrace";
          goto LABEL_32;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        v5 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_dictionary_create";
          v6 = "%{public}s xpc_dictionary_create failed, backtrace limit exceeded";
          goto LABEL_32;
        }
      }
    }
LABEL_33:
    if (v3)
      free(v3);
    os_release(v1);
    return 0;
  }
  return v1;
}

id nw_path_copy_flows(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[9];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_copy_flows";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_flows";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_copy_flows";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_flows";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_flows";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_path_enumerate_resolve_options(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  id v6;
  void *v7;
  id v8;
  int v9;
  id v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  _QWORD applier[4];
  id v26;
  int v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_path_enumerate_resolve_options";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v12, &type, &v28))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_enumerate_resolve_options";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_path_enumerate_resolve_options";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v12)
          goto LABEL_7;
LABEL_42:
        free(v12);
        goto LABEL_7;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_enumerate_resolve_options";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_path_enumerate_resolve_options";
        _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_40:

    goto LABEL_41;
  }
  if (v4)
  {
    v6 = v3[3];
    v7 = v6;
    if (v6)
    {
      v8 = v6;
      v9 = objc_msgSend(v8, "type");

      v10 = v3[28];
      if (v10)
      {
        applier[0] = MEMORY[0x1E0C809B0];
        applier[1] = 3221225472;
        applier[2] = __nw_path_enumerate_resolve_options_block_invoke;
        applier[3] = &unk_1E14A8F00;
        v27 = v9;
        v26 = v5;
        xpc_dictionary_apply(v10, applier);

      }
    }

    goto LABEL_7;
  }
  __nwlog_obj();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v31 = "nw_path_enumerate_resolve_options";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (!__nwlog_fault(v12, &type, &v28))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_path_enumerate_resolve_options";
      _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (!v28)
  {
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v24 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_path_enumerate_resolve_options";
      _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_40;
  }
  v20 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v13 = objc_claimAutoreleasedReturnValue();
  v21 = type;
  v22 = os_log_type_enabled(v13, type);
  if (!v20)
  {
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      v31 = "nw_path_enumerate_resolve_options";
      _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    v31 = "nw_path_enumerate_resolve_options";
    v32 = 2082;
    v33 = v20;
    _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v20);
  if (v12)
    goto LABEL_42;
LABEL_7:

}

void sub_18312FC6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

id nw_path_copy_resolved_endpoints(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[8];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_path_copy_resolved_endpoints";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_resolved_endpoints";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_path_copy_resolved_endpoints";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_resolved_endpoints";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_path_copy_resolved_endpoints";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_queue_source_set_qos_class_fallback(_QWORD *a1, uint64_t a2)
{
  void *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  uint64_t v10;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*a1)
      dispatch_set_qos_class_fallback();
    return;
  }
  __nwlog_obj(0, a2);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_queue_source_set_qos_class_fallback";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  v4 = __nwlog_fault(v3, &type, &v12);
  if ((_DWORD)v4)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj(v4, v5);
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_queue_source_set_qos_class_fallback";
        v8 = "%{public}s called with null source";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj(backtrace_string, v10);
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v15 = "nw_queue_source_set_qos_class_fallback";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v11)
          goto LABEL_18;
        *(_DWORD *)buf = 136446210;
        v15 = "nw_queue_source_set_qos_class_fallback";
        v8 = "%{public}s called with null source, no backtrace";
        goto LABEL_17;
      }
      __nwlog_obj(v4, v5);
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_queue_source_set_qos_class_fallback";
        v8 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:

  }
LABEL_19:
  if (v3)
    free(v3);
}

BOOL nw_dictionary_apply(uint64_t a1, uint64_t a2)
{
  void *v2;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  const char *v10;
  _BOOL4 v11;
  _BOOL4 v12;
  _QWORD applier[6];
  char v14;
  os_log_type_t v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_dictionary_apply";
    v4 = (char *)_os_log_send_and_compose_impl();
    v15 = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v4, &v15, &v14))
      goto LABEL_45;
    if (v15 == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = v15;
      if (!os_log_type_enabled(v5, v15))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_apply";
      v7 = "%{public}s called with null dictionary";
LABEL_44:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      goto LABEL_45;
    }
    if (!v14)
    {
      v5 = __nwlog_obj();
      v6 = v15;
      if (os_log_type_enabled(v5, v15))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_apply";
        v7 = "%{public}s called with null dictionary, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = v15;
    v9 = os_log_type_enabled(v5, v15);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_apply";
        v7 = "%{public}s called with null dictionary, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v9)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    v17 = "nw_dictionary_apply";
    v18 = 2082;
    v19 = backtrace_string;
    v10 = "%{public}s called with null dictionary, dumping backtrace:%{public}s";
LABEL_30:
    _os_log_impl(&dword_182FBE000, v5, v6, v10, buf, 0x16u);
    goto LABEL_31;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_dictionary_apply";
    v4 = (char *)_os_log_send_and_compose_impl();
    v15 = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v4, &v15, &v14))
      goto LABEL_45;
    if (v15 == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = v15;
      if (!os_log_type_enabled(v5, v15))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_dictionary_apply";
      v7 = "%{public}s called with null applier";
      goto LABEL_44;
    }
    if (!v14)
    {
      v5 = __nwlog_obj();
      v6 = v15;
      if (os_log_type_enabled(v5, v15))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_apply";
        v7 = "%{public}s called with null applier, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = v15;
    v11 = os_log_type_enabled(v5, v15);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_apply";
        v7 = "%{public}s called with null applier, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v11)
      goto LABEL_31;
    *(_DWORD *)buf = 136446466;
    v17 = "nw_dictionary_apply";
    v18 = 2082;
    v19 = backtrace_string;
    v10 = "%{public}s called with null applier, dumping backtrace:%{public}s";
    goto LABEL_30;
  }
  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 0x40000000;
    applier[2] = __nw_dictionary_apply_block_invoke;
    applier[3] = &unk_1E14A3570;
    applier[4] = a2;
    applier[5] = a1;
    return xpc_dictionary_apply(v2, applier);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_dictionary_apply";
  v4 = (char *)_os_log_send_and_compose_impl();
  v15 = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v4, &v15, &v14))
    goto LABEL_45;
  if (v15 != OS_LOG_TYPE_FAULT)
  {
    if (!v14)
    {
      v5 = __nwlog_obj();
      v6 = v15;
      if (os_log_type_enabled(v5, v15))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_apply";
        v7 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = v15;
    v12 = os_log_type_enabled(v5, v15);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_dictionary_apply";
        v7 = "%{public}s called with null dictionary->xpc_object, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_dictionary_apply";
      v18 = 2082;
      v19 = backtrace_string;
      v10 = "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
LABEL_31:
    free(backtrace_string);
    goto LABEL_45;
  }
  v5 = __nwlog_obj();
  v6 = v15;
  if (os_log_type_enabled(v5, v15))
  {
    *(_DWORD *)buf = 136446210;
    v17 = "nw_dictionary_apply";
    v7 = "%{public}s called with null dictionary->xpc_object";
    goto LABEL_44;
  }
LABEL_45:
  if (v4)
    free(v4);
  return 0;
}

void nw_mem_region_free(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  void *v10;
  int64x2_t v11;
  int64x2_t v12;
  int64x2_t v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  unint64_t v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  NSObject *v27;
  int v28;
  unint64_t v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  _BYTE v33[24];
  __int16 v34;
  unint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 360)
     + 16
     * (((a2 >> *(_QWORD *)(a1 + 344)) + a2 + (a2 >> (2 * *(_QWORD *)(a1 + 344)))) & *(_QWORD *)(a1 + 352));
  v7 = *(_QWORD **)v6;
  do
  {
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      v31 = "nw_mem_region_free";
      v32 = 2082;
      *(_QWORD *)v33 = "VERIFY sg != NULL failed";
      v10 = (void *)_os_log_send_and_compose_impl();
      if (!__nwlog_abort((uint64_t)v10))
      {
        free(v10);
        nw_segment_freelist_insert((_QWORD *)a1, 0, 0);
        v8 = 0;
        goto LABEL_10;
      }
LABEL_35:
      __break(1u);
      return;
    }
    v8 = (uint64_t)v7;
    v7 = (_QWORD *)*v7;
  }
  while (*(_QWORD *)(v8 + 24) != a2);
  v9 = *(_QWORD **)(v8 + 8);
  if (v7)
  {
    v7[1] = v9;
    v9 = *(_QWORD **)(v8 + 8);
  }
  else
  {
    *(_QWORD *)(v6 + 8) = v9;
  }
  *v9 = v7;
  nw_segment_freelist_insert((_QWORD *)a1, v8, 0);
LABEL_10:
  v11 = *(int64x2_t *)(a1 + 8);
  v12.i64[0] = -1;
  v12.i64[1] = -1;
  v13.i64[1] = -1;
  v13.i64[0] = *(_QWORD *)(a1 + 88);
  v13.i64[0] = vsubq_s64(v11, v13).u64[0];
  v13.i64[1] = vaddq_s64(v11, v12).i64[1];
  *(int64x2_t *)(a1 + 8) = v13;
  ++*(_QWORD *)(a1 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_region_lock);
  v14 = g_total_memory_usage - *(_QWORD *)(a1 + 88);
  g_total_memory_usage = v14;
  if (g_process_transaction)
  {
    if (v14 <= 0x8000)
    {
      os_release((void *)g_process_transaction);
      g_process_transaction = 0;
      g_transaction_touched = 0;
      if (gLogDatapath)
      {
        v26 = __nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_mem_region_free";
          _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s os transaction disabled", buf, 0xCu);
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_region_lock);
  if (gLogDatapath)
  {
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v31 = "nw_mem_region_free";
      v32 = 2048;
      *(_QWORD *)v33 = a1;
      *(_WORD *)&v33[8] = 2048;
      *(_QWORD *)&v33[10] = v8;
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s nwr %p sg %p", buf, 0x20u);
    }
  }
  v15 = *(_QWORD *)(a1 + 392);
  if (v15)
  {
    if ((*(_DWORD *)(v15 + 240) & 0x80000000) != 0)
    {
      if (gLogDatapath)
      {
        v27 = __nwlog_obj();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          v28 = *(_DWORD *)(v8 + 40);
          v29 = *(_QWORD *)(a1 + 88) + a2;
          *(_DWORD *)buf = 136447234;
          v31 = "nw_mem_region_free";
          v32 = 1024;
          *(_DWORD *)v33 = v28;
          *(_WORD *)&v33[4] = 2048;
          *(_QWORD *)&v33[6] = v8;
          *(_WORD *)&v33[14] = 2048;
          *(_QWORD *)&v33[16] = a2;
          v34 = 2048;
          v35 = v29;
          v19 = "%{public}s   [%u] sg %p [%p-%p) mirrored";
          v20 = v27;
          v21 = 48;
LABEL_34:
          _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, v19, buf, v21);
        }
      }
    }
    else if (gLogDatapath)
    {
LABEL_19:
      v16 = __nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        v17 = *(_DWORD *)(v8 + 40);
        v18 = *(_QWORD *)(a1 + 88) + a2;
        *(_DWORD *)buf = 136446978;
        v31 = "nw_mem_region_free";
        v32 = 1024;
        *(_DWORD *)v33 = v17;
        *(_WORD *)&v33[4] = 2048;
        *(_QWORD *)&v33[6] = a2;
        *(_WORD *)&v33[14] = 2048;
        *(_QWORD *)&v33[16] = v18;
        v19 = "%{public}s   [%u] [%p-%p)";
        v20 = v16;
        v21 = 38;
        goto LABEL_34;
      }
    }
  }
  else if (gLogDatapath)
  {
    goto LABEL_19;
  }
  v22 = *(_QWORD *)(a1 + 392);
  if (v22)
    nw_mem_region_free(v22, a3, 0);
  if (*(_DWORD *)(a1 + 384))
  {
    v24 = __nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v31 = "nw_mem_region_free";
    v32 = 2082;
    *(_QWORD *)v33 = "VERIFY nwr->nwr_seg_waiters == 0 failed";
    v25 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v25))
    {
      free(v25);
      return;
    }
    goto LABEL_35;
  }
}

BOOL nw_mem_region_alloc(uint64_t a1, uint64_t *a2, _QWORD *a3, _QWORD *a4, char a5)
{
  _QWORD *v5;
  uint64_t *v6;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  vm_map_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  char v21;
  unint64_t v22;
  int v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  mach_vm_address_t v32;
  mach_vm_address_t v33;
  NSObject *v34;
  void *v35;
  _BOOL8 result;
  NSObject *v37;
  void *v38;
  NSObject *v39;
  NSObject *v40;
  void *v41;
  NSObject *v42;
  uint64_t v43;
  NSObject *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  NSObject *v49;
  uint32_t v50;
  uint64_t v51;
  void *v52;
  NSObject *v53;
  NSObject *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  NSObject *v58;
  void *v59;
  char v63;
  uint64_t v64;
  uint64_t v65;
  mach_vm_address_t address;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  _BYTE v70[26];
  uint64_t v71;
  uint64_t v72;

  v5 = a4;
  v6 = a2;
  v72 = *MEMORY[0x1E0C80C00];
  v65 = 0;
  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  v8 = *(_QWORD *)(a1 + 368);
  if (v8)
  {
LABEL_6:
    nw_segment_freelist_remove((_QWORD *)a1, (uint64_t *)v8, 0);
    v9 = *(_QWORD *)(v8 + 24);
    v10 = (_QWORD *)(*(_QWORD *)(a1 + 360)
                   + 16
                   * (((v9 >> *(_QWORD *)(a1 + 344)) + v9 + (v9 >> (2 * *(_QWORD *)(a1 + 344)))) & *(_QWORD *)(a1 + 352)));
    v11 = (_QWORD *)*v10;
    *(_QWORD *)v8 = *v10;
    if (!v11)
      v11 = v10;
    v11[1] = v8;
    *v10 = v8;
    *(_QWORD *)(v8 + 8) = v10;
    v12 = *(_QWORD *)(a1 + 16) + 1;
    *(_QWORD *)(a1 + 16) = v12;
    if (v12 > *(_QWORD *)(a1 + 48))
      *(_QWORD *)(a1 + 48) = v12;
    *(_QWORD *)(a1 + 8) += *(_QWORD *)(a1 + 88);
    os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_region_lock);
    g_total_memory_usage += *(_QWORD *)(a1 + 88);
    if ((unint64_t)g_total_memory_usage >= 0x4B000)
    {
      g_transaction_touched = 1;
      if (!g_process_transaction)
      {
        g_process_transaction = os_transaction_create();
        if (gLogDatapath)
        {
          v58 = __nwlog_obj();
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            v68 = "nw_mem_region_alloc";
            _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_DEBUG, "%{public}s os transaction enabled", buf, 0xCu);
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_region_lock);
LABEL_14:
    if (gLogDatapath)
    {
      v53 = __nwlog_obj();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v68 = "nw_mem_region_alloc";
        v69 = 2048;
        *(_QWORD *)v70 = a1;
        *(_WORD *)&v70[8] = 2048;
        *(_QWORD *)&v70[10] = v8;
        _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_DEBUG, "%{public}s nwr %p sg %p", buf, 0x20u);
      }
    }
    v13 = *(_QWORD *)(a1 + 392);
    if (v13)
    {
      if ((*(_DWORD *)(v13 + 240) & 0x80000000) != 0)
      {
        if (!gLogDatapath || (v54 = __nwlog_obj(), !os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)))
        {
LABEL_64:
          v51 = *(_QWORD *)(a1 + 392);
          if (v51)
            v51 = nw_mem_region_alloc(v51, 0, &v65, 0, 3);
          if (v9)
          {
            if (a3)
              *a3 = v8;
            if (v5)
              *v5 = v65;
          }
LABEL_71:
          if (v6)
            *v6 = v51;
          return v9;
        }
        v55 = *(_DWORD *)(v8 + 40);
        v56 = *(_QWORD *)(v8 + 24);
        v57 = *(_QWORD *)(v8 + 32);
        *(_DWORD *)buf = 136447234;
        v68 = "nw_mem_region_alloc";
        v69 = 1024;
        *(_DWORD *)v70 = v55;
        *(_WORD *)&v70[4] = 2048;
        *(_QWORD *)&v70[6] = v8;
        *(_WORD *)&v70[14] = 2048;
        *(_QWORD *)&v70[16] = v56;
        *(_WORD *)&v70[24] = 2048;
        v71 = v57;
        v48 = "%{public}s   [%u] seg %p [0x%llu-0x%llu) mirrored";
        v49 = v54;
        v50 = 48;
LABEL_81:
        _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_DEBUG, v48, buf, v50);
        goto LABEL_64;
      }
      if (!gLogDatapath)
        goto LABEL_64;
    }
    else if (!gLogDatapath)
    {
      goto LABEL_64;
    }
    v44 = __nwlog_obj();
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      goto LABEL_64;
    v45 = *(_DWORD *)(v8 + 40);
    v46 = *(_QWORD *)(v8 + 24);
    v47 = *(_QWORD *)(v8 + 32);
    *(_DWORD *)buf = 136446978;
    v68 = "nw_mem_region_alloc";
    v69 = 1024;
    *(_DWORD *)v70 = v45;
    *(_WORD *)&v70[4] = 2048;
    *(_QWORD *)&v70[6] = v46;
    *(_WORD *)&v70[14] = 2048;
    *(_QWORD *)&v70[16] = v47;
    v48 = "%{public}s   [%u] [0x%llu-0x%llu)";
    v49 = v44;
    v50 = 38;
    goto LABEL_81;
  }
  v64 = a1 + 160;
  v14 = (unsigned int *)&unk_1ECD84000;
  v15 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  v63 = a5;
  while (1)
  {
    address = 0;
    if (*(_QWORD *)(a1 + 96) - *(_QWORD *)(a1 + 16) >= (unint64_t)v14[195])
      v16 = v14[195];
    else
      v16 = *(_QWORD *)(a1 + 96) - *(_QWORD *)(a1 + 16);
    if (v16)
    {
      v17 = *(_QWORD *)(a1 + 312);
      if (v17)
      {
        v18 = 0;
LABEL_26:
        v19 = 0;
        v20 = 0;
        while (1)
        {
          v21 = v17 - 1 == v19 ? (*(_DWORD *)(a1 + 96) - 1) & 0x3F : 63;
          v22 = (0xFFFFFFFFFFFFFFFFLL >> (v21 ^ 0x3Fu)) & *(_QWORD *)(*(_QWORD *)(a1 + 304) + 8 * v19);
          if (v22)
            break;
          v19 = ++v20;
          if (v17 <= v20)
            goto LABEL_42;
        }
        v23 = __clz(__rbit64(v22));
        v24 = v23 | (v20 << 6);
        if (mach_vm_allocate(*v15, &address, *(_QWORD *)(a1 + 88), 1493172227))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v25 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v26 = *(_QWORD *)(a1 + 88);
            v27 = *(_QWORD *)(a1 + 96);
            *(_DWORD *)buf = 136447234;
            v68 = "nw_segment_freelist_grow";
            v69 = 2082;
            *(_QWORD *)v70 = v64;
            *(_WORD *)&v70[8] = 1024;
            *(_DWORD *)&v70[10] = v26;
            *(_WORD *)&v70[14] = 1024;
            *(_DWORD *)&v70[16] = v27;
            *(_WORD *)&v70[20] = 1024;
            *(_DWORD *)&v70[22] = v24;
            _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s \"%{public}s\": [%u * %u] mach_vm_allocate idx %u failed", buf, 0x28u);
          }
          goto LABEL_42;
        }
        if (*(_QWORD *)(a1 + 88) != ((*(_QWORD *)(a1 + 88) + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8]))
        {
          v34 = __nwlog_obj();
          os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          v68 = "nw_segment_create";
          v69 = 2082;
          *(_QWORD *)v70 = "VERIFY segsize == round_page(segsize) failed";
          v35 = (void *)_os_log_send_and_compose_impl();
          result = __nwlog_abort((uint64_t)v35);
          if (result)
            goto LABEL_84;
          free(v35);
        }
        v28 = *(_QWORD *)(a1 + 304);
        v29 = v20 & 0x3FFFFFF;
        v30 = 1 << v23;
        if ((*(_QWORD *)(v28 + 8 * v29) & (1 << v23)) == 0)
        {
          v37 = __nwlog_obj();
          os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          v68 = "nw_segment_create";
          v69 = 2082;
          *(_QWORD *)v70 = "VERIFY bit_test(*bmap, i % BMAPSZ) failed";
          v38 = (void *)_os_log_send_and_compose_impl();
          result = __nwlog_abort((uint64_t)v38);
          if (result)
            goto LABEL_84;
          free(v38);
        }
        v31 = malloc_type_zone_calloc((malloc_zone_t *)g_slab_zone, 1uLL, 0x38uLL, 0x61BC51D5uLL);
        if (!v31)
        {
          v39 = __nwlog_obj();
          os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          v68 = "strict_malloc_zone_calloc";
          v69 = 2048;
          *(_QWORD *)v70 = 1;
          *(_WORD *)&v70[8] = 2048;
          *(_QWORD *)&v70[10] = 56;
          v59 = (void *)_os_log_send_and_compose_impl();
          result = __nwlog_abort((uint64_t)v59);
          if (result)
            goto LABEL_84;
          free(v59);
        }
        v31[2] = a1;
        *((_DWORD *)v31 + 10) = v24;
        *((_DWORD *)v31 + 12) = 1;
        *(_QWORD *)(v28 + 8 * v29) &= ~v30;
        v32 = address;
        v31[3] = address;
        v33 = *(_QWORD *)(a1 + 88) + v32;
        v31[4] = v33;
        if (!v32 || !v33)
        {
          v40 = __nwlog_obj();
          os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          v68 = "nw_segment_freelist_grow";
          v69 = 2082;
          *(_QWORD *)v70 = "VERIFY sg->sg_start != 0 && sg->sg_end != 0 failed";
          v41 = (void *)_os_log_send_and_compose_impl();
          result = __nwlog_abort((uint64_t)v41);
          if (result)
            goto LABEL_84;
          free(v41);
        }
        *((_DWORD *)v31 + 12) = 3;
        nw_segment_freelist_insert((_QWORD *)a1, (uint64_t)v31, 1);
        ++*(_QWORD *)(a1 + 32);
        if (gLogDatapath)
        {
          v42 = __nwlog_obj();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
          {
            v43 = *(_QWORD *)(a1 + 96);
            *(_DWORD *)buf = 136446722;
            v68 = "nw_segment_freelist_grow";
            v69 = 1024;
            *(_DWORD *)v70 = v24 + 1;
            *(_WORD *)&v70[4] = 2048;
            *(_QWORD *)&v70[6] = v43;
            _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_DEBUG, "%{public}s sg %u/%zu", buf, 0x1Cu);
          }
        }
LABEL_42:
        while (++v18 != v16)
        {
          v17 = *(_QWORD *)(a1 + 312);
          if (v17)
            goto LABEL_26;
        }
        v8 = *(_QWORD *)(a1 + 368);
        a5 = v63;
        v14 = (_DWORD *)&unk_1ECD84000;
        if (v8)
        {
          v5 = a4;
          v6 = a2;
          goto LABEL_6;
        }
      }
    }
    ++*(_QWORD *)(a1 + 56);
    if ((a5 & 1) != 0)
      break;
    ++*(_DWORD *)(a1 + 384);
  }
  v6 = a2;
  if ((a5 & 2) == 0)
  {
    v9 = 0;
    v51 = 0;
    goto LABEL_71;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v68 = "nw_mem_region_alloc";
  v69 = 2082;
  *(_QWORD *)v70 = v64;
  *(_WORD *)&v70[8] = 2048;
  *(_QWORD *)&v70[10] = a1;
  v52 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v52);
  if (!result)
  {
    free(v52);
    v8 = 0;
    v9 = 0;
    v5 = a4;
    goto LABEL_14;
  }
LABEL_84:
  __break(1u);
  return result;
}

void nw_segment_freelist_insert(_QWORD *a1, uint64_t a2, int a3)
{
  void (*v6)(uint64_t, _QWORD);
  _QWORD *v7;
  unint64_t v8;
  NSObject *v9;
  void *v10;
  NSObject *v11;
  void *v12;
  NSObject *v13;
  void *v14;
  int state;
  int v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 48) == 3)
  {
    if (a3)
      goto LABEL_5;
  }
  else
  {
    v9 = __nwlog_obj();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    v16 = 136446466;
    v17 = "nw_segment_freelist_insert";
    v18 = 2082;
    v19 = "VERIFY sg->sg_state == NW_SEG_STATE_MAPPED failed";
    v10 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v10))
      goto LABEL_15;
    free(v10);
    if (a3)
      goto LABEL_5;
  }
  v6 = (void (*)(uint64_t, _QWORD))a1[36];
  if (v6)
    v6(a2, a1[33]);
LABEL_5:
  state = 2;
  if (!mach_vm_purgable_control(*MEMORY[0x1E0C83DA0], *(_QWORD *)(a2 + 24), 0, &state))
    goto LABEL_6;
  v11 = __nwlog_obj();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  v16 = 136446466;
  v17 = "nw_segment_freelist_insert";
  v18 = 2082;
  v19 = "VERIFY result == 0 failed";
  v12 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v12))
  {
LABEL_15:
    __break(1u);
    return;
  }
  free(v12);
LABEL_6:
  *(_QWORD *)(a2 + 44) = 0x200000002;
  *(_QWORD *)a2 = 0;
  v7 = (_QWORD *)a1[47];
  *(_QWORD *)(a2 + 8) = v7;
  *v7 = a2;
  a1[47] = a2;
  v8 = a1[40] + 1;
  a1[40] = v8;
  if (v8 > a1[12])
  {
    v13 = __nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    v16 = 136446466;
    v17 = "nw_segment_freelist_insert";
    v18 = 2082;
    v19 = "VERIFY nwr->nwr_seg_free_cnt <= nwr->nwr_seg_max_cnt failed";
    v14 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v14))
    {
      free(v14);
      return;
    }
    goto LABEL_15;
  }
}

BOOL nw_segment_freelist_remove(_QWORD *a1, uint64_t *a2, int a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  void (*v9)(uint64_t *, _QWORD);
  _BOOL8 result;
  NSObject *v11;
  void *v12;
  NSObject *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  int state;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v6 = *a2;
  v7 = (_QWORD *)a2[1];
  if (*a2)
  {
    *(_QWORD *)(v6 + 8) = v7;
    v7 = (_QWORD *)a2[1];
  }
  else
  {
    a1[47] = v7;
  }
  *v7 = v6;
  *a2 = 0;
  a2[1] = 0;
  v8 = a1[40];
  if (!v8)
  {
    v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    v18 = 136446466;
    v19 = "nw_segment_freelist_remove";
    v20 = 2082;
    v21 = "VERIFY nwr->nwr_seg_free_cnt != 0 failed";
    v12 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v12);
    if (result)
      goto LABEL_20;
    free(v12);
    v8 = a1[40];
  }
  a1[40] = v8 - 1;
  if (a3)
  {
    *((_DWORD *)a2 + 11) = 3;
    return (BOOL)a2;
  }
  if (*((_DWORD *)a2 + 12) != 2)
  {
    v13 = __nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    v18 = 136446466;
    v19 = "nw_segment_freelist_remove";
    v20 = 2082;
    v21 = "VERIFY sg->sg_state == NW_SEG_STATE_UNMAPPED failed";
    v14 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v14);
    if (result)
      goto LABEL_20;
    free(v14);
  }
  state = 0;
  if (!mach_vm_purgable_control(*MEMORY[0x1E0C83DA0], a2[3], 0, &state))
  {
    v9 = (void (*)(uint64_t *, _QWORD))a1[35];
    if (!v9)
    {
LABEL_10:
      *(uint64_t *)((char *)a2 + 44) = 0x300000001;
      return (BOOL)a2;
    }
LABEL_9:
    v9(a2, a1[33]);
    goto LABEL_10;
  }
  v15 = __nwlog_obj();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  v18 = 136446466;
  v19 = "nw_segment_freelist_remove";
  v20 = 2082;
  v21 = "VERIFY result == 0 failed";
  v16 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v16);
  if (!result)
  {
    free(v16);
    v9 = (void (*)(uint64_t *, _QWORD))a1[35];
    if (!v9)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_20:
  __break(1u);
  return result;
}

void nw_protocol_http2_transport_process_input(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t);
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  _BYTE *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  os_log_type_t v16;
  uint64_t v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *backtrace_string;
  NSObject *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t v26;
  os_log_type_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  int v35;
  NSObject *v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  char *v41;
  _BOOL4 v42;
  NSObject *v43;
  NSObject *v44;
  _QWORD v45[5];
  char v46;
  _QWORD v47[2];
  uint64_t (*v48)(uint64_t, uint64_t);
  void *v49;
  _BYTE *v50;
  uint64_t v51;
  os_log_type_t type;
  _QWORD v53[2];
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  char *v59;
  _BYTE v60[24];
  char *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v2 = &unk_1ECD84000;
  if (gLogDatapath)
  {
    v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v60 = 136446466;
      *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(_QWORD *)&v60[14] = a1 + 205;
      _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", v60, 0x16u);
    }
  }
  v3 = MEMORY[0x1E0C809B0];
  while (1)
  {
    v53[0] = 0;
    v53[1] = v53;
    v4 = *(_QWORD *)(a1 + 32);
    if (!v4)
      break;
    v5 = *(_QWORD *)(v4 + 24);
    if (!v5)
      break;
    v6 = *(uint64_t (**)(uint64_t, uint64_t))(v5 + 80);
    if (!v6)
      break;
    v7 = v6(v4, a1);
    if (!v7)
      goto LABEL_56;
    v8 = v7;
    if (v2[1345])
    {
      v33 = __nwlog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v60 = 136446722;
        *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
        *(_WORD *)&v60[12] = 2082;
        *(_QWORD *)&v60[14] = a1 + 205;
        *(_WORD *)&v60[22] = 1024;
        LODWORD(v61) = v8;
        _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s received %u frames from output_handler", v60, 0x1Cu);
      }
    }
    *(_QWORD *)v60 = 0;
    *(_QWORD *)&v60[8] = v60;
    LODWORD(v61) = 0;
    *(_QWORD *)&v60[16] = 0x2000000000;
    v47[0] = v3;
    v47[1] = 0x40000000;
    v48 = ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke;
    v49 = &unk_1E14A0CE0;
    v50 = v60;
    v51 = a1;
    v9 = v53[0];
    do
    {
      if (!v9)
        break;
      v10 = *(_QWORD *)(v9 + 32);
      v11 = ((uint64_t (*)(_QWORD *))v48)(v47);
      v9 = v10;
    }
    while ((v11 & 1) != 0);
    if (nghttp2_session_consume_connection())
    {
      v12 = v2;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      v55 = "nw_protocol_http2_transport_process_input";
      v56 = 2082;
      v57 = v13;
      v14 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v46 = 0;
      if (!__nwlog_fault(v14, &type, &v46))
        goto LABEL_26;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        v16 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v17 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http2_transport_process_input";
          v56 = 2082;
          v57 = v17;
          v18 = v15;
          v19 = v16;
          v20 = "%{public}s nghttp2_session_consume_connection: %{public}s failed";
          goto LABEL_25;
        }
        goto LABEL_26;
      }
      if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        v24 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v24)
          {
            v25 = nghttp2_strerror();
            *(_DWORD *)buf = 136446722;
            v55 = "nw_protocol_http2_transport_process_input";
            v56 = 2082;
            v57 = v25;
            v58 = 2082;
            v59 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s nghttp2_session_consume_connection: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_26;
        }
        if (!v24)
        {
LABEL_26:
          if (v14)
            free(v14);
          v2 = v12;
          goto LABEL_29;
        }
        v29 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v55 = "nw_protocol_http2_transport_process_input";
        v56 = 2082;
        v57 = v29;
        v18 = v22;
        v19 = v23;
        v20 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = gLogObj;
        v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_26;
        v28 = nghttp2_strerror();
        *(_DWORD *)buf = 136446466;
        v55 = "nw_protocol_http2_transport_process_input";
        v56 = 2082;
        v57 = v28;
        v18 = v26;
        v19 = v27;
        v20 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, backtrace limit exceeded";
      }
LABEL_25:
      _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0x16u);
      goto LABEL_26;
    }
LABEL_29:
    if (v2[1345])
    {
      v34 = __nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        v35 = *(_DWORD *)(*(_QWORD *)&v60[8] + 24);
        *(_DWORD *)buf = 136446722;
        v55 = "nw_protocol_http2_transport_process_input";
        v56 = 2082;
        v57 = a1 + 205;
        v58 = 1024;
        LODWORD(v59) = v35;
        _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s consumed %u bytes on connection", buf, 0x1Cu);
      }
    }
    v30 = *(char **)(a1 + 112);
    v45[0] = v3;
    v45[1] = 0x40000000;
    v45[2] = ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke_23;
    v45[3] = &__block_descriptor_tmp_24_37808;
    v45[4] = a1;
    nw_hash_table_apply(v30, (uint64_t)v45);
    v31 = v53[0];
    if (v53[0])
    {
      do
      {
        v32 = *(_QWORD *)(v31 + 32);
        nw_frame_finalize(v31);
        v31 = v32;
      }
      while (v32);
    }
    if (v2[1345])
    {
      v36 = __nwlog_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_protocol_http2_transport_process_input";
        v56 = 2082;
        v57 = a1 + 205;
        v58 = 1024;
        LODWORD(v59) = v8;
        _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s processed %u frames", buf, 0x1Cu);
      }
    }
    _Block_object_dispose(v60, 8);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)v60 = 136446466;
  *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
  *(_WORD *)&v60[12] = 2082;
  *(_QWORD *)&v60[14] = a1 + 205;
  v37 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v37, buf, &type))
    goto LABEL_54;
  if (buf[0] == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = gLogObj;
    v39 = buf[0];
    if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
    {
      *(_DWORD *)v60 = 136446466;
      *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(_QWORD *)&v60[14] = a1 + 205;
      v40 = "%{public}s %{public}s output handler has no get_input_frames callback";
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    v38 = __nwlog_obj();
    v39 = buf[0];
    if (!os_log_type_enabled(v38, (os_log_type_t)buf[0]))
      goto LABEL_54;
    *(_DWORD *)v60 = 136446466;
    *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
    *(_WORD *)&v60[12] = 2082;
    *(_QWORD *)&v60[14] = a1 + 205;
    v40 = "%{public}s %{public}s output handler has no get_input_frames callback, backtrace limit exceeded";
    goto LABEL_53;
  }
  v41 = (char *)__nw_create_backtrace_string();
  v38 = __nwlog_obj();
  v39 = buf[0];
  v42 = os_log_type_enabled(v38, (os_log_type_t)buf[0]);
  if (v41)
  {
    if (v42)
    {
      *(_DWORD *)v60 = 136446722;
      *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(_QWORD *)&v60[14] = a1 + 205;
      *(_WORD *)&v60[22] = 2082;
      v61 = v41;
      _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s %{public}s output handler has no get_input_frames callback, dumping backtrace:%{public}s", v60, 0x20u);
    }
    free(v41);
    goto LABEL_54;
  }
  if (v42)
  {
    *(_DWORD *)v60 = 136446466;
    *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
    *(_WORD *)&v60[12] = 2082;
    *(_QWORD *)&v60[14] = a1 + 205;
    v40 = "%{public}s %{public}s output handler has no get_input_frames callback, no backtrace";
LABEL_53:
    _os_log_impl(&dword_182FBE000, v38, v39, v40, v60, 0x16u);
  }
LABEL_54:
  if (v37)
    free(v37);
LABEL_56:
  if (v2[1345])
  {
    v44 = __nwlog_obj();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v60 = 136446466;
      *(_QWORD *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(_QWORD *)&v60[14] = a1 + 205;
      _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s about to allow http2_transport to send pending data", v60, 0x16u);
    }
  }
  nw_http2_transport_session_send(a1);
}

uint64_t nw_socket_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, uint64_t a5, nw_frame_array_s *a6)
{
  void *handle;
  nw_protocol **p_output_handler;
  char *v9;
  nw_frame_array_s *v10;
  uint64_t v12;
  _WORD *v13;
  int v14;
  int v15;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  nw_protocol_identifier *v22;
  uint64_t *v23;
  uint64_t callbacks;
  uint64_t v25;
  nw_protocol *v26;
  int v27;
  _BOOL8 v28;
  ssize_t v29;
  nw_protocol *v30;
  unsigned int v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  unsigned int *msg_control;
  int v44;
  unsigned int *v45;
  BOOL v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  void *v50;
  uint64_t v51;
  _QWORD *v52;
  int v53;
  NSObject *singleton;
  NSObject *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  NSObject *v59;
  char *backtrace_string;
  _BOOL4 v61;
  const char *v62;
  _BOOL4 v63;
  unsigned int *v64;
  unsigned int v65;
  int v66;
  int v67;
  unsigned int *v68;
  NSObject *v69;
  char *v70;
  NSObject *v71;
  os_log_type_t msg_name;
  const char *v73;
  _BOOL4 v74;
  uint64_t v76;
  NSObject *v77;
  uint64_t v78;
  char *v79;
  _BOOL4 v80;
  NSObject *v81;
  int v82;
  char *v83;
  int v84;
  NSObject *v85;
  os_log_type_t v86;
  const char *v87;
  size_t v88;
  _BOOL8 v89;
  ssize_t v90;
  nw_protocol *v91;
  NSObject *v92;
  uint64_t v93;
  NSObject *v94;
  NSObject *v95;
  nw_protocol *output_handler;
  uint64_t v97;
  NSObject *v98;
  nw_protocol *v99;
  uint64_t v100;
  int v101;
  uint64_t output_handler_context;
  uint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  NSObject *v106;
  int output_handler_high;
  nw_protocol *v108;
  char *v109;
  NSObject *v110;
  os_log_type_t v111;
  const char *v112;
  int v113;
  nw_protocol_identifier *identifier;
  uint64_t *tqh_last;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  int v119;
  NSObject *v120;
  int v121;
  int v122;
  char *v123;
  NSObject *v124;
  os_log_type_t v125;
  int v126;
  const char *v127;
  unsigned int v128;
  char *v129;
  _BOOL4 v130;
  int v131;
  int v132;
  int v133;
  int v134;
  NSObject *v135;
  int v136;
  NSObject *v137;
  int v138;
  int v139;
  char *v140;
  NSObject *v141;
  os_log_type_t v142;
  int v143;
  const char *v144;
  char *v145;
  _BOOL4 v146;
  int v147;
  int v148;
  int v149;
  char *v150;
  _BOOL4 v151;
  char *v152;
  _BOOL4 v153;
  char *v154;
  _BOOL4 v156;
  _BOOL4 v157;
  NSObject *v158;
  const char *v159;
  char *v160;
  unsigned int v161;
  unsigned int v162;
  size_t count;
  _BOOL4 counta;
  uint64_t v165;
  nw_frame_array_s *v166;
  nw_frame_array_s *v167;
  msghdr v168;
  char v169;
  _BYTE buf[40];
  _BYTE v171[10];
  __int16 v172;
  int v173;
  __int128 type;
  uint8_t v175[64];
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  uint64_t v189;

  v189 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)v175 = 136446210;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    v154 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    LOBYTE(v168.msg_name) = 0;
    if (!__nwlog_fault(v154, buf, &v168))
      goto LABEL_140;
    if (buf[0] == 17)
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v175 = 136446210;
        *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
        v58 = "%{public}s called with null protocol";
LABEL_139:
        _os_log_impl(&dword_182FBE000, v56, v57, v58, v175, 0xCu);
      }
LABEL_140:
      if (v154)
        free(v154);
      return 0;
    }
    if (!LOBYTE(v168.msg_name))
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v175 = 136446210;
        *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
        v58 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_139;
      }
      goto LABEL_140;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = buf[0];
    v156 = os_log_type_enabled(v56, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v156)
      {
        *(_DWORD *)v175 = 136446210;
        *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
        v58 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_139;
      }
      goto LABEL_140;
    }
    if (!v156)
      goto LABEL_117;
    *(_DWORD *)v175 = 136446466;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    *(_WORD *)&v175[12] = 2082;
    *(_QWORD *)&v175[14] = backtrace_string;
    v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_116:
    _os_log_impl(&dword_182FBE000, v56, v57, v62, v175, 0x16u);
    goto LABEL_117;
  }
  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle)
    v9 = (char *)&a1[1].output_handler;
  else
    v9 = 0;
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)v175 = 136446210;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    v154 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    LOBYTE(v168.msg_name) = 0;
    if (!__nwlog_fault(v154, buf, &v168))
      goto LABEL_140;
    if (buf[0] == 17)
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v175 = 136446210;
        *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
        v58 = "%{public}s called with null socket_handler";
        goto LABEL_139;
      }
      goto LABEL_140;
    }
    if (!LOBYTE(v168.msg_name))
    {
      v56 = __nwlog_obj();
      v57 = buf[0];
      if (os_log_type_enabled(v56, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v175 = 136446210;
        *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
        v58 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_139;
      }
      goto LABEL_140;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = buf[0];
    v157 = os_log_type_enabled(v56, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v157)
      {
        *(_DWORD *)v175 = 136446210;
        *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
        v58 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_139;
      }
      goto LABEL_140;
    }
    if (v157)
    {
      *(_DWORD *)v175 = 136446466;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      *(_WORD *)&v175[12] = 2082;
      *(_QWORD *)&v175[14] = backtrace_string;
      v62 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_116;
    }
LABEL_117:
    free(backtrace_string);
    goto LABEL_140;
  }
  v10 = a6;
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  if (!a4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)v175 = 136446210;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    v154 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    LOBYTE(v168.msg_name) = 0;
    if (!__nwlog_fault(v154, buf, &v168))
      goto LABEL_140;
    if (buf[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v56 = gLogObj;
      v57 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_140;
      *(_DWORD *)v175 = 136446210;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      v58 = "%{public}s called with null maximum_bytes";
      goto LABEL_139;
    }
    if (!LOBYTE(v168.msg_name))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v56 = gLogObj;
      v57 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_140;
      *(_DWORD *)v175 = 136446210;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      v58 = "%{public}s called with null maximum_bytes, backtrace limit exceeded";
      goto LABEL_139;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v56 = gLogObj;
    v57 = buf[0];
    v61 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (!v61)
        goto LABEL_140;
      *(_DWORD *)v175 = 136446210;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      v58 = "%{public}s called with null maximum_bytes, no backtrace";
      goto LABEL_139;
    }
    if (!v61)
      goto LABEL_117;
    *(_DWORD *)v175 = 136446466;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    *(_WORD *)&v175[12] = 2082;
    *(_QWORD *)&v175[14] = backtrace_string;
    v62 = "%{public}s called with null maximum_bytes, dumping backtrace:%{public}s";
    goto LABEL_116;
  }
  v12 = a5;
  if (!(_DWORD)a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)v175 = 136446210;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    v154 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    LOBYTE(v168.msg_name) = 0;
    if (!__nwlog_fault(v154, buf, &v168))
      goto LABEL_140;
    if (buf[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v56 = gLogObj;
      v57 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_140;
      *(_DWORD *)v175 = 136446210;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      v58 = "%{public}s called with null maximum_frame_count";
      goto LABEL_139;
    }
    if (!LOBYTE(v168.msg_name))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v56 = gLogObj;
      v57 = buf[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
        goto LABEL_140;
      *(_DWORD *)v175 = 136446210;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      v58 = "%{public}s called with null maximum_frame_count, backtrace limit exceeded";
      goto LABEL_139;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v56 = gLogObj;
    v57 = buf[0];
    v63 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (!v63)
        goto LABEL_140;
      *(_DWORD *)v175 = 136446210;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      v58 = "%{public}s called with null maximum_frame_count, no backtrace";
      goto LABEL_139;
    }
    if (!v63)
      goto LABEL_117;
    *(_DWORD *)v175 = 136446466;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    *(_WORD *)&v175[12] = 2082;
    *(_QWORD *)&v175[14] = backtrace_string;
    v62 = "%{public}s called with null maximum_frame_count, dumping backtrace:%{public}s";
    goto LABEL_116;
  }
  v13 = (_WORD *)((char *)&a1[6].handle + 5);
  v14 = *(unsigned __int16 *)((char *)&a1[6].handle + 5);
  v15 = v14 | (HIBYTE(a1[6].handle) << 16);
  if ((v14 & 0x4000) != 0)
  {
    v20 = 0;
    if ((v14 & 0x80) != 0 || !gLogDatapath)
      return v20;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v59 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v175 = 136446466;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      *(_WORD *)&v175[12] = 2082;
      *(_QWORD *)&v175[14] = (char *)a1 + 436;
      _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Ignoring read because socket is cancelled", v175, 0x16u);
      return 0;
    }
    return 0;
  }
  *v13 = v14 & 0xFDFF;
  HIBYTE(a1[6].handle) = (v15 & 0xFFFFFDFF) >> 16;
  if ((v15 & 0x400) != 0)
  {
    if (_nw_signposts_once == -1)
    {
      if (_nw_signposts_enabled)
        goto LABEL_13;
    }
    else
    {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
      if (_nw_signposts_enabled)
      {
LABEL_13:
        if (kdebug_is_enabled())
          kdebug_trace();
      }
    }
    nw_queue_resume_source((uint64_t)a1[3].default_input_handler, (uint64_t)a2);
    v17 = (unsigned __int16)*v13;
    v18 = v17 & 0xFFFFFBFF | (HIBYTE(a1[6].handle) << 16);
    *v13 = v17 & 0xFBFF;
    HIBYTE(a1[6].handle) = BYTE2(v18);
  }
  v19 = (int)a1[4].handle;
  v165 = (uint64_t)v9;
  v161 = a3;
  if (v19 == 2)
  {
    v64 = (unsigned int *)MEMORY[0x1E0C85AD8];
    v65 = *MEMORY[0x1E0C85AD8];
    LODWORD(type) = v65;
    v167 = v10;
    if (v65 >= a4)
    {
      v74 = 0;
      goto LABEL_182;
    }
    *(_DWORD *)buf = 4;
    v66 = getsockopt(HIDWORD(a1[4].output_handler), 0xFFFF, 4128, &type, (socklen_t *)buf);
    counta = v66 == 0;
    if (!v66)
    {
      v65 = type;
LABEL_179:
      if (!v65)
      {
        v65 = 1024;
        LODWORD(type) = 1024;
      }
      v74 = counta;
LABEL_182:
      if (v65 >= a4)
        v88 = a4;
      else
        v88 = v65;
      v89 = nw_calloc_type<unsigned char>(v88);
      v168.msg_name = (void *)v89;
      *(_QWORD *)&v168.msg_namelen = v88;
      *(_OWORD *)buf = 0u;
      *(_QWORD *)&buf[16] = &v168;
      *(_QWORD *)&buf[24] = 1;
      *(_QWORD *)&buf[32] = 0;
      *(_QWORD *)v171 = 0x8000000000;
      v90 = recvmsg(HIDWORD(a1[4].output_handler), (msghdr *)buf, 0);
      if (v90 < 0)
      {
        v93 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if ((_DWORD)v93 == 35)
        {
          if ((*v13 & 0x80) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v94 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v175 = 136446466;
              *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
              *(_WORD *)&v175[12] = 2082;
              *(_QWORD *)&v175[14] = (char *)a1 + 436;
              _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Received EWOULDBLOCK", v175, 0x16u);
            }
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v106 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            output_handler_high = HIDWORD(a1[4].output_handler);
            *(_DWORD *)v175 = 136447234;
            *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
            *(_WORD *)&v175[12] = 2080;
            *(_QWORD *)&v175[14] = (char *)a1 + 436;
            *(_WORD *)&v175[22] = 1024;
            *(_DWORD *)&v175[24] = output_handler_high;
            *(_WORD *)&v175[28] = 1024;
            *(_DWORD *)&v175[30] = v88;
            *(_WORD *)&v175[34] = 1024;
            *(_DWORD *)&v175[36] = v93;
            _os_log_impl(&dword_182FBE000, v106, OS_LOG_TYPE_ERROR, "%{public}s %s recvmsg(fd %d, %u bytes) %{darwin.errno}d", v175, 0x28u);
          }
          nw_socket_internal_error((uint64_t)p_output_handler, v93);
          nw_socket_input_finished(a1, v108);
        }
LABEL_224:
        if (v89)
        {
          free((void *)v89);
          return 0;
        }
        return 0;
      }
      v10 = (nw_frame_array_s *)v90;
      if ((*v13 & 0x100) != 0)
      {
        v188 = 0uLL;
        nw_protocol_get_flow_id(a1, &v188);
        if ((*v13 & 0x80) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v95 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
          {
            output_handler = a1[1].output_handler;
            v97 = ((_DWORD)v10 - 1);
            if (!v10)
              v97 = 0;
            *(_DWORD *)v175 = 136447234;
            *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
            *(_WORD *)&v175[12] = 2082;
            *(_QWORD *)&v175[14] = (char *)a1 + 436;
            *(_WORD *)&v175[22] = 1024;
            *(_DWORD *)&v175[24] = (_DWORD)v10;
            *(_WORD *)&v175[28] = 2048;
            *(_QWORD *)&v175[30] = output_handler;
            *(_WORD *)&v175[38] = 2048;
            *(_QWORD *)&v175[40] = (char *)output_handler + v97;
            _os_log_impl(&dword_182FBE000, v95, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Received %u bytes (overall bytes %llu -> %llu)", v175, 0x30u);
          }
        }
        pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
        v98 = gMpklLogObj;
        if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
        {
          v99 = a1[1].output_handler;
          v100 = ((_DWORD)v10 - 1);
          if (!v10)
            v100 = 0;
          v101 = BYTE2(a1[6].default_input_handler);
          *(_DWORD *)v175 = 67110658;
          *(_DWORD *)&v175[4] = 100;
          *(_WORD *)&v175[8] = 1024;
          *(_DWORD *)&v175[10] = 150;
          *(_WORD *)&v175[14] = 1042;
          *(_DWORD *)&v175[16] = 16;
          *(_WORD *)&v175[20] = 2098;
          *(_QWORD *)&v175[22] = &v188;
          *(_WORD *)&v175[30] = 2048;
          *(_QWORD *)&v175[32] = v99;
          *(_WORD *)&v175[40] = 2048;
          *(_QWORD *)&v175[42] = (char *)v99 + v100;
          *(_WORD *)&v175[50] = 1024;
          *(_DWORD *)&v175[52] = v101;
          _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_DEFAULT, "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %llu, logSeqn: %hhu}", v175, 0x38u);
        }
        ++BYTE2(a1[6].default_input_handler);
      }
      else if ((*v13 & 0x80) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v92 = gconnectionLogObj;
        v9 = (char *)v165;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v175 = 136446722;
          *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v175[12] = 2082;
          *(_QWORD *)&v175[14] = (char *)a1 + 436;
          *(_WORD *)&v175[22] = 1024;
          *(_DWORD *)&v175[24] = (_DWORD)v10;
          _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Received %u bytes", v175, 0x1Cu);
        }
      }
      *p_output_handler = (nw_protocol *)((char *)*p_output_handler + v10);
      if (!v10)
      {
        if (v89)
          free((void *)v89);
        nw_socket_input_finished(a1, v91);
        nw_socket_cancel_input_source((uint64_t)p_output_handler, v105);
        return 0;
      }
      output_handler_context = (uint64_t)a1[5].output_handler_context;
      if (output_handler_context)
      {
        v103 = *(_QWORD *)(output_handler_context + 16);
        v104 = *(_QWORD **)(output_handler_context + 24);
        if (v103)
        {
          *(_QWORD *)(v103 + 24) = v104;
          v104 = *(_QWORD **)(output_handler_context + 24);
        }
        else
        {
          *(_QWORD *)a1[6].flow_id = v104;
        }
        *v104 = v103;
        *(_QWORD *)(output_handler_context + 16) = 0;
        *(_QWORD *)(output_handler_context + 24) = 0;
        nw_frame_reset(output_handler_context, v89, (int)v10, (uint64_t)nw_socket_frame_input_finalizer, (uint64_t)p_output_handler);
        goto LABEL_233;
      }
      output_handler_context = nw_frame_create(0, v89, (int)v10, (uint64_t)nw_socket_frame_input_finalizer, (uint64_t)p_output_handler);
      if (output_handler_context)
      {
LABEL_233:
        if (a1[2].callbacks)
        {
          v113 = v88 > v10 || (_DWORD)type == (_DWORD)v10 && v74;
          if ((*v13 & 0x80) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v158 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              v159 = "Did not drain";
              *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
              *(_DWORD *)v175 = 136446722;
              if (v113)
                v159 = "Drained";
              *(_WORD *)&v175[12] = 2082;
              *(_QWORD *)&v175[14] = (char *)a1 + 436;
              *(_WORD *)&v175[22] = 2080;
              *(_QWORD *)&v175[24] = v159;
              _os_log_impl(&dword_182FBE000, v158, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s %s all data", v175, 0x20u);
            }
          }
          nw_frame_set_metadata(output_handler_context, a1[2].callbacks, 1, v113 & ((unsigned __int16)*v13 >> 4));
          v9 = (char *)v165;
        }
        v20 = 1;
        nw_frame_set_buffer_used_malloc(output_handler_context, 1);
        *(_QWORD *)(output_handler_context + 16) = 0;
        identifier = a1[6].identifier;
        *(_QWORD *)(output_handler_context + 24) = identifier;
        *(_QWORD *)identifier->name = output_handler_context;
        a1[6].identifier = (nw_protocol_identifier *)(output_handler_context + 16);
        *(_QWORD *)(output_handler_context + 32) = 0;
        tqh_last = (uint64_t *)v167->tqh_last;
        *(_QWORD *)(output_handler_context + 40) = tqh_last;
        *tqh_last = output_handler_context;
        v167->tqh_last = (nw_frame **)(output_handler_context + 32);
        goto LABEL_243;
      }
      __nwlog_obj();
      *(_DWORD *)v175 = 136446210;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      v109 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v188) = 16;
      v169 = 0;
      if (__nwlog_fault(v109, &v188, &v169))
      {
        if (v188 == 17)
        {
          v110 = __nwlog_obj();
          v111 = v188;
          if (!os_log_type_enabled(v110, (os_log_type_t)v188))
            goto LABEL_340;
          *(_DWORD *)v175 = 136446210;
          *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
          v112 = "%{public}s nw_frame_create failed";
          goto LABEL_339;
        }
        if (!v169)
        {
          v110 = __nwlog_obj();
          v111 = v188;
          if (!os_log_type_enabled(v110, (os_log_type_t)v188))
            goto LABEL_340;
          *(_DWORD *)v175 = 136446210;
          *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
          v112 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
          goto LABEL_339;
        }
        v152 = (char *)__nw_create_backtrace_string();
        v110 = __nwlog_obj();
        v111 = v188;
        v153 = os_log_type_enabled(v110, (os_log_type_t)v188);
        if (v152)
        {
          if (v153)
          {
            *(_DWORD *)v175 = 136446466;
            *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
            *(_WORD *)&v175[12] = 2082;
            *(_QWORD *)&v175[14] = v152;
            _os_log_impl(&dword_182FBE000, v110, v111, "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", v175, 0x16u);
          }
          free(v152);
          goto LABEL_340;
        }
        if (v153)
        {
          *(_DWORD *)v175 = 136446210;
          *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
          v112 = "%{public}s nw_frame_create failed, no backtrace";
LABEL_339:
          _os_log_impl(&dword_182FBE000, v110, v111, v112, v175, 0xCu);
        }
      }
LABEL_340:
      if (v109)
        free(v109);
      goto LABEL_224;
    }
    v67 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    v68 = v64;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v69 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v175 = 136446722;
      *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
      *(_WORD *)&v175[12] = 2080;
      *(_QWORD *)&v175[14] = (char *)a1 + 436;
      *(_WORD *)&v175[22] = 1024;
      *(_DWORD *)&v175[24] = v67;
      _os_log_impl(&dword_182FBE000, v69, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_NREAD failed %{darwin.errno}d", v175, 0x1Cu);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)v175 = 136446466;
    *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
    *(_WORD *)&v175[12] = 1024;
    *(_DWORD *)&v175[14] = v67;
    v70 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v168.msg_name) = 16;
    LOBYTE(v188) = 0;
    if (__nwlog_fault(v70, &v168, &v188))
    {
      if (LOBYTE(v168.msg_name) == 17)
      {
        v71 = __nwlog_obj();
        msg_name = (os_log_type_t)v168.msg_name;
        if (os_log_type_enabled(v71, (os_log_type_t)v168.msg_name))
        {
          *(_DWORD *)v175 = 136446466;
          *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v175[12] = 1024;
          *(_DWORD *)&v175[14] = v67;
          v73 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d";
LABEL_175:
          _os_log_impl(&dword_182FBE000, v71, msg_name, v73, v175, 0x12u);
        }
      }
      else if ((_BYTE)v188)
      {
        v79 = (char *)__nw_create_backtrace_string();
        v71 = __nwlog_obj();
        msg_name = (os_log_type_t)v168.msg_name;
        v80 = os_log_type_enabled(v71, (os_log_type_t)v168.msg_name);
        if (v79)
        {
          if (v80)
          {
            *(_DWORD *)v175 = 136446722;
            *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
            *(_WORD *)&v175[12] = 1024;
            *(_DWORD *)&v175[14] = v67;
            *(_WORD *)&v175[18] = 2082;
            *(_QWORD *)&v175[20] = v79;
            _os_log_impl(&dword_182FBE000, v71, msg_name, "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, dumping backtrace:%{public}s", v175, 0x1Cu);
          }
          free(v79);
          goto LABEL_176;
        }
        if (v80)
        {
          *(_DWORD *)v175 = 136446466;
          *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v175[12] = 1024;
          *(_DWORD *)&v175[14] = v67;
          v73 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, no backtrace";
          goto LABEL_175;
        }
      }
      else
      {
        v71 = __nwlog_obj();
        msg_name = (os_log_type_t)v168.msg_name;
        if (os_log_type_enabled(v71, (os_log_type_t)v168.msg_name))
        {
          *(_DWORD *)v175 = 136446466;
          *(_QWORD *)&v175[4] = "nw_socket_get_input_frames";
          *(_WORD *)&v175[12] = 1024;
          *(_DWORD *)&v175[14] = v67;
          v73 = "%{public}s getsockopt SO_NREAD failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_175;
        }
      }
    }
LABEL_176:
    if (v70)
      free(v70);
    v65 = *v68;
    LODWORD(type) = *v68;
    v9 = (char *)v165;
    goto LABEL_179;
  }
  if (v19 != 1)
  {
    LODWORD(v10) = 0;
    v20 = 0;
    goto LABEL_243;
  }
  v166 = v10;
  v20 = 0;
  LODWORD(v10) = 0;
  if (a4 >= 0x2400)
    v21 = 9216;
  else
    v21 = a4;
  count = v21;
  v160 = v9 - 96;
  v162 = v12;
  while (1)
  {
    callbacks = (uint64_t)a1[6].callbacks;
    if (!callbacks)
      break;
    v25 = *(_QWORD *)(callbacks + 16);
    v26 = *(nw_protocol **)(callbacks + 24);
    v27 = (int)v10;
    if (v25)
    {
      *(_QWORD *)(v25 + 24) = v26;
      v26 = *(nw_protocol **)(callbacks + 24);
    }
    else
    {
      a1[6].output_handler = v26;
    }
    LODWORD(v10) = 0;
    *(_QWORD *)v26->flow_id = v25;
    *(_QWORD *)(callbacks + 16) = 0;
    *(_QWORD *)(callbacks + 24) = 0;
LABEL_87:
    if ((((unsigned __int16)*v13 | (HIBYTE(a1[6].handle) << 16)) & 0x100000) == 0)
    {
      if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1)
        dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45078);
      singleton = nw_protocol_metadata_create_singleton((void *)g_udp_definition);
      if (singleton)
      {
        v55 = singleton;
        nw_frame_set_metadata(callbacks, singleton, 1, 1);
        os_release(v55);
      }
    }
    LODWORD(v10) = v27 + (_DWORD)v10;
    *(_QWORD *)(callbacks + 16) = 0;
    v22 = a1[6].identifier;
    *(_QWORD *)(callbacks + 24) = v22;
    *(_QWORD *)v22->name = callbacks;
    a1[6].identifier = (nw_protocol_identifier *)(callbacks + 16);
    *(_QWORD *)(callbacks + 32) = 0;
    v23 = (uint64_t *)v166->tqh_last;
    *(_QWORD *)(callbacks + 40) = v23;
    *v23 = callbacks;
    v166->tqh_last = (nw_frame **)(callbacks + 32);
    v20 = (v20 + 1);
    if ((_DWORD)v20 == (_DWORD)v12)
    {
      v20 = v12;
      goto LABEL_243;
    }
  }
  v27 = (int)v10;
  v28 = nw_calloc_type<unsigned char>(count);
  *(_QWORD *)&v188 = v28;
  *((_QWORD *)&v188 + 1) = count;
  v186 = 0u;
  v187 = 0u;
  v184 = 0u;
  v185 = 0u;
  v182 = 0u;
  v183 = 0u;
  v180 = 0u;
  v181 = 0u;
  v178 = 0u;
  v179 = 0u;
  v176 = 0u;
  v177 = 0u;
  memset(v175, 0, sizeof(v175));
  *(_OWORD *)&v168.msg_name = 0u;
  *(&v168.msg_iovlen + 1) = 0;
  v168.msg_iov = (iovec *)&v188;
  v168.msg_iovlen = 1;
  v168.msg_control = v175;
  *(_QWORD *)&v168.msg_controllen = 0x8000000100;
  v29 = recvmsg(HIDWORD(a1[4].output_handler), &v168, 0);
  if (v29 < 0)
  {
    v76 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if ((_DWORD)v76 == 35)
    {
      if ((*v13 & 0x80) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v77 = gconnectionLogObj;
        v9 = (char *)v165;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = (char *)a1 + 436;
          _os_log_impl(&dword_182FBE000, v77, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Received EWOULDBLOCK", buf, 0x16u);
        }
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v81 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        v82 = HIDWORD(a1[4].output_handler);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = (char *)a1 + 436;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = v82;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = count;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v76;
        _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_ERROR, "%{public}s %s recvmsg(fd %d, %u bytes) %{darwin.errno}d", buf, 0x28u);
      }
      HIBYTE(a1[6].handle) = ((unsigned __int16)*v13 | (HIBYTE(a1[6].handle) << 16) | 0x80000u) >> 16;
      nw_socket_internal_error((uint64_t)v9, v76);
    }
    if (v28)
      free((void *)v28);
    goto LABEL_243;
  }
  v10 = (nw_frame_array_s *)v29;
  v31 = (unsigned __int16)*v13 | (HIBYTE(a1[6].handle) << 16);
  if ((v31 & 0x80000) != 0)
  {
    nw_socket_internal_error((uint64_t)v9, 0);
    v31 = (*(unsigned __int16 *)((char *)&a1[6].handle + 5) | (HIBYTE(a1[6].handle) << 16)) & 0xFFF7FFFF;
    *v13 = *v13;
    HIBYTE(a1[6].handle) = BYTE2(v31);
  }
  if ((v31 & 0x100) != 0)
  {
    type = 0uLL;
    nw_protocol_get_flow_id(v160, &type);
    if ((*v13 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v33 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        v34 = *(_QWORD *)v9;
        v35 = ((_DWORD)v10 - 1);
        if (!v10)
          v35 = 0;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)a1 + 436;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = (_DWORD)v10;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v34;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)v171 = v34 + v35;
        _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Received %u bytes (overall bytes %llu -> %llu)", buf, 0x30u);
      }
    }
    pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
    v36 = gMpklLogObj;
    if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v37 = *(_QWORD *)v9;
      v38 = ((_DWORD)v10 - 1);
      if (!v10)
        v38 = 0;
      v39 = BYTE2(a1[6].default_input_handler);
      *(_DWORD *)buf = 67110658;
      *(_DWORD *)&buf[4] = 100;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = 150;
      *(_WORD *)&buf[14] = 1042;
      *(_DWORD *)&buf[16] = 16;
      *(_WORD *)&buf[20] = 2098;
      *(_QWORD *)&buf[22] = &type;
      *(_WORD *)&buf[30] = 2048;
      *(_QWORD *)&buf[32] = v37;
      *(_WORD *)v171 = 2048;
      *(_QWORD *)&v171[2] = v37 + v38;
      v172 = 1024;
      v173 = v39;
      _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEFAULT, "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %llu, logSeqn: %hhu}", buf, 0x38u);
    }
    ++BYTE2(a1[6].default_input_handler);
  }
  else if ((v31 & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v32 = gconnectionLogObj;
    v9 = (char *)v165;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)a1 + 436;
      *(_WORD *)&buf[22] = 1024;
      *(_DWORD *)&buf[24] = (_DWORD)v10;
      _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Received %u bytes", buf, 0x1Cu);
    }
  }
  *(_QWORD *)v9 += v10;
  ++a1[1].default_input_handler;
  if (!v10)
  {
    if (v28)
      free((void *)v28);
    nw_socket_input_finished(a1, v30);
    nw_socket_cancel_input_source((uint64_t)v9, v78);
    LODWORD(v10) = v27;
    goto LABEL_243;
  }
  v40 = v28;
  v41 = 0;
  v42 = 0;
  if (v168.msg_controllen < 0xC)
  {
    v44 = 0;
    callbacks = (uint64_t)a1[5].output_handler_context;
    if (!callbacks)
      goto LABEL_72;
    goto LABEL_76;
  }
  msg_control = (unsigned int *)v168.msg_control;
  v44 = 0;
  if (!v168.msg_control)
  {
LABEL_75:
    callbacks = (uint64_t)a1[5].output_handler_context;
    if (!callbacks)
      goto LABEL_72;
LABEL_76:
    v51 = *(_QWORD *)(callbacks + 16);
    v52 = *(_QWORD **)(callbacks + 24);
    if (v51)
    {
      *(_QWORD *)(v51 + 24) = v52;
      v52 = *(_QWORD **)(callbacks + 24);
    }
    else
    {
      *(_QWORD *)a1[6].flow_id = v52;
    }
    *v52 = v51;
    *(_QWORD *)(callbacks + 16) = 0;
    *(_QWORD *)(callbacks + 24) = 0;
    nw_frame_reset(callbacks, v40, (int)v10, (uint64_t)nw_socket_frame_input_finalizer, v165);
    goto LABEL_80;
  }
  v42 = 0;
  while (1)
  {
    v47 = msg_control[1];
    if (v47 != 0xFFFF)
      break;
    if (msg_control[2] == 7)
      v42 = *(_QWORD *)(msg_control + 3);
LABEL_54:
    v45 = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
    if ((char *)(v45 + 3) <= (char *)v168.msg_control + v168.msg_controllen)
    {
      v46 = v45 == msg_control;
    }
    else
    {
      v45 = 0;
      v46 = 1;
    }
    msg_control = v45;
    if (v46)
    {
      v41 = 0;
      v44 = 0;
      callbacks = (uint64_t)a1[5].output_handler_context;
      if (callbacks)
        goto LABEL_76;
      goto LABEL_72;
    }
  }
  if (v47 != 41)
  {
    if (!v47)
    {
      v48 = msg_control[2];
      if (v48 == 24)
        goto LABEL_92;
      if (v48 == 27)
      {
LABEL_74:
        v44 = 0;
        v41 = msg_control[3];
        goto LABEL_75;
      }
    }
    goto LABEL_54;
  }
  v49 = msg_control[2];
  if (v49 != 47)
  {
    if (v49 == 36)
      goto LABEL_74;
    goto LABEL_54;
  }
LABEL_92:
  v41 = 0;
  v44 = *((unsigned __int8 *)msg_control + 12);
  callbacks = (uint64_t)a1[5].output_handler_context;
  if (callbacks)
    goto LABEL_76;
LABEL_72:
  v50 = (void *)v40;
  callbacks = nw_frame_create(0, v40, (int)v10, (uint64_t)nw_socket_frame_input_finalizer, v165);
  if (callbacks)
  {
LABEL_80:
    nw_frame_set_buffer_used_malloc(callbacks, 1);
    if (v41)
      *(_BYTE *)(callbacks + 186) = *(_BYTE *)(callbacks + 186) & 0xFC | v41 & 3;
    v12 = v162;
    if (v42)
    {
      v53 = *(_WORD *)(callbacks + 204) & 0xFFEF | (*(unsigned __int8 *)(callbacks + 206) << 16);
      *(_WORD *)(callbacks + 204) &= ~0x10u;
      *(_BYTE *)(callbacks + 206) = BYTE2(v53);
      *(_QWORD *)(callbacks + 152) = v42;
    }
    if (v44)
      *(_BYTE *)(callbacks + 185) = v44;
    v9 = (char *)v165;
    goto LABEL_87;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
  v83 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(type) = 16;
  v169 = 0;
  v84 = __nwlog_fault(v83, &type, &v169);
  v9 = (char *)v165;
  LODWORD(v10) = v27;
  if (!v84)
    goto LABEL_325;
  if (type != 17)
  {
    if (v169)
    {
      v150 = (char *)__nw_create_backtrace_string();
      v85 = __nwlog_obj();
      v86 = type;
      v151 = os_log_type_enabled(v85, (os_log_type_t)type);
      if (v150)
      {
        if (v151)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v150;
          _os_log_impl(&dword_182FBE000, v85, v86, "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v150);
        goto LABEL_325;
      }
      if (!v151)
        goto LABEL_325;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
      v87 = "%{public}s nw_frame_create failed, no backtrace";
    }
    else
    {
      v85 = __nwlog_obj();
      v86 = type;
      if (!os_log_type_enabled(v85, (os_log_type_t)type))
        goto LABEL_325;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
      v87 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
    }
LABEL_324:
    _os_log_impl(&dword_182FBE000, v85, v86, v87, buf, 0xCu);
    goto LABEL_325;
  }
  v85 = __nwlog_obj();
  v86 = type;
  if (os_log_type_enabled(v85, (os_log_type_t)type))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socket_get_input_frames";
    v87 = "%{public}s nw_frame_create failed";
    goto LABEL_324;
  }
LABEL_325:
  if (v83)
    free(v83);
  if (v50)
    free(v50);
LABEL_243:
  v116 = v161 - (_DWORD)v10;
  if (v161 < v10)
    v116 = 0;
  if (v116 <= 1)
    v117 = 1;
  else
    v117 = v116;
  *(_DWORD *)buf = v117;
  v118 = *((_DWORD *)v9 + 44);
  if (v118 != v117)
  {
    if (v117 > v118)
    {
      LODWORD(v168.msg_name) = 0;
      LODWORD(v188) = 4;
      if (getsockopt(*((_DWORD *)v9 + 49), 0xFFFF, 4098, &v168, (socklen_t *)&v188))
      {
        v119 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v120 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          v121 = *((_DWORD *)v9 + 49);
          *(_DWORD *)v175 = 136446978;
          *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
          *(_WORD *)&v175[12] = 2080;
          *(_QWORD *)&v175[14] = v9 + 340;
          *(_WORD *)&v175[22] = 1024;
          *(_DWORD *)&v175[24] = v121;
          *(_WORD *)&v175[28] = 1024;
          *(_DWORD *)&v175[30] = v119;
          _os_log_impl(&dword_182FBE000, v120, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d", v175, 0x22u);
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v122 = *((_DWORD *)v9 + 49);
        *(_DWORD *)v175 = 136446722;
        *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
        *(_WORD *)&v175[12] = 1024;
        *(_DWORD *)&v175[14] = v122;
        *(_WORD *)&v175[18] = 1024;
        *(_DWORD *)&v175[20] = v119;
        v123 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(type) = 16;
        v169 = 0;
        if (__nwlog_fault(v123, &type, &v169))
        {
          if (type != 17)
          {
            if (v169)
            {
              v129 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v124 = gLogObj;
              v125 = type;
              v130 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type);
              if (v129)
              {
                if (v130)
                {
                  v131 = *(_DWORD *)(v165 + 196);
                  *(_DWORD *)v175 = 136446978;
                  *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
                  *(_WORD *)&v175[12] = 1024;
                  *(_DWORD *)&v175[14] = v131;
                  *(_WORD *)&v175[18] = 1024;
                  *(_DWORD *)&v175[20] = v119;
                  *(_WORD *)&v175[24] = 2082;
                  *(_QWORD *)&v175[26] = v129;
                  _os_log_impl(&dword_182FBE000, v124, v125, "%{public}s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d, dumping backtrace:%{public}s", v175, 0x22u);
                }
                free(v129);
                goto LABEL_275;
              }
              if (!v130)
                goto LABEL_275;
              v133 = *(_DWORD *)(v165 + 196);
              *(_DWORD *)v175 = 136446722;
              *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
              *(_WORD *)&v175[12] = 1024;
              *(_DWORD *)&v175[14] = v133;
              *(_WORD *)&v175[18] = 1024;
              *(_DWORD *)&v175[20] = v119;
              v127 = "%{public}s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v124 = gLogObj;
              v125 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type))
                goto LABEL_275;
              v132 = *(_DWORD *)(v165 + 196);
              *(_DWORD *)v175 = 136446722;
              *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
              *(_WORD *)&v175[12] = 1024;
              *(_DWORD *)&v175[14] = v132;
              *(_WORD *)&v175[18] = 1024;
              *(_DWORD *)&v175[20] = v119;
              v127 = "%{public}s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d, backtrace limit exceeded";
            }
LABEL_274:
            _os_log_impl(&dword_182FBE000, v124, v125, v127, v175, 0x18u);
            goto LABEL_275;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v124 = gLogObj;
          v125 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type))
          {
            v126 = *(_DWORD *)(v165 + 196);
            *(_DWORD *)v175 = 136446722;
            *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
            *(_WORD *)&v175[12] = 1024;
            *(_DWORD *)&v175[14] = v126;
            *(_WORD *)&v175[18] = 1024;
            *(_DWORD *)&v175[20] = v119;
            v127 = "%{public}s getsockopt SO_RCVBUF fd %d failed %{darwin.errno}d";
            goto LABEL_274;
          }
        }
LABEL_275:
        if (v123)
          free(v123);
        v9 = (char *)v165;
      }
      else if (LODWORD(v168.msg_name) && v117 > LODWORD(v168.msg_name) / 3)
      {
        if (LODWORD(v168.msg_name) < 3)
          v128 = 1;
        else
          v128 = LODWORD(v168.msg_name) / 3;
        *(_DWORD *)buf = v128;
      }
    }
    if (!setsockopt(*((_DWORD *)v9 + 49), 0xFFFF, 4100, buf, 4u))
    {
      *((_DWORD *)v9 + 44) = *(_DWORD *)buf;
      goto LABEL_303;
    }
    v134 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v135 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      v136 = *((_DWORD *)v9 + 49);
      *(_DWORD *)v175 = 136447234;
      *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
      *(_WORD *)&v175[12] = 2080;
      *(_QWORD *)&v175[14] = v9 + 340;
      *(_WORD *)&v175[22] = 1024;
      *(_DWORD *)&v175[24] = *(_DWORD *)buf;
      *(_WORD *)&v175[28] = 1024;
      *(_DWORD *)&v175[30] = v136;
      *(_WORD *)&v175[34] = 1024;
      *(_DWORD *)&v175[36] = v134;
      _os_log_impl(&dword_182FBE000, v135, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_RCVLOWAT %u fd %d failed %{darwin.errno}d", v175, 0x28u);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v137 = gLogObj;
    if (v134 == 22)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v138 = *(_DWORD *)(v165 + 196);
        *(_DWORD *)v175 = 136446978;
        *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
        *(_WORD *)&v175[12] = 1024;
        *(_DWORD *)&v175[14] = *(_DWORD *)buf;
        *(_WORD *)&v175[18] = 1024;
        *(_DWORD *)&v175[20] = v138;
        *(_WORD *)&v175[24] = 1024;
        *(_DWORD *)&v175[26] = 22;
        _os_log_impl(&dword_182FBE000, v137, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_RCVLOWAT %u fd %d failed %{darwin.errno}d", v175, 0x1Eu);
      }
      goto LABEL_303;
    }
    v139 = *(_DWORD *)(v165 + 196);
    *(_DWORD *)v175 = 136446978;
    *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
    *(_WORD *)&v175[12] = 1024;
    *(_DWORD *)&v175[14] = *(_DWORD *)buf;
    *(_WORD *)&v175[18] = 1024;
    *(_DWORD *)&v175[20] = v139;
    *(_WORD *)&v175[24] = 1024;
    *(_DWORD *)&v175[26] = v134;
    v140 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v168.msg_name) = 16;
    LOBYTE(v188) = 0;
    if (__nwlog_fault(v140, &v168, &v188))
    {
      if (LOBYTE(v168.msg_name) != 17)
      {
        if ((_BYTE)v188)
        {
          v145 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v141 = gLogObj;
          v142 = (os_log_type_t)v168.msg_name;
          v146 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v168.msg_name);
          if (v145)
          {
            if (v146)
            {
              v147 = *(_DWORD *)(v165 + 196);
              *(_DWORD *)v175 = 136447234;
              *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
              *(_WORD *)&v175[12] = 1024;
              *(_DWORD *)&v175[14] = *(_DWORD *)buf;
              *(_WORD *)&v175[18] = 1024;
              *(_DWORD *)&v175[20] = v147;
              *(_WORD *)&v175[24] = 1024;
              *(_DWORD *)&v175[26] = v134;
              *(_WORD *)&v175[30] = 2082;
              *(_QWORD *)&v175[32] = v145;
              _os_log_impl(&dword_182FBE000, v141, v142, "%{public}s setsockopt SO_RCVLOWAT %u fd %d failed %{darwin.errno}d, dumping backtrace:%{public}s", v175, 0x28u);
            }
            free(v145);
            goto LABEL_301;
          }
          if (!v146)
            goto LABEL_301;
          v149 = *(_DWORD *)(v165 + 196);
          *(_DWORD *)v175 = 136446978;
          *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
          *(_WORD *)&v175[12] = 1024;
          *(_DWORD *)&v175[14] = *(_DWORD *)buf;
          *(_WORD *)&v175[18] = 1024;
          *(_DWORD *)&v175[20] = v149;
          *(_WORD *)&v175[24] = 1024;
          *(_DWORD *)&v175[26] = v134;
          v144 = "%{public}s setsockopt SO_RCVLOWAT %u fd %d failed %{darwin.errno}d, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v141 = gLogObj;
          v142 = (os_log_type_t)v168.msg_name;
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v168.msg_name))
            goto LABEL_301;
          v148 = *(_DWORD *)(v165 + 196);
          *(_DWORD *)v175 = 136446978;
          *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
          *(_WORD *)&v175[12] = 1024;
          *(_DWORD *)&v175[14] = *(_DWORD *)buf;
          *(_WORD *)&v175[18] = 1024;
          *(_DWORD *)&v175[20] = v148;
          *(_WORD *)&v175[24] = 1024;
          *(_DWORD *)&v175[26] = v134;
          v144 = "%{public}s setsockopt SO_RCVLOWAT %u fd %d failed %{darwin.errno}d, backtrace limit exceeded";
        }
LABEL_300:
        _os_log_impl(&dword_182FBE000, v141, v142, v144, v175, 0x1Eu);
        goto LABEL_301;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v141 = gLogObj;
      v142 = (os_log_type_t)v168.msg_name;
      if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v168.msg_name))
      {
        v143 = *(_DWORD *)(v165 + 196);
        *(_DWORD *)v175 = 136446978;
        *(_QWORD *)&v175[4] = "nw_socket_set_receive_low_water_mark";
        *(_WORD *)&v175[12] = 1024;
        *(_DWORD *)&v175[14] = *(_DWORD *)buf;
        *(_WORD *)&v175[18] = 1024;
        *(_DWORD *)&v175[20] = v143;
        *(_WORD *)&v175[24] = 1024;
        *(_DWORD *)&v175[26] = v134;
        v144 = "%{public}s setsockopt SO_RCVLOWAT %u fd %d failed %{darwin.errno}d";
        goto LABEL_300;
      }
    }
LABEL_301:
    if (v140)
      free(v140);
  }
LABEL_303:
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  return v20;
}

void nw_frame_set_buffer_used_malloc(uint64_t a1, __int16 a2)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_WORD *)(a1 + 204) = *(_WORD *)(a1 + 204) & 0xFFFE | a2;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "__nw_frame_set_buffer_used_malloc";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v11 = "__nw_frame_set_buffer_used_malloc";
      v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }
    if (!v8)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (!os_log_type_enabled(v3, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v11 = "__nw_frame_set_buffer_used_malloc";
      v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v3 = __nwlog_obj();
    v4 = type;
    v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        v11 = "__nw_frame_set_buffer_used_malloc";
        v12 = 2082;
        v13 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      v11 = "__nw_frame_set_buffer_used_malloc";
      v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_18:
  if (v2)
    free(v2);
}

uint64_t ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  NSObject *v27;
  _BOOL4 v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  unsigned int v33;
  unsigned int v34;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v3 = nw_frame_unclaimed_bytes(a2, &v34);
  v4 = v34;
  if (v3)
    v5 = v34 == 0;
  else
    v5 = 1;
  v6 = !v5;
  if (v5)
    return v6;
  v7 = v3;
  v33 = v6;
  if (!gLogDatapath)
    goto LABEL_9;
  v27 = __nwlog_obj();
  v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
  v4 = v34;
  if (v28)
  {
    v29 = *(_QWORD *)(a1 + 40);
    v30 = (const char *)(v29 + 205);
    v5 = v29 == 0;
    v31 = "";
    if (!v5)
      v31 = v30;
    *(_DWORD *)buf = 136446722;
    v36 = "nw_protocol_http2_transport_process_input_block_invoke";
    v37 = 2082;
    v38 = v31;
    v39 = 1024;
    v40 = v34;
    _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s processing frame of length %u bytes", buf, 0x1Cu);
    v4 = v34;
  }
  if (v4)
  {
LABEL_9:
    v8 = 0;
    while (1)
    {
      v9 = MEMORY[0x186DB4424](*(_QWORD *)(*(_QWORD *)(a1 + 40) + 80), v7 + v8, v4 - v8);
      if ((v9 & 0x8000000000000000) == 0)
        goto LABEL_28;
      v10 = *(_BYTE *)(*(_QWORD *)(a1 + 40) + 204) & 8;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      if (v9 == -902 && v10 != 0)
        break;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v13 = *(_QWORD *)(a1 + 40);
        if (v13)
          v14 = (const char *)(v13 + 205);
        else
          v14 = "";
        v15 = nghttp2_strerror();
        *(_DWORD *)buf = 136446978;
        v36 = "nw_protocol_http2_transport_process_input_block_invoke";
        v37 = 2082;
        v38 = v14;
        v39 = 1024;
        v40 = v9;
        v41 = 2082;
        v42 = v15;
        v16 = v11;
        v17 = OS_LOG_TYPE_ERROR;
        v18 = "%{public}s %{public}s ERROR: Could not process incoming data: %d (%{public}s)";
LABEL_26:
        _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0x26u);
      }
LABEL_27:
      nw_http2_transport_connection_close(*(_QWORD *)(a1 + 40));
LABEL_28:
      v8 += v9;
      if (gLogDatapath)
      {
        v23 = __nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          v24 = *(_QWORD *)(a1 + 40);
          v25 = (const char *)(v24 + 205);
          v5 = v24 == 0;
          v26 = "";
          if (!v5)
            v26 = v25;
          *(_DWORD *)buf = 136446722;
          v36 = "nw_protocol_http2_transport_process_input_block_invoke";
          v37 = 2082;
          v38 = v26;
          v39 = 1024;
          v40 = v8;
          _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s nghttp2_session_mem_recv consumed %u bytes", buf, 0x1Cu);
        }
      }
      v4 = v34;
      if (v8 >= v34)
        goto LABEL_41;
    }
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      goto LABEL_27;
    v20 = *(_QWORD *)(a1 + 40);
    if (v20)
      v21 = (const char *)(v20 + 205);
    else
      v21 = "";
    v22 = nghttp2_strerror();
    *(_DWORD *)buf = 136446978;
    v36 = "nw_protocol_http2_transport_process_input_block_invoke";
    v37 = 2082;
    v38 = v21;
    v39 = 1024;
    v40 = -902;
    v41 = 2082;
    v42 = v22;
    v16 = v11;
    v17 = OS_LOG_TYPE_DEFAULT;
    v18 = "%{public}s %{public}s Could not process incoming data: %d (%{public}s), closing";
    goto LABEL_26;
  }
  v8 = 0;
LABEL_41:
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v8;
  return v33;
}

void nw_socket_frame_input_finalizer(nw_frame *a1, BOOL a2, _QWORD *a3)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;

  nw_frame_free_buffer((uint64_t)a1);
  nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
  v6 = *((_QWORD *)a1 + 2);
  v7 = (_QWORD *)*((_QWORD *)a1 + 3);
  v5 = (_QWORD *)((char *)a1 + 16);
  if (v6)
  {
    *(_QWORD *)(v6 + 24) = v7;
    v7 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    a3[38] = v7;
  }
  *v7 = v6;
  *v5 = 0;
  *((_QWORD *)a1 + 3) = 0;
  v8 = (_QWORD *)a3[36];
  *((_QWORD *)a1 + 3) = v8;
  *v8 = a1;
  a3[36] = v5;
}

void nw_frame_free_buffer(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  void *v4;

  if ((*(_WORD *)(a1 + 204) & 2) == 0)
  {
    v2 = *(void **)(a1 + 112);
    if (!v2)
    {
LABEL_4:
      *(_WORD *)(a1 + 196) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      return;
    }
LABEL_3:
    free(v2);
    *(_QWORD *)(a1 + 112) = 0;
    goto LABEL_4;
  }
  v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  v4 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v4))
  {
    free(v4);
    v2 = *(void **)(a1 + 112);
    if (!v2)
      goto LABEL_4;
    goto LABEL_3;
  }
  __break(1u);
}

void nw_quic_connection_set_keepalive(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  __int16 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_keepalive_block_invoke;
    v12[3] = &__block_descriptor_34_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_keepalive";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_keepalive";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_183135574(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_keepalive_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 160);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(unsigned __int16 *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

id nw_connection_copy_tcp_info(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v19)(uint64_t, uint64_t);
  void (*v20)(uint64_t);
  id v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v19 = __Block_byref_object_copy__78229;
    v20 = __Block_byref_object_dispose__78230;
    v21 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_tcp_info_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_tcp_info_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(id *)(*(_QWORD *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_copy_tcp_info";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_tcp_info";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_copy_tcp_info";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_tcp_info";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_copy_tcp_info";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_tcp_info_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  id *v3;
  id v4;
  int is_multipath;
  id v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  NSObject *v10;
  unsigned int v11;
  uint64_t v12;
  void *v13;
  char *v14;
  xpc_object_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  const char *v19;
  id v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *backtrace_string;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t v30[4];
  const char *v31;
  __int16 v32;
  char *v33;
  tcp_info buf;

  buf.var97 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD **)(a1 + 32);
  if (v2[18])
  {
    v3 = v2;
    v4 = v3[2];

    if (nw_parameters_get_multipath(v4))
    {
      is_multipath = nw_endpoint_handler_is_multipath(*(void **)(*(_QWORD *)(a1 + 32) + 144));

      if (is_multipath)
      {
        v6 = nw_endpoint_handler_copy_multipath_tcp_info(*(void **)(*(_QWORD *)(a1 + 32) + 144));
        v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v8 = *(void **)(v7 + 40);
        *(_QWORD *)(v7 + 40) = v6;

        return;
      }
    }
    else
    {

    }
    memset(&buf, 0, 408);
    if (nw_connection_get_tcp_info_for_connected_endpoint_locked(*(NWConcrete_nw_connection **)(a1 + 32), &buf))
    {
      v12 = nw_endpoint_handler_copy_connected_path(*(void **)(*(_QWORD *)(a1 + 32) + 144));
      v13 = (void *)v12;
      if (v12)
        v14 = (char *)*(id *)(v12 + 96);
      else
        v14 = 0;
      v15 = xpc_dictionary_create(0, 0, 0);
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v17 = *(void **)(v16 + 40);
      *(_QWORD *)(v16 + 40) = v15;

      v18 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
      if (v18)
      {
        if (v14)
          v19 = v14 + 104;
        else
          v19 = "unknown";
        xpc_dictionary_set_data(v18, v19, &buf, 0x198uLL);
        goto LABEL_29;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = (id)gLogObj;
      *(_DWORD *)v30 = 136446210;
      v31 = "nw_connection_copy_tcp_info_block_invoke";
      v21 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v28 = 0;
      if (__nwlog_fault(v21, &type, &v28))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)v30 = 136446210;
            v31 = "nw_connection_copy_tcp_info_block_invoke";
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s xpc_dictionary_create failed", v30, 0xCu);
          }
        }
        else if (v28)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          v25 = type;
          v26 = os_log_type_enabled(v22, type);
          if (backtrace_string)
          {
            if (v26)
            {
              *(_DWORD *)v30 = 136446466;
              v31 = "nw_connection_copy_tcp_info_block_invoke";
              v32 = 2082;
              v33 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", v30, 0x16u);
            }

            free(backtrace_string);
            if (!v21)
              goto LABEL_29;
            goto LABEL_28;
          }
          if (v26)
          {
            *(_DWORD *)v30 = 136446210;
            v31 = "nw_connection_copy_tcp_info_block_invoke";
            _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s xpc_dictionary_create failed, no backtrace", v30, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v22 = objc_claimAutoreleasedReturnValue();
          v27 = type;
          if (os_log_type_enabled(v22, type))
          {
            *(_DWORD *)v30 = 136446210;
            v31 = "nw_connection_copy_tcp_info_block_invoke";
            _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", v30, 0xCu);
          }
        }

      }
      if (!v21)
      {
LABEL_29:

        return;
      }
LABEL_28:
      free(v21);
      goto LABEL_29;
    }
  }
  else
  {
    v9 = v2[2];
    if (v9 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v9 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        v11 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        *(_DWORD *)&buf.var0 = 136446466;
        *(_QWORD *)&buf.var4 = "nw_connection_copy_tcp_info_block_invoke";
        LOWORD(buf.var6) = 1024;
        *(unsigned int *)((char *)&buf.var6 + 2) = v11;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%u] No parent endpoint handler", &buf.var0, 0x12u);
      }

    }
  }
}

void sub_183135DD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183135DE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_connection_used_tfo(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v19 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_used_tfo_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_used_tfo_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_used_tfo";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_used_tfo";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_used_tfo";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_used_tfo";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_used_tfo";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_used_tfo_block_invoke(uint64_t a1)
{
  _BYTE *v1;
  id *v3;
  id v4;
  int is_multipath;
  uint64_t v6;
  void *v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  NSObject *v13;
  unsigned int v14;
  id xdict;
  _QWORD applier[5];
  tcp_info buf;

  buf.var97 = *MEMORY[0x1E0C80C00];
  v1 = *(_BYTE **)(a1 + 32);
  if ((v1[109] & 0x40) == 0)
    return;
  v3 = v1;
  v4 = v3[2];

  if (!nw_parameters_get_multipath(v4))
  {

LABEL_8:
    v6 = nw_endpoint_handler_copy_connected_path(*(void **)(*(_QWORD *)(a1 + 32) + 144));
    v7 = (void *)v6;
    if (v6)
    {
      v8 = *(id *)(v6 + 96);
      if (v8)
      {
        v9 = v8;
        memset(&buf, 0, 408);
        if (nw_connection_get_tcp_info_for_connected_endpoint_locked(*(NWConcrete_nw_connection **)(a1 + 32), &buf))
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = (buf.var43 & 0x1000000000) != 0;
      }
      else
      {
        v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
        if (v12 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v12 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v13 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          {
            v14 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
            *(_DWORD *)&buf.var0 = 136446466;
            *(_QWORD *)&buf.var4 = "nw_connection_used_tfo_block_invoke";
            LOWORD(buf.var6) = 1024;
            *(unsigned int *)((char *)&buf.var6 + 2) = v14;
            _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s [C%u] No connected interface", &buf.var0, 0x12u);
          }

        }
        v9 = 0;
      }
    }
    else
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
      if (!v10 || nw_path_parameters_get_logging_disabled(*(_QWORD *)(v10 + 104)))
        goto LABEL_27;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v9 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        v11 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        *(_DWORD *)&buf.var0 = 136446466;
        *(_QWORD *)&buf.var4 = "nw_connection_used_tfo_block_invoke";
        LOWORD(buf.var6) = 1024;
        *(unsigned int *)((char *)&buf.var6 + 2) = v11;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s [C%u] No connected path", &buf.var0, 0x12u);
      }
    }

LABEL_27:
    return;
  }
  is_multipath = nw_endpoint_handler_is_multipath(*(void **)(*(_QWORD *)(a1 + 32) + 144));

  if (!is_multipath)
    goto LABEL_8;
  xdict = nw_endpoint_handler_copy_multipath_tcp_info(*(void **)(*(_QWORD *)(a1 + 32) + 144));
  if (xdict)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = __nw_connection_used_tfo_block_invoke_2;
    applier[3] = &unk_1E14AAE28;
    applier[4] = *(_QWORD *)(a1 + 40);
    xpc_dictionary_apply(xdict, applier);
  }

}

void sub_183136440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{

  _Unwind_Resume(a1);
}

void sub_183136454(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_fillout_tcp_info(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  void *v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  const void *v8;
  BOOL v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t (*v12)(void);
  void *v13;
  char v14;
  uint64_t v15;
  void *v16;
  NSObject *v17;
  _BOOL8 v18;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  char *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  char *backtrace_string;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  os_log_type_t v35;
  _QWORD v36[6];
  os_log_type_t type[15];
  char v38;
  _BYTE v39[24];
  char v40;
  _BYTE buf[12];
  __int16 v42;
  char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_QWORD *)v39 = 0;
    *(_QWORD *)&v39[8] = v39;
    *(_QWORD *)&v39[16] = 0x2020000000;
    v40 = 0;
    os_unfair_lock_lock(v3 + 28);
    v5 = *(void **)&v4[62]._os_unfair_lock_opaque;
    if (v4[29]._os_unfair_lock_opaque != 2)
    {
      v36[0] = MEMORY[0x1E0C809B0];
      v36[1] = 3221225472;
      v36[2] = __nw_endpoint_handler_fillout_tcp_info_block_invoke;
      v36[3] = &unk_1E149FAD8;
      v36[4] = v39;
      v36[5] = a2;
      objc_msgSend(v5, "applyWithHandler:toChildren:", v4, v36);
LABEL_27:
      os_unfair_lock_unlock(v4 + 28);
      v18 = *(_BYTE *)(*(_QWORD *)&v39[8] + 24) != 0;
      _Block_object_dispose(v39, 8);
      goto LABEL_28;
    }
    v6 = v5;
    v7 = v6;
    if (v6)
    {
      os_unfair_lock_lock(v6 + 220);
      v8 = *(const void **)&v7[198]._os_unfair_lock_opaque;
      if (v8)
      {
        memcpy(a2, v8, 0x198uLL);
        v9 = 1;
      }
      else
      {
        v10 = *(_QWORD **)&v7[102]._os_unfair_lock_opaque;
        if (v10)
        {
          v11 = v10[3];
          if (v11)
          {
            v12 = *(uint64_t (**)(void))(v11 + 224);
            if (v12)
            {
              *(_QWORD *)type = 0;
              v13 = (void *)v10[5];
              if (v13 == &nw_protocol_ref_counted_handle)
              {
                v15 = v10[11];
                if (v15)
                  v10[11] = v15 + 1;
                v14 = -1;
              }
              else
              {
                v14 = 0;
              }
              *(_QWORD *)buf = v10;
              buf[8] = v14;
              v16 = (void *)v12();
              if (v13 == &nw_protocol_ref_counted_handle)
                nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              if (v16)
              {
                v9 = *(_QWORD *)type == 408;
                if (*(_QWORD *)type == 408)
                  memcpy(a2, v16, 0x198uLL);
                free(v16);
                goto LABEL_25;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v17 = (id)gLogObj;
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_tcp_info";
                _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s copy_info() returned NULL", buf, 0xCu);
              }

            }
          }
        }
        v9 = 0;
      }
LABEL_25:
      os_unfair_lock_unlock(v7 + 220);
LABEL_26:

      *(_BYTE *)(*(_QWORD *)&v39[8] + 24) = v9;
      goto LABEL_27;
    }
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_tcp_info";
    v25 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v25, type, &v38))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v27 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v32 = type[0];
        v33 = os_log_type_enabled(v26, type[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_tcp_info";
            v42 = 2082;
            v43 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v26, v32, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_64;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_182FBE000, v26, v32, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v35 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_182FBE000, v26, v35, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_64:
    if (v25)
      free(v25);
    v9 = 0;
    goto LABEL_26;
  }
  __nwlog_obj();
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)v39 = 136446210;
  *(_QWORD *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
  v21 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v21, buf, type))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = buf[0];
      if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v39 = 136446210;
        *(_QWORD *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
        _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null handler", v39, 0xCu);
      }
    }
    else if (type[0])
    {
      v28 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v29 = buf[0];
      v30 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (v28)
      {
        if (v30)
        {
          *(_DWORD *)v39 = 136446466;
          *(_QWORD *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
          *(_WORD *)&v39[12] = 2082;
          *(_QWORD *)&v39[14] = v28;
          _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null handler, dumping backtrace:%{public}s", v39, 0x16u);
        }

        free(v28);
        goto LABEL_55;
      }
      if (v30)
      {
        *(_DWORD *)v39 = 136446210;
        *(_QWORD *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
        _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null handler, no backtrace", v39, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v34 = buf[0];
      if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v39 = 136446210;
        *(_QWORD *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
        _os_log_impl(&dword_182FBE000, v22, v34, "%{public}s called with null handler, backtrace limit exceeded", v39, 0xCu);
      }
    }

  }
LABEL_55:
  if (v21)
    free(v21);
  v18 = 0;
LABEL_28:

  return v18;
}

BOOL nw_protocol_metadata_is_tls(nw_protocol_metadata_t metadata)
{
  NSObject *v1;
  NSObject *v2;
  id *v3;
  id v4;
  void *v5;
  BOOL is_equal_unsafe;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = metadata;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    v4 = v3[1];

    v5 = (void *)nw_protocol_boringssl_copy_definition();
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, (uint64_t)v5);

    goto LABEL_3;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_metadata_is_tls";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_metadata_is_tls";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_metadata_is_tls";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_metadata_is_tls";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_metadata_is_tls";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v9)
    free(v9);
  is_equal_unsafe = 0;
LABEL_3:

  return is_equal_unsafe;
}

void sub_183136E30(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_application_error(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_application_error_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_application_error";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_application_error";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_application_error";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_application_error";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_application_error";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_183137148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_application_error_block_invoke(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

#error "18313718C: too big function (funcsize=0)"

void sub_18315DE34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,void *a37,uint64_t a38,void *a39)
{
  void *v39;
  void *v41;

  v41 = (void *)STACK[0x248];
  _Block_object_dispose(&STACK[0x3E8], 8);

  _Block_object_dispose(&STACK[0x418], 8);
  _Block_object_dispose(&STACK[0x438], 8);

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_is_system_proxy_connection(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 108) >> 13) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_is_system_proxy_connection";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_is_system_proxy_connection";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_is_system_proxy_connection";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_is_system_proxy_connection";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_is_system_proxy_connection";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_discretionary(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(_WORD *)(*((_QWORD *)v1 + 13) + 108) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_discretionary";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_discretionary";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_discretionary";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_discretionary";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_discretionary";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_ecn_mode(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_parameters_get_ecn_mode";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_get_ecn_mode";
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v10 = type;
        v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_parameters_get_ecn_mode";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v5)
            goto LABEL_10;
          goto LABEL_9;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_get_ecn_mode";
          _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          v16 = "nw_parameters_get_ecn_mode";
          _os_log_impl(&dword_182FBE000, v6, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v5)
    {
LABEL_10:
      v3 = 0;
      goto LABEL_11;
    }
LABEL_9:
    free(v5);
    goto LABEL_10;
  }
  v3 = v1[93];
LABEL_11:

  return v3;
}

uint64_t nw_parameters_is_fallback(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 98) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_is_fallback";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_is_fallback";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_is_fallback";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_is_fallback";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_is_fallback";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

xpc_object_t nw_parameters_copy_avoided_netagent_domains(void *a1)
{
  NWConcrete_nw_parameters *v1;
  const char *v2;
  const char *v3;
  NWConcrete_nw_parameters *v4;
  NWConcrete_nw_path_parameters *path_parameters;
  OS_nw_interface *required_interface;
  xpc_object_t v7;
  int agent_preference;
  NSObject *v9;
  xpc_object_t v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v4 = v1;
  if (v1)
  {
    path_parameters = v1->path_parameters;
    required_interface = path_parameters->required_interface;
    if (required_interface)
    {
      v7 = *((id *)required_interface + 13);
      path_parameters = v4->path_parameters;
    }
    else
    {
      v7 = 0;
    }
    if (path_parameters->path_value.companion_preference == 2)
    {
      agent_preference = nw_parameters_get_agent_preference(v4, v2, v3);
      if (agent_preference)
      {
        if (agent_preference == 1)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v23 = "nw_parameters_copy_avoided_netagent_domains";
            _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Parameters companion_preference is avoid but companion is in preferred array", buf, 0xCu);
          }

        }
      }
      else
      {
        if (v7)
        {
          v10 = xpc_copy(*((xpc_object_t *)v4->path_parameters->required_interface + 13));

          v7 = v10;
        }
        else
        {
          v7 = xpc_array_create(0, 0);
        }
        xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "com.apple.networkrelay");
      }
    }
    goto LABEL_15;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_parameters_copy_avoided_netagent_domains";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_avoided_netagent_domains";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_parameters_copy_avoided_netagent_domains";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_avoided_netagent_domains";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_avoided_netagent_domains";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_32:
  if (v13)
    free(v13);
  v7 = 0;
LABEL_15:

  return v7;
}

void sub_18315EF58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_parameters_iterate_parent_ids(void *a1, void *a2)
{
  unsigned __int8 *v3;
  id v4;
  uint64_t (**v5)(_QWORD, _QWORD);
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD applier[4];
  uint64_t (**v22)(_QWORD, _QWORD);
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = (uint64_t (**)(_QWORD, _QWORD))v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_parameters_iterate_parent_ids";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_iterate_parent_ids";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_parameters_iterate_parent_ids";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v8)
          goto LABEL_7;
LABEL_42:
        free(v8);
        goto LABEL_7;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_iterate_parent_ids";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_parameters_iterate_parent_ids";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_40:

    goto LABEL_41;
  }
  if (v4)
  {
    if (uuid_is_null(v3 + 8) || (((uint64_t (**)(_QWORD, unsigned __int8 *))v5)[2](v5, v3 + 8) & 1) != 0)
    {
      v6 = (void *)*((_QWORD *)v3 + 17);
      if (v6)
      {
        applier[0] = MEMORY[0x1E0C809B0];
        applier[1] = 3221225472;
        applier[2] = __nw_parameters_iterate_parent_ids_block_invoke;
        applier[3] = &unk_1E14A4E60;
        v22 = v5;
        xpc_array_apply(v6, applier);

      }
    }
    goto LABEL_7;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_parameters_iterate_parent_ids";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_parameters_iterate_parent_ids";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null iterator", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (!v23)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_parameters_iterate_parent_ids";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null iterator, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_40;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_parameters_iterate_parent_ids";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null iterator, no backtrace", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_parameters_iterate_parent_ids";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null iterator, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_42;
LABEL_7:

}

void sub_18315F48C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

id nw_parameters_copy_prohibited_interfaces(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_prohibited_interfaces";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interfaces";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_prohibited_interfaces";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interfaces";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_prohibited_interfaces";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 24);
LABEL_23:

  return v4;
}

xpc_object_t nw_parameters_copy_avoided_netagent_types(void *a1)
{
  NWConcrete_nw_parameters *v1;
  const char *v2;
  const char *v3;
  NWConcrete_nw_parameters *v4;
  NWConcrete_nw_path_parameters *path_parameters;
  OS_nw_interface *required_interface;
  xpc_object_t v7;
  int agent_preference;
  NSObject *v9;
  xpc_object_t v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v4 = v1;
  if (v1)
  {
    path_parameters = v1->path_parameters;
    required_interface = path_parameters->required_interface;
    if (required_interface)
    {
      v7 = *((id *)required_interface + 14);
      path_parameters = v4->path_parameters;
    }
    else
    {
      v7 = 0;
    }
    if (path_parameters->path_value.companion_preference == 2)
    {
      agent_preference = nw_parameters_get_agent_preference(v4, v2, v3);
      if (agent_preference)
      {
        if (agent_preference == 2)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v23 = "nw_parameters_copy_avoided_netagent_types";
            _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Parameters companion_preference is avoid but companion is in preferred array", buf, 0xCu);
          }

        }
      }
      else
      {
        if (v7)
        {
          v10 = xpc_copy(*((xpc_object_t *)v4->path_parameters->required_interface + 14));

          v7 = v10;
        }
        else
        {
          v7 = xpc_array_create(0, 0);
        }
        xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "CompanionProxy");
      }
    }
    goto LABEL_15;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_parameters_copy_avoided_netagent_types";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_avoided_netagent_types";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_parameters_copy_avoided_netagent_types";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_avoided_netagent_types";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_parameters_copy_avoided_netagent_types";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_32:
  if (v13)
    free(v13);
  v7 = 0;
LABEL_15:

  return v7;
}

void sub_18315FAEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_web_search_content(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int8 *)(*((_QWORD *)v1 + 13) + 110) >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_web_search_content";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_web_search_content";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_web_search_content";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_web_search_content";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_web_search_content";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_use_enhanced_privacy_mode(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int8 *)(*((_QWORD *)v1 + 13) + 110) >> 1) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_use_enhanced_privacy_mode";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_use_enhanced_privacy_mode";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_use_enhanced_privacy_mode";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_use_enhanced_privacy_mode";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_use_enhanced_privacy_mode";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_only_primary_requires_type(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 100) >> 5) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_only_primary_requires_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_only_primary_requires_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_only_primary_requires_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_only_primary_requires_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_only_primary_requires_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_no_wake_from_sleep(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(unsigned __int16 *)(*((_QWORD *)v1 + 13) + 108) >> 7) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_no_wake_from_sleep";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_no_wake_from_sleep";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_no_wake_from_sleep";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_no_wake_from_sleep";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_no_wake_from_sleep";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_attributed_bundle_identifier(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 128);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_attributed_bundle_identifier";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attributed_bundle_identifier";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_attributed_bundle_identifier";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attributed_bundle_identifier";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_attributed_bundle_identifier";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_parameters_copy_preferred_netagent_uuids(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_preferred_netagent_uuids";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_preferred_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_preferred_netagent_uuids";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_preferred_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_preferred_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 96);
LABEL_23:

  return v4;
}

uint64_t nw_parameters_get_parent_id_count(void *a1)
{
  id v1;
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = uuid_is_null((const unsigned __int8 *)v1 + 8) == 0;
    v4 = (void *)v2[17];
    if (v4)
      v3 = xpc_array_get_count(v4) + v3;
    goto LABEL_4;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_parameters_get_parent_id_count";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_get_parent_id_count";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_parameters_get_parent_id_count";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_get_parent_id_count";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_parameters_get_parent_id_count";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v7)
    free(v7);
  v3 = 0;
LABEL_4:

  return v3;
}

void sub_183160D64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_local_address_preference(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  id *v4;
  id v5;
  id v6;
  uint64_t is_equal_unsafe;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_parameters_get_local_address_preference";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_get_local_address_preference";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_parameters_get_local_address_preference";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_get_local_address_preference";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_parameters_get_local_address_preference";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_24:
    if (v9)
      free(v9);
    goto LABEL_26;
  }
  v3 = *(void **)(v1[19] + 48);
  if (!v3)
  {
LABEL_26:
    is_equal_unsafe = 0;
    goto LABEL_27;
  }
  v4 = v3;
  v5 = v4[1];

  if (nw_protocol_setup_ip_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_52132);
  v6 = (id)g_ip_definition;
  is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v6);

  if ((_DWORD)is_equal_unsafe)
    is_equal_unsafe = nw_ip_options_get_local_address_preference(*(void **)(v2[19] + 48));

LABEL_27:
  return is_equal_unsafe;
}

void sub_183161088(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_delegated_unique_pid(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 56);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_delegated_unique_pid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_delegated_unique_pid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_delegated_unique_pid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_delegated_unique_pid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_delegated_unique_pid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_parameters_copy_preferred_interface_subtypes(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_preferred_interface_subtypes";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_preferred_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_preferred_interface_subtypes";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_preferred_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_preferred_interface_subtypes";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 16);
LABEL_23:

  return v4;
}

id nw_parameters_copy_channel_demux_options(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_channel_demux_options";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_channel_demux_options";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_channel_demux_options";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_channel_demux_options";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_channel_demux_options";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 128);
LABEL_23:

  return v4;
}

id nw_parameters_copy_avoided_netagent_uuids(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_copy_avoided_netagent_uuids";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_avoided_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_copy_avoided_netagent_uuids";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_avoided_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_copy_avoided_netagent_uuids";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *(_QWORD *)(*((_QWORD *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(id *)(v3 + 120);
LABEL_23:

  return v4;
}

BOOL nw_path_evaluator_add_endpoint_to_necp_message(void *a1, int a2, unint64_t a3, unint64_t a4, char a5)
{
  NSObject *v7;
  NSObject *v8;
  nw_endpoint_type_t v9;
  NSObject *v10;
  nw_endpoint_type_t v11;
  nw_txt_record_t v12;
  _BOOL8 domain_for_policy;
  size_t v14;
  unint64_t sa_len;
  const char *bonjour_service_name;
  const char *bonjour_service_type;
  const char *bonjour_service_domain;
  size_t v19;
  size_t v20;
  size_t v21;
  Class isa;
  const sockaddr *address;
  const char *application_service_alias;
  const char *application_service_name;
  const char *device_name;
  const char *device_model;
  const char *contact_id;
  size_t v29;
  size_t v30;
  size_t v31;
  size_t v32;
  size_t v33;
  Class v34;
  size_t custom_data_length;
  id v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *url;
  size_t v41;
  void *v42;
  os_log_type_t *v43;
  char v44;
  unsigned __int8 v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  _BOOL4 v49;
  os_log_type_t v50;
  char v51;
  unint64_t v52;
  const sockaddr *v53;
  size_t v54;
  unint64_t v55;
  id v56;
  char *v57;
  NSObject *v58;
  os_log_type_t v59;
  _BOOL8 v60;
  const void *v61;
  size_t v62;
  nw_txt_record_t v63;
  const char *v64;
  const char *v65;
  const char *v66;
  size_t v67;
  size_t v68;
  size_t v69;
  const char *v70;
  const char *v71;
  size_t v72;
  id v73;
  NSObject *v74;
  os_log_type_t v75;
  _BOOL8 v76;
  const void *v77;
  size_t v78;
  nw_txt_record_t v79;
  const char *v80;
  const char *v81;
  size_t v82;
  size_t v83;
  NSObject *v84;
  NSObject *v85;
  size_t size;
  id v87;
  char *v88;
  NSObject *v89;
  os_log_type_t v90;
  id v91;
  os_log_type_t v92;
  id v93;
  os_log_type_t v94;
  size_t v95;
  id v96;
  os_log_type_t v97;
  void *v98;
  os_log_type_t *v99;
  size_t v100;
  void *v101;
  os_log_type_t v102;
  const char *v103;
  const char *v104;
  size_t v105;
  size_t v106;
  const char *v107;
  const char *v108;
  size_t v109;
  size_t v110;
  size_t v111;
  const char *v112;
  const char *v113;
  size_t v114;
  size_t v115;
  size_t v116;
  const char *v117;
  const char *v118;
  size_t v119;
  size_t v120;
  size_t v121;
  size_t v122;
  os_log_type_t *v123;
  id v124;
  os_log_type_t v125;
  char *v126;
  os_log_type_t v127;
  _BOOL4 v128;
  os_log_type_t v129;
  _BOOL4 v130;
  os_log_type_t v131;
  _BOOL4 v132;
  os_log_type_t v133;
  _BOOL4 v134;
  os_log_type_t v135;
  _BOOL4 v136;
  char v137;
  char v138;
  char *v139;
  os_log_type_t v140;
  _BOOL4 v141;
  os_log_type_t v142;
  os_log_type_t v143;
  os_log_type_t v144;
  os_log_type_t v145;
  os_log_type_t v146;
  char *v147;
  NSObject *v148;
  os_log_type_t v149;
  _BOOL4 v150;
  os_log_type_t v151;
  NSObject *v152;
  id v153;
  char *v154;
  NSObject *v155;
  os_log_type_t v156;
  char *v157;
  NSObject *v158;
  os_log_type_t v159;
  _BOOL4 v160;
  os_log_type_t v161;
  os_log_type_t v162;
  const char *device_id;
  const char *v164;
  unsigned int v165;
  unsigned int v166;
  unint64_t v167;
  id v168;
  const char *v169;
  NSObject *v170;
  os_log_type_t v171;
  id v172;
  uint64_t v173;
  uint64_t i;
  char *v175;
  void *v176;
  unsigned int v177;
  const void *v178;
  unint64_t v179;
  id v180;
  const char *v181;
  NSObject *v182;
  os_log_type_t v183;
  char *v184;
  os_log_type_t v185;
  _BOOL4 v186;
  os_log_type_t v187;
  id v188;
  const char *v189;
  NSObject *v190;
  os_log_type_t v191;
  id v192;
  const char *v193;
  NSObject *v194;
  os_log_type_t v195;
  const char *v196;
  char *v197;
  NSObject *v198;
  os_log_type_t v199;
  const char *v200;
  char *v201;
  NSObject *v202;
  os_log_type_t v203;
  id v204;
  os_log_type_t v205;
  os_log_type_t v206;
  os_log_type_t v207;
  char *v208;
  os_log_type_t v209;
  _BOOL4 v210;
  os_log_type_t v211;
  os_log_type_t v212;
  os_log_type_t v213;
  NSObject *v214;
  _BOOL8 result;
  const char *v216;
  char *v217;
  NSObject *v218;
  os_log_type_t v219;
  os_log_type_t v220;
  os_log_type_t v221;
  char *v222;
  size_t v223;
  unint64_t v224;
  id v225;
  int v226;
  char *v227;
  NSObject *v228;
  os_log_type_t v229;
  char *v230;
  os_log_type_t v231;
  _BOOL4 v232;
  os_log_type_t v233;
  void *v234;
  char *v235;
  NSObject *v236;
  os_log_type_t v237;
  void *v238;
  os_log_type_t v239;
  void *v240;
  os_log_type_t v241;
  char *backtrace_string;
  os_log_type_t v243;
  _BOOL4 v244;
  os_log_type_t v245;
  _BOOL4 v246;
  char *v247;
  os_log_type_t v248;
  _BOOL4 v249;
  NSObject *v250;
  void *v251;
  void *v252;
  const char *v253;
  NSObject *v254;
  os_log_type_t v255;
  void *v256;
  os_log_type_t v257;
  os_log_type_t v258;
  os_log_type_t v259;
  os_log_type_t v260;
  void *v261;
  os_log_type_t v262;
  void *v263;
  os_log_type_t v264;
  char *v265;
  os_log_type_t v266;
  _BOOL4 v267;
  char *v268;
  NSObject *v269;
  os_log_type_t v270;
  _BOOL4 v271;
  char *v272;
  os_log_type_t v273;
  _BOOL4 v274;
  char *v275;
  os_log_type_t v276;
  _BOOL4 v277;
  os_log_type_t v278;
  os_log_type_t v279;
  os_log_type_t v280;
  os_log_type_t v281;
  char *v282;
  os_log_type_t v283;
  _BOOL4 v284;
  os_log_type_t v285;
  uint8_t *v286;
  uint64_t v287;
  void *v288;
  NSObject *v289;
  nw_txt_record_t v290;
  unint64_t obj;
  void *obja;
  uint64_t v295;
  unint64_t v296;
  __int128 v297;
  __int128 v298;
  __int128 v299;
  __int128 v300;
  _QWORD applier[5];
  char v302;
  os_log_type_t v303[8];
  uint64_t v304;
  uint64_t v305;
  int v306;
  char v307;
  os_log_type_t type;
  unsigned __int8 v309[128];
  uuid_t uu;
  uuid_t v311;
  uint8_t buf[4];
  const char *v313;
  __int16 v314;
  _BYTE v315[20];
  _BYTE v316[10];
  _BYTE v317[10];
  __int16 v318;
  char *v319;
  uint64_t v320;

  v320 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!a3)
  {
    v214 = v7;
    __nwlog_obj();
    v234 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
    v235 = (char *)_os_log_send_and_compose_impl();

    v303[0] = OS_LOG_TYPE_ERROR;
    v311[0] = 0;
    if (!__nwlog_fault(v235, v303, v311))
      goto LABEL_546;
    if (v303[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v236 = objc_claimAutoreleasedReturnValue();
      v237 = v303[0];
      if (os_log_type_enabled(v236, v303[0]))
      {
        *(_DWORD *)buf = 136446210;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_182FBE000, v236, v237, "%{public}s called with null cursor", buf, 0xCu);
      }
      goto LABEL_545;
    }
    if (!v311[0])
    {
      __nwlog_obj();
      v236 = objc_claimAutoreleasedReturnValue();
      v258 = v303[0];
      if (os_log_type_enabled(v236, v303[0]))
      {
        *(_DWORD *)buf = 136446210;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_182FBE000, v236, v258, "%{public}s called with null cursor, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_545;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v236 = objc_claimAutoreleasedReturnValue();
    v243 = v303[0];
    v244 = os_log_type_enabled(v236, v303[0]);
    if (!backtrace_string)
    {
      if (v244)
      {
        *(_DWORD *)buf = 136446210;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_182FBE000, v236, v243, "%{public}s called with null cursor, no backtrace", buf, 0xCu);
      }
      goto LABEL_545;
    }
    if (v244)
    {
      *(_DWORD *)buf = 136446466;
      v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
      v314 = 2082;
      *(_QWORD *)v315 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v236, v243, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_489;
  }
  if (!a4)
  {
    v214 = v7;
    __nwlog_obj();
    v238 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
    v235 = (char *)_os_log_send_and_compose_impl();

    v303[0] = OS_LOG_TYPE_ERROR;
    v311[0] = 0;
    if (!__nwlog_fault(v235, v303, v311))
      goto LABEL_546;
    if (v303[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v236 = objc_claimAutoreleasedReturnValue();
      v239 = v303[0];
      if (os_log_type_enabled(v236, v303[0]))
      {
        *(_DWORD *)buf = 136446210;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_182FBE000, v236, v239, "%{public}s called with null beyond", buf, 0xCu);
      }
      goto LABEL_545;
    }
    if (!v311[0])
    {
      __nwlog_obj();
      v236 = objc_claimAutoreleasedReturnValue();
      v259 = v303[0];
      if (os_log_type_enabled(v236, v303[0]))
      {
        *(_DWORD *)buf = 136446210;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_182FBE000, v236, v259, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_545;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v236 = objc_claimAutoreleasedReturnValue();
    v245 = v303[0];
    v246 = os_log_type_enabled(v236, v303[0]);
    if (!backtrace_string)
    {
      if (v246)
      {
        *(_DWORD *)buf = 136446210;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        _os_log_impl(&dword_182FBE000, v236, v245, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
      }
      goto LABEL_545;
    }
    if (v246)
    {
      *(_DWORD *)buf = 136446466;
      v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
      v314 = 2082;
      *(_QWORD *)v315 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v236, v245, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_489:

    free(backtrace_string);
    if (!v235)
      goto LABEL_548;
    goto LABEL_547;
  }
  v296 = a4;
  if (a3 >= a4)
  {
    v214 = v7;
    __nwlog_obj();
    v240 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
    v314 = 2048;
    *(_QWORD *)v315 = a3;
    *(_WORD *)&v315[8] = 2048;
    *(_QWORD *)&v315[10] = a4;
    v235 = (char *)_os_log_send_and_compose_impl();

    v303[0] = OS_LOG_TYPE_ERROR;
    v311[0] = 0;
    if (!__nwlog_fault(v235, v303, v311))
      goto LABEL_546;
    if (v303[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v236 = objc_claimAutoreleasedReturnValue();
      v241 = v303[0];
      if (os_log_type_enabled(v236, v303[0]))
      {
        *(_DWORD *)buf = 136446722;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        v314 = 2048;
        *(_QWORD *)v315 = a3;
        *(_WORD *)&v315[8] = 2048;
        *(_QWORD *)&v315[10] = v296;
        _os_log_impl(&dword_182FBE000, v236, v241, "%{public}s Invalid cursor %p >= beyond %p", buf, 0x20u);
      }
    }
    else if (v311[0])
    {
      v247 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v236 = objc_claimAutoreleasedReturnValue();
      v248 = v303[0];
      v249 = os_log_type_enabled(v236, v303[0]);
      if (v247)
      {
        if (v249)
        {
          *(_DWORD *)buf = 136446978;
          v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
          v314 = 2048;
          *(_QWORD *)v315 = a3;
          *(_WORD *)&v315[8] = 2048;
          *(_QWORD *)&v315[10] = v296;
          *(_WORD *)&v315[18] = 2082;
          *(_QWORD *)v316 = v247;
          _os_log_impl(&dword_182FBE000, v236, v248, "%{public}s Invalid cursor %p >= beyond %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v247);
LABEL_546:
        if (!v235)
        {
LABEL_548:
          a3 = 0;
LABEL_418:

          return a3;
        }
LABEL_547:
        free(v235);
        goto LABEL_548;
      }
      if (v249)
      {
        *(_DWORD *)buf = 136446722;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        v314 = 2048;
        *(_QWORD *)v315 = a3;
        *(_WORD *)&v315[8] = 2048;
        *(_QWORD *)&v315[10] = v296;
        _os_log_impl(&dword_182FBE000, v236, v248, "%{public}s Invalid cursor %p >= beyond %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      __nwlog_obj();
      v236 = objc_claimAutoreleasedReturnValue();
      v260 = v303[0];
      if (os_log_type_enabled(v236, v303[0]))
      {
        *(_DWORD *)buf = 136446722;
        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
        v314 = 2048;
        *(_QWORD *)v315 = a3;
        *(_WORD *)&v315[8] = 2048;
        *(_QWORD *)&v315[10] = v296;
        _os_log_impl(&dword_182FBE000, v236, v260, "%{public}s Invalid cursor %p >= beyond %p, backtrace limit exceeded", buf, 0x20u);
      }
    }
LABEL_545:

    goto LABEL_546;
  }
  *(_QWORD *)v303 = 0;
  v304 = 0;
  v306 = 0;
  v305 = 0;
  v289 = v7;
  v290 = nw_endpoint_copy_txt_record(v7);
  v9 = nw_endpoint_get_type(v8);
  v10 = v8;
  v11 = nw_endpoint_get_type(v10);
  v12 = nw_endpoint_copy_txt_record(v10);
  switch(v11)
  {
    case nw_endpoint_type_address:
      address = nw_endpoint_get_address(v10);
      if (address)
      {
        sa_len = address->sa_len;
        if (!v12)
          goto LABEL_50;
      }
      else
      {
        sa_len = 0;
        if (!v12)
          goto LABEL_50;
      }
      sa_len = (unint64_t)v12[2].isa + 28;
      goto LABEL_50;
    case nw_endpoint_type_host:
    case nw_endpoint_type_url|nw_endpoint_type_address:
      domain_for_policy = nw_endpoint_get_domain_for_policy(v10);
      if (domain_for_policy)
      {
        v14 = strlen((const char *)domain_for_policy) + 9;
        if (v12)
        {
LABEL_7:
          sa_len = (unint64_t)v12[2].isa + v14;
          goto LABEL_50;
        }
      }
      else
      {
        v14 = 9;
        if (v12)
          goto LABEL_7;
      }
      sa_len = v14;
      goto LABEL_50;
    case nw_endpoint_type_bonjour_service:
      bonjour_service_name = nw_endpoint_get_bonjour_service_name(v10);
      bonjour_service_type = nw_endpoint_get_bonjour_service_type(v10);
      bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(v10);
      if (bonjour_service_name)
      {
        v19 = strlen(bonjour_service_name) + 9;
        if (bonjour_service_type)
          goto LABEL_10;
      }
      else
      {
        v19 = 9;
        if (bonjour_service_type)
        {
LABEL_10:
          v20 = strlen(bonjour_service_type) + 1;
          if (bonjour_service_domain)
          {
LABEL_11:
            v21 = strlen(bonjour_service_domain) + 1;
            if (v12)
            {
LABEL_12:
              isa = v12[2].isa;
              goto LABEL_42;
            }
LABEL_41:
            isa = 0;
LABEL_42:
            sa_len = (unint64_t)isa + v21 + v20 + v19;
            goto LABEL_50;
          }
LABEL_40:
          v21 = 1;
          if (v12)
            goto LABEL_12;
          goto LABEL_41;
        }
      }
      v20 = 1;
      if (bonjour_service_domain)
        goto LABEL_11;
      goto LABEL_40;
    case nw_endpoint_type_url:
      url = nw_endpoint_get_url(v10);
      if (url)
        sa_len = strlen(url) + 9;
      else
        sa_len = 9;
      goto LABEL_50;
    case nw_endpoint_type_url|nw_endpoint_type_host:
      application_service_alias = (const char *)nw_endpoint_get_application_service_alias(v10);
      application_service_name = (const char *)nw_endpoint_get_application_service_name(v10);
      nw_endpoint_get_service_identifier(v10, buf);
      device_name = (const char *)nw_endpoint_get_device_name(v10);
      device_model = (const char *)nw_endpoint_get_device_model(v10);
      contact_id = (const char *)nw_endpoint_get_contact_id(v10);
      if (application_service_alias)
      {
        v29 = strlen(application_service_alias) + 9;
        if (application_service_name)
          goto LABEL_18;
      }
      else
      {
        v29 = 9;
        if (application_service_name)
        {
LABEL_18:
          v30 = strlen(application_service_name) + 1;
          if (device_name)
            goto LABEL_19;
          goto LABEL_45;
        }
      }
      v30 = 1;
      if (device_name)
      {
LABEL_19:
        v31 = strlen(device_name) + 1;
        if (device_model)
          goto LABEL_20;
        goto LABEL_46;
      }
LABEL_45:
      v31 = 1;
      if (device_model)
      {
LABEL_20:
        v32 = strlen(device_model) + 1;
        if (contact_id)
          goto LABEL_21;
        goto LABEL_47;
      }
LABEL_46:
      v32 = 1;
      if (contact_id)
      {
LABEL_21:
        v33 = strlen(contact_id) + 1;
        if (v12)
        {
LABEL_22:
          v34 = v12[2].isa;
          goto LABEL_49;
        }
LABEL_48:
        v34 = 0;
LABEL_49:
        sa_len = (unint64_t)v34 + v33 + v29 + v30 + v31 + v32 + 24;
LABEL_50:
        if (sa_len <= 0x1C)
          v41 = 28;
        else
          v41 = sa_len;
        goto LABEL_53;
      }
LABEL_47:
      v33 = 1;
      if (v12)
        goto LABEL_22;
      goto LABEL_48;
    default:
      if (!nw_endpoint_is_custom_type(v10))
        goto LABEL_74;
      custom_data_length = nw_endpoint_get_custom_data_length(v10);
      if (!custom_data_length)
        goto LABEL_74;
      if (custom_data_length > 0x400)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v36 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v313 = "nw_path_struct_size_for_endpoint";
        v314 = 1024;
        *(_DWORD *)v315 = 1024;
        LODWORD(v287) = 18;
        v286 = buf;
        v37 = (char *)_os_log_send_and_compose_impl();

        v311[0] = 16;
        uu[0] = 0;
        if (__nwlog_fault(v37, v311, uu))
        {
          if (v311[0] == 17)
          {
            __nwlog_obj();
            v38 = objc_claimAutoreleasedReturnValue();
            v39 = v311[0];
            if (os_log_type_enabled(v38, (os_log_type_t)v311[0]))
            {
              *(_DWORD *)buf = 136446466;
              v313 = "nw_path_struct_size_for_endpoint";
              v314 = 1024;
              *(_DWORD *)v315 = 1024;
              _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
            }
LABEL_30:

            goto LABEL_72;
          }
          if (!uu[0])
          {
            __nwlog_obj();
            v38 = objc_claimAutoreleasedReturnValue();
            v50 = v311[0];
            if (os_log_type_enabled(v38, (os_log_type_t)v311[0]))
            {
              *(_DWORD *)buf = 136446466;
              v313 = "nw_path_struct_size_for_endpoint";
              v314 = 1024;
              *(_DWORD *)v315 = 1024;
              _os_log_impl(&dword_182FBE000, v38, v50, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", buf, 0x12u);
            }
            goto LABEL_30;
          }
          v46 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v47 = objc_claimAutoreleasedReturnValue();
          v48 = v311[0];
          v49 = os_log_type_enabled(v47, (os_log_type_t)v311[0]);
          if (v46)
          {
            if (v49)
            {
              *(_DWORD *)buf = 136446722;
              v313 = "nw_path_struct_size_for_endpoint";
              v314 = 1024;
              *(_DWORD *)v315 = 1024;
              *(_WORD *)&v315[4] = 2082;
              *(_QWORD *)&v315[6] = v46;
              _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v46);
          }
          else
          {
            if (v49)
            {
              *(_DWORD *)buf = 136446466;
              v313 = "nw_path_struct_size_for_endpoint";
              v314 = 1024;
              *(_DWORD *)v315 = 1024;
              _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s Custom data size must be no larger than %d, no backtrace", buf, 0x12u);
            }

          }
        }
LABEL_72:
        if (v37)
          free(v37);
LABEL_74:

        sa_len = 0;
        goto LABEL_75;
      }
      v44 = -9;
      if (custom_data_length < 0xF7)
        v44 = custom_data_length;
      v45 = v44 + 8;
      sa_len = v45;
      if (v45 <= 0x1Cu)
        v41 = 28;
      else
        v41 = v45;
LABEL_53:

      if (v41 < 0x1D)
      {
LABEL_75:
        v288 = 0;
        v43 = v303;
        v41 = 28;
        goto LABEL_76;
      }
      v42 = malloc_type_calloc(v41, 1uLL, 0xEAFB8F1AuLL);
      if (v42)
      {
        v288 = v42;
        v43 = (os_log_type_t *)v42;
        goto LABEL_76;
      }
      __nwlog_obj();
      v250 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v250, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v313 = "strict_calloc";
      v314 = 2048;
      *(_QWORD *)v315 = v41;
      *(_WORD *)&v315[8] = 2048;
      *(_QWORD *)&v315[10] = 1;
      LODWORD(v287) = 32;
      v286 = buf;
      v251 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v251);
      if (!result)
      {
        free(v251);
        v288 = 0;
        v43 = 0;
LABEL_76:
        v51 = -1;
        if (v41 >= 0xFF)
          v52 = 255;
        else
          v52 = v41;
        if (sa_len < 0xFF)
          v51 = sa_len;
        switch(v9)
        {
          case nw_endpoint_type_address:
            v53 = nw_endpoint_get_address(v10);
            if (v53)
            {
              memcpy(v43, v53, v53->sa_len);
              if (v290)
              {
                v54 = (size_t)v290[2].isa;
                if (v52 >= v54 + 28)
                  memcpy(v43 + 28, v290[1].isa, v54);
              }
              v55 = v52 + 5;
              if (v296 - a3 >= v52 + 5)
              {
                *(_BYTE *)a3 = a2;
                *(_DWORD *)(a3 + 1) = v52;
                if (v43)
                  goto LABEL_196;
                __nwlog_obj();
                v101 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136446722;
                v313 = "nw_necp_append_tlv";
                v314 = 1024;
                *(_DWORD *)v315 = a2;
                *(_WORD *)&v315[4] = 1024;
                *(_DWORD *)&v315[6] = v52;
                LODWORD(v287) = 24;
                v286 = buf;
                v57 = (char *)_os_log_send_and_compose_impl();

                v311[0] = 16;
                uu[0] = 0;
                if (!__nwlog_fault(v57, v311, uu))
                  goto LABEL_276;
                if (v311[0] == 17)
                {
                  __nwlog_obj();
                  v58 = objc_claimAutoreleasedReturnValue();
                  v102 = v311[0];
                  if (os_log_type_enabled(v58, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    v313 = "nw_necp_append_tlv";
                    v314 = 1024;
                    *(_DWORD *)v315 = a2;
                    *(_WORD *)&v315[4] = 1024;
                    *(_DWORD *)&v315[6] = v52;
                    _os_log_impl(&dword_182FBE000, v58, v102, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
                  }
                  goto LABEL_275;
                }
                if (!uu[0])
                {
                  __nwlog_obj();
                  v58 = objc_claimAutoreleasedReturnValue();
                  v285 = v311[0];
                  if (os_log_type_enabled(v58, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    v313 = "nw_necp_append_tlv";
                    v314 = 1024;
                    *(_DWORD *)v315 = a2;
                    *(_WORD *)&v315[4] = 1024;
                    *(_DWORD *)&v315[6] = v52;
                    _os_log_impl(&dword_182FBE000, v58, v285, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
                  }
                  goto LABEL_275;
                }
                v282 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v58 = objc_claimAutoreleasedReturnValue();
                v283 = v311[0];
                v284 = os_log_type_enabled(v58, (os_log_type_t)v311[0]);
                if (!v282)
                {
                  if (v284)
                  {
                    *(_DWORD *)buf = 136446722;
                    v313 = "nw_necp_append_tlv";
                    v314 = 1024;
                    *(_DWORD *)v315 = a2;
                    *(_WORD *)&v315[4] = 1024;
                    *(_DWORD *)&v315[6] = v52;
                    _os_log_impl(&dword_182FBE000, v58, v283, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
                  }
                  goto LABEL_275;
                }
                if (v284)
                {
                  *(_DWORD *)buf = 136446978;
                  v313 = "nw_necp_append_tlv";
                  v314 = 1024;
                  *(_DWORD *)v315 = a2;
                  *(_WORD *)&v315[4] = 1024;
                  *(_DWORD *)&v315[6] = v52;
                  *(_WORD *)&v315[10] = 2082;
                  *(_QWORD *)&v315[12] = v282;
                  _os_log_impl(&dword_182FBE000, v58, v283, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
                }

                free(v282);
                if (v57)
                  goto LABEL_277;
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v56 = (id)gLogObj;
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                LODWORD(v287) = 54;
                v286 = buf;
                v57 = (char *)_os_log_send_and_compose_impl();

                v311[0] = 16;
                uu[0] = 0;
                if (!__nwlog_fault(v57, v311, uu))
                  goto LABEL_276;
                if (v311[0] == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v58 = (id)gLogObj;
                  v59 = v311[0];
                  if (os_log_type_enabled(v58, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136447490;
                    v313 = "nw_necp_append_tlv";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v52 + 5;
                    *(_WORD *)&v315[18] = 2048;
                    *(_QWORD *)v316 = v296;
                    *(_WORD *)&v316[8] = 1024;
                    *(_DWORD *)v317 = a2;
                    *(_WORD *)&v317[4] = 1024;
                    *(_DWORD *)&v317[6] = v52;
                    _os_log_impl(&dword_182FBE000, v58, v59, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                  }
                  goto LABEL_275;
                }
                if (!uu[0])
                {
                  __nwlog_obj();
                  v58 = objc_claimAutoreleasedReturnValue();
                  v151 = v311[0];
                  if (os_log_type_enabled(v58, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136447490;
                    v313 = "nw_necp_append_tlv";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v52 + 5;
                    *(_WORD *)&v315[18] = 2048;
                    *(_QWORD *)v316 = v296;
                    *(_WORD *)&v316[8] = 1024;
                    *(_DWORD *)v317 = a2;
                    *(_WORD *)&v317[4] = 1024;
                    *(_DWORD *)&v317[6] = v52;
                    _os_log_impl(&dword_182FBE000, v58, v151, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                  }
                  goto LABEL_275;
                }
                v139 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v58 = objc_claimAutoreleasedReturnValue();
                v140 = v311[0];
                v141 = os_log_type_enabled(v58, (os_log_type_t)v311[0]);
                if (!v139)
                {
                  if (v141)
                  {
                    *(_DWORD *)buf = 136447490;
                    v313 = "nw_necp_append_tlv";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v52 + 5;
                    *(_WORD *)&v315[18] = 2048;
                    *(_QWORD *)v316 = v296;
                    *(_WORD *)&v316[8] = 1024;
                    *(_DWORD *)v317 = a2;
                    *(_WORD *)&v317[4] = 1024;
                    *(_DWORD *)&v317[6] = v52;
                    _os_log_impl(&dword_182FBE000, v58, v140, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                  }
                  goto LABEL_275;
                }
                if (v141)
                {
                  *(_DWORD *)buf = 136447746;
                  v313 = "nw_necp_append_tlv";
                  v314 = 2048;
                  *(_QWORD *)v315 = a3;
                  *(_WORD *)&v315[8] = 2048;
                  *(_QWORD *)&v315[10] = v52 + 5;
                  *(_WORD *)&v315[18] = 2048;
                  *(_QWORD *)v316 = v296;
                  *(_WORD *)&v316[8] = 1024;
                  *(_DWORD *)v317 = a2;
                  *(_WORD *)&v317[4] = 1024;
                  *(_DWORD *)&v317[6] = v52;
                  v318 = 2082;
                  v319 = v139;
                  _os_log_impl(&dword_182FBE000, v58, v140, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }

                free(v139);
                if (v57)
                  goto LABEL_277;
              }
              goto LABEL_278;
            }
            goto LABEL_279;
          case nw_endpoint_type_host:
            *((_BYTE *)v43 + 1) = 0;
            *v43 = v51;
            *((_WORD *)v43 + 1) = __rev16(nw_endpoint_get_port(v10));
            *((_DWORD *)v43 + 1) = 2;
            v76 = nw_endpoint_get_domain_for_policy(v10);
            v77 = (const void *)v76;
            if (v76)
            {
              v78 = strlen((const char *)v76) + 1;
              memcpy(v43 + 8, v77, v78);
              v79 = v290;
              if (v290)
              {
LABEL_110:
                memcpy(&v43[v78 + 8], v79[1].isa, (size_t)v79[2].isa);
LABEL_133:
                v55 = v52 + 5;
                if (v296 - a3 >= v52 + 5)
                  goto LABEL_195;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v93 = (id)gLogObj;
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                LODWORD(v287) = 54;
                v286 = buf;
                v57 = (char *)_os_log_send_and_compose_impl();

                v311[0] = 16;
                uu[0] = 0;
                if (!__nwlog_fault(v57, v311, uu))
                  goto LABEL_276;
                if (v311[0] == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v74 = (id)gLogObj;
                  v94 = v311[0];
                  if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136447490;
                    v313 = "nw_necp_append_tlv";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v52 + 5;
                    *(_WORD *)&v315[18] = 2048;
                    *(_QWORD *)v316 = v296;
                    *(_WORD *)&v316[8] = 1024;
                    *(_DWORD *)v317 = a2;
                    *(_WORD *)&v317[4] = 1024;
                    *(_DWORD *)&v317[6] = v52;
                    _os_log_impl(&dword_182FBE000, v74, v94, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                  }
                  goto LABEL_269;
                }
                if (uu[0])
                {
                  v126 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v74 = objc_claimAutoreleasedReturnValue();
                  v131 = v311[0];
                  v132 = os_log_type_enabled(v74, (os_log_type_t)v311[0]);
                  if (v126)
                  {
                    if (v132)
                    {
                      *(_DWORD *)buf = 136447746;
                      v313 = "nw_necp_append_tlv";
                      v314 = 2048;
                      *(_QWORD *)v315 = a3;
                      *(_WORD *)&v315[8] = 2048;
                      *(_QWORD *)&v315[10] = v52 + 5;
                      *(_WORD *)&v315[18] = 2048;
                      *(_QWORD *)v316 = v296;
                      *(_WORD *)&v316[8] = 1024;
                      *(_DWORD *)v317 = a2;
                      *(_WORD *)&v317[4] = 1024;
                      *(_DWORD *)&v317[6] = v52;
                      v318 = 2082;
                      v319 = v126;
                      _os_log_impl(&dword_182FBE000, v74, v131, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                    }
                    goto LABEL_217;
                  }
                  if (v132)
                  {
                    *(_DWORD *)buf = 136447490;
                    v313 = "nw_necp_append_tlv";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v52 + 5;
                    *(_WORD *)&v315[18] = 2048;
                    *(_QWORD *)v316 = v296;
                    *(_WORD *)&v316[8] = 1024;
                    *(_DWORD *)v317 = a2;
                    *(_WORD *)&v317[4] = 1024;
                    *(_DWORD *)&v317[6] = v52;
                    _os_log_impl(&dword_182FBE000, v74, v131, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                  }
                }
                else
                {
                  __nwlog_obj();
                  v74 = objc_claimAutoreleasedReturnValue();
                  v144 = v311[0];
                  if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136447490;
                    v313 = "nw_necp_append_tlv";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v52 + 5;
                    *(_WORD *)&v315[18] = 2048;
                    *(_QWORD *)v316 = v296;
                    *(_WORD *)&v316[8] = 1024;
                    *(_DWORD *)v317 = a2;
                    *(_WORD *)&v317[4] = 1024;
                    *(_DWORD *)&v317[6] = v52;
                    _os_log_impl(&dword_182FBE000, v74, v144, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                  }
                }
                goto LABEL_269;
              }
            }
            else
            {
              v78 = 1;
              v79 = v290;
              if (v290)
                goto LABEL_110;
            }
            v43[v52 - 1] = OS_LOG_TYPE_DEFAULT;
            goto LABEL_133;
          case nw_endpoint_type_bonjour_service:
            *((_BYTE *)v43 + 1) = 0;
            *v43 = v51;
            *((_WORD *)v43 + 1) = 0;
            *((_DWORD *)v43 + 1) = 3;
            v64 = nw_endpoint_get_bonjour_service_name(v10);
            v65 = nw_endpoint_get_bonjour_service_type(v10);
            v66 = nw_endpoint_get_bonjour_service_domain(v10);
            if (v64)
            {
              v67 = strlen(v64) + 1;
              if (v65)
                goto LABEL_97;
            }
            else
            {
              v67 = 1;
              if (v65)
              {
LABEL_97:
                v68 = strlen(v65) + 1;
                obj = v52;
                if (v66)
                  goto LABEL_98;
                goto LABEL_141;
              }
            }
            v68 = 1;
            obj = v52;
            if (v66)
            {
LABEL_98:
              v69 = strlen(v66) + 1;
              if (!v64)
                goto LABEL_144;
              goto LABEL_142;
            }
LABEL_141:
            v69 = 1;
            if (!v64)
              goto LABEL_144;
LABEL_142:
            if (v67)
              memcpy(v43 + 8, v64, v67);
LABEL_144:
            if (v65 && v68)
              memcpy(&v43[v67 + 8], v65, v68);
            if (v66 && v69)
              memcpy(&v43[v67 + 8 + v68], v66, v69);
            if (v290)
            {
              memcpy(&v43[v67 + 8 + v68 + v69], v290[1].isa, (size_t)v290[2].isa);
              v95 = obj;
            }
            else
            {
              v95 = obj;
              v43[obj - 1] = OS_LOG_TYPE_DEFAULT;
            }
            v55 = v95 + 5;
            if (v296 - a3 >= v95 + 5)
            {
              *(_BYTE *)a3 = a2;
              *(_DWORD *)(a3 + 1) = v95;
              v98 = (void *)(a3 + 5);
              v99 = v43;
              v100 = v95;
              goto LABEL_197;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v96 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v313 = "nw_necp_append_tlv";
            v314 = 2048;
            *(_QWORD *)v315 = a3;
            *(_WORD *)&v315[8] = 2048;
            *(_QWORD *)&v315[10] = v95 + 5;
            *(_WORD *)&v315[18] = 2048;
            *(_QWORD *)v316 = v296;
            *(_WORD *)&v316[8] = 1024;
            *(_DWORD *)v317 = a2;
            *(_WORD *)&v317[4] = 1024;
            *(_DWORD *)&v317[6] = v95;
            LODWORD(v287) = 54;
            v286 = buf;
            v57 = (char *)_os_log_send_and_compose_impl();

            v311[0] = 16;
            uu[0] = 0;
            if (!__nwlog_fault(v57, v311, uu))
              goto LABEL_276;
            if (v311[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v74 = (id)gLogObj;
              v97 = v311[0];
              if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v95 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = obj;
                _os_log_impl(&dword_182FBE000, v74, v97, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
              goto LABEL_269;
            }
            if (uu[0])
            {
              v126 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v74 = objc_claimAutoreleasedReturnValue();
              v133 = v311[0];
              v134 = os_log_type_enabled(v74, (os_log_type_t)v311[0]);
              if (v126)
              {
                if (v134)
                {
                  *(_DWORD *)buf = 136447746;
                  v313 = "nw_necp_append_tlv";
                  v314 = 2048;
                  *(_QWORD *)v315 = a3;
                  *(_WORD *)&v315[8] = 2048;
                  *(_QWORD *)&v315[10] = v55;
                  *(_WORD *)&v315[18] = 2048;
                  *(_QWORD *)v316 = v296;
                  *(_WORD *)&v316[8] = 1024;
                  *(_DWORD *)v317 = a2;
                  *(_WORD *)&v317[4] = 1024;
                  *(_DWORD *)&v317[6] = obj;
                  v318 = 2082;
                  v319 = v126;
                  _os_log_impl(&dword_182FBE000, v74, v133, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }
                goto LABEL_217;
              }
              if (v134)
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v55;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = obj;
                _os_log_impl(&dword_182FBE000, v74, v133, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
            }
            else
            {
              __nwlog_obj();
              v74 = objc_claimAutoreleasedReturnValue();
              v145 = v311[0];
              if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v95 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = obj;
                _os_log_impl(&dword_182FBE000, v74, v145, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
            }
            goto LABEL_269;
          case nw_endpoint_type_url:
            *((_BYTE *)v43 + 1) = 0;
            *v43 = v51;
            *((_WORD *)v43 + 1) = __rev16(nw_endpoint_get_port(v10));
            *((_DWORD *)v43 + 1) = 4;
            v70 = nw_endpoint_get_url(v10);
            v71 = v70;
            if (v70)
            {
              v72 = strlen(v70);
              memcpy(v43 + 8, v71, v72 + 1);
            }
            v43[v52 - 1] = OS_LOG_TYPE_DEFAULT;
            v55 = v52 + 5;
            if (v296 - a3 >= v52 + 5)
              goto LABEL_195;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v73 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v313 = "nw_necp_append_tlv";
            v314 = 2048;
            *(_QWORD *)v315 = a3;
            *(_WORD *)&v315[8] = 2048;
            *(_QWORD *)&v315[10] = v52 + 5;
            *(_WORD *)&v315[18] = 2048;
            *(_QWORD *)v316 = v296;
            *(_WORD *)&v316[8] = 1024;
            *(_DWORD *)v317 = a2;
            *(_WORD *)&v317[4] = 1024;
            *(_DWORD *)&v317[6] = v52;
            LODWORD(v287) = 54;
            v286 = buf;
            v57 = (char *)_os_log_send_and_compose_impl();

            v311[0] = 16;
            uu[0] = 0;
            if (!__nwlog_fault(v57, v311, uu))
              goto LABEL_276;
            if (v311[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v74 = (id)gLogObj;
              v75 = v311[0];
              if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
              goto LABEL_269;
            }
            if (uu[0])
            {
              v126 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v74 = objc_claimAutoreleasedReturnValue();
              v129 = v311[0];
              v130 = os_log_type_enabled(v74, (os_log_type_t)v311[0]);
              if (v126)
              {
                if (v130)
                {
                  *(_DWORD *)buf = 136447746;
                  v313 = "nw_necp_append_tlv";
                  v314 = 2048;
                  *(_QWORD *)v315 = a3;
                  *(_WORD *)&v315[8] = 2048;
                  *(_QWORD *)&v315[10] = v52 + 5;
                  *(_WORD *)&v315[18] = 2048;
                  *(_QWORD *)v316 = v296;
                  *(_WORD *)&v316[8] = 1024;
                  *(_DWORD *)v317 = a2;
                  *(_WORD *)&v317[4] = 1024;
                  *(_DWORD *)&v317[6] = v52;
                  v318 = 2082;
                  v319 = v126;
                  _os_log_impl(&dword_182FBE000, v74, v129, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }
                goto LABEL_217;
              }
              if (v130)
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v74, v129, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
            }
            else
            {
              __nwlog_obj();
              v74 = objc_claimAutoreleasedReturnValue();
              v143 = v311[0];
              if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v74, v143, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
            }
            goto LABEL_269;
          case nw_endpoint_type_url|nw_endpoint_type_address:
            *((_BYTE *)v43 + 1) = 0;
            *v43 = v51;
            *((_WORD *)v43 + 1) = 0;
            *((_DWORD *)v43 + 1) = 5;
            v60 = nw_endpoint_get_domain_for_policy(v10);
            v61 = (const void *)v60;
            if (v60)
            {
              v62 = strlen((const char *)v60) + 1;
              memcpy(v43 + 8, v61, v62);
              v63 = v290;
              if (v290)
              {
LABEL_94:
                memcpy(&v43[v62 + 8], v63[1].isa, (size_t)v63[2].isa);
                goto LABEL_124;
              }
            }
            else
            {
              v62 = 1;
              v63 = v290;
              if (v290)
                goto LABEL_94;
            }
            v43[v52 - 1] = OS_LOG_TYPE_DEFAULT;
LABEL_124:
            v55 = v52 + 5;
            if (v296 - a3 >= v52 + 5)
            {
LABEL_195:
              *(_BYTE *)a3 = a2;
              *(_DWORD *)(a3 + 1) = v52;
LABEL_196:
              v98 = (void *)(a3 + 5);
              v99 = v43;
              v100 = v52;
LABEL_197:
              memcpy(v98, v99, v100);
              a3 += v55;
              goto LABEL_279;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v91 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v313 = "nw_necp_append_tlv";
            v314 = 2048;
            *(_QWORD *)v315 = a3;
            *(_WORD *)&v315[8] = 2048;
            *(_QWORD *)&v315[10] = v52 + 5;
            *(_WORD *)&v315[18] = 2048;
            *(_QWORD *)v316 = v296;
            *(_WORD *)&v316[8] = 1024;
            *(_DWORD *)v317 = a2;
            *(_WORD *)&v317[4] = 1024;
            *(_DWORD *)&v317[6] = v52;
            LODWORD(v287) = 54;
            v286 = buf;
            v57 = (char *)_os_log_send_and_compose_impl();

            v311[0] = 16;
            uu[0] = 0;
            if (!__nwlog_fault(v57, v311, uu))
              goto LABEL_276;
            if (v311[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v74 = (id)gLogObj;
              v92 = v311[0];
              if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v74, v92, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
            }
            else if (uu[0])
            {
              v126 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v74 = objc_claimAutoreleasedReturnValue();
              v127 = v311[0];
              v128 = os_log_type_enabled(v74, (os_log_type_t)v311[0]);
              if (v126)
              {
                if (v128)
                {
                  *(_DWORD *)buf = 136447746;
                  v313 = "nw_necp_append_tlv";
                  v314 = 2048;
                  *(_QWORD *)v315 = a3;
                  *(_WORD *)&v315[8] = 2048;
                  *(_QWORD *)&v315[10] = v52 + 5;
                  *(_WORD *)&v315[18] = 2048;
                  *(_QWORD *)v316 = v296;
                  *(_WORD *)&v316[8] = 1024;
                  *(_DWORD *)v317 = a2;
                  *(_WORD *)&v317[4] = 1024;
                  *(_DWORD *)&v317[6] = v52;
                  v318 = 2082;
                  v319 = v126;
                  _os_log_impl(&dword_182FBE000, v74, v127, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                }
LABEL_217:

                goto LABEL_223;
              }
              if (v128)
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v74, v127, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
            }
            else
            {
              __nwlog_obj();
              v74 = objc_claimAutoreleasedReturnValue();
              v142 = v311[0];
              if (os_log_type_enabled(v74, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v74, v142, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
            }
LABEL_269:

LABEL_276:
            if (!v57)
              goto LABEL_278;
            goto LABEL_277;
          case nw_endpoint_type_url|nw_endpoint_type_host:
            *((_BYTE *)v43 + 1) = 0;
            *v43 = v51;
            *((_WORD *)v43 + 1) = 0;
            *((_DWORD *)v43 + 1) = 6;
            v80 = (const char *)nw_endpoint_get_application_service_alias(v10);
            v81 = v80;
            if (v80)
            {
              v82 = strlen(v80);
              v83 = v82 + 1;
              if (v82 == -1)
                v83 = 0;
              else
                memcpy(v43 + 8, v81, v83);
            }
            else
            {
              v83 = 1;
            }
            v103 = (const char *)nw_endpoint_get_application_service_name(v10);
            v104 = v103;
            if (v103)
            {
              v105 = strlen(v103);
              v106 = v105 + 1;
              if (v105 == -1)
                v106 = 0;
              else
                memcpy(&v43[v83 + 8], v104, v106);
            }
            else
            {
              v106 = 1;
            }
            v107 = (const char *)nw_endpoint_get_device_name(v10);
            v108 = v107;
            v109 = v106 + v83;
            if (v107)
            {
              v110 = strlen(v107);
              v111 = v110 + 1;
              if (v110 == -1)
                v111 = 0;
              else
                memcpy(&v43[v109 + 8], v108, v111);
            }
            else
            {
              v111 = 1;
            }
            v112 = (const char *)nw_endpoint_get_device_model(v10);
            v113 = v112;
            v114 = v111 + v109;
            if (v112)
            {
              v115 = strlen(v112);
              v116 = v115 + 1;
              if (v115 == -1)
                v116 = 0;
              else
                memcpy(&v43[v114 + 8], v113, v116);
            }
            else
            {
              v116 = 1;
            }
            v117 = (const char *)nw_endpoint_get_contact_id(v10);
            v118 = v117;
            v119 = v116 + v114;
            if (v117)
            {
              v120 = strlen(v117);
              v121 = v120 + 1;
              if (v120 == -1)
                v121 = 0;
              else
                memcpy(&v43[v119 + 8], v118, v121);
            }
            else
            {
              v121 = 1;
            }
            v122 = v121 + v119;
            v123 = v43 + 8;
            *(_DWORD *)&v43[v122 + 8] = nw_endpoint_get_device_color(v10);
            *(_DWORD *)&v123[v122 + 4] = nw_endpoint_get_advertised_route(v10);
            memset(v311, 0, sizeof(v311));
            nw_endpoint_get_service_identifier(v10, v311);
            *(_OWORD *)&v123[v122 + 8] = *(_OWORD *)v311;
            if (v290)
              memcpy(&v123[v122 + 24], v290[1].isa, (size_t)v290[2].isa);
            v55 = v52 + 5;
            if (v296 - a3 >= v52 + 5)
              goto LABEL_195;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v124 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v313 = "nw_necp_append_tlv";
            v314 = 2048;
            *(_QWORD *)v315 = a3;
            *(_WORD *)&v315[8] = 2048;
            *(_QWORD *)&v315[10] = v52 + 5;
            *(_WORD *)&v315[18] = 2048;
            *(_QWORD *)v316 = v296;
            *(_WORD *)&v316[8] = 1024;
            *(_DWORD *)v317 = a2;
            *(_WORD *)&v317[4] = 1024;
            *(_DWORD *)&v317[6] = v52;
            LODWORD(v287) = 54;
            v286 = buf;
            v57 = (char *)_os_log_send_and_compose_impl();

            uu[0] = 16;
            type = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v57, uu, &type))
              goto LABEL_276;
            if (uu[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v58 = (id)gLogObj;
              v125 = uu[0];
              if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v58, v125, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
LABEL_275:

              goto LABEL_276;
            }
            if (type == OS_LOG_TYPE_DEFAULT)
            {
              __nwlog_obj();
              v58 = objc_claimAutoreleasedReturnValue();
              v146 = uu[0];
              if (os_log_type_enabled(v58, (os_log_type_t)uu[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v58, v146, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
              goto LABEL_275;
            }
            v126 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v58 = objc_claimAutoreleasedReturnValue();
            v135 = uu[0];
            v136 = os_log_type_enabled(v58, (os_log_type_t)uu[0]);
            if (!v126)
            {
              if (v136)
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v52 + 5;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v52;
                _os_log_impl(&dword_182FBE000, v58, v135, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
              goto LABEL_275;
            }
            if (v136)
            {
              *(_DWORD *)buf = 136447746;
              v313 = "nw_necp_append_tlv";
              v314 = 2048;
              *(_QWORD *)v315 = a3;
              *(_WORD *)&v315[8] = 2048;
              *(_QWORD *)&v315[10] = v52 + 5;
              *(_WORD *)&v315[18] = 2048;
              *(_QWORD *)v316 = v296;
              *(_WORD *)&v316[8] = 1024;
              *(_DWORD *)v317 = a2;
              *(_WORD *)&v317[4] = 1024;
              *(_DWORD *)&v317[6] = v52;
              v318 = 2082;
              v319 = v126;
              _os_log_impl(&dword_182FBE000, v58, v135, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
            }

LABEL_223:
            free(v126);
            if (v57)
LABEL_277:
              free(v57);
LABEL_278:
            a3 = 0;
            goto LABEL_279;
          default:
            if (!nw_endpoint_is_custom_type(v10))
              goto LABEL_279;
            v84 = nw_endpoint_copy_custom_data(v10);
            v85 = v84;
            if (!v84)
            {
              *(_DWORD *)v43 = 8;
              *((_DWORD *)v43 + 1) = v9;
              goto LABEL_443;
            }
            size = dispatch_data_get_size(v84);
            if (size > 0x400)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v87 = (id)gLogObj;
              *(_DWORD *)buf = 136446466;
              v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
              v314 = 1024;
              *(_DWORD *)v315 = 1024;
              LODWORD(v287) = 18;
              v286 = buf;
              v88 = (char *)_os_log_send_and_compose_impl();

              v311[0] = 16;
              uu[0] = 0;
              if (__nwlog_fault(v88, v311, uu))
              {
                if (v311[0] == 17)
                {
                  __nwlog_obj();
                  v89 = objc_claimAutoreleasedReturnValue();
                  v90 = v311[0];
                  if (os_log_type_enabled(v89, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
                    v314 = 1024;
                    *(_DWORD *)v315 = 1024;
                    _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
                  }
                }
                else
                {
                  if (uu[0])
                  {
                    v147 = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    v148 = objc_claimAutoreleasedReturnValue();
                    v149 = v311[0];
                    v150 = os_log_type_enabled(v148, (os_log_type_t)v311[0]);
                    if (v147)
                    {
                      if (v150)
                      {
                        *(_DWORD *)buf = 136446722;
                        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
                        v314 = 1024;
                        *(_DWORD *)v315 = 1024;
                        *(_WORD *)&v315[4] = 2082;
                        *(_QWORD *)&v315[6] = v147;
                        _os_log_impl(&dword_182FBE000, v148, v149, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", buf, 0x1Cu);
                      }

                      free(v147);
                    }
                    else
                    {
                      if (v150)
                      {
                        *(_DWORD *)buf = 136446466;
                        v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
                        v314 = 1024;
                        *(_DWORD *)v315 = 1024;
                        _os_log_impl(&dword_182FBE000, v148, v149, "%{public}s Custom data size must be no larger than %d, no backtrace", buf, 0x12u);
                      }

                    }
                    goto LABEL_439;
                  }
                  __nwlog_obj();
                  v89 = objc_claimAutoreleasedReturnValue();
                  v162 = v311[0];
                  if (os_log_type_enabled(v89, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136446466;
                    v313 = "nw_path_evaluator_add_endpoint_to_necp_message";
                    v314 = 1024;
                    *(_DWORD *)v315 = 1024;
                    _os_log_impl(&dword_182FBE000, v89, v162, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", buf, 0x12u);
                  }
                }

              }
LABEL_439:
              if (v88)
                free(v88);
              v138 = 8;
              goto LABEL_442;
            }
            v137 = -9;
            if (size < 0xF7)
              v137 = size;
            v138 = v137 + 8;
LABEL_442:
            *((_BYTE *)v43 + 1) = 0;
            *v43 = v138;
            *((_WORD *)v43 + 1) = 0;
            *((_DWORD *)v43 + 1) = v9;
            applier[0] = MEMORY[0x1E0C809B0];
            applier[1] = 3221225472;
            applier[2] = __nw_path_evaluator_add_endpoint_to_necp_message_block_invoke;
            applier[3] = &__block_descriptor_41_e47_B40__0__NSObject_OS_dispatch_data__8Q16r_v24Q32l;
            v302 = v138;
            applier[4] = v43;
            dispatch_data_apply(v85, applier);
LABEL_443:
            v223 = v52;
            v224 = v52 + 5;
            if (v296 - a3 >= v224)
            {
              *(_BYTE *)a3 = a2;
              *(_DWORD *)(a3 + 1) = v223;
              memcpy((void *)(a3 + 5), v43, v223);
              a3 += v224;
              goto LABEL_464;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v225 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v313 = "nw_necp_append_tlv";
            v314 = 2048;
            *(_QWORD *)v315 = a3;
            *(_WORD *)&v315[8] = 2048;
            *(_QWORD *)&v315[10] = v224;
            *(_WORD *)&v315[18] = 2048;
            *(_QWORD *)v316 = v296;
            *(_WORD *)&v316[8] = 1024;
            *(_DWORD *)v317 = a2;
            *(_WORD *)&v317[4] = 1024;
            v226 = v223;
            *(_DWORD *)&v317[6] = v223;
            LODWORD(v287) = 54;
            v286 = buf;
            v227 = (char *)_os_log_send_and_compose_impl();

            v311[0] = 16;
            uu[0] = 0;
            if (!__nwlog_fault(v227, v311, uu))
              goto LABEL_461;
            if (v311[0] == 17)
            {
              __nwlog_obj();
              v228 = objc_claimAutoreleasedReturnValue();
              v229 = v311[0];
              if (os_log_type_enabled(v228, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v224;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v226;
                _os_log_impl(&dword_182FBE000, v228, v229, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
LABEL_460:

              goto LABEL_461;
            }
            if (!uu[0])
            {
              __nwlog_obj();
              v228 = objc_claimAutoreleasedReturnValue();
              v233 = v311[0];
              if (os_log_type_enabled(v228, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v224;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v226;
                _os_log_impl(&dword_182FBE000, v228, v233, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
              goto LABEL_460;
            }
            v230 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v228 = objc_claimAutoreleasedReturnValue();
            v231 = v311[0];
            v232 = os_log_type_enabled(v228, (os_log_type_t)v311[0]);
            if (!v230)
            {
              if (v232)
              {
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v224;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = a2;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = v223;
                _os_log_impl(&dword_182FBE000, v228, v231, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
              }
              goto LABEL_460;
            }
            if (v232)
            {
              *(_DWORD *)buf = 136447746;
              v313 = "nw_necp_append_tlv";
              v314 = 2048;
              *(_QWORD *)v315 = a3;
              *(_WORD *)&v315[8] = 2048;
              *(_QWORD *)&v315[10] = v224;
              *(_WORD *)&v315[18] = 2048;
              *(_QWORD *)v316 = v296;
              *(_WORD *)&v316[8] = 1024;
              *(_DWORD *)v317 = a2;
              *(_WORD *)&v317[4] = 1024;
              *(_DWORD *)&v317[6] = v223;
              v318 = 2082;
              v319 = v230;
              _os_log_impl(&dword_182FBE000, v228, v231, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
            }

            free(v230);
LABEL_461:
            if (v227)
              free(v227);
            a3 = 0;
LABEL_464:

LABEL_279:
            if ((a5 & 1) == 0)
              goto LABEL_310;
            memset(uu, 0, sizeof(uu));
            uuid_clear(uu);
            nw_endpoint_get_agent_identifier(v10, uu);
            if (uuid_is_null(uu))
              goto LABEL_310;
            v152 = v10;
            if (a3)
            {
              if (a3 >= v296)
              {
                __nwlog_obj();
                v263 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 136446722;
                v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = v296;
                LODWORD(v287) = 32;
                v286 = buf;
                v154 = (char *)_os_log_send_and_compose_impl();

                v311[0] = 16;
                type = OS_LOG_TYPE_DEFAULT;
                if (!__nwlog_fault(v154, v311, &type))
                  goto LABEL_306;
                if (v311[0] == 17)
                {
                  __nwlog_obj();
                  v155 = objc_claimAutoreleasedReturnValue();
                  v264 = v311[0];
                  if (os_log_type_enabled(v155, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v296;
                    _os_log_impl(&dword_182FBE000, v155, v264, "%{public}s Invalid cursor %p >= beyond %p", buf, 0x20u);
                  }
                  goto LABEL_579;
                }
                if (type == OS_LOG_TYPE_DEFAULT)
                {
                  __nwlog_obj();
                  v155 = objc_claimAutoreleasedReturnValue();
                  v281 = v311[0];
                  if (os_log_type_enabled(v155, (os_log_type_t)v311[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v296;
                    _os_log_impl(&dword_182FBE000, v155, v281, "%{public}s Invalid cursor %p >= beyond %p, backtrace limit exceeded", buf, 0x20u);
                  }
                  goto LABEL_579;
                }
                v275 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v158 = objc_claimAutoreleasedReturnValue();
                v276 = v311[0];
                v277 = os_log_type_enabled(v158, (os_log_type_t)v311[0]);
                if (!v275)
                {
                  if (v277)
                  {
                    *(_DWORD *)buf = 136446722;
                    v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = v296;
                    _os_log_impl(&dword_182FBE000, v158, v276, "%{public}s Invalid cursor %p >= beyond %p, no backtrace", buf, 0x20u);
                  }
                  goto LABEL_305;
                }
                if (v277)
                {
                  *(_DWORD *)buf = 136446978;
                  v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                  v314 = 2048;
                  *(_QWORD *)v315 = a3;
                  *(_WORD *)&v315[8] = 2048;
                  *(_QWORD *)&v315[10] = v296;
                  *(_WORD *)&v315[18] = 2082;
                  *(_QWORD *)v316 = v275;
                  _os_log_impl(&dword_182FBE000, v158, v276, "%{public}s Invalid cursor %p >= beyond %p, dumping backtrace:%{public}s", buf, 0x2Au);
                }

                free(v275);
              }
              else
              {
                memset(v311, 0, sizeof(v311));
                uuid_clear(v311);
                nw_endpoint_get_agent_identifier(v152, v311);
                if (uuid_is_null(v311))
                  goto LABEL_309;
                if (v296 - a3 > 0x14)
                {
                  *(_BYTE *)a3 = -100;
                  *(_DWORD *)(a3 + 1) = 16;
                  *(_OWORD *)(a3 + 5) = *(_OWORD *)v311;
                  a3 += 21;
                  goto LABEL_309;
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v153 = (id)gLogObj;
                *(_DWORD *)buf = 136447490;
                v313 = "nw_necp_append_tlv";
                v314 = 2048;
                *(_QWORD *)v315 = a3;
                *(_WORD *)&v315[8] = 2048;
                *(_QWORD *)&v315[10] = 21;
                *(_WORD *)&v315[18] = 2048;
                *(_QWORD *)v316 = v296;
                *(_WORD *)&v316[8] = 1024;
                *(_DWORD *)v317 = 156;
                *(_WORD *)&v317[4] = 1024;
                *(_DWORD *)&v317[6] = 16;
                LODWORD(v287) = 54;
                v286 = buf;
                v154 = (char *)_os_log_send_and_compose_impl();

                type = OS_LOG_TYPE_ERROR;
                v307 = 0;
                if (__nwlog_fault(v154, &type, &v307))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    v155 = objc_claimAutoreleasedReturnValue();
                    v156 = type;
                    if (os_log_type_enabled(v155, type))
                    {
                      *(_DWORD *)buf = 136447490;
                      v313 = "nw_necp_append_tlv";
                      v314 = 2048;
                      *(_QWORD *)v315 = a3;
                      *(_WORD *)&v315[8] = 2048;
                      *(_QWORD *)&v315[10] = 21;
                      *(_WORD *)&v315[18] = 2048;
                      *(_QWORD *)v316 = v296;
                      *(_WORD *)&v316[8] = 1024;
                      *(_DWORD *)v317 = 156;
                      *(_WORD *)&v317[4] = 1024;
                      *(_DWORD *)&v317[6] = 16;
                      _os_log_impl(&dword_182FBE000, v155, v156, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                    }
LABEL_579:

                    goto LABEL_306;
                  }
                  if (!v307)
                  {
                    __nwlog_obj();
                    v155 = objc_claimAutoreleasedReturnValue();
                    v161 = type;
                    if (os_log_type_enabled(v155, type))
                    {
                      *(_DWORD *)buf = 136447490;
                      v313 = "nw_necp_append_tlv";
                      v314 = 2048;
                      *(_QWORD *)v315 = a3;
                      *(_WORD *)&v315[8] = 2048;
                      *(_QWORD *)&v315[10] = 21;
                      *(_WORD *)&v315[18] = 2048;
                      *(_QWORD *)v316 = v296;
                      *(_WORD *)&v316[8] = 1024;
                      *(_DWORD *)v317 = 156;
                      *(_WORD *)&v317[4] = 1024;
                      *(_DWORD *)&v317[6] = 16;
                      _os_log_impl(&dword_182FBE000, v155, v161, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                    }
                    goto LABEL_579;
                  }
                  v157 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v158 = objc_claimAutoreleasedReturnValue();
                  v159 = type;
                  v160 = os_log_type_enabled(v158, type);
                  if (v157)
                  {
                    if (v160)
                    {
                      *(_DWORD *)buf = 136447746;
                      v313 = "nw_necp_append_tlv";
                      v314 = 2048;
                      *(_QWORD *)v315 = a3;
                      *(_WORD *)&v315[8] = 2048;
                      *(_QWORD *)&v315[10] = 21;
                      *(_WORD *)&v315[18] = 2048;
                      *(_QWORD *)v316 = v296;
                      *(_WORD *)&v316[8] = 1024;
                      *(_DWORD *)v317 = 156;
                      *(_WORD *)&v317[4] = 1024;
                      *(_DWORD *)&v317[6] = 16;
                      v318 = 2082;
                      v319 = v157;
                      _os_log_impl(&dword_182FBE000, v158, v159, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                    }

                    free(v157);
                    if (!v154)
                    {
LABEL_308:
                      a3 = 0;
LABEL_309:

LABEL_310:
                      if ((a5 & 2) == 0)
                        goto LABEL_323;
                      device_id = (const char *)nw_endpoint_get_device_id(v10);
                      if (!device_id)
                        goto LABEL_323;
                      v164 = device_id;
                      v165 = strlen(device_id);
                      if (a3)
                      {
                        v166 = v165;
                        if (a3 < v296)
                        {
                          v167 = v165 + 5;
                          if (v296 - a3 < v167)
                          {
                            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                            networkd_settings_init();
                            v168 = (id)gLogObj;
                            *(_DWORD *)buf = 136447490;
                            v313 = "nw_necp_append_tlv";
                            v314 = 2048;
                            *(_QWORD *)v315 = a3;
                            *(_WORD *)&v315[8] = 2048;
                            *(_QWORD *)&v315[10] = v167;
                            *(_WORD *)&v315[18] = 2048;
                            *(_QWORD *)v316 = v296;
                            *(_WORD *)&v316[8] = 1024;
                            *(_DWORD *)v317 = 158;
                            *(_WORD *)&v317[4] = 1024;
                            *(_DWORD *)&v317[6] = v166;
                            LODWORD(v287) = 54;
                            v286 = buf;
                            v169 = (const char *)_os_log_send_and_compose_impl();

                            v311[0] = 16;
                            uu[0] = 0;
                            if (!__nwlog_fault(v169, v311, uu))
                              goto LABEL_431;
                            if (v311[0] == 17)
                            {
                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                              networkd_settings_init();
                              v170 = (id)gLogObj;
                              v171 = v311[0];
                              if (os_log_type_enabled(v170, (os_log_type_t)v311[0]))
                              {
                                *(_DWORD *)buf = 136447490;
                                v313 = "nw_necp_append_tlv";
                                v314 = 2048;
                                *(_QWORD *)v315 = a3;
                                *(_WORD *)&v315[8] = 2048;
                                *(_QWORD *)&v315[10] = v167;
                                *(_WORD *)&v315[18] = 2048;
                                *(_QWORD *)v316 = v296;
                                *(_WORD *)&v316[8] = 1024;
                                *(_DWORD *)v317 = 158;
                                *(_WORD *)&v317[4] = 1024;
                                *(_DWORD *)&v317[6] = v166;
                                _os_log_impl(&dword_182FBE000, v170, v171, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                              }
                            }
                            else if (uu[0])
                            {
                              v216 = __nw_create_backtrace_string();
                              if (v216)
                              {
                                v217 = (char *)v216;
                                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                networkd_settings_init();
                                v218 = (id)gLogObj;
                                v219 = v311[0];
                                if (os_log_type_enabled(v218, (os_log_type_t)v311[0]))
                                {
                                  *(_DWORD *)buf = 136447746;
                                  v313 = "nw_necp_append_tlv";
                                  v314 = 2048;
                                  *(_QWORD *)v315 = a3;
                                  *(_WORD *)&v315[8] = 2048;
                                  *(_QWORD *)&v315[10] = v167;
                                  *(_WORD *)&v315[18] = 2048;
                                  *(_QWORD *)v316 = v296;
                                  *(_WORD *)&v316[8] = 1024;
                                  *(_DWORD *)v317 = 158;
                                  *(_WORD *)&v317[4] = 1024;
                                  *(_DWORD *)&v317[6] = v166;
                                  v318 = 2082;
                                  v319 = v217;
                                  _os_log_impl(&dword_182FBE000, v218, v219, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                                }

                                free(v217);
                                if (!v169)
                                  goto LABEL_434;
LABEL_432:
                                v222 = (char *)v169;
LABEL_433:
                                free(v222);
                                goto LABEL_434;
                              }
                              __nwlog_obj();
                              v170 = objc_claimAutoreleasedReturnValue();
                              v221 = v311[0];
                              if (os_log_type_enabled(v170, (os_log_type_t)v311[0]))
                              {
                                *(_DWORD *)buf = 136447490;
                                v313 = "nw_necp_append_tlv";
                                v314 = 2048;
                                *(_QWORD *)v315 = a3;
                                *(_WORD *)&v315[8] = 2048;
                                *(_QWORD *)&v315[10] = v167;
                                *(_WORD *)&v315[18] = 2048;
                                *(_QWORD *)v316 = v296;
                                *(_WORD *)&v316[8] = 1024;
                                *(_DWORD *)v317 = 158;
                                *(_WORD *)&v317[4] = 1024;
                                *(_DWORD *)&v317[6] = v166;
                                _os_log_impl(&dword_182FBE000, v170, v221, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                              }
                            }
                            else
                            {
                              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                              networkd_settings_init();
                              v170 = (id)gLogObj;
                              v220 = v311[0];
                              if (os_log_type_enabled(v170, (os_log_type_t)v311[0]))
                              {
                                *(_DWORD *)buf = 136447490;
                                v313 = "nw_necp_append_tlv";
                                v314 = 2048;
                                *(_QWORD *)v315 = a3;
                                *(_WORD *)&v315[8] = 2048;
                                *(_QWORD *)&v315[10] = v167;
                                *(_WORD *)&v315[18] = 2048;
                                *(_QWORD *)v316 = v296;
                                *(_WORD *)&v316[8] = 1024;
                                *(_DWORD *)v317 = 158;
                                *(_WORD *)&v317[4] = 1024;
                                *(_DWORD *)&v317[6] = v166;
                                _os_log_impl(&dword_182FBE000, v170, v220, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                              }
                            }
                            goto LABEL_430;
                          }
                          *(_BYTE *)a3 = -98;
                          *(_DWORD *)(a3 + 1) = v165;
                          if (v165)
                            memcpy((void *)(a3 + 5), v164, v165);
                          a3 += v167;
LABEL_323:
                          if ((a5 & 4) == 0)
                            goto LABEL_415;
                          goto LABEL_324;
                        }
                        __nwlog_obj();
                        v256 = (void *)objc_claimAutoreleasedReturnValue();
                        *(_DWORD *)buf = 136447234;
                        v313 = "nw_necp_append_tlv";
                        v314 = 2048;
                        *(_QWORD *)v315 = a3;
                        *(_WORD *)&v315[8] = 2048;
                        *(_QWORD *)&v315[10] = v296;
                        *(_WORD *)&v315[18] = 1024;
                        *(_DWORD *)v316 = 158;
                        *(_WORD *)&v316[4] = 1024;
                        *(_DWORD *)&v316[6] = v166;
                        LODWORD(v287) = 44;
                        v286 = buf;
                        v169 = (const char *)_os_log_send_and_compose_impl();

                        v311[0] = 16;
                        uu[0] = 0;
                        if (__nwlog_fault(v169, v311, uu))
                        {
                          if (v311[0] == 17)
                          {
                            __nwlog_obj();
                            v170 = objc_claimAutoreleasedReturnValue();
                            v257 = v311[0];
                            if (os_log_type_enabled(v170, (os_log_type_t)v311[0]))
                            {
                              *(_DWORD *)buf = 136447234;
                              v313 = "nw_necp_append_tlv";
                              v314 = 2048;
                              *(_QWORD *)v315 = a3;
                              *(_WORD *)&v315[8] = 2048;
                              *(_QWORD *)&v315[10] = v296;
                              *(_WORD *)&v315[18] = 1024;
                              *(_DWORD *)v316 = 158;
                              *(_WORD *)&v316[4] = 1024;
                              *(_DWORD *)&v316[6] = v166;
                              _os_log_impl(&dword_182FBE000, v170, v257, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                            }
LABEL_430:

                            goto LABEL_431;
                          }
                          if (!uu[0])
                          {
                            __nwlog_obj();
                            v170 = objc_claimAutoreleasedReturnValue();
                            v279 = v311[0];
                            if (os_log_type_enabled(v170, (os_log_type_t)v311[0]))
                            {
                              *(_DWORD *)buf = 136447234;
                              v313 = "nw_necp_append_tlv";
                              v314 = 2048;
                              *(_QWORD *)v315 = a3;
                              *(_WORD *)&v315[8] = 2048;
                              *(_QWORD *)&v315[10] = v296;
                              *(_WORD *)&v315[18] = 1024;
                              *(_DWORD *)v316 = 158;
                              *(_WORD *)&v316[4] = 1024;
                              *(_DWORD *)&v316[6] = v166;
                              _os_log_impl(&dword_182FBE000, v170, v279, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                            }
                            goto LABEL_430;
                          }
                          v268 = (char *)__nw_create_backtrace_string();
                          __nwlog_obj();
                          v269 = objc_claimAutoreleasedReturnValue();
                          v270 = v311[0];
                          v271 = os_log_type_enabled(v269, (os_log_type_t)v311[0]);
                          if (v268)
                          {
                            if (v271)
                            {
                              *(_DWORD *)buf = 136447490;
                              v313 = "nw_necp_append_tlv";
                              v314 = 2048;
                              *(_QWORD *)v315 = a3;
                              *(_WORD *)&v315[8] = 2048;
                              *(_QWORD *)&v315[10] = v296;
                              *(_WORD *)&v315[18] = 1024;
                              *(_DWORD *)v316 = 158;
                              *(_WORD *)&v316[4] = 1024;
                              *(_DWORD *)&v316[6] = v166;
                              *(_WORD *)v317 = 2082;
                              *(_QWORD *)&v317[2] = v268;
                              _os_log_impl(&dword_182FBE000, v269, v270, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                            }

                            free(v268);
                          }
                          else
                          {
                            if (v271)
                            {
                              *(_DWORD *)buf = 136447234;
                              v313 = "nw_necp_append_tlv";
                              v314 = 2048;
                              *(_QWORD *)v315 = a3;
                              *(_WORD *)&v315[8] = 2048;
                              *(_QWORD *)&v315[10] = v296;
                              *(_WORD *)&v315[18] = 1024;
                              *(_DWORD *)v316 = 158;
                              *(_WORD *)&v316[4] = 1024;
                              *(_DWORD *)&v316[6] = v166;
                              _os_log_impl(&dword_182FBE000, v269, v270, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                            }

                          }
                        }
LABEL_431:
                        if (!v169)
                        {
LABEL_434:
                          a3 = 0;
                          if ((a5 & 4) != 0)
                          {
LABEL_324:
                            v299 = 0u;
                            v300 = 0u;
                            v297 = 0u;
                            v298 = 0u;
                            v172 = nw_endpoint_copy_public_keys(v10);
                            obja = v172;
                            v173 = objc_msgSend(v172, "countByEnumeratingWithState:objects:count:", &v297, v309, 16);
                            if (!v173)
                              goto LABEL_414;
                            v295 = *(_QWORD *)v298;
                            while (1)
                            {
                              for (i = 0; i != v173; ++i)
                              {
                                if (*(_QWORD *)v298 != v295)
                                  objc_enumerationMutation(obja);
                                v176 = *(void **)(*((_QWORD *)&v297 + 1) + 8 * i);
                                v177 = objc_msgSend(v176, "length", v286, v287);
                                v178 = (const void *)objc_msgSend(v176, "bytes");
                                if (!a3)
                                {
                                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                  networkd_settings_init();
                                  v188 = (id)gLogObj;
                                  *(_DWORD *)buf = 136446210;
                                  v313 = "nw_necp_append_tlv";
                                  LODWORD(v287) = 12;
                                  v286 = buf;
                                  v189 = (const char *)_os_log_send_and_compose_impl();

                                  v311[0] = 16;
                                  uu[0] = 0;
                                  if (__nwlog_fault(v189, v311, uu))
                                  {
                                    if (v311[0] == 17)
                                    {
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v190 = (id)gLogObj;
                                      v191 = v311[0];
                                      if (os_log_type_enabled(v190, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136446210;
                                        v313 = "nw_necp_append_tlv";
                                        _os_log_impl(&dword_182FBE000, v190, v191, "%{public}s called with null tlv_start", buf, 0xCu);
                                      }
                                      goto LABEL_399;
                                    }
                                    if (uu[0])
                                    {
                                      v196 = __nw_create_backtrace_string();
                                      if (v196)
                                      {
                                        v197 = (char *)v196;
                                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                        networkd_settings_init();
                                        v198 = (id)gLogObj;
                                        v199 = v311[0];
                                        if (os_log_type_enabled(v198, (os_log_type_t)v311[0]))
                                        {
                                          *(_DWORD *)buf = 136446466;
                                          v313 = "nw_necp_append_tlv";
                                          v314 = 2082;
                                          *(_QWORD *)v315 = v197;
                                          _os_log_impl(&dword_182FBE000, v198, v199, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                                        }

                                        free(v197);
                                        if (!v189)
                                          goto LABEL_329;
LABEL_401:
                                        v175 = (char *)v189;
LABEL_328:
                                        free(v175);
LABEL_329:
                                        a3 = 0;
                                        continue;
                                      }
                                      __nwlog_obj();
                                      v190 = objc_claimAutoreleasedReturnValue();
                                      v211 = v311[0];
                                      if (os_log_type_enabled(v190, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136446210;
                                        v313 = "nw_necp_append_tlv";
                                        _os_log_impl(&dword_182FBE000, v190, v211, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                                      }
                                    }
                                    else
                                    {
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v190 = (id)gLogObj;
                                      v206 = v311[0];
                                      if (os_log_type_enabled(v190, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136446210;
                                        v313 = "nw_necp_append_tlv";
                                        _os_log_impl(&dword_182FBE000, v190, v206, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                                      }
                                    }
LABEL_399:

                                  }
                                  if (v189)
                                    goto LABEL_401;
                                  goto LABEL_329;
                                }
                                if (a3 >= v296)
                                {
                                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                  networkd_settings_init();
                                  v192 = (id)gLogObj;
                                  *(_DWORD *)buf = 136447234;
                                  v313 = "nw_necp_append_tlv";
                                  v314 = 2048;
                                  *(_QWORD *)v315 = a3;
                                  *(_WORD *)&v315[8] = 2048;
                                  *(_QWORD *)&v315[10] = v296;
                                  *(_WORD *)&v315[18] = 1024;
                                  *(_DWORD *)v316 = 159;
                                  *(_WORD *)&v316[4] = 1024;
                                  *(_DWORD *)&v316[6] = v177;
                                  LODWORD(v287) = 44;
                                  v286 = buf;
                                  v193 = (const char *)_os_log_send_and_compose_impl();

                                  v311[0] = 16;
                                  uu[0] = 0;
                                  if (__nwlog_fault(v193, v311, uu))
                                  {
                                    if (v311[0] == 17)
                                    {
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v194 = (id)gLogObj;
                                      v195 = v311[0];
                                      if (os_log_type_enabled(v194, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136447234;
                                        v313 = "nw_necp_append_tlv";
                                        v314 = 2048;
                                        *(_QWORD *)v315 = a3;
                                        *(_WORD *)&v315[8] = 2048;
                                        *(_QWORD *)&v315[10] = v296;
                                        *(_WORD *)&v315[18] = 1024;
                                        *(_DWORD *)v316 = 159;
                                        *(_WORD *)&v316[4] = 1024;
                                        *(_DWORD *)&v316[6] = v177;
                                        _os_log_impl(&dword_182FBE000, v194, v195, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                                      }
                                      goto LABEL_404;
                                    }
                                    if (uu[0])
                                    {
                                      v200 = __nw_create_backtrace_string();
                                      if (v200)
                                      {
                                        v201 = (char *)v200;
                                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                        networkd_settings_init();
                                        v202 = (id)gLogObj;
                                        v203 = v311[0];
                                        if (os_log_type_enabled(v202, (os_log_type_t)v311[0]))
                                        {
                                          *(_DWORD *)buf = 136447490;
                                          v313 = "nw_necp_append_tlv";
                                          v314 = 2048;
                                          *(_QWORD *)v315 = a3;
                                          *(_WORD *)&v315[8] = 2048;
                                          *(_QWORD *)&v315[10] = v296;
                                          *(_WORD *)&v315[18] = 1024;
                                          *(_DWORD *)v316 = 159;
                                          *(_WORD *)&v316[4] = 1024;
                                          *(_DWORD *)&v316[6] = v177;
                                          *(_WORD *)v317 = 2082;
                                          *(_QWORD *)&v317[2] = v201;
                                          _os_log_impl(&dword_182FBE000, v202, v203, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
                                        }

                                        free(v201);
                                        if (!v193)
                                          goto LABEL_329;
                                        goto LABEL_406;
                                      }
                                      __nwlog_obj();
                                      v194 = objc_claimAutoreleasedReturnValue();
                                      v212 = v311[0];
                                      if (os_log_type_enabled(v194, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136447234;
                                        v313 = "nw_necp_append_tlv";
                                        v314 = 2048;
                                        *(_QWORD *)v315 = a3;
                                        *(_WORD *)&v315[8] = 2048;
                                        *(_QWORD *)&v315[10] = v296;
                                        *(_WORD *)&v315[18] = 1024;
                                        *(_DWORD *)v316 = 159;
                                        *(_WORD *)&v316[4] = 1024;
                                        *(_DWORD *)&v316[6] = v177;
                                        _os_log_impl(&dword_182FBE000, v194, v212, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                                      }
                                    }
                                    else
                                    {
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v194 = (id)gLogObj;
                                      v207 = v311[0];
                                      if (os_log_type_enabled(v194, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136447234;
                                        v313 = "nw_necp_append_tlv";
                                        v314 = 2048;
                                        *(_QWORD *)v315 = a3;
                                        *(_WORD *)&v315[8] = 2048;
                                        *(_QWORD *)&v315[10] = v296;
                                        *(_WORD *)&v315[18] = 1024;
                                        *(_DWORD *)v316 = 159;
                                        *(_WORD *)&v316[4] = 1024;
                                        *(_DWORD *)&v316[6] = v177;
                                        _os_log_impl(&dword_182FBE000, v194, v207, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                                      }
                                    }
LABEL_404:

                                  }
                                  if (!v193)
                                    goto LABEL_329;
LABEL_406:
                                  v175 = (char *)v193;
                                  goto LABEL_328;
                                }
                                v179 = v177 + 5;
                                if (v296 - a3 < v179)
                                {
                                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                  networkd_settings_init();
                                  v180 = (id)gLogObj;
                                  *(_DWORD *)buf = 136447490;
                                  v313 = "nw_necp_append_tlv";
                                  v314 = 2048;
                                  *(_QWORD *)v315 = a3;
                                  *(_WORD *)&v315[8] = 2048;
                                  *(_QWORD *)&v315[10] = v177 + 5;
                                  *(_WORD *)&v315[18] = 2048;
                                  *(_QWORD *)v316 = v296;
                                  *(_WORD *)&v316[8] = 1024;
                                  *(_DWORD *)v317 = 159;
                                  *(_WORD *)&v317[4] = 1024;
                                  *(_DWORD *)&v317[6] = v177;
                                  LODWORD(v287) = 54;
                                  v286 = buf;
                                  v181 = (const char *)_os_log_send_and_compose_impl();

                                  v311[0] = 16;
                                  uu[0] = 0;
                                  if (__nwlog_fault(v181, v311, uu))
                                  {
                                    if (v311[0] == 17)
                                    {
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v182 = (id)gLogObj;
                                      v183 = v311[0];
                                      if (os_log_type_enabled(v182, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136447490;
                                        v313 = "nw_necp_append_tlv";
                                        v314 = 2048;
                                        *(_QWORD *)v315 = a3;
                                        *(_WORD *)&v315[8] = 2048;
                                        *(_QWORD *)&v315[10] = v177 + 5;
                                        *(_WORD *)&v315[18] = 2048;
                                        *(_QWORD *)v316 = v296;
                                        *(_WORD *)&v316[8] = 1024;
                                        *(_DWORD *)v317 = 159;
                                        *(_WORD *)&v317[4] = 1024;
                                        *(_DWORD *)&v317[6] = v177;
                                        _os_log_impl(&dword_182FBE000, v182, v183, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                                      }
                                      goto LABEL_356;
                                    }
                                    if (uu[0])
                                    {
                                      v184 = (char *)__nw_create_backtrace_string();
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v182 = (id)gLogObj;
                                      v185 = v311[0];
                                      v186 = os_log_type_enabled(v182, (os_log_type_t)v311[0]);
                                      if (v184)
                                      {
                                        if (v186)
                                        {
                                          *(_DWORD *)buf = 136447746;
                                          v313 = "nw_necp_append_tlv";
                                          v314 = 2048;
                                          *(_QWORD *)v315 = a3;
                                          *(_WORD *)&v315[8] = 2048;
                                          *(_QWORD *)&v315[10] = v177 + 5;
                                          *(_WORD *)&v315[18] = 2048;
                                          *(_QWORD *)v316 = v296;
                                          *(_WORD *)&v316[8] = 1024;
                                          *(_DWORD *)v317 = 159;
                                          *(_WORD *)&v317[4] = 1024;
                                          *(_DWORD *)&v317[6] = v177;
                                          v318 = 2082;
                                          v319 = v184;
                                          _os_log_impl(&dword_182FBE000, v182, v185, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                                        }

                                        free(v184);
                                        if (!v181)
                                          goto LABEL_329;
                                        goto LABEL_327;
                                      }
                                      if (v186)
                                      {
                                        *(_DWORD *)buf = 136447490;
                                        v313 = "nw_necp_append_tlv";
                                        v314 = 2048;
                                        *(_QWORD *)v315 = a3;
                                        *(_WORD *)&v315[8] = 2048;
                                        *(_QWORD *)&v315[10] = v177 + 5;
                                        *(_WORD *)&v315[18] = 2048;
                                        *(_QWORD *)v316 = v296;
                                        *(_WORD *)&v316[8] = 1024;
                                        *(_DWORD *)v317 = 159;
                                        *(_WORD *)&v317[4] = 1024;
                                        *(_DWORD *)&v317[6] = v177;
                                        _os_log_impl(&dword_182FBE000, v182, v185, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                                      }
                                    }
                                    else
                                    {
                                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                      networkd_settings_init();
                                      v182 = (id)gLogObj;
                                      v187 = v311[0];
                                      if (os_log_type_enabled(v182, (os_log_type_t)v311[0]))
                                      {
                                        *(_DWORD *)buf = 136447490;
                                        v313 = "nw_necp_append_tlv";
                                        v314 = 2048;
                                        *(_QWORD *)v315 = a3;
                                        *(_WORD *)&v315[8] = 2048;
                                        *(_QWORD *)&v315[10] = v177 + 5;
                                        *(_WORD *)&v315[18] = 2048;
                                        *(_QWORD *)v316 = v296;
                                        *(_WORD *)&v316[8] = 1024;
                                        *(_DWORD *)v317 = 159;
                                        *(_WORD *)&v317[4] = 1024;
                                        *(_DWORD *)&v317[6] = v177;
                                        _os_log_impl(&dword_182FBE000, v182, v187, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                                      }
                                    }
LABEL_356:

                                  }
                                  goto LABEL_357;
                                }
                                *(_BYTE *)a3 = -97;
                                *(_DWORD *)(a3 + 1) = v177;
                                if (v177)
                                {
                                  if (!v178)
                                  {
                                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                    networkd_settings_init();
                                    v204 = (id)gLogObj;
                                    *(_DWORD *)buf = 136446722;
                                    v313 = "nw_necp_append_tlv";
                                    v314 = 1024;
                                    *(_DWORD *)v315 = 159;
                                    *(_WORD *)&v315[4] = 1024;
                                    *(_DWORD *)&v315[6] = v177;
                                    LODWORD(v287) = 24;
                                    v286 = buf;
                                    v181 = (const char *)_os_log_send_and_compose_impl();

                                    v311[0] = 16;
                                    uu[0] = 0;
                                    if (__nwlog_fault(v181, v311, uu))
                                    {
                                      if (v311[0] == 17)
                                      {
                                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                        networkd_settings_init();
                                        v182 = (id)gLogObj;
                                        v205 = v311[0];
                                        if (os_log_type_enabled(v182, (os_log_type_t)v311[0]))
                                        {
                                          *(_DWORD *)buf = 136446722;
                                          v313 = "nw_necp_append_tlv";
                                          v314 = 1024;
                                          *(_DWORD *)v315 = 159;
                                          *(_WORD *)&v315[4] = 1024;
                                          *(_DWORD *)&v315[6] = v177;
                                          _os_log_impl(&dword_182FBE000, v182, v205, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
                                        }
                                        goto LABEL_356;
                                      }
                                      if (!uu[0])
                                      {
                                        __nwlog_obj();
                                        v182 = objc_claimAutoreleasedReturnValue();
                                        v213 = v311[0];
                                        if (os_log_type_enabled(v182, (os_log_type_t)v311[0]))
                                        {
                                          *(_DWORD *)buf = 136446722;
                                          v313 = "nw_necp_append_tlv";
                                          v314 = 1024;
                                          *(_DWORD *)v315 = 159;
                                          *(_WORD *)&v315[4] = 1024;
                                          *(_DWORD *)&v315[6] = v177;
                                          _os_log_impl(&dword_182FBE000, v182, v213, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
                                        }
                                        goto LABEL_356;
                                      }
                                      v208 = (char *)__nw_create_backtrace_string();
                                      __nwlog_obj();
                                      v182 = objc_claimAutoreleasedReturnValue();
                                      v209 = v311[0];
                                      v210 = os_log_type_enabled(v182, (os_log_type_t)v311[0]);
                                      if (!v208)
                                      {
                                        if (v210)
                                        {
                                          *(_DWORD *)buf = 136446722;
                                          v313 = "nw_necp_append_tlv";
                                          v314 = 1024;
                                          *(_DWORD *)v315 = 159;
                                          *(_WORD *)&v315[4] = 1024;
                                          *(_DWORD *)&v315[6] = v177;
                                          _os_log_impl(&dword_182FBE000, v182, v209, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
                                        }
                                        goto LABEL_356;
                                      }
                                      if (v210)
                                      {
                                        *(_DWORD *)buf = 136446978;
                                        v313 = "nw_necp_append_tlv";
                                        v314 = 1024;
                                        *(_DWORD *)v315 = 159;
                                        *(_WORD *)&v315[4] = 1024;
                                        *(_DWORD *)&v315[6] = v177;
                                        *(_WORD *)&v315[10] = 2082;
                                        *(_QWORD *)&v315[12] = v208;
                                        _os_log_impl(&dword_182FBE000, v182, v209, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
                                      }

                                      free(v208);
                                    }
LABEL_357:
                                    if (!v181)
                                      goto LABEL_329;
LABEL_327:
                                    v175 = (char *)v181;
                                    goto LABEL_328;
                                  }
                                  memcpy((void *)(a3 + 5), v178, v177);
                                }
                                a3 += v179;
                              }
                              v172 = obja;
                              v173 = objc_msgSend(obja, "countByEnumeratingWithState:objects:count:", &v297, v309, 16);
                              if (!v173)
                              {
LABEL_414:

                                break;
                              }
                            }
                          }
LABEL_415:
                          if (v288)
                            free(v288);

                          v214 = v289;
                          goto LABEL_418;
                        }
                        goto LABEL_432;
                      }
                      __nwlog_obj();
                      v252 = (void *)objc_claimAutoreleasedReturnValue();
                      *(_DWORD *)buf = 136446210;
                      v313 = "nw_necp_append_tlv";
                      LODWORD(v287) = 12;
                      v286 = buf;
                      v253 = (const char *)_os_log_send_and_compose_impl();

                      v311[0] = 16;
                      uu[0] = 0;
                      if (__nwlog_fault(v253, v311, uu))
                      {
                        if (v311[0] == 17)
                        {
                          __nwlog_obj();
                          v254 = objc_claimAutoreleasedReturnValue();
                          v255 = v311[0];
                          if (os_log_type_enabled(v254, (os_log_type_t)v311[0]))
                          {
                            *(_DWORD *)buf = 136446210;
                            v313 = "nw_necp_append_tlv";
                            _os_log_impl(&dword_182FBE000, v254, v255, "%{public}s called with null tlv_start", buf, 0xCu);
                          }
                        }
                        else if (uu[0])
                        {
                          v265 = (char *)__nw_create_backtrace_string();
                          __nwlog_obj();
                          v254 = objc_claimAutoreleasedReturnValue();
                          v266 = v311[0];
                          v267 = os_log_type_enabled(v254, (os_log_type_t)v311[0]);
                          if (v265)
                          {
                            if (v267)
                            {
                              *(_DWORD *)buf = 136446466;
                              v313 = "nw_necp_append_tlv";
                              v314 = 2082;
                              *(_QWORD *)v315 = v265;
                              _os_log_impl(&dword_182FBE000, v254, v266, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
                            }

                            free(v265);
                            goto LABEL_569;
                          }
                          if (v267)
                          {
                            *(_DWORD *)buf = 136446210;
                            v313 = "nw_necp_append_tlv";
                            _os_log_impl(&dword_182FBE000, v254, v266, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
                          }
                        }
                        else
                        {
                          __nwlog_obj();
                          v254 = objc_claimAutoreleasedReturnValue();
                          v278 = v311[0];
                          if (os_log_type_enabled(v254, (os_log_type_t)v311[0]))
                          {
                            *(_DWORD *)buf = 136446210;
                            v313 = "nw_necp_append_tlv";
                            _os_log_impl(&dword_182FBE000, v254, v278, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
                          }
                        }

                      }
LABEL_569:
                      if (!v253)
                        goto LABEL_434;
                      v222 = (char *)v253;
                      goto LABEL_433;
                    }
LABEL_307:
                    free(v154);
                    goto LABEL_308;
                  }
                  if (v160)
                  {
                    *(_DWORD *)buf = 136447490;
                    v313 = "nw_necp_append_tlv";
                    v314 = 2048;
                    *(_QWORD *)v315 = a3;
                    *(_WORD *)&v315[8] = 2048;
                    *(_QWORD *)&v315[10] = 21;
                    *(_WORD *)&v315[18] = 2048;
                    *(_QWORD *)v316 = v296;
                    *(_WORD *)&v316[8] = 1024;
                    *(_DWORD *)v317 = 156;
                    *(_WORD *)&v317[4] = 1024;
                    *(_DWORD *)&v317[6] = 16;
                    _os_log_impl(&dword_182FBE000, v158, v159, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                  }
                  goto LABEL_305;
                }
              }
LABEL_306:
              if (!v154)
                goto LABEL_308;
              goto LABEL_307;
            }
            __nwlog_obj();
            v261 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
            LODWORD(v287) = 12;
            v286 = buf;
            v154 = (char *)_os_log_send_and_compose_impl();

            v311[0] = 16;
            type = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v154, v311, &type))
              goto LABEL_306;
            if (v311[0] == 17)
            {
              __nwlog_obj();
              v155 = objc_claimAutoreleasedReturnValue();
              v262 = v311[0];
              if (os_log_type_enabled(v155, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136446210;
                v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                _os_log_impl(&dword_182FBE000, v155, v262, "%{public}s called with null cursor", buf, 0xCu);
              }
              goto LABEL_579;
            }
            if (type == OS_LOG_TYPE_DEFAULT)
            {
              __nwlog_obj();
              v155 = objc_claimAutoreleasedReturnValue();
              v280 = v311[0];
              if (os_log_type_enabled(v155, (os_log_type_t)v311[0]))
              {
                *(_DWORD *)buf = 136446210;
                v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                _os_log_impl(&dword_182FBE000, v155, v280, "%{public}s called with null cursor, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_579;
            }
            v272 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v158 = objc_claimAutoreleasedReturnValue();
            v273 = v311[0];
            v274 = os_log_type_enabled(v158, (os_log_type_t)v311[0]);
            if (v272)
            {
              if (v274)
              {
                *(_DWORD *)buf = 136446466;
                v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
                v314 = 2082;
                *(_QWORD *)v315 = v272;
                _os_log_impl(&dword_182FBE000, v158, v273, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v272);
              if (!v154)
                goto LABEL_308;
              goto LABEL_307;
            }
            if (v274)
            {
              *(_DWORD *)buf = 136446210;
              v313 = "nw_path_add_endpoint_agent_uuid_to_necp_message";
              _os_log_impl(&dword_182FBE000, v158, v273, "%{public}s called with null cursor, no backtrace", buf, 0xCu);
            }
LABEL_305:

            goto LABEL_306;
        }
      }
      __break(1u);
      return result;
  }
}

void sub_183166BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24)
{

  _Unwind_Resume(a1);
}

_BYTE *nw_endpoint_get_ethernet_address(void *a1)
{
  id v1;
  void *v2;
  id v3;
  int v4;
  _BYTE *v5;
  _BYTE *v6;
  id v7;
  id v8;
  int v9;
  const char *v10;
  NSObject *v11;
  os_log_type_t v12;
  id v13;
  int v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  id v18;
  int v19;
  os_log_type_t v20;
  id v21;
  int v22;
  id v23;
  int v24;
  char *v25;
  void *v27;
  const char *v28;
  NSObject *v29;
  os_log_type_t v30;
  char *backtrace_string;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  uint64_t v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  _WORD v41[17];

  *(_QWORD *)&v41[13] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_endpoint_get_ethernet_address";
    v28 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v28, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_endpoint_get_ethernet_address";
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        v33 = os_log_type_enabled(v29, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_endpoint_get_ethernet_address";
            v40 = 2082;
            *(_QWORD *)v41 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_endpoint_get_ethernet_address";
          _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v29 = objc_claimAutoreleasedReturnValue();
        v34 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_endpoint_get_ethernet_address";
          _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_49:
    if (!v28)
      goto LABEL_31;
    v25 = (char *)v28;
    goto LABEL_30;
  }
  v3 = v1;
  v4 = objc_msgSend(v3, "type");

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = v3;
    v9 = objc_msgSend(v8, "type");

    *(_DWORD *)buf = 136446466;
    v39 = "nw_endpoint_get_ethernet_address";
    v40 = 1024;
    *(_DWORD *)v41 = v9;
    LODWORD(v35) = 18;
    v10 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v10, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          v13 = v8;
          v14 = objc_msgSend(v13, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v39 = "nw_endpoint_get_ethernet_address";
          v40 = 1024;
          *(_DWORD *)v41 = v14;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v36)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v16 = type;
        v17 = os_log_type_enabled(v11, type);
        if (v15)
        {
          if (v17)
          {
            v18 = v8;
            v19 = objc_msgSend(v18, "type", buf, v35);

            *(_DWORD *)buf = 136446722;
            v39 = "nw_endpoint_get_ethernet_address";
            v40 = 1024;
            *(_DWORD *)v41 = v19;
            v41[2] = 2082;
            *(_QWORD *)&v41[3] = v15;
            _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v15);
          if (!v10)
            goto LABEL_31;
LABEL_29:
          v25 = (char *)v10;
LABEL_30:
          free(v25);
          goto LABEL_31;
        }
        if (v17)
        {
          v23 = v8;
          v24 = objc_msgSend(v23, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v39 = "nw_endpoint_get_ethernet_address";
          v40 = 1024;
          *(_DWORD *)v41 = v24;
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          v21 = v8;
          v22 = objc_msgSend(v21, "type", buf, v35);

          *(_DWORD *)buf = 136446466;
          v39 = "nw_endpoint_get_ethernet_address";
          v40 = 1024;
          *(_DWORD *)v41 = v22;
          _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
    if (!v10)
    {
LABEL_31:
      v6 = 0;
      goto LABEL_32;
    }
    goto LABEL_29;
  }
  v5 = v3;
  v6 = v5 + 360;
  if (!v5[360] && !v5[361] && !v5[362] && !v5[363] && !v5[364] && !v5[365])
    v6 = 0;

LABEL_32:
  return v6;
}

void sub_183167294(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t __nw_path_create_necp_parameters_block_invoke_3(uint64_t a1, _OWORD *a2)
{
  unint64_t v3;
  unint64_t v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  unint64_t v10;
  char *backtrace_string;
  _BOOL4 v12;
  const char *v13;
  NSObject *v14;
  os_log_type_t v15;
  uint32_t v16;
  void *v18;
  os_log_type_t v19;
  const char *v20;
  void *v21;
  void *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  _BOOL4 v25;
  void *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  _BOOL4 v29;
  NSObject *v30;
  os_log_type_t v31;
  uint32_t v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  _BYTE v38[10];
  _BYTE v39[10];
  _BYTE v40[10];
  _BYTE v41[10];
  __int16 v42;
  char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (!v3)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_necp_append_tlv";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v6, &type, &v33))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_necp_append_tlv";
      v20 = "%{public}s called with null tlv_start";
      goto LABEL_71;
    }
    if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v24 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v24)
          goto LABEL_16;
        *(_DWORD *)buf = 136446466;
        v36 = "nw_necp_append_tlv";
        v37 = 2082;
        *(_QWORD *)v38 = backtrace_string;
        v13 = "%{public}s called with null tlv_start, dumping backtrace:%{public}s";
        goto LABEL_48;
      }
      if (!v24)
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_necp_append_tlv";
      v20 = "%{public}s called with null tlv_start, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_necp_append_tlv";
      v20 = "%{public}s called with null tlv_start, backtrace limit exceeded";
    }
LABEL_71:
    v30 = v7;
    v31 = v19;
    v32 = 12;
    goto LABEL_80;
  }
  v4 = *(_QWORD *)(a1 + 40);
  if (!v4)
  {
    __nwlog_obj();
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_necp_append_tlv";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v6, &type, &v33))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_necp_append_tlv";
      v20 = "%{public}s called with null beyond";
      goto LABEL_71;
    }
    if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v25 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v25)
          goto LABEL_16;
        *(_DWORD *)buf = 136446466;
        v36 = "nw_necp_append_tlv";
        v37 = 2082;
        *(_QWORD *)v38 = backtrace_string;
        v13 = "%{public}s called with null beyond, dumping backtrace:%{public}s";
LABEL_48:
        v14 = v7;
        v15 = v19;
        v16 = 22;
LABEL_15:
        _os_log_impl(&dword_182FBE000, v14, v15, v13, buf, v16);
LABEL_16:

        free(backtrace_string);
        goto LABEL_17;
      }
      if (!v25)
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_necp_append_tlv";
      v20 = "%{public}s called with null beyond, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_necp_append_tlv";
      v20 = "%{public}s called with null beyond, backtrace limit exceeded";
    }
    goto LABEL_71;
  }
  if (v3 >= v4)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v36 = "nw_necp_append_tlv";
    v37 = 2048;
    *(_QWORD *)v38 = v3;
    *(_WORD *)&v38[8] = 2048;
    *(_QWORD *)v39 = v4;
    *(_WORD *)&v39[8] = 1024;
    *(_DWORD *)v40 = 150;
    *(_WORD *)&v40[4] = 1024;
    *(_DWORD *)&v40[6] = 16;
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v6, &type, &v33))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136447234;
      v36 = "nw_necp_append_tlv";
      v37 = 2048;
      *(_QWORD *)v38 = v3;
      *(_WORD *)&v38[8] = 2048;
      *(_QWORD *)v39 = v4;
      *(_WORD *)&v39[8] = 1024;
      *(_DWORD *)v40 = 150;
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = 16;
      v20 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v28 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (!v28)
          goto LABEL_16;
        *(_DWORD *)buf = 136447490;
        v36 = "nw_necp_append_tlv";
        v37 = 2048;
        *(_QWORD *)v38 = v3;
        *(_WORD *)&v38[8] = 2048;
        *(_QWORD *)v39 = v4;
        *(_WORD *)&v39[8] = 1024;
        *(_DWORD *)v40 = 150;
        *(_WORD *)&v40[4] = 1024;
        *(_DWORD *)&v40[6] = 16;
        *(_WORD *)v41 = 2082;
        *(_QWORD *)&v41[2] = backtrace_string;
        v13 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s";
        v14 = v7;
        v15 = v23;
        v16 = 54;
        goto LABEL_15;
      }
      if (!v28)
        goto LABEL_81;
      *(_DWORD *)buf = 136447234;
      v36 = "nw_necp_append_tlv";
      v37 = 2048;
      *(_QWORD *)v38 = v3;
      *(_WORD *)&v38[8] = 2048;
      *(_QWORD *)v39 = v4;
      *(_WORD *)&v39[8] = 1024;
      *(_DWORD *)v40 = 150;
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = 16;
      v20 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136447234;
      v36 = "nw_necp_append_tlv";
      v37 = 2048;
      *(_QWORD *)v38 = v3;
      *(_WORD *)&v38[8] = 2048;
      *(_QWORD *)v39 = v4;
      *(_WORD *)&v39[8] = 1024;
      *(_DWORD *)v40 = 150;
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = 16;
      v20 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }
    v30 = v7;
    v31 = v23;
    v32 = 44;
LABEL_80:
    _os_log_impl(&dword_182FBE000, v30, v31, v20, buf, v32);
    goto LABEL_81;
  }
  if (v4 - v3 <= 0x14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    v36 = "nw_necp_append_tlv";
    v37 = 2048;
    *(_QWORD *)v38 = v3;
    *(_WORD *)&v38[8] = 2048;
    *(_QWORD *)v39 = 21;
    *(_WORD *)&v39[8] = 2048;
    *(_QWORD *)v40 = v4;
    *(_WORD *)&v40[8] = 1024;
    *(_DWORD *)v41 = 150;
    *(_WORD *)&v41[4] = 1024;
    *(_DWORD *)&v41[6] = 16;
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v6, &type, &v33))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136447490;
      v36 = "nw_necp_append_tlv";
      v37 = 2048;
      *(_QWORD *)v38 = v3;
      *(_WORD *)&v38[8] = 2048;
      *(_QWORD *)v39 = 21;
      *(_WORD *)&v39[8] = 2048;
      *(_QWORD *)v40 = v4;
      *(_WORD *)&v40[8] = 1024;
      *(_DWORD *)v41 = 150;
      *(_WORD *)&v41[4] = 1024;
      *(_DWORD *)&v41[6] = 16;
      v9 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
      goto LABEL_25;
    }
    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136447490;
      v36 = "nw_necp_append_tlv";
      v37 = 2048;
      *(_QWORD *)v38 = v3;
      *(_WORD *)&v38[8] = 2048;
      *(_QWORD *)v39 = 21;
      *(_WORD *)&v39[8] = 2048;
      *(_QWORD *)v40 = v4;
      *(_WORD *)&v40[8] = 1024;
      *(_DWORD *)v41 = 150;
      *(_WORD *)&v41[4] = 1024;
      *(_DWORD *)&v41[6] = 16;
      v9 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_25;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = type;
    v12 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (!v12)
        goto LABEL_26;
      *(_DWORD *)buf = 136447490;
      v36 = "nw_necp_append_tlv";
      v37 = 2048;
      *(_QWORD *)v38 = v3;
      *(_WORD *)&v38[8] = 2048;
      *(_QWORD *)v39 = 21;
      *(_WORD *)&v39[8] = 2048;
      *(_QWORD *)v40 = v4;
      *(_WORD *)&v40[8] = 1024;
      *(_DWORD *)v41 = 150;
      *(_WORD *)&v41[4] = 1024;
      *(_DWORD *)&v41[6] = 16;
      v9 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
LABEL_25:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0x36u);
LABEL_26:

      if (!v6)
        goto LABEL_19;
      goto LABEL_18;
    }
    if (!v12)
      goto LABEL_16;
    *(_DWORD *)buf = 136447746;
    v36 = "nw_necp_append_tlv";
    v37 = 2048;
    *(_QWORD *)v38 = v3;
    *(_WORD *)&v38[8] = 2048;
    *(_QWORD *)v39 = 21;
    *(_WORD *)&v39[8] = 2048;
    *(_QWORD *)v40 = v4;
    *(_WORD *)&v40[8] = 1024;
    *(_DWORD *)v41 = 150;
    *(_WORD *)&v41[4] = 1024;
    *(_DWORD *)&v41[6] = 16;
    v42 = 2082;
    v43 = backtrace_string;
    v13 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s";
    v14 = v7;
    v15 = v8;
    v16 = 64;
    goto LABEL_15;
  }
  *(_BYTE *)v3 = -106;
  *(_DWORD *)(v3 + 1) = 16;
  if (!a2)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v36 = "nw_necp_append_tlv";
    v37 = 1024;
    *(_DWORD *)v38 = 150;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = 16;
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v6, &type, &v33))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "nw_necp_append_tlv";
        v37 = 1024;
        *(_DWORD *)v38 = 150;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 16;
        v20 = "%{public}s type=%u length=%u but value is NULL";
LABEL_79:
        v30 = v7;
        v31 = v27;
        v32 = 24;
        goto LABEL_80;
      }
    }
    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        v29 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (!v29)
            goto LABEL_16;
          *(_DWORD *)buf = 136446978;
          v36 = "nw_necp_append_tlv";
          v37 = 1024;
          *(_DWORD *)v38 = 150;
          *(_WORD *)&v38[4] = 1024;
          *(_DWORD *)&v38[6] = 16;
          *(_WORD *)v39 = 2082;
          *(_QWORD *)&v39[2] = backtrace_string;
          v13 = "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s";
          v14 = v7;
          v15 = v27;
          v16 = 34;
          goto LABEL_15;
        }
        if (!v29)
          goto LABEL_81;
        *(_DWORD *)buf = 136446722;
        v36 = "nw_necp_append_tlv";
        v37 = 1024;
        *(_DWORD *)v38 = 150;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 16;
        v20 = "%{public}s type=%u length=%u but value is NULL, no backtrace";
        goto LABEL_79;
      }
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "nw_necp_append_tlv";
        v37 = 1024;
        *(_DWORD *)v38 = 150;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 16;
        v20 = "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded";
        goto LABEL_79;
      }
    }
LABEL_81:

LABEL_17:
    if (!v6)
    {
LABEL_19:
      v10 = 0;
      goto LABEL_20;
    }
LABEL_18:
    free(v6);
    goto LABEL_19;
  }
  *(_OWORD *)(v3 + 5) = *a2;
  v10 = v3 + 21;
LABEL_20:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v10;
  return 1;
}

uint64_t nw_interface_type_to_functional_type(unsigned int a1, int a2)
{
  uint64_t v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  NSObject *v13;
  os_log_type_t v14;
  id v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  NSObject *v23;
  os_log_type_t v24;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  unsigned int v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a2 <= 1001)
  {
    if (!a2)
      goto LABEL_27;
    if (a2 == 1001)
    {
      LOBYTE(v4) = 3;
      return v4;
    }
  }
  else
  {
    switch(a2)
    {
      case 5001:
        LOBYTE(v4) = 7;
        return v4;
      case 4001:
        LOBYTE(v4) = 6;
        return v4;
      case 1002:
        LOBYTE(v4) = 4;
        return v4;
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v29 = "nw_interface_type_to_functional_type";
  v30 = 1024;
  v31 = a2;
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v6, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_interface_type_to_functional_type";
        v30 = 1024;
        v31 = a2;
        v9 = "%{public}s Unknown interface_subtype %d";
LABEL_22:
        v13 = v7;
        v14 = v8;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v13, v14, v9, buf, 0x12u);
      }
    }
    else
    {
      if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v11 = type;
        v12 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446722;
            v29 = "nw_interface_type_to_functional_type";
            v30 = 1024;
            v31 = a2;
            v32 = 2082;
            v33 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v11, "%{public}s Unknown interface_subtype %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (!v12)
          goto LABEL_24;
        *(_DWORD *)buf = 136446466;
        v29 = "nw_interface_type_to_functional_type";
        v30 = 1024;
        v31 = a2;
        v9 = "%{public}s Unknown interface_subtype %d, no backtrace";
        v13 = v7;
        v14 = v11;
        goto LABEL_23;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_interface_type_to_functional_type";
        v30 = 1024;
        v31 = a2;
        v9 = "%{public}s Unknown interface_subtype %d, backtrace limit exceeded";
        goto LABEL_22;
      }
    }
LABEL_24:

  }
LABEL_25:
  if (v6)
    free(v6);
LABEL_27:
  if (a1 < 5)
    return (0x102050300uLL >> (8 * a1));
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v15 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v29 = "nw_interface_type_to_functional_type";
  v30 = 1024;
  v31 = a1;
  v16 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (!__nwlog_fault(v16, &type, &v26))
    goto LABEL_43;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_interface_type_to_functional_type";
      v30 = 1024;
      v31 = a1;
      v19 = "%{public}s Unknown interface_type %d";
LABEL_40:
      v23 = v17;
      v24 = v18;
LABEL_41:
      _os_log_impl(&dword_182FBE000, v23, v24, v19, buf, 0x12u);
    }
  }
  else if (v26)
  {
    v20 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    v21 = type;
    v22 = os_log_type_enabled(v17, type);
    if (v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446722;
        v29 = "nw_interface_type_to_functional_type";
        v30 = 1024;
        v31 = a1;
        v32 = 2082;
        v33 = v20;
        _os_log_impl(&dword_182FBE000, v17, v21, "%{public}s Unknown interface_type %d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(v20);
      goto LABEL_43;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_interface_type_to_functional_type";
      v30 = 1024;
      v31 = a1;
      v19 = "%{public}s Unknown interface_type %d, no backtrace";
      v23 = v17;
      v24 = v21;
      goto LABEL_41;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_interface_type_to_functional_type";
      v30 = 1024;
      v31 = a1;
      v19 = "%{public}s Unknown interface_type %d, backtrace limit exceeded";
      goto LABEL_40;
    }
  }

LABEL_43:
  if (v16)
    free(v16);
  LOBYTE(v4) = 0;
  return v4;
}

void nw_protocol_definition_set_copy_metadata(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var22 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_copy_metadata";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_metadata";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_copy_metadata";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_metadata";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_metadata";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1831687C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_fallback_changed_handler(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var27 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_fallback_changed_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_fallback_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_fallback_changed_handler";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_fallback_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_fallback_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183168A70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_message_size_handler(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var28 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_message_size_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_message_size_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_message_size_handler";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_message_size_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_message_size_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183168D1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_handle_error(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_handle_error";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_handle_error";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_handle_error";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var9 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_handle_error";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_error";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_error";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_handle_error";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_handle_error";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_1831691E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_copy_data_transfer_snapshot(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var24 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_data_transfer_snapshot";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183169488(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_custom_flow_map_key_size(void *a1, unsigned int a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var32 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_custom_flow_map_key_size";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183169734(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_stop(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var16 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_stop";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_stop";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_stop";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_stop";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_stop";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1831699E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_has_global_definition(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *((_BYTE *)v1 + 184) |= 0x40u;
    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_definition_set_has_global_definition";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_protocol_definition_set_has_global_definition";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_definition_set_has_global_definition";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

void __nw_protocol_copy_quic_stream_definition_block_invoke()
{
  NWConcrete_nw_protocol_definition *named;
  void *v1;
  id v2;
  void *v3;
  id v4;
  void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  named = nw_protocol_definition_create_named(3, "quic");
  v1 = (void *)nw_protocol_copy_quic_stream_definition::quic_definition;
  nw_protocol_copy_quic_stream_definition::quic_definition = (uint64_t)named;

  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_quic_stream_definition::quic_definition, (uint64_t)nw_quic_stream_allocate_options, (uint64_t)nw_quic_stream_copy_options, (uint64_t)nw_quic_stream_deallocate_options);
  nw_protocol_definition_set_options_comparator((void *)nw_protocol_copy_quic_stream_definition::quic_definition, (uint64_t)nw_quic_stream_option_compare);
  nw_protocol_definition_set_options_serializer((void *)nw_protocol_copy_quic_stream_definition::quic_definition, 0, (uint64_t)nw_quic_stream_serialize_options, (uint64_t)nw_quic_stream_deserialize_options);
  nw_protocol_definition_set_metadata_initializer((void *)nw_protocol_copy_quic_stream_definition::quic_definition, 0x30u, nw_quic_stream_initialize_metadata, nw_quic_stream_finalize_metadata);
  v2 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  v3 = v2;
  if (v2)
  {
    *((_BYTE *)v2 + 184) |= 8u;
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_definition_set_receive_single_message";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_receive_single_message";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_definition_set_receive_single_message";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_receive_single_message";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_receive_single_message";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_26:
  if (v7)
    free(v7);
LABEL_3:

  v4 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  v5 = v4;
  if (quic_fillout_definition_callbacks_override)
  {
    quic_fillout_definition_callbacks_override(v4);
  }
  else
  {
    if (!MEMORY[0x1E0DE8470])
    {

      goto LABEL_8;
    }
    quic_fillout_definition_callbacks();
  }

  nw_protocol_definition_register((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
LABEL_8:
  nw_protocol_definition_set_options_should_serialize((void *)nw_protocol_copy_quic_stream_definition::quic_definition, (uint64_t)nw_quic_stream_should_serialize_options);
}

void sub_183169FFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_register_handle(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t *v9;
  _BOOL8 v10;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  _QWORD *v19;
  __int128 v20;
  __int128 v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  _BOOL4 v26;
  _BOOL8 result;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  NSObject *v32;
  void *v33;
  char *backtrace_string;
  _BOOL4 v35;
  const char *v36;
  _BOOL4 v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  nw_allow_use_of_dispatch_internal();
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_register_handle";
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v28, &type, &v38))
      goto LABEL_77;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v38)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (!os_log_type_enabled(v29, type))
          goto LABEL_77;
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_register_handle";
        v31 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_76;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v29 = __nwlog_obj();
      v30 = type;
      v35 = os_log_type_enabled(v29, type);
      if (!backtrace_string)
      {
        if (!v35)
          goto LABEL_77;
        *(_DWORD *)buf = 136446210;
        v41 = "nw_protocol_register_handle";
        v31 = "%{public}s called with null handle, no backtrace";
        goto LABEL_76;
      }
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_register_handle";
        v42 = 2082;
        v43 = (uint64_t)backtrace_string;
        v36 = "%{public}s called with null handle, dumping backtrace:%{public}s";
LABEL_66:
        _os_log_impl(&dword_182FBE000, v29, v30, v36, buf, 0x16u);
      }
LABEL_67:
      free(backtrace_string);
      goto LABEL_77;
    }
    v29 = __nwlog_obj();
    v30 = type;
    if (!os_log_type_enabled(v29, type))
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_register_handle";
    v31 = "%{public}s called with null handle";
LABEL_76:
    _os_log_impl(&dword_182FBE000, v29, v30, v31, buf, 0xCu);
LABEL_77:
    if (v28)
      free(v28);
    return 0;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_register_handle";
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v28, &type, &v38))
      goto LABEL_77;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_register_handle";
      v31 = "%{public}s called with null create_handle_function";
      goto LABEL_76;
    }
    if (!v38)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_register_handle";
      v31 = "%{public}s called with null create_handle_function, backtrace limit exceeded";
      goto LABEL_76;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v29 = __nwlog_obj();
    v30 = type;
    v37 = os_log_type_enabled(v29, type);
    if (backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_register_handle";
        v42 = 2082;
        v43 = (uint64_t)backtrace_string;
        v36 = "%{public}s called with null create_handle_function, dumping backtrace:%{public}s";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    if (!v37)
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_register_handle";
    v31 = "%{public}s called with null create_handle_function, no backtrace";
    goto LABEL_76;
  }
  if (*(_DWORD *)(a1 + 36) == 2)
    v8 = a4;
  else
    v8 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  v9 = &g_registration_list;
  while (1)
  {
    v9 = (uint64_t *)*v9;
    v10 = v9 == 0;
    if (!v9)
      break;
    if (*(_QWORD *)a1 == v9[4]
      && *(_QWORD *)(a1 + 8) == v9[5]
      && *(_QWORD *)(a1 + 16) == v9[6]
      && *(_QWORD *)(a1 + 24) == v9[7]
      && *(_QWORD *)(a1 + 32) == v9[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_register_handle";
      v42 = 2082;
      v43 = a1;
      v15 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v38 = 0;
      if (!__nwlog_fault(v15, &type, &v38))
        goto LABEL_44;
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v38)
        {
          v25 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v16 = gLogObj;
          v17 = type;
          v26 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v25)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446722;
              v41 = "nw_protocol_register_handle";
              v42 = 2082;
              v43 = a1;
              v44 = 2082;
              v45 = (uint64_t)v25;
              _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s Protocol identifier %{public}s is already registered, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v25);
            goto LABEL_44;
          }
          if (!v26)
            goto LABEL_44;
          *(_DWORD *)buf = 136446466;
          v41 = "nw_protocol_register_handle";
          v42 = 2082;
          v43 = a1;
          v18 = "%{public}s Protocol identifier %{public}s is already registered, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v16 = gLogObj;
          v17 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_44;
          *(_DWORD *)buf = 136446466;
          v41 = "nw_protocol_register_handle";
          v42 = 2082;
          v43 = a1;
          v18 = "%{public}s Protocol identifier %{public}s is already registered, backtrace limit exceeded";
        }
LABEL_43:
        _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0x16u);
        goto LABEL_44;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = gLogObj;
      v17 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_register_handle";
        v42 = 2082;
        v43 = a1;
        v18 = "%{public}s Protocol identifier %{public}s is already registered";
        goto LABEL_43;
      }
LABEL_44:
      if (v15)
        free(v15);
LABEL_46:
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      return v10;
    }
  }
  v19 = malloc_type_calloc(1uLL, 0x78uLL, 0xEAFB8F1AuLL);
  if (v19)
  {
LABEL_27:
    v20 = *(_OWORD *)a1;
    v21 = *(_OWORD *)(a1 + 16);
    v19[8] = *(_QWORD *)(a1 + 32);
    *((_OWORD *)v19 + 2) = v20;
    *((_OWORD *)v19 + 3) = v21;
    v19[12] = a3;
    v22 = os_retain(a2);
    v19[13] = v8;
    v19[14] = v22;
    v23 = g_registration_list;
    *v19 = g_registration_list;
    if (v23)
      *(_QWORD *)(v23 + 8) = v19;
    g_registration_list = (uint64_t)v19;
    v19[1] = &g_registration_list;
    if (v8)
    {
      v24 = g_many_to_one_list;
      v19[2] = g_many_to_one_list;
      if (v24)
        *(_QWORD *)(v24 + 24) = v19 + 2;
      g_many_to_one_list = (uint64_t)v19;
      v19[3] = &g_many_to_one_list;
    }
    v19[9] = nw_array_create();
    goto LABEL_46;
  }
  v32 = __nwlog_obj();
  os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v41 = "strict_calloc";
  v42 = 2048;
  v43 = 1;
  v44 = 2048;
  v45 = 120;
  v33 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v33);
  if (!result)
  {
    free(v33);
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

void nw_protocol_definition_set_options_serializer(void *a1, char a2, uint64_t a3, uint64_t a4)
{
  id v7;
  void *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_definition_set_options_serializer";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_protocol_definition_set_options_serializer";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10)
          goto LABEL_5;
LABEL_56:
        free(v10);
        goto LABEL_5;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_definition_set_options_serializer";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null serialize_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v26, "%{public}s called with null serialize_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null serialize_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_protocol_definition_set_options_serializer";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null serialize_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a4)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_definition_set_options_serializer";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null deserialize_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null deserialize_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_options_serializer";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null deserialize_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_protocol_definition_set_options_serializer";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null deserialize_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v20);
    if (!v10)
      goto LABEL_5;
    goto LABEL_56;
  }
  *((_BYTE *)v7 + 185) = *((_BYTE *)v7 + 185) & 0xFE | a2;
  *((_QWORD *)v7 + 16) = a3;
  *((_QWORD *)v7 + 17) = a4;
LABEL_5:

}

void nw_protocol_definition_set_probe_connectivity_update(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var21 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_probe_connectivity_update";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_probe_connectivity_update";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_probe_connectivity_update";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_probe_connectivity_update";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_probe_connectivity_update";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18316B10C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_definition_register(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_protocol_register_handle((uint64_t)v1 + 8, v1, (uint64_t)nw_protocol_implementation_create, (uint64_t)nw_protocol_implementation_accept);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_register";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_register";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_register";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_register";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_register";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_protocol_copy_quic_connection_definition_block_invoke()
{
  NWConcrete_nw_protocol_definition *named;
  void *v1;
  id v2;
  void *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  void *v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  named = nw_protocol_definition_create_named(3, "quic-connection");
  v1 = (void *)nw_protocol_copy_quic_connection_definition::quic_definition;
  nw_protocol_copy_quic_connection_definition::quic_definition = (uint64_t)named;

  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_quic_connection_definition::quic_definition, (uint64_t)nw_quic_connection_allocate_options, (uint64_t)nw_quic_connection_copy_options, (uint64_t)nw_quic_connection_deallocate_options);
  nw_protocol_definition_set_options_comparator((void *)nw_protocol_copy_quic_connection_definition::quic_definition, (uint64_t)nw_quic_connection_option_compare);
  nw_protocol_definition_set_metadata_initializer((void *)nw_protocol_copy_quic_connection_definition::quic_definition, 0xE0u, nw_quic_connection_initialize_metadata, nw_quic_connection_finalize_metadata);
  nw_protocol_definition_set_metadata_copy_reply((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_metadata_create_reply, nw_quic_metadata_copy_original, nw_quic_metadata_set_original);
  nw_protocol_definition_set_metadata_copy_message_options((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_metadata_copy_stream_options);
  v2 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  v3 = v2;
  if (v2)
  {
    *((_BYTE *)v2 + 184) |= 6u;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_definition_set_message_is_stream";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v6, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_message_is_stream";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_definition_set_message_is_stream";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_message_is_stream";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_message_is_stream";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_25:
  if (v6)
    free(v6);
LABEL_3:

  nw_protocol_definition_set_cache_entry_deallocator((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_deallocate_cache_entry);
  nw_protocol_definition_set_should_flush_cache_entry((void *)nw_protocol_copy_quic_connection_definition::quic_definition, nw_quic_should_flush_cache_entry);
  v4 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
  if (quic_fillout_definition_callbacks_override)
  {
    v13 = v4;
    quic_fillout_definition_callbacks_override(v4);
LABEL_7:

    nw_protocol_definition_register((void *)nw_protocol_copy_quic_connection_definition::quic_definition);
    return;
  }
  if (MEMORY[0x1E0DE8470])
  {
    v13 = v4;
    quic_fillout_definition_callbacks();
    goto LABEL_7;
  }

}

void sub_18316B790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_options_comparator(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_options_comparator";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_comparator";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_options_comparator";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_comparator";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_options_comparator";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    *((_QWORD *)v3 + 15) = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_options_comparator";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_comparator";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null comparator_function", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_comparator";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null comparator_function, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_options_comparator";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null comparator_function, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_options_comparator";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null comparator_function, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void nw_protocol_definition_set_metadata_copy_reply(void *a1, void *a2, void *a3, void *a4)
{
  NWConcrete_nw_protocol_definition *v7;
  NWConcrete_nw_protocol_definition *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_definition_set_metadata_copy_reply";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_protocol_definition_set_metadata_copy_reply";
          v32 = 2082;
          v33 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v10)
          goto LABEL_5;
LABEL_56:
        free(v10);
        goto LABEL_5;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v25, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a2)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_definition_set_metadata_copy_reply";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null create_reply_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v26, "%{public}s called with null create_reply_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null create_reply_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_protocol_definition_set_metadata_copy_reply";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null create_reply_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a3)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_definition_set_metadata_copy_reply";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null copy_original_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v27, "%{public}s called with null copy_original_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v20 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v11, type);
    if (!v20)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_definition_set_metadata_copy_reply";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null copy_original_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_protocol_definition_set_metadata_copy_reply";
      v32 = 2082;
      v33 = v20;
      _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null copy_original_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v20);
    if (!v10)
      goto LABEL_5;
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_common_state(v7);
  v8->common_state->var3 = a2;
  v8->common_state->var4 = a3;
  v8->common_state->var5 = a4;
LABEL_5:

}

void sub_18316C318(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_metadata_copy_message_options(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_definition_set_metadata_copy_message_options";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_definition_set_metadata_copy_message_options";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_definition_set_metadata_copy_message_options";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    nw_protocol_definition_initialize_common_state(v3);
    v4->common_state->var6 = a2;
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_definition_set_metadata_copy_message_options";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_metadata_copy_message_options";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null copy_message_options", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_metadata_copy_message_options";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null copy_message_options, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_definition_set_metadata_copy_message_options";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null copy_message_options, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_definition_set_metadata_copy_message_options";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null copy_message_options, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_18316C7DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_copy_establishment_report(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var23 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_copy_establishment_report";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_establishment_report";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_copy_establishment_report";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_establishment_report";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_establishment_report";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18316CA84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_metadata_initializer(void *a1, unsigned int a2, void *a3, void *a4)
{
  NWConcrete_nw_protocol_definition *v7;
  NWConcrete_nw_protocol_definition *v8;
  nw_protocol_definition_extended_state *extended_state;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  void *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  char *v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  os_log_type_t v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_protocol_definition_set_metadata_initializer";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v11, &type, &v29))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v32 = "nw_protocol_definition_set_metadata_initializer";
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11)
          goto LABEL_5;
LABEL_56:
        free(v11);
        goto LABEL_5;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v26, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!a3)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_protocol_definition_set_metadata_initializer";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v11, &type, &v29))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null initialize_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v29)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v27, "%{public}s called with null initialize_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null initialize_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v32 = "nw_protocol_definition_set_metadata_initializer";
      v33 = 2082;
      v34 = v21;
      _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null initialize_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a4)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_protocol_definition_set_metadata_initializer";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v11, &type, &v29))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null finalize_function", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v29)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v28, "%{public}s called with null finalize_function, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v21 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v24 = type;
    v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v32 = "nw_protocol_definition_set_metadata_initializer";
        _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s called with null finalize_function, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v32 = "nw_protocol_definition_set_metadata_initializer";
      v33 = 2082;
      v34 = v21;
      _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s called with null finalize_function, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v21);
    if (!v11)
      goto LABEL_5;
    goto LABEL_56;
  }
  nw_protocol_definition_initialize_extended_state(v7);
  extended_state = v8->extended_state;
  extended_state->var33 = a2;
  extended_state->var29 = a3;
  v8->extended_state->var30 = a4;
LABEL_5:

}

void sub_18316D160(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_has_associations_block_invoke(uint64_t a1, uint64_t a2)
{
  void *object;
  id v5;
  const char *logging_description;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  const char *v15;
  os_log_type_t v16;
  const char *v17;
  const char *v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  object = (void *)nw_hash_node_get_object(a2);
  if (!nw_association_is_empty(object) || nw_hash_table_remove_node(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 200), a2))
    return 1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  logging_description = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
  *(_DWORD *)buf = 136446722;
  v22 = "nw_endpoint_has_associations_block_invoke";
  v23 = 2082;
  v24 = logging_description;
  v25 = 2048;
  v26 = a2;
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v7, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        v10 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446722;
        v22 = "nw_endpoint_has_associations_block_invoke";
        v23 = 2082;
        v24 = v10;
        v25 = 2048;
        v26 = a2;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s %{public}s failed to remove association for node %p", buf, 0x20u);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          v15 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
          *(_DWORD *)buf = 136446978;
          v22 = "nw_endpoint_has_associations_block_invoke";
          v23 = 2082;
          v24 = v15;
          v25 = 2048;
          v26 = a2;
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s %{public}s failed to remove association for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(backtrace_string);
        if (v7)
          goto LABEL_9;
        return 1;
      }
      if (v14)
      {
        v18 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446722;
        v22 = "nw_endpoint_has_associations_block_invoke";
        v23 = 2082;
        v24 = v18;
        v25 = 2048;
        v26 = a2;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s %{public}s failed to remove association for node %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v16 = type;
      if (os_log_type_enabled(v8, type))
      {
        v17 = nw_endpoint_get_logging_description(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136446722;
        v22 = "nw_endpoint_has_associations_block_invoke";
        v23 = 2082;
        v24 = v17;
        v25 = 2048;
        v26 = a2;
        _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s %{public}s failed to remove association for node %p, backtrace limit exceeded", buf, 0x20u);
      }
    }

  }
  if (v7)
LABEL_9:
    free(v7);
  return 1;
}

void sub_18316D510(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_association_is_empty(void *a1)
{
  void **v1;
  void **v2;
  id v3;
  _DWORD *v4;
  time_t v5;
  char *v6;
  _BOOL8 v7;
  _DWORD *v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _QWORD v18[4];
  id v19;
  void **v20;
  time_t v21;
  char v22;
  os_log_type_t v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_path_parameters_copy_context(v1[2]);
    nw_context_assert_queue(v3);
    v4 = v2[7];
    if (v4 && v4[10])
    {
      v5 = time(0);
      v6 = (char *)v2[7];
      v18[0] = MEMORY[0x1E0C809B0];
      v18[1] = 3221225472;
      v18[2] = __nw_association_is_empty_block_invoke;
      v18[3] = &unk_1E14AC2F0;
      v21 = v5;
      v19 = v3;
      v20 = v2;
      nw_hash_table_apply(v6, (uint64_t)v18);

    }
    if ((*((_BYTE *)v2 + 76) & 1) != 0)
    {
      v8 = v2[7];
      if (v8)
        v7 = v8[10] == 0;
      else
        v7 = 1;
    }
    else
    {
      v7 = 0;
    }

    goto LABEL_11;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_association_is_empty";
  v11 = (char *)_os_log_send_and_compose_impl();

  v23 = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (__nwlog_fault(v11, &v23, &v22))
  {
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = v23;
      if (os_log_type_enabled(v12, v23))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_association_is_empty";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = v23;
      v16 = os_log_type_enabled(v12, v23);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_association_is_empty";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_association_is_empty";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = v23;
      if (os_log_type_enabled(v12, v23))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_association_is_empty";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_28:
  if (v11)
    free(v11);
  v7 = 0;
LABEL_11:

  return v7;
}

void sub_18316D888(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_register(_QWORD *a1, uint64_t a2)
{
  uint64_t *v4;
  NSObject *v9;
  _QWORD *v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  _BOOL8 result;
  NSObject *v15;
  void *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  v4 = &g_registration_list;
  while (1)
  {
    v4 = (uint64_t *)*v4;
    if (!v4)
      break;
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v18 = "nw_protocol_register";
        v19 = 2082;
        v20 = (uint64_t)a1;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Protocol %{public}s is already registered", buf, 0x16u);
      }
LABEL_23:
      os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
      return v4 == 0;
    }
  }
  v10 = malloc_type_calloc(1uLL, 0x78uLL, 0xEAFB8F1AuLL);
  if (v10)
  {
LABEL_20:
    v11 = *(_OWORD *)a1;
    v12 = *((_OWORD *)a1 + 1);
    v10[8] = a1[4];
    *((_OWORD *)v10 + 2) = v11;
    *((_OWORD *)v10 + 3) = v12;
    v10[10] = a2;
    v13 = g_registration_list;
    *v10 = g_registration_list;
    if (v13)
      *(_QWORD *)(v13 + 8) = v10;
    g_registration_list = (uint64_t)v10;
    v10[1] = &g_registration_list;
    goto LABEL_23;
  }
  v15 = __nwlog_obj();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v18 = "strict_calloc";
  v19 = 2048;
  v20 = 1;
  v21 = 2048;
  v22 = 120;
  v16 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v16);
  if (!result)
  {
    free(v16);
    goto LABEL_20;
  }
  __break(1u);
  return result;
}

BOOL network_config_register_boringssl_log_debug_updates(void *a1)
{
  id v1;
  _BOOL8 v2;

  v1 = a1;
  nw_allow_use_of_dispatch_internal();
  v2 = nw_settings_register_boringssl_log_debug_updates(v1);

  return v2;
}

BOOL nw_settings_register_boringssl_log_debug_updates(void *a1)
{
  const void *v2;
  const char *v3;
  void *v4;
  Class Class;
  _BOOL8 v6;
  xpc_object_t value;
  void *v8;

  nw_allow_use_of_dispatch_internal();
  pthread_mutex_lock(&sSettingsMutex);
  v2 = (const void *)sBoringSSLUpdateBlock;
  if ((void *)sBoringSSLUpdateBlock != a1)
  {
    if (a1)
    {
      a1 = _Block_copy(a1);
      v2 = (const void *)sBoringSSLUpdateBlock;
    }
    if (v2)
      _Block_release(v2);
    sBoringSSLUpdateBlock = (uint64_t)a1;
  }
  pthread_mutex_unlock(&sSettingsMutex);
  v3 = (const char *)nw_setting_boringssl_log_debug;
  networkd_settings_init();
  if (!sCachedSettings)
    return 0;
  pthread_mutex_lock(&sSettingsMutex);
  v4 = (void *)sCachedSettings;
  if (!sCachedSettings)
    goto LABEL_13;
  Class = object_getClass((id)sCachedSettings);
  v6 = 0;
  if (!v3 || Class != (Class)MEMORY[0x1E0C812F8])
    goto LABEL_14;
  value = xpc_dictionary_get_value(v4, v3);
  if (value && (v8 = value, object_getClass(value) == (Class)MEMORY[0x1E0C812D0]))
    v6 = xpc_BOOL_get_value(v8);
  else
LABEL_13:
    v6 = 0;
LABEL_14:
  pthread_mutex_unlock(&sSettingsMutex);
  return v6;
}

uint64_t NWActivity.domain.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 24);
}

uint64_t NWActivity.label.getter()
{
  uint64_t v0;

  return *(_QWORD *)(v0 + 32);
}

uint64_t sub_18316DC38(uint64_t a1)
{
  uint64_t v1;

  return sub_183062338(a1, *(unint64_t **)(v1 + 16));
}

void __nw_context_reset_timer_block_with_time_block_invoke(uint64_t a1)
{
  void *v1;
  uint64_t *v2;
  uint64_t v3;
  _QWORD *v4;
  _BOOL8 node;
  void *v6;
  uint64_t *v7;
  dispatch_time_t v8;
  uint64_t *v9;
  uint64_t v10;
  dispatch_time_t v11;
  void (**v12)(_QWORD);
  void *v13;
  char v14;
  id v15;
  uint64_t v16;
  _QWORD *v17;
  id v18;

  v18 = *(id *)(a1 + 32);
  nw_context_assert_queue(v18);
  v1 = v18;
  v2 = (uint64_t *)*((_QWORD *)v18 + 4);
  v2[4] = -1;
  v3 = *v2;
  if (*v2)
  {
    if (v2[1])
    {
      do
      {
        v8 = dispatch_time(0x8000000000000000, 0);
        v9 = (uint64_t *)*((_QWORD *)v18 + 4);
        v10 = v9[1];
        v11 = *(_QWORD *)(v10 + 16);
        if (v11 > v8)
        {
          nw_queue_set_timer_values(*v9, v11, 0xFFFFFFFFFFFFFFFFLL, 0);
          v1 = v18;
          *(_QWORD *)(*((_QWORD *)v18 + 4) + 32) = *(_QWORD *)(v10 + 16);
          goto LABEL_18;
        }
        v12 = (void (**)(_QWORD))_Block_copy(*(const void **)(v10 + 32));
        v13 = *(void **)(v10 + 32);
        *(_QWORD *)(v10 + 32) = 0;

        v14 = *(_BYTE *)(v10 + 40) | 1;
        *(_BYTE *)(v10 + 40) = v14;
        if (v12)
        {
          v12[2](v12);
          v14 = *(_BYTE *)(v10 + 40);
        }
        *(_BYTE *)(v10 + 40) = v14 & 0xFE;
        if (!*(_QWORD *)(v10 + 32))
        {
          v15 = v18;
          if ((*(_BYTE *)(v10 + 40) & 1) == 0)
          {
            v16 = *(_QWORD *)v10;
            v17 = *(_QWORD **)(v10 + 8);
            if (*(_QWORD *)v10)
            {
              *(_QWORD *)(v16 + 8) = v17;
              v17 = *(_QWORD **)(v10 + 8);
              v4 = v18;
            }
            else
            {
              v4 = v18;
              *(_QWORD *)(*((_QWORD *)v18 + 4) + 16) = v17;
            }
            *v17 = v16;
            *(_QWORD *)v10 = 0;
            *(_QWORD *)(v10 + 8) = 0;
            node = nw_hash_table_get_node(*(_QWORD *)(v4[4] + 24), *(_QWORD *)(v10 + 24), 0);
            nw_hash_table_remove_node(*(_QWORD *)(*((_QWORD *)v18 + 4) + 24), node);
            v6 = *(void **)(v10 + 32);
            *(_QWORD *)(v10 + 32) = 0;

            free((void *)v10);
          }

        }
        v7 = (uint64_t *)*((_QWORD *)v18 + 4);
      }
      while (v7[1]);
      v3 = *v7;
    }
    nw_queue_set_timer_values(v3, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
    nw_context_cleanup_timer((NWConcrete_nw_context *)v18);
    v1 = v18;
  }
LABEL_18:

}

void sub_18316DDE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void __nw_protocol_instance_schedule_wakeup_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _QWORD *WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v1 = WeakRetained[33];
    if (v1)
    {
      if ((*((_BYTE *)WeakRetained + 404) & 0x10) != 0)
        (*(void (**)(uint64_t, _QWORD *))(v1 + 16))(v1, WeakRetained);
    }
  }

}

void sub_18316DE5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_protocol_instance_notify_connection_id_changed(void *a1, uint64_t a2, void *a3)
{
  _QWORD *v5;
  NSObject *v6;
  size_t size;
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  char v12;
  uint64_t v13;
  void *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(_QWORD *, _QWORD *, uint64_t, void *, size_t);
  NSObject *v19;
  void *v20;
  NSObject *v21;
  void *v22;
  void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  void *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  void *v33;
  os_log_type_t v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  char *backtrace_string;
  os_log_type_t v39;
  _BOOL4 v40;
  char *v41;
  os_log_type_t v42;
  _BOOL4 v43;
  os_log_type_t v44;
  const char *v45;
  const char *v46;
  os_log_type_t v47;
  os_log_type_t v48;
  void *v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  char *v53;
  os_log_type_t v54;
  _BOOL4 v55;
  os_log_type_t v56;
  os_log_type_t v57;
  char v58;
  os_log_type_t type;
  _QWORD *v60;
  uint64_t *v61;
  uint64_t v62;
  void *v63;
  os_log_type_t v64[8];
  os_log_type_t *v65;
  uint64_t v66;
  uint64_t v67;
  _BYTE applier[24];
  void *v69;
  __int128 v70;
  size_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  size = dispatch_data_get_size(v6);
  if (!size)
  {
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "strict_calloc";
    v20 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v20))
      goto LABEL_116;
    free(v20);
  }
  v8 = malloc_type_calloc(1uLL, size, 0xEAFB8F1AuLL);
  if (v8)
    goto LABEL_3;
  __nwlog_obj();
  v21 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446722;
  *(_QWORD *)&applier[4] = "strict_calloc";
  *(_WORD *)&applier[12] = 2048;
  *(_QWORD *)&applier[14] = 1;
  *(_WORD *)&applier[22] = 2048;
  v69 = (void *)size;
  v22 = (void *)_os_log_send_and_compose_impl();

  if (__nwlog_abort((uint64_t)v22))
  {
LABEL_116:
    __break(1u);
    JUMPOUT(0x18316EAF8);
  }
  free(v22);
LABEL_3:
  *(_QWORD *)v64 = 0;
  v65 = v64;
  v66 = 0x2000000000;
  v67 = 0;
  v60 = 0;
  v61 = (uint64_t *)&v60;
  v62 = 0x2000000000;
  v63 = v8;
  if (v6)
  {
    *(_QWORD *)applier = MEMORY[0x1E0C809B0];
    *(_QWORD *)&applier[8] = 0x40000000;
    *(_QWORD *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    v69 = &unk_1E14A3448;
    *((_QWORD *)&v70 + 1) = &v60;
    v71 = size;
    *(_QWORD *)&v70 = v64;
    dispatch_data_apply(v6, applier);
    v9 = *((_QWORD *)v65 + 3);
  }
  else
  {
    v9 = 0;
  }
  _Block_object_dispose(&v60, 8);
  _Block_object_dispose(v64, 8);
  if (v9 != size)
    goto LABEL_28;
  if (!v5)
  {
    __nwlog_obj();
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "__nw_protocol_get_output_handler";
    v30 = (char *)_os_log_send_and_compose_impl();

    v64[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v60) = 0;
    if (__nwlog_fault(v30, v64, &v60))
    {
      if (v64[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v32 = v64[0];
        if (os_log_type_enabled(v31, v64[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "__nw_protocol_get_output_handler";
          _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s called with null protocol", applier, 0xCu);
        }
      }
      else if ((_BYTE)v60)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v39 = v64[0];
        v40 = os_log_type_enabled(v31, v64[0]);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)applier = 136446466;
            *(_QWORD *)&applier[4] = "__nw_protocol_get_output_handler";
            *(_WORD *)&applier[12] = 2082;
            *(_QWORD *)&applier[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v31, v39, "%{public}s called with null protocol, dumping backtrace:%{public}s", applier, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_91;
        }
        if (v40)
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "__nw_protocol_get_output_handler";
          _os_log_impl(&dword_182FBE000, v31, v39, "%{public}s called with null protocol, no backtrace", applier, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v31 = objc_claimAutoreleasedReturnValue();
        v47 = v64[0];
        if (os_log_type_enabled(v31, v64[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "__nw_protocol_get_output_handler";
          _os_log_impl(&dword_182FBE000, v31, v47, "%{public}s called with null protocol, backtrace limit exceeded", applier, 0xCu);
        }
      }

    }
LABEL_91:
    if (v30)
      free(v30);
LABEL_93:
    __nwlog_obj();
    v49 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "__nw_protocol_notify";
    v50 = (char *)_os_log_send_and_compose_impl();

    v64[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v60) = 0;
    if (__nwlog_fault(v50, v64, &v60))
    {
      if (v64[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v51 = objc_claimAutoreleasedReturnValue();
        v52 = v64[0];
        if (os_log_type_enabled(v51, v64[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "__nw_protocol_notify";
          _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s called with null protocol", applier, 0xCu);
        }
      }
      else if ((_BYTE)v60)
      {
        v53 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v51 = objc_claimAutoreleasedReturnValue();
        v54 = v64[0];
        v55 = os_log_type_enabled(v51, v64[0]);
        if (v53)
        {
          if (v55)
          {
            *(_DWORD *)applier = 136446466;
            *(_QWORD *)&applier[4] = "__nw_protocol_notify";
            *(_WORD *)&applier[12] = 2082;
            *(_QWORD *)&applier[14] = v53;
            _os_log_impl(&dword_182FBE000, v51, v54, "%{public}s called with null protocol, dumping backtrace:%{public}s", applier, 0x16u);
          }

          free(v53);
          goto LABEL_109;
        }
        if (v55)
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "__nw_protocol_notify";
          _os_log_impl(&dword_182FBE000, v51, v54, "%{public}s called with null protocol, no backtrace", applier, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v51 = objc_claimAutoreleasedReturnValue();
        v56 = v64[0];
        if (os_log_type_enabled(v51, v64[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "__nw_protocol_notify";
          _os_log_impl(&dword_182FBE000, v51, v56, "%{public}s called with null protocol, backtrace limit exceeded", applier, 0xCu);
        }
      }

    }
LABEL_109:
    if (v50)
      free(v50);
    goto LABEL_28;
  }
  v10 = (_QWORD *)*(v5 - 8);
  if (!v10)
    goto LABEL_93;
  v11 = (void *)v10[5];
  if (v11 == &nw_protocol_ref_counted_handle)
  {
    v13 = v10[11];
    if (v13)
      v10[11] = v13 + 1;
    v12 = -1;
  }
  else
  {
    v12 = 0;
  }
  *(_QWORD *)v64 = v10;
  LOBYTE(v65) = v12;
  v14 = (void *)*(v5 - 7);
  if (v14 == &nw_protocol_ref_counted_handle)
  {
    v16 = *(v5 - 1);
    if (v16)
      *(v5 - 1) = v16 + 1;
    v15 = -1;
  }
  else
  {
    v15 = 0;
  }
  v60 = v5 - 12;
  LOBYTE(v61) = v15;
  if (!(_DWORD)a2)
  {
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "__nw_protocol_notify";
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (!__nwlog_fault(v25, &type, &v58))
      goto LABEL_114;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "__nw_protocol_notify";
        _os_log_impl(&dword_182FBE000, v26, v34, "%{public}s called with null type", applier, 0xCu);
      }
    }
    else if (v58)
    {
      v41 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v42 = type;
      v43 = os_log_type_enabled(v26, type);
      if (v41)
      {
        if (v43)
        {
          *(_DWORD *)applier = 136446466;
          *(_QWORD *)&applier[4] = "__nw_protocol_notify";
          *(_WORD *)&applier[12] = 2082;
          *(_QWORD *)&applier[14] = v41;
          _os_log_impl(&dword_182FBE000, v26, v42, "%{public}s called with null type, dumping backtrace:%{public}s", applier, 0x16u);
        }

        free(v41);
        if (!v25)
          goto LABEL_23;
        goto LABEL_115;
      }
      if (v43)
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "__nw_protocol_notify";
        _os_log_impl(&dword_182FBE000, v26, v42, "%{public}s called with null type, no backtrace", applier, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v48 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "__nw_protocol_notify";
        _os_log_impl(&dword_182FBE000, v26, v48, "%{public}s called with null type, backtrace limit exceeded", applier, 0xCu);
      }
    }
    goto LABEL_113;
  }
  v17 = v10[3];
  if (!v17 || (v18 = *(void (**)(_QWORD *, _QWORD *, uint64_t, void *, size_t))(v17 + 160)) == 0)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v24 = (const char *)v10[2];
    *(_DWORD *)applier = 136446722;
    *(_QWORD *)&applier[4] = "__nw_protocol_notify";
    if (!v24)
      v24 = "invalid";
    *(_WORD *)&applier[12] = 2082;
    *(_QWORD *)&applier[14] = v24;
    *(_WORD *)&applier[22] = 2048;
    v69 = v10;
    v25 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v58 = 0;
    if (__nwlog_fault(v25, &type, &v58))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          v28 = (const char *)v10[2];
          if (!v28)
            v28 = "invalid";
          *(_DWORD *)applier = 136446722;
          *(_QWORD *)&applier[4] = "__nw_protocol_notify";
          *(_WORD *)&applier[12] = 2082;
          *(_QWORD *)&applier[14] = v28;
          *(_WORD *)&applier[22] = 2048;
          v69 = v10;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid notify callback", applier, 0x20u);
        }
LABEL_113:

        goto LABEL_114;
      }
      if (!v58)
      {
        __nwlog_obj();
        v26 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        if (os_log_type_enabled(v26, type))
        {
          v45 = (const char *)v10[2];
          if (!v45)
            v45 = "invalid";
          *(_DWORD *)applier = 136446722;
          *(_QWORD *)&applier[4] = "__nw_protocol_notify";
          *(_WORD *)&applier[12] = 2082;
          *(_QWORD *)&applier[14] = v45;
          *(_WORD *)&applier[22] = 2048;
          v69 = v10;
          _os_log_impl(&dword_182FBE000, v26, v44, "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded", applier, 0x20u);
        }
        goto LABEL_113;
      }
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v57 = type;
      v36 = os_log_type_enabled(v26, type);
      if (!v35)
      {
        if (v36)
        {
          v46 = (const char *)v10[2];
          if (!v46)
            v46 = "invalid";
          *(_DWORD *)applier = 136446722;
          *(_QWORD *)&applier[4] = "__nw_protocol_notify";
          *(_WORD *)&applier[12] = 2082;
          *(_QWORD *)&applier[14] = v46;
          *(_WORD *)&applier[22] = 2048;
          v69 = v10;
          _os_log_impl(&dword_182FBE000, v26, v57, "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace", applier, 0x20u);
        }
        goto LABEL_113;
      }
      if (v36)
      {
        v37 = (const char *)v10[2];
        if (!v37)
          v37 = "invalid";
        *(_DWORD *)applier = 136446978;
        *(_QWORD *)&applier[4] = "__nw_protocol_notify";
        *(_WORD *)&applier[12] = 2082;
        *(_QWORD *)&applier[14] = v37;
        *(_WORD *)&applier[22] = 2048;
        v69 = v10;
        LOWORD(v70) = 2082;
        *(_QWORD *)((char *)&v70 + 2) = v35;
        _os_log_impl(&dword_182FBE000, v26, v57, "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s", applier, 0x2Au);
      }

      free(v35);
    }
LABEL_114:
    if (!v25)
      goto LABEL_23;
LABEL_115:
    free(v25);
    goto LABEL_23;
  }
  v18(v10, v5 - 12, a2, v8, size);
LABEL_23:
  if (v14 == &nw_protocol_ref_counted_handle)
  {
    nw::release_if_needed<nw_protocol *>((uint64_t *)&v60);
    if (v11 != &nw_protocol_ref_counted_handle)
      goto LABEL_28;
  }
  else if (v11 != &nw_protocol_ref_counted_handle)
  {
    goto LABEL_28;
  }
  nw::release_if_needed<nw_protocol *>((uint64_t *)v64);
LABEL_28:
  if (v8)
    free(v8);

}

void nw_flow_passthrough_notify(uint64_t a1, nw_protocol *a2, unsigned int a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v9;
  id v10;
  void *v11;
  NWConcrete_nw_endpoint_handler *v12;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v14;
  NWConcrete_nw_endpoint_handler *v15;
  int state;
  const char *v17;
  NWConcrete_nw_endpoint_handler *v18;
  char v19;
  NSObject *v20;
  char *v21;
  char *v22;
  char v23;
  const char *v24;
  nw_endpoint_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  const char *v29;
  void **v30;
  void **v31;
  const char *v32;
  void **v33;
  id v34;
  id v35;
  void *v36;
  const char *v37;
  uint64_t v38;
  int minimize_logging;
  char logging_disabled;
  NSObject *v41;
  const char *v42;
  const char *v43;
  nw_endpoint_t v44;
  NWConcrete_nw_endpoint_mode_handler *v45;
  const char *v46;
  const char *v47;
  const char *v48;
  id v49;
  int v50;
  int v51;
  char v52;
  void *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  id v57;
  const char *v58;
  const char *v59;
  nw_endpoint_t v60;
  const char *v61;
  const char *v62;
  const char *v63;
  id v64;
  char *v65;
  NSObject *v66;
  os_log_type_t v67;
  const char *v68;
  const char *v69;
  nw_endpoint_t v70;
  const char *v71;
  const char *v72;
  const char *v73;
  id v74;
  int v75;
  uint64_t v76;
  void (*v77)(void);
  NWConcrete_nw_endpoint_mode_handler *v78;
  char *v79;
  NSObject *v80;
  os_log_type_t v81;
  _BOOL4 v82;
  const char *backtrace_string;
  char *v84;
  NSObject *v85;
  os_log_type_t v86;
  const char *v87;
  nw_endpoint_t v88;
  const char *v89;
  const char *v90;
  const char *v91;
  id v92;
  os_log_type_t v93;
  os_log_type_t v94;
  const char *v95;
  const char *v96;
  nw_endpoint_t v97;
  const char *v98;
  const char *v99;
  const char *v100;
  id v101;
  os_log_type_t v102;
  const char *v103;
  const char *v104;
  nw_endpoint_t v105;
  const char *v106;
  const char *v107;
  const char *v108;
  id v109;
  const char *v110;
  id v111;
  void *v112;
  const char *v113;
  uint64_t v114;
  const char *v115;
  nw_endpoint_t v116;
  const char *v117;
  const char *v118;
  const char *v119;
  id v120;
  int v121;
  nw_endpoint_t v122;
  char *v123;
  const char *v124;
  const char *v125;
  const char *logging_description;
  const char *v127;
  const char *v128;
  const char *v129;
  char *v130;
  char *v131;
  char *v132;
  char *v133;
  const char *id_string;
  NWConcrete_nw_endpoint_mode_handler *v135;
  NWConcrete_nw_endpoint_mode_handler *v136;
  NWConcrete_nw_endpoint_mode_handler *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  nw_endpoint_t v141;
  NSObject *log;
  NSObject *loga;
  const char *logb;
  const char *logc;
  NWConcrete_nw_endpoint_handler *v146;
  _QWORD v147[4];
  NWConcrete_nw_endpoint_handler *v148;
  uint64_t v149;
  char v150;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v153;
  __int16 v154;
  void *v155;
  __int16 v156;
  const char *v157;
  __int16 v158;
  const char *v159;
  __int16 v160;
  const char *v161;
  __int16 v162;
  const char *v163;
  __int16 v164;
  id v165;
  __int16 v166;
  const char *v167;
  uint64_t v168;

  v9 = a1;
  v168 = *MEMORY[0x1E0C80C00];
  v10 = *(id *)(*(_QWORD *)(a1 + 40) + 160);
  v11 = v10;
  if (v10)
  {
    v12 = (NWConcrete_nw_endpoint_handler *)v10;
    mode = v12->mode;

    if ((_DWORD)mode != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (NWConcrete_nw_endpoint_mode_handler *)(id)gLogObj;
      if (os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5)
          v17 = "unknown-mode";
        else
          v17 = off_1E149FC18[mode];
        *(_DWORD *)buf = 136446722;
        v153 = "nw_flow_passthrough_notify";
        v154 = 2082;
        v155 = (void *)v17;
        v156 = 2082;
        v157 = "flow";
        _os_log_impl(&dword_182FBE000, (os_log_t)v14, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
      goto LABEL_74;
    }
    v14 = nw_endpoint_handler_copy_flow(v12);
    v15 = v12;
    state = v15->state;

    v146 = v15;
    if (state == 5)
    {
      switch(a3)
      {
        case 7u:
        case 0x15u:
          goto LABEL_74;
        case 0xDu:
        case 0xFu:
        case 0x10u:
          goto LABEL_35;
        case 0x13u:
          goto LABEL_52;
        case 0x16u:
          goto LABEL_37;
        case 0x17u:
          goto LABEL_46;
        case 0x19u:
          goto LABEL_51;
        default:
          goto LABEL_70;
      }
      goto LABEL_74;
    }
    if (nw_endpoint_handler_get_minimize_logging(v15))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v15) & 1) != 0)
        goto LABEL_34;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      log = (id)gconnectionLogObj;
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v15);
        v128 = nw_endpoint_handler_dry_run_string(v15);
        v141 = nw_endpoint_handler_copy_endpoint(v15);
        logging_description = nw_endpoint_get_logging_description(v141);
        v124 = nw_endpoint_handler_state_string(v15);
        v110 = nw_endpoint_handler_mode_string(v15);
        v111 = nw_endpoint_handler_copy_current_path(v15);
        v112 = v111;
        if (a3 > 0x19)
          v113 = "unknown";
        else
          v113 = off_1E14A22C8[a3];
        *(_DWORD *)buf = 136448002;
        v153 = "nw_flow_passthrough_notify";
        v154 = 2082;
        v155 = (void *)id_string;
        v156 = 2082;
        v157 = v128;
        v158 = 2082;
        v159 = logging_description;
        v160 = 2082;
        v161 = v124;
        v162 = 2082;
        v163 = v110;
        v164 = 2114;
        v165 = v111;
        v166 = 2082;
        v167 = v113;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received notification %{public}s", buf, 0x52u);

      }
    }
    else
    {
      v18 = v15;
      v19 = *((_BYTE *)v18 + 268);

      if ((v19 & 0x20) != 0)
      {
LABEL_34:
        switch(a3)
        {
          case 7u:
          case 0x15u:
            goto LABEL_74;
          case 0xCu:
            v75 = *((char *)v14 + 34);
            if ((v75 & 0x80000000) == 0)
            {
              *((_BYTE *)v14 + 34) = v75 | 0x80;
              v146->event = (nw_endpoint_handler_event_s)524291;
              nw_endpoint_handler_report(v146, 0, &v146->event.domain, 0);
            }
            goto LABEL_70;
          case 0xDu:
          case 0xFu:
          case 0x10u:
LABEL_35:
            v38 = *(_QWORD *)(v9 + 32);
            if (!v38)
              goto LABEL_74;
            goto LABEL_71;
          case 0x13u:
LABEL_52:
            nw_endpoint_flow_rebuild_stack(v146, a2);
            goto LABEL_74;
          case 0x16u:
LABEL_37:
            if (*((_DWORD *)v14 + 251) <= 0x13u)
            {
              minimize_logging = nw_endpoint_handler_get_minimize_logging(v146);
              logging_disabled = nw_endpoint_handler_get_logging_disabled(v146);
              if (minimize_logging)
              {
                if ((logging_disabled & 1) != 0)
                  goto LABEL_45;
                v114 = v9;
                v137 = v14;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v41 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
                {
                  logc = nw_endpoint_handler_get_id_string(v146);
                  v115 = nw_endpoint_handler_dry_run_string(v146);
                  v116 = nw_endpoint_handler_copy_endpoint(v146);
                  v117 = nw_endpoint_get_logging_description(v116);
                  v118 = nw_endpoint_handler_state_string(v146);
                  v119 = nw_endpoint_handler_mode_string(v146);
                  v120 = nw_endpoint_handler_copy_current_path(v146);
                  v121 = *((_DWORD *)v137 + 251);
                  *(_DWORD *)buf = 136448002;
                  v153 = "nw_flow_passthrough_notify";
                  v154 = 2082;
                  v155 = (void *)logc;
                  v156 = 2082;
                  v157 = v115;
                  v158 = 2082;
                  v159 = v117;
                  v160 = 2082;
                  v161 = v118;
                  v162 = 2082;
                  v163 = v119;
                  v14 = v137;
                  v164 = 2114;
                  v165 = v120;
                  v166 = 1024;
                  LODWORD(v167) = v121;
                  _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with count %u, rebuilding stack", buf, 0x4Eu);

                  v9 = v114;
                }
              }
              else
              {
                if ((logging_disabled & 1) != 0)
                {
LABEL_45:
                  ++*((_DWORD *)v14 + 251);
                  nw_endpoint_flow_rebuild_stack(v146, (nw_protocol *)v9);
                  v146->event = (nw_endpoint_handler_event_s)262147;
                  nw_endpoint_handler_report(v146, 0, &v146->event.domain, 0);
                  goto LABEL_74;
                }
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v41 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
                {
                  loga = v41;
                  v42 = nw_endpoint_handler_get_id_string(v146);
                  v43 = nw_endpoint_handler_dry_run_string(v146);
                  v44 = nw_endpoint_handler_copy_endpoint(v146);
                  v139 = v9;
                  v45 = v14;
                  v46 = nw_endpoint_get_logging_description(v44);
                  v47 = nw_endpoint_handler_state_string(v146);
                  v48 = nw_endpoint_handler_mode_string(v146);
                  v49 = nw_endpoint_handler_copy_current_path(v146);
                  v50 = *((_DWORD *)v45 + 251);
                  *(_DWORD *)buf = 136448002;
                  v153 = "nw_flow_passthrough_notify";
                  v154 = 2082;
                  v155 = (void *)v42;
                  v156 = 2082;
                  v157 = v43;
                  v158 = 2082;
                  v159 = v46;
                  v160 = 2082;
                  v161 = v47;
                  v162 = 2082;
                  v163 = v48;
                  v14 = v45;
                  v164 = 2114;
                  v165 = v49;
                  v166 = 1024;
                  LODWORD(v167) = v50;
                  v41 = loga;
                  _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart with count %u, rebuilding stack", buf, 0x4Eu);

                  v9 = v139;
                }
              }

              goto LABEL_45;
            }
            if ((nw_endpoint_handler_get_logging_disabled(v146) & 1) != 0)
              goto LABEL_108;
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v57 = (id)gconnectionLogObj;
            v58 = nw_endpoint_handler_get_id_string(v146);
            v59 = nw_endpoint_handler_dry_run_string(v146);
            v136 = v14;
            v60 = nw_endpoint_handler_copy_endpoint(v146);
            v140 = v9;
            v61 = nw_endpoint_get_logging_description(v60);
            v62 = nw_endpoint_handler_state_string(v146);
            v63 = nw_endpoint_handler_mode_string(v146);
            v64 = nw_endpoint_handler_copy_current_path(v146);
            *(_DWORD *)buf = 136447746;
            v153 = "nw_flow_passthrough_notify";
            v154 = 2082;
            v155 = (void *)v58;
            v156 = 2082;
            v157 = v59;
            v158 = 2082;
            v159 = v61;
            v160 = 2082;
            v161 = v62;
            v162 = 2082;
            v163 = v63;
            v164 = 2114;
            v165 = v64;
            v65 = (char *)_os_log_send_and_compose_impl();

            v14 = v136;
            v9 = v140;

            type = OS_LOG_TYPE_ERROR;
            v150 = 0;
            if ((__nwlog_fault(v65, &type, &v150) & 1) == 0)
              goto LABEL_106;
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v66 = (id)gconnectionLogObj;
              v67 = type;
              if (os_log_type_enabled(v66, type))
              {
                v130 = v65;
                v68 = nw_endpoint_handler_get_id_string(v146);
                v69 = nw_endpoint_handler_dry_run_string(v146);
                v70 = nw_endpoint_handler_copy_endpoint(v146);
                v71 = nw_endpoint_get_logging_description(v70);
                v72 = nw_endpoint_handler_state_string(v146);
                v73 = nw_endpoint_handler_mode_string(v146);
                v74 = nw_endpoint_handler_copy_current_path(v146);
                *(_DWORD *)buf = 136447746;
                v153 = "nw_flow_passthrough_notify";
                v154 = 2082;
                v155 = (void *)v68;
                v156 = 2082;
                v157 = v69;
                v158 = 2082;
                v159 = v71;
                v160 = 2082;
                v161 = v72;
                v162 = 2082;
                v163 = v73;
                v164 = 2114;
                v165 = v74;
                _os_log_impl(&dword_182FBE000, v66, v67, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow", buf, 0x48u);

                v14 = v136;
                v9 = v140;
                v65 = v130;

              }
            }
            else if (v150)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v84 = (char *)backtrace_string;
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v85 = (id)gconnectionLogObj;
                v86 = type;
                if (os_log_type_enabled(v85, type))
                {
                  v131 = v65;
                  v87 = nw_endpoint_handler_get_id_string(v146);
                  logb = nw_endpoint_handler_dry_run_string(v146);
                  v88 = nw_endpoint_handler_copy_endpoint(v146);
                  v89 = nw_endpoint_get_logging_description(v88);
                  v90 = nw_endpoint_handler_state_string(v146);
                  v91 = nw_endpoint_handler_mode_string(v146);
                  v92 = nw_endpoint_handler_copy_current_path(v146);
                  *(_DWORD *)buf = 136448002;
                  v153 = "nw_flow_passthrough_notify";
                  v154 = 2082;
                  v155 = (void *)v87;
                  v156 = 2082;
                  v157 = logb;
                  v158 = 2082;
                  v159 = v89;
                  v160 = 2082;
                  v161 = v90;
                  v162 = 2082;
                  v163 = v91;
                  v164 = 2114;
                  v165 = v92;
                  v166 = 2082;
                  v167 = v84;
                  _os_log_impl(&dword_182FBE000, v85, v86, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow, dumping backtrace:%{public}s", buf, 0x52u);

                  v14 = v136;
                  v9 = v140;
                  v65 = v131;

                }
                free(v84);
                goto LABEL_106;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v66 = (id)gconnectionLogObj;
              v102 = type;
              if (os_log_type_enabled(v66, type))
              {
                v133 = v65;
                v103 = nw_endpoint_handler_get_id_string(v146);
                v104 = nw_endpoint_handler_dry_run_string(v146);
                v105 = nw_endpoint_handler_copy_endpoint(v146);
                v106 = nw_endpoint_get_logging_description(v105);
                v107 = nw_endpoint_handler_state_string(v146);
                v108 = nw_endpoint_handler_mode_string(v146);
                v109 = nw_endpoint_handler_copy_current_path(v146);
                *(_DWORD *)buf = 136447746;
                v153 = "nw_flow_passthrough_notify";
                v154 = 2082;
                v155 = (void *)v103;
                v156 = 2082;
                v157 = v104;
                v158 = 2082;
                v159 = v106;
                v160 = 2082;
                v161 = v107;
                v162 = 2082;
                v163 = v108;
                v164 = 2114;
                v165 = v109;
                _os_log_impl(&dword_182FBE000, v66, v102, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow, no backtrace", buf, 0x48u);

                v14 = v136;
                v9 = v140;
                v65 = v133;

              }
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v66 = (id)gconnectionLogObj;
              v94 = type;
              if (os_log_type_enabled(v66, type))
              {
                v132 = v65;
                v95 = nw_endpoint_handler_get_id_string(v146);
                v96 = nw_endpoint_handler_dry_run_string(v146);
                v97 = nw_endpoint_handler_copy_endpoint(v146);
                v98 = nw_endpoint_get_logging_description(v97);
                v99 = nw_endpoint_handler_state_string(v146);
                v100 = nw_endpoint_handler_mode_string(v146);
                v101 = nw_endpoint_handler_copy_current_path(v146);
                *(_DWORD *)buf = 136447746;
                v153 = "nw_flow_passthrough_notify";
                v154 = 2082;
                v155 = (void *)v95;
                v156 = 2082;
                v157 = v96;
                v158 = 2082;
                v159 = v98;
                v160 = 2082;
                v161 = v99;
                v162 = 2082;
                v163 = v100;
                v164 = 2114;
                v165 = v101;
                _os_log_impl(&dword_182FBE000, v66, v94, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received restart without connecting too many times, failing flow, backtrace limit exceeded", buf, 0x48u);

                v14 = v136;
                v9 = v140;
                v65 = v132;

              }
            }

LABEL_106:
            if (v65)
              free(v65);
LABEL_108:
            nw_protocol_disconnected((_QWORD *)v9, *(_QWORD *)(v9 + 32));
LABEL_74:

            goto LABEL_75;
          case 0x17u:
LABEL_46:
            if (a4 && a5 == 1)
            {
              v51 = *a4;
              v52 = *((_BYTE *)v14 + 35);
              *((_BYTE *)v14 + 35) = v52 & 0xEF | (16 * v51);
              if (!v51 && (v52 & 8) != 0)
              {
                *((_BYTE *)v14 + 35) = v52 & 0xE7 | (16 * v51);
                nw_endpoint_flow_start_child(v146);
              }
              goto LABEL_74;
            }
            __nwlog_obj();
            v53 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446210;
            v153 = "nw_flow_passthrough_notify";
            v54 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v150 = 0;
            if (!__nwlog_fault(v54, &type, &v150))
              goto LABEL_99;
            if (type == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v55 = objc_claimAutoreleasedReturnValue();
              v56 = type;
              if (os_log_type_enabled(v55, type))
              {
                *(_DWORD *)buf = 136446210;
                v153 = "nw_flow_passthrough_notify";
                _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child", buf, 0xCu);
              }
            }
            else
            {
              if (v150)
              {
                v78 = v14;
                v79 = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v80 = objc_claimAutoreleasedReturnValue();
                v81 = type;
                v82 = os_log_type_enabled(v80, type);
                if (v79)
                {
                  if (v82)
                  {
                    *(_DWORD *)buf = 136446466;
                    v153 = "nw_flow_passthrough_notify";
                    v154 = 2082;
                    v155 = v79;
                    _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  v14 = v78;
                  free(v79);
                }
                else
                {
                  if (v82)
                  {
                    *(_DWORD *)buf = 136446210;
                    v153 = "nw_flow_passthrough_notify";
                    _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child, no backtrace", buf, 0xCu);
                  }

                  v14 = v78;
                }
LABEL_99:
                if (v54)
                  free(v54);
                goto LABEL_74;
              }
              __nwlog_obj();
              v55 = objc_claimAutoreleasedReturnValue();
              v93 = type;
              if (os_log_type_enabled(v55, type))
              {
                *(_DWORD *)buf = 136446210;
                v153 = "nw_flow_passthrough_notify";
                _os_log_impl(&dword_182FBE000, v55, v93, "%{public}s Invalid argument passed to nw_protocol_notification_type_delay_child, backtrace limit exceeded", buf, 0xCu);
              }
            }

            goto LABEL_99;
          case 0x19u:
LABEL_51:
            v147[0] = MEMORY[0x1E0C809B0];
            v147[1] = 3221225472;
            v147[2] = ___ZL26nw_flow_passthrough_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke;
            v147[3] = &unk_1E149C8D8;
            v149 = v9;
            v148 = v146;
            nw_endpoint_handler_access_parent_flow_handler(v148, v147);

            goto LABEL_74;
          default:
LABEL_70:
            v38 = *(_QWORD *)(v9 + 48);
            if (v38)
            {
LABEL_71:
              v76 = *(_QWORD *)(v38 + 24);
              if (v76)
              {
                v77 = *(void (**)(void))(v76 + 160);
                if (v77)
                  v77();
              }
            }
            goto LABEL_74;
        }
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v20 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
LABEL_33:

        goto LABEL_34;
      }
      v138 = v9;
      log = v20;
      v135 = v14;
      v21 = v18;

      v22 = v21;
      v23 = *((_BYTE *)v18 + 268);

      if ((v23 & 1) != 0)
        v24 = "dry-run ";
      else
        v24 = "";
      v25 = nw_endpoint_handler_copy_endpoint(v22);
      v129 = nw_endpoint_get_logging_description(v25);
      v26 = v22;
      v27 = v26;
      v28 = v146->state;
      v127 = v24;
      if (v28 > 5)
        v29 = "unknown-state";
      else
        v29 = off_1E149FC48[v28];
      v125 = v29;
      v123 = v21 + 168;

      v30 = v27;
      v31 = v30;
      v122 = v25;
      v32 = "path";
      switch(v12->mode)
      {
        case 0:
          break;
        case 1:
          v32 = "resolver";
          break;
        case 2:
          v32 = nw_endpoint_flow_mode_string(v30[31]);
          break;
        case 3:
          v32 = "proxy";
          break;
        case 4:
          v32 = "fallback";
          break;
        case 5:
          v32 = "transform";
          break;
        default:
          v32 = "unknown-mode";
          break;
      }

      v33 = v31;
      os_unfair_lock_lock((os_unfair_lock_t)v33 + 28);
      v34 = v33[8];
      os_unfair_lock_unlock((os_unfair_lock_t)v33 + 28);

      v35 = v34;
      v36 = v35;
      if (a3 > 0x19)
        v37 = "unknown";
      else
        v37 = off_1E14A22C8[a3];
      v14 = v135;
      v9 = v138;
      *(_DWORD *)buf = 136448002;
      v153 = "nw_flow_passthrough_notify";
      v154 = 2082;
      v155 = v123;
      v156 = 2082;
      v157 = v127;
      v158 = 2082;
      v159 = v129;
      v160 = 2082;
      v161 = v125;
      v162 = 2082;
      v163 = v32;
      v164 = 2114;
      v165 = v35;
      v166 = 2082;
      v167 = v37;
      _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received notification %{public}s", buf, 0x52u);

    }
    v20 = log;
    goto LABEL_33;
  }
LABEL_75:

}

void sub_18316FD8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void nw_protocol_default_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  void (*v5)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_default_notify";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_default_notify";
      v9 = "%{public}s called with null protocol";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_default_notify";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_41:
        if (!v6)
          return;
LABEL_42:
        free(v6);
        return;
      }
      if (!v11)
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_default_notify";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_default_notify";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_40:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_41;
  }
  if (a2)
  {
    if (a3 <= 0x15)
    {
      if (((1 << a3) & 0x1A000) != 0)
      {
        v3 = *(_QWORD *)(a1 + 32);
        if (!v3)
          return;
LABEL_10:
        v4 = *(_QWORD *)(v3 + 24);
        if (v4)
        {
          v5 = *(void (**)(void))(v4 + 160);
          if (v5)
            v5();
        }
        return;
      }
      if (((1 << a3) & 0x200080) != 0)
        return;
    }
    v3 = *(_QWORD *)(a1 + 48);
    if (!v3)
      return;
    goto LABEL_10;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_default_notify";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_default_notify";
    v9 = "%{public}s called with null other_protocol";
    goto LABEL_40;
  }
  if (!v14)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_default_notify";
    v9 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_40;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13)
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_default_notify";
    v9 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_40;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v17 = "nw_protocol_default_notify";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v6)
    goto LABEL_42;
}

void nw_protocol_ipv4_notify(uint64_t a1, uint64_t a2, unsigned int a3, _BYTE *a4, uint64_t a5)
{
  uint64_t v8;
  char v9;
  NSObject *v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t);
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  void (**v20)(_QWORD);
  const void *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  char *backtrace_string;
  _BOOL4 v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  _BOOL4 v31;
  const char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  const char *v36;
  _BOOL4 v37;
  _BOOL4 v38;
  _BOOL4 v39;
  char *v40;
  _BOOL4 v41;
  const char *v42;
  const char *v43;
  const char *v44;
  char *v45;
  char v46;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  void *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  char *v55;
  __int16 v56;
  int v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null protocol";
    }
    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v27 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          v49 = "nw_protocol_ipv4_notify";
          v50 = 2082;
          v51 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_131:
        if (!v22)
          return;
        goto LABEL_132;
      }
      if (!v27)
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_130;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv4_notify";
        v25 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_130;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v29 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v29)
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv4_notify";
        v25 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_130;
      }
      if (!v29)
        goto LABEL_99;
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv4_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_131;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v25 = "%{public}s called with null ipv4";
LABEL_130:
    _os_log_impl(&dword_182FBE000, v23, v24, v25, buf, 0xCu);
    goto LABEL_131;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv4_notify";
        v25 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_130;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v31 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v31)
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv4_notify";
        v25 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_130;
      }
      if (!v31)
        goto LABEL_99;
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv4_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_131;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v25 = "%{public}s called with null other_protocol";
    goto LABEL_130;
  }
  v8 = a1 + 96;
  if (a3 == 17)
  {
    if (*(_QWORD *)(a1 + 32) != a2)
      goto LABEL_13;
    v12 = *(void **)(a2 + 40);
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      v13 = *(_QWORD *)(a2 + 88);
      if (v13)
        *(_QWORD *)(a2 + 88) = v13 + 1;
    }
    v14 = *(_QWORD *)(a2 + 24);
    if (v14)
    {
      v15 = *(uint64_t (**)(uint64_t))(v14 + 200);
      if (v15)
      {
        v16 = v15(a2);
        if (v12 != &nw_protocol_ref_counted_handle)
        {
LABEL_22:
          if (v16)
          {
            if (nw_endpoint_get_address_family(v16) == 2)
            {
              *(_DWORD *)(a1 + 152) = *(_DWORD *)&nw_endpoint_get_address(v16)->sa_data[2];
              if ((*(_BYTE *)(a1 + 232) & 1) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v17 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)buf = 136446978;
                  v49 = "nw_protocol_ipv4_notify";
                  v50 = 2082;
                  v51 = (void *)(a1 + 233);
                  v52 = 2080;
                  v53 = " ";
                  v54 = 2048;
                  v55 = (char *)v8;
                  _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p updated local address", buf, 0x2Au);
                }
              }
            }
          }
          goto LABEL_13;
        }
LABEL_21:
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          v18 = *(_QWORD *)(a2 + 88);
          if (v18)
          {
            v19 = v18 - 1;
            *(_QWORD *)(a2 + 88) = v19;
            if (!v19)
            {
              v20 = *(void (***)(_QWORD))(a2 + 64);
              if (v20)
              {
                *(_QWORD *)(a2 + 64) = 0;
                v20[2](v20);
                _Block_release(v20);
              }
              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                v21 = *(const void **)(a2 + 64);
                if (v21)
                  _Block_release(v21);
              }
              free((void *)a2);
            }
          }
        }
        goto LABEL_22;
      }
    }
    __nwlog_obj();
    v32 = *(const char **)(a2 + 16);
    *(_DWORD *)buf = 136446722;
    v49 = "__nw_protocol_get_output_local_endpoint";
    if (!v32)
      v32 = "invalid";
    v50 = 2082;
    v51 = (void *)v32;
    v52 = 2048;
    v53 = (const char *)a2;
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    v45 = (char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v45, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_138;
        v35 = *(const char **)(a2 + 16);
        if (!v35)
          v35 = "invalid";
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v35;
        v52 = 2048;
        v53 = (const char *)a2;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback";
LABEL_137:
        _os_log_impl(&dword_182FBE000, v33, v34, v36, buf, 0x20u);
        goto LABEL_138;
      }
      if (!v46)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_138;
        v43 = *(const char **)(a2 + 16);
        if (!v43)
          v43 = "invalid";
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v43;
        v52 = 2048;
        v53 = (const char *)a2;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, backtrace limit exceeded";
        goto LABEL_137;
      }
      v40 = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v41 = os_log_type_enabled(v33, type);
      if (!v40)
      {
        v8 = a1 + 96;
        if (!v41)
          goto LABEL_138;
        v44 = *(const char **)(a2 + 16);
        if (!v44)
          v44 = "invalid";
        *(_DWORD *)buf = 136446722;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v44;
        v52 = 2048;
        v53 = (const char *)a2;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, no backtrace";
        goto LABEL_137;
      }
      if (v41)
      {
        v42 = *(const char **)(a2 + 16);
        if (!v42)
          v42 = "invalid";
        *(_DWORD *)buf = 136446978;
        v49 = "__nw_protocol_get_output_local_endpoint";
        v50 = 2082;
        v51 = (void *)v42;
        v52 = 2048;
        v53 = (const char *)a2;
        v54 = 2082;
        v55 = v40;
        _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v40);
      v8 = a1 + 96;
    }
LABEL_138:
    if (v45)
      free(v45);
    v16 = 0;
    if (v12 != &nw_protocol_ref_counted_handle)
      goto LABEL_22;
    goto LABEL_21;
  }
  if (a3 != 14)
  {
LABEL_13:
    nw_protocol_common_notify(a1, a2, a3);
    return;
  }
  if (*(_QWORD *)(a1 + 48) != a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v46)
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (!os_log_type_enabled(v23, type))
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv4_notify";
        v25 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv4->protocol)), backtrace limit exceeded";
        goto LABEL_130;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v23 = __nwlog_obj();
      v24 = type;
      v37 = os_log_type_enabled(v23, type);
      if (!v28)
      {
        if (!v37)
          goto LABEL_131;
        *(_DWORD *)buf = 136446210;
        v49 = "nw_protocol_ipv4_notify";
        v25 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv4->protocol)), no backtrace";
        goto LABEL_130;
      }
      if (!v37)
        goto LABEL_99;
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv4_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv4->protocol)), dumping back"
            "trace:%{public}s";
      goto LABEL_98;
    }
    v23 = __nwlog_obj();
    v24 = type;
    if (!os_log_type_enabled(v23, type))
      goto LABEL_131;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v25 = "%{public}s called with null (other_protocol == nw_protocol_get_input_handler(&ipv4->protocol))";
    goto LABEL_130;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null (val != nil)";
      goto LABEL_130;
    }
    if (!v46)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null (val != nil), backtrace limit exceeded";
      goto LABEL_130;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type;
    v38 = os_log_type_enabled(v23, type);
    if (!v28)
    {
      if (!v38)
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null (val != nil), no backtrace";
      goto LABEL_130;
    }
    if (!v38)
      goto LABEL_99;
    *(_DWORD *)buf = 136446466;
    v49 = "nw_protocol_ipv4_notify";
    v50 = 2082;
    v51 = v28;
    v30 = "%{public}s called with null (val != nil), dumping backtrace:%{public}s";
LABEL_98:
    _os_log_impl(&dword_182FBE000, v23, v24, v30, buf, 0x16u);
    goto LABEL_99;
  }
  if (a5 != 1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v49 = "nw_protocol_ipv4_notify";
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v22, &type, &v46))
      goto LABEL_131;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null (len == sizeof(BOOL))";
      goto LABEL_130;
    }
    if (!v46)
    {
      v23 = __nwlog_obj();
      v24 = type;
      if (!os_log_type_enabled(v23, type))
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null (len == sizeof(BOOL)), backtrace limit exceeded";
      goto LABEL_130;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v23 = __nwlog_obj();
    v24 = type;
    v39 = os_log_type_enabled(v23, type);
    if (!v28)
    {
      if (!v39)
        goto LABEL_131;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_protocol_ipv4_notify";
      v25 = "%{public}s called with null (len == sizeof(BOOL)), no backtrace";
      goto LABEL_130;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v49 = "nw_protocol_ipv4_notify";
      v50 = 2082;
      v51 = v28;
      v30 = "%{public}s called with null (len == sizeof(BOOL)), dumping backtrace:%{public}s";
      goto LABEL_98;
    }
LABEL_99:
    free(v28);
    if (!v22)
      return;
LABEL_132:
    free(v22);
    return;
  }
  v9 = *(_BYTE *)(a1 + 232);
  *(_BYTE *)(a1 + 232) = v9 & 0xFB | (4 * *a4);
  if ((v9 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v11 = (*(unsigned __int8 *)(a1 + 232) >> 2) & 1;
      *(_DWORD *)buf = 136447234;
      v49 = "nw_protocol_ipv4_notify";
      v50 = 2082;
      v51 = (void *)(a1 + 233);
      v52 = 2080;
      v53 = " ";
      v54 = 2048;
      v55 = (char *)(a1 + 96);
      v56 = 1024;
      v57 = v11;
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p segmentation offload notify enable %d", buf, 0x30u);
    }
  }
}

void nw_protocol_common_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, uint64_t);
  void *v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  uint64_t v13;
  char *v14;
  _BOOL4 v15;
  const char *v16;
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (**v24)(_QWORD);
  const void *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  void (**v29)(_QWORD);
  const void *v30;
  _BOOL4 v31;
  char *backtrace_string;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_common_notify";
    v9 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v9, &type, &v36))
      goto LABEL_76;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v33 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_protocol_common_notify";
            v40 = 2082;
            v41 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_protocol_common_notify";
          v12 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_75;
        }
      }
      else
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_protocol_common_notify";
          v12 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_75;
        }
      }
      goto LABEL_76;
    }
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_76;
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_common_notify";
    v12 = "%{public}s called with null protocol";
LABEL_75:
    _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
    goto LABEL_76;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_common_notify";
    v9 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v9, &type, &v36))
      goto LABEL_76;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v36)
      {
        v14 = (char *)__nw_create_backtrace_string();
        v10 = __nwlog_obj();
        v11 = type;
        v34 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_protocol_common_notify";
            v40 = 2082;
            v41 = v14;
            v16 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_66;
          }
          goto LABEL_67;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_protocol_common_notify";
          v12 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_75;
        }
      }
      else
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v39 = "nw_protocol_common_notify";
          v12 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_75;
        }
      }
      goto LABEL_76;
    }
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_76;
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_common_notify";
    v12 = "%{public}s called with null other_protocol";
    goto LABEL_75;
  }
  if (a3 <= 0x15)
  {
    if (((1 << a3) & 0x200080) != 0)
      return;
    if (((1 << a3) & 0x1A000) != 0)
    {
      v4 = *(_QWORD *)(a1 + 32);
      if (v4)
      {
        v5 = *(_QWORD *)(v4 + 24);
        if (!v5)
          return;
        v6 = *(void (**)(uint64_t, uint64_t))(v5 + 160);
        if (!v6)
          return;
        v7 = *(void **)(v4 + 40);
        if (v7 == &nw_protocol_ref_counted_handle)
        {
          v8 = *(_QWORD *)(v4 + 88);
          if (v8)
            *(_QWORD *)(v4 + 88) = v8 + 1;
        }
        if (*(_UNKNOWN **)(a2 + 40) != &nw_protocol_ref_counted_handle)
        {
          v6(v4, a2);
          goto LABEL_38;
        }
        v13 = *(_QWORD *)(a2 + 88);
        if (v13)
          *(_QWORD *)(a2 + 88) = v13 + 1;
        v6(v4, a2);
        goto LABEL_37;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_common_notify";
      v9 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v36 = 0;
      if (!__nwlog_fault(v9, &type, &v36))
        goto LABEL_76;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        v11 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_76;
        *(_DWORD *)buf = 136446210;
        v39 = "nw_protocol_common_notify";
        v12 = "%{public}s notify requires an output handler";
        goto LABEL_75;
      }
      if (!v36)
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
          goto LABEL_76;
        *(_DWORD *)buf = 136446210;
        v39 = "nw_protocol_common_notify";
        v12 = "%{public}s notify requires an output handler, backtrace limit exceeded";
        goto LABEL_75;
      }
      v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v14)
      {
        if (!v15)
          goto LABEL_76;
        *(_DWORD *)buf = 136446210;
        v39 = "nw_protocol_common_notify";
        v12 = "%{public}s notify requires an output handler, no backtrace";
        goto LABEL_75;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v39 = "nw_protocol_common_notify";
        v40 = 2082;
        v41 = v14;
        v16 = "%{public}s notify requires an output handler, dumping backtrace:%{public}s";
LABEL_66:
        _os_log_impl(&dword_182FBE000, v10, v11, v16, buf, 0x16u);
        goto LABEL_67;
      }
      goto LABEL_67;
    }
    if (!a3)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_common_notify";
      v9 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v36 = 0;
      if (__nwlog_fault(v9, &type, &v36))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v10 = __nwlog_obj();
          v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446210;
            v39 = "nw_protocol_common_notify";
            v12 = "%{public}s called with null type";
            goto LABEL_75;
          }
        }
        else if (v36)
        {
          v14 = (char *)__nw_create_backtrace_string();
          v10 = __nwlog_obj();
          v11 = type;
          v35 = os_log_type_enabled(v10, type);
          if (v14)
          {
            if (v35)
            {
              *(_DWORD *)buf = 136446466;
              v39 = "nw_protocol_common_notify";
              v40 = 2082;
              v41 = v14;
              v16 = "%{public}s called with null type, dumping backtrace:%{public}s";
              goto LABEL_66;
            }
            goto LABEL_67;
          }
          if (v35)
          {
            *(_DWORD *)buf = 136446210;
            v39 = "nw_protocol_common_notify";
            v12 = "%{public}s called with null type, no backtrace";
            goto LABEL_75;
          }
        }
        else
        {
          v10 = __nwlog_obj();
          v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446210;
            v39 = "nw_protocol_common_notify";
            v12 = "%{public}s called with null type, backtrace limit exceeded";
            goto LABEL_75;
          }
        }
      }
LABEL_76:
      if (!v9)
        return;
      goto LABEL_77;
    }
  }
  v4 = *(_QWORD *)(a1 + 48);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_common_notify";
    v9 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v9, &type, &v36))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_common_notify";
      v12 = "%{public}s notify requires a default input handler";
      goto LABEL_75;
    }
    if (!v36)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_common_notify";
      v12 = "%{public}s notify requires a default input handler, backtrace limit exceeded";
      goto LABEL_75;
    }
    v14 = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v31 = os_log_type_enabled(v10, type);
    if (!v14)
    {
      if (!v31)
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_common_notify";
      v12 = "%{public}s notify requires a default input handler, no backtrace";
      goto LABEL_75;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v39 = "nw_protocol_common_notify";
      v40 = 2082;
      v41 = v14;
      v16 = "%{public}s notify requires a default input handler, dumping backtrace:%{public}s";
      goto LABEL_66;
    }
LABEL_67:
    free(v14);
    if (!v9)
      return;
LABEL_77:
    v26 = (char *)v9;
LABEL_78:
    free(v26);
    return;
  }
  v17 = *(_QWORD *)(v4 + 24);
  if (!v17)
    return;
  v18 = *(void (**)(uint64_t, uint64_t))(v17 + 160);
  if (!v18)
    return;
  v7 = *(void **)(v4 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    v19 = *(_QWORD *)(v4 + 88);
    if (v19)
      *(_QWORD *)(v4 + 88) = v19 + 1;
  }
  v20 = *(void **)(a2 + 40);
  if (v20 == &nw_protocol_ref_counted_handle)
  {
    v21 = *(_QWORD *)(a2 + 88);
    if (v21)
      *(_QWORD *)(a2 + 88) = v21 + 1;
  }
  v18(v4, a2);
  if (v20 == &nw_protocol_ref_counted_handle)
  {
LABEL_37:
    if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
    {
      v27 = *(_QWORD *)(a2 + 88);
      if (v27)
      {
        v28 = v27 - 1;
        *(_QWORD *)(a2 + 88) = v28;
        if (!v28)
        {
          v29 = *(void (***)(_QWORD))(a2 + 64);
          if (v29)
          {
            *(_QWORD *)(a2 + 64) = 0;
            v29[2](v29);
            _Block_release(v29);
          }
          if ((*(_BYTE *)(a2 + 72) & 1) != 0)
          {
            v30 = *(const void **)(a2 + 64);
            if (v30)
              _Block_release(v30);
          }
          free((void *)a2);
        }
      }
    }
  }
LABEL_38:
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    v22 = *(_QWORD *)(v4 + 88);
    if (v22)
    {
      v23 = v22 - 1;
      *(_QWORD *)(v4 + 88) = v23;
      if (!v23)
      {
        v24 = *(void (***)(_QWORD))(v4 + 64);
        if (v24)
        {
          *(_QWORD *)(v4 + 64) = 0;
          v24[2](v24);
          _Block_release(v24);
        }
        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          v25 = *(const void **)(v4 + 64);
          if (v25)
            _Block_release(v25);
        }
        v26 = (char *)v4;
        goto LABEL_78;
      }
    }
  }
}

BOOL __nw_dispatch_data_copyout_block_invoke(_QWORD *a1, int a2, int a3, void *__src, size_t a5)
{
  unint64_t v5;
  unint64_t v6;
  size_t v7;

  v5 = a1[6];
  v6 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (v5 - v6 >= a5)
    v7 = a5;
  else
    v7 = v5 - v6;
  if (v7)
  {
    memcpy((void *)(*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) + v6), __src, v7);
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += v7;
    v6 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v5 = a1[6];
  }
  return v6 < v5;
}

void nw_parameters_get_proc_uuid(void *a1, _OWORD *a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(*((_QWORD *)v3 + 13) + 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_proc_uuid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_proc_uuid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_proc_uuid";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_proc_uuid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_proc_uuid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

const char *nw_parameters_get_url(void *a1)
{
  NSObject **v1;
  NSObject **v2;
  NSObject *v3;
  const char *url;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_get_url";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_url";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_get_url";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_url";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_url";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = v1[25];
  if (!v3)
  {
LABEL_22:
    url = 0;
    goto LABEL_23;
  }
  url = nw_endpoint_get_url(v3);
LABEL_23:

  return url;
}

void sub_1831724DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

xpc_object_t nw_parameters_copy_dictionary(void *a1)
{
  char *v1;
  xpc_object_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  const char *url;
  NSObject *v14;
  NSObject *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  int64_t v20;
  uint64_t v21;
  __int16 v22;
  xpc_object_t *v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  xpc_object_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v39;
  __int128 v40;

  v1 = a1;
  if (v1)
  {
    v2 = xpc_dictionary_create(0, 0, 0);
    v3 = nw_interface_copy_dictionary(*(void **)(*((_QWORD *)v1 + 13) + 168));
    if (v3)
      xpc_dictionary_set_value(v2, "required_interface", v3);
    v4 = *((_QWORD *)v1 + 13);
    v5 = *(unsigned int *)(v4 + 76);
    if ((_DWORD)v5)
    {
      xpc_dictionary_set_uint64(v2, "required_interface_type", v5);
      v4 = *((_QWORD *)v1 + 13);
    }
    xpc_dictionary_set_BOOL(v2, "only_primary_requires_type", (*(_WORD *)(v4 + 100) & 0x20) != 0);
    v6 = (unsigned int *)*((_QWORD *)v1 + 13);
    v7 = v6[20];
    if ((_DWORD)v7)
    {
      xpc_dictionary_set_uint64(v2, "required_interface_subtype", v7);
      v6 = (unsigned int *)*((_QWORD *)v1 + 13);
    }
    v8 = v6[23];
    if ((_DWORD)v8)
    {
      xpc_dictionary_set_uint64(v2, "next_hop_required_interface_type", v8);
      v6 = (unsigned int *)*((_QWORD *)v1 + 13);
    }
    v9 = v6[24];
    if ((_DWORD)v9)
      xpc_dictionary_set_uint64(v2, "next_hop_required_interface_subtype", v9);
    v10 = (const char *)*((_QWORD *)v1 + 14);
    if (v10)
      xpc_dictionary_set_string(v2, "effective_bundle_id", v10);
    v39 = *(_OWORD *)(v1 + 40);
    v40 = *(_OWORD *)(v1 + 56);
    if ((unint64_t)v39 | *((_QWORD *)&v39 + 1) | (unint64_t)v40 | *((_QWORD *)&v40 + 1))
      xpc_dictionary_set_data(v2, "effective_audit_token", v1 + 40, 0x20uLL);
    v11 = *((_QWORD *)v1 + 13);
    v12 = *(const char **)(v11 + 112);
    if (v12)
    {
      xpc_dictionary_set_string(v2, "account_id", v12);
      v11 = *((_QWORD *)v1 + 13);
    }
    url = *(const char **)(v11 + 120);
    if (url)
      xpc_dictionary_set_string(v2, "attribution_context", url);
    v14 = *((_QWORD *)v1 + 25);
    if (v14)
    {
      url = nw_endpoint_get_url(v14);
      if (url)
        xpc_dictionary_set_string(v2, "url", url);
    }
    v15 = *((_QWORD *)v1 + 26);
    if (v15)
    {
      url = nw_endpoint_get_url(v15);
      if (url)
        xpc_dictionary_set_string(v2, "main_document_url", url);
    }
    v16 = (void *)objc_msgSend(*(id *)(*((_QWORD *)v1 + 13) + 160), "copyDictionary", url, v39, v40);
    if (v16)
      xpc_dictionary_set_value(v2, "local_address", v16);
    if ((v1[97] & 1) != 0)
      xpc_dictionary_set_BOOL(v2, "reuse_local_address", 1);
    xpc_dictionary_set_value(v2, "tls_session_id", *((xpc_object_t *)v1 + 16));
    v17 = *((_QWORD *)v1 + 13);
    v18 = *(unsigned int *)(v17 + 72);
    if ((_DWORD)v18)
    {
      xpc_dictionary_set_uint64(v2, "traffic_class", v18);
      v17 = *((_QWORD *)v1 + 13);
    }
    v19 = *(int *)(v17 + 64);
    if ((_DWORD)v19)
    {
      xpc_dictionary_set_int64(v2, "pid", v19);
      v17 = *((_QWORD *)v1 + 13);
    }
    v20 = *(unsigned int *)(v17 + 68);
    if ((_DWORD)v20)
    {
      xpc_dictionary_set_int64(v2, "uid", v20);
      v17 = *((_QWORD *)v1 + 13);
    }
    xpc_dictionary_set_uuid(v2, "proc_uuid", (const unsigned __int8 *)(v17 + 8));
    xpc_dictionary_set_uuid(v2, "e_proc_uuid", (const unsigned __int8 *)(*((_QWORD *)v1 + 13) + 24));
    xpc_dictionary_set_uuid(v2, "persona_id", (const unsigned __int8 *)(*((_QWORD *)v1 + 13) + 40));
    xpc_dictionary_set_uuid(v2, "parent_id", (const unsigned __int8 *)v1 + 8);
    if ((v1[96] & 1) != 0)
      xpc_dictionary_set_BOOL(v2, "dry_run", 1);
    v21 = *((_QWORD *)v1 + 13);
    v22 = *(_WORD *)(v21 + 100);
    if ((v22 & 1) != 0)
    {
      xpc_dictionary_set_BOOL(v2, "prohibit_expensive", 1);
      v21 = *((_QWORD *)v1 + 13);
      v22 = *(_WORD *)(v21 + 100);
      if ((v22 & 2) == 0)
      {
LABEL_40:
        if ((v22 & 4) == 0)
          goto LABEL_41;
        goto LABEL_47;
      }
    }
    else if ((v22 & 2) == 0)
    {
      goto LABEL_40;
    }
    xpc_dictionary_set_BOOL(v2, "prohibit_constrained", 1);
    v21 = *((_QWORD *)v1 + 13);
    v22 = *(_WORD *)(v21 + 100);
    if ((v22 & 4) == 0)
    {
LABEL_41:
      if ((v22 & 8) == 0)
        goto LABEL_42;
      goto LABEL_48;
    }
LABEL_47:
    xpc_dictionary_set_BOOL(v2, "allow_ultra_constrained", 1);
    v21 = *((_QWORD *)v1 + 13);
    if ((*(_WORD *)(v21 + 100) & 8) == 0)
    {
LABEL_42:
      v23 = *(xpc_object_t **)(v21 + 176);
      if (!v23)
      {
LABEL_50:
        xpc_dictionary_set_value(v2, "extra_parent_ids", *((xpc_object_t *)v1 + 17));
        v24 = *((_QWORD *)v1 + 12);
        if ((v24 & 0x200000000000) != 0)
        {
          xpc_dictionary_set_BOOL(v2, "trust_invalid_certs", 1);
          v24 = *((_QWORD *)v1 + 12);
          if ((v24 & 0x400000000000) == 0)
          {
LABEL_52:
            if ((v24 & 8) == 0)
              goto LABEL_54;
            goto LABEL_53;
          }
        }
        else if ((v24 & 0x400000000000) == 0)
        {
          goto LABEL_52;
        }
        xpc_dictionary_set_BOOL(v2, "should_skip_probe_sampling", 1);
        if ((*((_QWORD *)v1 + 12) & 8) == 0)
        {
LABEL_54:
          v25 = *(_WORD *)(*((_QWORD *)v1 + 13) + 108);
          if ((v25 & 8) != 0)
          {
            xpc_dictionary_set_BOOL(v2, "use_awdl", 1);
            if ((*(_WORD *)(*((_QWORD *)v1 + 13) + 108) & 0x10) == 0)
            {
LABEL_56:
              v26 = *((_QWORD *)v1 + 12);
              if ((v26 & 0x20) == 0)
                goto LABEL_58;
              goto LABEL_57;
            }
          }
          else if ((v25 & 0x10) == 0)
          {
            goto LABEL_56;
          }
          xpc_dictionary_set_BOOL(v2, "use_p2p", 1);
          v26 = *((_QWORD *)v1 + 12);
          if ((v26 & 0x20) == 0)
          {
LABEL_58:
            if ((~(_BYTE)v26 & 0xC0) == 0)
              xpc_dictionary_set_BOOL(v2, "indefinite", 1);
            v27 = *(_WORD *)(*((_QWORD *)v1 + 13) + 108);
            if ((v27 & 2) != 0)
            {
              xpc_dictionary_set_BOOL(v2, "no_proxy", 1);
              v27 = *(_WORD *)(*((_QWORD *)v1 + 13) + 108);
              if ((v27 & 4) == 0)
              {
LABEL_62:
                if ((v27 & 0x20) == 0)
                  goto LABEL_63;
                goto LABEL_115;
              }
            }
            else if ((v27 & 4) == 0)
            {
              goto LABEL_62;
            }
            xpc_dictionary_set_BOOL(v2, "no_transform", 1);
            if ((*(_WORD *)(*((_QWORD *)v1 + 13) + 108) & 0x20) == 0)
            {
LABEL_63:
              if ((v1[97] & 0x80) == 0)
                goto LABEL_65;
              goto LABEL_64;
            }
LABEL_115:
            xpc_dictionary_set_BOOL(v2, "no_fallback", 1);
            if ((v1[97] & 0x80) == 0)
            {
LABEL_65:
              v28 = *(unsigned int *)(*((_QWORD *)v1 + 13) + 103);
              if ((_DWORD)v28)
                xpc_dictionary_set_uint64(v2, "multipath_service", v28);
              if (v1[92])
                xpc_dictionary_set_uint64(v2, "data_mode", v1[92]);
              v29 = *((unsigned int *)v1 + 22);
              if ((_DWORD)v29)
                xpc_dictionary_set_uint64(v2, "sleep_keepalive_interval", v29);
              if ((v1[97] & 8) != 0)
                xpc_dictionary_set_BOOL(v2, "custom_protocols_only", 1);
              if ((*(_WORD *)(*((_QWORD *)v1 + 13) + 108) & 1) != 0)
              {
                xpc_dictionary_set_BOOL(v2, "discretionary", 1);
                v30 = *((_QWORD *)v1 + 12);
                if ((v30 & 0x4000) == 0)
                {
LABEL_75:
                  if ((v30 & 0x200) == 0)
                    goto LABEL_76;
                  goto LABEL_119;
                }
              }
              else
              {
                v30 = *((_QWORD *)v1 + 12);
                if ((v30 & 0x4000) == 0)
                  goto LABEL_75;
              }
              xpc_dictionary_set_BOOL(v2, "local_only", 1);
              if ((*((_QWORD *)v1 + 12) & 0x200) == 0)
              {
LABEL_76:
                v31 = v1[93];
                if (!v1[93])
                  goto LABEL_78;
                goto LABEL_77;
              }
LABEL_119:
              xpc_dictionary_set_BOOL(v2, "receive_any_interface", 1);
              v31 = v1[93];
              if (!v1[93])
              {
LABEL_78:
                v32 = *(unsigned int *)(*((_QWORD *)v1 + 13) + 84);
                if ((_DWORD)v32)
                  xpc_dictionary_set_uint64(v2, "companion_preference", v32);
                v33 = *((_QWORD *)v1 + 18);
                if (v33)
                {
                  v34 = xpc_data_create_with_dispatch_data(v33);
                  xpc_dictionary_set_value(v2, "initial_data_payload", v34);

                }
                if ((v1[98] & 8) != 0)
                  xpc_dictionary_set_BOOL(v2, "allow_unusable_addresses", 1);
                if ((*(_WORD *)(*((_QWORD *)v1 + 13) + 108) & 0x100) != 0)
                {
                  xpc_dictionary_set_BOOL(v2, "prefer_no_proxy", 1);
                  v35 = *((_QWORD *)v1 + 12);
                  if ((v35 & 0x100000) == 0)
                  {
LABEL_86:
                    if ((v35 & 0x200000) == 0)
                      goto LABEL_87;
                    goto LABEL_123;
                  }
                }
                else
                {
                  v35 = *((_QWORD *)v1 + 12);
                  if ((v35 & 0x100000) == 0)
                    goto LABEL_86;
                }
                xpc_dictionary_set_BOOL(v2, "https_proxy_is_opaque", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x200000) == 0)
                {
LABEL_87:
                  if ((v35 & 0x400000) == 0)
                    goto LABEL_88;
                  goto LABEL_124;
                }
LABEL_123:
                xpc_dictionary_set_BOOL(v2, "https_proxy_over_tls", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x400000) == 0)
                {
LABEL_88:
                  if ((v35 & 0x800000) == 0)
                    goto LABEL_89;
                  goto LABEL_125;
                }
LABEL_124:
                xpc_dictionary_set_BOOL(v2, "attach_protocol_listener", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x800000) == 0)
                {
LABEL_89:
                  if ((v35 & 0x1000000) == 0)
                    goto LABEL_90;
                  goto LABEL_126;
                }
LABEL_125:
                xpc_dictionary_set_BOOL(v2, "prohibit_joining_protocols", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x1000000) == 0)
                {
LABEL_90:
                  if ((v35 & 0x4000000) == 0)
                    goto LABEL_91;
                  goto LABEL_127;
                }
LABEL_126:
                xpc_dictionary_set_BOOL(v2, "allow_joining_connected_fd", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x4000000) == 0)
                {
LABEL_91:
                  if ((v35 & 0x8000000) == 0)
                    goto LABEL_92;
                  goto LABEL_128;
                }
LABEL_127:
                xpc_dictionary_set_BOOL(v2, "allow_duplicate_state_updates", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x8000000) == 0)
                {
LABEL_92:
                  if ((v35 & 0x10000000) == 0)
                    goto LABEL_93;
                  goto LABEL_129;
                }
LABEL_128:
                xpc_dictionary_set_BOOL(v2, "always_open_listener_socket", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x10000000) == 0)
                {
LABEL_93:
                  if ((v35 & 0x20000000) == 0)
                    goto LABEL_94;
                  goto LABEL_130;
                }
LABEL_129:
                xpc_dictionary_set_BOOL(v2, "never_open_listener_socket", 1);
                v35 = *((_QWORD *)v1 + 12);
                if ((v35 & 0x20000000) == 0)
                {
LABEL_94:
                  if ((v35 & 0x40000000) == 0)
                    goto LABEL_96;
                  goto LABEL_95;
                }
LABEL_130:
                xpc_dictionary_set_BOOL(v2, "disable_listener_datapath", 1);
                if ((*((_QWORD *)v1 + 12) & 0x40000000) == 0)
                {
LABEL_96:
                  v36 = *((_QWORD *)v1 + 13);
                  if ((*(_WORD *)(v36 + 108) & 0x4000) != 0)
                  {
                    xpc_dictionary_set_BOOL(v2, "known_tracker", 1);
                    v36 = *((_QWORD *)v1 + 13);
                  }
                  if (*(_BYTE *)(v36 + 102))
                    xpc_dictionary_set_uint64(v2, "attribution", *(unsigned __int8 *)(v36 + 102));
                  v37 = *((_QWORD *)v1 + 12);
                  if ((v37 & 0x800000000) != 0)
                  {
                    xpc_dictionary_set_BOOL(v2, "include_ble", 1);
                    v37 = *((_QWORD *)v1 + 12);
                    if ((v37 & 0x1000000000) == 0)
                    {
LABEL_102:
                      if ((v37 & 0x2000000000) == 0)
                        goto LABEL_103;
                      goto LABEL_134;
                    }
                  }
                  else if ((v37 & 0x1000000000) == 0)
                  {
                    goto LABEL_102;
                  }
                  xpc_dictionary_set_BOOL(v2, "screen_off", 1);
                  v37 = *((_QWORD *)v1 + 12);
                  if ((v37 & 0x2000000000) == 0)
                  {
LABEL_103:
                    if ((v37 & 0x4000000000) == 0)
                    {
LABEL_105:
                      xpc_dictionary_set_value(v2, "metadata", *((xpc_object_t *)v1 + 27));

                      goto LABEL_106;
                    }
LABEL_104:
                    xpc_dictionary_set_BOOL(v2, "minimize_logging", 1);
                    goto LABEL_105;
                  }
LABEL_134:
                  xpc_dictionary_set_BOOL(v2, "internet_fallback", 1);
                  if ((*((_QWORD *)v1 + 12) & 0x4000000000) == 0)
                    goto LABEL_105;
                  goto LABEL_104;
                }
LABEL_95:
                xpc_dictionary_set_BOOL(v2, "requires_dnssec_validation", 1);
                goto LABEL_96;
              }
LABEL_77:
              xpc_dictionary_set_uint64(v2, "ecn_mode", v31);
              goto LABEL_78;
            }
LABEL_64:
            xpc_dictionary_set_BOOL(v2, "server", 1);
            goto LABEL_65;
          }
LABEL_57:
          xpc_dictionary_set_BOOL(v2, "resolve_ptr", 1);
          v26 = *((_QWORD *)v1 + 12);
          goto LABEL_58;
        }
LABEL_53:
        xpc_dictionary_set_BOOL(v2, "use_long_outstanding_queries", 1);
        goto LABEL_54;
      }
LABEL_49:
      xpc_dictionary_set_value(v2, "prohibited_interface_types", *v23);
      xpc_dictionary_set_value(v2, "prohibited_interface_subtypes", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 8));
      xpc_dictionary_set_value(v2, "preferred_interface_subtypes", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 16));
      xpc_dictionary_set_value(v2, "prohibited_interfaces", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 24));
      xpc_dictionary_set_value(v2, "prohibited_netagent_domains", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 32));
      xpc_dictionary_set_value(v2, "prohibited_netagent_types", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 40));
      xpc_dictionary_set_value(v2, "prohibited_netagent_uuids", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 48));
      xpc_dictionary_set_value(v2, "required_netagent_domains", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 56));
      xpc_dictionary_set_value(v2, "required_netagent_types", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 64));
      xpc_dictionary_set_value(v2, "required_netagent_uuids", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 72));
      xpc_dictionary_set_value(v2, "preferred_netagent_domains", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 80));
      xpc_dictionary_set_value(v2, "preferred_netagent_types", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 88));
      xpc_dictionary_set_value(v2, "preferred_netagent_uuids", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 96));
      xpc_dictionary_set_value(v2, "avoided_netagent_domains", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 104));
      xpc_dictionary_set_value(v2, "avoided_netagent_types", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 112));
      xpc_dictionary_set_value(v2, "avoided_netagent_uuids", *(xpc_object_t *)(*(_QWORD *)(*((_QWORD *)v1 + 13) + 176) + 120));
      goto LABEL_50;
    }
LABEL_48:
    xpc_dictionary_set_BOOL(v2, "prohibit_roaming", 1);
    v23 = *(xpc_object_t **)(*((_QWORD *)v1 + 13) + 176);
    if (!v23)
      goto LABEL_50;
    goto LABEL_49;
  }
  v2 = 0;
LABEL_106:

  return v2;
}

void sub_183173570(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

const char *__cdecl nw_endpoint_get_url(nw_endpoint_t endpoint)
{
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  int v4;
  const char *isa;
  id v6;
  NSObject *v7;
  int v8;
  const char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  int v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  NSObject *v17;
  int v18;
  os_log_type_t v19;
  NSObject *v20;
  int v21;
  NSObject *v22;
  int v23;
  char *v24;
  void *v26;
  const char *v27;
  NSObject *v28;
  os_log_type_t v29;
  char *backtrace_string;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  uint64_t v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  _WORD v40[17];

  *(_QWORD *)&v40[13] = *MEMORY[0x1E0C80C00];
  v1 = endpoint;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_endpoint_get_url";
    v27 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_url";
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v38 = "nw_endpoint_get_url";
            v39 = 2082;
            *(_QWORD *)v40 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_url";
          _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v28 = objc_claimAutoreleasedReturnValue();
        v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_endpoint_get_url";
          _os_log_impl(&dword_182FBE000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_42:
    if (!v27)
      goto LABEL_24;
    v24 = (char *)v27;
    goto LABEL_23;
  }
  v3 = v1;
  v4 = -[NSObject type](v3, "type");

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    v7 = v3;
    v8 = -[NSObject type](v7, "type");

    *(_DWORD *)buf = 136446466;
    v38 = "nw_endpoint_get_url";
    v39 = 1024;
    *(_DWORD *)v40 = v8;
    LODWORD(v34) = 18;
    v9 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          v12 = v7;
          v13 = -[NSObject type](v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url";
          v39 = 1024;
          *(_DWORD *)v40 = v13;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            v17 = v7;
            v18 = -[NSObject type](v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            v38 = "nw_endpoint_get_url";
            v39 = 1024;
            *(_DWORD *)v40 = v18;
            v40[2] = 2082;
            *(_QWORD *)&v40[3] = v14;
            _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9)
            goto LABEL_24;
LABEL_22:
          v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          v22 = v7;
          v23 = -[NSObject type](v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url";
          v39 = 1024;
          *(_DWORD *)v40 = v23;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          v20 = v7;
          v21 = -[NSObject type](v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          v38 = "nw_endpoint_get_url";
          v39 = 1024;
          *(_DWORD *)v40 = v21;
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
    if (!v9)
    {
LABEL_24:
      isa = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  isa = (const char *)v3[31].isa;
LABEL_25:

  return isa;
}

void sub_183173B7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void *nw_interface_copy_dictionary(void *a1)
{
  char *v1;
  xpc_object_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v1 = a1;
  if (v1)
  {
    v2 = xpc_dictionary_create(0, 0, 0);
    v3 = v2;
    v4 = *((unsigned int *)v1 + 24);
    if ((_DWORD)v4)
      xpc_dictionary_set_uint64(v2, "type", v4);
    v5 = *((unsigned int *)v1 + 25);
    if ((_DWORD)v5)
      xpc_dictionary_set_uint64(v3, "subtype", v5);
    xpc_dictionary_set_string(v3, "name", v1 + 104);
    v6 = *((unsigned int *)v1 + 2);
    if ((_DWORD)v6)
      xpc_dictionary_set_uint64(v3, "index", v6);
    v7 = *((unsigned int *)v1 + 23);
    if ((_DWORD)v7)
      xpc_dictionary_set_uint64(v3, "generation", v7);
    v8 = *((unsigned int *)v1 + 22);
    if ((_DWORD)v8)
      xpc_dictionary_set_uint64(v3, "delegate_index", v8);
    xpc_dictionary_set_data(v3, "details", v1 + 12, 0x4CuLL);
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_183173CD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_sanitized_url(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t sanitized_url;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_get_sanitized_url";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_sanitized_url";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_get_sanitized_url";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_sanitized_url";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_sanitized_url";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = (void *)*((_QWORD *)v1 + 25);
  if (!v3)
  {
LABEL_22:
    sanitized_url = 0;
    goto LABEL_23;
  }
  sanitized_url = nw_endpoint_get_sanitized_url(v3);
LABEL_23:

  return sanitized_url;
}

void sub_183173FF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id NWUtilsCreateNSObjectFromSimpleXPCObject(void *a1)
{
  id v1;
  Class Class;
  Class v3;
  objc_class *v4;
  NSObject *v5;
  NSObject *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  _BOOL4 value;
  void *v12;
  id v13;
  const char *string_ptr;
  void *v15;
  const void *bytes_ptr;
  char *backtrace_string;
  _BOOL4 v18;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  Class v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  Class = object_getClass(v1);
  if (Class == (Class)MEMORY[0x1E0C812D0])
  {
    value = xpc_BOOL_get_value(v1);
    v12 = (void *)MEMORY[0x1E0C9AAA0];
    if (value)
      v12 = (void *)MEMORY[0x1E0C9AAB0];
    v13 = v12;
  }
  else
  {
    v3 = Class;
    if (Class == (Class)MEMORY[0x1E0C81390])
    {
      string_ptr = xpc_string_get_string_ptr(v1);
      if (!string_ptr)
      {
LABEL_39:
        v13 = 0;
        goto LABEL_40;
      }
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", string_ptr);
      v13 = (id)objc_claimAutoreleasedReturnValue();
    }
    else if (Class == (Class)MEMORY[0x1E0C812E8])
    {
      v15 = (void *)MEMORY[0x1E0C99D50];
      bytes_ptr = xpc_data_get_bytes_ptr(v1);
      objc_msgSend(v15, "dataWithBytes:length:", bytes_ptr, xpc_data_get_length(v1));
      v13 = (id)objc_claimAutoreleasedReturnValue();
    }
    else if (Class == (Class)MEMORY[0x1E0C81328])
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", xpc_int64_get_value(v1));
      v13 = (id)objc_claimAutoreleasedReturnValue();
    }
    else if (Class == (Class)MEMORY[0x1E0C81398])
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLongLong:", xpc_uint64_get_value(v1));
      v13 = (id)objc_claimAutoreleasedReturnValue();
    }
    else if (Class == (Class)MEMORY[0x1E0C81300])
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", xpc_double_get_value(v1));
      v13 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      if (Class != (Class)MEMORY[0x1E0C813A0])
      {
        v4 = (objc_class *)MEMORY[0x1E0C81360];
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        v6 = v5;
        if (v3 == v4)
        {
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            v23 = "NWUtilsCreateNSObjectFromSimpleXPCObject";
            _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s Cannot encode pointer types, skipping value", buf, 0xCu);
          }

          goto LABEL_39;
        }
        *(_DWORD *)buf = 136446466;
        v23 = "NWUtilsCreateNSObjectFromSimpleXPCObject";
        v24 = 2048;
        v25 = v3;
        v7 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v20 = 0;
        if (!__nwlog_fault(v7, &type, &v20))
          goto LABEL_37;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v8 = objc_claimAutoreleasedReturnValue();
          v9 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            v23 = "NWUtilsCreateNSObjectFromSimpleXPCObject";
            v24 = 2048;
            v25 = v3;
            v10 = "%{public}s Cannot handle XPC type %p";
LABEL_35:
            _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0x16u);
          }
        }
        else if (v20)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v8 = objc_claimAutoreleasedReturnValue();
          v9 = type;
          v18 = os_log_type_enabled(v8, type);
          if (backtrace_string)
          {
            if (v18)
            {
              *(_DWORD *)buf = 136446722;
              v23 = "NWUtilsCreateNSObjectFromSimpleXPCObject";
              v24 = 2048;
              v25 = v3;
              v26 = 2082;
              v27 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s Cannot handle XPC type %p, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(backtrace_string);
            goto LABEL_37;
          }
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v23 = "NWUtilsCreateNSObjectFromSimpleXPCObject";
            v24 = 2048;
            v25 = v3;
            v10 = "%{public}s Cannot handle XPC type %p, no backtrace";
            goto LABEL_35;
          }
        }
        else
        {
          __nwlog_obj();
          v8 = objc_claimAutoreleasedReturnValue();
          v9 = type;
          if (os_log_type_enabled(v8, type))
          {
            *(_DWORD *)buf = 136446466;
            v23 = "NWUtilsCreateNSObjectFromSimpleXPCObject";
            v24 = 2048;
            v25 = v3;
            v10 = "%{public}s Cannot handle XPC type %p, backtrace limit exceeded";
            goto LABEL_35;
          }
        }

LABEL_37:
        if (v7)
          free(v7);
        goto LABEL_39;
      }
      v13 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", xpc_uuid_get_bytes(v1));
    }
  }
LABEL_40:

  return v13;
}

void __nw_path_enumerate_interface_options_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  id v5;
  id v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  v7 = 0uLL;
  nw_interface_option_details_get_nexus_agent(v3, &v7);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = nw_interface_option_details_copy_interface(v3);
  v6 = nw_interface_option_details_copy_remote_endpoint(v3);
  (*(void (**)(uint64_t, id, __int128 *, id))(v4 + 16))(v4, v5, &v7, v6);

}

void sub_183175CD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void nw_interface_option_details_get_nexus_agent(void *a1, _OWORD *a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_interface_option_details_get_nexus_agent";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_interface_option_details_get_nexus_agent";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_interface_option_details_get_nexus_agent";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_interface_option_details_get_nexus_agent";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_interface_option_details_get_nexus_agent";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    *a2 = *((_OWORD *)v3 + 2);
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_interface_option_details_get_nexus_agent";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_interface_option_details_get_nexus_agent";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null out_nexus_agent", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_interface_option_details_get_nexus_agent";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null out_nexus_agent, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_interface_option_details_get_nexus_agent";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null out_nexus_agent, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_interface_option_details_get_nexus_agent";
    v23 = 2082;
    v24 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null out_nexus_agent, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

id nw_interface_option_details_copy_remote_endpoint(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[3];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_copy_remote_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_remote_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_copy_remote_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_remote_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_remote_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_interface_option_details_copy_interface(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[1];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_interface_option_details_copy_interface";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_interface_option_details_copy_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_interface_option_details_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_path_flow_registration_uses_nexus(void *a1, const unsigned __int8 *a2)
{
  const unsigned __int8 *v3;
  unsigned __int8 *v4;
  _BOOL8 v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (unsigned __int8 *)v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_path_flow_registration_uses_nexus";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_path_flow_registration_uses_nexus";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null flow_registration", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_path_flow_registration_uses_nexus";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_path_flow_registration_uses_nexus";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_path_flow_registration_uses_nexus";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_22:
    if (v8)
      free(v8);
    goto LABEL_3;
  }
  if ((v3[148] & 4) != 0)
  {
    v5 = uuid_compare(v3 + 48, a2) == 0;
    goto LABEL_5;
  }
LABEL_3:
  v5 = 0;
LABEL_5:

  return v5;
}

void sub_18317698C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

const char *nw_listener_get_id_string(void *a1)
{
  const char *v1;
  char *v2;
  const char *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (char *)v1;
  if (v1)
  {
    v3 = v1 + 42;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_listener_get_id_string";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_listener_get_id_string";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_listener_get_id_string";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_listener_get_id_string";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_listener_get_id_string";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = "";
LABEL_3:

  return v3;
}

void sub_183178784(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_183178A8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_get_protocol_level(void *a1)
{
  const unsigned __int8 *v1;
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  void *v4;
  _DWORD *data;
  _DWORD *v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  _BYTE length[12];
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (unsigned __int8 *)v1;
  if (!v1)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)length = 136446210;
    *(_QWORD *)&length[4] = "nw_path_flow_get_protocol_level";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_get_protocol_level";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null flow", length, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)length = 136446466;
            *(_QWORD *)&length[4] = "nw_path_flow_get_protocol_level";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null flow, dumping backtrace:%{public}s", length, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v17)
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_get_protocol_level";
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null flow, no backtrace", length, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)length = 136446210;
          *(_QWORD *)&length[4] = "nw_path_flow_get_protocol_level";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null flow, backtrace limit exceeded", length, 0xCu);
        }
      }

    }
LABEL_35:
    if (v12)
      free(v12);
    goto LABEL_13;
  }
  if (uuid_is_null(v1 + 84))
  {
LABEL_13:
    v8 = 0;
    goto LABEL_14;
  }
  v3 = v2;
  v4 = (void *)*((_QWORD *)v3 + 3);
  if (!v4
    || (*(_QWORD *)length = 0, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) == 0)
    || *(_QWORD *)length < 0xD8uLL
    || (v6 = data, *(_QWORD *)length != data[53] + 216)
    || ((data[52] & 0xE080) != 0 ? (v7 = (data[52] & 0x13) == 1) : (v7 = 1), v7))
  {

    goto LABEL_13;
  }

  if (v6[53] < 0xCCu)
    goto LABEL_13;
  v10 = v6[54];
  if (v10 >= 5)
    v8 = 0;
  else
    v8 = v10;
LABEL_14:

  return v8;
}

void sub_183178DC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_path_flow_get_id(void *a1, _OWORD *a2)
{
  _OWORD *v3;
  void *v4;
  _OWORD *v5;
  uint64_t v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_path_flow_get_id";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_flow_get_id";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null flow", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_path_flow_get_id";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_flow_get_id";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_path_flow_get_id";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_22:
    if (v9)
      free(v9);
    goto LABEL_3;
  }
  v5 = v3 + 9;
  if (!uuid_is_null((const unsigned __int8 *)v3 + 144))
  {
    *a2 = *v5;
    v6 = 1;
    goto LABEL_5;
  }
LABEL_3:
  v6 = 0;
LABEL_5:

  return v6;
}

void sub_18317908C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_stream_data_unidirectional_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_stream_data_unidirectional_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183179384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_unidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 72);
  *(_QWORD *)(a2 + 72) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_max_stream_data_bidirectional_remote_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_stream_data_bidirectional_remote_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_bidirectional_remote_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1831796E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_bidirectional_remote_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_max_stream_data_bidirectional_local_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_stream_data_bidirectional_local_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_stream_data_bidirectional_local_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183179A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_bidirectional_local_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_max_data_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_max_data_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_max_data_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_data_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_max_data_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_data_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_max_data_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183179DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_data_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_local_max_streams_unidirectional_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_local_max_streams_unidirectional_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317A104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_local_max_streams_unidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_local_max_streams_bidirectional_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_local_max_streams_bidirectional_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317A464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_local_max_streams_bidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 80);
  *(_QWORD *)(a2 + 80) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_link_flow_controlled_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_link_flow_controlled_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_link_flow_controlled_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_link_flow_controlled_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_link_flow_controlled_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_link_flow_controlled_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_link_flow_controlled_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317A7C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_link_flow_controlled_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 200);
  *(_QWORD *)(a2 + 200) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_keepalive_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_keepalive_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_keepalive_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_keepalive_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_keepalive_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_keepalive_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_keepalive_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317AB24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_keepalive_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 160);
  *(_QWORD *)(a2 + 160) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_close_with_error_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_close_with_error_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_close_with_error_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_close_with_error_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_close_with_error_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_close_with_error_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_close_with_error_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317AE84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_close_with_error_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 144);
  *(_QWORD *)(a2 + 144) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_application_result_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_application_result_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_application_result_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_application_result_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_application_result_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_application_result_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_application_result_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317B1E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_application_result_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 184);
  *(_QWORD *)(a2 + 184) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_inject_packet_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_inject_packet_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_inject_packet_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_inject_packet_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_inject_packet_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_inject_packet_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_inject_packet_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317B544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_inject_packet_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 176);
  *(_QWORD *)(a2 + 176) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_remote_max_streams_unidirectional_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_remote_max_streams_unidirectional_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_remote_max_streams_unidirectional_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_remote_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_remote_max_streams_unidirectional_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_remote_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_remote_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317B8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_remote_max_streams_unidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 136);
  *(_QWORD *)(a2 + 136) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_remote_max_streams_bidirectional_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_remote_max_streams_bidirectional_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_remote_max_streams_bidirectional_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_remote_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_remote_max_streams_bidirectional_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_remote_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_remote_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317BC04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_remote_max_streams_bidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_peer_idle_timeout_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_peer_idle_timeout_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_peer_idle_timeout_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317BF64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_peer_idle_timeout_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 152);
  *(_QWORD *)(a2 + 152) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_local_max_streams_unidirectional_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_local_max_streams_unidirectional_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_local_max_streams_unidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317C2C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_local_max_streams_unidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_local_max_streams_bidirectional_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_local_max_streams_bidirectional_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_local_max_streams_bidirectional_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317C624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_local_max_streams_bidirectional_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 96);
  *(_QWORD *)(a2 + 96) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_keepalive_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_keepalive_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_keepalive_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_keepalive_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_keepalive_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_keepalive_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_keepalive_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317C984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_keepalive_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 168);
  *(_QWORD *)(a2 + 168) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_application_result_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_application_result_handler_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_application_result_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_application_result_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_application_result_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_application_result_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_application_result_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18317CCE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_application_result_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  void *v6;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = _Block_copy(*(const void **)(a1 + 32));
  v6 = *(void **)(a2 + 192);
  *(_QWORD *)(a2 + 192) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t net_flowhash_jhash(int *a1, unsigned int a2, int a3)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int *v52;
  int v53;
  int v54;
  int v55;
  int *v56;
  unint64_t v57;
  int v58;
  int v59;
  int v60;
  unint64_t v61;

  result = a2 + a3 - 559038737;
  if ((a1 & 3) != 0)
  {
    if ((a1 & 1) != 0)
    {
      if (a2 >= 0xD)
      {
        v42 = a2 + a3 - 559038737;
        v41 = v42;
        do
        {
          v27 = v42
              + *((unsigned __int8 *)a1 + 4)
              + (*((unsigned __int8 *)a1 + 5) << 8)
              + (*((unsigned __int8 *)a1 + 6) << 16)
              + (*((unsigned __int8 *)a1 + 7) << 24);
          v28 = result
              + *((unsigned __int8 *)a1 + 8)
              + (*((unsigned __int8 *)a1 + 9) << 8)
              + (*((unsigned __int8 *)a1 + 10) << 16)
              + (*((unsigned __int8 *)a1 + 11) << 24);
          v29 = (v41
               + *(unsigned __int8 *)a1
               + (*((unsigned __int8 *)a1 + 1) << 8)
               + (*((unsigned __int8 *)a1 + 2) << 16)
               + (*((unsigned __int8 *)a1 + 3) << 24)
               - v28) ^ __ROR4__(v28, 28);
          v30 = v28 + v27;
          v31 = (v27 - v29) ^ __ROR4__(v29, 26);
          v32 = v29 + v30;
          v33 = (v30 - v31) ^ __ROR4__(v31, 24);
          v34 = v31 + v32;
          v35 = (v32 - v33) ^ __ROR4__(v33, 16);
          v36 = v33 + v34;
          v37 = (v34 - v35) ^ __ROR4__(v35, 13);
          v41 = v35 + v36;
          result = (v36 - v37) ^ __ROR4__(v37, 28);
          v42 = v37 + v41;
          a2 -= 12;
          a1 += 3;
        }
        while (a2 > 0xC);
      }
      else
      {
        v41 = a2 + a3 - 559038737;
        v42 = v41;
      }
      switch(a2)
      {
        case 0u:
          return result;
        case 1u:
          goto LABEL_34;
        case 2u:
          goto LABEL_33;
        case 3u:
          goto LABEL_32;
        case 4u:
          goto LABEL_31;
        case 5u:
          goto LABEL_30;
        case 6u:
          goto LABEL_29;
        case 7u:
          goto LABEL_28;
        case 8u:
          goto LABEL_27;
        case 9u:
          goto LABEL_26;
        case 0xAu:
          goto LABEL_25;
        case 0xBu:
          goto LABEL_24;
        case 0xCu:
          LODWORD(result) = result + (*((unsigned __int8 *)a1 + 11) << 24);
LABEL_24:
          LODWORD(result) = result + (*((unsigned __int8 *)a1 + 10) << 16);
LABEL_25:
          LODWORD(result) = result + (*((unsigned __int8 *)a1 + 9) << 8);
LABEL_26:
          LODWORD(result) = result + *((unsigned __int8 *)a1 + 8);
LABEL_27:
          v42 += *((unsigned __int8 *)a1 + 7) << 24;
LABEL_28:
          v42 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_29:
          v42 += *((unsigned __int8 *)a1 + 5) << 8;
LABEL_30:
          v42 += *((unsigned __int8 *)a1 + 4);
LABEL_31:
          v41 += *((unsigned __int8 *)a1 + 3) << 24;
LABEL_32:
          v41 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_33:
          v41 += *((unsigned __int8 *)a1 + 1) << 8;
LABEL_34:
          v41 += *(unsigned __int8 *)a1;
          break;
        default:
          break;
      }
      HIDWORD(v43) = v42;
      LODWORD(v43) = v42;
      HIDWORD(v43) = (result ^ v42) - (v43 >> 18);
      v44 = HIDWORD(v43);
      LODWORD(v43) = HIDWORD(v43);
      v45 = (HIDWORD(v43) ^ v41) - (v43 >> 21);
      HIDWORD(v43) = v45;
      LODWORD(v43) = v45;
      v46 = (v45 ^ v42) - (v43 >> 7);
      HIDWORD(v43) = v46;
      LODWORD(v43) = v46;
      v47 = (v46 ^ v44) - (v43 >> 16);
      HIDWORD(v43) = v47;
      LODWORD(v43) = v47;
      HIDWORD(v43) = (v47 ^ v45) - (v43 >> 28);
      LODWORD(v43) = HIDWORD(v43);
      v48 = v43 >> 18;
      v49 = HIDWORD(v43) ^ v46;
      goto LABEL_62;
    }
    if (a2 >= 0xD)
    {
      v40 = a2 + a3 - 559038737;
      v39 = v40;
      do
      {
        v5 = a1[1] + v40;
        v6 = a1[2] + result;
        v7 = (*a1 + v39 - v6) ^ __ROR4__(v6, 28);
        v8 = v6 + v5;
        v9 = (v5 - v7) ^ __ROR4__(v7, 26);
        v10 = v7 + v8;
        v11 = (v8 - v9) ^ __ROR4__(v9, 24);
        v12 = v9 + v10;
        v13 = (v10 - v11) ^ __ROR4__(v11, 16);
        v14 = v11 + v12;
        v15 = (v12 - v13) ^ __ROR4__(v13, 13);
        v39 = v13 + v14;
        result = (v14 - v15) ^ __ROR4__(v15, 28);
        v40 = v15 + v39;
        a2 -= 12;
        a1 += 3;
      }
      while (a2 > 0xC);
    }
    else
    {
      v39 = a2 + a3 - 559038737;
      v40 = v39;
    }
    switch(a2)
    {
      case 0u:
        return result;
      case 1u:
        v39 += *(unsigned __int8 *)a1;
        goto LABEL_61;
      case 2u:
        goto LABEL_48;
      case 3u:
        v39 += *((unsigned __int8 *)a1 + 2) << 16;
LABEL_48:
        v39 += *(unsigned __int16 *)a1;
        goto LABEL_61;
      case 4u:
        goto LABEL_53;
      case 5u:
        v54 = *((unsigned __int8 *)a1 + 4);
        goto LABEL_52;
      case 6u:
        goto LABEL_51;
      case 7u:
        v40 += *((unsigned __int8 *)a1 + 6) << 16;
LABEL_51:
        v54 = *((unsigned __int16 *)a1 + 2);
LABEL_52:
        v40 += v54;
        goto LABEL_53;
      case 8u:
        break;
      case 9u:
        v55 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_57;
      case 0xAu:
        goto LABEL_56;
      case 0xBu:
        LODWORD(result) = result + (*((unsigned __int8 *)a1 + 10) << 16);
LABEL_56:
        v55 = *((unsigned __int16 *)a1 + 4);
LABEL_57:
        LODWORD(result) = result + v55;
        break;
      case 0xCu:
        goto LABEL_36;
      default:
        goto LABEL_61;
    }
  }
  else
  {
    if (a2 < 0xD)
    {
      v39 = a2 + a3 - 559038737;
      v40 = v39;
    }
    else
    {
      v40 = a2 + a3 - 559038737;
      v39 = v40;
      do
      {
        v16 = a1[1] + v40;
        v17 = a1[2] + result;
        v18 = (*a1 + v39 - v17) ^ __ROR4__(v17, 28);
        v19 = v17 + v16;
        v20 = (v16 - v18) ^ __ROR4__(v18, 26);
        v21 = v18 + v19;
        v22 = (v19 - v20) ^ __ROR4__(v20, 24);
        v23 = v20 + v21;
        v24 = (v21 - v22) ^ __ROR4__(v22, 16);
        v25 = v22 + v23;
        v26 = (v23 - v24) ^ __ROR4__(v24, 13);
        v39 = v24 + v25;
        result = (v25 - v26) ^ __ROR4__(v26, 28);
        v40 = v26 + v39;
        a2 -= 12;
        a1 += 3;
      }
      while (a2 > 0xC);
    }
    switch(a2)
    {
      case 0u:
        return result;
      case 1u:
        v38 = *(unsigned __int8 *)a1;
        goto LABEL_60;
      case 2u:
        v38 = *(unsigned __int16 *)a1;
        goto LABEL_60;
      case 3u:
        v38 = *a1 & 0xFFFFFF;
        goto LABEL_60;
      case 4u:
        goto LABEL_53;
      case 5u:
        v51 = *((unsigned __int8 *)a1 + 4);
        goto LABEL_41;
      case 6u:
        v51 = *((unsigned __int16 *)a1 + 2);
LABEL_41:
        v40 += v51;
LABEL_53:
        v38 = *a1;
        goto LABEL_60;
      case 7u:
        v52 = a1;
        v38 = *a1;
        v53 = v52[1] & 0xFFFFFF;
        goto LABEL_59;
      case 8u:
        break;
      case 9u:
        v50 = *((unsigned __int8 *)a1 + 8);
        goto LABEL_46;
      case 0xAu:
        v50 = *((unsigned __int16 *)a1 + 4);
        goto LABEL_46;
      case 0xBu:
        v50 = a1[2] & 0xFFFFFF;
        goto LABEL_46;
      case 0xCu:
LABEL_36:
        v50 = a1[2];
LABEL_46:
        LODWORD(result) = v50 + result;
        break;
      default:
        goto LABEL_61;
    }
  }
  v56 = a1;
  v38 = *a1;
  v53 = v56[1];
LABEL_59:
  v40 += v53;
LABEL_60:
  v39 += v38;
LABEL_61:
  HIDWORD(v57) = v40;
  LODWORD(v57) = v40;
  HIDWORD(v57) = (result ^ v40) - (v57 >> 18);
  v58 = HIDWORD(v57);
  LODWORD(v57) = HIDWORD(v57);
  v59 = (HIDWORD(v57) ^ v39) - (v57 >> 21);
  HIDWORD(v57) = v59;
  LODWORD(v57) = v59;
  v60 = (v59 ^ v40) - (v57 >> 7);
  HIDWORD(v57) = v60;
  LODWORD(v57) = v60;
  v47 = (v60 ^ v58) - (v57 >> 16);
  HIDWORD(v57) = v47;
  LODWORD(v57) = v47;
  HIDWORD(v57) = (v47 ^ v59) - (v57 >> 28);
  LODWORD(v57) = HIDWORD(v57);
  v48 = v57 >> 18;
  v49 = HIDWORD(v57) ^ v60;
LABEL_62:
  HIDWORD(v61) = v49 - v48;
  LODWORD(v61) = v49 - v48;
  return ((v49 - v48) ^ v47) - (v61 >> 8);
}

uint64_t nw_context_128k_buffer_length()
{
  return dword_1EDCDF3D8;
}

nw_protocol *nw_socket_get_output_local(nw_protocol *a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  const char *v8;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
      return a1[2].default_input_handler;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v13 = "nw_socket_get_output_local";
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_socket_get_output_local";
        v5 = "%{public}s called with null socket_handler";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v10)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_socket_get_output_local";
        v5 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v3 = __nwlog_obj();
    v4 = type;
    v9 = os_log_type_enabled(v3, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_socket_get_output_local";
        v5 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v13 = "nw_socket_get_output_local";
      v14 = 2082;
      v15 = backtrace_string;
      v8 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_socket_get_output_local";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v10)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_socket_get_output_local";
        v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v3 = __nwlog_obj();
    v4 = type;
    v7 = os_log_type_enabled(v3, type);
    if (!backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_socket_get_output_local";
        v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      v13 = "nw_socket_get_output_local";
      v14 = 2082;
      v15 = backtrace_string;
      v8 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v3, v4, v8, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v3 = __nwlog_obj();
  v4 = type;
  if (os_log_type_enabled(v3, type))
  {
    *(_DWORD *)buf = 136446210;
    v13 = "nw_socket_get_output_local";
    v5 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
  }
LABEL_32:
  if (v2)
    free(v2);
  return 0;
}

void nw_protocol_socket_set_necp_attributes(uint64_t a1, NWConcrete_nw_parameters *a2, const char **a3)
{
  _BOOL8 domain_for_policy;
  const char *v7;
  socklen_t v8;
  const char *account_id;
  const char *v10;
  const char *v11;
  char v12;
  const char *attribution_context;
  const char *v14;
  const char *v15;
  int v16;
  unint64_t v17;
  void *v18;
  char *v19;
  int v20;
  const char *v21;
  char v22;
  size_t v23;
  char *v24;
  uint64_t v25;
  os_log_type_t v26;
  const char *v27;
  char *backtrace_string;
  NSObject *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  NSObject *v32;
  os_log_type_t v33;
  int v34;
  size_t v35;
  char *v36;
  char *v37;
  uint64_t v38;
  os_log_type_t v39;
  const char *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  NSObject *v45;
  os_log_type_t v46;
  uint32_t v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  const char *v51;
  char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  NSObject *v56;
  os_log_type_t v57;
  char *v58;
  _BOOL4 v59;
  char *v60;
  _BOOL4 v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  _BOOL4 v65;
  int v66;
  size_t v67;
  char *v68;
  uint64_t v69;
  os_log_type_t v70;
  const char *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  _BOOL4 v75;
  NSObject *v76;
  os_log_type_t v77;
  uint32_t v78;
  int v79;
  size_t v80;
  char *v81;
  uint64_t v82;
  os_log_type_t v83;
  const char *v84;
  char *v85;
  NSObject *v86;
  os_log_type_t v87;
  _BOOL4 v88;
  NSObject *v89;
  os_log_type_t v90;
  uint32_t v91;
  int v92;
  size_t v93;
  char *v94;
  uint64_t v95;
  os_log_type_t v96;
  const char *v97;
  char *v98;
  NSObject *v99;
  os_log_type_t v100;
  _BOOL4 v101;
  NSObject *v102;
  os_log_type_t v103;
  char *v104;
  NSObject *v105;
  int v106;
  const char *logging_description;
  const char *v108;
  const char *v109;
  int v110;
  NSObject *v111;
  int v112;
  int v113;
  char *v114;
  NSObject *v115;
  os_log_type_t v116;
  int v117;
  const char *v118;
  char *v119;
  NSObject *v120;
  os_log_type_t v121;
  _BOOL4 v122;
  int v123;
  int v124;
  NSObject *v125;
  os_log_type_t v126;
  int v127;
  char *v128;
  NSObject *v129;
  os_log_type_t v130;
  const char *v131;
  NSObject *v132;
  os_log_type_t v133;
  char *v134;
  NSObject *v135;
  os_log_type_t v136;
  const char *v137;
  char *v138;
  NSObject *v139;
  os_log_type_t v140;
  const char *v141;
  NSObject *v142;
  os_log_type_t v143;
  NSObject *v144;
  os_log_type_t v145;
  char *v146;
  _BOOL4 v147;
  char *v148;
  NSObject *v149;
  os_log_type_t v150;
  _BOOL4 v151;
  char *v152;
  _BOOL4 v153;
  char *v154;
  _BOOL4 v155;
  char *v156;
  NSObject *v157;
  os_log_type_t v158;
  _BOOL4 v159;
  char *v160;
  NSObject *v161;
  os_log_type_t v162;
  _BOOL4 v163;
  NSObject *v164;
  os_log_type_t v165;
  uint32_t v166;
  const char **v167;
  socklen_t v168;
  char v169;
  NWConcrete_nw_parameters *v170;
  uint64_t v171;
  const char *v172;
  char v173;
  void *v174;
  char *v175;
  char v176;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v179;
  __int16 v180;
  _BYTE v181[10];
  _BYTE v182[44];
  __int16 v183;
  socklen_t v184;
  __int16 v185;
  void *v186;
  uint64_t v187;

  v187 = *MEMORY[0x1E0C80C00];
  domain_for_policy = nw_endpoint_get_domain_for_policy(a3);
  v7 = (const char *)domain_for_policy;
  if (domain_for_policy)
    v8 = strlen((const char *)domain_for_policy) + 6;
  else
    v8 = 0;
  account_id = (const char *)nw_parameters_get_account_id(a2);
  v10 = account_id;
  if (account_id)
    v8 += strlen(account_id) + 6;
  if (a3)
  {
    v11 = a3[12];
    if (v11)
    {
      v12 = 0;
      v8 += strlen(a3[12]) + 6;
      goto LABEL_11;
    }
  }
  else
  {
    v11 = 0;
  }
  v12 = 1;
LABEL_11:
  attribution_context = (const char *)nw_parameters_get_attribution_context(a2);
  v14 = attribution_context;
  if (attribution_context)
    v8 += strlen(attribution_context) + 6;
  if (a3)
  {
    v15 = a3[11];
    if (v15)
    {
      v173 = 0;
      v16 = v8 + strlen(a3[11]);
      v8 = v16 + 6;
      if (v16 == -6)
        return;
      goto LABEL_19;
    }
  }
  else
  {
    v15 = 0;
  }
  v173 = 1;
  if (!v8)
    return;
LABEL_19:
  v170 = a2;
  v171 = a1;
  v167 = a3;
  v17 = v8;
  v18 = (void *)nw_calloc_type<unsigned char>(v8);
  v174 = v18;
  v175 = (char *)v18 + v8;
  v19 = (char *)v18;
  v172 = v15;
  if (!v7)
    goto LABEL_42;
  v20 = strlen(v7);
  if (v18)
  {
    v168 = v8;
    v21 = v14;
    v22 = v12;
    v23 = (v20 + 1);
    if (v23 + 5 <= v17)
    {
      *(_BYTE *)v18 = 7;
      *(_DWORD *)((char *)v18 + 1) = v23;
      if (v20 != -1)
        memcpy((char *)v18 + 5, v7, v23);
      v19 = (char *)v18 + v23 + 5;
      goto LABEL_41;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136447490;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v18;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v23 + 5;
    *(_WORD *)&v182[8] = 2048;
    *(_QWORD *)&v182[10] = v175;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = 7;
    *(_WORD *)&v182[24] = 1024;
    *(_DWORD *)&v182[26] = v23;
    v24 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (__nwlog_fault(v24, &type, &v176))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = gLogObj;
        v26 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136447490;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v174;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v23 + 5;
          *(_WORD *)&v182[8] = 2048;
          *(_QWORD *)&v182[10] = v175;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = 7;
          *(_WORD *)&v182[24] = 1024;
          *(_DWORD *)&v182[26] = v23;
          v27 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
LABEL_36:
          v32 = v25;
          v33 = v26;
LABEL_37:
          _os_log_impl(&dword_182FBE000, v32, v33, v27, buf, 0x36u);
        }
      }
      else if (v176)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = gLogObj;
        v30 = type;
        v31 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136447746;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(_QWORD *)v181 = v174;
            *(_WORD *)&v181[8] = 2048;
            *(_QWORD *)v182 = v23 + 5;
            *(_WORD *)&v182[8] = 2048;
            *(_QWORD *)&v182[10] = v175;
            *(_WORD *)&v182[18] = 1024;
            *(_DWORD *)&v182[20] = 7;
            *(_WORD *)&v182[24] = 1024;
            *(_DWORD *)&v182[26] = v23;
            *(_WORD *)&v182[30] = 2082;
            *(_QWORD *)&v182[32] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
          }
          free(backtrace_string);
          goto LABEL_38;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136447490;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v174;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v23 + 5;
          *(_WORD *)&v182[8] = 2048;
          *(_QWORD *)&v182[10] = v175;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = 7;
          *(_WORD *)&v182[24] = 1024;
          *(_DWORD *)&v182[26] = v23;
          v27 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
          v32 = v29;
          v33 = v30;
          goto LABEL_37;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = gLogObj;
        v26 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)buf = 136447490;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v174;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v23 + 5;
          *(_WORD *)&v182[8] = 2048;
          *(_QWORD *)&v182[10] = v175;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = 7;
          *(_WORD *)&v182[24] = 1024;
          *(_DWORD *)&v182[26] = v23;
          v27 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
          goto LABEL_36;
        }
      }
    }
LABEL_38:
    if (v24)
      free(v24);
    v19 = 0;
    v18 = v174;
    v15 = v172;
LABEL_41:
    v12 = v22;
    v14 = v21;
    v8 = v168;
LABEL_42:
    if (v10)
      goto LABEL_43;
LABEL_114:
    v36 = v175;
    if ((v12 & 1) != 0)
      goto LABEL_139;
    goto LABEL_115;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v179 = "nw_necp_append_tlv";
  v48 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v176 = 0;
  if (__nwlog_fault(v48, &type, &v176))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v49 = __nwlog_obj();
      v50 = type;
      if (!os_log_type_enabled(v49, type))
        goto LABEL_111;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v51 = "%{public}s called with null tlv_start";
LABEL_110:
      _os_log_impl(&dword_182FBE000, v49, v50, v51, buf, 0xCu);
      goto LABEL_111;
    }
    if (!v176)
    {
      v49 = __nwlog_obj();
      v50 = type;
      if (!os_log_type_enabled(v49, type))
        goto LABEL_111;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v51 = "%{public}s called with null tlv_start, backtrace limit exceeded";
      goto LABEL_110;
    }
    v58 = (char *)__nw_create_backtrace_string();
    v49 = __nwlog_obj();
    v50 = type;
    v59 = os_log_type_enabled(v49, type);
    if (!v58)
    {
      v15 = v172;
      if (!v59)
        goto LABEL_111;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v51 = "%{public}s called with null tlv_start, no backtrace";
      goto LABEL_110;
    }
    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      v179 = "nw_necp_append_tlv";
      v180 = 2082;
      *(_QWORD *)v181 = v58;
      _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v58);
    v15 = v172;
  }
LABEL_111:
  if (v48)
    free(v48);
  v19 = 0;
  v18 = v174;
  if (!v10)
    goto LABEL_114;
LABEL_43:
  v34 = strlen(v10);
  if (v19)
  {
    v169 = v12;
    v35 = (v34 + 1);
    v36 = v175;
    if (v19 < v175)
    {
      if (v175 - v19 >= v35 + 5)
      {
        *v19 = 8;
        *(_DWORD *)(v19 + 1) = v35;
        if (v34 != -1)
          memcpy(v19 + 5, v10, v35);
        v19 += v35 + 5;
LABEL_67:
        v15 = v172;
        if ((v169 & 1) != 0)
          goto LABEL_139;
        goto LABEL_115;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v35 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 8;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v35;
      v37 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v176 = 0;
      if (__nwlog_fault(v37, &type, &v176))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = gLogObj;
          v39 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_64;
          *(_DWORD *)buf = 136447490;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v19;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v35 + 5;
          *(_WORD *)&v182[8] = 2048;
          *(_QWORD *)&v182[10] = v175;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = 8;
          *(_WORD *)&v182[24] = 1024;
          *(_DWORD *)&v182[26] = v35;
          v40 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
LABEL_61:
          v45 = v38;
          v46 = v39;
LABEL_62:
          v47 = 54;
LABEL_63:
          _os_log_impl(&dword_182FBE000, v45, v46, v40, buf, v47);
          goto LABEL_64;
        }
        if (!v176)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v38 = gLogObj;
          v39 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_64;
          *(_DWORD *)buf = 136447490;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v19;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v35 + 5;
          *(_WORD *)&v182[8] = 2048;
          *(_QWORD *)&v182[10] = v175;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = 8;
          *(_WORD *)&v182[24] = 1024;
          *(_DWORD *)&v182[26] = v35;
          v40 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
          goto LABEL_61;
        }
        v41 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v42 = gLogObj;
        v43 = type;
        v44 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v41)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136447746;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(_QWORD *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(_QWORD *)v182 = v35 + 5;
            *(_WORD *)&v182[8] = 2048;
            *(_QWORD *)&v182[10] = v175;
            *(_WORD *)&v182[18] = 1024;
            *(_DWORD *)&v182[20] = 8;
            *(_WORD *)&v182[24] = 1024;
            *(_DWORD *)&v182[26] = v35;
            *(_WORD *)&v182[30] = 2082;
            *(_QWORD *)&v182[32] = v41;
            _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
          }
          free(v41);
          if (!v37)
            goto LABEL_66;
          goto LABEL_65;
        }
        if (v44)
        {
          *(_DWORD *)buf = 136447490;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v19;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v35 + 5;
          *(_WORD *)&v182[8] = 2048;
          *(_QWORD *)&v182[10] = v175;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = 8;
          *(_WORD *)&v182[24] = 1024;
          *(_DWORD *)&v182[26] = v35;
          v40 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
          v45 = v42;
          v46 = v43;
          goto LABEL_62;
        }
      }
LABEL_64:
      if (!v37)
      {
LABEL_66:
        v19 = 0;
        v18 = v174;
        v36 = v175;
        goto LABEL_67;
      }
LABEL_65:
      free(v37);
      goto LABEL_66;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136447234;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v175;
    *(_WORD *)&v182[8] = 1024;
    *(_DWORD *)&v182[10] = 8;
    *(_WORD *)&v182[14] = 1024;
    *(_DWORD *)&v182[16] = v35;
    v37 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v37, &type, &v176))
      goto LABEL_64;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_64;
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 8;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v35;
      v40 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }
    else
    {
      if (v176)
      {
        v62 = (char *)__nw_create_backtrace_string();
        v63 = __nwlog_obj();
        v64 = type;
        v65 = os_log_type_enabled(v63, type);
        if (v62)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136447490;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(_QWORD *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(_QWORD *)v182 = v175;
            *(_WORD *)&v182[8] = 1024;
            *(_DWORD *)&v182[10] = 8;
            *(_WORD *)&v182[14] = 1024;
            *(_DWORD *)&v182[16] = v35;
            *(_WORD *)&v182[20] = 2082;
            *(_QWORD *)&v182[22] = v62;
            _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
          }
          free(v62);
          goto LABEL_64;
        }
        if (!v65)
          goto LABEL_64;
        *(_DWORD *)buf = 136447234;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(_QWORD *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(_QWORD *)v182 = v175;
        *(_WORD *)&v182[8] = 1024;
        *(_DWORD *)&v182[10] = 8;
        *(_WORD *)&v182[14] = 1024;
        *(_DWORD *)&v182[16] = v35;
        v40 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
        v45 = v63;
        v46 = v64;
LABEL_107:
        v47 = 44;
        goto LABEL_63;
      }
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_64;
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 8;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v35;
      v40 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }
    v45 = v56;
    v46 = v57;
    goto LABEL_107;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v179 = "nw_necp_append_tlv";
  v52 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v176 = 0;
  if (__nwlog_fault(v52, &type, &v176))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v53 = __nwlog_obj();
      v54 = type;
      if (!os_log_type_enabled(v53, type))
        goto LABEL_307;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v55 = "%{public}s called with null tlv_start";
LABEL_306:
      _os_log_impl(&dword_182FBE000, v53, v54, v55, buf, 0xCu);
      goto LABEL_307;
    }
    if (!v176)
    {
      v53 = __nwlog_obj();
      v54 = type;
      v15 = v172;
      if (!os_log_type_enabled(v53, type))
        goto LABEL_307;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v55 = "%{public}s called with null tlv_start, backtrace limit exceeded";
      goto LABEL_306;
    }
    v60 = (char *)__nw_create_backtrace_string();
    v53 = __nwlog_obj();
    v54 = type;
    v61 = os_log_type_enabled(v53, type);
    if (!v60)
    {
      v15 = v172;
      if (!v61)
        goto LABEL_307;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v55 = "%{public}s called with null tlv_start, no backtrace";
      goto LABEL_306;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      v179 = "nw_necp_append_tlv";
      v180 = 2082;
      *(_QWORD *)v181 = v60;
      _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v60);
    v15 = v172;
  }
LABEL_307:
  if (v52)
    free(v52);
  v19 = 0;
  v18 = v174;
  v36 = v175;
  if ((v12 & 1) != 0)
    goto LABEL_139;
LABEL_115:
  v66 = strlen(v11);
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v179 = "nw_necp_append_tlv";
    v134 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (__nwlog_fault(v134, &type, &v176))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v135 = __nwlog_obj();
        v136 = type;
        if (os_log_type_enabled(v135, type))
        {
          *(_DWORD *)buf = 136446210;
          v179 = "nw_necp_append_tlv";
          v137 = "%{public}s called with null tlv_start";
LABEL_324:
          _os_log_impl(&dword_182FBE000, v135, v136, v137, buf, 0xCu);
        }
      }
      else if (v176)
      {
        v152 = (char *)__nw_create_backtrace_string();
        v135 = __nwlog_obj();
        v136 = type;
        v153 = os_log_type_enabled(v135, type);
        if (v152)
        {
          if (v153)
          {
            *(_DWORD *)buf = 136446466;
            v179 = "nw_necp_append_tlv";
            v180 = 2082;
            *(_QWORD *)v181 = v152;
            _os_log_impl(&dword_182FBE000, v135, v136, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v152);
          v15 = v172;
          goto LABEL_325;
        }
        v15 = v172;
        if (v153)
        {
          *(_DWORD *)buf = 136446210;
          v179 = "nw_necp_append_tlv";
          v137 = "%{public}s called with null tlv_start, no backtrace";
          goto LABEL_324;
        }
      }
      else
      {
        v135 = __nwlog_obj();
        v136 = type;
        v15 = v172;
        if (os_log_type_enabled(v135, type))
        {
          *(_DWORD *)buf = 136446210;
          v179 = "nw_necp_append_tlv";
          v137 = "%{public}s called with null tlv_start, backtrace limit exceeded";
          goto LABEL_324;
        }
      }
    }
LABEL_325:
    if (v134)
      free(v134);
    v19 = 0;
    v18 = v174;
    v36 = v175;
    goto LABEL_139;
  }
  v67 = (v66 + 1);
  if (v19 >= v36)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136447234;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v36;
    *(_WORD *)&v182[8] = 1024;
    *(_DWORD *)&v182[10] = 11;
    *(_WORD *)&v182[14] = 1024;
    *(_DWORD *)&v182[16] = v67;
    v68 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v68, &type, &v176))
      goto LABEL_136;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v142 = __nwlog_obj();
      v143 = type;
      if (!os_log_type_enabled(v142, type))
        goto LABEL_136;
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 11;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v67;
      v71 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }
    else
    {
      if (v176)
      {
        v156 = (char *)__nw_create_backtrace_string();
        v157 = __nwlog_obj();
        v158 = type;
        v159 = os_log_type_enabled(v157, type);
        if (v156)
        {
          if (v159)
          {
            *(_DWORD *)buf = 136447490;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(_QWORD *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(_QWORD *)v182 = v175;
            *(_WORD *)&v182[8] = 1024;
            *(_DWORD *)&v182[10] = 11;
            *(_WORD *)&v182[14] = 1024;
            *(_DWORD *)&v182[16] = v67;
            *(_WORD *)&v182[20] = 2082;
            *(_QWORD *)&v182[22] = v156;
            _os_log_impl(&dword_182FBE000, v157, v158, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
          }
          free(v156);
          goto LABEL_136;
        }
        if (!v159)
          goto LABEL_136;
        *(_DWORD *)buf = 136447234;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(_QWORD *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(_QWORD *)v182 = v175;
        *(_WORD *)&v182[8] = 1024;
        *(_DWORD *)&v182[10] = 11;
        *(_WORD *)&v182[14] = 1024;
        *(_DWORD *)&v182[16] = v67;
        v71 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
        v76 = v157;
        v77 = v158;
LABEL_299:
        v78 = 44;
        goto LABEL_135;
      }
      v142 = __nwlog_obj();
      v143 = type;
      if (!os_log_type_enabled(v142, type))
        goto LABEL_136;
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 11;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v67;
      v71 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }
    v76 = v142;
    v77 = v143;
    goto LABEL_299;
  }
  if (v36 - v19 < v67 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136447490;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v67 + 5;
    *(_WORD *)&v182[8] = 2048;
    *(_QWORD *)&v182[10] = v36;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = 11;
    *(_WORD *)&v182[24] = 1024;
    *(_DWORD *)&v182[26] = v67;
    v68 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v68, &type, &v176))
      goto LABEL_136;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v69 = gLogObj;
      v70 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_136;
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v67 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 11;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v67;
      v71 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
LABEL_133:
      v76 = v69;
      v77 = v70;
LABEL_134:
      v78 = 54;
LABEL_135:
      _os_log_impl(&dword_182FBE000, v76, v77, v71, buf, v78);
      goto LABEL_136;
    }
    if (!v176)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v69 = gLogObj;
      v70 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_136;
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v67 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 11;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v67;
      v71 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_133;
    }
    v72 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v73 = gLogObj;
    v74 = type;
    v75 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v72)
    {
      if (v75)
      {
        *(_DWORD *)buf = 136447746;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(_QWORD *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(_QWORD *)v182 = v67 + 5;
        *(_WORD *)&v182[8] = 2048;
        *(_QWORD *)&v182[10] = v175;
        *(_WORD *)&v182[18] = 1024;
        *(_DWORD *)&v182[20] = 11;
        *(_WORD *)&v182[24] = 1024;
        *(_DWORD *)&v182[26] = v67;
        *(_WORD *)&v182[30] = 2082;
        *(_QWORD *)&v182[32] = v72;
        _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
      }
      free(v72);
      if (!v68)
        goto LABEL_138;
      goto LABEL_137;
    }
    if (v75)
    {
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v67 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 11;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v67;
      v71 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
      v76 = v73;
      v77 = v74;
      goto LABEL_134;
    }
LABEL_136:
    if (!v68)
    {
LABEL_138:
      v19 = 0;
      v18 = v174;
      v36 = v175;
      v15 = v172;
      goto LABEL_139;
    }
LABEL_137:
    free(v68);
    goto LABEL_138;
  }
  *v19 = 11;
  *(_DWORD *)(v19 + 1) = v67;
  if (v66 != -1)
    memcpy(v19 + 5, v11, v67);
  v19 += v67 + 5;
LABEL_139:
  if (!v14)
    goto LABEL_165;
  v79 = strlen(v14);
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v179 = "nw_necp_append_tlv";
    v128 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v128, &type, &v176))
      goto LABEL_316;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v129 = __nwlog_obj();
      v130 = type;
      if (!os_log_type_enabled(v129, type))
        goto LABEL_316;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v131 = "%{public}s called with null tlv_start";
    }
    else if (v176)
    {
      v146 = (char *)__nw_create_backtrace_string();
      v129 = __nwlog_obj();
      v130 = type;
      v147 = os_log_type_enabled(v129, type);
      if (v146)
      {
        if (v147)
        {
          *(_DWORD *)buf = 136446466;
          v179 = "nw_necp_append_tlv";
          v180 = 2082;
          *(_QWORD *)v181 = v146;
          _os_log_impl(&dword_182FBE000, v129, v130, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v146);
        v15 = v172;
LABEL_316:
        if (v128)
          free(v128);
        v19 = 0;
        v18 = v174;
        v36 = v175;
        if ((v173 & 1) != 0)
          goto LABEL_186;
        goto LABEL_166;
      }
      v15 = v172;
      if (!v147)
        goto LABEL_316;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v131 = "%{public}s called with null tlv_start, no backtrace";
    }
    else
    {
      v129 = __nwlog_obj();
      v130 = type;
      v15 = v172;
      if (!os_log_type_enabled(v129, type))
        goto LABEL_316;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v131 = "%{public}s called with null tlv_start, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v129, v130, v131, buf, 0xCu);
    goto LABEL_316;
  }
  v80 = (v79 + 1);
  if (v19 >= v36)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136447234;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v36;
    *(_WORD *)&v182[8] = 1024;
    *(_DWORD *)&v182[10] = 13;
    *(_WORD *)&v182[14] = 1024;
    *(_DWORD *)&v182[16] = v80;
    v81 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v81, &type, &v176))
      goto LABEL_162;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v132 = __nwlog_obj();
      v133 = type;
      if (!os_log_type_enabled(v132, type))
        goto LABEL_162;
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 13;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v80;
      v84 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
    }
    else
    {
      if (v176)
      {
        v148 = (char *)__nw_create_backtrace_string();
        v149 = __nwlog_obj();
        v150 = type;
        v151 = os_log_type_enabled(v149, type);
        if (v148)
        {
          if (v151)
          {
            *(_DWORD *)buf = 136447490;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(_QWORD *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(_QWORD *)v182 = v175;
            *(_WORD *)&v182[8] = 1024;
            *(_DWORD *)&v182[10] = 13;
            *(_WORD *)&v182[14] = 1024;
            *(_DWORD *)&v182[16] = v80;
            *(_WORD *)&v182[20] = 2082;
            *(_QWORD *)&v182[22] = v148;
            _os_log_impl(&dword_182FBE000, v149, v150, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
          }
          free(v148);
          goto LABEL_162;
        }
        if (!v151)
          goto LABEL_162;
        *(_DWORD *)buf = 136447234;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(_QWORD *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(_QWORD *)v182 = v175;
        *(_WORD *)&v182[8] = 1024;
        *(_DWORD *)&v182[10] = 13;
        *(_WORD *)&v182[14] = 1024;
        *(_DWORD *)&v182[16] = v80;
        v84 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
        v89 = v149;
        v90 = v150;
LABEL_291:
        v91 = 44;
        goto LABEL_161;
      }
      v132 = __nwlog_obj();
      v133 = type;
      if (!os_log_type_enabled(v132, type))
        goto LABEL_162;
      *(_DWORD *)buf = 136447234;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v175;
      *(_WORD *)&v182[8] = 1024;
      *(_DWORD *)&v182[10] = 13;
      *(_WORD *)&v182[14] = 1024;
      *(_DWORD *)&v182[16] = v80;
      v84 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
    }
    v89 = v132;
    v90 = v133;
    goto LABEL_291;
  }
  if (v36 - v19 < v80 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136447490;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v80 + 5;
    *(_WORD *)&v182[8] = 2048;
    *(_QWORD *)&v182[10] = v36;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = 13;
    *(_WORD *)&v182[24] = 1024;
    *(_DWORD *)&v182[26] = v80;
    v81 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v81, &type, &v176))
      goto LABEL_162;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v82 = gLogObj;
      v83 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_162;
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v80 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 13;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v80;
      v84 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
LABEL_159:
      v89 = v82;
      v90 = v83;
LABEL_160:
      v91 = 54;
LABEL_161:
      _os_log_impl(&dword_182FBE000, v89, v90, v84, buf, v91);
      goto LABEL_162;
    }
    if (!v176)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v82 = gLogObj;
      v83 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_162;
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v80 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 13;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v80;
      v84 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_159;
    }
    v85 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v86 = gLogObj;
    v87 = type;
    v88 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v85)
    {
      if (v88)
      {
        *(_DWORD *)buf = 136447746;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(_QWORD *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(_QWORD *)v182 = v80 + 5;
        *(_WORD *)&v182[8] = 2048;
        *(_QWORD *)&v182[10] = v175;
        *(_WORD *)&v182[18] = 1024;
        *(_DWORD *)&v182[20] = 13;
        *(_WORD *)&v182[24] = 1024;
        *(_DWORD *)&v182[26] = v80;
        *(_WORD *)&v182[30] = 2082;
        *(_QWORD *)&v182[32] = v85;
        _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
      }
      free(v85);
      if (!v81)
        goto LABEL_164;
      goto LABEL_163;
    }
    if (v88)
    {
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v80 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 13;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v80;
      v84 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
      v89 = v86;
      v90 = v87;
      goto LABEL_160;
    }
LABEL_162:
    if (!v81)
    {
LABEL_164:
      v19 = 0;
      v18 = v174;
      v36 = v175;
      v15 = v172;
LABEL_165:
      if ((v173 & 1) != 0)
        goto LABEL_186;
      goto LABEL_166;
    }
LABEL_163:
    free(v81);
    goto LABEL_164;
  }
  *v19 = 13;
  *(_DWORD *)(v19 + 1) = v80;
  if (v79 != -1)
    memcpy(v19 + 5, v14, v80);
  v19 += v80 + 5;
  if ((v173 & 1) != 0)
    goto LABEL_186;
LABEL_166:
  v92 = strlen(v15);
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v179 = "nw_necp_append_tlv";
    v138 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v138, &type, &v176))
      goto LABEL_332;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v139 = __nwlog_obj();
      v140 = type;
      if (!os_log_type_enabled(v139, type))
        goto LABEL_332;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v141 = "%{public}s called with null tlv_start";
    }
    else if (v176)
    {
      v154 = (char *)__nw_create_backtrace_string();
      v139 = __nwlog_obj();
      v140 = type;
      v155 = os_log_type_enabled(v139, type);
      if (v154)
      {
        if (v155)
        {
          *(_DWORD *)buf = 136446466;
          v179 = "nw_necp_append_tlv";
          v180 = 2082;
          *(_QWORD *)v181 = v154;
          _os_log_impl(&dword_182FBE000, v139, v140, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v154);
        goto LABEL_332;
      }
      if (!v155)
        goto LABEL_332;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v141 = "%{public}s called with null tlv_start, no backtrace";
    }
    else
    {
      v139 = __nwlog_obj();
      v140 = type;
      if (!os_log_type_enabled(v139, type))
        goto LABEL_332;
      *(_DWORD *)buf = 136446210;
      v179 = "nw_necp_append_tlv";
      v141 = "%{public}s called with null tlv_start, backtrace limit exceeded";
    }
    v164 = v139;
    v165 = v140;
    v166 = 12;
    goto LABEL_331;
  }
  v93 = (v92 + 1);
  if (v19 >= v36)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136447234;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v36;
    *(_WORD *)&v182[8] = 1024;
    *(_DWORD *)&v182[10] = 12;
    *(_WORD *)&v182[14] = 1024;
    *(_DWORD *)&v182[16] = v93;
    v138 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (__nwlog_fault(v138, &type, &v176))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v144 = __nwlog_obj();
        v145 = type;
        if (os_log_type_enabled(v144, type))
        {
          *(_DWORD *)buf = 136447234;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v19;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v175;
          *(_WORD *)&v182[8] = 1024;
          *(_DWORD *)&v182[10] = 12;
          *(_WORD *)&v182[14] = 1024;
          *(_DWORD *)&v182[16] = v93;
          v141 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
LABEL_302:
          v164 = v144;
          v165 = v145;
LABEL_303:
          v166 = 44;
LABEL_331:
          _os_log_impl(&dword_182FBE000, v164, v165, v141, buf, v166);
        }
      }
      else if (v176)
      {
        v160 = (char *)__nw_create_backtrace_string();
        v161 = __nwlog_obj();
        v162 = type;
        v163 = os_log_type_enabled(v161, type);
        if (v160)
        {
          if (v163)
          {
            *(_DWORD *)buf = 136447490;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(_QWORD *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(_QWORD *)v182 = v175;
            *(_WORD *)&v182[8] = 1024;
            *(_DWORD *)&v182[10] = 12;
            *(_WORD *)&v182[14] = 1024;
            *(_DWORD *)&v182[16] = v93;
            *(_WORD *)&v182[20] = 2082;
            *(_QWORD *)&v182[22] = v160;
            _os_log_impl(&dword_182FBE000, v161, v162, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
          }
          free(v160);
          goto LABEL_332;
        }
        if (v163)
        {
          *(_DWORD *)buf = 136447234;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v19;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v175;
          *(_WORD *)&v182[8] = 1024;
          *(_DWORD *)&v182[10] = 12;
          *(_WORD *)&v182[14] = 1024;
          *(_DWORD *)&v182[16] = v93;
          v141 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
          v164 = v161;
          v165 = v162;
          goto LABEL_303;
        }
      }
      else
      {
        v144 = __nwlog_obj();
        v145 = type;
        if (os_log_type_enabled(v144, type))
        {
          *(_DWORD *)buf = 136447234;
          v179 = "nw_necp_append_tlv";
          v180 = 2048;
          *(_QWORD *)v181 = v19;
          *(_WORD *)&v181[8] = 2048;
          *(_QWORD *)v182 = v175;
          *(_WORD *)&v182[8] = 1024;
          *(_DWORD *)&v182[10] = 12;
          *(_WORD *)&v182[14] = 1024;
          *(_DWORD *)&v182[16] = v93;
          v141 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
          goto LABEL_302;
        }
      }
    }
LABEL_332:
    if (v138)
      free(v138);
    v18 = v174;
    goto LABEL_186;
  }
  if (v36 - v19 < v93 + 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136447490;
    v179 = "nw_necp_append_tlv";
    v180 = 2048;
    *(_QWORD *)v181 = v19;
    *(_WORD *)&v181[8] = 2048;
    *(_QWORD *)v182 = v93 + 5;
    *(_WORD *)&v182[8] = 2048;
    *(_QWORD *)&v182[10] = v36;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = 12;
    *(_WORD *)&v182[24] = 1024;
    *(_DWORD *)&v182[26] = v93;
    v94 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v176 = 0;
    if (!__nwlog_fault(v94, &type, &v176))
      goto LABEL_184;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v95 = gLogObj;
      v96 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_184;
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v93 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 12;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v93;
      v97 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
    }
    else
    {
      if (v176)
      {
        v98 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v99 = gLogObj;
        v100 = type;
        v101 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v98)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136447746;
            v179 = "nw_necp_append_tlv";
            v180 = 2048;
            *(_QWORD *)v181 = v19;
            *(_WORD *)&v181[8] = 2048;
            *(_QWORD *)v182 = v93 + 5;
            *(_WORD *)&v182[8] = 2048;
            *(_QWORD *)&v182[10] = v175;
            *(_WORD *)&v182[18] = 1024;
            *(_DWORD *)&v182[20] = 12;
            *(_WORD *)&v182[24] = 1024;
            *(_DWORD *)&v182[26] = v93;
            *(_WORD *)&v182[30] = 2082;
            *(_QWORD *)&v182[32] = v98;
            _os_log_impl(&dword_182FBE000, v99, v100, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
          }
          free(v98);
          goto LABEL_184;
        }
        if (!v101)
        {
LABEL_184:
          v18 = v174;
          if (v94)
            free(v94);
          goto LABEL_186;
        }
        *(_DWORD *)buf = 136447490;
        v179 = "nw_necp_append_tlv";
        v180 = 2048;
        *(_QWORD *)v181 = v19;
        *(_WORD *)&v181[8] = 2048;
        *(_QWORD *)v182 = v93 + 5;
        *(_WORD *)&v182[8] = 2048;
        *(_QWORD *)&v182[10] = v175;
        *(_WORD *)&v182[18] = 1024;
        *(_DWORD *)&v182[20] = 12;
        *(_WORD *)&v182[24] = 1024;
        *(_DWORD *)&v182[26] = v93;
        v97 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
        v102 = v99;
        v103 = v100;
LABEL_183:
        _os_log_impl(&dword_182FBE000, v102, v103, v97, buf, 0x36u);
        goto LABEL_184;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v95 = gLogObj;
      v96 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_184;
      *(_DWORD *)buf = 136447490;
      v179 = "nw_necp_append_tlv";
      v180 = 2048;
      *(_QWORD *)v181 = v19;
      *(_WORD *)&v181[8] = 2048;
      *(_QWORD *)v182 = v93 + 5;
      *(_WORD *)&v182[8] = 2048;
      *(_QWORD *)&v182[10] = v175;
      *(_WORD *)&v182[18] = 1024;
      *(_DWORD *)&v182[20] = 12;
      *(_WORD *)&v182[24] = 1024;
      *(_DWORD *)&v182[26] = v93;
      v97 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
    }
    v102 = v95;
    v103 = v96;
    goto LABEL_183;
  }
  *v19 = 12;
  *(_DWORD *)(v19 + 1) = v93;
  if (v92 != -1)
    memcpy(v19 + 5, v15, v93);
LABEL_186:
  if ((setsockopt(*(_DWORD *)(v171 + 196), 0xFFFF, 4361, v18, v8) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG) || gLogFDOverride != -1)
    {
      v104 = nw_parameters_copy_description_internal(v170, 1);
      if ((*(_WORD *)(v171 + 333) & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v105 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          v106 = *(_DWORD *)(v171 + 196);
          logging_description = nw_endpoint_get_logging_description(v167);
          if (v167)
          {
            v108 = v167[11];
            v109 = v167[12];
          }
          else
          {
            v108 = 0;
            v109 = 0;
          }
          *(_DWORD *)buf = 136448258;
          v179 = "nw_protocol_socket_set_necp_attributes";
          v180 = 2082;
          *(_QWORD *)v181 = v171 + 340;
          *(_WORD *)&v181[8] = 1024;
          *(_DWORD *)v182 = v106;
          *(_WORD *)&v182[4] = 2082;
          *(_QWORD *)&v182[6] = v104;
          *(_WORD *)&v182[14] = 2082;
          *(_QWORD *)&v182[16] = logging_description;
          *(_WORD *)&v182[24] = 2080;
          *(_QWORD *)&v182[26] = v108;
          *(_WORD *)&v182[34] = 2080;
          *(_QWORD *)&v182[36] = v109;
          v183 = 1040;
          v184 = v8;
          v185 = 2096;
          v186 = v174;
          _os_log_impl(&dword_182FBE000, v105, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s setsockopt %d SO_NECP_ATTRIBUTES\nparameters: %{public}s, endpoint: %{public}s %s %s\n%{network:data}.*P", buf, 0x54u);
        }
      }
      v18 = v174;
      if (v104)
        free(v104);
    }
LABEL_215:
    if (!v18)
      return;
    goto LABEL_216;
  }
  v110 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (v110 == 22 || v110 == 42)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v111 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      goto LABEL_215;
    v112 = *(_DWORD *)(v171 + 196);
    *(_DWORD *)buf = 136447234;
    v179 = "nw_protocol_socket_set_necp_attributes";
    v180 = 1024;
    *(_DWORD *)v181 = v112;
    *(_WORD *)&v181[4] = 1040;
    *(_DWORD *)&v181[6] = v8;
    *(_WORD *)v182 = 2096;
    *(_QWORD *)&v182[2] = v18;
    *(_WORD *)&v182[10] = 1024;
    *(_DWORD *)&v182[12] = v110;
    _os_log_impl(&dword_182FBE000, v111, OS_LOG_TYPE_ERROR, "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n%{network:data}.*P %{darwin.errno}d", buf, 0x28u);
    if (!v18)
      return;
LABEL_216:
    free(v18);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v113 = *(_DWORD *)(v171 + 196);
  *(_DWORD *)buf = 136447234;
  v179 = "nw_protocol_socket_set_necp_attributes";
  v180 = 1024;
  *(_DWORD *)v181 = v113;
  *(_WORD *)&v181[4] = 1040;
  *(_DWORD *)&v181[6] = v8;
  *(_WORD *)v182 = 2096;
  *(_QWORD *)&v182[2] = v18;
  *(_WORD *)&v182[10] = 1024;
  *(_DWORD *)&v182[12] = v110;
  v114 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v176 = 0;
  if ((__nwlog_fault(v114, &type, &v176) & 1) != 0)
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v115 = gLogObj;
      v116 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_226;
      v117 = *(_DWORD *)(v171 + 196);
      *(_DWORD *)buf = 136447234;
      v179 = "nw_protocol_socket_set_necp_attributes";
      v180 = 1024;
      *(_DWORD *)v181 = v117;
      *(_WORD *)&v181[4] = 1040;
      *(_DWORD *)&v181[6] = v8;
      *(_WORD *)v182 = 2096;
      *(_QWORD *)&v182[2] = v174;
      *(_WORD *)&v182[10] = 1024;
      *(_DWORD *)&v182[12] = v110;
      v118 = "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n%{network:data}.*P %{darwin.errno}d";
LABEL_224:
      v125 = v115;
      v126 = v116;
LABEL_225:
      _os_log_impl(&dword_182FBE000, v125, v126, v118, buf, 0x28u);
      goto LABEL_226;
    }
    if (!v176)
    {
      v115 = __nwlog_obj();
      v116 = type;
      if (!os_log_type_enabled(v115, type))
        goto LABEL_226;
      v124 = *(_DWORD *)(v171 + 196);
      *(_DWORD *)buf = 136447234;
      v179 = "nw_protocol_socket_set_necp_attributes";
      v180 = 1024;
      *(_DWORD *)v181 = v124;
      *(_WORD *)&v181[4] = 1040;
      *(_DWORD *)&v181[6] = v8;
      *(_WORD *)v182 = 2096;
      *(_QWORD *)&v182[2] = v174;
      *(_WORD *)&v182[10] = 1024;
      *(_DWORD *)&v182[12] = v110;
      v118 = "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n"
             "%{network:data}.*P %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_224;
    }
    v119 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v120 = gLogObj;
    v121 = type;
    v122 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v119)
    {
      if (v122)
      {
        v123 = *(_DWORD *)(v171 + 196);
        *(_DWORD *)buf = 136447490;
        v179 = "nw_protocol_socket_set_necp_attributes";
        v180 = 1024;
        *(_DWORD *)v181 = v123;
        *(_WORD *)&v181[4] = 1040;
        *(_DWORD *)&v181[6] = v8;
        *(_WORD *)v182 = 2096;
        *(_QWORD *)&v182[2] = v174;
        *(_WORD *)&v182[10] = 1024;
        *(_DWORD *)&v182[12] = v110;
        *(_WORD *)&v182[16] = 2082;
        *(_QWORD *)&v182[18] = v119;
        _os_log_impl(&dword_182FBE000, v120, v121, "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n%{network:data}.*P %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x32u);
      }
      free(v119);
    }
    else if (v122)
    {
      v127 = *(_DWORD *)(v171 + 196);
      *(_DWORD *)buf = 136447234;
      v179 = "nw_protocol_socket_set_necp_attributes";
      v180 = 1024;
      *(_DWORD *)v181 = v127;
      *(_WORD *)&v181[4] = 1040;
      *(_DWORD *)&v181[6] = v8;
      *(_WORD *)v182 = 2096;
      *(_QWORD *)&v182[2] = v174;
      *(_WORD *)&v182[10] = 1024;
      *(_DWORD *)&v182[12] = v110;
      v118 = "%{public}s setsockopt %d SO_NECP_ATTRIBUTES failed:\n%{network:data}.*P %{darwin.errno}d, no backtrace";
      v125 = v120;
      v126 = v121;
      goto LABEL_225;
    }
  }
LABEL_226:
  if (v114)
    free(v114);
  v18 = v174;
  if (v174)
    goto LABEL_216;
}

uint64_t nw_parameters_get_attribution_context(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_parameters_get_attribution_context";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_attribution_context";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_parameters_get_attribution_context";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_attribution_context";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_parameters_get_attribution_context";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = *((_QWORD *)v1 + 13);
  if (!*(_BYTE *)(v3 + 102))
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = *(_QWORD *)(v3 + 120);
LABEL_23:

  return v4;
}

void sub_183180C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  void *v51;

  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_include_peer_to_peer(nw_parameters_t parameters)
{
  nw_parameters_t v1;
  nw_parameters_t v2;
  _BOOL4 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = parameters;
  v2 = v1;
  if (v1)
  {
    v3 = (*((unsigned __int16 *)v1[13].isa + 54) >> 3) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_get_include_peer_to_peer";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_include_peer_to_peer";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_get_include_peer_to_peer";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_include_peer_to_peer";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_get_include_peer_to_peer";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

void nw_protocol_definition_set_multipath(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 16;
    else
      v5 = 0;
    *((_BYTE *)v3 + 184) = *((_BYTE *)v3 + 184) & 0xEF | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_definition_set_multipath";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_multipath";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_definition_set_multipath";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_multipath";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_multipath";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

uint64_t NWPathMonitor.__deallocating_deinit()
{
  uint64_t v0;

  nw_path_monitor_cancel(*(nw_path_monitor_t *)(v0 + 24));
  swift_unknownObjectRelease();
  swift_release();
  return swift_deallocClassInstance();
}

uint64_t nw_path_evaluator_cancel(void *a1)
{
  char *v1;
  _DWORD *v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  void *v6;
  const void *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  id *v11;
  void *v12;
  id v13;
  void *v14;
  id v15;
  uint64_t globals_for_path;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  _BOOL8 v20;
  void **v21;
  void **v22;
  void *v23;
  uint64_t v24;
  id v25;
  int v26;
  void *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  char *backtrace_string;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  NSObject *v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  char v41;
  os_log_type_t type;
  _QWORD v43[4];
  id v44;
  _QWORD block[4];
  id v46;
  uint8_t buf[48];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (!v1)
    goto LABEL_8;
  os_unfair_lock_lock((os_unfair_lock_t)v1 + 24);
  if ((v1[107] & 0x20) != 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)v1 + 24);
LABEL_8:
    v4 = 0;
    goto LABEL_76;
  }
  if ((v1[107] & 0x40) != 0)
  {
    v2 = nw_parameters_copy_context(*((void **)v1 + 1));
    if (!v2 || (v3 = v2[31], v2, v3 != 4))
    {
      if (__nwlog_path_log::onceToken[0] != -1)
        dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44205);
      v5 = (id)gpathLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
        *(_WORD *)&buf[12] = 1042;
        *(_DWORD *)&buf[14] = 16;
        *(_WORD *)&buf[18] = 2098;
        *(_QWORD *)&buf[20] = v1 + 80;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s [%{public,uuid_t}.16P] cancel", buf, 0x1Cu);
      }

    }
  }
  v1[107] |= 0x20u;
  v6 = (void *)*((_QWORD *)v1 + 8);
  *((_QWORD *)v1 + 8) = 0;

  v7 = (const void *)*((_QWORD *)v1 + 9);
  if (v7)
  {
    v8 = _Block_copy(v7);
    v9 = v8;
    v10 = *((_QWORD *)v1 + 7);
    if (v10)
    {
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __nw_path_evaluator_cancel_block_invoke;
      block[3] = &unk_1E14AC390;
      v11 = &v46;
      v46 = v8;
      dispatch_async(v10, block);
    }
    else
    {
      v13 = nw_parameters_copy_context(*((void **)v1 + 1));
      v43[0] = MEMORY[0x1E0C809B0];
      v43[1] = 3221225472;
      v43[2] = __nw_path_evaluator_cancel_block_invoke_2;
      v43[3] = &unk_1E14AC390;
      v44 = v9;
      nw_queue_context_async(v13, v43);

      v11 = &v44;
    }

    v12 = (void *)*((_QWORD *)v1 + 9);
  }
  else
  {
    v12 = 0;
  }
  *((_QWORD *)v1 + 9) = 0;

  v14 = (void *)*((_QWORD *)v1 + 7);
  *((_QWORD *)v1 + 7) = 0;

  v15 = nw_parameters_copy_context(*((void **)v1 + 1));
  globals_for_path = nw_context_get_globals_for_path(v15);

  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
  if ((v1[107] & 1) == 0)
  {
    memset(buf, 0, 37);
    uuid_unparse((const unsigned __int8 *)v1 + 80, (char *)buf);
    v17 = *(_QWORD *)(globals_for_path + 32);
    if (v17)
      nw_dictionary_set_value(v17, (const char *)buf, 0);
    goto LABEL_66;
  }
  uuid_clear((unsigned __int8 *)v1 + 80);
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if ((sNWDispatchAllowedNow & 1) != 0)
    {
LABEL_31:
      if (!*(_QWORD *)(globals_for_path + 48))
        goto LABEL_66;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (id)gLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
        _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s Removing client from default path evaluator", buf, 0xCu);
      }

      v19 = *(_QWORD *)(globals_for_path + 48);
      if (!v19 || *(_QWORD *)(v19 + 16) == *(_QWORD *)(v19 + 24))
      {
        v20 = nw_array_create();
      }
      else
      {
        v20 = nw_array_create();
        std::vector<nw_object_wrapper_t>::reserve(v20 + 16, ((uint64_t)(*(_QWORD *)(v19 + 24) - *(_QWORD *)(v19 + 16)) >> 3) - 1);
        v22 = *(void ***)(v19 + 16);
        v21 = *(void ***)(v19 + 24);
        while (v22 != v21)
        {
          if (*v22 != v1)
            nw_array_append(v20, *v22);
          ++v22;
        }
      }
      v23 = *(void **)(globals_for_path + 48);
      *(_QWORD *)(globals_for_path + 48) = v20;

      v24 = *(_QWORD *)(globals_for_path + 48);
      if (v24)
      {
        if (*(_QWORD *)(v24 + 24) != *(_QWORD *)(v24 + 16))
          goto LABEL_66;
      }
      v25 = nw_parameters_copy_context(*((void **)v1 + 1));
      nw_path_shared_necp_fd(v25);

      if (!necp_client_action())
        goto LABEL_63;
      v26 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      __nwlog_obj();
      v27 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v26;
      v28 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v41 = 0;
      if (__nwlog_fault(v28, &type, &v41))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v30 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v26;
            _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d", buf, 0x12u);
          }
        }
        else if (v41)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v32 = type;
          v33 = os_log_type_enabled(v29, type);
          if (backtrace_string)
          {
            if (v33)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v26;
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(backtrace_string);
            goto LABEL_61;
          }
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v26;
            _os_log_impl(&dword_182FBE000, v29, v32, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          v34 = type;
          if (os_log_type_enabled(v29, type))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v26;
            _os_log_impl(&dword_182FBE000, v29, v34, "%{public}s NECP_CLIENT_ACTION_REMOVE error %{darwin.errno}d, backtrace limit exceeded", buf, 0x12u);
          }
        }

      }
LABEL_61:
      if (v28)
        free(v28);
LABEL_63:
      uuid_clear((unsigned __int8 *)globals_for_path);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = (id)gLogObj;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
        _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s Removed last default path evaluator client", buf, 0xCu);
      }

      goto LABEL_66;
    }
    if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
      || (getpid(), sandbox_check() == 1))
    {
      sNWDispatchAllowedNow = 1;
      goto LABEL_31;
    }
    if (sNWDispatchAllowedNow == 1)
      goto LABEL_31;
  }
LABEL_66:
  v36 = nw_parameters_copy_context(*((void **)v1 + 1));
  if (nw_context_is_inline(v36))
  {
    v37 = *(_QWORD *)(globals_for_path + 32);
    if (!v37 || !nw_dictionary_get_count(v37))
    {
      v38 = *(_QWORD *)(globals_for_path + 48);
      if (!v38 || *(_QWORD *)(v38 + 16) == *(_QWORD *)(v38 + 24))
      {
        if (*(_QWORD *)(globals_for_path + 56))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v39 = (id)gLogObj;
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_path_evaluator_cancel";
            _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s Suspending global NECP read source", buf, 0xCu);
          }

          *(_BYTE *)(globals_for_path + 140) |= 1u;
          nw_queue_suspend_source(*(_QWORD *)(globals_for_path + 56));
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(globals_for_path + 124));
  os_unfair_lock_unlock((os_unfair_lock_t)v1 + 24);

  v4 = 1;
LABEL_76:

  return v4;
}

void sub_183181D10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_nat64_v4_address_requires_synthesis(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  id is_eligible_for_CrazyIvan46;
  BOOL v6;
  BOOL v7;
  nw_endpoint_t v8;
  nw_endpoint_t v9;
  NWConcrete_nw_path_evaluator *v10;
  os_unfair_lock_s *v11;
  id *v12;
  os_unfair_lock_s *v13;
  uint32_t os_unfair_lock_opaque;
  os_unfair_lock_s *evaluator_for_endpoint;
  os_unfair_lock_s *v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  char v25;
  os_log_type_t type;
  _BYTE address[22];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)address = 136446210;
    *(_QWORD *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v18, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null ipv4_addr", address, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        v23 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)address = 136446466;
            *(_QWORD *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
            *(_WORD *)&address[12] = 2082;
            *(_QWORD *)&address[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s", address, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (v23)
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null ipv4_addr, no backtrace", address, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)address = 136446210;
          *(_QWORD *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_182FBE000, v19, v24, "%{public}s called with null ipv4_addr, backtrace limit exceeded", address, 0xCu);
        }
      }

    }
LABEL_44:
    if (v18)
      free(v18);
    return 0;
  }
  v1 = *a1;
  v2 = bswap32(*a1);
  if ((v2 & 0xFF000000) == 0 || (v2 & 0xFF000000) == 2130706432)
    return 0;
  v6 = v2 >> 8 == 12605539 || (v2 & 0xFFFF0000) == -1442971648;
  is_eligible_for_CrazyIvan46 = 0;
  v7 = v6 || (v2 & 0xFFFFFFF8) == -1073741824;
  if (!v7 && v1 != -1 && (v2 & 0xF0000000) != 0xE0000000)
  {
    *(_DWORD *)address = 528;
    *(_DWORD *)&address[4] = v1;
    *(_QWORD *)&address[8] = 0;
    v8 = nw_endpoint_create_address((const sockaddr *)address);
    v9 = v8;
    if (v8 && (v10 = nw_path_create_evaluator_for_endpoint(v8, 0)) != 0)
    {
      v11 = (os_unfair_lock_s *)((char *)v10 + 96);
      v12 = v10;
      os_unfair_lock_lock(v11);
      is_eligible_for_CrazyIvan46 = v12[6];
      os_unfair_lock_unlock(v11);

      if (is_eligible_for_CrazyIvan46)
      {
        v13 = (os_unfair_lock_s *)is_eligible_for_CrazyIvan46;
        os_unfair_lock_opaque = v13[94]._os_unfair_lock_opaque;

        if (os_unfair_lock_opaque == 2)
        {
          evaluator_for_endpoint = (os_unfair_lock_s *)nw_path_create_evaluator_for_endpoint(0, 0);

          v16 = nw_path_evaluator_copy_path(evaluator_for_endpoint);
          is_eligible_for_CrazyIvan46 = (id)nw_path_is_eligible_for_CrazyIvan46(v16);
          v12 = (id *)evaluator_for_endpoint;
          v13 = v16;
        }
        else
        {
          is_eligible_for_CrazyIvan46 = 0;
        }
      }
      else
      {
        v13 = 0;
      }

    }
    else
    {
      is_eligible_for_CrazyIvan46 = 0;
    }

  }
  return is_eligible_for_CrazyIvan46;
}

void sub_183182118(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_183182594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)NWConcrete_nw_path_evaluator;
  -[_Unwind_Exception dealloc](&a14, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_183182640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_context;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void nw_hash_table_release_all_objects(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD *v7;
  _QWORD *v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  uint64_t (*v15)(_QWORD);
  _QWORD *v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  unint64_t v20;
  const char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  NSObject *v25;
  void *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  int v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  os_log_type_t v38;
  int v39;
  const char *v40;
  char *v41;
  uint64_t v42;
  _BOOL4 v43;
  char *v44;
  uint64_t v45;
  _BOOL4 v46;
  char *backtrace_string;
  uint64_t v48;
  _BOOL4 v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  int v54;
  char v55;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  _BYTE v60[14];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = a1;
    if (*(_DWORD *)(a1 + 32))
    {
      v4 = *(_DWORD *)(a1 + 48);
      if ((v4 & 2) == 0)
        goto LABEL_5;
      goto LABEL_4;
    }
    v25 = __nwlog_obj(a1, a2);
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v58 = "nw_hash_table_lock";
    v26 = (void *)_os_log_send_and_compose_impl();
    v11 = __nwlog_abort((uint64_t)v26);
    if (!(_DWORD)v11)
    {
      free(v26);
      v4 = *(_DWORD *)(v3 + 48);
      if ((v4 & 2) == 0)
      {
LABEL_5:
        if ((v4 & 1) != 0)
        {
          v5 = *(_DWORD *)(v3 + 32);
          if (v5)
          {
            v6 = 0;
            v7 = (_QWORD *)(v3 + 56);
            v54 = 136446210;
            v2 = &dword_182FBE000;
            do
            {
              v8 = (_QWORD *)*v7;
              if (*v7)
              {
                v53 = v6;
                do
                {
                  v13 = v8;
                  v8 = (_QWORD *)*v8;
                  v14 = *((unsigned __int8 *)v13 + 30);
                  if (v14 == 1)
                  {
                    *((_BYTE *)v13 + 30) = 2;
                    v15 = *(uint64_t (**)(_QWORD))(v3 + 24);
                    if (v15)
                    {
                      a1 = v15(v13[2]);
                      v13[2] = 0;
                    }
                    --*(_DWORD *)(v3 + 40);
                    v16 = (_QWORD *)v13[1];
                    if (!v16 || (_QWORD *)*v16 != v13)
                    {
                      v17 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init(v17);
                      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)buf = 136446210;
                      v58 = "nw_hash_table_remove_node_internal";
                      v18 = (void *)_os_log_send_and_compose_impl();
                      v11 = __nwlog_abort((uint64_t)v18);
                      if ((_DWORD)v11)
                        goto LABEL_47;
                      free(v18);
                    }
                    if (!*((_WORD *)v13 + 14))
                      nw_hash_node_free((uint64_t)v7, v13);
                  }
                  else if (v14 != 2 || !*((_WORD *)v13 + 14))
                  {
                    v19 = __nwlog_obj(a1, a2);
                    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
                    v20 = *((unsigned __int8 *)v13 + 30);
                    v21 = "invalid_state";
                    if (v20 <= 3)
                      v21 = off_1E14A86D0[v20];
                    v9 = *((unsigned __int16 *)v13 + 14);
                    *(_DWORD *)buf = 136446722;
                    v58 = "nw_hash_table_release_all_objects";
                    v59 = 2082;
                    *(_QWORD *)v60 = v21;
                    *(_WORD *)&v60[8] = 1024;
                    *(_DWORD *)&v60[10] = v9;
                    v10 = (void *)_os_log_send_and_compose_impl();
                    v11 = __nwlog_abort((uint64_t)v10);
                    if ((_DWORD)v11)
                      goto LABEL_47;
                    free(v10);
                  }
                }
                while (v8);
                v5 = *(_DWORD *)(v3 + 32);
                v6 = v53;
              }
              ++v6;
              v7 += 2;
            }
            while (v6 < v5);
          }
          if (!*(_DWORD *)(v3 + 40))
            goto LABEL_29;
          __nwlog_obj(a1, a2);
          v33 = *(_DWORD *)(v3 + 40);
          *(_DWORD *)buf = 136446466;
          v58 = "nw_hash_table_release_all_objects";
          v59 = 1024;
          *(_DWORD *)v60 = v33;
          v34 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v55 = 0;
          v35 = __nwlog_fault(v34, &type, &v55);
          if (!(_DWORD)v35)
            goto LABEL_82;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v37 = __nwlog_obj(v35, v36);
            v38 = type;
            if (os_log_type_enabled(v37, type))
            {
              v39 = *(_DWORD *)(v3 + 40);
              *(_DWORD *)buf = 136446466;
              v58 = "nw_hash_table_release_all_objects";
              v59 = 1024;
              *(_DWORD *)v60 = v39;
              v40 = "%{public}s table count %d != 0";
LABEL_81:
              _os_log_impl(&dword_182FBE000, v37, v38, v40, buf, 0x12u);
            }
          }
          else if (v55)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            v37 = __nwlog_obj(backtrace_string, v48);
            v38 = type;
            v49 = os_log_type_enabled(v37, type);
            if (backtrace_string)
            {
              if (v49)
              {
                v50 = *(_DWORD *)(v3 + 40);
                *(_DWORD *)buf = 136446722;
                v58 = "nw_hash_table_release_all_objects";
                v59 = 1024;
                *(_DWORD *)v60 = v50;
                *(_WORD *)&v60[4] = 2082;
                *(_QWORD *)&v60[6] = backtrace_string;
                _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s table count %d != 0, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(backtrace_string);
              goto LABEL_82;
            }
            if (v49)
            {
              v52 = *(_DWORD *)(v3 + 40);
              *(_DWORD *)buf = 136446466;
              v58 = "nw_hash_table_release_all_objects";
              v59 = 1024;
              *(_DWORD *)v60 = v52;
              v40 = "%{public}s table count %d != 0, no backtrace";
              goto LABEL_81;
            }
          }
          else
          {
            v37 = __nwlog_obj(v35, v36);
            v38 = type;
            if (os_log_type_enabled(v37, type))
            {
              v51 = *(_DWORD *)(v3 + 40);
              *(_DWORD *)buf = 136446466;
              v58 = "nw_hash_table_release_all_objects";
              v59 = 1024;
              *(_DWORD *)v60 = v51;
              v40 = "%{public}s table count %d != 0, backtrace limit exceeded";
              goto LABEL_81;
            }
          }
LABEL_82:
          if (v34)
            free(v34);
          *(_DWORD *)(v3 + 40) = 0;
LABEL_29:
          if ((*(_BYTE *)(v3 + 48) & 2) != 0)
            os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 52));
          return;
        }
        __nwlog_obj(a1, a2);
        *(_DWORD *)buf = 136446210;
        v58 = "nw_hash_table_release_all_objects";
        v27 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v55 = 0;
        v28 = __nwlog_fault(v27, &type, &v55);
        if ((_DWORD)v28)
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v30 = __nwlog_obj(v28, v29);
            v31 = type;
            if (!os_log_type_enabled(v30, type))
              goto LABEL_77;
            *(_DWORD *)buf = 136446210;
            v58 = "nw_hash_table_release_all_objects";
            v32 = "%{public}s called with invalid hash table";
            goto LABEL_76;
          }
          if (!v55)
          {
            v30 = __nwlog_obj(v28, v29);
            v31 = type;
            if (!os_log_type_enabled(v30, type))
              goto LABEL_77;
            *(_DWORD *)buf = 136446210;
            v58 = "nw_hash_table_release_all_objects";
            v32 = "%{public}s called with invalid hash table, backtrace limit exceeded";
            goto LABEL_76;
          }
          v44 = (char *)__nw_create_backtrace_string();
          v30 = __nwlog_obj(v44, v45);
          v31 = type;
          v46 = os_log_type_enabled(v30, type);
          if (v44)
          {
            if (v46)
            {
              *(_DWORD *)buf = 136446466;
              v58 = "nw_hash_table_release_all_objects";
              v59 = 2082;
              *(_QWORD *)v60 = v44;
              _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v44);
            goto LABEL_77;
          }
          if (v46)
          {
            *(_DWORD *)buf = 136446210;
            v58 = "nw_hash_table_release_all_objects";
            v32 = "%{public}s called with invalid hash table, no backtrace";
LABEL_76:
            _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0xCu);
          }
        }
LABEL_77:
        if (v27)
          free(v27);
        goto LABEL_29;
      }
LABEL_4:
      os_unfair_lock_lock((os_unfair_lock_t)(v3 + 52));
      v4 = *(_DWORD *)(v3 + 48);
      goto LABEL_5;
    }
LABEL_47:
    __break(1u);
  }
  else
  {
    __nwlog_obj(0, a2);
    v54 = 136446210;
    *(_DWORD *)buf = 136446210;
    v2 = (int *)"nw_hash_table_release_all_objects";
    v58 = "nw_hash_table_release_all_objects";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    v11 = __nwlog_fault((const char *)v3, &type, &v55);
    if (!(_DWORD)v11)
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj(v11, v12);
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v58 = "nw_hash_table_release_all_objects";
      v24 = "%{public}s called with null table";
      goto LABEL_71;
    }
  }
  if (!v55)
  {
    v22 = __nwlog_obj(v11, v12);
    v23 = type;
    if (!os_log_type_enabled(v22, type))
      goto LABEL_72;
    *(_DWORD *)buf = v54;
    v58 = (const char *)v2;
    v24 = "%{public}s called with null table, backtrace limit exceeded";
    goto LABEL_71;
  }
  v41 = (char *)__nw_create_backtrace_string();
  v22 = __nwlog_obj(v41, v42);
  v23 = type;
  v43 = os_log_type_enabled(v22, type);
  if (v41)
  {
    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      v58 = (const char *)v2;
      v59 = 2082;
      *(_QWORD *)v60 = v41;
      _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v41);
    goto LABEL_72;
  }
  if (v43)
  {
    *(_DWORD *)buf = v54;
    v58 = (const char *)v2;
    v24 = "%{public}s called with null table, no backtrace";
LABEL_71:
    _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
  }
LABEL_72:
  if (v3)
    free((void *)v3);
}

void nw_path_monitor_cancel(nw_path_monitor_t monitor)
{
  NSObject *v1;
  NSObject *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = monitor;
  v2 = v1;
  if (v1)
  {
    nw_path_evaluator_cancel(v1);
    goto LABEL_3;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_path_monitor_cancel";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_monitor_cancel";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_path_monitor_cancel";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_monitor_cancel";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_path_monitor_cancel";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v4)
    free(v4);
LABEL_3:

}

void sub_1831831C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_supports_discontiguous_data(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 32;
    else
      v5 = 0;
    *((_BYTE *)v3 + 184) = *((_BYTE *)v3 + 184) & 0xDF | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_definition_set_supports_discontiguous_data";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_supports_discontiguous_data";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_definition_set_supports_discontiguous_data";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_supports_discontiguous_data";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_definition_set_supports_discontiguous_data";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

void nw_protocol_definition_set_traffic_mgmt_update(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var19 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_traffic_mgmt_update";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_traffic_mgmt_update";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_traffic_mgmt_update";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_traffic_mgmt_update";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_traffic_mgmt_update";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183183714(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_start(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var15 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_start";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_start";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_start";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_start";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_start";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1831839C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_path_changed_handler(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var26 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_path_changed_handler";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_path_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_path_changed_handler";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_path_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_path_changed_handler";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183183C6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_maximum_message_size_update(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var20 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_maximum_message_size_update";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_maximum_message_size_update";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_maximum_message_size_update";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_maximum_message_size_update";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_maximum_message_size_update";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183183F18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_link_state_update(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var17 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_link_state_update";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_link_state_update";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_link_state_update";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_link_state_update";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_link_state_update";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1831841C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_link_congestion_state_update(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var18 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_link_congestion_state_update";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_link_congestion_state_update";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_link_congestion_state_update";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_link_congestion_state_update";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_link_congestion_state_update";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_183184470(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_copy_quic_info(void *a1, void *a2)
{
  NWConcrete_nw_protocol_definition *v3;
  NWConcrete_nw_protocol_definition *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    nw_protocol_definition_initialize_extended_state(v3);
    v4->extended_state->var25 = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_definition_set_copy_quic_info";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_quic_info";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_definition_set_copy_quic_info";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_quic_info";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_definition_set_copy_quic_info";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_18318471C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t send_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  unint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  os_log_type_t v18;
  const char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  os_log_type_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t (*v29)(_QWORD, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *);
  unsigned int v30;
  int v31;
  uint64_t v32;
  char *v33;
  _BOOL4 v34;
  int v35;
  const char *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint32_t v39;
  _BOOL4 v40;
  NSObject *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  uint64_t v46;
  void (*v47)(uint64_t, _QWORD *);
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  NSObject *v54;
  os_log_type_t v55;
  uint32_t v56;
  uint64_t v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  const char *v62;
  char *v63;
  _BOOL4 v64;
  char *v65;
  NSObject *v66;
  os_log_type_t v67;
  const char *v68;
  NSObject *v69;
  NSObject *v70;
  os_log_type_t v71;
  uint64_t v72;
  NSObject *v73;
  os_log_type_t v74;
  char *backtrace_string;
  _BOOL4 v76;
  const char *v77;
  NSObject *v78;
  os_log_type_t v79;
  uint32_t v80;
  _BOOL4 v81;
  _BOOL4 v82;
  _BOOL4 v83;
  _BOOL4 v84;
  NSObject *v85;
  os_log_type_t v86;
  uint32_t v87;
  NSObject *v88;
  int v89;
  const char *v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  const char *v94;
  const char *v95;
  NSObject *v96;
  NSObject *v97;
  int v98;
  char *v99;
  _BOOL4 v100;
  const char *v101;
  const char *v102;
  NSObject *v103;
  int v104;
  const char *v105;
  NSObject *v106;
  int v107;
  char v108;
  os_log_type_t type;
  _QWORD v110[2];
  uint64_t (*v111)(uint64_t, uint64_t);
  void *v112;
  uint64_t *v113;
  uint64_t *v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t *v121;
  _QWORD *v122;
  unsigned int v123;
  _QWORD v124[3];
  int v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  int v133;
  _QWORD v134[2];
  uint64_t v135[2];
  unsigned int buf;
  const char *v137;
  __int16 v138;
  uint64_t v139;
  __int16 v140;
  _BYTE v141[14];
  uint64_t v142;

  v142 = *MEMORY[0x1E0C80C00];
  if (!a6)
  {
    __nwlog_obj();
    buf = 136446210;
    v137 = "send_data_callback";
    v65 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v130) = 16;
    LOBYTE(v126) = 0;
    if (!__nwlog_fault(v65, &v130, &v126))
      goto LABEL_179;
    if (v130 == 17)
    {
      v66 = __nwlog_obj();
      v67 = v130;
      if (!os_log_type_enabled(v66, (os_log_type_t)v130))
        goto LABEL_179;
      buf = 136446210;
      v137 = "send_data_callback";
      v68 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }
    else if ((_BYTE)v126)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v66 = __nwlog_obj();
      v67 = v130;
      v76 = os_log_type_enabled(v66, (os_log_type_t)v130);
      if (backtrace_string)
      {
        if (v76)
        {
          buf = 136446466;
          v137 = "send_data_callback";
          v138 = 2082;
          v139 = (uint64_t)backtrace_string;
          v77 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
          v78 = v66;
          v79 = v67;
          v80 = 22;
LABEL_141:
          _os_log_impl(&dword_182FBE000, v78, v79, v77, (uint8_t *)&buf, v80);
        }
LABEL_142:
        free(backtrace_string);
        goto LABEL_179;
      }
      if (!v76)
        goto LABEL_179;
      buf = 136446210;
      v137 = "send_data_callback";
      v68 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }
    else
    {
      v66 = __nwlog_obj();
      v67 = v130;
      if (!os_log_type_enabled(v66, (os_log_type_t)v130))
        goto LABEL_179;
      buf = 136446210;
      v137 = "send_data_callback";
      v68 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }
    v85 = v66;
    v86 = v67;
    v87 = 12;
LABEL_178:
    _os_log_impl(&dword_182FBE000, v85, v86, v68, (uint8_t *)&buf, v87);
    goto LABEL_179;
  }
  if (gLogDatapath)
  {
    v69 = __nwlog_obj();
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
    {
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = a6 + 205;
      _os_log_impl(&dword_182FBE000, v69, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", (uint8_t *)&buf, 0x16u);
    }
  }
  if (!a3)
  {
    __nwlog_obj();
    buf = 136446210;
    v137 = "send_data_callback";
    v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v130) = 16;
    LOBYTE(v126) = 0;
    if (!__nwlog_fault(v16, &v130, &v126))
      goto LABEL_72;
    if (v130 != 17)
    {
      if (!(_BYTE)v126)
      {
        v70 = __nwlog_obj();
        v71 = v130;
        if (os_log_type_enabled(v70, (os_log_type_t)v130))
        {
          buf = 136446210;
          v137 = "send_data_callback";
          v19 = "%{public}s called with null framehd, backtrace limit exceeded";
          goto LABEL_160;
        }
        goto LABEL_72;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v70 = __nwlog_obj();
      v71 = v130;
      v81 = os_log_type_enabled(v70, (os_log_type_t)v130);
      if (!v33)
      {
        if (v81)
        {
          buf = 136446210;
          v137 = "send_data_callback";
          v19 = "%{public}s called with null framehd, no backtrace";
          goto LABEL_160;
        }
        goto LABEL_72;
      }
      if (!v81)
        goto LABEL_44;
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = (uint64_t)v33;
      v36 = "%{public}s called with null framehd, dumping backtrace:%{public}s";
LABEL_136:
      v37 = v70;
      v38 = v71;
      v39 = 22;
      goto LABEL_43;
    }
    v70 = __nwlog_obj();
    v71 = v130;
    if (!os_log_type_enabled(v70, (os_log_type_t)v130))
      goto LABEL_72;
    buf = 136446210;
    v137 = "send_data_callback";
    v19 = "%{public}s called with null framehd";
LABEL_160:
    v54 = v70;
    v55 = v71;
    v56 = 12;
    goto LABEL_71;
  }
  if (!a2)
  {
    __nwlog_obj();
    buf = 136446210;
    v137 = "send_data_callback";
    v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v130) = 16;
    LOBYTE(v126) = 0;
    if (!__nwlog_fault(v16, &v130, &v126))
      goto LABEL_72;
    if (v130 != 17)
    {
      if (!(_BYTE)v126)
      {
        v70 = __nwlog_obj();
        v71 = v130;
        if (os_log_type_enabled(v70, (os_log_type_t)v130))
        {
          buf = 136446210;
          v137 = "send_data_callback";
          v19 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_160;
        }
        goto LABEL_72;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v70 = __nwlog_obj();
      v71 = v130;
      v82 = os_log_type_enabled(v70, (os_log_type_t)v130);
      if (!v33)
      {
        if (v82)
        {
          buf = 136446210;
          v137 = "send_data_callback";
          v19 = "%{public}s called with null frame, no backtrace";
          goto LABEL_160;
        }
        goto LABEL_72;
      }
      if (!v82)
        goto LABEL_44;
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = (uint64_t)v33;
      v36 = "%{public}s called with null frame, dumping backtrace:%{public}s";
      goto LABEL_136;
    }
    v70 = __nwlog_obj();
    v71 = v130;
    if (!os_log_type_enabled(v70, (os_log_type_t)v130))
      goto LABEL_72;
    buf = 136446210;
    v137 = "send_data_callback";
    v19 = "%{public}s called with null frame";
    goto LABEL_160;
  }
  if (!a5)
  {
    __nwlog_obj();
    buf = 136446210;
    v137 = "send_data_callback";
    v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v130) = 16;
    LOBYTE(v126) = 0;
    if (!__nwlog_fault(v16, &v130, &v126))
      goto LABEL_72;
    if (v130 == 17)
    {
      v70 = __nwlog_obj();
      v71 = v130;
      if (os_log_type_enabled(v70, (os_log_type_t)v130))
      {
        buf = 136446210;
        v137 = "send_data_callback";
        v19 = "%{public}s called with null source";
        goto LABEL_160;
      }
LABEL_72:
      if (v16)
        free(v16);
      return 4294966775;
    }
    if (!(_BYTE)v126)
    {
      v70 = __nwlog_obj();
      v71 = v130;
      if (os_log_type_enabled(v70, (os_log_type_t)v130))
      {
        buf = 136446210;
        v137 = "send_data_callback";
        v19 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_160;
      }
      goto LABEL_72;
    }
    v33 = (char *)__nw_create_backtrace_string();
    v70 = __nwlog_obj();
    v71 = v130;
    v83 = os_log_type_enabled(v70, (os_log_type_t)v130);
    if (!v33)
    {
      if (v83)
      {
        buf = 136446210;
        v137 = "send_data_callback";
        v19 = "%{public}s called with null source, no backtrace";
        goto LABEL_160;
      }
      goto LABEL_72;
    }
    if (!v83)
      goto LABEL_44;
    buf = 136446466;
    v137 = "send_data_callback";
    v138 = 2082;
    v139 = (uint64_t)v33;
    v36 = "%{public}s called with null source, dumping backtrace:%{public}s";
    goto LABEL_136;
  }
  if (!a4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = a6 + 205;
    v21 = *(_DWORD *)(a2 + 8);
    buf = 136446722;
    v137 = "send_data_callback";
    v138 = 2082;
    v139 = a6 + 205;
    v140 = 1024;
    *(_DWORD *)v141 = v21;
    v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v130) = 16;
    LOBYTE(v126) = 0;
    if (!__nwlog_fault(v16, &v130, &v126))
      goto LABEL_72;
    if (v130 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v23 = v130;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v130))
        goto LABEL_72;
      v24 = *(_DWORD *)(a2 + 8);
      buf = 136446722;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v20;
      v140 = 1024;
      *(_DWORD *)v141 = v24;
      v19 = "%{public}s %{public}s asked to send 0 bytes on stream %d";
    }
    else if ((_BYTE)v126)
    {
      v33 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v23 = v130;
      v34 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v130);
      if (v33)
      {
        if (v34)
        {
          v35 = *(_DWORD *)(a2 + 8);
          buf = 136446978;
          v137 = "send_data_callback";
          v138 = 2082;
          v139 = v20;
          v140 = 1024;
          *(_DWORD *)v141 = v35;
          *(_WORD *)&v141[4] = 2082;
          *(_QWORD *)&v141[6] = v33;
          v36 = "%{public}s %{public}s asked to send 0 bytes on stream %d, dumping backtrace:%{public}s";
          v37 = v22;
          v38 = v23;
          v39 = 38;
LABEL_43:
          _os_log_impl(&dword_182FBE000, v37, v38, v36, (uint8_t *)&buf, v39);
        }
LABEL_44:
        free(v33);
        goto LABEL_72;
      }
      if (!v34)
        goto LABEL_72;
      v53 = *(_DWORD *)(a2 + 8);
      buf = 136446722;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v20;
      v140 = 1024;
      *(_DWORD *)v141 = v53;
      v19 = "%{public}s %{public}s asked to send 0 bytes on stream %d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      v23 = v130;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v130))
        goto LABEL_72;
      v42 = *(_DWORD *)(a2 + 8);
      buf = 136446722;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v20;
      v140 = 1024;
      *(_DWORD *)v141 = v42;
      v19 = "%{public}s %{public}s asked to send 0 bytes on stream %d, backtrace limit exceeded";
    }
    v54 = v22;
    v55 = v23;
    v56 = 28;
LABEL_71:
    _os_log_impl(&dword_182FBE000, v54, v55, v19, (uint8_t *)&buf, v56);
    goto LABEL_72;
  }
  v11 = *(_QWORD *)(a2 + 16);
  if (v11)
    v12 = 10;
  else
    v12 = 9;
  if (v11 <= 1)
    v13 = 0;
  else
    v13 = v11 - 1;
  v14 = (v13 + v12);
  if (0xFFFFFFFFLL - a4 < v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = a6 + 205;
    buf = 136446466;
    v137 = "send_data_callback";
    v138 = 2082;
    v139 = a6 + 205;
    v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v130) = 16;
    LOBYTE(v126) = 0;
    if (!__nwlog_fault(v16, &v130, &v126))
      goto LABEL_72;
    if (v130 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = v130;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v130))
        goto LABEL_72;
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v15;
      v19 = "%{public}s %{public}s bytes_to_send overflow";
LABEL_70:
      v54 = v17;
      v55 = v18;
      v56 = 22;
      goto LABEL_71;
    }
    if (!(_BYTE)v126)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = v130;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v130))
        goto LABEL_72;
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v15;
      v19 = "%{public}s %{public}s bytes_to_send overflow, backtrace limit exceeded";
      goto LABEL_70;
    }
    v33 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = v130;
    v40 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v130);
    if (!v33)
    {
      if (!v40)
        goto LABEL_72;
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v15;
      v19 = "%{public}s %{public}s bytes_to_send overflow, no backtrace";
      goto LABEL_70;
    }
    if (v40)
    {
      buf = 136446722;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v15;
      v140 = 2082;
      *(_QWORD *)v141 = v33;
      v36 = "%{public}s %{public}s bytes_to_send overflow, dumping backtrace:%{public}s";
      v37 = v17;
      v38 = v18;
      v39 = 32;
      goto LABEL_43;
    }
    goto LABEL_44;
  }
  v25 = *a5;
  if (!*a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v41 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = a6 + 205;
      _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received unexpected NULL frame from data source", (uint8_t *)&buf, 0x16u);
    }
    return 4294966775;
  }
  v26 = *(_DWORD *)(v25 + 52);
  if (v26)
    v26 -= *(_DWORD *)(v25 + 56) + *(_DWORD *)(v25 + 60);
  if (v26 != (_DWORD)a4)
  {
    if (gLogDatapath)
    {
      v88 = __nwlog_obj();
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
      {
        v89 = *(_DWORD *)(v25 + 52);
        if (v89)
          v89 -= *(_DWORD *)(v25 + 56) + *(_DWORD *)(v25 + 60);
        buf = 136446978;
        v137 = "send_data_callback";
        v138 = 2082;
        v139 = a6 + 205;
        v140 = 1024;
        *(_DWORD *)v141 = v89;
        *(_WORD *)&v141[4] = 1024;
        *(_DWORD *)&v141[6] = a4;
        _os_log_impl(&dword_182FBE000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s source frame length %u, asked to send %u", (uint8_t *)&buf, 0x22u);
      }
    }
  }
  v135[0] = 0;
  v135[1] = (uint64_t)v135;
  v134[0] = 0;
  v134[1] = v134;
  v27 = *(_QWORD *)(a6 + 32);
  if (v27)
  {
    v28 = *(_QWORD *)(v27 + 24);
    if (v28)
    {
      v29 = *(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *))(v28 + 88);
      if (v29)
      {
        v30 = v14 + a4;
        v31 = v29(*(_QWORD *)(a6 + 32), a6, (v14 + a4), (v14 + a4), 0xFFFFFFFFLL, v135);
        v32 = 4294966792;
        if (!v31 || !v135[0])
          return v32;
        buf = 0;
        nw_frame_array_get_frame_count(v135, 1, &buf);
        if (buf < v30)
        {
          if (!gLogDatapath)
            return 4294966792;
          v96 = __nwlog_obj();
          if (!os_log_type_enabled(v96, OS_LOG_TYPE_DEBUG))
            return 4294966792;
          buf = 136446466;
          v137 = "send_data_callback";
          v138 = 2082;
          v139 = a6 + 205;
          _os_log_impl(&dword_182FBE000, v96, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got back fewer bytes than necessary, returing E_WOULDBLOCK", (uint8_t *)&buf, 0x16u);
          return 4294966792;
        }
        v130 = 0;
        v131 = &v130;
        v133 = 0;
        v132 = 0x2000000000;
        v126 = 0;
        v127 = &v126;
        v129 = 0;
        v128 = 0x2000000000;
        v124[0] = 0;
        v125 = 0;
        v124[1] = v124;
        v124[2] = 0x2000000000;
        v110[0] = MEMORY[0x1E0C809B0];
        v110[1] = 0x40000000;
        v111 = ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke;
        v112 = &unk_1E14A0F60;
        v117 = a6;
        v118 = a2;
        v123 = v30;
        v113 = &v130;
        v114 = &v126;
        v119 = a4;
        v120 = v25;
        v115 = v124;
        v116 = a3;
        v121 = v135;
        v122 = v134;
        v43 = v135[0];
        do
        {
          if (!v43)
            break;
          v44 = *(_QWORD *)(v43 + 32);
          v45 = ((uint64_t (*)(_QWORD *))v111)(v110);
          v43 = v44;
        }
        while ((v45 & 1) != 0);
        v46 = *(_QWORD *)(v27 + 24);
        if (v46)
        {
          v47 = *(void (**)(uint64_t, _QWORD *))(v46 + 96);
          if (v47)
          {
            v47(v27, v134);
            goto LABEL_57;
          }
        }
        __nwlog_obj();
        v90 = *(const char **)(v27 + 16);
        if (!v90)
          v90 = "invalid";
        buf = 136446466;
        v137 = "send_data_callback";
        v138 = 2082;
        v139 = (uint64_t)v90;
        v91 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v108 = 0;
        if (__nwlog_fault(v91, &type, &v108))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v92 = __nwlog_obj();
            v93 = type;
            if (!os_log_type_enabled(v92, type))
              goto LABEL_204;
            v94 = *(const char **)(v27 + 16);
            if (!v94)
              v94 = "invalid";
            buf = 136446466;
            v137 = "send_data_callback";
            v138 = 2082;
            v139 = (uint64_t)v94;
            v95 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
            goto LABEL_203;
          }
          if (!v108)
          {
            v92 = __nwlog_obj();
            v93 = type;
            if (!os_log_type_enabled(v92, type))
              goto LABEL_204;
            v102 = *(const char **)(v27 + 16);
            if (!v102)
              v102 = "invalid";
            buf = 136446466;
            v137 = "send_data_callback";
            v138 = 2082;
            v139 = (uint64_t)v102;
            v95 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
            goto LABEL_203;
          }
          v99 = (char *)__nw_create_backtrace_string();
          v92 = __nwlog_obj();
          v93 = type;
          v100 = os_log_type_enabled(v92, type);
          if (v99)
          {
            if (v100)
            {
              v101 = *(const char **)(v27 + 16);
              if (!v101)
                v101 = "invalid";
              buf = 136446722;
              v137 = "send_data_callback";
              v138 = 2082;
              v139 = (uint64_t)v101;
              v140 = 2082;
              *(_QWORD *)v141 = v99;
              _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x20u);
            }
            free(v99);
            goto LABEL_204;
          }
          if (v100)
          {
            v105 = *(const char **)(v27 + 16);
            if (!v105)
              v105 = "invalid";
            buf = 136446466;
            v137 = "send_data_callback";
            v138 = 2082;
            v139 = (uint64_t)v105;
            v95 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_203:
            _os_log_impl(&dword_182FBE000, v92, v93, v95, (uint8_t *)&buf, 0x16u);
          }
        }
LABEL_204:
        if (v91)
          free(v91);
LABEL_57:
        v48 = v135[0];
        if (v135[0])
        {
          do
          {
            v49 = *(_QWORD *)(v48 + 32);
            nw_frame_finalize(v48);
            v48 = v49;
          }
          while (v49);
        }
        if (gLogDatapath)
        {
          v97 = __nwlog_obj();
          if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
          {
            v98 = *((_DWORD *)v131 + 6);
            buf = 136446722;
            v137 = "send_data_callback";
            v138 = 2082;
            v139 = a6 + 205;
            v140 = 1024;
            *(_DWORD *)v141 = v98;
            _os_log_impl(&dword_182FBE000, v97, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes", (uint8_t *)&buf, 0x1Cu);
          }
        }
        if (*((_DWORD *)v131 + 6) == v30)
        {
          v50 = *(_DWORD *)(v25 + 52);
          if (v50)
          {
            v51 = *(_DWORD *)(v25 + 56) + *(_DWORD *)(v25 + 60);
            v52 = v50 - v51;
            if (v50 != v51)
            {
              if (gLogDatapath)
              {
                v106 = __nwlog_obj();
                if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
                {
                  v107 = *((_DWORD *)v127 + 6);
                  buf = 136446978;
                  v137 = "send_data_callback";
                  v138 = 2082;
                  v139 = a6 + 205;
                  v140 = 1024;
                  *(_DWORD *)v141 = v107;
                  *(_WORD *)&v141[4] = 1024;
                  *(_DWORD *)&v141[6] = v52;
                  _os_log_impl(&dword_182FBE000, v106, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote partial frame, %u bytes, %u remaining", (uint8_t *)&buf, 0x22u);
                }
              }
              v32 = 0;
              goto LABEL_97;
            }
            if (gLogDatapath)
              goto LABEL_197;
          }
          else if (gLogDatapath)
          {
LABEL_197:
            v103 = __nwlog_obj();
            if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
            {
              v104 = *((_DWORD *)v127 + 6);
              buf = 136446978;
              v137 = "send_data_callback";
              v138 = 2082;
              v139 = a6 + 205;
              v140 = 2048;
              *(_QWORD *)v141 = v25;
              *(_WORD *)&v141[8] = 1024;
              *(_DWORD *)&v141[10] = v104;
              _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s finished writing complete frame %p, final length %u", (uint8_t *)&buf, 0x26u);
            }
          }
          http2_transport_cache_output_frame(a6, (_QWORD *)v25);
          v32 = 0;
          *a5 = 0;
LABEL_97:
          _Block_object_dispose(v124, 8);
          _Block_object_dispose(&v126, 8);
          _Block_object_dispose(&v130, 8);
          return v32;
        }
        __nwlog_obj();
        v58 = a6 + 205;
        buf = 136446466;
        v137 = "send_data_callback";
        v138 = 2082;
        v139 = a6 + 205;
        v59 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v108 = 0;
        if (__nwlog_fault(v59, &type, &v108))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v60 = __nwlog_obj();
            v61 = type;
            if (os_log_type_enabled(v60, type))
            {
              buf = 136446466;
              v137 = "send_data_callback";
              v138 = 2082;
              v139 = v58;
              v62 = "%{public}s %{public}s did not write complete frame";
LABEL_93:
              _os_log_impl(&dword_182FBE000, v60, v61, v62, (uint8_t *)&buf, 0x16u);
            }
          }
          else if (v108)
          {
            v63 = (char *)__nw_create_backtrace_string();
            v60 = __nwlog_obj();
            v61 = type;
            v64 = os_log_type_enabled(v60, type);
            if (v63)
            {
              if (v64)
              {
                buf = 136446722;
                v137 = "send_data_callback";
                v138 = 2082;
                v139 = v58;
                v140 = 2082;
                *(_QWORD *)v141 = v63;
                _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s %{public}s did not write complete frame, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x20u);
              }
              free(v63);
              goto LABEL_94;
            }
            if (v64)
            {
              buf = 136446466;
              v137 = "send_data_callback";
              v138 = 2082;
              v139 = v58;
              v62 = "%{public}s %{public}s did not write complete frame, no backtrace";
              goto LABEL_93;
            }
          }
          else
          {
            v60 = __nwlog_obj();
            v61 = type;
            if (os_log_type_enabled(v60, type))
            {
              buf = 136446466;
              v137 = "send_data_callback";
              v138 = 2082;
              v139 = v58;
              v62 = "%{public}s %{public}s did not write complete frame, backtrace limit exceeded";
              goto LABEL_93;
            }
          }
        }
LABEL_94:
        if (v59)
          free(v59);
        v32 = 4294966394;
        goto LABEL_97;
      }
    }
  }
  __nwlog_obj();
  v72 = a6 + 205;
  buf = 136446466;
  v137 = "send_data_callback";
  v138 = 2082;
  v139 = a6 + 205;
  v65 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v130) = 16;
  LOBYTE(v126) = 0;
  if (!__nwlog_fault(v65, &v130, &v126))
    goto LABEL_179;
  if (v130 == 17)
  {
    v73 = __nwlog_obj();
    v74 = v130;
    if (os_log_type_enabled(v73, (os_log_type_t)v130))
    {
      buf = 136446466;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v72;
      v68 = "%{public}s %{public}s output handler has no get_output_frames callback";
LABEL_177:
      v85 = v73;
      v86 = v74;
      v87 = 22;
      goto LABEL_178;
    }
    goto LABEL_179;
  }
  if ((_BYTE)v126)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    v73 = __nwlog_obj();
    v74 = v130;
    v84 = os_log_type_enabled(v73, (os_log_type_t)v130);
    if (!backtrace_string)
    {
      if (v84)
      {
        buf = 136446466;
        v137 = "send_data_callback";
        v138 = 2082;
        v139 = v72;
        v68 = "%{public}s %{public}s output handler has no get_output_frames callback, no backtrace";
        goto LABEL_177;
      }
      goto LABEL_179;
    }
    if (v84)
    {
      buf = 136446722;
      v137 = "send_data_callback";
      v138 = 2082;
      v139 = v72;
      v140 = 2082;
      *(_QWORD *)v141 = backtrace_string;
      v77 = "%{public}s %{public}s output handler has no get_output_frames callback, dumping backtrace:%{public}s";
      v78 = v73;
      v79 = v74;
      v80 = 32;
      goto LABEL_141;
    }
    goto LABEL_142;
  }
  v73 = __nwlog_obj();
  v74 = v130;
  if (os_log_type_enabled(v73, (os_log_type_t)v130))
  {
    buf = 136446466;
    v137 = "send_data_callback";
    v138 = 2082;
    v139 = v72;
    v68 = "%{public}s %{public}s output handler has no get_output_frames callback, backtrace limit exceeded";
    goto LABEL_177;
  }
LABEL_179:
  if (v65)
    free(v65);
  return 4294966394;
}

uint64_t nw_socket_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  nw_frame *tqh_first;
  uint64_t v4;
  nw_frame **v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_socket_finalize_output_frames";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_socket_finalize_output_frames";
      v10 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v15)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (!os_log_type_enabled(v8, type))
          goto LABEL_38;
        *(_DWORD *)buf = 136446210;
        v18 = "nw_socket_finalize_output_frames";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_37;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_socket_finalize_output_frames";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v7)
          return 0;
        goto LABEL_39;
      }
      if (!v12)
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_socket_finalize_output_frames";
      v10 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_37:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_38;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_socket_finalize_output_frames";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_socket_finalize_output_frames";
      v10 = "%{public}s called with null socket_handler";
      goto LABEL_37;
    }
    if (!v15)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_socket_finalize_output_frames";
      v10 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_37;
    }
    v13 = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v14 = os_log_type_enabled(v8, type);
    if (!v13)
    {
      if (!v14)
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_socket_finalize_output_frames";
      v10 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_37;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v18 = "nw_socket_finalize_output_frames";
      v19 = 2082;
      v20 = v13;
      _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v13);
LABEL_38:
    if (!v7)
      return 0;
LABEL_39:
    free(v7);
    return 0;
  }
  while (1)
  {
    tqh_first = a2->tqh_first;
    if (!a2->tqh_first)
      break;
    v4 = *((_QWORD *)tqh_first + 4);
    v5 = (nw_frame **)*((_QWORD *)tqh_first + 5);
    if (v4)
    {
      *(_QWORD *)(v4 + 40) = v5;
      v5 = (nw_frame **)*((_QWORD *)tqh_first + 5);
    }
    else
    {
      a2->tqh_last = v5;
    }
    *v5 = (nw_frame *)v4;
    *((_QWORD *)tqh_first + 4) = 0;
    *((_QWORD *)tqh_first + 5) = 0;
    nw_frame_finalize((uint64_t)tqh_first);
  }
  return 1;
}

void nw_socket_frame_output_finalizer(nw_frame *a1, nw_protocol *a2, char *a3)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;

  v5 = *((_QWORD *)a1 + 2);
  v6 = (_QWORD *)*((_QWORD *)a1 + 3);
  v4 = (_QWORD *)((char *)a1 + 16);
  if (v5)
  {
    *(_QWORD *)(v5 + 24) = v6;
    v6 = (_QWORD *)*((_QWORD *)a1 + 3);
  }
  else
  {
    *((_QWORD *)a3 + 32) = v6;
  }
  *v6 = v5;
  *v4 = 0;
  *((_QWORD *)a1 + 3) = 0;
  if ((_DWORD)a2)
  {
    v7 = (_QWORD *)*((_QWORD *)a3 + 34);
    *((_QWORD *)a1 + 3) = v7;
    *v7 = a1;
    *((_QWORD *)a3 + 34) = v4;
    nw_socket_service_writes((uint64_t)a3);
  }
  else
  {
    v8 = (_QWORD *)*((_QWORD *)a3 + 30);
    *((_QWORD *)a1 + 3) = v8;
    *v8 = a1;
    *((_QWORD *)a3 + 30) = v4;
  }
  if ((*(_WORD *)(a3 + 333) & 8) != 0)
    nw_socket_output_finished((nw_protocol *)(a3 - 96), a2);
}

BOOL nw_socket_service_writes(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  char v4;
  int v5;
  _WORD *v6;
  int v7;
  int v8;
  _QWORD v10[2];
  BOOL (*v11)(uint64_t, uint64_t);
  void *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;

  v15 = 0;
  v16 = &v15;
  v18 = 0;
  v17 = 0x2000000000;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v11 = ___ZL24nw_socket_service_writesP9nw_socket_block_invoke;
  v12 = &unk_1E14A8B08;
  v13 = &v15;
  v14 = a1;
  v2 = *(_QWORD *)(a1 + 264);
  do
  {
    if (!v2)
      break;
    v3 = *(_QWORD *)(v2 + 16);
    v4 = ((uint64_t (*)(_QWORD *))v11)(v10);
    v2 = v3;
  }
  while ((v4 & 1) != 0);
  v5 = *((_DWORD *)v16 + 6);
  v6 = (_WORD *)(a1 + 333);
  v7 = *(unsigned __int16 *)(a1 + 333) | (*(unsigned __int8 *)(a1 + 335) << 16);
  if (v5)
  {
    if ((*(_WORD *)(a1 + 333) & 0x800) == 0)
    {
      *(_BYTE *)(a1 + 335) = BYTE2(v7);
      *v6 = v7 | 0x800;
      nw_queue_resume_source(*(_QWORD *)(a1 + 152), v2);
      LOWORD(v7) = *v6;
    }
    if ((v7 & 0x8000) == 0)
      nw_socket_set_send_low_water_mark(a1, *((_DWORD *)v16 + 6));
  }
  else if ((*(_WORD *)(a1 + 333) & 0x800) != 0)
  {
    v8 = *(_WORD *)(a1 + 333) & 0xF7FF | (*(unsigned __int8 *)(a1 + 335) << 16);
    *v6 = *(_WORD *)(a1 + 333) & 0xF7FF;
    *(_BYTE *)(a1 + 335) = BYTE2(v8);
    nw_queue_suspend_source(*(_QWORD *)(a1 + 152));
  }
  _Block_object_dispose(&v15, 8);
  return v5 == 0;
}

BOOL ___ZL24nw_socket_service_writesP9nw_socket_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *external_data;
  NSObject *v6;
  int v7;
  void *buffer;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t v11;
  _BOOL4 v12;
  BOOL v13;
  uint64_t v14;
  void *v15;
  char v16;
  char v17;
  unsigned __int8 v18;
  uint64_t v19;
  int v20;
  int v21;
  NSObject *v22;
  const char *v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  ssize_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  __int16 v41;
  NSObject *v42;
  _BOOL4 v43;
  const char *v44;
  uint64_t v45;
  NSObject *v46;
  _BOOL4 v47;
  const char *v48;
  _OWORD *v49;
  uint64_t v50;
  NSObject *v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  ssize_t v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  ssize_t v59;
  int v60;
  _OWORD *v61;
  uint64_t v62;
  NSObject *v63;
  uint64_t v64;
  const char *v65;
  uint64_t v66;
  ssize_t v67;
  NSObject *v68;
  uint64_t v69;
  uint64_t v70;
  ssize_t v71;
  int v72;
  uint64_t v73;
  int v74;
  unsigned int v75;
  __int16 v76;
  uint64_t v77;
  uint64_t v78;
  const char *v79;
  const char *v80;
  NSObject *v81;
  os_log_type_t v82;
  uint32_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  const char *v87;
  int v88;
  const char *v89;
  NSObject *v90;
  os_log_type_t v91;
  uint32_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  uint64_t v99;
  uint64_t v100;
  size_t *p_iov_len;
  int v102;
  char *v103;
  NSObject *v104;
  os_log_type_t v105;
  const char *v106;
  char *backtrace_string;
  _BOOL4 v108;
  char *v109;
  _BOOL4 v110;
  int v111;
  nw_protocol *v112;
  _QWORD *v113;
  uint64_t v114;
  _QWORD *v115;
  uint64_t v116;
  uint64_t *v117;
  _BOOL8 result;
  uint64_t v119;
  nw_protocol *v120;
  char *v121;
  NSObject *v122;
  os_log_type_t v123;
  const char *v124;
  char *v125;
  _BOOL4 v126;
  NSObject *v127;
  void *v128;
  NSObject *v129;
  void *v130;
  NSObject *v131;
  _BOOL4 v132;
  const char *v133;
  NSObject *v134;
  uint64_t v135;
  const char *v136;
  unsigned int v137;
  msghdr v138;
  _DWORD size[3];
  uint64_t v140;
  _BYTE applier[56];
  void *v142;
  __int128 v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;

  v150 = *MEMORY[0x1E0C80C00];
  size[0] = 0;
  v4 = nw_frame_uses_external_data(a2);
  memset(&v138, 0, sizeof(v138));
  v138.msg_flags = 128;
  if (!v4)
  {
    v9 = nw_frame_unclaimed_bytes(a2, size);
    v10 = v9 != 0;
    v11 = size[0];
    v12 = size[0] != 0;
    v13 = !v10 || !v12;
    if (v10 && v12)
      v14 = v9;
    else
      v14 = 0;
    if (v13)
      v11 = 0;
    *(_QWORD *)&size[1] = v14;
    v140 = v11;
    v138.msg_iov = (iovec *)&size[1];
    v138.msg_iovlen = 1;
    buffer = (void *)nw_frame_get_buffer(a2, 0);
    goto LABEL_14;
  }
  v137 = 0;
  external_data = nw_frame_get_external_data(a2, &v137, size);
  if (!external_data || !size[0])
  {
    v15 = 0;
    *(_QWORD *)&size[1] = 0;
    v140 = 0;
    goto LABEL_31;
  }
  v6 = external_data;
  v7 = nw_dispatch_data_to_iovec(external_data, v137, size[0], (uint64_t)&size[1], 10);
  if (v7)
  {
    v138.msg_iov = (iovec *)&size[1];
    v138.msg_iovlen = v7;
    if (v7 < 1)
    {
LABEL_139:
      nw_frame_set_external_data(a2, 0, 0);
LABEL_193:
      v111 = *(char *)(a2 + 186);
      nw_frame_reset(a2, 0, 0, 0, 0);
      v114 = *(_QWORD *)(a2 + 16);
      v115 = *(_QWORD **)(a2 + 24);
      v113 = (_QWORD *)(a2 + 16);
      if (v114)
      {
        *(_QWORD *)(v114 + 24) = v115;
        v115 = *(_QWORD **)(a2 + 24);
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 272) = v115;
      }
      *v115 = v114;
      *v113 = 0;
      *(_QWORD *)(a2 + 24) = 0;
      v116 = *(_QWORD *)(a1 + 40);
      v117 = *(uint64_t **)(v116 + 240);
      *(_QWORD *)(a2 + 24) = v117;
      *v117 = a2;
      *(_QWORD *)(v116 + 240) = v113;
      if ((v111 & 0x80000000) == 0)
        return 1;
      v119 = *(_QWORD *)(a1 + 40);
      if ((!v119 || (*(_WORD *)(v119 + 333) & 0x80) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v131 = gconnectionLogObj;
        v132 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        v119 = *(_QWORD *)(a1 + 40);
        if (v132)
        {
          if (v119)
            v133 = (const char *)(v119 + 340);
          else
            v133 = "";
          *(_DWORD *)applier = 136446466;
          *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
          *(_WORD *)&applier[12] = 2082;
          *(_QWORD *)&applier[14] = v133;
          _os_log_impl(&dword_182FBE000, v131, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s calling output finished because frame indicated connection is complete", applier, 0x16u);
          v119 = *(_QWORD *)(a1 + 40);
        }
      }
      if (v119)
        v120 = (nw_protocol *)(v119 - 96);
      else
        v120 = 0;
      nw_socket_output_finished(v120, v112);
      return 0;
    }
    buffer = 0;
LABEL_14:
    v15 = 0;
    if (a2)
    {
LABEL_15:
      v16 = *(_BYTE *)(a2 + 186) & 3;
      v17 = *(_BYTE *)(a2 + 184);
      goto LABEL_16;
    }
LABEL_32:
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "__nw_frame_get_ecn_flag";
    v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v146) = 16;
    LOBYTE(v143) = 0;
    if (!__nwlog_fault(v27, &v146, &v143))
      goto LABEL_213;
    if (v146 == 17)
    {
      v28 = __nwlog_obj();
      v29 = v146;
      if (!os_log_type_enabled(v28, (os_log_type_t)v146))
        goto LABEL_213;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "__nw_frame_get_ecn_flag";
      v30 = "%{public}s called with null frame";
    }
    else if ((_BYTE)v143)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = v146;
      v108 = os_log_type_enabled(v28, (os_log_type_t)v146);
      if (backtrace_string)
      {
        if (v108)
        {
          *(_DWORD *)applier = 136446466;
          *(_QWORD *)&applier[4] = "__nw_frame_get_ecn_flag";
          *(_WORD *)&applier[12] = 2082;
          *(_QWORD *)&applier[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null frame, dumping backtrace:%{public}s", applier, 0x16u);
        }
        free(backtrace_string);
LABEL_213:
        if (v27)
          free(v27);
        __nwlog_obj();
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "__nw_frame_get_dscp_value";
        v121 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(v146) = 16;
        LOBYTE(v143) = 0;
        if (!__nwlog_fault(v121, &v146, &v143))
          goto LABEL_234;
        if (v146 == 17)
        {
          v122 = __nwlog_obj();
          v123 = v146;
          if (os_log_type_enabled(v122, (os_log_type_t)v146))
          {
            *(_DWORD *)applier = 136446210;
            *(_QWORD *)&applier[4] = "__nw_frame_get_dscp_value";
            v124 = "%{public}s called with null frame";
LABEL_233:
            _os_log_impl(&dword_182FBE000, v122, v123, v124, applier, 0xCu);
          }
        }
        else if ((_BYTE)v143)
        {
          v125 = (char *)__nw_create_backtrace_string();
          v122 = __nwlog_obj();
          v123 = v146;
          v126 = os_log_type_enabled(v122, (os_log_type_t)v146);
          if (v125)
          {
            if (v126)
            {
              *(_DWORD *)applier = 136446466;
              *(_QWORD *)&applier[4] = "__nw_frame_get_dscp_value";
              *(_WORD *)&applier[12] = 2082;
              *(_QWORD *)&applier[14] = v125;
              _os_log_impl(&dword_182FBE000, v122, v123, "%{public}s called with null frame, dumping backtrace:%{public}s", applier, 0x16u);
            }
            free(v125);
            goto LABEL_234;
          }
          if (v126)
          {
            *(_DWORD *)applier = 136446210;
            *(_QWORD *)&applier[4] = "__nw_frame_get_dscp_value";
            v124 = "%{public}s called with null frame, no backtrace";
            goto LABEL_233;
          }
        }
        else
        {
          v122 = __nwlog_obj();
          v123 = v146;
          if (os_log_type_enabled(v122, (os_log_type_t)v146))
          {
            *(_DWORD *)applier = 136446210;
            *(_QWORD *)&applier[4] = "__nw_frame_get_dscp_value";
            v124 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_233;
          }
        }
LABEL_234:
        if (v121)
          free(v121);
        v16 = 0;
        v17 = 0;
LABEL_16:
        v18 = v16 | (4 * v17);
        v19 = *(_QWORD *)(a1 + 40);
        if (*(unsigned __int8 *)(v19 + 332) == v18)
          goto LABEL_39;
        LODWORD(v146) = v18;
        v20 = *(unsigned __int8 *)(v19 + 336);
        if (v20 == 30)
        {
          if (setsockopt(*(_DWORD *)(v19 + 196), 41, 36, &v146, 4u) < 0)
          {
            v31 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v22 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_39;
            *(_DWORD *)applier = 136446466;
            *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
            *(_WORD *)&applier[12] = 1024;
            *(_DWORD *)&applier[14] = v31;
            v23 = "%{public}s setsockopt IPV6_TCLASS %{darwin.errno}d";
LABEL_38:
            _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, v23, applier, 0x12u);
LABEL_39:
            if (a2)
            {
              v32 = *(_DWORD *)(a2 + 176);
              if (v32 > 3145999)
              {
                if (v32 <= 3670319)
                {
                  if (v32 == 3146000)
                  {
                    v33 = 5;
                    goto LABEL_61;
                  }
                  if (v32 == 3670272)
                  {
                    v33 = 3;
                    goto LABEL_61;
                  }
                  goto LABEL_62;
                }
                if (v32 == 3670320)
                {
                  v33 = 2;
                  goto LABEL_61;
                }
                if (v32 == 4194688)
                {
                  v33 = 4;
                  goto LABEL_61;
                }
                if (v32 != 4718992)
                  goto LABEL_62;
              }
              else
              {
                if (v32 <= 1572879)
                {
                  v33 = 1;
                  if (v32 == 524432 || v32 == 1048704)
                    goto LABEL_61;
                  goto LABEL_62;
                }
                if (v32 != 1572880)
                {
                  if (v32 == 2097184)
                  {
                    v33 = 7;
                    goto LABEL_61;
                  }
                  if (v32 == 2621728)
                  {
                    v33 = 6;
LABEL_61:
                    v146 = 0xFFFF00000010;
                    v138.msg_controllen += 16;
                    LODWORD(v147) = 4374;
                    HIDWORD(v147) = v33;
                    v138.msg_control = &v146;
                  }
LABEL_62:
                  v35 = sendmsg(*(_DWORD *)(*(_QWORD *)(a1 + 40) + 196), &v138, 0);
                  if ((v35 & 0x8000000000000000) == 0)
                  {
                    v36 = *(_QWORD *)(a1 + 40);
                    if (((*(unsigned __int16 *)(v36 + 333) | (*(unsigned __int8 *)(v36 + 335) << 16)) & 0x40000) != 0)
                    {
                      nw_socket_internal_error(v36, 0);
                      v37 = *(_QWORD *)(a1 + 40);
                      v38 = *(unsigned __int16 *)(v37 + 333);
                      v39 = (v38 | (*(unsigned __int8 *)(v37 + 335) << 16)) & 0xFFFBFFFF;
                      *(_WORD *)(v37 + 333) = v38;
                      *(_BYTE *)(v37 + 335) = BYTE2(v39);
                    }
                  }
                  if (v15)
                    free(v15);
                  if ((v35 & 0x8000000000000000) == 0)
                  {
                    v40 = *(_QWORD *)(a1 + 40);
                    v41 = *(_WORD *)(v40 + 333);
                    if (size[0] > v35)
                    {
                      if ((*(_WORD *)(v40 + 333) & 0x100) != 0)
                      {
                        v143 = 0uLL;
                        if (v40)
                          v49 = (_OWORD *)(v40 - 96);
                        else
                          v49 = 0;
                        nw_protocol_get_flow_id(v49, &v143);
                        v50 = *(_QWORD *)(a1 + 40);
                        if (!v50 || (*(_WORD *)(v50 + 333) & 0x80) == 0)
                        {
                          if (__nwlog_connection_log::onceToken != -1)
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                          v51 = gconnectionLogObj;
                          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                          {
                            v52 = *(_QWORD *)(a1 + 40);
                            v53 = (const char *)(v52 + 340);
                            if (!v52)
                              v53 = "";
                            v54 = *(_QWORD *)(v52 + 8);
                            v55 = v35 - 1;
                            if (!v35)
                              v55 = 0;
                            *(_DWORD *)applier = 136447490;
                            *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                            *(_WORD *)&applier[12] = 2082;
                            *(_QWORD *)&applier[14] = v53;
                            *(_WORD *)&applier[22] = 1024;
                            *(_DWORD *)&applier[24] = v35;
                            *(_WORD *)&applier[28] = 1024;
                            *(_DWORD *)&applier[30] = size[0];
                            *(_WORD *)&applier[34] = 2048;
                            *(_QWORD *)&applier[36] = v54;
                            *(_WORD *)&applier[44] = 2048;
                            *(_QWORD *)&applier[46] = v54 + v55;
                            _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Wrote %u/%u bytes, waiting for writable event (overall bytes %llu -> %llu)", applier, 0x36u);
                          }
                        }
                        pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
                        v56 = gMpklLogObj;
                        if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
                        {
                          v57 = *(_QWORD *)(a1 + 40);
                          v58 = *(_QWORD *)(v57 + 8);
                          v59 = v35 - 1;
                          if (!v35)
                            v59 = 0;
                          v60 = *(unsigned __int8 *)(v57 + 337);
                          *(_DWORD *)applier = 67110658;
                          *(_DWORD *)&applier[4] = 150;
                          *(_WORD *)&applier[8] = 1024;
                          *(_DWORD *)&applier[10] = 100;
                          *(_WORD *)&applier[14] = 1042;
                          *(_DWORD *)&applier[16] = 16;
                          *(_WORD *)&applier[20] = 2098;
                          *(_QWORD *)&applier[22] = &v143;
                          *(_WORD *)&applier[30] = 2048;
                          *(_QWORD *)&applier[32] = v58;
                          *(_WORD *)&applier[40] = 2048;
                          *(_QWORD *)&applier[42] = v58 + v59;
                          *(_WORD *)&applier[50] = 1024;
                          *(_DWORD *)&applier[52] = v60;
                          _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_DEFAULT, "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %llu, logSeqn: %hhu}", applier, 0x38u);
                        }
                        v40 = *(_QWORD *)(a1 + 40);
                        ++*(_BYTE *)(v40 + 337);
                      }
                      else if ((v41 & 0x80) == 0 && gLogDatapath)
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v42 = gconnectionLogObj;
                        v43 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
                        v40 = *(_QWORD *)(a1 + 40);
                        if (v43)
                        {
                          v44 = (const char *)(v40 + 340);
                          *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                          *(_DWORD *)applier = 136446978;
                          if (!v40)
                            v44 = "";
                          *(_WORD *)&applier[12] = 2082;
                          *(_QWORD *)&applier[14] = v44;
                          *(_WORD *)&applier[22] = 1024;
                          *(_DWORD *)&applier[24] = v35;
                          *(_WORD *)&applier[28] = 1024;
                          *(_DWORD *)&applier[30] = size[0];
                          _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Wrote %u/%u bytes, waiting for writable event", applier, 0x22u);
                          v40 = *(_QWORD *)(a1 + 40);
                        }
                      }
                      *(_QWORD *)(v40 + 8) += v35;
                      if (*(_DWORD *)(v40 + 200) == 1)
                        ++*(_QWORD *)(v40 + 24);
                      nw_frame_claim(a2, v34, v35, 0);
                      *(_BYTE *)(*(_QWORD *)(a1 + 40) + 335) |= 0x20u;
                      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = size[0] - v35;
                      return 0;
                    }
                    if ((*(_WORD *)(v40 + 333) & 0x100) != 0)
                    {
                      v143 = 0uLL;
                      if (v40)
                        v61 = (_OWORD *)(v40 - 96);
                      else
                        v61 = 0;
                      nw_protocol_get_flow_id(v61, &v143);
                      v62 = *(_QWORD *)(a1 + 40);
                      if (!v62 || (*(_WORD *)(v62 + 333) & 0x80) == 0)
                      {
                        if (__nwlog_connection_log::onceToken != -1)
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                        v63 = gconnectionLogObj;
                        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                        {
                          v64 = *(_QWORD *)(a1 + 40);
                          v65 = (const char *)(v64 + 340);
                          if (!v64)
                            v65 = "";
                          v66 = *(_QWORD *)(v64 + 8);
                          v67 = v35 - 1;
                          if (!v35)
                            v67 = 0;
                          *(_DWORD *)applier = 136447234;
                          *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                          *(_WORD *)&applier[12] = 2082;
                          *(_QWORD *)&applier[14] = v65;
                          *(_WORD *)&applier[22] = 1024;
                          *(_DWORD *)&applier[24] = size[0];
                          *(_WORD *)&applier[28] = 2048;
                          *(_QWORD *)&applier[30] = v66;
                          *(_WORD *)&applier[38] = 2048;
                          *(_QWORD *)&applier[40] = v66 + v67;
                          _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Wrote %u bytes (overall bytes %llu -> %llu)", applier, 0x30u);
                        }
                      }
                      pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
                      v68 = gMpklLogObj;
                      if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
                      {
                        v69 = *(_QWORD *)(a1 + 40);
                        v70 = *(_QWORD *)(v69 + 8);
                        v71 = v35 - 1;
                        if (!v35)
                          v71 = 0;
                        v72 = *(unsigned __int8 *)(v69 + 337);
                        *(_DWORD *)applier = 67110658;
                        *(_DWORD *)&applier[4] = 150;
                        *(_WORD *)&applier[8] = 1024;
                        *(_DWORD *)&applier[10] = 100;
                        *(_WORD *)&applier[14] = 1042;
                        *(_DWORD *)&applier[16] = 16;
                        *(_WORD *)&applier[20] = 2098;
                        *(_QWORD *)&applier[22] = &v143;
                        *(_WORD *)&applier[30] = 2048;
                        *(_QWORD *)&applier[32] = v70;
                        *(_WORD *)&applier[40] = 2048;
                        *(_QWORD *)&applier[42] = v70 + v71;
                        *(_WORD *)&applier[50] = 1024;
                        *(_DWORD *)&applier[52] = v72;
                        _os_log_impl(&dword_182FBE000, v68, OS_LOG_TYPE_DEFAULT, "32 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, curStart: %llu, curEnd: %llu, logSeqn: %hhu}", applier, 0x38u);
                      }
                      v40 = *(_QWORD *)(a1 + 40);
                      ++*(_BYTE *)(v40 + 337);
                    }
                    else if ((v41 & 0x80) == 0 && gLogDatapath)
                    {
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v46 = gconnectionLogObj;
                      v47 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
                      v40 = *(_QWORD *)(a1 + 40);
                      if (v47)
                      {
                        v48 = (const char *)(v40 + 340);
                        *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                        *(_DWORD *)applier = 136446722;
                        if (!v40)
                          v48 = "";
                        *(_WORD *)&applier[12] = 2082;
                        *(_QWORD *)&applier[14] = v48;
                        *(_WORD *)&applier[22] = 1024;
                        *(_DWORD *)&applier[24] = size[0];
                        _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Wrote %u bytes", applier, 0x1Cu);
                        v40 = *(_QWORD *)(a1 + 40);
                      }
                    }
                    *(_QWORD *)(v40 + 8) += v35;
                    if (*(_DWORD *)(v40 + 200) == 1)
                      ++*(_QWORD *)(v40 + 24);
                    if (((*(unsigned __int16 *)(v40 + 333) | (*(unsigned __int8 *)(v40 + 335) << 16)) & 0x200000) != 0)
                    {
                      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
                      nw_socket_set_send_low_water_mark(v40, 1u);
                      v73 = *(_QWORD *)(a1 + 40);
                      v74 = *(unsigned __int16 *)(v73 + 333);
                      v75 = (v74 | (*(unsigned __int8 *)(v73 + 335) << 16)) & 0xFFDFFFFF;
                      *(_WORD *)(v73 + 333) = v74;
                      *(_BYTE *)(v73 + 335) = BYTE2(v75);
                    }
                    if (_nw_signposts_once != -1)
                      dispatch_once(&_nw_signposts_once, &__block_literal_global_18_63832);
                    if (_nw_signposts_enabled && kdebug_is_enabled())
                    {
                      kdebug_trace();
                      if (v4)
                        goto LABEL_139;
                    }
                    else if (v4)
                    {
                      goto LABEL_139;
                    }
                    if (buffer)
                      free(buffer);
                    goto LABEL_193;
                  }
                  v45 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                  if ((_DWORD)v45 == 32)
                  {
                    v84 = *(_QWORD *)(a1 + 40);
                    if (v84 && (*(_WORD *)(v84 + 333) & 0x80) != 0)
                      goto LABEL_162;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v85 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
                      goto LABEL_162;
                    v86 = *(_QWORD *)(a1 + 40);
                    v87 = (const char *)(v86 + 340);
                    if (!v86)
                      v87 = "";
                    v88 = *(_DWORD *)(v86 + 196);
                    *(_DWORD *)applier = 136446978;
                    *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2082;
                    *(_QWORD *)&applier[14] = v87;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = v88;
                    *(_WORD *)&applier[28] = 1024;
                    *(_DWORD *)&applier[30] = size[0];
                    v89 = "%{public}s %{public}s sendmsg(fd %d, %u bytes): socket has been closed";
                    v90 = v85;
                    v91 = OS_LOG_TYPE_INFO;
                    v92 = 34;
                    goto LABEL_161;
                  }
                  if ((_DWORD)v45 != 35)
                  {
                    if ((_DWORD)v45 == 55)
                    {
                      nw_socket_internal_link_state(*(_QWORD *)(a1 + 40), 1);
                      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
                      return 0;
                    }
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v93 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                    {
LABEL_162:
                      *(_BYTE *)(*(_QWORD *)(a1 + 40) + 335) |= 4u;
                      nw_socket_internal_error(*(_QWORD *)(a1 + 40), v45);
                      return 0;
                    }
                    v94 = *(_QWORD *)(a1 + 40);
                    v95 = v94 + 340;
                    LODWORD(v94) = *(_DWORD *)(v94 + 196);
                    *(_DWORD *)applier = 136447234;
                    *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2080;
                    *(_QWORD *)&applier[14] = v95;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = v94;
                    *(_WORD *)&applier[28] = 1024;
                    *(_DWORD *)&applier[30] = size[0];
                    *(_WORD *)&applier[34] = 1024;
                    *(_DWORD *)&applier[36] = v45;
                    v89 = "%{public}s %s sendmsg(fd %d, %u bytes) %{darwin.errno}d";
                    v90 = v93;
                    v91 = OS_LOG_TYPE_ERROR;
                    v92 = 40;
LABEL_161:
                    _os_log_impl(&dword_182FBE000, v90, v91, v89, applier, v92);
                    goto LABEL_162;
                  }
                  v76 = *(_WORD *)(*(_QWORD *)(a1 + 40) + 333);
                  if ((v76 & 0x100) != 0)
                  {
                    if ((v76 & 0x80) != 0)
                      goto LABEL_171;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v96 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_171;
                    v97 = *(_QWORD *)(a1 + 40);
                    v98 = (const char *)(v97 + 340);
                    if (!v97)
                      v98 = "";
                    v99 = *(_QWORD *)(v97 + 8);
                    *(_DWORD *)applier = 136446978;
                    *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2082;
                    *(_QWORD *)&applier[14] = v98;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = size[0];
                    *(_WORD *)&applier[28] = 2048;
                    *(_QWORD *)&applier[30] = v99;
                    v80 = "%{public}s %{public}s Wrote 0/%u bytes, waiting for writable event (overall bytes still %llu)";
                    v81 = v96;
                    v82 = OS_LOG_TYPE_DEFAULT;
                    v83 = 38;
                  }
                  else
                  {
                    if ((v76 & 0x80) != 0 || !gLogDatapath)
                      goto LABEL_171;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v77 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                      goto LABEL_171;
                    v78 = *(_QWORD *)(a1 + 40);
                    v79 = (const char *)(v78 + 340);
                    if (!v78)
                      v79 = "";
                    *(_DWORD *)applier = 136446722;
                    *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
                    *(_WORD *)&applier[12] = 2082;
                    *(_QWORD *)&applier[14] = v79;
                    *(_WORD *)&applier[22] = 1024;
                    *(_DWORD *)&applier[24] = size[0];
                    v80 = "%{public}s %{public}s Wrote 0/%u bytes, waiting for writable event";
                    v81 = v77;
                    v82 = OS_LOG_TYPE_DEBUG;
                    v83 = 28;
                  }
                  _os_log_impl(&dword_182FBE000, v81, v82, v80, applier, v83);
LABEL_171:
                  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
                  if (v138.msg_iovlen >= 1)
                  {
                    v100 = 0;
                    p_iov_len = &v138.msg_iov->iov_len;
                    do
                    {
                      v102 = *(_DWORD *)p_iov_len;
                      p_iov_len += 2;
                      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v102;
                      ++v100;
                    }
                    while (v100 < v138.msg_iovlen);
                  }
                  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
                    *(_BYTE *)(*(_QWORD *)(a1 + 40) + 335) |= 0x20u;
                  return 0;
                }
              }
              v33 = 8;
              goto LABEL_61;
            }
            __nwlog_obj();
            *(_DWORD *)applier = 136446210;
            *(_QWORD *)&applier[4] = "__nw_frame_get_network_service_type";
            v103 = (char *)_os_log_send_and_compose_impl();
            LOBYTE(v143) = 16;
            LOBYTE(v137) = 0;
            if (__nwlog_fault(v103, &v143, &v137))
            {
              if (v143 == 17)
              {
                v104 = __nwlog_obj();
                v105 = v143;
                if (!os_log_type_enabled(v104, (os_log_type_t)v143))
                  goto LABEL_229;
                *(_DWORD *)applier = 136446210;
                *(_QWORD *)&applier[4] = "__nw_frame_get_network_service_type";
                v106 = "%{public}s called with null frame";
                goto LABEL_228;
              }
              if (!(_BYTE)v137)
              {
                v104 = __nwlog_obj();
                v105 = v143;
                if (!os_log_type_enabled(v104, (os_log_type_t)v143))
                  goto LABEL_229;
                *(_DWORD *)applier = 136446210;
                *(_QWORD *)&applier[4] = "__nw_frame_get_network_service_type";
                v106 = "%{public}s called with null frame, backtrace limit exceeded";
                goto LABEL_228;
              }
              v109 = (char *)__nw_create_backtrace_string();
              v104 = __nwlog_obj();
              v105 = v143;
              v110 = os_log_type_enabled(v104, (os_log_type_t)v143);
              if (v109)
              {
                if (v110)
                {
                  *(_DWORD *)applier = 136446466;
                  *(_QWORD *)&applier[4] = "__nw_frame_get_network_service_type";
                  *(_WORD *)&applier[12] = 2082;
                  *(_QWORD *)&applier[14] = v109;
                  _os_log_impl(&dword_182FBE000, v104, v105, "%{public}s called with null frame, dumping backtrace:%{public}s", applier, 0x16u);
                }
                free(v109);
                goto LABEL_229;
              }
              if (v110)
              {
                *(_DWORD *)applier = 136446210;
                *(_QWORD *)&applier[4] = "__nw_frame_get_network_service_type";
                v106 = "%{public}s called with null frame, no backtrace";
LABEL_228:
                _os_log_impl(&dword_182FBE000, v104, v105, v106, applier, 0xCu);
              }
            }
LABEL_229:
            if (v103)
              free(v103);
            goto LABEL_62;
          }
        }
        else
        {
          if (v20 != 2)
            goto LABEL_39;
          if (setsockopt(*(_DWORD *)(v19 + 196), 0, 3, &v146, 4u) < 0)
          {
            v21 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v22 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_39;
            *(_DWORD *)applier = 136446466;
            *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
            *(_WORD *)&applier[12] = 1024;
            *(_DWORD *)&applier[14] = v21;
            v23 = "%{public}s setsockopt IP_TOS %{darwin.errno}d";
            goto LABEL_38;
          }
        }
        *(_BYTE *)(*(_QWORD *)(a1 + 40) + 332) = v18;
        goto LABEL_39;
      }
      if (!v108)
        goto LABEL_213;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "__nw_frame_get_ecn_flag";
      v30 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v28 = __nwlog_obj();
      v29 = v146;
      if (!os_log_type_enabled(v28, (os_log_type_t)v146))
        goto LABEL_213;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "__nw_frame_get_ecn_flag";
      v30 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v28, v29, v30, applier, 0xCu);
    goto LABEL_213;
  }
  v24 = size[0];
  if (!size[0])
  {
    v127 = __nwlog_obj();
    os_log_type_enabled(v127, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "strict_malloc";
    v128 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v128);
    if (result)
      goto LABEL_256;
    free(v128);
  }
  v15 = malloc_type_malloc(v24, 0xF2B69DE5uLL);
  if (v15)
  {
    v25 = *(_QWORD *)(a1 + 40);
    if (!v25)
      goto LABEL_29;
LABEL_28:
    if ((*(_WORD *)(v25 + 333) & 0x80) != 0)
    {
LABEL_30:
      *(_QWORD *)&size[1] = v15;
      v146 = 0;
      v147 = &v146;
      v148 = 0x2000000000;
      v149 = 0;
      *(_QWORD *)&v143 = 0;
      *((_QWORD *)&v143 + 1) = &v143;
      v144 = 0x2000000000;
      v145 = v137;
      *(_QWORD *)applier = MEMORY[0x1E0C809B0];
      *(_QWORD *)&applier[8] = 0x40000000;
      *(_QWORD *)&applier[16] = __nw_dispatch_data_copyout_from_offset_block_invoke;
      *(_QWORD *)&applier[24] = &unk_1E14A3470;
      *(_QWORD *)&applier[32] = &v143;
      *(_QWORD *)&applier[40] = &v146;
      *(_QWORD *)&applier[48] = size[0];
      v142 = v15;
      dispatch_data_apply(v6, applier);
      v26 = v147[3];
      _Block_object_dispose(&v143, 8);
      _Block_object_dispose(&v146, 8);
      v140 = v26;
LABEL_31:
      buffer = 0;
      v138.msg_iov = (iovec *)&size[1];
      v138.msg_iovlen = 1;
      if (a2)
        goto LABEL_15;
      goto LABEL_32;
    }
LABEL_29:
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v134 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        v135 = *(_QWORD *)(a1 + 40);
        if (v135)
          v136 = (const char *)(v135 + 340);
        else
          v136 = "";
        *(_DWORD *)applier = 136446466;
        *(_QWORD *)&applier[4] = "nw_socket_service_writes_block_invoke";
        *(_WORD *)&applier[12] = 2082;
        *(_QWORD *)&applier[14] = v136;
        _os_log_impl(&dword_182FBE000, v134, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Dispatch data too fragmented, making a copy", applier, 0x16u);
      }
    }
    goto LABEL_30;
  }
  v129 = __nwlog_obj();
  os_log_type_enabled(v129, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446466;
  *(_QWORD *)&applier[4] = "strict_malloc";
  *(_WORD *)&applier[12] = 2048;
  *(_QWORD *)&applier[14] = v24;
  v130 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v130);
  if (!result)
  {
    free(v130);
    v25 = *(_QWORD *)(a1 + 40);
    if (!v25)
      goto LABEL_29;
    goto LABEL_28;
  }
LABEL_256:
  __break(1u);
  return result;
}

uint64_t nw_frame_get_external_data(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  NSObject *v3;
  int v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "__nw_frame_get_external_data";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12))
      goto LABEL_28;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_28;
      *(_DWORD *)buf = 136446210;
      v15 = "__nw_frame_get_external_data";
      v9 = "%{public}s called with null frame";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "__nw_frame_get_external_data";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_28;
      }
      if (!v11)
      {
LABEL_28:
        if (v6)
          free(v6);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v15 = "__nw_frame_get_external_data";
      v9 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_28;
      *(_DWORD *)buf = 136446210;
      v15 = "__nw_frame_get_external_data";
      v9 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_28;
  }
  if ((*(_WORD *)(a1 + 204) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v15 = "__nw_frame_get_external_data";
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
    }
    return 0;
  }
  if (a2)
    *a2 = *(_DWORD *)(a1 + 56);
  if (a3)
  {
    v5 = *(_DWORD *)(a1 + 52);
    if (v5)
      v5 -= *(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60);
    *a3 = v5;
  }
  return *(_QWORD *)(a1 + 96);
}

uint64_t nw_dispatch_data_to_iovec(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v10;
  size_t size;
  const char *v12;
  NSObject *v13;
  os_log_type_t v14;
  size_t v15;
  const char *v16;
  uint64_t v17;
  NSObject *v18;
  size_t v19;
  char *v20;
  _BOOL4 v21;
  size_t v22;
  size_t v23;
  size_t v24;
  char *v25;
  const char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  char *v33;
  _BOOL4 v34;
  const char *v35;
  _BOOL4 v36;
  _BOOL4 v37;
  uint8_t *v38;
  _BOOL4 v39;
  uint8_t *v40;
  char v41;
  os_log_type_t type[8];
  os_log_type_t *v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  _BYTE applier[24];
  void *v48;
  os_log_type_t *v49;
  _QWORD *v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  int v54;
  _QWORD buf[3];
  uint64_t v56;
  __int16 v57;
  size_t v58;
  __int16 v59;
  char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
    v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v27, buf, type))
      goto LABEL_94;
    if (LOBYTE(buf[0]) == 17)
    {
      v28 = __nwlog_obj();
      v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0]))
        goto LABEL_94;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      v30 = "%{public}s called with null data";
    }
    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = buf[0];
      v32 = os_log_type_enabled(v28, buf[0]);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)applier = 136446466;
          *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
          *(_WORD *)&applier[12] = 2082;
          *(_QWORD *)&applier[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null data, dumping backtrace:%{public}s", applier, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_94;
      }
      if (!v32)
        goto LABEL_94;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      v30 = "%{public}s called with null data, no backtrace";
    }
    else
    {
      v28 = __nwlog_obj();
      v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0]))
        goto LABEL_94;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      v30 = "%{public}s called with null data, backtrace limit exceeded";
    }
    goto LABEL_92;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
    v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v27, buf, type))
      goto LABEL_94;
    if (LOBYTE(buf[0]) != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v28 = __nwlog_obj();
        v29 = buf[0];
        if (!os_log_type_enabled(v28, buf[0]))
          goto LABEL_94;
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
        v30 = "%{public}s called with null len, backtrace limit exceeded";
        goto LABEL_92;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = buf[0];
      v34 = os_log_type_enabled(v28, buf[0]);
      if (!v33)
      {
        if (!v34)
          goto LABEL_94;
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
        v30 = "%{public}s called with null len, no backtrace";
        goto LABEL_92;
      }
      if (!v34)
        goto LABEL_72;
      *(_DWORD *)applier = 136446466;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      *(_WORD *)&applier[12] = 2082;
      *(_QWORD *)&applier[14] = v33;
      v35 = "%{public}s called with null len, dumping backtrace:%{public}s";
      goto LABEL_66;
    }
    v28 = __nwlog_obj();
    v29 = buf[0];
    if (!os_log_type_enabled(v28, buf[0]))
      goto LABEL_94;
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
    v30 = "%{public}s called with null len";
LABEL_92:
    v40 = applier;
LABEL_93:
    _os_log_impl(&dword_182FBE000, v28, v29, v30, v40, 0xCu);
    goto LABEL_94;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
    v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v27, buf, type))
      goto LABEL_94;
    if (LOBYTE(buf[0]) != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v28 = __nwlog_obj();
        v29 = buf[0];
        if (!os_log_type_enabled(v28, buf[0]))
          goto LABEL_94;
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
        v30 = "%{public}s called with null iovs, backtrace limit exceeded";
        goto LABEL_92;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = buf[0];
      v36 = os_log_type_enabled(v28, buf[0]);
      if (!v33)
      {
        if (!v36)
          goto LABEL_94;
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
        v30 = "%{public}s called with null iovs, no backtrace";
        goto LABEL_92;
      }
      if (!v36)
        goto LABEL_72;
      *(_DWORD *)applier = 136446466;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      *(_WORD *)&applier[12] = 2082;
      *(_QWORD *)&applier[14] = v33;
      v35 = "%{public}s called with null iovs, dumping backtrace:%{public}s";
      goto LABEL_66;
    }
    v28 = __nwlog_obj();
    v29 = buf[0];
    if (!os_log_type_enabled(v28, buf[0]))
      goto LABEL_94;
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
    v30 = "%{public}s called with null iovs";
    goto LABEL_92;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
    v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v27, buf, type))
      goto LABEL_94;
    if (LOBYTE(buf[0]) == 17)
    {
      v28 = __nwlog_obj();
      v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0]))
        goto LABEL_94;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      v30 = "%{public}s called with null maxiov";
      goto LABEL_92;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v28 = __nwlog_obj();
      v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0]))
        goto LABEL_94;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      v30 = "%{public}s called with null maxiov, backtrace limit exceeded";
      goto LABEL_92;
    }
    v33 = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = buf[0];
    v37 = os_log_type_enabled(v28, buf[0]);
    if (!v33)
    {
      if (!v37)
        goto LABEL_94;
      *(_DWORD *)applier = 136446210;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      v30 = "%{public}s called with null maxiov, no backtrace";
      goto LABEL_92;
    }
    if (!v37)
      goto LABEL_72;
    *(_DWORD *)applier = 136446466;
    *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
    *(_WORD *)&applier[12] = 2082;
    *(_QWORD *)&applier[14] = v33;
    v35 = "%{public}s called with null maxiov, dumping backtrace:%{public}s";
LABEL_66:
    v38 = applier;
    goto LABEL_71;
  }
  v41 = 0;
  if (a5 <= 0)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
    v27 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (!__nwlog_fault(v27, type, &v46))
      goto LABEL_94;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (!os_log_type_enabled(v28, type[0]))
        goto LABEL_94;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      v30 = "%{public}s called with null (maxiov >= 1)";
      goto LABEL_98;
    }
    if (!v46)
    {
      v28 = __nwlog_obj();
      v29 = type[0];
      if (!os_log_type_enabled(v28, type[0]))
        goto LABEL_94;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      v30 = "%{public}s called with null (maxiov >= 1), backtrace limit exceeded";
      goto LABEL_98;
    }
    v33 = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = type[0];
    v39 = os_log_type_enabled(v28, type[0]);
    if (v33)
    {
      if (!v39)
        goto LABEL_72;
      LODWORD(buf[0]) = 136446466;
      *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      WORD2(buf[1]) = 2082;
      *(_QWORD *)((char *)&buf[1] + 6) = v33;
      v35 = "%{public}s called with null (maxiov >= 1), dumping backtrace:%{public}s";
      v38 = (uint8_t *)buf;
LABEL_71:
      _os_log_impl(&dword_182FBE000, v28, v29, v35, v38, 0x16u);
LABEL_72:
      free(v33);
      if (!v27)
        return 0;
LABEL_95:
      v25 = (char *)v27;
      goto LABEL_26;
    }
    if (v39)
    {
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      v30 = "%{public}s called with null (maxiov >= 1), no backtrace";
LABEL_98:
      v40 = (uint8_t *)buf;
      goto LABEL_93;
    }
LABEL_94:
    if (!v27)
      return 0;
    goto LABEL_95;
  }
  v10 = a3 + a2;
  if (a3 + a2 > dispatch_data_get_size(a1))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size = dispatch_data_get_size(a1);
    LODWORD(buf[0]) = 136446978;
    *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
    WORD2(buf[1]) = 2048;
    *(_QWORD *)((char *)&buf[1] + 6) = a2;
    HIWORD(buf[2]) = 2048;
    v56 = a3;
    v57 = 2048;
    v58 = size;
    v12 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v12, type, &v46))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          v15 = dispatch_data_get_size(a1);
          LODWORD(buf[0]) = 136446978;
          *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
          WORD2(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 6) = a2;
          HIWORD(buf[2]) = 2048;
          v56 = a3;
          v57 = 2048;
          v58 = v15;
          v16 = "%{public}s Invalid offset and length (%zu + %zu > %zu)";
LABEL_23:
          _os_log_impl(&dword_182FBE000, v13, v14, v16, (uint8_t *)buf, 0x2Au);
        }
      }
      else if (v46)
      {
        v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type[0];
        v21 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v20)
        {
          if (v21)
          {
            v22 = dispatch_data_get_size(a1);
            LODWORD(buf[0]) = 136447234;
            *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
            WORD2(buf[1]) = 2048;
            *(_QWORD *)((char *)&buf[1] + 6) = a2;
            HIWORD(buf[2]) = 2048;
            v56 = a3;
            v57 = 2048;
            v58 = v22;
            v59 = 2082;
            v60 = v20;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s Invalid offset and length (%zu + %zu > %zu), dumping backtrace:%{public}s", (uint8_t *)buf, 0x34u);
          }
          free(v20);
          goto LABEL_24;
        }
        if (v21)
        {
          v24 = dispatch_data_get_size(a1);
          LODWORD(buf[0]) = 136446978;
          *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
          WORD2(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 6) = a2;
          HIWORD(buf[2]) = 2048;
          v56 = a3;
          v57 = 2048;
          v58 = v24;
          v16 = "%{public}s Invalid offset and length (%zu + %zu > %zu), no backtrace";
          goto LABEL_23;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        v14 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          v23 = dispatch_data_get_size(a1);
          LODWORD(buf[0]) = 136446978;
          *(_QWORD *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
          WORD2(buf[1]) = 2048;
          *(_QWORD *)((char *)&buf[1] + 6) = a2;
          HIWORD(buf[2]) = 2048;
          v56 = a3;
          v57 = 2048;
          v58 = v23;
          v16 = "%{public}s Invalid offset and length (%zu + %zu > %zu), backtrace limit exceeded";
          goto LABEL_23;
        }
      }
    }
LABEL_24:
    if (!v12)
      return 0;
    v25 = (char *)v12;
LABEL_26:
    free(v25);
    return 0;
  }
  v41 = 0;
  buf[0] = 0;
  LODWORD(v56) = 0;
  buf[1] = buf;
  buf[2] = 0x2000000000;
  *(_QWORD *)type = 0;
  v43 = type;
  v44 = 0x2000000000;
  v45 = a2;
  *(_QWORD *)applier = MEMORY[0x1E0C809B0];
  *(_QWORD *)&applier[8] = 0x40000000;
  *(_QWORD *)&applier[16] = ___ZL33nw_dispatch_data_to_iovec_partialP15dispatch_data_smmP5ioveciPb_block_invoke;
  v48 = &unk_1E14A3528;
  v49 = type;
  v50 = buf;
  v54 = a5;
  v51 = v10;
  v52 = &v41;
  v53 = a4;
  dispatch_data_apply(a1, applier);
  v17 = *(unsigned int *)(buf[1] + 24);
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  if (v41)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v19 = dispatch_data_get_size(a1);
      *(_DWORD *)applier = 136446722;
      *(_QWORD *)&applier[4] = "nw_dispatch_data_to_iovec";
      *(_WORD *)&applier[12] = 2048;
      *(_QWORD *)&applier[14] = v19;
      *(_WORD *)&applier[22] = 1024;
      LODWORD(v48) = a5;
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_INFO, "%{public}s data (%zu bytes) couldn't get mapped to %d iovecs due to fragmentation", applier, 0x1Cu);
    }
    return 0;
  }
  return v17;
}

uint64_t ___ZL33nw_dispatch_data_to_iovec_partialP15dispatch_data_smmP5ioveciPb_block_invoke(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5;
  unint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  NSObject *v10;
  uint64_t result;
  int v12;
  BOOL v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  char *backtrace_string;
  _BOOL4 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (a5 + a3 <= v5)
    return 1;
  v7 = *(_QWORD *)(a1 + 48);
  if (v7 <= a3)
    return 0;
  v8 = *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if ((_DWORD)v8 != *(_DWORD *)(a1 + 72))
  {
    v13 = v5 >= a3;
    v14 = v5 - a3;
    if (!v13)
      v14 = 0;
    *(_QWORD *)(*(_QWORD *)(a1 + 64) + 16 * v8) = a4 + v14;
    v15 = v7 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v16 = a5 - v14;
    if (v15 >= v16)
      v15 = v16;
    v17 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(v17 + 16 * *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + 8) = v15;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += *(_QWORD *)(v17
                                                                             + 16
                                                                             * (int)(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                                               + 24))++
                                                                             + 8);
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v19 = *(_QWORD *)(a1 + 48);
    if (v18 <= v19)
      return v18 < v19;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v21 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)buf = 136446722;
    v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
    v40 = 2048;
    v41 = v20;
    v42 = 2048;
    v43 = v21;
    v22 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (__nwlog_fault(v22, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = gLogObj;
        v24 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v25 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v26 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 136446722;
          v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
          v40 = 2048;
          v41 = v25;
          v42 = 2048;
          v43 = v26;
          v27 = "%{public}s Cursor hit invalid value (%zu > %zu)";
LABEL_28:
          _os_log_impl(&dword_182FBE000, v23, v24, v27, buf, 0x20u);
        }
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v23 = __nwlog_obj();
        v24 = type;
        v29 = os_log_type_enabled(v23, type);
        if (backtrace_string)
        {
          if (v29)
          {
            v30 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            v31 = *(_QWORD *)(a1 + 48);
            *(_DWORD *)buf = 136446978;
            v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
            v40 = 2048;
            v41 = v30;
            v42 = 2048;
            v43 = v31;
            v44 = 2082;
            v45 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s Cursor hit invalid value (%zu > %zu), dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
          goto LABEL_29;
        }
        if (v29)
        {
          v34 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v35 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 136446722;
          v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
          v40 = 2048;
          v41 = v34;
          v42 = 2048;
          v43 = v35;
          v27 = "%{public}s Cursor hit invalid value (%zu > %zu), no backtrace";
          goto LABEL_28;
        }
      }
      else
      {
        v23 = __nwlog_obj();
        v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          v32 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v33 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 136446722;
          v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
          v40 = 2048;
          v41 = v32;
          v42 = 2048;
          v43 = v33;
          v27 = "%{public}s Cursor hit invalid value (%zu > %zu), backtrace limit exceeded";
          goto LABEL_28;
        }
      }
    }
LABEL_29:
    if (v22)
      free(v22);
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v19 = *(_QWORD *)(a1 + 48);
    return v18 < v19;
  }
  v9 = *(_BYTE **)(a1 + 56);
  if (v9)
    *v9 = 1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = gLogObj;
  result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    v12 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)buf = 136446466;
    v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
    v40 = 1024;
    LODWORD(v41) = v12;
    _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s Data had too many fragments for iovec (max %d)", buf, 0x12u);
    return 0;
  }
  return result;
}

uint64_t ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  size_t v8;
  unint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  const void *v13;
  unsigned int v14;
  size_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  size_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  const void *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v34;
  const char *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint64_t v39;
  const char *v40;
  const char *v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  char *backtrace_string;
  _BOOL4 v46;
  uint64_t v47;
  const char *v48;
  _BOOL4 v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  NSObject *v57;
  uint64_t v58;
  const char *v59;
  NSObject *v60;
  uint64_t v61;
  const char *v62;
  NSObject *v63;
  uint64_t v64;
  const char *v65;
  NSObject *v66;
  uint64_t v67;
  const char *v68;
  NSObject *v69;
  uint64_t v70;
  const char *v71;
  NSObject *v72;
  uint64_t v73;
  const char *v74;
  char v75;
  os_log_type_t type;
  unsigned int v77;
  unsigned int v78;
  uint8_t buf[4];
  const char *v80;
  __int16 v81;
  const char *v82;
  __int16 v83;
  char *v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  v78 = 0;
  v4 = (_BYTE *)nw_frame_unclaimed_bytes(a2, &v78);
  v6 = v4;
  v7 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v7 > 8)
  {
    LODWORD(v8) = 0;
  }
  else
  {
    if (!v78)
    {
      LODWORD(v8) = 0;
      goto LABEL_43;
    }
    if (9 - (int)v7 >= v78)
      v8 = v78;
    else
      v8 = (9 - v7);
    memcpy(v4, (const void *)(*(_QWORD *)(a1 + 56) + v7), v8);
    if (gLogDatapath)
    {
      v60 = __nwlog_obj();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      {
        v61 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)buf = 136446722;
        v80 = "send_data_callback_block_invoke";
        if (v61)
          v62 = (const char *)(v61 + 205);
        else
          v62 = "";
        v81 = 2082;
        v82 = v62;
        v83 = 1024;
        LODWORD(v84) = v8;
        _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of frame header", buf, 0x1Cu);
      }
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v8;
    LODWORD(v7) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
  if (v9)
  {
    if (v7 <= 9)
    {
      if (v78 <= v8)
        goto LABEL_43;
      v6[v8] = v9 - 1;
      if (gLogDatapath)
      {
        v63 = __nwlog_obj();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          v64 = *(_QWORD *)(a1 + 64);
          *(_DWORD *)buf = 136446722;
          v80 = "send_data_callback_block_invoke";
          if (v64)
            v65 = (const char *)(v64 + 205);
          else
            v65 = "";
          v81 = 2082;
          v82 = v65;
          v83 = 1024;
          LODWORD(v84) = 1;
          _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u byte of padding length", buf, 0x1Cu);
        }
      }
      LODWORD(v8) = v8 + 1;
      LODWORD(v7) = ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
    }
    if (v7 >= *(_DWORD *)(a1 + 112) + ~(_DWORD)v9)
      goto LABEL_24;
    v10 = v78 - v8;
    if (v78 <= v8)
      goto LABEL_43;
    v11 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v77 = 0;
    v12 = *(_QWORD *)(a1 + 80);
    v13 = (const void *)nw_frame_unclaimed_bytes(*(_QWORD *)(a1 + 88), &v77);
    if (v13)
    {
      v14 = v12 - v11;
      if ((int)v12 - v11 >= v10)
        v14 = v10;
      if (v14 >= v77)
        v15 = v77;
      else
        v15 = v14;
      memcpy(&v6[v8], v13, v15);
      if (gLogDatapath)
      {
        v69 = __nwlog_obj();
        if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
        {
          v70 = *(_QWORD *)(a1 + 64);
          *(_DWORD *)buf = 136446722;
          v80 = "send_data_callback_block_invoke";
          if (v70)
            v71 = (const char *)(v70 + 205);
          else
            v71 = "";
          v81 = 2082;
          v82 = v71;
          v83 = 1024;
          LODWORD(v84) = v15;
          _os_log_impl(&dword_182FBE000, v69, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of body data (padding)", buf, 0x1Cu);
        }
      }
      nw_frame_claim(*(_QWORD *)(a1 + 88), v16, v15, 0);
      LODWORD(v8) = v15 + v8;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v15;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v15;
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 16);
LABEL_24:
      if (v9 >= 2)
      {
        v17 = v78 - v8;
        if (v78 > v8)
        {
          v18 = ~*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) + v9;
          if (v18 >= v17)
            v19 = v17;
          else
            v19 = v18;
          bzero(&v6[v8], v19);
          if (gLogDatapath)
          {
            v66 = __nwlog_obj();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
            {
              v67 = *(_QWORD *)(a1 + 64);
              *(_DWORD *)buf = 136446722;
              v80 = "send_data_callback_block_invoke";
              if (v67)
                v68 = (const char *)(v67 + 205);
              else
                v68 = "";
              v81 = 2082;
              v82 = v68;
              v83 = 1024;
              LODWORD(v84) = v19;
              _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of padding", buf, 0x1Cu);
            }
          }
          LODWORD(v8) = v19 + v8;
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v19;
          v20 = *(_QWORD *)(a1 + 48);
LABEL_41:
          *(_DWORD *)(*(_QWORD *)(v20 + 8) + 24) += v19;
        }
      }
LABEL_43:
      nw_frame_claim(a2, v5, v8, 0);
      nw_frame_collapse(a2);
      nw_frame_unclaim(a2, v27, v8, 0);
      v29 = *(_QWORD *)(a2 + 32);
      v30 = *(_QWORD **)(a2 + 40);
      v28 = (_QWORD *)(a2 + 32);
      if (v29)
      {
        *(_QWORD *)(v29 + 40) = v30;
        v30 = *(_QWORD **)(a2 + 40);
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) = v30;
      }
      *v30 = v29;
      *v28 = 0;
      *(_QWORD *)(a2 + 40) = 0;
      v31 = *(_QWORD *)(a1 + 104);
      v32 = *(uint64_t **)(v31 + 8);
      *(_QWORD *)(a2 + 40) = v32;
      *v32 = a2;
      *(_QWORD *)(v31 + 8) = v28;
      if (gLogDatapath)
      {
        v57 = __nwlog_obj();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
        {
          v58 = *(_QWORD *)(a1 + 64);
          *(_DWORD *)buf = 136446722;
          v80 = "send_data_callback_block_invoke";
          if (v58)
            v59 = (const char *)(v58 + 205);
          else
            v59 = "";
          v81 = 2082;
          v82 = v59;
          v83 = 1024;
          LODWORD(v84) = v8;
          _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s copied %u bytes into output frame", buf, 0x1Cu);
        }
      }
      return 1;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v34 = *(_QWORD *)(a1 + 64);
    if (v34)
      v35 = (const char *)(v34 + 205);
    else
      v35 = "";
    *(_DWORD *)buf = 136446466;
    v80 = "send_data_callback_block_invoke";
    v81 = 2082;
    v82 = v35;
    v36 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v75 = 0;
    if (!__nwlog_fault(v36, &type, &v75))
      goto LABEL_100;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (os_log_type_enabled(v37, type))
      {
        v39 = *(_QWORD *)(a1 + 64);
        if (v39)
          v40 = (const char *)(v39 + 205);
        else
          v40 = "";
LABEL_57:
        *(_DWORD *)buf = 136446466;
        v80 = "send_data_callback_block_invoke";
        v81 = 2082;
        v82 = v40;
        v41 = "%{public}s %{public}s unexpected NULL in source frame";
LABEL_99:
        _os_log_impl(&dword_182FBE000, v37, v38, v41, buf, 0x16u);
        goto LABEL_100;
      }
      goto LABEL_100;
    }
    if (v75)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type;
      v46 = os_log_type_enabled(v37, type);
      if (backtrace_string)
      {
        if (v46)
        {
          v47 = *(_QWORD *)(a1 + 64);
          if (v47)
            v48 = (const char *)(v47 + 205);
          else
            v48 = "";
LABEL_79:
          *(_DWORD *)buf = 136446722;
          v80 = "send_data_callback_block_invoke";
          v81 = 2082;
          v82 = v48;
          v83 = 2082;
          v84 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s %{public}s unexpected NULL in source frame, dumping backtrace:%{public}s", buf, 0x20u);
          goto LABEL_80;
        }
        goto LABEL_80;
      }
      if (!v46)
        goto LABEL_100;
      v54 = *(_QWORD *)(a1 + 64);
      if (v54)
        v55 = (const char *)(v54 + 205);
      else
        v55 = "";
      goto LABEL_98;
    }
    v37 = __nwlog_obj();
    v38 = type;
    if (!os_log_type_enabled(v37, type))
      goto LABEL_100;
    v51 = *(_QWORD *)(a1 + 64);
    if (v51)
      v52 = (const char *)(v51 + 205);
    else
      v52 = "";
    goto LABEL_85;
  }
  if (v7 >= *(_DWORD *)(a1 + 112))
    goto LABEL_43;
  v21 = v78 - v8;
  if (v78 <= v8)
    goto LABEL_43;
  v22 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v77 = 0;
  v23 = *(_QWORD *)(a1 + 80);
  v24 = (const void *)nw_frame_unclaimed_bytes(*(_QWORD *)(a1 + 88), &v77);
  if (v24)
  {
    v25 = v23 - v22;
    if ((int)v23 - v22 >= v21)
      v25 = v21;
    if (v25 >= v77)
      v19 = v77;
    else
      v19 = v25;
    memcpy(&v6[v8], v24, v19);
    if (gLogDatapath)
    {
      v72 = __nwlog_obj();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
      {
        v73 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)buf = 136446722;
        v80 = "send_data_callback_block_invoke";
        if (v73)
          v74 = (const char *)(v73 + 205);
        else
          v74 = "";
        v81 = 2082;
        v82 = v74;
        v83 = 1024;
        LODWORD(v84) = v19;
        _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes of body data (no padding)", buf, 0x1Cu);
      }
    }
    nw_frame_claim(*(_QWORD *)(a1 + 88), v26, v19, 0);
    LODWORD(v8) = v19 + v8;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v19;
    v20 = *(_QWORD *)(a1 + 40);
    goto LABEL_41;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v42 = *(_QWORD *)(a1 + 64);
  if (v42)
    v43 = (const char *)(v42 + 205);
  else
    v43 = "";
  *(_DWORD *)buf = 136446466;
  v80 = "send_data_callback_block_invoke";
  v81 = 2082;
  v82 = v43;
  v36 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v75 = 0;
  if (!__nwlog_fault(v36, &type, &v75))
    goto LABEL_100;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (v75)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type;
      v49 = os_log_type_enabled(v37, type);
      if (backtrace_string)
      {
        if (v49)
        {
          v50 = *(_QWORD *)(a1 + 64);
          if (v50)
            v48 = (const char *)(v50 + 205);
          else
            v48 = "";
          goto LABEL_79;
        }
LABEL_80:
        free(backtrace_string);
        goto LABEL_100;
      }
      if (!v49)
        goto LABEL_100;
      v56 = *(_QWORD *)(a1 + 64);
      if (v56)
        v55 = (const char *)(v56 + 205);
      else
        v55 = "";
LABEL_98:
      *(_DWORD *)buf = 136446466;
      v80 = "send_data_callback_block_invoke";
      v81 = 2082;
      v82 = v55;
      v41 = "%{public}s %{public}s unexpected NULL in source frame, no backtrace";
      goto LABEL_99;
    }
    v37 = __nwlog_obj();
    v38 = type;
    if (!os_log_type_enabled(v37, type))
      goto LABEL_100;
    v53 = *(_QWORD *)(a1 + 64);
    if (v53)
      v52 = (const char *)(v53 + 205);
    else
      v52 = "";
LABEL_85:
    *(_DWORD *)buf = 136446466;
    v80 = "send_data_callback_block_invoke";
    v81 = 2082;
    v82 = v52;
    v41 = "%{public}s %{public}s unexpected NULL in source frame, backtrace limit exceeded";
    goto LABEL_99;
  }
  v37 = __nwlog_obj();
  v38 = type;
  if (os_log_type_enabled(v37, type))
  {
    v44 = *(_QWORD *)(a1 + 64);
    if (v44)
      v40 = (const char *)(v44 + 205);
    else
      v40 = "";
    goto LABEL_57;
  }
LABEL_100:
  if (v36)
    free(v36);
  return 0;
}

void nw_quic_stream_set_application_error(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_application_error_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_stream_set_application_error";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_application_error";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_stream_set_application_error";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_application_error";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_application_error";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_183189F24(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_application_error_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
  v5 = *(_QWORD *)(a2 + 24);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw::object::class_def::setup(_QWORD *a1, int64x2_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t j;
  unint64_t v20;
  char *v21;
  int64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BOOL8 v31;
  size_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  size_t v44;
  unint64_t *v45;
  uint64_t v46;
  unint64_t *v47;
  unint64_t *v48;
  unint64_t *v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t *v57;
  int64_t v58;
  size_t v59;
  _BYTE *v60;
  size_t v61;
  unint64_t *v62;
  unint64_t *v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  __int128 *v71;
  _OWORD *v72;
  uint64_t v73;
  __int128 v74;
  unint64_t v75;
  void *v76;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  unint64_t v82;
  void *v83;
  uint64_t *v84;
  char *v85;
  void *v86;
  void *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  _QWORD *v92;
  uint64_t v93;
  size_t v94;
  uint64_t *v95;
  uint64_t *v96;
  size_t v97;
  char *v98;
  uint64_t v99;
  unint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  __int128 *v105;
  uint64_t *v106;
  uint64_t v107;
  __int128 v108;
  uint64_t v109;
  uint64_t *v110;
  uint64_t *v111;
  void *v112;
  unint64_t *v113;
  char *v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  _QWORD *v121;
  uint64_t v122;
  size_t v123;
  uint64_t *v124;
  uint64_t *v125;
  size_t v126;
  uint64_t v127;
  unint64_t v128;
  char *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  __int128 *v133;
  uint64_t *v134;
  uint64_t v135;
  __int128 v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char *v142;
  _QWORD *v143;
  size_t v144;
  _BYTE *v145;
  unint64_t v146;
  size_t v147;
  uint64_t v148;
  unint64_t v149;
  char *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  __int128 *v154;
  _OWORD *v155;
  uint64_t v156;
  __int128 v157;
  uint64_t v158;
  char *v159;
  char **v160;
  uint64_t v161;
  const void **v162;
  char *v163;
  __int128 v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  unsigned __int8 v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t *v171;
  char *v172;
  unint64_t v173;
  void **v174;
  char *v175;
  __int128 v176;
  uint64_t v177;
  uint64_t v178;
  char *v179;
  uint64_t v180;
  char **v181;
  uint64_t v182;
  unint64_t v183;
  uint64_t v184;
  char *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  char *v189;
  char *v190;
  char **v191;
  uint64_t v192;
  unint64_t v193;
  uint64_t v194;
  char *v195;
  uint64_t v196;
  uint64_t v197;
  char *v198;
  char *v199;
  char *v200;
  char *v201;
  uint64_t v202;
  uint64_t v203;
  char *v204;
  char *v205;
  uint64_t v206;
  uint64_t v207;
  char *v208;
  uint64_t v209;
  char *v210;
  uint64_t v211;
  uint64_t v212;
  char *v213;
  char *v214;
  uint64_t *v215;
  char *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  char *v221;
  char *v222;
  char *v223;
  char *v224;
  void **v225;
  char *v226;
  uint64_t v227;
  uint64_t v228;
  char *v229;
  char *v230;
  void **v231;
  char *v232;
  uint64_t v233;
  uint64_t v234;
  char *v235;
  char *v236;
  char *v237;
  uint64_t v238;
  void *v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  char *v243;
  char *v244;
  size_t v245;
  char *v246;
  size_t v247;
  unint64_t *v248;
  int64_t v249;
  unint64_t v250;
  unint64_t *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  __int128 *v255;
  char *v256;
  uint64_t v257;
  __int128 v258;
  unint64_t v259;
  uint64_t v260;
  void *v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  char *v265;
  char *v266;
  size_t v267;
  char *v268;
  size_t v269;
  int64_t v270;
  unint64_t v271;
  unint64_t *v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  __int128 *v276;
  char *v277;
  uint64_t v278;
  __int128 v279;
  unint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  unint64_t *v285;
  size_t v286;
  char *v287;
  unint64_t *v288;
  unint64_t v289;
  BOOL v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t *v293;
  unint64_t *v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  __int128 *v298;
  char *v299;
  uint64_t v300;
  __int128 v301;
  unint64_t v302;
  uint64_t v303;
  void *v304;
  uint64_t v305;
  uint64_t v306;
  unint64_t *v307;
  char *v308;
  unint64_t *v309;
  unint64_t *v310;
  unint64_t *v311;
  unint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  unint64_t *v318;
  int64_t v319;
  size_t v320;
  _BYTE *v321;
  size_t v322;
  unint64_t *v323;
  unint64_t *v324;
  uint64_t v325;
  unint64_t v326;
  unint64_t *v327;
  uint64_t v328;
  unint64_t v329;
  uint64_t v330;
  uint64_t v331;
  __int128 *v332;
  _OWORD *v333;
  uint64_t v334;
  __int128 v335;
  unint64_t v336;
  void *v337;
  unint64_t v338;
  uint64_t v339;
  uint64_t v340;
  _OWORD *v341;
  unint64_t *v342;
  char *v343;
  uint64_t *v344;
  char *v345;
  _OWORD *v346;
  char *v347;
  unint64_t v348;
  unsigned __int8 v349;
  uint64_t v350;
  unint64_t v351;
  uint64_t v352;
  unint64_t *v353;
  char *v354;
  unint64_t v355;
  unint64_t *v356;
  char *v357;
  _OWORD *v358;
  char *v359;
  char *v360;
  uint64_t v361;
  unint64_t *v362;
  uint64_t v363;
  _BYTE *v364;
  uint64_t v365;
  char *v366;
  char *v367;
  unint64_t *i;
  _BYTE *v369;
  char *v370;
  uint64_t v371;
  char *v372;
  char *v373;
  char *v374;
  unint64_t v375;
  uint64_t v376;
  unint64_t v377;
  unint64_t v378;
  char *v379;
  uint64_t v380;
  char *v381;
  uint64_t v382;
  unint64_t v383;
  uint64_t v384;
  unint64_t v385;
  char *v386;
  uint64_t *v387;
  char *v388;
  _BYTE *v389;
  char *v390;
  uint64_t v391;
  char *v392;
  char *v393;
  _BYTE *v394;
  uint64_t v395;
  uint64_t *v396;
  char *v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t *v401;
  char *v402;
  uint64_t v403;
  uint64_t v404;
  unint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  unint64_t v409;
  unint64_t v410;
  unint64_t v411;
  unint64_t v412;
  char *v413;
  uint64_t *__src;
  uint64_t *__srca;
  char *__srcb;
  unint64_t *__srcc;
  unint64_t *__srcd;
  uint64_t *v419;
  void *v420;

  v4 = a1[14];
  if (v4)
    nw::object::class_def::setup(v4, a2);
  v5 = a2[2].u64[0];
  v6 = a2[2].i64[1];
  v7 = v5 + v6;
  v8 = (v5 + v6) >> 8;
  v9 = (unint64_t *)a2->i64[1];
  v10 = (unint64_t *)a2[1].i64[0];
  v11 = (char *)&v9[v8];
  if (v10 == v9)
    v12 = 0;
  else
    v12 = *(_QWORD *)v11 + 16 * v7;
  v13 = a1[12];
  v14 = a1[9];
  v15 = v14 + 8 * (v13 >> 8);
  if (a1[10] == v14)
  {
    v16 = 0;
    v18 = 0;
    v419 = (uint64_t *)(v14 + 8 * ((a1[13] + v13) >> 8));
  }
  else
  {
    v16 = (char *)(*(_QWORD *)v15 + 16 * v13);
    v17 = a1[13] + v13;
    v419 = (uint64_t *)(v14 + 8 * (v17 >> 8));
    v18 = *v419 + 16 * v17;
    if ((char *)v18 != v16)
    {
      j = ((16 * v17) >> 4) + 32 * ((_QWORD)v419 - v15) - ((uint64_t)&v16[-*(_QWORD *)v15] >> 4);
      goto LABEL_11;
    }
  }
  j = 0;
LABEL_11:
  v20 = v5 >> 8;
  v21 = (char *)&v9[v5 >> 8];
  v22 = (char *)v10 - (char *)v9;
  if (v10 == v9)
  {
    v23 = 0;
    if (v12)
      goto LABEL_13;
  }
  else
  {
    v23 = *(_QWORD *)v21 + 16 * v5;
    if (v12 != v23)
    {
LABEL_13:
      v24 = ((v12 - *(_QWORD *)v11) >> 4) + 32 * (v11 - v21) - ((v23 - *(_QWORD *)v21) >> 4);
      goto LABEL_16;
    }
  }
  v24 = 0;
LABEL_16:
  if (v24 >= v6 - v24)
  {
    v34 = 32 * v22 - 1;
    v35 = (char *)v10 - (char *)v9;
    if (v10 == v9)
      v34 = 0;
    v36 = v34 - v7;
    v37 = j >= v36;
    v38 = j - v36;
    if (v38 == 0 || !v37)
      goto LABEL_420;
    v408 = v15;
    if (v10 == v9)
      v39 = v38 + 1;
    else
      v39 = v38;
    if ((_BYTE)v39)
      v40 = (v39 >> 8) + 1;
    else
      v40 = v39 >> 8;
    if (v40 >= v20)
      v15 = v5 >> 8;
    else
      v15 = v40;
    v411 = j;
    v412 = v24;
    if (v40 > v20)
    {
      j = v40 - v15;
      v41 = a2[1].i64[1] - a2->i64[0];
      v42 = v35 >> 3;
      if (v40 - v15 > (v41 >> 3) - (v35 >> 3))
      {
        v43 = v41 >> 2;
        if (v43 <= j + v42)
          v44 = j + v42;
        else
          v44 = v43;
        v409 = v18;
        if (v44)
        {
          v45 = (unint64_t *)malloc_type_calloc(v44, 8uLL, 0x80040B8603338uLL);
          if (!v45)
          {
LABEL_54:
            __break(1u);
            goto LABEL_55;
          }
        }
        else
        {
          v45 = 0;
        }
        v406 = v15 << 8;
        v236 = (char *)&v45[v42 - v15];
        v237 = (char *)&v45[v44];
        v10 = (unint64_t *)v236;
        while (1)
        {
          v239 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v239)
            goto LABEL_54;
          v18 = (unint64_t)v239;
          if (v10 != (unint64_t *)v237)
            goto LABEL_329;
          __srcc = v45;
          if (v236 > (char *)v45)
          {
            v240 = (v236 - (char *)v45) >> 3;
            if (v240 >= -1)
              v241 = v240 + 1;
            else
              v241 = v240 + 2;
            v242 = v241 >> 1;
            v243 = &v236[-8 * (v241 >> 1)];
            v244 = v237;
            if (v237 != v236)
            {
              memmove(v243, v236, v237 - v236);
              v244 = v236;
            }
            v238 = -v242;
            v10 = (unint64_t *)&v243[v237 - v236];
            v236 = &v244[8 * v238];
            v45 = __srcc;
            goto LABEL_329;
          }
          if (v237 == (char *)v45)
            v245 = 1;
          else
            v245 = (v237 - (char *)v45) >> 2;
          v246 = (char *)malloc_type_calloc(v245, 8uLL, 0x80040B8603338uLL);
          if (!v246)
            goto LABEL_54;
          v45 = (unint64_t *)v246;
          v247 = v245 >> 2;
          v248 = (unint64_t *)&v246[8 * (v245 >> 2)];
          v10 = v248;
          v249 = v237 - v236;
          if (v237 != v236)
          {
            v10 = (unint64_t *)((char *)v248 + (v249 & 0xFFFFFFFFFFFFFFF8));
            v250 = v249 - 8;
            if (v250 >= 0x38)
            {
              v252 = 8 * v247;
              if ((unint64_t)(&v246[8 * v247] - v236) >= 0x20)
              {
                v253 = (v250 >> 3) + 1;
                v254 = v253 & 0x3FFFFFFFFFFFFFFCLL;
                v251 = &v248[v254];
                v255 = (__int128 *)(v236 + 16);
                v256 = &v246[v252 + 16];
                v257 = v253 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  v258 = *v255;
                  *((_OWORD *)v256 - 1) = *(v255 - 1);
                  *(_OWORD *)v256 = v258;
                  v255 += 2;
                  v256 += 32;
                  v257 -= 4;
                }
                while (v257);
                if (v253 == (v253 & 0x3FFFFFFFFFFFFFFCLL))
                  goto LABEL_352;
                v236 += v254 * 8;
              }
              else
              {
                v251 = (unint64_t *)&v246[8 * (v245 >> 2)];
              }
            }
            else
            {
              v251 = (unint64_t *)&v246[8 * (v245 >> 2)];
            }
            do
            {
              v259 = *(_QWORD *)v236;
              v236 += 8;
              *v251++ = v259;
            }
            while (v251 != v10);
          }
LABEL_352:
          v237 = &v246[8 * v245];
          if (__srcc)
          {
            v236 = &v246[8 * (v245 >> 2)];
            free(__srcc);
          }
          else
          {
            v236 = (char *)v248;
          }
LABEL_329:
          *v10++ = v18;
          if (!--j)
          {
            j = a2->u64[1];
            if (!v15)
            {
              v18 = (unint64_t)v236;
LABEL_357:
              v260 = a2[1].i64[0];
              if (v260 == j)
              {
LABEL_358:
                v261 = (void *)a2->i64[0];
                a2->i64[0] = (uint64_t)v45;
                a2->i64[1] = v18;
                a2[1].i64[0] = (uint64_t)v10;
                a2[1].i64[1] = (uint64_t)v237;
                a2[2].i64[0] -= v406;
                v18 = v409;
                if (v261)
                {
                  free(v261);
                  v10 = (unint64_t *)a2[1].i64[0];
                }
LABEL_419:
                v6 = a2[2].i64[1];
                v9 = (unint64_t *)a2->i64[1];
                v7 = a2[2].i64[0] + v6;
                v8 = v7 >> 8;
                v15 = v408;
                j = v411;
                v24 = v412;
LABEL_420:
                v307 = &v9[v8];
                if (v10 == v9)
                  v308 = 0;
                else
                  v308 = (char *)(*v307 + 16 * v7);
                v338 = v6 - v24;
                if (v6 - v24 >= j)
                {
                  v341 = v308;
                  v342 = &v9[v8];
                  if (!j)
                    return;
                }
                else
                {
                  if (v338 >= j >> 1)
                  {
                    v339 = v6 - v24 - j + ((uint64_t)(v18 - *v419) >> 4);
                    if (v339 < 1)
                    {
                      v348 = 255 - v339;
                      v349 = ~(_BYTE)v348;
                      v419 -= v348 >> 8;
                      v350 = *v419;
                      goto LABEL_467;
                    }
                    v419 += (unint64_t)v339 >> 8;
                    v340 = *v419;
LABEL_456:
                    v343 = (char *)(v340 + 16 * v339);
                    if (v343 != (char *)v18)
                      goto LABEL_457;
LABEL_468:
                    v341 = v308;
                    v342 = v307;
                  }
                  else
                  {
                    if (v338)
                    {
                      v339 = v338 + ((uint64_t)&v16[-*(_QWORD *)v15] >> 4);
                      if (v339 >= 1)
                      {
                        v419 = (uint64_t *)(v15 + 8 * ((unint64_t)v339 >> 8));
                        v340 = *v419;
                        goto LABEL_456;
                      }
                      v351 = 255 - v339;
                      v349 = ~(_BYTE)v351;
                      v419 = (uint64_t *)(v15 - 8 * (v351 >> 8));
                      v350 = *v419;
LABEL_467:
                      v343 = (char *)(v350 + 16 * v349);
                      if (v343 == (char *)v18)
                        goto LABEL_468;
                    }
                    else
                    {
                      v419 = (uint64_t *)v15;
                      v343 = v16;
                      if (v16 == (char *)v18)
                        goto LABEL_468;
                    }
LABEL_457:
                    v344 = v419;
                    v345 = v343;
                    v342 = v307;
                    v341 = v308;
                    do
                    {
                      *v341++ = *(_OWORD *)v345;
                      if ((_OWORD *)((char *)v341 - *v342) == (_OWORD *)4096)
                      {
                        v346 = (_OWORD *)v342[1];
                        ++v342;
                        v341 = v346;
                      }
                      v345 += 16;
                      if (&v345[-*v344] == (char *)4096)
                      {
                        v347 = (char *)v344[1];
                        ++v344;
                        v345 = v347;
                      }
                      ++a2[2].i64[1];
                    }
                    while (v345 != (char *)v18);
                  }
                  j = v338;
                  v18 = (unint64_t)v343;
                  if (!v338)
                    return;
                }
                v352 = ((uint64_t)&v308[-*v307] >> 4) - j;
                if (v352 < 1)
                {
                  v355 = 255 - v352;
                  v353 = &v307[-(v355 >> 8)];
                  v354 = (char *)(*v353 + 16 * ~(_BYTE)v355);
                  if (v354 == v308)
                    goto LABEL_480;
                }
                else
                {
                  v353 = &v307[(unint64_t)v352 >> 8];
                  v354 = (char *)(*v353 + 16 * v352);
                  if (v354 == v308)
                    goto LABEL_480;
                }
                v356 = v353;
                v357 = v354;
                do
                {
                  *v341++ = *(_OWORD *)v357;
                  if ((_OWORD *)((char *)v341 - *v342) == (_OWORD *)4096)
                  {
                    v358 = (_OWORD *)v342[1];
                    ++v342;
                    v341 = v358;
                  }
                  v357 += 16;
                  if (&v357[-*v356] == (char *)4096)
                  {
                    v359 = (char *)v356[1];
                    ++v356;
                    v357 = v359;
                  }
                  ++a2[2].i64[1];
                }
                while (v357 != v308);
LABEL_480:
                if (j >= v338)
                  goto LABEL_523;
                v360 = (char *)*v307;
                v361 = ((uint64_t)&v308[-*v307] >> 4) - v338;
                if (v361 < 1)
                {
                  v378 = 255 - v361;
                  v362 = &v307[-(v378 >> 8)];
                  v363 = *v362 + 16 * ~(_BYTE)v378;
                  if (v362 == v353)
                    goto LABEL_513;
LABEL_483:
                  v364 = (_BYTE *)*v353;
                  if ((char *)*v353 != v354)
                  {
                    while (1)
                    {
                      v365 = (v308 - v360) >> 4;
                      if ((v354 - v364) >> 4 < v365)
                        v365 = (v354 - v364) >> 4;
                      v354 -= 16 * v365;
                      v308 -= 16 * v365;
                      if (v365)
                        memmove(v308, v354, 16 * v365);
                      if (v354 == v364)
                        break;
                      v366 = (char *)*--v307;
                      v360 = v366;
                      v308 = v366 + 4096;
                    }
                    v360 = (char *)*v307;
                    if ((char *)(*v307 + 4096) == v308)
                    {
                      v367 = (char *)v307[1];
                      ++v307;
                      v360 = v367;
                      v308 = v367;
                    }
                  }
                  for (i = v353 - 1; i != v362; --i)
                  {
                    v369 = (_BYTE *)*i;
                    v370 = (char *)(*i + 4096);
                    while (1)
                    {
                      v371 = (v308 - v360) >> 4;
                      if ((v370 - v369) >> 4 < v371)
                        v371 = (v370 - v369) >> 4;
                      v370 -= 16 * v371;
                      v308 -= 16 * v371;
                      if (v371)
                        memmove(v308, v370, 16 * v371);
                      if (v370 == v369)
                        break;
                      v372 = (char *)*--v307;
                      v360 = v372;
                      v308 = v372 + 4096;
                    }
                    v360 = (char *)*v307;
                    if ((char *)(*v307 + 4096) == v308)
                    {
                      v373 = (char *)v307[1];
                      ++v307;
                      v360 = v373;
                      v308 = v373;
                    }
                  }
                  v374 = (char *)(*v362 + 4096);
                  if (v374 == (char *)v363)
                  {
LABEL_523:
                    if ((uint64_t *)v15 == v419)
                    {
                      if (v16 != (char *)v18)
                      {
                        v402 = (char *)*v307;
                        v401 = (uint64_t *)(v307 - 1);
                        v400 = (uint64_t)v402;
                        while (1)
                        {
                          v403 = (uint64_t)&v308[-v400] >> 4;
                          if ((uint64_t)(v18 - (_QWORD)v16) >> 4 < v403)
                            v403 = (uint64_t)(v18 - (_QWORD)v16) >> 4;
                          v18 -= 16 * v403;
                          if (v403)
                            memmove(&v308[-16 * v403], (const void *)v18, 16 * v403);
                          if ((char *)v18 == v16)
                            break;
                          v404 = *v401--;
                          v400 = v404;
                          v308 = (char *)(v404 + 4096);
                        }
                      }
                    }
                    else
                    {
                      v382 = *v419;
                      if (*v419 != v18)
                      {
                        v383 = *v307;
                        while (1)
                        {
                          v384 = (uint64_t)&v308[-v383] >> 4;
                          if ((uint64_t)(v18 - v382) >> 4 < v384)
                            v384 = (uint64_t)(v18 - v382) >> 4;
                          v18 -= 16 * v384;
                          v308 -= 16 * v384;
                          if (v384)
                            memmove(v308, (const void *)v18, 16 * v384);
                          if (v18 == v382)
                            break;
                          v385 = *--v307;
                          v383 = v385;
                          v308 = (char *)(v385 + 4096);
                        }
                        if ((char *)(*v307 + 4096) == v308)
                        {
                          v386 = (char *)v307[1];
                          ++v307;
                          v308 = v386;
                        }
                      }
                      v387 = v419 - 1;
                      if (v419 - 1 != (uint64_t *)v15)
                      {
                        v388 = (char *)*v307;
                        do
                        {
                          v389 = (_BYTE *)*v387;
                          v390 = (char *)(*v387 + 4096);
                          while (1)
                          {
                            v391 = (v308 - v388) >> 4;
                            if ((v390 - v389) >> 4 < v391)
                              v391 = (v390 - v389) >> 4;
                            v390 -= 16 * v391;
                            v308 -= 16 * v391;
                            if (v391)
                              memmove(v308, v390, 16 * v391);
                            if (v390 == v389)
                              break;
                            v392 = (char *)*--v307;
                            v388 = v392;
                            v308 = v392 + 4096;
                          }
                          v388 = (char *)*v307;
                          if ((char *)(*v307 + 4096) == v308)
                          {
                            v393 = (char *)v307[1];
                            ++v307;
                            v388 = v393;
                            v308 = v393;
                          }
                          --v387;
                        }
                        while (v387 != (uint64_t *)v15);
                      }
                      v394 = (_BYTE *)(*(_QWORD *)v15 + 4096);
                      if (v394 != v16)
                      {
                        v397 = (char *)*v307;
                        v396 = (uint64_t *)(v307 - 1);
                        v395 = (uint64_t)v397;
                        while (1)
                        {
                          v398 = (uint64_t)&v308[-v395] >> 4;
                          if ((v394 - v16) >> 4 < v398)
                            v398 = (v394 - v16) >> 4;
                          v394 -= 16 * v398;
                          if (v398)
                            memmove(&v308[-16 * v398], v394, 16 * v398);
                          if (v394 == v16)
                            break;
                          v399 = *v396--;
                          v395 = v399;
                          v308 = (char *)(v399 + 4096);
                        }
                      }
                    }
                    return;
                  }
                  v375 = *v307;
                  while (1)
                  {
                    v376 = (uint64_t)&v308[-v375] >> 4;
                    if ((uint64_t)&v374[-v363] >> 4 < v376)
                      v376 = (uint64_t)&v374[-v363] >> 4;
                    v374 -= 16 * v376;
                    v308 -= 16 * v376;
                    if (v376)
                      memmove(v308, v374, 16 * v376);
                    if (v374 == (char *)v363)
                      break;
                    v377 = *--v307;
                    v375 = v377;
                    v308 = (char *)(v377 + 4096);
                  }
                }
                else
                {
                  v362 = &v307[(unint64_t)v361 >> 8];
                  v363 = *v362 + 16 * v361;
                  if (v362 != v353)
                    goto LABEL_483;
LABEL_513:
                  if ((char *)v363 == v354)
                    goto LABEL_523;
                  while (1)
                  {
                    v380 = (v308 - v360) >> 4;
                    if ((uint64_t)&v354[-v363] >> 4 < v380)
                      v380 = (uint64_t)&v354[-v363] >> 4;
                    v354 -= 16 * v380;
                    v308 -= 16 * v380;
                    if (v380)
                      memmove(v308, v354, 16 * v380);
                    if (v354 == (char *)v363)
                      break;
                    v379 = (char *)*--v307;
                    v360 = v379;
                    v308 = v379 + 4096;
                  }
                }
                if ((char *)(*v307 + 4096) == v308)
                {
                  v381 = (char *)v307[1];
                  ++v307;
                  v308 = v381;
                }
                goto LABEL_523;
              }
              while (2)
              {
                if ((unint64_t *)v18 != v45)
                {
LABEL_387:
                  v281 = *(_QWORD *)(v260 - 8);
                  v260 -= 8;
                  *(_QWORD *)(v18 - 8) = v281;
                  v18 -= 8;
                  if (v260 == a2->i64[1])
                    goto LABEL_358;
                  continue;
                }
                break;
              }
              if (v10 < (unint64_t *)v237)
              {
                v282 = (v237 - (char *)v10) >> 3;
                if (v282 >= -1)
                  v283 = v282 + 1;
                else
                  v283 = v282 + 2;
                v284 = v283 >> 1;
                v18 = (unint64_t)&v45[v283 >> 1];
                v285 = v45;
                if (v10 != v45)
                {
                  memmove((void *)v18, v45, (char *)v10 - (char *)v45);
                  v285 = v10;
                }
                v10 = &v285[v284];
                goto LABEL_387;
              }
              j = (unint64_t)v45;
              if (v237 == (char *)v45)
                v286 = 1;
              else
                v286 = (v237 - (char *)v45) >> 2;
              v287 = (char *)malloc_type_calloc(v286, 8uLL, 0x80040B8603338uLL);
              if (!v287)
                goto LABEL_54;
              v288 = (unint64_t *)v287;
              v289 = (v286 + 3) >> 2;
              v18 = (unint64_t)&v287[8 * v289];
              v237 = &v287[8 * v286];
              v291 = (unint64_t)v10 - j;
              v290 = v10 == (unint64_t *)j;
              v10 = (unint64_t *)v18;
              if (!v290)
              {
                v10 = (unint64_t *)(v18 + (v291 & 0xFFFFFFFFFFFFFFF8));
                v292 = v291 - 8;
                v293 = (unint64_t *)&v287[8 * v289];
                v294 = (unint64_t *)j;
                if (v292 >= 0x38)
                {
                  v295 = 8 * v289;
                  v293 = (unint64_t *)&v287[8 * v289];
                  v294 = (unint64_t *)j;
                  if ((unint64_t)v293 - j >= 0x20)
                  {
                    v296 = (v292 >> 3) + 1;
                    v297 = 8 * (v296 & 0x3FFFFFFFFFFFFFFCLL);
                    v293 = (unint64_t *)(v18 + v297);
                    v298 = (__int128 *)(j + 16);
                    v299 = &v287[v295 + 16];
                    v300 = v296 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      v301 = *v298;
                      *((_OWORD *)v299 - 1) = *(v298 - 1);
                      *(_OWORD *)v299 = v301;
                      v298 += 2;
                      v299 += 32;
                      v300 -= 4;
                    }
                    while (v300);
                    if (v296 != (v296 & 0x3FFFFFFFFFFFFFFCLL))
                    {
                      v294 = (unint64_t *)(j + v297);
                      goto LABEL_406;
                    }
LABEL_408:
                    free((void *)j);
LABEL_409:
                    v45 = v288;
                    goto LABEL_387;
                  }
                }
                do
                {
LABEL_406:
                  v302 = *v294++;
                  *v293++ = v302;
                }
                while (v293 != v10);
              }
              if (j)
                goto LABEL_408;
              goto LABEL_409;
            }
            while (2)
            {
              if (v10 != (unint64_t *)v237)
              {
                v18 = (unint64_t)v236;
                goto LABEL_361;
              }
              __srcd = v45;
              if (v236 > (char *)v45)
              {
                v262 = (v236 - (char *)v45) >> 3;
                if (v262 >= -1)
                  v263 = v262 + 1;
                else
                  v263 = v262 + 2;
                v264 = v263 >> 1;
                v265 = &v236[-8 * (v263 >> 1)];
                v266 = v237;
                if (v237 != v236)
                {
                  memmove(v265, v236, v237 - v236);
                  v266 = v236;
                }
                v10 = (unint64_t *)&v265[v237 - v236];
                v18 = (unint64_t)&v266[-8 * v264];
                goto LABEL_361;
              }
              if (v237 == (char *)v45)
                v267 = 1;
              else
                v267 = (v237 - (char *)v45) >> 2;
              v268 = (char *)malloc_type_calloc(v267, 8uLL, 0x80040B8603338uLL);
              if (!v268)
                goto LABEL_54;
              v45 = (unint64_t *)v268;
              v269 = v267 >> 2;
              v18 = (unint64_t)&v268[8 * (v267 >> 2)];
              v10 = (unint64_t *)v18;
              v270 = v237 - v236;
              if (v237 != v236)
              {
                v10 = (unint64_t *)(v18 + (v270 & 0xFFFFFFFFFFFFFFF8));
                v271 = v270 - 8;
                if (v271 >= 0x38)
                {
                  v273 = 8 * v269;
                  if ((unint64_t)(&v268[8 * v269] - v236) < 0x20)
                  {
                    v272 = (unint64_t *)&v268[8 * (v267 >> 2)];
                    goto LABEL_383;
                  }
                  v274 = (v271 >> 3) + 1;
                  v275 = 8 * (v274 & 0x3FFFFFFFFFFFFFFCLL);
                  v272 = (unint64_t *)(v18 + v275);
                  v276 = (__int128 *)(v236 + 16);
                  v277 = &v268[v273 + 16];
                  v278 = v274 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    v279 = *v276;
                    *((_OWORD *)v277 - 1) = *(v276 - 1);
                    *(_OWORD *)v277 = v279;
                    v276 += 2;
                    v277 += 32;
                    v278 -= 4;
                  }
                  while (v278);
                  if (v274 != (v274 & 0x3FFFFFFFFFFFFFFCLL))
                  {
                    v236 += v275;
                    goto LABEL_383;
                  }
                }
                else
                {
                  v272 = (unint64_t *)&v268[8 * (v267 >> 2)];
                  do
                  {
LABEL_383:
                    v280 = *(_QWORD *)v236;
                    v236 += 8;
                    *v272++ = v280;
                  }
                  while (v272 != v10);
                }
              }
              v237 = &v268[8 * v267];
              if (__srcd)
                free(__srcd);
LABEL_361:
              *v10++ = *(_QWORD *)j;
              j = a2->i64[1] + 8;
              a2->i64[1] = j;
              v236 = (char *)v18;
              if (!--v15)
                goto LABEL_357;
              continue;
            }
          }
        }
      }
      if (j)
      {
        while (a2[1].i64[1] != a2[1].i64[0])
        {
          v82 = v24;
          v83 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v83)
            goto LABEL_54;
          v420 = v83;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_back(a2, &v420);
          --j;
          v24 = v82;
          if (!j)
          {
            v10 = (unint64_t *)a2[1].i64[0];
            goto LABEL_417;
          }
        }
        v303 = 0;
        v15 += j;
        while (1)
        {
          v304 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v304)
            goto LABEL_54;
          v420 = v304;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
          v10 = (unint64_t *)a2[1].i64[0];
          if ((unint64_t *)((char *)v10 - a2->i64[1]) == (unint64_t *)8)
            v305 = 255;
          else
            v305 = 256;
          v306 = v305 + a2[2].i64[0];
          a2[2].i64[0] = v306;
          if (j == ++v303)
            goto LABEL_418;
        }
      }
LABEL_417:
      v306 = a2[2].i64[0];
LABEL_418:
      a2[2].i64[0] = v306 - (v15 << 8);
      if (!v15)
        goto LABEL_419;
      while (1)
      {
        v310 = (unint64_t *)a2->i64[1];
        v312 = *v310;
        v311 = v310 + 1;
        j = v312;
        a2->i64[1] = (uint64_t)v311;
        if (v10 == (unint64_t *)a2[1].i64[1])
        {
          v313 = (uint64_t)v311 - a2->i64[0];
          if ((unint64_t)v311 <= a2->i64[0])
          {
            if (v10 == (unint64_t *)a2->i64[0])
              v320 = 1;
            else
              v320 = ((uint64_t)v10 - a2->i64[0]) >> 2;
            v321 = malloc_type_calloc(v320, 8uLL, 0x80040B8603338uLL);
            if (!v321)
              goto LABEL_54;
            v322 = v320 >> 2;
            v323 = (unint64_t *)&v321[8 * (v320 >> 2)];
            v324 = (unint64_t *)a2->i64[1];
            v10 = v323;
            v325 = a2[1].i64[0] - (_QWORD)v324;
            if (v325)
            {
              v10 = (unint64_t *)((char *)v323 + (v325 & 0xFFFFFFFFFFFFFFF8));
              v326 = v325 - 8;
              if (v326 >= 0x38)
              {
                v328 = 8 * v322;
                v329 = &v321[8 * v322] - (_BYTE *)v324;
                v327 = (unint64_t *)&v321[8 * (v320 >> 2)];
                if (v329 < 0x20)
                  goto LABEL_443;
                v330 = (v326 >> 3) + 1;
                v331 = v330 & 0x3FFFFFFFFFFFFFFCLL;
                v327 = &v323[v331];
                v332 = (__int128 *)(v324 + 2);
                v333 = &v321[v328 + 16];
                v334 = v330 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  v335 = *v332;
                  *(v333 - 1) = *(v332 - 1);
                  *v333 = v335;
                  v332 += 2;
                  v333 += 2;
                  v334 -= 4;
                }
                while (v334);
                if (v330 != (v330 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  v324 = (unint64_t *)((char *)v324 + v331 * 8);
                  goto LABEL_443;
                }
              }
              else
              {
                v327 = (unint64_t *)&v321[8 * (v320 >> 2)];
                do
                {
LABEL_443:
                  v336 = *v324++;
                  *v327++ = v336;
                }
                while (v327 != v10);
              }
            }
            v337 = (void *)a2->i64[0];
            a2->i64[0] = (uint64_t)v321;
            a2->i64[1] = (uint64_t)v323;
            a2[1].i64[0] = (uint64_t)v10;
            a2[1].i64[1] = (uint64_t)&v321[8 * v320];
            if (v337)
            {
              free(v337);
              v10 = (unint64_t *)a2[1].i64[0];
            }
            goto LABEL_423;
          }
          v314 = v313 >> 3;
          v53 = v313 >> 3 < -1;
          v315 = (v313 >> 3) + 2;
          if (v53)
            v316 = v315;
          else
            v316 = v314 + 1;
          v317 = v316 >> 1;
          v318 = &v311[-(v316 >> 1)];
          v319 = (char *)v10 - (char *)v311;
          if (v10 != v311)
          {
            memmove(&v311[-(v316 >> 1)], v311, (char *)v10 - (char *)v311);
            v10 = (unint64_t *)a2->i64[1];
          }
          v309 = &v10[-v317];
          v10 = (unint64_t *)((char *)v318 + v319);
          a2->i64[1] = (uint64_t)v309;
          a2[1].i64[0] = (uint64_t)v318 + v319;
        }
LABEL_423:
        *v10 = j;
        v10 = (unint64_t *)(a2[1].i64[0] + 8);
        a2[1].i64[0] = (uint64_t)v10;
        if (!--v15)
          goto LABEL_419;
      }
    }
    a2[2].i64[0] = v5 - (v15 << 8);
    if (!v15)
      goto LABEL_419;
    while (1)
    {
      v48 = (unint64_t *)a2->i64[1];
      v50 = *v48;
      v49 = v48 + 1;
      j = v50;
      a2->i64[1] = (uint64_t)v49;
      if (v10 == (unint64_t *)a2[1].i64[1])
      {
        v51 = (uint64_t)v49 - a2->i64[0];
        if ((unint64_t)v49 <= a2->i64[0])
        {
          if (v10 == (unint64_t *)a2->i64[0])
            v59 = 1;
          else
            v59 = ((uint64_t)v10 - a2->i64[0]) >> 2;
          v60 = malloc_type_calloc(v59, 8uLL, 0x80040B8603338uLL);
          if (!v60)
            goto LABEL_54;
          v61 = v59 >> 2;
          v62 = (unint64_t *)&v60[8 * (v59 >> 2)];
          v63 = (unint64_t *)a2->i64[1];
          v10 = v62;
          v64 = a2[1].i64[0] - (_QWORD)v63;
          if (v64)
          {
            v10 = (unint64_t *)((char *)v62 + (v64 & 0xFFFFFFFFFFFFFFF8));
            v65 = v64 - 8;
            if (v65 >= 0x38)
            {
              v67 = 8 * v61;
              v68 = &v60[8 * v61] - (_BYTE *)v63;
              v66 = (unint64_t *)&v60[8 * (v59 >> 2)];
              if (v68 < 0x20)
                goto LABEL_81;
              v69 = (v65 >> 3) + 1;
              v70 = v69 & 0x3FFFFFFFFFFFFFFCLL;
              v66 = &v62[v70];
              v71 = (__int128 *)(v63 + 2);
              v72 = &v60[v67 + 16];
              v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v74 = *v71;
                *(v72 - 1) = *(v71 - 1);
                *v72 = v74;
                v71 += 2;
                v72 += 2;
                v73 -= 4;
              }
              while (v73);
              if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v63 = (unint64_t *)((char *)v63 + v70 * 8);
                goto LABEL_81;
              }
            }
            else
            {
              v66 = (unint64_t *)&v60[8 * (v59 >> 2)];
              do
              {
LABEL_81:
                v75 = *v63++;
                *v66++ = v75;
              }
              while (v66 != v10);
            }
          }
          v76 = (void *)a2->i64[0];
          a2->i64[0] = (uint64_t)v60;
          a2->i64[1] = (uint64_t)v62;
          a2[1].i64[0] = (uint64_t)v10;
          a2[1].i64[1] = (uint64_t)&v60[8 * v59];
          if (v76)
          {
            free(v76);
            v10 = (unint64_t *)a2[1].i64[0];
          }
          goto LABEL_61;
        }
        v52 = v51 >> 3;
        v53 = v51 >> 3 < -1;
        v54 = (v51 >> 3) + 2;
        if (v53)
          v55 = v54;
        else
          v55 = v52 + 1;
        v56 = v55 >> 1;
        v57 = &v49[-(v55 >> 1)];
        v58 = (char *)v10 - (char *)v49;
        if (v10 != v49)
        {
          memmove(&v49[-(v55 >> 1)], v49, (char *)v10 - (char *)v49);
          v10 = (unint64_t *)a2->i64[1];
        }
        v47 = &v10[-v56];
        v10 = (unint64_t *)((char *)v57 + v58);
        a2->i64[1] = (uint64_t)v47;
        a2[1].i64[0] = (uint64_t)v57 + v58;
      }
LABEL_61:
      *v10 = j;
      v10 = (unint64_t *)(a2[1].i64[0] + 8);
      a2[1].i64[0] = (uint64_t)v10;
      if (!--v15)
        goto LABEL_419;
    }
  }
  v25 = j - v5;
  if (j <= v5)
    goto LABEL_141;
  v409 = v18;
  v26 = 32 * v22 - 1;
  if (v10 == v9)
  {
    v26 = 0;
    ++v25;
  }
  if ((_BYTE)v25)
    v27 = (v25 >> 8) + 1;
  else
    v27 = v25 >> 8;
  v28 = (v26 - v7) >> 8;
  if (v27 >= v28)
    v18 = v28;
  else
    v18 = v27;
  v412 = v24;
  if (v27 <= v28)
  {
LABEL_55:
    for (a2[2].i64[0] = v5 + (v18 << 8); v18; --v18)
    {
      v46 = a2[1].i64[0];
      v420 = *(void **)(v46 - 8);
      a2[1].i64[0] = v46 - 8;
      std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
    }
    goto LABEL_140;
  }
  v410 = j;
  j = v27 - v18;
  v29 = a2[1].i64[1] - a2->i64[0];
  v30 = v10 - v9;
  if (v27 - v18 <= (v29 >> 3) - v30)
  {
    if (j)
    {
      if (v9 != (unint64_t *)a2->i64[0])
      {
        do
        {
          v77 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
          if (!v77)
            goto LABEL_54;
          v420 = v77;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
          v78 = a2->i64[1];
          if (a2[1].i64[0] - v78 == 8)
            v79 = 255;
          else
            v79 = 256;
          v5 = v79 + a2[2].i64[0];
          a2[2].i64[0] = v5;
          if (!--j)
            goto LABEL_96;
        }
        while (v78 != a2->i64[0]);
      }
      v18 += j;
      do
      {
        v80 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
        if (!v80)
          goto LABEL_54;
        v420 = v80;
        std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_back(a2, &v420);
        --j;
      }
      while (j);
      v5 = a2[2].u64[0];
    }
LABEL_96:
    a2[2].i64[0] = v5 + (v18 << 8);
    for (j = v410; v18; --v18)
    {
      v81 = a2[1].i64[0];
      v420 = *(void **)(v81 - 8);
      a2[1].i64[0] = v81 - 8;
      std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)a2, &v420);
    }
    goto LABEL_140;
  }
  v31 = v10 == v9;
  if (v29 >> 2 <= j + v30)
    v32 = j + v30;
  else
    v32 = v29 >> 2;
  v407 = v15;
  if (v32)
  {
    v33 = (uint64_t *)malloc_type_calloc(v32, 8uLL, 0x80040B8603338uLL);
    if (!v33)
      goto LABEL_54;
  }
  else
  {
    v33 = 0;
  }
  v405 = (v27 << 8) - v31;
  v15 = (uint64_t)&v33[v32];
  v84 = v33;
  v85 = (char *)v33;
  do
  {
    v86 = malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
    if (!v86)
      goto LABEL_54;
    v87 = v86;
    if (v85 == (char *)v15)
    {
      __src = v33;
      if (v84 <= v33)
      {
        if ((uint64_t *)v15 == v33)
          v94 = 1;
        else
          v94 = (v15 - (uint64_t)v33) >> 2;
        v95 = (uint64_t *)malloc_type_calloc(v94, 8uLL, 0x80040B8603338uLL);
        if (!v95)
          goto LABEL_54;
        v96 = v95;
        v97 = v94 >> 2;
        v98 = (char *)&v95[v94 >> 2];
        v85 = v98;
        v99 = v15 - (_QWORD)v84;
        if ((uint64_t *)v15 != v84)
        {
          v85 = &v98[v99 & 0xFFFFFFFFFFFFFFF8];
          v100 = v99 - 8;
          if (v100 >= 0x38)
          {
            v102 = v97;
            if ((unint64_t)((char *)&v95[v97] - (char *)v84) < 0x20)
            {
              v101 = (char *)&v95[v94 >> 2];
              goto LABEL_131;
            }
            v103 = (v100 >> 3) + 1;
            v104 = 8 * (v103 & 0x3FFFFFFFFFFFFFFCLL);
            v101 = &v98[v104];
            v105 = (__int128 *)(v84 + 2);
            v106 = &v95[v102 + 2];
            v107 = v103 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v108 = *v105;
              *((_OWORD *)v106 - 1) = *(v105 - 1);
              *(_OWORD *)v106 = v108;
              v105 += 2;
              v106 += 4;
              v107 -= 4;
            }
            while (v107);
            if (v103 != (v103 & 0x3FFFFFFFFFFFFFFCLL))
            {
              v84 = (uint64_t *)((char *)v84 + v104);
              goto LABEL_131;
            }
          }
          else
          {
            v101 = (char *)&v95[v94 >> 2];
            do
            {
LABEL_131:
              v109 = *v84++;
              *(_QWORD *)v101 = v109;
              v101 += 8;
            }
            while (v101 != v85);
          }
        }
        v15 = (uint64_t)&v95[v94];
        if (__src)
        {
          v84 = &v95[v94 >> 2];
          free(__src);
        }
        else
        {
          v84 = (uint64_t *)v98;
        }
        v33 = v96;
        goto LABEL_108;
      }
      v88 = v84 - v33;
      if (v88 >= -1)
        v89 = v88 + 1;
      else
        v89 = v88 + 2;
      v90 = v89 >> 1;
      v91 = (char *)&v84[-(v89 >> 1)];
      v92 = (_QWORD *)v15;
      if ((uint64_t *)v15 != v84)
      {
        memmove(v91, v84, v15 - (_QWORD)v84);
        v92 = v84;
      }
      v93 = -v90;
      v85 = &v91[v15 - (_QWORD)v84];
      v84 = &v92[v93];
    }
LABEL_108:
    *(_QWORD *)v85 = v87;
    v85 += 8;
    --j;
  }
  while (j);
  j = a2[1].u64[0];
  if (v18)
  {
    while (1)
    {
      if (v85 == (char *)v15)
      {
        if (v84 <= v33)
        {
          __srca = v33;
          if ((uint64_t *)v15 == v33)
            v123 = 1;
          else
            v123 = (v15 - (uint64_t)v33) >> 2;
          v124 = (uint64_t *)malloc_type_calloc(v123, 8uLL, 0x80040B8603338uLL);
          if (!v124)
            goto LABEL_54;
          v125 = v124;
          v126 = v123 >> 2;
          v110 = &v124[v123 >> 2];
          v85 = (char *)v110;
          v127 = v15 - (_QWORD)v84;
          if ((uint64_t *)v15 != v84)
          {
            v85 = (char *)v110 + (v127 & 0xFFFFFFFFFFFFFFF8);
            v128 = v127 - 8;
            if (v128 >= 0x38)
            {
              v130 = v126;
              if ((unint64_t)((char *)&v124[v126] - (char *)v84) < 0x20)
              {
                v129 = (char *)&v124[v123 >> 2];
                goto LABEL_170;
              }
              v131 = (v128 >> 3) + 1;
              v132 = v131 & 0x3FFFFFFFFFFFFFFCLL;
              v129 = (char *)&v110[v132];
              v133 = (__int128 *)(v84 + 2);
              v134 = &v124[v130 + 2];
              v135 = v131 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v136 = *v133;
                *((_OWORD *)v134 - 1) = *(v133 - 1);
                *(_OWORD *)v134 = v136;
                v133 += 2;
                v134 += 4;
                v135 -= 4;
              }
              while (v135);
              if (v131 != (v131 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v84 = (uint64_t *)((char *)v84 + v132 * 8);
                goto LABEL_170;
              }
            }
            else
            {
              v129 = (char *)&v124[v123 >> 2];
              do
              {
LABEL_170:
                v137 = *v84++;
                *(_QWORD *)v129 = v137;
                v129 += 8;
              }
              while (v129 != v85);
            }
          }
          v15 = (uint64_t)&v124[v123];
          if (__srca)
            free(__srca);
          v33 = v125;
          goto LABEL_148;
        }
        v117 = v84 - v33;
        if (v117 >= -1)
          v118 = v117 + 1;
        else
          v118 = v117 + 2;
        v119 = v118 >> 1;
        v120 = (char *)&v84[-(v118 >> 1)];
        v121 = (_QWORD *)v15;
        if ((uint64_t *)v15 != v84)
        {
          memmove(v120, v84, v15 - (_QWORD)v84);
          v121 = v84;
        }
        v122 = -v119;
        v85 = &v120[v15 - (_QWORD)v84];
        v110 = &v121[v122];
      }
      else
      {
        v110 = v84;
      }
LABEL_148:
      *(_QWORD *)v85 = *(_QWORD *)(j - 8);
      v85 += 8;
      j = a2[1].i64[0] - 8;
      a2[1].i64[0] = j;
      v84 = v110;
      if (!--v18)
        goto LABEL_136;
    }
  }
  v110 = v84;
LABEL_136:
  v18 = (unint64_t)v33;
  v111 = (uint64_t *)a2->i64[1];
  if (v111 != (uint64_t *)j)
  {
    while (1)
    {
      if (v85 == (char *)v15)
      {
        if ((unint64_t)v110 <= v18)
        {
          if (v15 == v18)
            v144 = 1;
          else
            v144 = (uint64_t)(v15 - v18) >> 2;
          v145 = malloc_type_calloc(v144, 8uLL, 0x80040B8603338uLL);
          if (!v145)
            goto LABEL_54;
          v146 = (unint64_t)v145;
          v147 = v144 >> 2;
          j = (unint64_t)&v145[8 * (v144 >> 2)];
          v85 = (char *)j;
          v148 = v15 - (_QWORD)v110;
          if ((uint64_t *)v15 != v110)
          {
            v85 = (char *)(j + (v148 & 0xFFFFFFFFFFFFFFF8));
            v149 = v148 - 8;
            if (v149 >= 0x38)
            {
              v151 = 8 * v147;
              if ((unint64_t)(&v145[8 * v147] - (_BYTE *)v110) < 0x20)
              {
                v150 = &v145[8 * (v144 >> 2)];
                goto LABEL_197;
              }
              v152 = (v149 >> 3) + 1;
              v153 = 8 * (v152 & 0x3FFFFFFFFFFFFFFCLL);
              v150 = (char *)(j + v153);
              v154 = (__int128 *)(v110 + 2);
              v155 = &v145[v151 + 16];
              v156 = v152 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v157 = *v154;
                *(v155 - 1) = *(v154 - 1);
                *v155 = v157;
                v154 += 2;
                v155 += 2;
                v156 -= 4;
              }
              while (v156);
              if (v152 != (v152 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v110 = (uint64_t *)((char *)v110 + v153);
                goto LABEL_197;
              }
            }
            else
            {
              v150 = &v145[8 * (v144 >> 2)];
              do
              {
LABEL_197:
                v158 = *v110++;
                *(_QWORD *)v150 = v158;
                v150 += 8;
              }
              while (v150 != v85);
            }
          }
          v15 = (uint64_t)&v145[8 * v144];
          if (v18)
            free((void *)v18);
          v18 = v146;
          goto LABEL_175;
        }
        v139 = (uint64_t)((uint64_t)v110 - v18) >> 3;
        if (v139 >= -1)
          v140 = v139 + 1;
        else
          v140 = v139 + 2;
        v141 = v140 >> 1;
        v142 = (char *)&v110[-(v140 >> 1)];
        v143 = (_QWORD *)v15;
        if ((uint64_t *)v15 != v110)
        {
          memmove(v142, v110, v15 - (_QWORD)v110);
          v143 = v110;
        }
        v85 = &v142[v15 - (_QWORD)v110];
        j = (unint64_t)&v143[-v141];
      }
      else
      {
        j = (unint64_t)v110;
      }
LABEL_175:
      v138 = *v111++;
      *(_QWORD *)v85 = v138;
      v85 += 8;
      v110 = (uint64_t *)j;
      if (v111 == (uint64_t *)a2[1].i64[0])
        goto LABEL_138;
    }
  }
  j = (unint64_t)v110;
LABEL_138:
  v112 = (void *)a2->i64[0];
  a2->i64[0] = v18;
  a2->i64[1] = j;
  a2[1].i64[0] = (uint64_t)v85;
  a2[1].i64[1] = v15;
  v15 = v407;
  a2[2].i64[0] += v405;
  j = v410;
  if (v112)
    free(v112);
LABEL_140:
  v5 = a2[2].u64[0];
  v9 = (unint64_t *)a2->i64[1];
  v10 = (unint64_t *)a2[1].i64[0];
  v20 = v5 >> 8;
  v18 = v409;
  v24 = v412;
LABEL_141:
  v113 = &v9[v20];
  if (v10 == v9)
  {
    v114 = 0;
    v115 = j - v24;
    if (j <= v24)
      goto LABEL_202;
LABEL_143:
    if (v24 >= j >> 1)
    {
      v116 = v115 + ((uint64_t)&v16[-*(_QWORD *)v15] >> 4);
      if (v116 >= 1)
      {
        v15 += 8 * ((unint64_t)v116 >> 8);
LABEL_206:
        v161 = *(_QWORD *)v15 + 16 * v116;
        if ((char *)v161 != v16)
          goto LABEL_207;
LABEL_218:
        v159 = v114;
        v160 = (char **)v113;
        goto LABEL_219;
      }
      v167 = 255 - v116;
      v168 = ~(_BYTE)v167;
      v15 -= 8 * (v167 >> 8);
    }
    else
    {
      if (!v24)
      {
        v15 = (uint64_t)v419;
        v161 = v18;
        if ((char *)v18 == v16)
          goto LABEL_218;
        goto LABEL_207;
      }
      v116 = ((uint64_t)(v18 - *v419) >> 4) - v24;
      if (v116 >= 1)
      {
        v15 = (uint64_t)&v419[(unint64_t)v116 >> 8];
        goto LABEL_206;
      }
      v169 = 255 - v116;
      v168 = ~(_BYTE)v169;
      v15 = (uint64_t)&v419[-(v169 >> 8)];
    }
    v161 = *(_QWORD *)v15 + 16 * v168;
    if ((char *)v161 == v16)
      goto LABEL_218;
LABEL_207:
    v162 = (const void **)v15;
    v163 = (char *)v161;
    v160 = (char **)v113;
    v159 = v114;
    do
    {
      if (v159 == *v160)
      {
        v165 = (uint64_t)*--v160;
        v159 = (char *)(v165 + 4096);
      }
      if (v163 == *v162)
      {
        v166 = (uint64_t)*--v162;
        v163 = (char *)(v166 + 4096);
      }
      v164 = *((_OWORD *)v163 - 1);
      v163 -= 16;
      *((_OWORD *)v159 - 1) = v164;
      v159 -= 16;
      a2[2] = vaddq_s64(a2[2], (int64x2_t)xmmword_183C6F180);
    }
    while (v163 != v16);
LABEL_219:
    j = v24;
    v16 = (char *)v161;
    if (!v24)
      return;
LABEL_220:
    v170 = j + ((uint64_t)&v114[-*v113] >> 4);
    if (v170 < 1)
    {
      v173 = 255 - v170;
      v171 = &v113[-(v173 >> 8)];
      v172 = (char *)(*v171 + 16 * ~(_BYTE)v173);
      if (v172 == v114)
        goto LABEL_230;
    }
    else
    {
      v171 = &v113[(unint64_t)v170 >> 8];
      v172 = (char *)(*v171 + 16 * v170);
      if (v172 == v114)
        goto LABEL_230;
    }
    v174 = (void **)v171;
    v175 = v172;
    do
    {
      if (v159 == *v160)
      {
        v177 = (uint64_t)*--v160;
        v159 = (char *)(v177 + 4096);
      }
      if (v175 == *v174)
      {
        v178 = (uint64_t)*--v174;
        v175 = (char *)(v178 + 4096);
      }
      v176 = *((_OWORD *)v175 - 1);
      v175 -= 16;
      *((_OWORD *)v159 - 1) = v176;
      v159 -= 16;
      a2[2] = vaddq_s64(a2[2], (int64x2_t)xmmword_183C6F180);
    }
    while (v175 != v114);
LABEL_230:
    if (j < v24)
    {
      v179 = (char *)*v113;
      v180 = v24 + ((uint64_t)&v114[-*v113] >> 4);
      if (v180 < 1)
      {
        v183 = 255 - v180;
        v181 = (char **)&v113[-(v183 >> 8)];
        v182 = (uint64_t)&(*v181)[16 * ~(_BYTE)v183];
      }
      else
      {
        v181 = (char **)&v113[(unint64_t)v180 >> 8];
        v182 = (uint64_t)&(*v181)[16 * v180];
      }
      __srcb = (char *)v182;
      if (v171 != (unint64_t *)v181)
      {
        v184 = *v171 + 4096;
        if ((char *)v184 != v172)
        {
          v185 = v16;
          v186 = v15;
          while (1)
          {
            v187 = (v179 - v114 + 4096) >> 4;
            if ((v184 - (uint64_t)v172) >> 4 >= v187)
              v188 = v187;
            else
              v188 = (v184 - (uint64_t)v172) >> 4;
            if (v188)
              memmove(v114, v172, 16 * v188);
            v172 += 16 * v188;
            if (v172 == (char *)v184)
              break;
            v189 = (char *)v113[1];
            ++v113;
            v179 = v189;
            v114 = v189;
          }
          v114 += 16 * v188;
          v179 = (char *)*v113;
          if ((char *)(*v113 + 4096) == v114)
          {
            v190 = (char *)v113[1];
            ++v113;
            v179 = v190;
            v114 = v190;
          }
          v15 = v186;
          v16 = v185;
        }
        v191 = (char **)(v171 + 1);
        if (v171 + 1 != (unint64_t *)v181)
        {
          v413 = v16;
          do
          {
            v192 = v15;
            v193 = v18;
            v194 = 0;
            v195 = *v191;
            while (1)
            {
              v196 = (v179 - v114 + 4096) >> 4;
              if ((4096 - 16 * v194) >> 4 >= v196)
                v197 = v196;
              else
                v197 = (4096 - 16 * v194) >> 4;
              if (v197)
                memmove(v114, &v195[16 * v194], 16 * v197);
              v194 += v197;
              if (v194 == 256)
                break;
              v198 = (char *)v113[1];
              ++v113;
              v179 = v198;
              v114 = v198;
            }
            v114 += 16 * v197;
            v179 = (char *)*v113;
            if ((char *)(*v113 + 4096) == v114)
            {
              v199 = (char *)v113[1];
              ++v113;
              v179 = v199;
              v114 = v199;
            }
            v18 = v193;
            v15 = v192;
            ++v191;
          }
          while (v191 != v181);
          v16 = v413;
        }
        v200 = *v181;
        if (*v181 == __srcb)
          goto LABEL_283;
        v201 = (char *)*v113;
        while (1)
        {
          v202 = (v201 - v114 + 4096) >> 4;
          if ((__srcb - v200) >> 4 >= v202)
            v203 = v202;
          else
            v203 = (__srcb - v200) >> 4;
          if (v203)
            memmove(v114, v200, 16 * v203);
          v200 += 16 * v203;
          if (v200 == __srcb)
            break;
          v204 = (char *)v113[1];
          ++v113;
          v201 = v204;
          v114 = v204;
        }
        v114 += 16 * v203;
        goto LABEL_281;
      }
      if (v172 != (char *)v182)
      {
        while (1)
        {
          v206 = (v179 - v114 + 4096) >> 4;
          if ((__srcb - v172) >> 4 >= v206)
            v207 = v206;
          else
            v207 = (__srcb - v172) >> 4;
          if (v207)
            memmove(v114, v172, 16 * v207);
          v172 += 16 * v207;
          if (v172 == __srcb)
            break;
          v205 = (char *)v113[1];
          ++v113;
          v179 = v205;
          v114 = v205;
        }
        v114 += 16 * v207;
LABEL_281:
        if ((char *)(*v113 + 4096) == v114)
        {
          v208 = (char *)v113[1];
          ++v113;
          v114 = v208;
        }
      }
    }
LABEL_283:
    if (v419 == (uint64_t *)v15)
    {
      if (v16 != (char *)v18)
      {
        v232 = (char *)*v113;
        v231 = (void **)(v113 + 1);
        v230 = v232;
        while (1)
        {
          v233 = (v230 - v114 + 4096) >> 4;
          if ((uint64_t)(v18 - (_QWORD)v16) >> 4 >= v233)
            v234 = v233;
          else
            v234 = (uint64_t)(v18 - (_QWORD)v16) >> 4;
          if (v234)
            memmove(v114, v16, 16 * v234);
          v16 += 16 * v234;
          if (v16 == (char *)v18)
            break;
          v235 = (char *)*v231++;
          v230 = v235;
          v114 = v235;
        }
      }
    }
    else
    {
      v209 = *(_QWORD *)v15 + 4096;
      if ((char *)v209 != v16)
      {
        v210 = (char *)*v113;
        while (1)
        {
          v211 = (v210 - v114 + 4096) >> 4;
          if ((v209 - (uint64_t)v16) >> 4 >= v211)
            v212 = v211;
          else
            v212 = (v209 - (uint64_t)v16) >> 4;
          if (v212)
            memmove(v114, v16, 16 * v212);
          v16 += 16 * v212;
          if (v16 == (char *)v209)
            break;
          v213 = (char *)v113[1];
          ++v113;
          v210 = v213;
          v114 = v213;
        }
        v114 += 16 * v212;
        if ((char *)(*v113 + 4096) == v114)
        {
          v214 = (char *)v113[1];
          ++v113;
          v114 = v214;
        }
      }
      v215 = (uint64_t *)(v15 + 8);
      if ((uint64_t *)(v15 + 8) != v419)
      {
        v216 = (char *)*v113;
        do
        {
          v217 = 0;
          v218 = *v215;
          while (1)
          {
            v219 = (v216 - v114 + 4096) >> 4;
            if ((4096 - 16 * v217) >> 4 >= v219)
              v220 = v219;
            else
              v220 = (4096 - 16 * v217) >> 4;
            if (v220)
              memmove(v114, (const void *)(v218 + 16 * v217), 16 * v220);
            v217 += v220;
            if (v217 == 256)
              break;
            v221 = (char *)v113[1];
            ++v113;
            v216 = v221;
            v114 = v221;
          }
          v114 += 16 * v220;
          v216 = (char *)*v113;
          if ((char *)(*v113 + 4096) == v114)
          {
            v222 = (char *)v113[1];
            ++v113;
            v216 = v222;
            v114 = v222;
          }
          ++v215;
        }
        while (v215 != v419);
      }
      v223 = (char *)*v419;
      if (*v419 != v18)
      {
        v226 = (char *)*v113;
        v225 = (void **)(v113 + 1);
        v224 = v226;
        while (1)
        {
          v227 = (v224 - v114 + 4096) >> 4;
          v228 = (uint64_t)(v18 - (_QWORD)v223) >> 4 >= v227 ? v227 : (uint64_t)(v18 - (_QWORD)v223) >> 4;
          if (v228)
            memmove(v114, v223, 16 * v228);
          v223 += 16 * v228;
          if (v223 == (char *)v18)
            break;
          v229 = (char *)*v225++;
          v224 = v229;
          v114 = v229;
        }
      }
    }
    return;
  }
  v114 = (char *)(*v113 + 16 * v5);
  v115 = j - v24;
  if (j > v24)
    goto LABEL_143;
LABEL_202:
  v159 = v114;
  v160 = (char **)v113;
  if (j)
    goto LABEL_220;
}

void nw::object::_class(nw::object *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      nw::object::_class(void)::instance = (uint64_t)"object";
      *(_QWORD *)algn_1ECD84F58 = 6;
      xmmword_1ECD84F60 = 0u;
      unk_1ECD84F70 = 0u;
      xmmword_1ECD84F80 = 0u;
      *(_OWORD *)&qword_1ECD84F90 = 0u;
      *(__int128 *)((char *)&xmmword_1ECD84F98 + 8) = 0u;
      *(_OWORD *)&qword_1ECD84FB0 = 0u;
      xmmword_1ECD84FC0 = 0u;
      unk_1ECD84FD0 = 0u;
      qword_1ECD84FE0 = (uint64_t)&qword_1ECD84FE0;
      unk_1ECD84FE8 = &qword_1ECD84FE0;
      qword_1ECD84FF0 = 0;
      dword_1ECD84FF8 = 0;
    }
  }
}

void __cxx_global_var_init_2()
{
  unsigned __int8 v0;
  unsigned __int8 v1;
  uint64_t v2;

  {
    if ((v1 & 1) == 0)
    {
      {
        nw::object::_class(void)::instance = (uint64_t)"object";
        *(_QWORD *)algn_1ECD84F58 = 6;
        xmmword_1ECD84F60 = 0u;
        unk_1ECD84F70 = 0u;
        xmmword_1ECD84F80 = 0u;
        *(_OWORD *)&qword_1ECD84F90 = 0u;
        *(__int128 *)((char *)&xmmword_1ECD84F98 + 8) = 0u;
        *(_OWORD *)&qword_1ECD84FB0 = 0u;
        xmmword_1ECD84FC0 = 0u;
        unk_1ECD84FD0 = 0u;
        qword_1ECD84FE0 = (uint64_t)&qword_1ECD84FE0;
        unk_1ECD84FE8 = &qword_1ECD84FE0;
        qword_1ECD84FF0 = 0;
        dword_1ECD84FF8 = 0;
      }
    }
    nw::object::__destroy_def_instance = (uint64_t)nw::object::class_def::register_method_def(qword_1ECD85030, (uint64_t)nw::object::_destroy, 0);
    qword_1ECD85030 = v2;
  }
}

void __cxx_global_var_init()
{
  unsigned __int8 v0;
  unsigned __int8 v1;
  uint64_t v2;

  {
    if ((v1 & 1) == 0)
    {
      {
        nw::object::_class(void)::instance = (uint64_t)"object";
        *(_QWORD *)algn_1ECD84F58 = 6;
        xmmword_1ECD84F60 = 0u;
        unk_1ECD84F70 = 0u;
        xmmword_1ECD84F80 = 0u;
        *(_OWORD *)&qword_1ECD84F90 = 0u;
        *(__int128 *)((char *)&xmmword_1ECD84F98 + 8) = 0u;
        *(_OWORD *)&qword_1ECD84FB0 = 0u;
        xmmword_1ECD84FC0 = 0u;
        unk_1ECD84FD0 = 0u;
        qword_1ECD84FE0 = (uint64_t)&qword_1ECD84FE0;
        unk_1ECD84FE8 = &qword_1ECD84FE0;
        qword_1ECD84FF0 = 0;
        dword_1ECD84FF8 = 0;
      }
    }
    nw::object::__description_def_instance = (uint64_t)nw::object::class_def::register_method_def(qword_1ECD85060, (uint64_t)nw::object::_description, 0);
    qword_1ECD85060 = v2;
  }
}

char *nw::object::class_def::register_method_def(char a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *result;
  size_t v25;
  char *v26;
  char *v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  size_t v31;
  char *v32;
  uint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  size_t v48;
  char *v49;
  char *v50;
  uint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  size_t v58;
  unint64_t v59;
  int64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  __int128 *v67;
  char *v68;
  uint64_t v69;
  __int128 v70;
  uint64_t v71;
  void *v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  __int128 *v76;
  _OWORD *v77;
  uint64_t v78;
  __int128 v79;
  uint64_t v80;
  void *v81;
  _QWORD *v82;
  size_t v83;
  char *v84;
  uint64_t *v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  __int128 *v92;
  _OWORD *v93;
  uint64_t v94;
  __int128 v95;
  uint64_t v96;
  void *v97;
  char *v98;
  NSObject *v99;
  os_log_type_t v100;
  const char *v101;
  char *backtrace_string;
  _BOOL4 v103;
  uint64_t v104;
  char v107;
  os_log_type_t type;
  _BYTE buf[12];
  __int16 v110;
  char *v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "register_method_def";
    v98 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v107 = 0;
    if (__nwlog_fault(v98, &type, &v107))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v99 = __nwlog_obj();
        v100 = type;
        if (os_log_type_enabled(v99, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "register_method_def";
          v101 = "%{public}s called with null (!def.slot())";
LABEL_120:
          _os_log_impl(&dword_182FBE000, v99, v100, v101, buf, 0xCu);
        }
      }
      else if (v107)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v99 = __nwlog_obj();
        v100 = type;
        v103 = os_log_type_enabled(v99, type);
        if (backtrace_string)
        {
          if (v103)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "register_method_def";
            v110 = 2082;
            v111 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v99, v100, "%{public}s called with null (!def.slot()), dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_121;
        }
        if (v103)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "register_method_def";
          v101 = "%{public}s called with null (!def.slot()), no backtrace";
          goto LABEL_120;
        }
      }
      else
      {
        v99 = __nwlog_obj();
        v100 = type;
        if (os_log_type_enabled(v99, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "register_method_def";
          v101 = "%{public}s called with null (!def.slot()), backtrace limit exceeded";
          goto LABEL_120;
        }
      }
    }
LABEL_121:
    if (v98)
      free(v98);
    return 0;
  }
  v3 = a3;
  v4 = a2;
  v5 = (char *)*((_QWORD *)&xmmword_1ECD84F98 + 1);
  v6 = (char *)xmmword_1ECD84F98;
  v7 = *((_QWORD *)&xmmword_1ECD84F98 + 1) - xmmword_1ECD84F98;
  if (*((_QWORD *)&xmmword_1ECD84F98 + 1) == (_QWORD)xmmword_1ECD84F98)
    v8 = 0;
  else
    v8 = 32 * (*((_QWORD *)&xmmword_1ECD84F98 + 1) - xmmword_1ECD84F98) - 1;
  v9 = qword_1ECD84FB8;
  v10 = qword_1ECD84FB0 + qword_1ECD84FB8;
  if (v8 != qword_1ECD84FB0 + qword_1ECD84FB8)
    goto LABEL_89;
  if ((unint64_t)qword_1ECD84FB0 < 0x100)
  {
    v23 = v7 >> 3;
    if (v7 >> 3 < (unint64_t)((qword_1ECD84FA8 - qword_1ECD84F90) >> 3))
    {
      if (qword_1ECD84FA8 != *((_QWORD *)&xmmword_1ECD84F98 + 1))
      {
        result = (char *)malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
        if (result)
        {
          *(_QWORD *)buf = result;
          std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_back(&qword_1ECD84F90, buf);
LABEL_88:
          v6 = (char *)xmmword_1ECD84F98;
          v10 = qword_1ECD84FB8 + qword_1ECD84FB0;
LABEL_89:
          v82 = (_QWORD *)(*(_QWORD *)&v6[(v10 >> 5) & 0x7FFFFFFFFFFFFF8] + 16 * v10);
          *v82 = v4;
          v82[1] = v3;
          ++qword_1ECD84FB8;
          return (char *)v9;
        }
        goto LABEL_124;
      }
      result = (char *)malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
      if (!result)
        goto LABEL_124;
      *(_QWORD *)buf = result;
      std::__split_buffer<void (nw::object::**)(void),nw::c_allocator<void (nw::object::**)(void)>>::push_front((const void **)&qword_1ECD84F90, buf);
      v37 = (char *)*((_QWORD *)&xmmword_1ECD84F98 + 1);
      v38 = (char *)(xmmword_1ECD84F98 + 8);
      v39 = *(_QWORD *)xmmword_1ECD84F98;
      *(_QWORD *)&xmmword_1ECD84F98 = xmmword_1ECD84F98 + 8;
      if (*((_QWORD *)&xmmword_1ECD84F98 + 1) != qword_1ECD84FA8)
      {
LABEL_106:
        *(_QWORD *)v37 = v39;
        *((_QWORD *)&xmmword_1ECD84F98 + 1) += 8;
        goto LABEL_88;
      }
      v40 = (uint64_t)&v38[-qword_1ECD84F90];
      if ((unint64_t)v38 > qword_1ECD84F90)
      {
        v41 = v40 >> 3;
        v15 = v40 >> 3 < -1;
        v42 = (v40 >> 3) + 2;
        if (v15)
          v43 = v42;
        else
          v43 = v41 + 1;
        v44 = v43 >> 1;
        v45 = -v44;
        v46 = &v38[-8 * v44];
        v47 = *((_QWORD *)&xmmword_1ECD84F98 + 1) - (_QWORD)v38;
        if (*((char **)&xmmword_1ECD84F98 + 1) != v38)
        {
          memmove(&v38[-8 * v44], v38, *((_QWORD *)&xmmword_1ECD84F98 + 1) - (_QWORD)v38);
          v38 = (char *)xmmword_1ECD84F98;
        }
        v37 = &v46[v47];
        *(_QWORD *)&xmmword_1ECD84F98 = &v38[8 * v45];
        *((_QWORD *)&xmmword_1ECD84F98 + 1) = &v46[v47];
        goto LABEL_106;
      }
      if (*((_QWORD *)&xmmword_1ECD84F98 + 1) == qword_1ECD84F90)
        v83 = 1;
      else
        v83 = (*((_QWORD *)&xmmword_1ECD84F98 + 1) - qword_1ECD84F90) >> 2;
      result = (char *)malloc_type_calloc(v83, 8uLL, 0x80040B8603338uLL);
      if (!result)
        goto LABEL_124;
      v84 = &result[8 * (v83 >> 2)];
      v85 = (uint64_t *)xmmword_1ECD84F98;
      v37 = v84;
      v86 = *((_QWORD *)&xmmword_1ECD84F98 + 1) - xmmword_1ECD84F98;
      if (*((_QWORD *)&xmmword_1ECD84F98 + 1) != (_QWORD)xmmword_1ECD84F98)
      {
        v37 = &v84[v86 & 0xFFFFFFFFFFFFFFF8];
        v87 = v86 - 8;
        if (v87 < 0x38)
        {
          v88 = &result[8 * (v83 >> 2)];
          goto LABEL_103;
        }
        v89 = &result[8 * (v83 >> 2)];
        v88 = v89;
        if ((unint64_t)&v89[-xmmword_1ECD84F98] < 0x20)
        {
          do
          {
LABEL_103:
            v96 = *v85++;
            *(_QWORD *)v88 = v96;
            v88 += 8;
          }
          while (v88 != v37);
          goto LABEL_104;
        }
        v90 = (v87 >> 3) + 1;
        v91 = 8 * (v90 & 0x3FFFFFFFFFFFFFFCLL);
        v88 = &v84[v91];
        v92 = (__int128 *)(xmmword_1ECD84F98 + 16);
        v93 = v89 + 16;
        v94 = v90 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v95 = *v92;
          *(v93 - 1) = *(v92 - 1);
          *v93 = v95;
          v92 += 2;
          v93 += 2;
          v94 -= 4;
        }
        while (v94);
        if (v90 != (v90 & 0x3FFFFFFFFFFFFFFCLL))
        {
          v85 = (uint64_t *)((char *)v85 + v91);
          goto LABEL_103;
        }
      }
LABEL_104:
      v97 = (void *)qword_1ECD84F90;
      qword_1ECD84F90 = (uint64_t)result;
      *(_QWORD *)&xmmword_1ECD84F98 = &result[8 * (v83 >> 2)];
      *((_QWORD *)&xmmword_1ECD84F98 + 1) = v37;
      qword_1ECD84FA8 = (uint64_t)&result[8 * v83];
      if (v97)
      {
        free(v97);
        v37 = (char *)*((_QWORD *)&xmmword_1ECD84F98 + 1);
      }
      goto LABEL_106;
    }
    if (qword_1ECD84FA8 == qword_1ECD84F90)
      v25 = 1;
    else
      v25 = (qword_1ECD84FA8 - qword_1ECD84F90) >> 2;
    result = (char *)malloc_type_calloc(v25, 8uLL, 0x80040B8603338uLL);
    if (!result)
      goto LABEL_124;
    v26 = result;
    v104 = v9;
    result = (char *)malloc_type_calloc(0x100uLL, 0x10uLL, 0x80040803F642BuLL);
    if (!result)
      goto LABEL_124;
    v27 = result;
    v28 = &v26[8 * v23];
    v29 = (unint64_t)&v26[8 * v25];
    if (v23 == v25)
    {
      if (v7 < 1)
      {
        if (v5 == v6)
          v48 = 1;
        else
          v48 = v7 >> 2;
        result = (char *)malloc_type_calloc(v48, 8uLL, 0x80040B8603338uLL);
        if (!result)
          goto LABEL_124;
        v49 = result;
        v28 = &result[8 * (v48 >> 2)];
        v29 = (unint64_t)&result[8 * v48];
        free(v26);
        v26 = v49;
      }
      else
      {
        v30 = v23 + 2;
        if (v23 >= -1)
          v30 = v23 + 1;
        v28 -= 8 * (v30 >> 1);
      }
    }
    *(_QWORD *)v28 = v27;
    v50 = v28 + 8;
    v51 = *((_QWORD *)&xmmword_1ECD84F98 + 1);
    if (*((_QWORD *)&xmmword_1ECD84F98 + 1) == (_QWORD)xmmword_1ECD84F98)
    {
      v55 = v28;
      v53 = v28 + 8;
LABEL_75:
      v72 = (void *)qword_1ECD84F90;
      qword_1ECD84F90 = (uint64_t)v26;
      *(_QWORD *)&xmmword_1ECD84F98 = v55;
      *((_QWORD *)&xmmword_1ECD84F98 + 1) = v53;
      qword_1ECD84FA8 = v29;
      v9 = v104;
      v4 = a2;
      v3 = a3;
      if (v72)
        free(v72);
      goto LABEL_88;
    }
    while (v28 != v26)
    {
      v52 = v28;
      v53 = v50;
LABEL_52:
      v54 = *(_QWORD *)(v51 - 8);
      v51 -= 8;
      *((_QWORD *)v52 - 1) = v54;
      v55 = v52 - 8;
      v50 = v53;
      v28 = v55;
      if (v51 == (_QWORD)xmmword_1ECD84F98)
        goto LABEL_75;
    }
    if ((unint64_t)v50 < v29)
    {
      v56 = (uint64_t)(v29 - (_QWORD)v50) >> 3;
      if (v56 >= -1)
        v57 = v56 + 1;
      else
        v57 = v56 + 2;
      v53 = &v50[8 * (v57 >> 1)];
      v52 = &v28[8 * (v57 >> 1)];
      if (v50 == v28)
      {
        v26 = v50;
      }
      else
      {
        memmove(&v28[8 * (v57 >> 1)], v28, v50 - v28);
        v26 = v28;
      }
      goto LABEL_52;
    }
    if ((char *)v29 == v28)
      v58 = 1;
    else
      v58 = (uint64_t)(v29 - (_QWORD)v28) >> 2;
    result = (char *)malloc_type_calloc(v58, 8uLL, 0x80040B8603338uLL);
    if (!result)
      goto LABEL_124;
    v26 = result;
    v59 = (v58 + 3) >> 2;
    v52 = &result[8 * v59];
    v53 = v52;
    v60 = v50 - v28;
    if (v50 != v28)
    {
      v53 = &v52[v60 & 0xFFFFFFFFFFFFFFF8];
      v61 = v60 - 8;
      v62 = &result[8 * v59];
      v63 = v28;
      if (v61 >= 0x38)
      {
        v64 = 8 * v59;
        v62 = &result[8 * v59];
        v63 = v28;
        if ((unint64_t)(v62 - v28) >= 0x20)
        {
          v65 = (v61 >> 3) + 1;
          v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
          v62 = &v52[v66];
          v67 = (__int128 *)(v28 + 16);
          v68 = &result[v64 + 16];
          v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v70 = *v67;
            *((_OWORD *)v68 - 1) = *(v67 - 1);
            *(_OWORD *)v68 = v70;
            v67 += 2;
            v68 += 32;
            v69 -= 4;
          }
          while (v69);
          if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL))
            goto LABEL_72;
          v63 = &v28[v66];
        }
      }
      do
      {
        v71 = *(_QWORD *)v63;
        v63 += 8;
        *(_QWORD *)v62 = v71;
        v62 += 8;
      }
      while (v62 != v53);
    }
LABEL_72:
    v29 = (unint64_t)&result[8 * v58];
    free(v28);
    goto LABEL_52;
  }
  qword_1ECD84FB0 -= 256;
  v12 = (char *)(xmmword_1ECD84F98 + 8);
  v11 = *(_QWORD *)xmmword_1ECD84F98;
  *(_QWORD *)&xmmword_1ECD84F98 = xmmword_1ECD84F98 + 8;
  if (qword_1ECD84FA8 != *((_QWORD *)&xmmword_1ECD84F98 + 1))
  {
LABEL_87:
    *(_QWORD *)v5 = v11;
    *((_QWORD *)&xmmword_1ECD84F98 + 1) += 8;
    goto LABEL_88;
  }
  v13 = (uint64_t)&v12[-qword_1ECD84F90];
  if ((unint64_t)v12 > qword_1ECD84F90)
  {
    v14 = v13 >> 3;
    v15 = v13 >> 3 < -1;
    v16 = (v13 >> 3) + 2;
    if (v15)
      v17 = v16;
    else
      v17 = v14 + 1;
    v18 = v17 >> 1;
    v19 = -v18;
    v20 = &v12[-8 * v18];
    v21 = *((_QWORD *)&xmmword_1ECD84F98 + 1) - (_QWORD)v12;
    if (*((char **)&xmmword_1ECD84F98 + 1) == v12)
    {
      v22 = *((_QWORD *)&xmmword_1ECD84F98 + 1);
    }
    else
    {
      memmove(&v12[-8 * v18], v12, *((_QWORD *)&xmmword_1ECD84F98 + 1) - (_QWORD)v12);
      v22 = xmmword_1ECD84F98;
    }
    v5 = &v20[v21];
    *(_QWORD *)&xmmword_1ECD84F98 = v22 + 8 * v19;
    *((_QWORD *)&xmmword_1ECD84F98 + 1) = &v20[v21];
    goto LABEL_87;
  }
  if (*((_QWORD *)&xmmword_1ECD84F98 + 1) == qword_1ECD84F90)
    v31 = 1;
  else
    v31 = (*((_QWORD *)&xmmword_1ECD84F98 + 1) - qword_1ECD84F90) >> 2;
  result = (char *)malloc_type_calloc(v31, 8uLL, 0x80040B8603338uLL);
  if (result)
  {
    v32 = &result[8 * (v31 >> 2)];
    v33 = (uint64_t *)xmmword_1ECD84F98;
    v5 = v32;
    v34 = *((_QWORD *)&xmmword_1ECD84F98 + 1) - xmmword_1ECD84F98;
    if (*((_QWORD *)&xmmword_1ECD84F98 + 1) == (_QWORD)xmmword_1ECD84F98)
      goto LABEL_85;
    v5 = &v32[v34 & 0xFFFFFFFFFFFFFFF8];
    v35 = v34 - 8;
    if (v35 >= 0x38)
    {
      v73 = &result[8 * (v31 >> 2)];
      v36 = v73;
      if ((unint64_t)&v73[-xmmword_1ECD84F98] >= 0x20)
      {
        v74 = (v35 >> 3) + 1;
        v75 = 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
        v36 = &v32[v75];
        v76 = (__int128 *)(xmmword_1ECD84F98 + 16);
        v77 = v73 + 16;
        v78 = v74 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v79 = *v76;
          *(v77 - 1) = *(v76 - 1);
          *v77 = v79;
          v76 += 2;
          v77 += 2;
          v78 -= 4;
        }
        while (v78);
        if (v74 == (v74 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_85:
          v81 = (void *)qword_1ECD84F90;
          qword_1ECD84F90 = (uint64_t)result;
          *(_QWORD *)&xmmword_1ECD84F98 = &result[8 * (v31 >> 2)];
          *((_QWORD *)&xmmword_1ECD84F98 + 1) = v5;
          qword_1ECD84FA8 = (uint64_t)&result[8 * v31];
          if (v81)
          {
            free(v81);
            v5 = (char *)*((_QWORD *)&xmmword_1ECD84F98 + 1);
          }
          goto LABEL_87;
        }
        v33 = (uint64_t *)((char *)v33 + v75);
      }
    }
    else
    {
      v36 = &result[8 * (v31 >> 2)];
    }
    do
    {
      v80 = *v33++;
      *(_QWORD *)v36 = v80;
      v36 += 8;
    }
    while (v36 != v5);
    goto LABEL_85;
  }
LABEL_124:
  __break(1u);
  return result;
}

uint64_t __nw_parameters_get_prohibit_cellular_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;

  v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1E0C81398])
  {
    v5 = 1;
    if (xpc_uint64_get_value(v4) == 2)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      v5 = 0;
    }
  }
  else
  {
    v5 = 1;
  }

  return v5;
}

void sub_18318C844(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_definition_set_outbound_events(void *a1, void *a2, void *a3, void *a4)
{
  NWConcrete_nw_protocol_definition *v7;
  NWConcrete_nw_protocol_definition *v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (v7)
  {
    nw_protocol_definition_initialize_extended_state(v7);
    v8->extended_state->var12 = a2;
    v8->extended_state->var13 = a3;
    v8->extended_state->var14 = a4;
    goto LABEL_3;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_definition_set_outbound_events";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_definition_set_outbound_events";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_protocol_definition_set_outbound_events";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_definition_set_outbound_events";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_definition_set_outbound_events";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v10)
    free(v10);
LABEL_3:

}

void sub_18318CB04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_report_application_result(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_report_application_result_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_report_application_result";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_report_application_result";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_report_application_result";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_report_application_result";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_report_application_result";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_18318CDE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_report_application_result_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 184);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(unsigned __int8 *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_stream_get_application_error(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_application_error_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_application_error";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_application_error";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_application_error";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_application_error";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_application_error";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_18318D140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_application_error_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 16);
  return 1;
}

_QWORD *nw_protocol_set_default_one_to_one_callbacks(_QWORD *result)
{
  *result = nw_protocol_default_add_input_handler;
  result[1] = nw_protocol_default_remove_input_handler;
  result[8] = nw_protocol_default_input_available;
  result[9] = nw_protocol_default_output_available;
  result[10] = nw_protocol_default_get_input_frames;
  result[11] = nw_protocol_default_get_output_frames;
  result[12] = nw_protocol_default_finalize_output_frames;
  result[13] = nw_protocol_default_link_state;
  result[16] = nw_protocol_default_get_local;
  result[17] = nw_protocol_default_get_remote;
  result[14] = nw_protocol_default_get_parameters;
  result[15] = nw_protocol_default_get_path;
  result[24] = nw_protocol_default_output_finished;
  result[25] = nw_protocol_default_get_output_local;
  result[2] = nw_protocol_default_replace_input_handler;
  result[3] = nw_protocol_default_connect;
  result[4] = nw_protocol_default_disconnect;
  result[5] = nw_protocol_default_connected;
  result[6] = nw_protocol_default_disconnected;
  result[7] = nw_protocol_default_error;
  result[32] = nw_protocol_default_reset;
  result[33] = nw_protocol_default_input_flush;
  result[22] = nw_protocol_default_supports_external_data;
  result[23] = nw_protocol_default_input_finished;
  result[26] = nw_protocol_default_get_output_interface;
  result[27] = nw_protocol_default_waiting_for_output;
  result[18] = nw_protocol_default_register_notification;
  result[19] = nw_protocol_default_unregister_notification;
  result[20] = nw_protocol_default_notify;
  result[21] = nw_protocol_default_updated_path;
  result[28] = nw_protocol_default_copy_info;
  result[29] = nw_protocol_default_add_listen_handler;
  result[30] = nw_protocol_default_remove_listen_handler;
  result[31] = nw_protocol_default_get_message_properties;
  return result;
}

BOOL nw_parameters_multipath_fallback_allowed(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (*(_DWORD *)(*((_QWORD *)v1 + 13) + 103) & 0xFFFFFFFE) == 2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_parameters_multipath_fallback_allowed";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_multipath_fallback_allowed";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_parameters_multipath_fallback_allowed";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_multipath_fallback_allowed";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_parameters_multipath_fallback_allowed";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_dictionary_apply_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t pointer;

  v3 = *(_QWORD *)(a1 + 32);
  pointer = xpc_dictionary_get_pointer();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 16))(v3, a2, pointer);
}

void nw_protocol_instance_clear_flow_for_key(void *a1, uint64_t a2)
{
  _QWORD *v3;
  char *v4;
  uint64_t v5;
  uint64_t node;
  uint64_t v7;
  int v8;
  NSObject *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  void *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  NSObject *v26;
  char *v27;
  os_log_type_t v28;
  os_log_type_t v29;
  char *v30;
  os_log_type_t v31;
  _BOOL4 v32;
  os_log_type_t v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = (char *)v3;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_protocol_instance_clear_flow_for_key";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v11, &type, &v34))
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_protocol_instance_clear_flow_for_key";
          v38 = 2082;
          v39 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_66:
        if (!v11)
          goto LABEL_14;
LABEL_67:
        free(v11);
        goto LABEL_14;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        _os_log_impl(&dword_182FBE000, v12, v28, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_65:

    goto LABEL_66;
  }
  if (a2)
  {
    v5 = v3[30];
    if (v5 && *(_DWORD *)(v5 + 40))
    {
      node = nw_hash_table_get_node(v5, a2, *(unsigned int *)(*(_QWORD *)(*((_QWORD *)v4 + 1) + 80) + 256));
      if (node)
      {
        v7 = node;
        v8 = v4[405];
        if (*(_QWORD *)(node + 16))
        {
          if ((v8 & 0x80000000) == 0 && gLogDatapath)
          {
            __nwlog_obj();
            v26 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              v27 = *(char **)(v7 + 32);
              *(_DWORD *)buf = 136447234;
              v37 = "nw_protocol_instance_clear_flow_for_key";
              v38 = 2082;
              v39 = v4 + 407;
              v40 = 2080;
              v41 = " ";
              v42 = 2048;
              v43 = a2;
              v44 = 2048;
              v45 = v27;
              _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sRemoving custom flow mapping for key %p, flow %llx", buf, 0x34u);
            }

          }
          nw_hash_table_remove_node(*((_QWORD *)v4 + 30), v7);
          goto LABEL_14;
        }
        if (v8 < 0)
          goto LABEL_14;
        __nwlog_obj();
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446978;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        v38 = 2082;
        v39 = v4 + 407;
        v40 = 2080;
        v41 = " ";
        v42 = 2048;
        v43 = v7;
        v23 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v34 = 0;
        if (!__nwlog_fault(v23, &type, &v34))
          goto LABEL_74;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446978;
            v37 = "nw_protocol_instance_clear_flow_for_key";
            v38 = 2082;
            v39 = v4 + 407;
            v40 = 2080;
            v41 = " ";
            v42 = 2048;
            v43 = v7;
            _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s %{public}s%sobject not present from node %p", buf, 0x2Au);
          }
        }
        else if (v34)
        {
          v30 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v31 = type;
          v32 = os_log_type_enabled(v24, type);
          if (v30)
          {
            if (v32)
            {
              *(_DWORD *)buf = 136447234;
              v37 = "nw_protocol_instance_clear_flow_for_key";
              v38 = 2082;
              v39 = v4 + 407;
              v40 = 2080;
              v41 = " ";
              v42 = 2048;
              v43 = v7;
              v44 = 2082;
              v45 = v30;
              _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s %{public}s%sobject not present from node %p, dumping backtrace:%{public}s", buf, 0x34u);
            }

            free(v30);
            goto LABEL_74;
          }
          if (v32)
          {
            *(_DWORD *)buf = 136446978;
            v37 = "nw_protocol_instance_clear_flow_for_key";
            v38 = 2082;
            v39 = v4 + 407;
            v40 = 2080;
            v41 = " ";
            v42 = 2048;
            v43 = v7;
            _os_log_impl(&dword_182FBE000, v24, v31, "%{public}s %{public}s%sobject not present from node %p, no backtrace", buf, 0x2Au);
          }
        }
        else
        {
          __nwlog_obj();
          v24 = objc_claimAutoreleasedReturnValue();
          v33 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446978;
            v37 = "nw_protocol_instance_clear_flow_for_key";
            v38 = 2082;
            v39 = v4 + 407;
            v40 = 2080;
            v41 = " ";
            v42 = 2048;
            v43 = v7;
            _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s %{public}s%sobject not present from node %p, backtrace limit exceeded", buf, 0x2Au);
          }
        }

LABEL_74:
        if (v23)
          free(v23);
        goto LABEL_14;
      }
      if (v4[405] < 0)
        goto LABEL_14;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        v38 = 2082;
        v39 = v4 + 407;
        v40 = 2080;
        v41 = " ";
        v42 = 2048;
        v43 = a2;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sNo flow found in custom flow mapping table for key %p", buf, 0x2Au);
      }
    }
    else
    {
      if (v4[405] < 0)
        goto LABEL_14;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v37 = "nw_protocol_instance_clear_flow_for_key";
        v38 = 2082;
        v39 = v4 + 407;
        v40 = 2080;
        v41 = " ";
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sFlow mapping table is empty", buf, 0x20u);
      }
    }

    goto LABEL_14;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_protocol_instance_clear_flow_for_key";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (!__nwlog_fault(v11, &type, &v34))
    goto LABEL_66;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null key", buf, 0xCu);
    }
    goto LABEL_65;
  }
  if (!v34)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v29 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_182FBE000, v12, v29, "%{public}s called with null key, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_65;
  }
  v19 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v12 = objc_claimAutoreleasedReturnValue();
  v20 = type;
  v21 = os_log_type_enabled(v12, type);
  if (!v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      v37 = "nw_protocol_instance_clear_flow_for_key";
      _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null key, no backtrace", buf, 0xCu);
    }
    goto LABEL_65;
  }
  if (v21)
  {
    *(_DWORD *)buf = 136446466;
    v37 = "nw_protocol_instance_clear_flow_for_key";
    v38 = 2082;
    v39 = v19;
    _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null key, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v11)
    goto LABEL_67;
LABEL_14:

}

