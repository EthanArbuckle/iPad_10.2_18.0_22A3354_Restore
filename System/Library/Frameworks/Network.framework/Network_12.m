void tcp_connection_set_source_application_by_bundle(uint64_t a1, const char *a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  char *backtrace_string;
  os_log_type_t v7;
  _BOOL4 v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_source_application_by_bundle_id_internal(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v13 = "tcp_connection_set_source_application_by_bundle";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v3, &type, &v10))
  {
LABEL_8:
    if (!v3)
      return;
    goto LABEL_9;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (os_log_type_enabled(v4, type))
    {
      *(_DWORD *)buf = 136446210;
      v13 = "tcp_connection_set_source_application_by_bundle";
      _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null connection", buf, 0xCu);
    }
LABEL_7:

    goto LABEL_8;
  }
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v9 = type;
    if (os_log_type_enabled(v4, type))
    {
      *(_DWORD *)buf = 136446210;
      v13 = "tcp_connection_set_source_application_by_bundle";
      _os_log_impl(&dword_182FBE000, v4, v9, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_7;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v7 = type;
  v8 = os_log_type_enabled(v4, type);
  if (!backtrace_string)
  {
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      v13 = "tcp_connection_set_source_application_by_bundle";
      _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null connection, no backtrace", buf, 0xCu);
    }
    goto LABEL_7;
  }
  if (v8)
  {
    *(_DWORD *)buf = 136446466;
    v13 = "tcp_connection_set_source_application_by_bundle";
    v14 = 2082;
    v15 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v4, v7, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v3)
LABEL_9:
    free(v3);
}

void tcp_connection_set_account_identifier(uint64_t a1, const char *a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_account_id(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_account_identifier";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_account_identifier";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_account_identifier";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_account_identifier";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_account_identifier";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

void tcp_connection_set_no_delay(uint64_t a1, BOOL a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_no_delay(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_no_delay";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_no_delay";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_no_delay";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_no_delay";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_no_delay";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

BOOL tcp_connection_is_sleep_proxied(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  _BOOL8 v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  NSObject *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v20 = "tcp_connection_is_sleep_proxied";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_is_sleep_proxied";
        v9 = "%{public}s called with null connection";
LABEL_22:
        v15 = v7;
        v16 = v8;
        goto LABEL_23;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_is_sleep_proxied";
        v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_is_sleep_proxied";
        v9 = "%{public}s called with null connection, no backtrace";
        v15 = v7;
        v16 = v12;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_connection_is_sleep_proxied";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_18:
      v4 = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v6);
    goto LABEL_18;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_connection_is_sleep_proxied";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_18;
  }
  v4 = nw_connection_uses_sleep_proxy(v3);
LABEL_19:

  return v4;
}

void tcp_connection_set_sleep_idle_interval(uint64_t a1, int a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_sleep_keepalive_interval(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_sleep_idle_interval";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_sleep_idle_interval";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_sleep_idle_interval";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_sleep_idle_interval";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_sleep_idle_interval";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

void tcp_connection_set_keepalive(void *a1, BOOL a2, uint32_t a3, uint32_t a4)
{
  void **v7;
  void **v8;
  id v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  NSObject *v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "tcp_connection_set_keepalive";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_keepalive";
        v13 = "%{public}s called with null connection";
LABEL_17:
        v17 = v11;
        v18 = v12;
        goto LABEL_18;
      }
      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_keepalive";
        v13 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      v15 = type;
      v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
LABEL_19:

          if (!v10)
            goto LABEL_14;
          goto LABEL_13;
        }
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_keepalive";
        v13 = "%{public}s called with null connection, no backtrace";
        v17 = v11;
        v18 = v15;
LABEL_18:
        _os_log_impl(&dword_182FBE000, v17, v18, v13, buf, 0xCu);
        goto LABEL_19;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "tcp_connection_set_keepalive";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v10)
      goto LABEL_14;
LABEL_13:
    free(v10);
    goto LABEL_14;
  }
  nw_parameters_set_keepalive_enabled(v7[6], a2);
  nw_parameters_set_keepalive_idle_time(v8[6], a3);
  nw_parameters_set_keepalive_interval(v8[6], a4);
LABEL_14:

}

void tcp_connection_set_keepalive_offload(uint64_t a1, char a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_keepalive_offload(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_keepalive_offload";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_keepalive_offload";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_keepalive_offload";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_keepalive_offload";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_keepalive_offload";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

BOOL tcp_connection_conditions_met(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void *v3;
  _DWORD *v4;
  _BOOL8 v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_connection_conditions_met";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "tcp_connection_conditions_met";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "tcp_connection_conditions_met";
            v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v7)
            goto LABEL_11;
          goto LABEL_10;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "tcp_connection_conditions_met";
          _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "tcp_connection_conditions_met";
          _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v7)
    {
LABEL_11:
      v5 = 0;
      goto LABEL_14;
    }
LABEL_10:
    free(v7);
    goto LABEL_11;
  }
  os_unfair_lock_lock(v1 + 30);
  v3 = *(void **)&v2[8]._os_unfair_lock_opaque;
  if (v3)
  {
    v4 = v3;
    v5 = v4[94] == 1;

  }
  else
  {
    v5 = 0;
  }
  os_unfair_lock_unlock(v2 + 30);
LABEL_14:

  return v5;
}

uint64_t tcp_connection_conditions_get_unmet_reason(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  unsigned int reason;
  unsigned int v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  uint64_t v18;
  char *v19;
  os_log_type_t v20;
  _BOOL4 v21;
  NSObject *v23;
  os_log_type_t v24;
  NSObject *v25;
  os_log_type_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  _WORD v32[17];

  *(_QWORD *)&v32[13] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 30);
    reason = nw_path_get_reason(*(void **)&v2[8]._os_unfair_lock_opaque);
    v4 = reason;
    if (reason < 0x20 && ((0xFFBFFFFF >> reason) & 1) != 0)
    {
      v18 = qword_183BA8DB8[reason];
      goto LABEL_29;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v30 = "tcp_connection_reason_code_from_path";
    v31 = 1024;
    *(_DWORD *)v32 = v4;
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v6, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_35;
        *(_DWORD *)buf = 136446466;
        v30 = "tcp_connection_reason_code_from_path";
        v31 = 1024;
        *(_DWORD *)v32 = v4;
        v9 = "%{public}s Unknown nw_path_reason_t %u";
LABEL_33:
        v23 = v7;
        v24 = v8;
        goto LABEL_34;
      }
      if (!v27)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_35;
        *(_DWORD *)buf = 136446466;
        v30 = "tcp_connection_reason_code_from_path";
        v31 = 1024;
        *(_DWORD *)v32 = v4;
        v9 = "%{public}s Unknown nw_path_reason_t %u, backtrace limit exceeded";
        goto LABEL_33;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v17)
        {
LABEL_35:

          if (!v6)
            goto LABEL_19;
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446466;
        v30 = "tcp_connection_reason_code_from_path";
        v31 = 1024;
        *(_DWORD *)v32 = v4;
        v9 = "%{public}s Unknown nw_path_reason_t %u, no backtrace";
        v23 = v7;
        v24 = v16;
LABEL_34:
        _os_log_impl(&dword_182FBE000, v23, v24, v9, buf, 0x12u);
        goto LABEL_35;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446722;
        v30 = "tcp_connection_reason_code_from_path";
        v31 = 1024;
        *(_DWORD *)v32 = v4;
        v32[2] = 2082;
        *(_QWORD *)&v32[3] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s Unknown nw_path_reason_t %u, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_19:
      v18 = 10000;
LABEL_29:
      os_unfair_lock_unlock(v2 + 30);
      goto LABEL_30;
    }
LABEL_18:
    free(v6);
    goto LABEL_19;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v30 = "tcp_connection_conditions_get_unmet_reason";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v11, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      v14 = "%{public}s called with null connection";
LABEL_39:
      v25 = v12;
      v26 = v13;
      goto LABEL_40;
    }
    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      v14 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_39;
    }
    v19 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    v20 = type;
    v21 = os_log_type_enabled(v12, type);
    if (!v19)
    {
      if (!v21)
      {
LABEL_41:

        if (!v11)
          goto LABEL_27;
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      v14 = "%{public}s called with null connection, no backtrace";
      v25 = v12;
      v26 = v20;
LABEL_40:
      _os_log_impl(&dword_182FBE000, v25, v26, v14, buf, 0xCu);
      goto LABEL_41;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "tcp_connection_conditions_get_unmet_reason";
      v31 = 2082;
      *(_QWORD *)v32 = v19;
      _os_log_impl(&dword_182FBE000, v12, v20, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v19);
  }
  if (v11)
LABEL_26:
    free(v11);
LABEL_27:
  v18 = 0;
LABEL_30:

  return v18;
}

void tcp_connection_set_queue(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  NSObject *v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  char *v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  NSObject *v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "tcp_connection_set_queue";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v8, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_25;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_queue";
        v11 = "%{public}s called with null connection";
LABEL_23:
        v17 = v9;
        v18 = v10;
        goto LABEL_24;
      }
      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_25;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_queue";
        v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_23;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v15 = type;
      v16 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
LABEL_25:

          if (!v8)
            goto LABEL_20;
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_queue";
        v11 = "%{public}s called with null connection, no backtrace";
        v17 = v9;
        v18 = v15;
LABEL_24:
        _os_log_impl(&dword_182FBE000, v17, v18, v11, buf, 0xCu);
        goto LABEL_25;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "tcp_connection_set_queue";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v15, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v8)
      goto LABEL_20;
LABEL_19:
    free(v8);
    goto LABEL_20;
  }
  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 30);
    objc_storeStrong((id *)v3 + 7, a2);
    v6 = *((_QWORD *)v3 + 2);
    if (v6)
      nw_connection_set_queue(v6, *((dispatch_queue_t *)v3 + 7));
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 30);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = (char *)*((_QWORD *)v3 + 12);
      *(_DWORD *)buf = 136446466;
      v22 = "tcp_connection_set_queue";
      v23 = 2048;
      v24 = v13;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s %llu client specified nil dispatch queue - not supported", buf, 0x16u);
    }

  }
LABEL_20:

}

void tcp_connection_set_minimum_throughput(void *a1, int a2)
{
  _DWORD *v3;
  _DWORD *v4;
  _QWORD *v5;
  void *v6;
  void *v7;
  int v8;
  id v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  NSObject *v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  _BYTE buf[24];
  void *v22;
  _QWORD *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_connection_set_minimum_throughput";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_21;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "tcp_connection_set_minimum_throughput";
        v13 = "%{public}s called with null connection";
LABEL_19:
        v17 = v11;
        v18 = v12;
        goto LABEL_20;
      }
      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_21;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "tcp_connection_set_minimum_throughput";
        v13 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_19;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      v15 = type;
      v16 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v16)
        {
LABEL_21:

          if (!v10)
            goto LABEL_16;
          goto LABEL_15;
        }
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "tcp_connection_set_minimum_throughput";
        v13 = "%{public}s called with null connection, no backtrace";
        v17 = v11;
        v18 = v15;
LABEL_20:
        _os_log_impl(&dword_182FBE000, v17, v18, v13, buf, 0xCu);
        goto LABEL_21;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_connection_set_minimum_throughput";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v10)
      goto LABEL_16;
LABEL_15:
    free(v10);
    goto LABEL_16;
  }
  v3[38] = a2;
  v5 = v3;
  v6 = v5;
  v7 = (void *)v5[2];
  if (v7)
  {
    v8 = v4[38];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __tcp_connection_set_minimum_throughput_on_nw_connection_block_invoke;
    v22 = &unk_1E149FE18;
    v23 = v5;
    nw_connection_set_low_throughput_handler(v7, v8, buf);

  }
LABEL_16:

}

void __tcp_connection_set_minimum_throughput_on_nw_connection_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  tcp_connection_send_event_unlocked(*(void **)(a1 + 32), 1073741830, &v2, 8uLL, (uint64_t)"low throughput");
}

void tcp_connection_override_obscure(void *a1, int a2, int a3)
{
  void **v5;
  void **v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  NSObject *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v20 = "tcp_connection_override_obscure";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_override_obscure";
        v11 = "%{public}s called with null connection";
LABEL_17:
        v15 = v9;
        v16 = v10;
        goto LABEL_18;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_override_obscure";
        v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
LABEL_19:

          if (!v8)
            goto LABEL_14;
          goto LABEL_13;
        }
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_override_obscure";
        v11 = "%{public}s called with null connection, no backtrace";
        v15 = v9;
        v16 = v13;
LABEL_18:
        _os_log_impl(&dword_182FBE000, v15, v16, v11, buf, 0xCu);
        goto LABEL_19;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_connection_override_obscure";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v8)
      goto LABEL_14;
LABEL_13:
    free(v8);
    goto LABEL_14;
  }
  nw_parameters_set_use_awdl(v5[6], a2);
  nw_parameters_set_use_p2p(v6[6], a3);
LABEL_14:

}

BOOL tcp_connection_is_viable(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  NSObject *v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_connection_is_viable";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_is_viable";
        v8 = "%{public}s called with null connection";
LABEL_21:
        v13 = v6;
        v14 = v7;
        goto LABEL_22;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_is_viable";
        v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v10 = type;
      v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_23:

          if (!v5)
            goto LABEL_17;
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_is_viable";
        v8 = "%{public}s called with null connection, no backtrace";
        v13 = v6;
        v14 = v10;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "tcp_connection_is_viable";
        v19 = 2082;
        v20 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
    {
LABEL_17:
      v3 = 0;
      goto LABEL_18;
    }
LABEL_16:
    free(v5);
    goto LABEL_17;
  }
  os_unfair_lock_lock(v1 + 30);
  v3 = (v2[39]._os_unfair_lock_opaque & 0x1000000) != 0 && (v2[39]._os_unfair_lock_opaque & 0x200000) == 0;
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v3;
}

BOOL tcp_connection_has_better_route(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  _BOOL8 v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  NSObject *v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_connection_has_better_route";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_has_better_route";
        v8 = "%{public}s called with null connection";
LABEL_21:
        v13 = v6;
        v14 = v7;
        goto LABEL_22;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_has_better_route";
        v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v10 = type;
      v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_23:

          if (!v5)
            goto LABEL_17;
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_has_better_route";
        v8 = "%{public}s called with null connection, no backtrace";
        v13 = v6;
        v14 = v10;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "tcp_connection_has_better_route";
        v19 = 2082;
        v20 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
    {
LABEL_17:
      v3 = 0;
      goto LABEL_18;
    }
LABEL_16:
    free(v5);
    goto LABEL_17;
  }
  os_unfair_lock_lock(v1 + 30);
  v3 = (v2[39]._os_unfair_lock_opaque & 0x1000000) == 0
    || nw_connection_better_path_available(*(void **)&v2[4]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v3;
}

uint64_t tcp_connection_get_connection_quality(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  NSObject *v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_connection_get_connection_quality";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_get_connection_quality";
        v8 = "%{public}s called with null connection";
LABEL_21:
        v13 = v6;
        v14 = v7;
        goto LABEL_22;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_get_connection_quality";
        v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v10 = type;
      v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_23:

          if (!v5)
            goto LABEL_17;
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_get_connection_quality";
        v8 = "%{public}s called with null connection, no backtrace";
        v13 = v6;
        v14 = v10;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "tcp_connection_get_connection_quality";
        v19 = 2082;
        v20 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
    {
LABEL_17:
      v3 = 0;
      goto LABEL_18;
    }
LABEL_16:
    free(v5);
    goto LABEL_17;
  }
  os_unfair_lock_lock(v1 + 30);
  if (*(_QWORD *)&v2[8]._os_unfair_lock_opaque)
    v3 = *(_QWORD *)&v2[32]._os_unfair_lock_opaque;
  else
    v3 = 0;
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v3;
}

id tcp_connection_copy_proxy(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  void *v5;
  id v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "tcp_connection_copy_proxy";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v8, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_28;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_copy_proxy";
        v11 = "%{public}s called with null connection";
LABEL_26:
        v17 = v9;
        v18 = v10;
        goto LABEL_27;
      }
      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_28;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_copy_proxy";
        v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_26;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_28:

          if (!v8)
            goto LABEL_22;
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_copy_proxy";
        v11 = "%{public}s called with null connection, no backtrace";
        v17 = v9;
        v18 = v14;
LABEL_27:
        _os_log_impl(&dword_182FBE000, v17, v18, v11, buf, 0xCu);
        goto LABEL_28;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "tcp_connection_copy_proxy";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v8)
    {
LABEL_22:
      v6 = 0;
      goto LABEL_23;
    }
LABEL_21:
    free(v8);
    goto LABEL_22;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (v3)
  {
    v4 = nw_connection_copy_proxy_settings(v3);
    v5 = v4;
    if (v4 && network_proxy_get_type(v4))
      v6 = v5;
    else
      v6 = 0;

  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "tcp_connection_copy_proxy";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    v6 = 0;
  }
LABEL_23:

  return v6;
}

void tcp_connection_set_connection_pool()
{
  NSObject *v0;
  int v1;
  const char *v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v0 = (id)gLogObj;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    v1 = 136446210;
    v2 = "tcp_connection_set_connection_pool";
    _os_log_impl(&dword_182FBE000, v0, OS_LOG_TYPE_ERROR, "%{public}s tcp_connection_set_connection_pool is deprecated", (uint8_t *)&v1, 0xCu);
  }

}

void tcp_connection_set_multipath_service(uint64_t a1, nw_multipath_service_t a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_multipath_service(*(nw_parameters_t *)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_multipath_service";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_multipath_service";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_multipath_service";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_multipath_service";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_multipath_service";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

BOOL tcp_connection_is_multipath(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  _BOOL8 v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  NSObject *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v20 = "tcp_connection_is_multipath";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_is_multipath";
        v9 = "%{public}s called with null connection";
LABEL_22:
        v15 = v7;
        v16 = v8;
        goto LABEL_23;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_is_multipath";
        v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_is_multipath";
        v9 = "%{public}s called with null connection, no backtrace";
        v15 = v7;
        v16 = v12;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_connection_is_multipath";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_18:
      v4 = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v6);
    goto LABEL_18;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_connection_is_multipath";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_18;
  }
  v4 = nw_connection_uses_multipath(v3);
LABEL_19:

  return v4;
}

uint64_t tcp_connection_multipath_get_subflow_count(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  char *v6;
  uint64_t v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v18;
  os_log_type_t type[8];
  os_log_type_t *v20;
  uint64_t v21;
  int v22;
  _BYTE buf[24];
  void *v24;
  char *v25;
  os_log_type_t *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_connection_multipath_get_subflow_count";
    v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v9, type, &v18))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_multipath_get_subflow_count";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v14 = type[0];
        v15 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_connection_multipath_get_subflow_count";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v9)
            goto LABEL_26;
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_multipath_get_subflow_count";
          _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v16 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_multipath_get_subflow_count";
          _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
    {
LABEL_26:
      v7 = 0;
      goto LABEL_27;
    }
LABEL_25:
    free(v9);
    goto LABEL_26;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_connection_multipath_get_subflow_count";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_26;
  }
  v4 = v3;
  *(_QWORD *)type = 0;
  v20 = type;
  v22 = 0;
  v21 = 0x2020000000;
  v5 = v4 + 34;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = __nw_connection_multipath_get_subflow_count_block_invoke;
  v24 = &unk_1E14ACE40;
  v6 = v4;
  v25 = v6;
  v26 = type;
  os_unfair_lock_lock(v5);
  __nw_connection_multipath_get_subflow_count_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v5);
  v7 = *((unsigned int *)v20 + 6);

  _Block_object_dispose(type, 8);
LABEL_27:

  return v7;
}

uint64_t tcp_connection_multipath_get_primary_subflow_ifindex(void *a1)
{
  _QWORD *v1;
  void *v2;
  uint64_t interface;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  NSObject *v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v5, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        v8 = "%{public}s called with null connection";
LABEL_22:
        v14 = v6;
        v15 = v7;
        goto LABEL_23;
      }
      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_24:

          if (!v5)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        v8 = "%{public}s called with null connection, no backtrace";
        v14 = v6;
        v15 = v11;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v14, v15, v8, buf, 0xCu);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
        v20 = 2082;
        v21 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
    {
LABEL_18:
      interface = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v5);
    goto LABEL_18;
  }
  if (!v1[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_connection_multipath_get_primary_subflow_ifindex";
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_18;
  }
  interface = tcp_connection_get_interface(v1);
LABEL_19:

  return interface;
}

uint64_t tcp_connection_get_interface(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  void *v5;
  NWConcrete_nw_path *v6;
  uint64_t routed_interface_index;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v16;
  os_log_type_t v17;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "tcp_connection_get_interface";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v9, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "tcp_connection_get_interface";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v14 = type;
        v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "tcp_connection_get_interface";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v9)
            goto LABEL_34;
          goto LABEL_33;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "tcp_connection_get_interface";
          _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "tcp_connection_get_interface";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
    {
LABEL_34:
      routed_interface_index = 0;
      goto LABEL_35;
    }
LABEL_33:
    free(v9);
    goto LABEL_34;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "tcp_connection_get_interface";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_34;
  }
  v4 = nw_connection_copy_connected_path(v3);
  v5 = v4;
  if (v4)
  {
    v6 = (NWConcrete_nw_path *)v4;
    if (nw_path_network_is_satisfied_update_reason(v6, 0))
      routed_interface_index = v6->policy_result.routed_interface_index;
    else
      routed_interface_index = 0;

  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "tcp_connection_get_interface";
      _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_ERROR, "%{public}s No connected path", buf, 0xCu);
    }

    routed_interface_index = 0;
  }

LABEL_35:
  return routed_interface_index;
}

void sub_183672774(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id tcp_connection_multipath_copy_subflow_switch_counts(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  NSObject *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        v9 = "%{public}s called with null connection";
LABEL_22:
        v15 = v7;
        v16 = v8;
        goto LABEL_23;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        v9 = "%{public}s called with null connection, no backtrace";
        v15 = v7;
        v16 = v12;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_18:
      v4 = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v6);
    goto LABEL_18;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_connection_multipath_copy_subflow_switch_counts";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_18;
  }
  v4 = nw_connection_multipath_copy_subflow_counts(v3);
LABEL_19:

  return v4;
}

id tcp_connection_copy_tcp_info(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  NSObject *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v20 = "tcp_connection_copy_tcp_info";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_copy_tcp_info";
        v9 = "%{public}s called with null connection";
LABEL_22:
        v15 = v7;
        v16 = v8;
        goto LABEL_23;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_copy_tcp_info";
        v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v13)
        {
LABEL_24:

          if (!v6)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_copy_tcp_info";
        v9 = "%{public}s called with null connection, no backtrace";
        v15 = v7;
        v16 = v12;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v15, v16, v9, buf, 0xCu);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_connection_copy_tcp_info";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_18:
      v4 = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v6);
    goto LABEL_18;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_connection_copy_tcp_info";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_18;
  }
  v4 = nw_connection_copy_tcp_info(v3);
LABEL_19:

  return v4;
}

void tcp_connection_set_tls(void *a1, int a2, size_t *a3)
{
  void **v5;
  void **v6;
  const void *v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  void *v24;
  id v25;
  size_t *v26;
  id v27;
  size_t *v28;
  char v29;
  os_log_type_t type;
  _BYTE buf[24];
  void *v32;
  id v33;
  size_t *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (v5)
  {
    nw_parameters_set_tls(v5[6], a2);
    if (!a2)
      goto LABEL_48;
    if (!a3)
      goto LABEL_45;
    v7 = (const void *)a3[1];
    if (!v7 || !*a3)
      goto LABEL_44;
    a3 = (size_t *)xpc_data_create(v7, *a3);
    if (a3)
    {
LABEL_45:
      nw_parameters_set_tls_session_id(v6[6], a3);
      v24 = v6[2];
      if (v24)
      {
        v25 = v24;
        v26 = a3;
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __nw_connection_start_tls_block_invoke;
        v32 = &unk_1E14ACE68;
        v27 = v25;
        v33 = v27;
        v28 = v26;
        v34 = v28;
        nw_connection_async_if_needed(v27, buf);

      }
      goto LABEL_48;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v9, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s xpc_data_create failed", buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        v22 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s xpc_data_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
          _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s xpc_data_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
          _os_log_impl(&dword_182FBE000, v10, v23, "%{public}s xpc_data_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_42:
    if (v9)
      free(v9);
LABEL_44:
    a3 = 0;
    goto LABEL_45;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v29 = 0;
  if (!__nwlog_fault(v13, &type, &v29))
    goto LABEL_17;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    v15 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
      _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null connection", buf, 0xCu);
    }
LABEL_16:

LABEL_17:
    if (!v13)
      goto LABEL_48;
LABEL_18:
    free(v13);
    goto LABEL_48;
  }
  if (!v29)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    v19 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
      _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_16;
  }
  v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = (id)gLogObj;
  v17 = type;
  v18 = os_log_type_enabled(v14, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
      _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null connection, no backtrace", buf, 0xCu);
    }
    goto LABEL_16;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "tcp_connection_set_tls";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v16;
    _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v13)
    goto LABEL_18;
LABEL_48:

}

void sub_1836733E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void tcp_connection_set_tls_prepare()
{
  id v0;
  char *v1;
  NSObject *v2;
  os_log_type_t v3;
  const char *v4;
  char *backtrace_string;
  os_log_type_t v6;
  _BOOL4 v7;
  NSObject *v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v0 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v13 = "tcp_connection_set_tls_prepare";
  v1 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v1, &type, &v10))
    goto LABEL_10;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = (id)gLogObj;
    v3 = type;
    if (!os_log_type_enabled(v2, type))
      goto LABEL_17;
    *(_DWORD *)buf = 136446210;
    v13 = "tcp_connection_set_tls_prepare";
    v4 = "%{public}s tcp_connection_set_tls_prepare is deprecated";
LABEL_15:
    v8 = v2;
    v9 = v3;
LABEL_16:
    _os_log_impl(&dword_182FBE000, v8, v9, v4, buf, 0xCu);
    goto LABEL_17;
  }
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = (id)gLogObj;
    v3 = type;
    if (!os_log_type_enabled(v2, type))
      goto LABEL_17;
    *(_DWORD *)buf = 136446210;
    v13 = "tcp_connection_set_tls_prepare";
    v4 = "%{public}s tcp_connection_set_tls_prepare is deprecated, backtrace limit exceeded";
    goto LABEL_15;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  v6 = type;
  v7 = os_log_type_enabled(v2, type);
  if (backtrace_string)
  {
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      v13 = "tcp_connection_set_tls_prepare";
      v14 = 2082;
      v15 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v2, v6, "%{public}s tcp_connection_set_tls_prepare is deprecated, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_10:
    if (!v1)
      return;
    goto LABEL_11;
  }
  if (v7)
  {
    *(_DWORD *)buf = 136446210;
    v13 = "tcp_connection_set_tls_prepare";
    v4 = "%{public}s tcp_connection_set_tls_prepare is deprecated, no backtrace";
    v8 = v2;
    v9 = v6;
    goto LABEL_16;
  }
LABEL_17:

  if (v1)
LABEL_11:
    free(v1);
}

void tcp_connection_set_tls_handshake_message_handler()
{
  id v0;
  char *v1;
  NSObject *v2;
  os_log_type_t v3;
  const char *v4;
  char *backtrace_string;
  os_log_type_t v6;
  _BOOL4 v7;
  NSObject *v8;
  os_log_type_t v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v0 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v13 = "tcp_connection_set_tls_handshake_message_handler";
  v1 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (!__nwlog_fault(v1, &type, &v10))
    goto LABEL_10;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = (id)gLogObj;
    v3 = type;
    if (!os_log_type_enabled(v2, type))
      goto LABEL_17;
    *(_DWORD *)buf = 136446210;
    v13 = "tcp_connection_set_tls_handshake_message_handler";
    v4 = "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated";
LABEL_15:
    v8 = v2;
    v9 = v3;
LABEL_16:
    _os_log_impl(&dword_182FBE000, v8, v9, v4, buf, 0xCu);
    goto LABEL_17;
  }
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = (id)gLogObj;
    v3 = type;
    if (!os_log_type_enabled(v2, type))
      goto LABEL_17;
    *(_DWORD *)buf = 136446210;
    v13 = "tcp_connection_set_tls_handshake_message_handler";
    v4 = "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated, backtrace limit exceeded";
    goto LABEL_15;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  v6 = type;
  v7 = os_log_type_enabled(v2, type);
  if (backtrace_string)
  {
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      v13 = "tcp_connection_set_tls_handshake_message_handler";
      v14 = 2082;
      v15 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v2, v6, "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
LABEL_10:
    if (!v1)
      return;
    goto LABEL_11;
  }
  if (v7)
  {
    *(_DWORD *)buf = 136446210;
    v13 = "tcp_connection_set_tls_handshake_message_handler";
    v4 = "%{public}s tcp_connection_set_tls_handshake_message_handler is deprecated, no backtrace";
    v8 = v2;
    v9 = v6;
    goto LABEL_16;
  }
LABEL_17:

  if (v1)
LABEL_11:
    free(v1);
}

char *tcp_connection_create_with_service(const char *a1, const char *a2, const char *a3, void *a4)
{
  id v7;
  nw_endpoint_t bonjour_service;
  nw_endpoint_t v9;
  char *v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  void *v17;
  void *v18;
  void *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v7 = a4;
  nw_allow_use_of_dispatch_internal();
  if (!a1)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "tcp_connection_create_with_service";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_62;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "tcp_connection_create_with_service";
          v16 = "%{public}s called with null name, backtrace limit exceeded";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v21 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "tcp_connection_create_with_service";
          v16 = "%{public}s called with null name, no backtrace";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      if (!v21)
        goto LABEL_43;
      *(_DWORD *)buf = 136446466;
      v29 = "tcp_connection_create_with_service";
      v30 = 2082;
      v31 = backtrace_string;
      v22 = "%{public}s called with null name, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v29 = "tcp_connection_create_with_service";
    v16 = "%{public}s called with null name";
LABEL_60:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_61;
  }
  if (!a2)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "tcp_connection_create_with_service";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_62;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v29 = "tcp_connection_create_with_service";
          v16 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v23 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v29 = "tcp_connection_create_with_service";
          v16 = "%{public}s called with null type, no backtrace";
          goto LABEL_60;
        }
        goto LABEL_61;
      }
      if (!v23)
        goto LABEL_43;
      *(_DWORD *)buf = 136446466;
      v29 = "tcp_connection_create_with_service";
      v30 = 2082;
      v31 = backtrace_string;
      v22 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v29 = "tcp_connection_create_with_service";
    v16 = "%{public}s called with null type";
    goto LABEL_60;
  }
  if (!a3)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v29 = "tcp_connection_create_with_service";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v13, &type, &v26))
      goto LABEL_62;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v29 = "tcp_connection_create_with_service";
      v16 = "%{public}s called with null domain";
      goto LABEL_60;
    }
    if (!v26)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "tcp_connection_create_with_service";
        v16 = "%{public}s called with null domain, backtrace limit exceeded";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "tcp_connection_create_with_service";
        v16 = "%{public}s called with null domain, no backtrace";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    if (!v24)
      goto LABEL_43;
    *(_DWORD *)buf = 136446466;
    v29 = "tcp_connection_create_with_service";
    v30 = 2082;
    v31 = backtrace_string;
    v22 = "%{public}s called with null domain, dumping backtrace:%{public}s";
LABEL_42:
    _os_log_impl(&dword_182FBE000, v14, v15, v22, buf, 0x16u);
LABEL_43:

    free(backtrace_string);
    goto LABEL_62;
  }
  if (v7)
  {
    bonjour_service = nw_endpoint_create_bonjour_service(a1, a2, a3);
    v9 = bonjour_service;
    if (bonjour_service)
      v10 = tcp_connection_create_with_endpoint_and_parameters(bonjour_service, 0, v7);
    else
      v10 = 0;

    goto LABEL_9;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v29 = "tcp_connection_create_with_service";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v13, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "tcp_connection_create_with_service";
        v16 = "%{public}s called with null queue";
        goto LABEL_60;
      }
LABEL_61:

      goto LABEL_62;
    }
    if (!v26)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "tcp_connection_create_with_service";
        v16 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "tcp_connection_create_with_service";
        v16 = "%{public}s called with null queue, no backtrace";
        goto LABEL_60;
      }
      goto LABEL_61;
    }
    if (!v25)
      goto LABEL_43;
    *(_DWORD *)buf = 136446466;
    v29 = "tcp_connection_create_with_service";
    v30 = 2082;
    v31 = backtrace_string;
    v22 = "%{public}s called with null queue, dumping backtrace:%{public}s";
    goto LABEL_42;
  }
LABEL_62:
  if (v13)
    free(v13);
  v10 = 0;
LABEL_9:

  return v10;
}

void tcp_connection_set_event_handler_f(void *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  void *v6;
  void *v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v16;
  os_log_type_t v17;
  _QWORD aBlock[6];
  char v19;
  os_log_type_t v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "tcp_connection_set_event_handler_f";
    v9 = (char *)_os_log_send_and_compose_impl();

    v20 = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v9, &v20, &v19))
    {
      if (v20 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = v20;
        if (!os_log_type_enabled(v10, v20))
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_event_handler_f";
        v12 = "%{public}s called with null connection";
LABEL_17:
        v16 = v10;
        v17 = v11;
        goto LABEL_18;
      }
      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = v20;
        if (!os_log_type_enabled(v10, v20))
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_event_handler_f";
        v12 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v14 = v20;
      v15 = os_log_type_enabled(v10, v20);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_19:

          if (!v9)
            goto LABEL_14;
          goto LABEL_13;
        }
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_event_handler_f";
        v12 = "%{public}s called with null connection, no backtrace";
        v16 = v10;
        v17 = v14;
LABEL_18:
        _os_log_impl(&dword_182FBE000, v16, v17, v12, buf, 0xCu);
        goto LABEL_19;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "tcp_connection_set_event_handler_f";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v9)
      goto LABEL_14;
LABEL_13:
    free(v9);
    goto LABEL_14;
  }
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __tcp_connection_set_event_handler_f_block_invoke;
  aBlock[3] = &__block_descriptor_48_e13_v20__0I8r_v12l;
  aBlock[4] = a3;
  aBlock[5] = a2;
  v6 = _Block_copy(aBlock);
  v7 = (void *)v5[8];
  v5[8] = v6;

LABEL_14:
}

uint64_t __tcp_connection_set_event_handler_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

void tcp_connection_set_interface_by_index(void *a1, unsigned int a2)
{
  nw_parameters_t *v3;
  NWConcrete_nw_interface *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  char *v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  NSObject *v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  unsigned int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v20 = "tcp_connection_set_interface_by_index";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v6, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_25;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_set_interface_by_index";
        v9 = "%{public}s called with null connection";
LABEL_23:
        v15 = v7;
        v16 = v8;
        goto LABEL_24;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_25;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_set_interface_by_index";
        v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_23;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v13 = type;
      v14 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v14)
        {
LABEL_25:

          if (!v6)
            goto LABEL_20;
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_connection_set_interface_by_index";
        v9 = "%{public}s called with null connection, no backtrace";
        v15 = v7;
        v16 = v13;
LABEL_24:
        _os_log_impl(&dword_182FBE000, v15, v16, v9, buf, 0xCu);
        goto LABEL_25;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_connection_set_interface_by_index";
        v21 = 2082;
        v22 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
      goto LABEL_20;
LABEL_19:
    free(v6);
    goto LABEL_20;
  }
  v4 = nw_interface_create_with_index(a2);
  if (v4)
  {
    nw_parameters_require_interface(v3[6], &v4->super);
    if (!strcasecmp("awdl0", v4->name))
      nw_parameters_set_use_awdl(v3[6], 1);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = (char *)v3[12];
      *(_DWORD *)buf = 136446722;
      v20 = "tcp_connection_set_interface_by_index";
      v21 = 2048;
      v22 = v11;
      v23 = 1024;
      v24 = a2;
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s %llu could not set interface with index %d", buf, 0x1Cu);
    }

  }
LABEL_20:

}

BOOL tcp_connection_set_interface_by_name(void *a1, char *a2)
{
  nw_parameters_t *v3;
  NWConcrete_nw_interface *v4;
  _BOOL8 v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  char *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "tcp_connection_set_interface_by_name";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (!os_log_type_enabled(v8, type))
          goto LABEL_25;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_interface_by_name";
        v10 = "%{public}s called with null connection";
LABEL_23:
        v17 = v8;
        v18 = v9;
        goto LABEL_24;
      }
      if (!v19)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (!os_log_type_enabled(v8, type))
          goto LABEL_25;
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_interface_by_name";
        v10 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_23;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_25:

          if (!v7)
            goto LABEL_19;
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        v22 = "tcp_connection_set_interface_by_name";
        v10 = "%{public}s called with null connection, no backtrace";
        v17 = v8;
        v18 = v14;
LABEL_24:
        _os_log_impl(&dword_182FBE000, v17, v18, v10, buf, 0xCu);
        goto LABEL_25;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "tcp_connection_set_interface_by_name";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v7)
    {
LABEL_19:
      v5 = 0;
      goto LABEL_20;
    }
LABEL_18:
    free(v7);
    goto LABEL_19;
  }
  v4 = nw_interface_create_with_name(a2);
  v5 = v4 != 0;
  if (v4)
  {
    nw_parameters_require_interface(v3[6], &v4->super);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = (char *)v3[12];
      *(_DWORD *)buf = 136446722;
      v22 = "tcp_connection_set_interface_by_name";
      v23 = 2048;
      v24 = v12;
      v25 = 2082;
      v26 = a2;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s %llu could not set interface with name %{public}s", buf, 0x20u);
    }

  }
LABEL_20:

  return v5;
}

void tcp_connection_set_indefinite(uint64_t a1, int a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_indefinite(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_indefinite";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_indefinite";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_indefinite";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_indefinite";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_indefinite";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

uint64_t tcp_connection_set_context(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  uint64_t v6;
  void *v7;
  os_unfair_lock_s *v8;
  id v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  void *v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  NSObject *v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v24 = "tcp_connection_set_context";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v10, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v24 = "tcp_connection_set_context";
        v13 = "%{public}s called with null connection";
LABEL_22:
        v19 = v11;
        v20 = v12;
        goto LABEL_23;
      }
      if (!v21)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_24;
        *(_DWORD *)buf = 136446210;
        v24 = "tcp_connection_set_context";
        v13 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v17)
        {
LABEL_24:

          if (!v10)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v24 = "tcp_connection_set_context";
        v13 = "%{public}s called with null connection, no backtrace";
        v19 = v11;
        v20 = v16;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v19, v20, v13, buf, 0xCu);
        goto LABEL_24;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "tcp_connection_set_context";
        v25 = 2082;
        v26 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v10)
    {
LABEL_18:
      v6 = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v10);
    goto LABEL_18;
  }
  if (!v4)
  {
    os_unfair_lock_lock(v3 + 30);
    v14 = *(void **)&v3[2]._os_unfair_lock_opaque;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = 0;

    v8 = v3 + 30;
    goto LABEL_10;
  }
  v6 = (uint64_t)xpc_copy(v4);
  if (v6)
  {
    os_unfair_lock_lock(v3 + 30);
    v7 = *(void **)&v3[2]._os_unfair_lock_opaque;
    *(_QWORD *)&v3[2]._os_unfair_lock_opaque = v6;

    v8 = v3 + 30;
LABEL_10:
    os_unfair_lock_unlock(v8);
    v6 = 1;
  }
LABEL_19:

  return v6;
}

void tcp_connection_set_low_latency(uint64_t a1, char a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_reduce_buffering(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_low_latency";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_low_latency";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_low_latency";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_low_latency";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_low_latency";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

xpc_object_t tcp_connection_copy_context(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void *v3;
  xpc_object_t v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  NSObject *v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_connection_copy_context";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v6, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_copy_context";
        v9 = "%{public}s called with null connection";
LABEL_21:
        v14 = v7;
        v15 = v8;
        goto LABEL_22;
      }
      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_copy_context";
        v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v6)
            goto LABEL_17;
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "tcp_connection_copy_context";
        v9 = "%{public}s called with null connection, no backtrace";
        v14 = v7;
        v15 = v11;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v14, v15, v9, buf, 0xCu);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "tcp_connection_copy_context";
        v20 = 2082;
        v21 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v11, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_17:
      v4 = 0;
      goto LABEL_18;
    }
LABEL_16:
    free(v6);
    goto LABEL_17;
  }
  os_unfair_lock_lock(v1 + 30);
  v3 = *(void **)&v2[2]._os_unfair_lock_opaque;
  if (v3)
    v4 = xpc_copy(v3);
  else
    v4 = 0;
  os_unfair_lock_unlock(v2 + 30);
LABEL_18:

  return v4;
}

CFErrorRef nw_tcp_connection_copy_error(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  NSObject *v3;
  CFErrorRef v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  NSObject *v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_tcp_connection_copy_error";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v6, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_tcp_connection_copy_error";
        v9 = "%{public}s called with null connection";
LABEL_21:
        v14 = v7;
        v15 = v8;
        goto LABEL_22;
      }
      if (!v16)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_tcp_connection_copy_error";
        v9 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v6)
            goto LABEL_17;
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v19 = "nw_tcp_connection_copy_error";
        v9 = "%{public}s called with null connection, no backtrace";
        v14 = v7;
        v15 = v11;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v14, v15, v9, buf, 0xCu);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_tcp_connection_copy_error";
        v20 = 2082;
        v21 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v11, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v6)
    {
LABEL_17:
      v4 = 0;
      goto LABEL_18;
    }
LABEL_16:
    free(v6);
    goto LABEL_17;
  }
  os_unfair_lock_lock(v1 + 30);
  v3 = *(id *)&v2[6]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v2 + 30);
  if (v3)
    v4 = nw_error_copy_cf_error(v3);
  else
    v4 = 0;

LABEL_18:
  return v4;
}

uint64_t tcp_connection_copy_socket(void *a1)
{
  char *v1;
  void *v2;
  void *v3;
  NSObject *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  uint64_t v9;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_unfair_lock_s *v14;
  os_unfair_lock_s *v15;
  char *v16;
  int v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type[8];
  os_log_type_t *v21;
  uint64_t v22;
  int v23;
  _BYTE buf[24];
  void *v25;
  char *v26;
  os_log_type_t *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_connection_copy_socket";
    v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, type, &v19))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v8 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_copy_socket";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v12 = type[0];
        v13 = os_log_type_enabled(v7, type[0]);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_connection_copy_socket";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v6)
            goto LABEL_17;
          goto LABEL_13;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_copy_socket";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = (id)gLogObj;
        v18 = type[0];
        if (os_log_type_enabled(v7, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_copy_socket";
          _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v6)
      goto LABEL_17;
LABEL_13:
    free(v6);
    goto LABEL_17;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_connection_copy_socket";
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }
    goto LABEL_16;
  }
  if ((v1[158] & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_connection_copy_socket";
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s Cannot get socket on a connection for which client socket access is disallowed.", buf, 0xCu);
    }
LABEL_16:

    goto LABEL_17;
  }
  v14 = v3;
  *(_QWORD *)type = 0;
  v21 = type;
  v23 = -1;
  v22 = 0x2020000000;
  v15 = v14 + 34;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = __nw_connection_get_connected_socket_block_invoke;
  v25 = &unk_1E14ACE40;
  v16 = v14;
  v26 = v16;
  v27 = type;
  os_unfair_lock_lock(v15);
  __nw_connection_get_connected_socket_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v15);
  v17 = *((_DWORD *)v21 + 6);

  _Block_object_dispose(type, 8);
  if ((v17 & 0x80000000) == 0)
  {
    v9 = dup(v17);
    goto LABEL_18;
  }
LABEL_17:
  v9 = 0xFFFFFFFFLL;
LABEL_18:

  return v9;
}

BOOL tcp_connection_get_hostname(void *a1, _BYTE *a2, unint64_t a3)
{
  id *v5;
  id *v6;
  id v7;
  id v8;
  id v9;
  unint64_t v10;
  const char *v11;
  size_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  id v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  id v20;
  id v21;
  int v22;
  char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  NSObject *v27;
  void *v28;
  _BOOL8 result;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v33 = "tcp_connection_get_hostname";
    v17 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (__nwlog_fault(v17, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "tcp_connection_get_hostname";
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v24 = type;
        v25 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "tcp_connection_get_hostname";
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v17)
            goto LABEL_25;
          goto LABEL_24;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v33 = "tcp_connection_get_hostname";
          _os_log_impl(&dword_182FBE000, v18, v24, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        v26 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "tcp_connection_get_hostname";
          _os_log_impl(&dword_182FBE000, v18, v26, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v17)
    {
LABEL_25:
      v10 = 0;
LABEL_49:

      return v10;
    }
LABEL_24:
    free(v17);
    goto LABEL_25;
  }
  if (a2 && a3)
    *a2 = 0;
  v7 = v5[2];
  if (v7)
  {
    v8 = nw_connection_copy_host_endpoint(v7);
  }
  else
  {
    v20 = v6[5];
    if (!v20 || (v21 = v20, v22 = objc_msgSend(v21, "type"), v21, v22 != 2))
    {
      v9 = 0;
      v10 = 0;
LABEL_48:

      goto LABEL_49;
    }
    v8 = v6[5];
  }
  v9 = v8;
  v10 = 0;
  if (!a2 || !v8)
    goto LABEL_48;
  v9 = v8;
  v11 = (const char *)objc_msgSend(v9, "hostname");

  v12 = strlen(v11);
  if (v12 >= a3)
    v10 = a3;
  else
    v10 = v12;
  if (v11)
  {
    if (a3 >= 2)
      goto LABEL_14;
    goto LABEL_44;
  }
  __nwlog_obj();
  v27 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v33 = "_strict_strlcpy";
  v28 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    if (a3 >= 2)
    {
LABEL_14:
      v13 = 1;
      v14 = a3;
      while (1)
      {
        v15 = *(unsigned __int8 *)v11;
        *a2 = v15;
        if (!v15)
          goto LABEL_48;
        ++a2;
        ++v11;
        if (--v14 <= 1)
          goto LABEL_45;
      }
    }
LABEL_44:
    v13 = a3;
LABEL_45:
    if (a3)
    {
      if (v13)
        *a2 = 0;
    }
    goto LABEL_48;
  }
  __break(1u);
  return result;
}

void sub_1836762C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __tcp_connection_start_attempt_timer_locked_block_invoke(uint64_t a1)
{
  id v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  unsigned __int8 *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = *(id *)(a1 + 32);
  v14 = 0;
  v15 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)v1 + 30);
  v2 = *((_QWORD *)v1 + 6);
  if (!v2 || !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v2 + 104)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *((_QWORD *)v1 + 12);
      *(_DWORD *)buf = 136446466;
      v17 = "tcp_connection_attempt_timer_fired_on_client_queue";
      v18 = 2048;
      v19 = v4;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s %llu connection took too long to connect, cleaning up current attempt", buf, 0x16u);
    }

  }
  *((_DWORD *)v1 + 28) = 60;
  if ((*((_BYTE *)v1 + 158) & 0x40) != 0
    && tcp_connection_fillout_event_locked(v1, (uint64_t)&v14, 1073741832, 0, 0, (uint64_t)"connection attempt timed out"))
  {
    v5 = _Block_copy(*((const void **)v1 + 8));
    v6 = 1;
    v7 = *((_QWORD *)v1 + 2);
    if (!v7)
      goto LABEL_9;
LABEL_12:
    nw_connection_cancel(v7);
    goto LABEL_13;
  }
  v5 = 0;
  v6 = 0;
  v7 = *((_QWORD *)v1 + 2);
  if (v7)
    goto LABEL_12;
LABEL_9:
  v8 = *((_QWORD *)v1 + 10);
  if (v8)
  {
    dispatch_source_cancel(v8);
    v9 = (void *)*((_QWORD *)v1 + 10);
    *((_QWORD *)v1 + 10) = 0;

  }
LABEL_13:
  os_unfair_lock_unlock((os_unfair_lock_t)v1 + 30);
  if (v6)
  {
    v10 = (unsigned __int8 *)v1;
    v11 = v5;
    v12 = v11;
    if (!v11 || v10[156] == 255)
    {
      v13 = v14;
      if (!v14)
        goto LABEL_18;
    }
    else
    {
      v13 = v14;
      (*((void (**)(id, _QWORD, void *))v11 + 2))(v11, v15, v14);
      if (!v13)
      {
LABEL_18:

        goto LABEL_19;
      }
    }
    free(v13);
    goto LABEL_18;
  }
LABEL_19:

}

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke(uint64_t a1)
{
  tcp_connection_send_event_unlocked(*(void **)(a1 + 32), 2, 0, 0, (uint64_t)"read closed");
}

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_2(uint64_t a1)
{
  tcp_connection_send_event_unlocked(*(void **)(a1 + 32), 4, 0, 0, (uint64_t)"write closed");
}

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_3(uint64_t a1, int a2)
{
  char *v3;
  os_unfair_lock_s *v4;
  char v5;
  char v6;
  NSObject *v7;
  uint64_t v8;
  char *v9;
  void *v10;
  unsigned __int8 *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = (char *)*(id *)(a1 + 32);
  v15 = 0;
  v16 = 0;
  v4 = (os_unfair_lock_s *)(v3 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)v3 + 30);
  v5 = v3[158];
  if ((v5 & 0x20) != 0 || (a2 & 1) == 0)
  {
    if (a2)
      v6 = 0;
    else
      v6 = 32;
    v3[158] = v5 & 0xDF | v6;
    if (((((v5 & 0x20) == 0) ^ a2) & 1) == 0 && v3[156] != 255)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *((_QWORD *)v3 + 12);
        *(_DWORD *)buf = 136446466;
        v18 = "tcp_connection_send_viability_event_unlocked";
        v19 = 2048;
        v20 = v8;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %llu notifying of connection non-viability event again", buf, 0x16u);
      }

    }
    v9 = a2 ? "viable" : "no longer viable";
    if (tcp_connection_fillout_event_locked(v3, (uint64_t)&v15, 6, 0, 0, (uint64_t)v9))
    {
      v10 = _Block_copy(*((const void **)v3 + 8));
      os_unfair_lock_unlock(v4);
      v11 = v3;
      v12 = v10;
      v13 = v12;
      if (!v12 || v11[156] == 255)
      {
        v14 = v15;
        if (!v15)
        {
LABEL_22:

          goto LABEL_23;
        }
      }
      else
      {
        v14 = v15;
        (*((void (**)(id, _QWORD, void *))v12 + 2))(v12, v16, v15);
        if (!v14)
          goto LABEL_22;
      }
      free(v14);
      goto LABEL_22;
    }
  }
  os_unfair_lock_unlock(v4);
LABEL_23:

}

void __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_4(uint64_t a1, int a2)
{
  os_unfair_lock_s *v3;
  void *v4;
  char v5;
  void *v6;
  char v7;
  const char *v8;
  BOOL v9;
  _BOOL4 v10;
  _BOOL4 v11;
  unsigned __int8 *v12;
  id v13;
  void *v14;
  unsigned __int8 *v15;
  id v16;
  void *v17;
  char *v18;
  void *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;

  v18 = (char *)*(id *)(a1 + 32);
  v19 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  v3 = (os_unfair_lock_s *)(v18 + 120);
  os_unfair_lock_lock((os_unfair_lock_t)v18 + 30);
  v4 = v18;
  v5 = v18[158];
  if (((v5 & 0x10) == 0) != a2)
  {
    os_unfair_lock_unlock(v3);
    v6 = 0;
    goto LABEL_27;
  }
  if (a2)
    v7 = 16;
  else
    v7 = 0;
  v18[158] = v5 & 0xEF | v7;
  if (a2)
  {
    v8 = "better route";
    v9 = tcp_connection_fillout_event_locked(v18, (uint64_t)&v21, 5, 0, 0, (uint64_t)"better route");
    v4 = v18;
  }
  else
  {
    v9 = 0;
    v8 = "no better route";
  }
  v10 = tcp_connection_fillout_event_locked(v4, (uint64_t)&v19, 1073741831, 0, 0, (uint64_t)v8);
  v11 = v10;
  if (!v9 && !v10)
  {
    os_unfair_lock_unlock(v3);
    v6 = 0;
    goto LABEL_20;
  }
  v6 = _Block_copy(*((const void **)v18 + 8));
  os_unfair_lock_unlock(v3);
  if (!v9)
  {
LABEL_20:
    if (!v11)
      goto LABEL_27;
    goto LABEL_21;
  }
  v12 = v18;
  v13 = v6;
  v6 = v13;
  v14 = v21;
  if (v13 && v12[156] != 255)
    (*((void (**)(id, _QWORD, void *))v13 + 2))(v13, v22, v21);
  if (v14)
    free(v14);

  if (v11)
  {
LABEL_21:
    v15 = v18;
    v16 = v6;
    v6 = v16;
    v17 = v19;
    if (v16 && v15[156] != 255)
      (*((void (**)(id, _QWORD, void *))v16 + 2))(v16, v20, v19);
    if (v17)
      free(v17);

  }
LABEL_27:

}

void tcp_connection_cancel(void *a1)
{
  unsigned __int8 *v1;
  NSObject *v2;
  NSObject *v3;
  char *v4;
  const void *v5;
  void *v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  unsigned __int8 *v13;
  NSObject *v14;
  void *v15;
  void *v16;
  int v17;
  unsigned __int8 v18;
  void *v19;
  void *v20;
  void *v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  NSObject *v25;
  os_log_type_t v26;
  _QWORD block[4];
  id v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  v3 = v2;
  if (!v1)
  {
    *(_DWORD *)buf = 136446210;
    v32 = "tcp_connection_cancel";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (__nwlog_fault(v9, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (!os_log_type_enabled(v10, type))
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v32 = "tcp_connection_cancel";
        v12 = "%{public}s called with null connection";
LABEL_35:
        v25 = v10;
        v26 = v11;
        goto LABEL_36;
      }
      if (!v29)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (!os_log_type_enabled(v10, type))
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v32 = "tcp_connection_cancel";
        v12 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v23 = type;
      v24 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v24)
        {
LABEL_37:

          if (!v9)
            goto LABEL_32;
          goto LABEL_31;
        }
        *(_DWORD *)buf = 136446210;
        v32 = "tcp_connection_cancel";
        v12 = "%{public}s called with null connection, no backtrace";
        v25 = v10;
        v26 = v23;
LABEL_36:
        _os_log_impl(&dword_182FBE000, v25, v26, v12, buf, 0xCu);
        goto LABEL_37;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v32 = "tcp_connection_cancel";
        v33 = 2082;
        v34 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v23, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v9)
      goto LABEL_32;
LABEL_31:
    free(v9);
    goto LABEL_32;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v4 = (char *)*((_QWORD *)v1 + 12);
    *(_DWORD *)buf = 136446466;
    v32 = "tcp_connection_cancel";
    v33 = 2048;
    v34 = v4;
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %llu", buf, 0x16u);
  }

  os_unfair_lock_lock((os_unfair_lock_t)v1 + 30);
  if (v1[156] == 255)
    goto LABEL_24;
  v1[156] = -1;
  v5 = (const void *)*((_QWORD *)v1 + 9);
  if (v5 && *((_QWORD *)v1 + 7))
  {
    v6 = _Block_copy(v5);
    v7 = *((id *)v1 + 7);
    v8 = *((_QWORD *)v1 + 2);
    if (!v8)
      goto LABEL_15;
    goto LABEL_14;
  }
  v6 = 0;
  v7 = 0;
  v8 = *((_QWORD *)v1 + 2);
  if (v8)
LABEL_14:
    nw_connection_cancel(v8);
LABEL_15:
  v13 = v1;
  v13[158] |= 0x30u;
  v14 = *((_QWORD *)v13 + 10);
  if (v14)
  {
    dispatch_source_cancel(v14);
    v15 = (void *)*((_QWORD *)v13 + 10);
    *((_QWORD *)v13 + 10) = 0;

  }
  v16 = (void *)*((_QWORD *)v13 + 11);
  *((_QWORD *)v13 + 11) = 0;

  v17 = *((_DWORD *)v13 + 29);
  if (v17 != -1)
  {
    v18 = v13[159];
    if ((v18 & 8) == 0)
    {
      close(v17);
      v18 = v13[159];
    }
    *((_DWORD *)v13 + 29) = -1;
    v13[159] = v18 & 0xF7;
  }
  v19 = (void *)*((_QWORD *)v13 + 7);
  *((_QWORD *)v13 + 7) = 0;

  v20 = (void *)*((_QWORD *)v13 + 8);
  *((_QWORD *)v13 + 8) = 0;

  v21 = (void *)*((_QWORD *)v1 + 9);
  *((_QWORD *)v1 + 9) = 0;

  if (v6)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __tcp_connection_cancel_block_invoke;
    block[3] = &unk_1E14AC390;
    v28 = v6;
    dispatch_async(v7, block);

  }
LABEL_24:
  os_unfair_lock_unlock((os_unfair_lock_t)v1 + 30);
LABEL_32:

}

uint64_t __tcp_connection_cancel_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t tcp_connection_get_local(void *a1, _QWORD *a2)
{
  void **v3;
  void **v4;
  id v5;
  void *v6;
  NSObject *v7;
  int v8;
  const sockaddr *address;
  const sockaddr *v10;
  size_t sa_len;
  NSObject *v12;
  int v13;
  uint64_t v14;
  id v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  NSObject *v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  void *v25;
  os_log_type_t v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v34 = "tcp_connection_get_local";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v16, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "tcp_connection_get_local";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v21 = type;
      v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "tcp_connection_get_local";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v21, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v16)
          goto LABEL_35;
        goto LABEL_34;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "tcp_connection_get_local";
        _os_log_impl(&dword_182FBE000, v17, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v23 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "tcp_connection_get_local";
        _os_log_impl(&dword_182FBE000, v17, v23, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_32;
  }
  if (!v3[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "tcp_connection_get_local";
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_35;
  }
  if (!a2)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "tcp_connection_get_local";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v16, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "tcp_connection_get_local";
          _os_log_impl(&dword_182FBE000, v17, v26, "%{public}s called with null outlocal", buf, 0xCu);
        }
LABEL_32:

        goto LABEL_33;
      }
      if (!v31)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "tcp_connection_get_local";
          _os_log_impl(&dword_182FBE000, v17, v30, "%{public}s called with null outlocal, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_32;
      }
      v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      v29 = os_log_type_enabled(v17, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "tcp_connection_get_local";
          _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s called with null outlocal, no backtrace", buf, 0xCu);
        }
        goto LABEL_32;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        v34 = "tcp_connection_get_local";
        v35 = 2082;
        v36 = v27;
        _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s called with null outlocal, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v27);
    }
LABEL_33:
    if (!v16)
    {
LABEL_35:
      v14 = 0;
      goto LABEL_36;
    }
LABEL_34:
    free(v16);
    goto LABEL_35;
  }
  *a2 = 0;
  a2[1] = 0;
  *((_DWORD *)a2 + 6) = 0;
  a2[2] = 0;
  v5 = nw_connection_copy_connected_local_endpoint(v3[2]);
  v6 = v5;
  if (v5)
  {
    v7 = v5;
    v8 = -[NSObject type](v7, "type");

    if (v8 == 1)
    {
      address = nw_endpoint_get_address(v7);
      if (address)
      {
        v10 = address;
        sa_len = address->sa_len;
        if (sa_len < 0x1D)
        {
          memcpy(a2, address, sa_len);
          v14 = 1;
          goto LABEL_12;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          v13 = v10->sa_len;
          *(_DWORD *)buf = 136446466;
          v34 = "tcp_connection_get_local";
          v35 = 1024;
          LODWORD(v36) = v13;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Local address length (%u) too long", buf, 0x12u);
        }

      }
    }
  }
  v14 = 0;
LABEL_12:

LABEL_36:
  return v14;
}

void sub_1836773A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t tcp_connection_get_remote(void *a1, _QWORD *a2)
{
  void **v3;
  void **v4;
  id v5;
  void *v6;
  NSObject *v7;
  int v8;
  const sockaddr *address;
  const sockaddr *v10;
  size_t sa_len;
  NSObject *v12;
  int v13;
  uint64_t v14;
  id v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  NSObject *v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  void *v25;
  os_log_type_t v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v34 = "tcp_connection_get_remote";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v16, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v21 = type;
      v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "tcp_connection_get_remote";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v17, v21, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v16)
          goto LABEL_35;
        goto LABEL_34;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_182FBE000, v17, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      v23 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "tcp_connection_get_remote";
        _os_log_impl(&dword_182FBE000, v17, v23, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_32;
  }
  if (!v3[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v34 = "tcp_connection_get_remote";
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_35;
  }
  if (!a2)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "tcp_connection_get_remote";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v16, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_182FBE000, v17, v26, "%{public}s called with null outremote", buf, 0xCu);
        }
LABEL_32:

        goto LABEL_33;
      }
      if (!v31)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_182FBE000, v17, v30, "%{public}s called with null outremote, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_32;
      }
      v27 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v17 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      v29 = os_log_type_enabled(v17, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "tcp_connection_get_remote";
          _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s called with null outremote, no backtrace", buf, 0xCu);
        }
        goto LABEL_32;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        v34 = "tcp_connection_get_remote";
        v35 = 2082;
        v36 = v27;
        _os_log_impl(&dword_182FBE000, v17, v28, "%{public}s called with null outremote, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v27);
    }
LABEL_33:
    if (!v16)
    {
LABEL_35:
      v14 = 0;
      goto LABEL_36;
    }
LABEL_34:
    free(v16);
    goto LABEL_35;
  }
  *a2 = 0;
  a2[1] = 0;
  *((_DWORD *)a2 + 6) = 0;
  a2[2] = 0;
  v5 = nw_connection_copy_connected_remote_endpoint(v3[2]);
  v6 = v5;
  if (v5)
  {
    v7 = v5;
    v8 = -[NSObject type](v7, "type");

    if (v8 == 1)
    {
      address = nw_endpoint_get_address(v7);
      if (address)
      {
        v10 = address;
        sa_len = address->sa_len;
        if (sa_len < 0x1D)
        {
          memcpy(a2, address, sa_len);
          v14 = 1;
          goto LABEL_12;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          v13 = v10->sa_len;
          *(_DWORD *)buf = 136446466;
          v34 = "tcp_connection_get_remote";
          v35 = 1024;
          LODWORD(v36) = v13;
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Remote address length (%u) too long", buf, 0x12u);
        }

      }
    }
  }
  v14 = 0;
LABEL_12:

LABEL_36:
  return v14;
}

void sub_183677A14(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void tcp_connection_read(void *a1, unsigned int a2, unsigned int a3, void *a4)
{
  _QWORD *v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  NSObject *v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  void *v20;
  os_log_type_t v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  _QWORD v25[4];
  _QWORD *v26;
  id v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  v9 = v8;
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v31 = "tcp_connection_read";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v12, &type, &v28))
      goto LABEL_25;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null connection", buf, 0xCu);
      }
      goto LABEL_24;
    }
    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v19 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    v17 = type;
    v18 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl(&dword_182FBE000, v13, v17, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_24;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "tcp_connection_read";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v17, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_17;
  }
  v10 = (void *)v7[2];
  if (v10)
  {
    if (v8)
    {
      v25[0] = MEMORY[0x1E0C809B0];
      v25[1] = 3221225472;
      v25[2] = __tcp_connection_read_block_invoke;
      v25[3] = &unk_1E14A9C38;
      v26 = v7;
      v27 = v9;
      nw_connection_receive_internal(v10, 0, a2, a3, v25);

      goto LABEL_27;
    }
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "tcp_connection_read";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v12, &type, &v28))
      goto LABEL_25;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null handler", buf, 0xCu);
      }
LABEL_24:

LABEL_25:
      if (!v12)
        goto LABEL_27;
LABEL_26:
      free(v12);
      goto LABEL_27;
    }
    if (!v28)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v22 = type;
    v23 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "tcp_connection_read";
        _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_24;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "tcp_connection_read";
      v32 = 2082;
      v33 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_17:

    free(backtrace_string);
    if (!v12)
      goto LABEL_27;
    goto LABEL_26;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v15 = (id)gLogObj;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    v31 = "tcp_connection_read";
    _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
  }

LABEL_27:
}

void __tcp_connection_read_block_invoke(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8;
  id v9;
  void *v10;
  id v11;

  v11 = a2;
  v8 = a3;
  v9 = a5;
  v10 = v9;
  if (*(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 156) != 255)
  {
    if (v9)

    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }

}

void tcp_connection_read_buffer(void *a1, char *a2, unint64_t a3, unint64_t a4, void *a5)
{
  _QWORD *v9;
  id v10;
  void *v11;
  void *v12;
  id v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  NSObject *v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  NSObject *v22;
  os_log_type_t v23;
  void *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  _QWORD v30[4];
  _QWORD *v31;
  id v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a5;
  v11 = v10;
  if (!v9)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v36 = "tcp_connection_read_buffer";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = (id)gLogObj;
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v36 = "tcp_connection_read_buffer";
      v17 = "%{public}s called with null connection";
    }
    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = (id)gLogObj;
        v20 = type;
        v21 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            v36 = "tcp_connection_read_buffer";
            v37 = 2082;
            v38 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v14)
            goto LABEL_19;
LABEL_18:
          free(v14);
          goto LABEL_19;
        }
        if (!v21)
        {
LABEL_24:

          if (!v14)
            goto LABEL_19;
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        v36 = "tcp_connection_read_buffer";
        v17 = "%{public}s called with null connection, no backtrace";
        v22 = v15;
        v23 = v20;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v22, v23, v17, buf, 0xCu);
        goto LABEL_24;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = (id)gLogObj;
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v36 = "tcp_connection_read_buffer";
      v17 = "%{public}s called with null connection, backtrace limit exceeded";
    }
    v22 = v15;
    v23 = v16;
    goto LABEL_23;
  }
  v12 = (void *)v9[2];
  if (v12)
  {
    if (v10)
    {
      v30[0] = MEMORY[0x1E0C809B0];
      v30[1] = 3221225472;
      v30[2] = __tcp_connection_read_buffer_block_invoke;
      v30[3] = &unk_1E149FDA8;
      v31 = v9;
      v32 = v11;
      nw_connection_read_buffer(v12, a2, a3, a4, v30);

      goto LABEL_19;
    }
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v36 = "tcp_connection_read_buffer";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "tcp_connection_read_buffer";
        v27 = "%{public}s called with null handler";
LABEL_42:
        _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
        goto LABEL_43;
      }
      goto LABEL_43;
    }
    if (!v33)
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "tcp_connection_read_buffer";
        v27 = "%{public}s called with null handler, backtrace limit exceeded";
        goto LABEL_42;
      }
LABEL_43:

      goto LABEL_17;
    }
    v28 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v25 = objc_claimAutoreleasedReturnValue();
    v26 = type;
    v29 = os_log_type_enabled(v25, type);
    if (!v28)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "tcp_connection_read_buffer";
        v27 = "%{public}s called with null handler, no backtrace";
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "tcp_connection_read_buffer";
      v37 = 2082;
      v38 = v28;
      _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v28);
    if (v14)
      goto LABEL_18;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = (id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v36 = "tcp_connection_read_buffer";
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

  }
LABEL_19:

}

uint64_t __tcp_connection_read_buffer_block_invoke(uint64_t result)
{
  if (*(unsigned __int8 *)(*(_QWORD *)(result + 32) + 156) != 255)
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 40) + 16))();
  return result;
}

void tcp_connection_write(void *a1, void *a2, void *a3)
{
  _QWORD *v5;
  NSObject *v6;
  id v7;
  void *v8;
  NSObject *v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  NSObject *v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  NSObject *v19;
  os_log_type_t v20;
  void *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  _QWORD completion[4];
  _QWORD *v28;
  id v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v33 = "tcp_connection_write";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v11, &type, &v30))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v33 = "tcp_connection_write";
      v14 = "%{public}s called with null connection";
    }
    else
    {
      if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v33 = "tcp_connection_write";
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v11)
            goto LABEL_19;
LABEL_18:
          free(v11);
          goto LABEL_19;
        }
        if (!v18)
        {
LABEL_24:

          if (!v11)
            goto LABEL_19;
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        v33 = "tcp_connection_write";
        v14 = "%{public}s called with null connection, no backtrace";
        v19 = v12;
        v20 = v17;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v19, v20, v14, buf, 0xCu);
        goto LABEL_24;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v33 = "tcp_connection_write";
      v14 = "%{public}s called with null connection, backtrace limit exceeded";
    }
    v19 = v12;
    v20 = v13;
    goto LABEL_23;
  }
  v9 = v5[2];
  if (v9)
  {
    if (v7)
    {
      completion[0] = MEMORY[0x1E0C809B0];
      completion[1] = 3221225472;
      completion[2] = __tcp_connection_write_block_invoke;
      completion[3] = &unk_1E14A3020;
      v28 = v5;
      v29 = v8;
      nw_connection_send(v9, v6, (nw_content_context_t)&__block_literal_global_41718, 1, completion);

      goto LABEL_19;
    }
    __nwlog_obj();
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "tcp_connection_write";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v11, &type, &v30))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "tcp_connection_write";
        v24 = "%{public}s called with null handler";
LABEL_42:
        _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
        goto LABEL_43;
      }
      goto LABEL_43;
    }
    if (!v30)
    {
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "tcp_connection_write";
        v24 = "%{public}s called with null handler, backtrace limit exceeded";
        goto LABEL_42;
      }
LABEL_43:

      goto LABEL_17;
    }
    v25 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v26 = os_log_type_enabled(v22, type);
    if (!v25)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "tcp_connection_write";
        v24 = "%{public}s called with null handler, no backtrace";
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "tcp_connection_write";
      v34 = 2082;
      v35 = v25;
      _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v25);
    if (v11)
      goto LABEL_18;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = (id)gLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v33 = "tcp_connection_write";
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

  }
LABEL_19:

}

void __tcp_connection_write_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t v6;
  id v7;

  v3 = a2;
  if (*(unsigned __int8 *)(*(_QWORD *)(a1 + 32) + 156) != 255)
  {
    v4 = *(_QWORD *)(a1 + 40);
    v7 = v3;
    if (v3)
    {
      v5 = (unsigned int *)v3;
      v6 = v5[3];

    }
    else
    {
      v6 = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(v4 + 16))(v4, v6);
    v3 = v7;
  }

}

void tcp_connection_write_buffer(void *a1, const void *a2, size_t a3, void *a4)
{
  _QWORD *v7;
  id v8;
  void (**v9)(_QWORD, _QWORD);
  NSObject *v10;
  id v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  NSObject *v19;
  os_log_type_t v20;
  void *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a4;
  v9 = (void (**)(_QWORD, _QWORD))v8;
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v30 = "tcp_connection_write_buffer";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v12, &type, &v27))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v15 = "%{public}s called with null connection";
    }
    else
    {
      if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v30 = "tcp_connection_write_buffer";
            v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v17, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v12)
            goto LABEL_27;
          goto LABEL_26;
        }
        if (!v18)
          goto LABEL_25;
        *(_DWORD *)buf = 136446210;
        v30 = "tcp_connection_write_buffer";
        v15 = "%{public}s called with null connection, no backtrace";
        v19 = v13;
        v20 = v17;
        goto LABEL_24;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = (id)gLogObj;
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v15 = "%{public}s called with null connection, backtrace limit exceeded";
    }
    v19 = v13;
    v20 = v14;
LABEL_24:
    _os_log_impl(&dword_182FBE000, v19, v20, v15, buf, 0xCu);
LABEL_25:

    if (!v12)
      goto LABEL_27;
    goto LABEL_26;
  }
  if (!v7[2])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }
    goto LABEL_20;
  }
  if (v8)
  {
    v10 = dispatch_data_create(a2, a3, 0, 0);
    if (v10)
      tcp_connection_write(v7, v10, v9);
    else
      v9[2](v9, 12);
LABEL_20:

    goto LABEL_27;
  }
  __nwlog_obj();
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v30 = "tcp_connection_write_buffer";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v12, &type, &v27))
    goto LABEL_17;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    if (os_log_type_enabled(v22, type))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v24 = "%{public}s called with null handler";
LABEL_44:
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
      goto LABEL_45;
    }
    goto LABEL_45;
  }
  if (!v27)
  {
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    if (os_log_type_enabled(v22, type))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v24 = "%{public}s called with null handler, backtrace limit exceeded";
      goto LABEL_44;
    }
LABEL_45:

    goto LABEL_17;
  }
  v25 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v22 = objc_claimAutoreleasedReturnValue();
  v23 = type;
  v26 = os_log_type_enabled(v22, type);
  if (!v25)
  {
    if (v26)
    {
      *(_DWORD *)buf = 136446210;
      v30 = "tcp_connection_write_buffer";
      v24 = "%{public}s called with null handler, no backtrace";
      goto LABEL_44;
    }
    goto LABEL_45;
  }
  if (v26)
  {
    *(_DWORD *)buf = 136446466;
    v30 = "tcp_connection_write_buffer";
    v31 = 2082;
    v32 = v25;
    _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v25);
  if (v12)
LABEL_26:
    free(v12);
LABEL_27:

}

void tcp_connection_write_eof(void *a1)
{
  NSObject **v1;
  NSObject **v2;
  NSObject *v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  NSObject *v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_connection_write_eof";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_write_eof";
        v8 = "%{public}s called with null connection";
LABEL_21:
        v13 = v6;
        v14 = v7;
        goto LABEL_22;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_write_eof";
        v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v5)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_write_eof";
        v8 = "%{public}s called with null connection, no backtrace";
        v13 = v6;
        v14 = v11;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "tcp_connection_write_eof";
        v19 = 2082;
        v20 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
      goto LABEL_18;
LABEL_17:
    free(v5);
    goto LABEL_18;
  }
  v3 = v1[2];
  if (v3)
  {
    nw_connection_send(v3, 0, (nw_content_context_t)&__block_literal_global_3_41726, 1, &__block_literal_global_24144);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_connection_write_eof";
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

  }
LABEL_18:

}

uint64_t tcp_connection_get_unsent_length(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  char *v6;
  uint64_t v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v18;
  os_log_type_t type[8];
  os_log_type_t *v20;
  uint64_t v21;
  int v22;
  _BYTE buf[24];
  void *v24;
  char *v25;
  os_log_type_t *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_connection_get_unsent_length";
    v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v9, type, &v18))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_get_unsent_length";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v14 = type[0];
        v15 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_connection_get_unsent_length";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v9)
            goto LABEL_26;
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_get_unsent_length";
          _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v16 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_get_unsent_length";
          _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
    {
LABEL_26:
      v7 = 0;
      goto LABEL_27;
    }
LABEL_25:
    free(v9);
    goto LABEL_26;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_connection_get_unsent_length";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_26;
  }
  v4 = v3;
  *(_QWORD *)type = 0;
  v20 = type;
  v22 = 0;
  v21 = 0x2020000000;
  v5 = v4 + 34;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = __nw_connection_get_unsent_byte_count_block_invoke;
  v24 = &unk_1E14ACE40;
  v6 = v4;
  v25 = v6;
  v26 = type;
  os_unfair_lock_lock(v5);
  __nw_connection_get_unsent_byte_count_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v5);
  v7 = *((unsigned int *)v20 + 6);

  _Block_object_dispose(type, 8);
LABEL_27:

  return v7;
}

void tcp_connection_accept(void *a1, void *a2)
{
  _BYTE *v3;
  id v4;
  void *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *v21;
  _BOOL4 v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v26 = "tcp_connection_accept";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23))
      goto LABEL_17;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v26 = "tcp_connection_accept";
      v10 = "%{public}s called with null connection";
    }
    else
    {
      if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v13 = type;
        v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v26 = "tcp_connection_accept";
            v27 = 2082;
            v28 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_17:
          if (!v7)
            goto LABEL_19;
LABEL_18:
          free(v7);
          goto LABEL_19;
        }
        if (!v14)
        {
LABEL_24:

          if (!v7)
            goto LABEL_19;
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        v26 = "tcp_connection_accept";
        v10 = "%{public}s called with null connection, no backtrace";
        v15 = v8;
        v16 = v13;
LABEL_23:
        _os_log_impl(&dword_182FBE000, v15, v16, v10, buf, 0xCu);
        goto LABEL_24;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (id)gLogObj;
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_24;
      *(_DWORD *)buf = 136446210;
      v26 = "tcp_connection_accept";
      v10 = "%{public}s called with null connection, backtrace limit exceeded";
    }
    v15 = v8;
    v16 = v9;
    goto LABEL_23;
  }
  if (v4)
  {
    if (v3[157] == 4)
    {
      tcp_connection_set_queue(v3, v4);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "tcp_connection_accept";
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s Connection is not applicable for accept", buf, 0xCu);
      }

    }
    goto LABEL_19;
  }
  __nwlog_obj();
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "tcp_connection_accept";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v7, &type, &v23))
    goto LABEL_17;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "tcp_connection_accept";
      v20 = "%{public}s called with null queue";
LABEL_42:
      _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
      goto LABEL_43;
    }
    goto LABEL_43;
  }
  if (!v23)
  {
    __nwlog_obj();
    v18 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v18, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "tcp_connection_accept";
      v20 = "%{public}s called with null queue, backtrace limit exceeded";
      goto LABEL_42;
    }
LABEL_43:

    goto LABEL_17;
  }
  v21 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v18 = objc_claimAutoreleasedReturnValue();
  v19 = type;
  v22 = os_log_type_enabled(v18, type);
  if (!v21)
  {
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "tcp_connection_accept";
      v20 = "%{public}s called with null queue, no backtrace";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "tcp_connection_accept";
    v27 = 2082;
    v28 = v21;
    _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v21);
  if (v7)
    goto LABEL_18;
LABEL_19:

}

BOOL tcp_connection_is_expensive(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  NSObject *v4;
  NSObject *v5;
  _BOOL8 is_expensive;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v16;
  NSObject *v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v23 = "tcp_connection_is_expensive";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_29;
        *(_DWORD *)buf = 136446210;
        v23 = "tcp_connection_is_expensive";
        v11 = "%{public}s called with null connection";
LABEL_27:
        v18 = v9;
        v19 = v10;
        goto LABEL_28;
      }
      if (!v20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_29;
        *(_DWORD *)buf = 136446210;
        v23 = "tcp_connection_is_expensive";
        v11 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_27;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_29:

          if (!v8)
            goto LABEL_19;
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        v23 = "tcp_connection_is_expensive";
        v11 = "%{public}s called with null connection, no backtrace";
        v18 = v9;
        v19 = v14;
LABEL_28:
        _os_log_impl(&dword_182FBE000, v18, v19, v11, buf, 0xCu);
        goto LABEL_29;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "tcp_connection_is_expensive";
        v24 = 2082;
        v25 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v8)
    {
LABEL_19:
      is_expensive = 0;
      goto LABEL_24;
    }
LABEL_18:
    free(v8);
    goto LABEL_19;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (v3)
  {
    v4 = nw_connection_copy_connected_path(v3);
    v5 = v4;
    if (v4)
    {
      is_expensive = nw_path_is_expensive(v4);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "tcp_connection_is_expensive";
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_ERROR, "%{public}s No connected path", buf, 0xCu);
      }

      is_expensive = 0;
    }

  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "tcp_connection_is_expensive";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    is_expensive = 0;
  }
LABEL_24:

  return is_expensive;
}

char *tcp_connection_copy_description(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  char *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  NSObject *v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_connection_copy_description";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "tcp_connection_copy_description";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v12 = type;
        v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "tcp_connection_copy_description";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v7)
            goto LABEL_26;
          goto LABEL_25;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "tcp_connection_copy_description";
          _os_log_impl(&dword_182FBE000, v8, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "tcp_connection_copy_description";
          _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v7)
    {
LABEL_26:
      v5 = 0;
      goto LABEL_27;
    }
LABEL_25:
    free(v7);
    goto LABEL_26;
  }
  v3 = (void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_connection_copy_description";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

    goto LABEL_26;
  }
  v4 = v3;
  v5 = nw_connection_copy_description_level(v4, 1);

LABEL_27:
  return v5;
}

void sub_18367A5C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void tcp_connection_get_counts(void *a1, uint64_t a2)
{
  void **v3;
  void **v4;
  id v5;
  void *v6;
  _QWORD *v7;
  id v8;
  void *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _QWORD applier[6];
  char v27;
  os_log_type_t v28;
  os_log_type_t type[8];
  os_log_type_t *v30;
  uint64_t v31;
  char v32;
  uint8_t v33[4];
  const char *v34;
  __int16 v35;
  char *v36;
  _BYTE buf[24];
  void *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_connection_get_counts";
    v9 = (void *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v33[0] = 0;
    if (__nwlog_fault((const char *)v9, type, v33))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_get_counts";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v33[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v14 = type[0];
        v15 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "tcp_connection_get_counts";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v9)
            goto LABEL_28;
LABEL_13:
          free(v9);
          goto LABEL_28;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_get_counts";
          _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v17 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_connection_get_counts";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
      goto LABEL_28;
    goto LABEL_13;
  }
  if (v3[2])
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x1B810000000;
    v39 = 0u;
    v40 = 0u;
    v41 = 0u;
    v42 = 0u;
    v43 = 0u;
    v44 = 0u;
    v45 = 0u;
    v46 = 0u;
    v47 = 0u;
    v48 = 0u;
    v49 = 0u;
    v50 = 0u;
    v51 = 0u;
    v52 = 0u;
    v53 = 0u;
    v54 = 0u;
    v55 = 0u;
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    v59 = 0u;
    v60 = 0u;
    v61 = 0u;
    v62 = 0u;
    v63 = 0u;
    v38 = &unk_183EA1965;
    v64 = 0;
    *(_QWORD *)type = 0;
    v30 = type;
    v31 = 0x2020000000;
    v32 = 0;
    if (a2)
    {
      *(_OWORD *)(a2 + 80) = 0uLL;
      *(_OWORD *)(a2 + 96) = 0uLL;
      *(_OWORD *)(a2 + 48) = 0uLL;
      *(_OWORD *)(a2 + 64) = 0uLL;
      *(_OWORD *)(a2 + 16) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      v5 = nw_connection_copy_tcp_info(v3[2]);
      v6 = v5;
      if (v5)
      {
        applier[0] = MEMORY[0x1E0C809B0];
        applier[1] = 3221225472;
        applier[2] = __tcp_connection_get_counts_block_invoke;
        applier[3] = &unk_1E149FDD0;
        applier[4] = buf;
        applier[5] = type;
        xpc_dictionary_apply(v5, applier);
        if (*((_BYTE *)v30 + 24))
        {
          v7 = *(_QWORD **)&buf[8];
          *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)&buf[8] + 140);
          *(_QWORD *)(a2 + 24) = *(_QWORD *)((char *)v7 + 108);
          *(_DWORD *)(a2 + 80) = *(_QWORD *)((char *)v7 + 148);
          *(_DWORD *)(a2 + 88) = *(_QWORD *)((char *)v7 + 116);
          *(_QWORD *)(a2 + 92) = 0x100000001;
          *(_QWORD *)(a2 + 104) = v7[7];
          *(_QWORD *)(a2 + 48) = v7[27];
          *(_QWORD *)(a2 + 56) = v7[29];
          *(_QWORD *)(a2 + 32) = v7[23];
          *(_QWORD *)(a2 + 40) = v7[25];
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v33 = 136446210;
          v34 = "tcp_connection_get_counts";
          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_ERROR, "%{public}s Could not retreive TCP info", v33, 0xCu);
        }

      }
LABEL_27:
      _Block_object_dispose(type, 8);
      _Block_object_dispose(buf, 8);
      goto LABEL_28;
    }
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v33 = 136446210;
    v34 = "tcp_connection_get_counts";
    v19 = (char *)_os_log_send_and_compose_impl();

    v28 = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v19, &v28, &v27))
    {
      if (v28 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v21 = v28;
        if (os_log_type_enabled(v20, v28))
        {
          *(_DWORD *)v33 = 136446210;
          v34 = "tcp_connection_get_counts";
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null counts", v33, 0xCu);
        }
      }
      else if (v27)
      {
        v22 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v23 = v28;
        v24 = os_log_type_enabled(v20, v28);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)v33 = 136446466;
            v34 = "tcp_connection_get_counts";
            v35 = 2082;
            v36 = v22;
            _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null counts, dumping backtrace:%{public}s", v33, 0x16u);
          }

          free(v22);
          goto LABEL_51;
        }
        if (v24)
        {
          *(_DWORD *)v33 = 136446210;
          v34 = "tcp_connection_get_counts";
          _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null counts, no backtrace", v33, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v25 = v28;
        if (os_log_type_enabled(v20, v28))
        {
          *(_DWORD *)v33 = 136446210;
          v34 = "tcp_connection_get_counts";
          _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null counts, backtrace limit exceeded", v33, 0xCu);
        }
      }

    }
LABEL_51:
    if (v19)
      free(v19);
    goto LABEL_27;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = (id)gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_connection_get_counts";
    _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
  }

LABEL_28:
}

void sub_18367AD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t __tcp_connection_get_counts_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  void *v5;
  const void *bytes_ptr;
  NSObject *v7;
  int v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1E0C812E8] && xpc_data_get_length(v4) == 408 && xpc_data_get_bytes_ptr(v4))
  {
    v5 = (void *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 32);
    bytes_ptr = xpc_data_get_bytes_ptr(v4);
    memcpy(v5, bytes_ptr, 0x198uLL);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v9 = 136446210;
      v10 = "tcp_connection_get_counts_block_invoke";
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s TCP info has invalid data", (uint8_t *)&v9, 0xCu);
    }

  }
  return 0;
}

void tcp_connection_retry(void *a1)
{
  NSObject **v1;
  NSObject **v2;
  NSObject *v3;
  id v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  NSObject *v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_connection_retry";
    v5 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_retry";
        v8 = "%{public}s called with null connection";
LABEL_21:
        v13 = v6;
        v14 = v7;
        goto LABEL_22;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_retry";
        v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v11 = type;
      v12 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v12)
        {
LABEL_23:

          if (!v5)
            goto LABEL_18;
          goto LABEL_17;
        }
        *(_DWORD *)buf = 136446210;
        v18 = "tcp_connection_retry";
        v8 = "%{public}s called with null connection, no backtrace";
        v13 = v6;
        v14 = v11;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v13, v14, v8, buf, 0xCu);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "tcp_connection_retry";
        v19 = 2082;
        v20 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
      goto LABEL_18;
LABEL_17:
    free(v5);
    goto LABEL_18;
  }
  v3 = v1[2];
  if (v3)
  {
    nw_connection_restart(v3);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_connection_retry";
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

  }
LABEL_18:

}

void tcp_connection_set_connection_attempt_timeout(uint64_t a1, uint64_t a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)(a1 + 104) = a2;
    *(_BYTE *)(a1 + 158) |= 0x40u;
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_connection_attempt_timeout";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_connection_attempt_timeout";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_connection_attempt_timeout";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_connection_attempt_timeout";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_connection_attempt_timeout";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

void tcp_connection_set_tfo(uint64_t a1, _BOOL4 a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_tfo(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_tfo";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_tfo";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_tfo";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_tfo";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_tfo";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

void tcp_connection_set_extended_background_idle(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  void *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  NSObject *v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  v3 = v2;
  if (!a1)
  {
    *(_DWORD *)buf = 136446210;
    v16 = "tcp_connection_set_extended_background_idle";
    v4 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_21;
        *(_DWORD *)buf = 136446210;
        v16 = "tcp_connection_set_extended_background_idle";
        v7 = "%{public}s called with null connection";
LABEL_19:
        v11 = v5;
        v12 = v6;
        goto LABEL_20;
      }
      if (!v13)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_21;
        *(_DWORD *)buf = 136446210;
        v16 = "tcp_connection_set_extended_background_idle";
        v7 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_19;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v9 = type;
      v10 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (!v10)
        {
LABEL_21:

          if (!v4)
            return;
LABEL_15:
          free(v4);
          return;
        }
        *(_DWORD *)buf = 136446210;
        v16 = "tcp_connection_set_extended_background_idle";
        v7 = "%{public}s called with null connection, no backtrace";
        v11 = v5;
        v12 = v9;
LABEL_20:
        _os_log_impl(&dword_182FBE000, v11, v12, v7, buf, 0xCu);
        goto LABEL_21;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v16 = "tcp_connection_set_extended_background_idle";
        v17 = 2082;
        v18 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v9, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v4)
      return;
    goto LABEL_15;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    v16 = "tcp_connection_set_extended_background_idle";
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s Extended background idle not supported", buf, 0xCu);
  }

}

void tcp_connection_set_receive_any_interface(uint64_t a1, int a2)
{
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  NSObject *v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    nw_parameters_set_receive_any_interface(*(void **)(a1 + 48), a2);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_connection_set_receive_any_interface";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12))
  {
LABEL_12:
    if (!v3)
      return;
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_receive_any_interface";
    v6 = "%{public}s called with null connection";
LABEL_17:
    v10 = v4;
    v11 = v5;
LABEL_18:
    _os_log_impl(&dword_182FBE000, v10, v11, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (!v12)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_19;
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_receive_any_interface";
    v6 = "%{public}s called with null connection, backtrace limit exceeded";
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v4 = (id)gLogObj;
  v8 = type;
  v9 = os_log_type_enabled(v4, type);
  if (backtrace_string)
  {
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "tcp_connection_set_receive_any_interface";
      v16 = 2082;
      v17 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v4, v8, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446210;
    v15 = "tcp_connection_set_receive_any_interface";
    v6 = "%{public}s called with null connection, no backtrace";
    v10 = v4;
    v11 = v8;
    goto LABEL_18;
  }
LABEL_19:

  if (v3)
LABEL_13:
    free(v3);
}

void tcp_connection_set_ecn_enabled(uint64_t a1, int a2)
{
  void *v2;
  unsigned int v3;
  id v4;
  void *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  NSObject *v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v17 = "tcp_connection_set_ecn_enabled";
    v5 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault((const char *)v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_22;
        *(_DWORD *)buf = 136446210;
        v17 = "tcp_connection_set_ecn_enabled";
        v8 = "%{public}s called with null connection";
LABEL_20:
        v12 = v6;
        v13 = v7;
        goto LABEL_21;
      }
      if (!v14)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = (id)gLogObj;
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_22;
        *(_DWORD *)buf = 136446210;
        v17 = "tcp_connection_set_ecn_enabled";
        v8 = "%{public}s called with null connection, backtrace limit exceeded";
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = (id)gLogObj;
      v10 = type;
      v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_22:

          if (!v5)
            return;
LABEL_16:
          free(v5);
          return;
        }
        *(_DWORD *)buf = 136446210;
        v17 = "tcp_connection_set_ecn_enabled";
        v8 = "%{public}s called with null connection, no backtrace";
        v12 = v6;
        v13 = v10;
LABEL_21:
        _os_log_impl(&dword_182FBE000, v12, v13, v8, buf, 0xCu);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v17 = "tcp_connection_set_ecn_enabled";
        v18 = 2082;
        v19 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v6, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
      return;
    goto LABEL_16;
  }
  v2 = *(void **)(a1 + 48);
  if (a2)
    v3 = 1;
  else
    v3 = 2;
  nw_parameters_set_ecn_mode(v2, v3);
}

void tcp_connection_log_event(void *a1, char *a2, void *a3)
{
  _QWORD *v5;
  id v6;
  void *v7;
  int v8;
  id v9;
  void *v10;
  NSObject *v11;
  os_log_type_t v12;
  NSObject *v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  NSObject *v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v22 = "tcp_connection_log_event";
    v10 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault((const char *)v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "tcp_connection_log_event";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v15 = type;
        v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "tcp_connection_log_event";
            v23 = 2082;
            v24 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v10)
            goto LABEL_27;
LABEL_12:
          free(v10);
          goto LABEL_27;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "tcp_connection_log_event";
          _os_log_impl(&dword_182FBE000, v11, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = (id)gLogObj;
        v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "tcp_connection_log_event";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v10)
      goto LABEL_27;
    goto LABEL_12;
  }
  v7 = (void *)v5[2];
  if (v7)
  {
    if (a2 == (char *)1)
    {
      v8 = 2;
      goto LABEL_23;
    }
    if (!a2)
    {
      v8 = 1;
LABEL_23:
      nw_connection_add_client_event_internal(v7, v8, v6, 0);
      goto LABEL_27;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v22 = "tcp_connection_log_event";
      v23 = 2048;
      v24 = a2;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_ERROR, "%{public}s Invalid log event %lld", buf, 0x16u);
    }

  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = (id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "tcp_connection_log_event";
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s API Misuse: Function must be called after tcp_connection_start", buf, 0xCu);
    }

  }
LABEL_27:

}

void __nw_write_request_create_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
  (*(void (**)(uint64_t))(v1 + 16))(v1);

}

void sub_18367E37C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_32786()
{
  _BOOL8 result;

  result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

NWConcrete_nw_write_request *nw_write_request_create_idempotent(void *a1, void *a2, void *a3, int a4)
{
  id v7;
  id v8;
  os_unfair_lock_s *v9;
  os_unfair_lock_s *v10;
  char v11;
  NSObject *v12;
  NWConcrete_nw_write_request *v13;
  NWConcrete_nw_write_request *v14;
  void *v15;
  dispatch_data_t *p_data;
  double *v17;
  double *v18;
  double v19;
  char v20;
  double *v21;
  NWConcrete_nw_write_request *v22;
  id v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *v27;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  void *v36;
  os_log_type_t v37;
  char *backtrace_string;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  os_log_type_t v44;
  NSObject *context;
  id v46;
  void *v47;
  id v48;
  char v49;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v52;
  __int16 v53;
  char *v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v47 = v8;
  v48 = a3;
  if (!v8)
  {
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v52 = "nw_write_request_create_idempotent";
    v33 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v33, &type, &v49))
      goto LABEL_101;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null context", buf, 0xCu);
      }
      goto LABEL_100;
    }
    if (!v49)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_182FBE000, v34, v44, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_100;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    v41 = type;
    v42 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_182FBE000, v34, v41, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
      goto LABEL_100;
    }
    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      v52 = "nw_write_request_create_idempotent";
      v53 = 2082;
      v54 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v34, v41, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_82;
  }
  if (!v7
    && (a4 & 1) == 0
    && (v8 == &__block_literal_global_3_41726
     || v8 == &__block_literal_global_41718
     || v8 == &__block_literal_global_4
     || v8 == &__block_literal_global_5_41741))
  {
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v52 = "nw_write_request_create_idempotent";
    v33 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (!__nwlog_fault(v33, &type, &v49))
      goto LABEL_101;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s Send content may only be nil if the request is marked as complete", buf, 0xCu);
      }
LABEL_100:

LABEL_101:
      if (v33)
        free(v33);
      goto LABEL_17;
    }
    if (!v49)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_182FBE000, v34, v43, "%{public}s Send content may only be nil if the request is marked as complete, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_100;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v34 = objc_claimAutoreleasedReturnValue();
    v39 = type;
    v40 = os_log_type_enabled(v34, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        v52 = "nw_write_request_create_idempotent";
        _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s Send content may only be nil if the request is marked as complete, no backtrace", buf, 0xCu);
      }
      goto LABEL_100;
    }
    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      v52 = "nw_write_request_create_idempotent";
      v53 = 2082;
      v54 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s Send content may only be nil if the request is marked as complete, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_82:

    free(backtrace_string);
    goto LABEL_101;
  }
  v46 = v7;
  if (!v48)
    goto LABEL_19;
  v9 = (os_unfair_lock_s *)v48;
  if (v9 == (os_unfair_lock_s *)&__block_literal_global_5_41741)
  {

    goto LABEL_19;
  }
  v10 = v9;
  if (v9 == (os_unfair_lock_s *)&__block_literal_global_4
    || v9 == (os_unfair_lock_s *)&__block_literal_global_3_41726
    || v9 == (os_unfair_lock_s *)&__block_literal_global_41718)
  {

    goto LABEL_14;
  }
  os_unfair_lock_lock(v9 + 28);
  v11 = BYTE2(v10[29]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v10 + 28);

  if ((v11 & 0x40) != 0)
  {
LABEL_19:
    v14 = objc_alloc_init(NWConcrete_nw_write_request);
    v13 = v14;
    v7 = v46;
    if (v14)
    {
      if (v46)
        v15 = v46;
      else
        v15 = (void *)MEMORY[0x1E0C80D00];
      p_data = (dispatch_data_t *)&v14->data;
      objc_storeStrong((id *)&v14->data, v15);
      objc_storeStrong((id *)&v13->context, a2);
      objc_storeStrong((id *)&v13->original_message, a3);
      *((_BYTE *)v13 + 128) = *((_BYTE *)v13 + 128) & 0xFE | a4 | 4;
      v17 = v47;
      v18 = v17;
      v19 = 0.5;
      if (v17 != (double *)&__block_literal_global_5_41741
        && v17 != (double *)&__block_literal_global_4
        && v17 != (double *)&__block_literal_global_3_41726
        && v17 != (double *)&__block_literal_global_41718
        && (*((_BYTE *)v17 + 118) & 1) == 0)
      {
        v19 = v17[10];
      }

      v20 = 0;
      v13->relative_priority = v19;
      if (!v46 && a4)
      {
        v21 = v18;
        v20 = 0;
        if (v18 != (double *)&__block_literal_global_41718 && v18 != (double *)&__block_literal_global_5_41741)
        {
          v20 = 8;
          if (v18 != (double *)&__block_literal_global_3_41726 && v18 != (double *)&__block_literal_global_4)
            v20 = 8 * (*((_BYTE *)v21 + 118) & 1);
        }

      }
      *((_BYTE *)v13 + 128) = *((_BYTE *)v13 + 128) & 0xF7 | v20;
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_32785);
      if (_nw_signposts_enabled && kdebug_is_enabled())
      {
        if (*p_data)
          dispatch_data_get_size(*p_data);
        context = v13->context;
        if (context)
          nw_content_context_get_is_final(context);
        kdebug_trace();
      }
      v22 = v13;
      goto LABEL_61;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v52 = "nw_write_request_create_idempotent";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v49 = 0;
    if (__nwlog_fault(v24, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "nw_write_request_create_idempotent";
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v49)
      {
        v27 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v28 = type;
        v29 = os_log_type_enabled(v25, type);
        if (v27)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v52 = "nw_write_request_create_idempotent";
            v53 = 2082;
            v54 = v27;
            _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v27);
          if (!v24)
            goto LABEL_61;
          goto LABEL_60;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v52 = "nw_write_request_create_idempotent";
          _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v52 = "nw_write_request_create_idempotent";
          _os_log_impl(&dword_182FBE000, v25, v30, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v24)
    {
LABEL_61:

      goto LABEL_62;
    }
LABEL_60:
    free(v24);
    goto LABEL_61;
  }
LABEL_14:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v12 = (id)gLogObj;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    v52 = "nw_write_request_create_idempotent";
    _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Cannot send a reply for a protocol that does not support replies", buf, 0xCu);
  }

  v7 = v46;
LABEL_17:
  v13 = 0;
LABEL_62:

  return v13;
}

void sub_18367EDA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

NWConcrete_nw_write_request *nw_write_request_create_clone(void *a1)
{
  id *v1;
  id v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  NWConcrete_nw_write_request *v6;
  NWConcrete_nw_write_request *v7;
  dispatch_data_t *p_data;
  char v9;
  NWConcrete_nw_write_request *v10;
  char *v11;
  os_log_type_t v12;
  _BOOL4 v13;
  id v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  NSObject *context;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (((_BYTE)v1[16] & 4) != 0)
  {
    v6 = objc_alloc_init(NWConcrete_nw_write_request);
    v7 = v6;
    if (v6)
    {
      p_data = (dispatch_data_t *)&v6->data;
      objc_storeStrong((id *)&v6->data, v1[7]);
      objc_storeStrong((id *)&v7->context, v1[8]);
      v9 = (_BYTE)v1[16] & 1 | *((_BYTE *)v7 + 128) & 0xFE | 4;
      *((_BYTE *)v7 + 128) = v9;
      *(_QWORD *)&v7->relative_priority = v1[15];
      *((_BYTE *)v7 + 128) = (_BYTE)v1[16] & 8 | v9 & 0xF7;
      if (_nw_signposts_once != -1)
        dispatch_once(&_nw_signposts_once, &__block_literal_global_32785);
      if (_nw_signposts_enabled && kdebug_is_enabled())
      {
        if (*p_data)
          dispatch_data_get_size(*p_data);
        context = v7->context;
        if (context)
          nw_content_context_get_is_final(context);
        kdebug_trace();
      }
      v10 = v7;
      goto LABEL_47;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v28 = "nw_write_request_create_clone";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v15, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_write_request_create_clone";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        v20 = type;
        v21 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            v28 = "nw_write_request_create_clone";
            v29 = 2082;
            v30 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v16, v20, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v15)
            goto LABEL_47;
          goto LABEL_46;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_write_request_create_clone";
          _os_log_impl(&dword_182FBE000, v16, v20, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v16 = (id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_write_request_create_clone";
          _os_log_impl(&dword_182FBE000, v16, v22, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_write_request) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v15)
    {
LABEL_47:

      goto LABEL_48;
    }
LABEL_46:
    free(v15);
    goto LABEL_47;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v28 = "nw_write_request_create_clone";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v3, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_write_request_create_clone";
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s Only idempotent write requests may be cloned", buf, 0xCu);
      }
    }
    else if (v25)
    {
      v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v4, type);
      if (v11)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_write_request_create_clone";
          v29 = 2082;
          v30 = v11;
          _os_log_impl(&dword_182FBE000, v4, v12, "%{public}s Only idempotent write requests may be cloned, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v11);
        if (!v3)
          goto LABEL_38;
        goto LABEL_37;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_write_request_create_clone";
        _os_log_impl(&dword_182FBE000, v4, v12, "%{public}s Only idempotent write requests may be cloned, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      v18 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_write_request_create_clone";
        _os_log_impl(&dword_182FBE000, v4, v18, "%{public}s Only idempotent write requests may be cloned, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
  if (v3)
LABEL_37:
    free(v3);
LABEL_38:
  v7 = 0;
LABEL_48:

  return v7;
}

void sub_18367F43C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void __nw_write_request_create_with_file_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
  (*(void (**)(uint64_t, _QWORD, _QWORD))(v1 + 16))(v1, 0, 0);

}

void sub_18367F4B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

size_t nw_write_request_remaining_bytes(void *a1)
{
  _QWORD *v1;
  NSObject *v2;
  uint64_t v3;
  size_t size;
  size_t v5;
  size_t v6;

  v1 = a1;
  v2 = v1[7];
  v3 = v1[9];
  if (!v2)
  {
    if (!v3)
    {
      v6 = 0;
      goto LABEL_9;
    }
    goto LABEL_5;
  }
  if (v3)
  {
LABEL_5:
    size = v1[12];
    goto LABEL_6;
  }
  size = dispatch_data_get_size(v2);
LABEL_6:
  v5 = v1[14];
  if (size <= v5)
    v5 = 0;
  v6 = size - v5;
LABEL_9:

  return v6;
}

void ___ZL35nw_write_request_start_file_updatesP27NWConcrete_nw_write_request_block_invoke(uint64_t a1)
{
  const void **WeakRetained;
  const void **v2;
  void *v3;
  void *v4;
  void *v5;
  dispatch_qos_class_t v6;
  _QWORD v7[4];
  const void **v8;
  id v9;

  WeakRetained = (const void **)objc_loadWeakRetained((id *)(a1 + 32));
  v2 = WeakRetained;
  if (WeakRetained)
  {
    v3 = _Block_copy(WeakRetained[4]);
    v4 = v3;
    if (v3)
    {
      v5 = (void *)v2[5];
      v6 = *((_DWORD *)v2 + 12);
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = ___ZL35nw_write_request_start_file_updatesP27NWConcrete_nw_write_request_block_invoke_2;
      v7[3] = &unk_1E14ACE18;
      v9 = v3;
      v8 = v2;
      nw_connection_async_client_if_needed_with_override(v5, 0, v6, v7);

    }
  }

}

void sub_18367F5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void ___ZL35nw_write_request_start_file_updatesP27NWConcrete_nw_write_request_block_invoke_2(uint64_t a1)
{
  void *v2;
  _DWORD *v3;

  if (((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))() & 1) == 0)
  {
    v2 = *(void **)(a1 + 32);
    v3 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 89);
    nw_write_request_report_error_with_override(v2, 0, v3);

  }
}

void sub_18367F6A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_write_request_report(void *a1, void *a2, void *a3)
{
  char *v5;
  id v6;
  id v7;
  char v8;
  uint64_t v9;
  void **v10;
  _DWORD *v11;
  int v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  uint32_t v21;
  uint64_t v22;
  _DWORD *v23;
  int v24;
  _DWORD *v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  const char *v30;
  NSObject *v31;
  os_log_type_t v32;
  uint32_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  void *v37;
  void *v38;
  dispatch_qos_class_t v39;
  id v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  void *v45;
  dispatch_qos_class_t v46;
  id v47;
  void *v48;
  NSObject *v49;
  NSObject *v50;
  _QWORD v51[4];
  char *v52;
  id v53;
  id v54;
  _QWORD v55[4];
  id v56;
  id v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  _DWORD *v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if ((v5[128] & 2) != 0)
    goto LABEL_59;
  if (_nw_signposts_once != -1)
    dispatch_once(&_nw_signposts_once, &__block_literal_global_32785);
  if (_nw_signposts_enabled && kdebug_is_enabled())
    kdebug_trace();
  if (v7 || (v8 = v5[128], (v8 & 1) != 0))
  {
    nw_content_context_mark_completed_send(*((void **)v5 + 8), v7);
    v8 = v5[128];
  }
  v5[128] = v8 | 2;
  if (_nw_signposts_once == -1)
  {
    if (!_nw_signposts_enabled)
      goto LABEL_13;
  }
  else
  {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_32785);
    if (!_nw_signposts_enabled)
      goto LABEL_13;
  }
  if (kdebug_is_enabled())
  {
    v49 = *((_QWORD *)v5 + 7);
    if (v49)
      dispatch_data_get_size(v49);
    v50 = *((_QWORD *)v5 + 8);
    if (v50)
      nw_content_context_get_is_final(v50);
    kdebug_trace();
  }
LABEL_13:
  if (!*((_QWORD *)v5 + 9))
  {
    v10 = (void **)(v5 + 24);
    v22 = *((_QWORD *)v5 + 3);
    if (!v22)
      goto LABEL_59;
    if (!*((_QWORD *)v5 + 5))
    {
      (*(void (**)(uint64_t, id))(v22 + 16))(v22, v7);
LABEL_58:
      v48 = *v10;
      *v10 = 0;

      goto LABEL_59;
    }
    if (!v7)
    {
LABEL_57:
      v44 = _Block_copy(*((const void **)v5 + 3));
      v45 = (void *)*((_QWORD *)v5 + 5);
      v46 = *((_DWORD *)v5 + 12);
      v55[0] = MEMORY[0x1E0C809B0];
      v55[1] = 3221225472;
      v55[2] = ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke;
      v55[3] = &unk_1E14ACE18;
      v57 = v44;
      v56 = v7;
      v47 = v44;
      nw_connection_async_client_if_needed_with_override(v45, v6, v46, v55);

      goto LABEL_58;
    }
    v23 = v7;
    v24 = v23[2];

    if (v24 == 1 && (v25 = v23, v26 = v25[3], v25, v26 == 89))
    {
      v27 = *(_QWORD *)(*((_QWORD *)v5 + 5) + 16);
      if (!v27 || nw_path_parameters_get_logging_disabled(*(_QWORD *)(v27 + 104)))
        goto LABEL_57;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v28 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        goto LABEL_56;
      v29 = *(_DWORD *)(*((_QWORD *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446466;
      v59 = "nw_write_request_report";
      v60 = 1024;
      v61 = v29;
      v30 = "%{public}s [C%u] Send cancelled";
      v31 = v28;
      v32 = OS_LOG_TYPE_INFO;
      v33 = 18;
    }
    else
    {
      v42 = *(_QWORD *)(*((_QWORD *)v5 + 5) + 16);
      if (!v42 || nw_path_parameters_get_logging_disabled(*(_QWORD *)(v42 + 104)))
        goto LABEL_57;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v28 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        goto LABEL_56;
      v43 = *(_DWORD *)(*((_QWORD *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446722;
      v59 = "nw_write_request_report";
      v60 = 1024;
      v61 = v43;
      v62 = 2114;
      v63 = v23;
      v30 = "%{public}s [C%u] Send failed with error \"%{public}@\"";
      v31 = v28;
      v32 = OS_LOG_TYPE_ERROR;
      v33 = 28;
    }
    _os_log_impl(&dword_182FBE000, v31, v32, v30, buf, v33);
LABEL_56:

    goto LABEL_57;
  }
  v10 = (void **)(v5 + 32);
  v9 = *((_QWORD *)v5 + 4);
  if (v9)
  {
    if (!*((_QWORD *)v5 + 5))
    {
      (*(void (**)(uint64_t, _QWORD, BOOL, id))(v9 + 16))(v9, *((_QWORD *)v5 + 14), v7 == 0, v7);
      goto LABEL_46;
    }
    if (!v7)
    {
LABEL_45:
      v37 = _Block_copy(*((const void **)v5 + 4));
      v38 = (void *)*((_QWORD *)v5 + 5);
      v39 = *((_DWORD *)v5 + 12);
      v51[0] = MEMORY[0x1E0C809B0];
      v51[1] = 3221225472;
      v51[2] = ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke_93;
      v51[3] = &unk_1E14A8D98;
      v54 = v37;
      v52 = v5;
      v53 = v7;
      v40 = v37;
      nw_connection_async_client_if_needed_with_override(v38, v6, v39, v51);

LABEL_46:
      v41 = *((_QWORD *)v5 + 10);
      if (v41)
      {
        nw_queue_cancel_source(v41, v34);
        *((_QWORD *)v5 + 10) = 0;
      }
      goto LABEL_58;
    }
    v11 = v7;
    v12 = v11[2];

    if (v12 == 1 && (v13 = v11, v14 = v13[3], v13, v14 == 89))
    {
      v15 = *(_QWORD *)(*((_QWORD *)v5 + 5) + 16);
      if (!v15 || nw_path_parameters_get_logging_disabled(*(_QWORD *)(v15 + 104)))
        goto LABEL_45;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        goto LABEL_44;
      v17 = *(_DWORD *)(*((_QWORD *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446466;
      v59 = "nw_write_request_report";
      v60 = 1024;
      v61 = v17;
      v18 = "%{public}s [C%u] Send cancelled";
      v19 = v16;
      v20 = OS_LOG_TYPE_INFO;
      v21 = 18;
    }
    else
    {
      v35 = *(_QWORD *)(*((_QWORD *)v5 + 5) + 16);
      if (!v35 || nw_path_parameters_get_logging_disabled(*(_QWORD *)(v35 + 104)))
        goto LABEL_45;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v16 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
      v36 = *(_DWORD *)(*((_QWORD *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446722;
      v59 = "nw_write_request_report";
      v60 = 1024;
      v61 = v36;
      v62 = 2114;
      v63 = v11;
      v18 = "%{public}s [C%u] Send failed with error \"%{public}@\"";
      v19 = v16;
      v20 = OS_LOG_TYPE_ERROR;
      v21 = 28;
    }
    _os_log_impl(&dword_182FBE000, v19, v20, v18, buf, v21);
LABEL_44:

    goto LABEL_45;
  }
LABEL_59:

}

void sub_18367FD20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

uint64_t ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
}

uint64_t ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke_93(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, BOOL))(a1[6] + 16))(a1[6], *(_QWORD *)(a1[4] + 112), a1[5] == 0);
}

void nw_write_request_fail(void *a1, int a2)
{
  id v3;
  _DWORD *posix_error;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (v3)
  {
    if (a2)
      posix_error = nw_error_create_posix_error(a2);
    else
      posix_error = 0;
    nw_write_request_report(v3, 0, posix_error);

    goto LABEL_6;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_write_request_fail";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_write_request_fail";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null request", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_write_request_fail";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_write_request_fail";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_write_request_fail";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v6)
    free(v6);
LABEL_6:

}

void sub_183680064(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

unint64_t nw_write_request_remaining_datagram_count(void *a1)
{
  id v1;
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = (uint64_t *)v1;
    if (*((_QWORD *)v1 + 7))
      v3 = !nw_content_context_is_blocked_by_antecedents(*((void **)v1 + 8));
    else
      v3 = 0;
    v5 = v2 + 1;
    v4 = v2[1];
    if (v4)
    {
      do
      {
        v6 = *(_QWORD *)(v4 + 56);
        if (v6)
        {
          v6 = !nw_content_context_is_blocked_by_antecedents(*(void **)(v4 + 64));
          v4 = *v5;
        }
        v3 += v6;
        v7 = (uint64_t *)(id)v4;

        v5 = v7 + 1;
        v4 = v7[1];
        if (!v4)
          break;
        v2 = v7;
      }
      while (v3 < 0x100);
    }
    else
    {
      v7 = v2;
    }
    goto LABEL_12;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_write_request_remaining_datagram_count";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_write_request_remaining_datagram_count";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null request", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_write_request_remaining_datagram_count";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_write_request_remaining_datagram_count";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_write_request_remaining_datagram_count";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_29:
  if (v10)
    free(v10);
  v7 = 0;
  v3 = 0;
LABEL_12:

  return v3;
}

uint64_t __nw_write_request_copy_data_from_fd_block_invoke(uint64_t a1, int a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = read(a2, *(void **)(a1 + 40), *(_QWORD *)(a1 + 48));
  return 1;
}

id nw_write_request_copy_context(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[8];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_write_request_copy_context";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_write_request_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null request", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_write_request_copy_context";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_write_request_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_write_request_copy_context";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void ___ZL35nw_write_request_coalesce_with_nextP27NWConcrete_nw_write_requestS0__block_invoke(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

}

void sub_1836806A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

char **nw_protocol_http_encoding_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  char **v6;
  char v7;
  char *v8;
  char *v9;
  char v10;
  char *v11;
  id v12;
  unsigned __int8 *v13;
  int type;
  char *v15;
  z_stream *v16;
  int v17;
  NSObject *v18;
  char *v19;
  NSObject *v21;
  void *v22;
  NSObject *v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  NSObject *v28;
  void *v29;
  NSObject *v30;
  void *v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v6 = (char **)malloc_type_calloc(1uLL, 0x290uLL, 0xEAFB8F1AuLL);
  if (!v6)
  {
    v21 = __nwlog_obj();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v33 = "strict_calloc";
    v34 = 2048;
    v35 = 1;
    v36 = 2048;
    v37 = 656;
    v22 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v22))
    {
LABEL_54:
      __break(1u);
      JUMPOUT(0x183680F00);
    }
    free(v22);
  }
  bzero(v6, 0x290uLL);
  if (gLogDatapath)
  {
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v33 = "nw_protocol_http_encoding_create";
      v34 = 2082;
      v35 = (uint64_t)v6 + 114;
      v36 = 2080;
      v37 = (uint64_t)" ";
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
    }
  }
  if (nw_protocol_http_encoding_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_http_encoding_identifier::onceToken, &__block_literal_global_33009);
  v6[2] = (char *)nw_protocol_http_encoding_identifier::protocol_identifier;
  if (nw_protocol_http_encoding_get_callbacks(void)::onceToken[0] != -1)
    dispatch_once(nw_protocol_http_encoding_get_callbacks(void)::onceToken, &__block_literal_global_18);
  v6[3] = (char *)&nw_protocol_http_encoding_get_callbacks(void)::protocol_callbacks;
  v6[5] = (char *)v6;
  if (a3)
    a3 = os_retain(a3);
  v7 = *((_BYTE *)v6 + 520);
  if ((v7 & 1) != 0)
  {
    v8 = v6[64];
    if (v8)
    {
      os_release(v8);
      v7 = *((_BYTE *)v6 + 520);
    }
  }
  v6[64] = (char *)a3;
  *((_BYTE *)v6 + 520) = v7 | 1;
  if (a4)
  {
    v9 = (char *)os_retain(a4);
    v10 = *((_BYTE *)v6 + 536);
    if ((v10 & 1) == 0)
      goto LABEL_18;
  }
  else
  {
    v9 = 0;
    v10 = *((_BYTE *)v6 + 536);
    if ((v10 & 1) == 0)
      goto LABEL_18;
  }
  v11 = v6[66];
  if (v11)
  {
    os_release(v11);
    v10 = *((_BYTE *)v6 + 536);
  }
LABEL_18:
  v6[66] = v9;
  *((_BYTE *)v6 + 536) = v10 | 1;
  *((_BYTE *)v6 + 648) = (_BYTE)v6[81] & 0xFE | nw_parameters_get_server_mode(a4);
  v6[70] = 0;
  v6[71] = (char *)(v6 + 70);
  v6[72] = 0;
  v6[73] = (char *)(v6 + 72);
  v6[74] = 0;
  v6[75] = (char *)(v6 + 74);
  v6[76] = 0;
  v6[77] = (char *)(v6 + 76);
  v6[78] = 0;
  v6[79] = (char *)(v6 + 78);
  nw_frame_cache_init((uint64_t)(v6 + 54), (uint64_t)v6, 256, 0x40000, 0);
  if (nw_protocol_copy_http_encoding_definition_onceToken != -1)
    dispatch_once(&nw_protocol_copy_http_encoding_definition_onceToken, &__block_literal_global_30_72927);
  v12 = (id)nw_protocol_copy_http_encoding_definition_http_encoding_definition;
  v13 = nw_parameters_copy_protocol_options_for_definition(a4, v12);
  type = nw_http_encoding_options_get_type(v13);
  *((_DWORD *)v6 + 160) = type;
  switch(type)
  {
    case 2:
      v15 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xEAFB8F1AuLL);
      if (v15)
        goto LABEL_22;
      v24 = __nwlog_obj();
      os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1;
      v36 = 2048;
      v37 = 128;
      v25 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v25))
        goto LABEL_54;
      free(v25);
LABEL_22:
      *(_QWORD *)v15 = &off_1E1492448;
      *((_DWORD *)v15 + 30) = 31;
      v16 = (z_stream *)(v15 + 8);
      v17 = 31;
      goto LABEL_27;
    case 3:
      v15 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xEAFB8F1AuLL);
      if (v15)
        goto LABEL_26;
      v28 = __nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1;
      v36 = 2048;
      v37 = 128;
      v29 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v29))
        goto LABEL_54;
      free(v29);
LABEL_26:
      *(_QWORD *)v15 = &off_1E1492448;
      *((_DWORD *)v15 + 30) = 15;
      v16 = (z_stream *)(v15 + 8);
      v17 = 15;
      goto LABEL_27;
    case 4:
      v15 = (char *)malloc_type_calloc(1uLL, 0x80uLL, 0xEAFB8F1AuLL);
      if (v15)
        goto LABEL_24;
      v26 = __nwlog_obj();
      os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1;
      v36 = 2048;
      v37 = 128;
      v27 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v27))
        goto LABEL_54;
      free(v27);
LABEL_24:
      *(_QWORD *)v15 = &off_1E1492448;
      *((_DWORD *)v15 + 30) = -15;
      v16 = (z_stream *)(v15 + 8);
      v17 = -15;
LABEL_27:
      deflateInit2_(v16, -1, 8, v17, 8, 0, "1.2.12", 112);
      break;
    case 5:
      v15 = (char *)malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL);
      if (v15)
        goto LABEL_29;
      v30 = __nwlog_obj();
      os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v33 = "strict_calloc";
      v34 = 2048;
      v35 = 1;
      v36 = 2048;
      v37 = 48;
      v31 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v31))
        goto LABEL_54;
      free(v31);
LABEL_29:
      *(_QWORD *)v15 = &off_1E1492498;
      if (compression_stream_init((compression_stream *)(v15 + 8), COMPRESSION_STREAM_ENCODE, COMPRESSION_BROTLI))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "brotli_encoder";
          _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, "%{public}s init failed", buf, 0xCu);
        }
      }
      break;
    default:
      v15 = 0;
      break;
  }
  v19 = v6[69];
  if (v19 != v15)
  {
    if (v19)
    {
      (**(void (***)(char *))v19)(v6[69]);
      free(v19);
    }
    v6[69] = v15;
  }
  v6[8] = (char *)(v6 + 13);
  nw_protocol_plugin_name_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_encoding_create::$_0::__invoke);
  v6[10] = (char *)(v6 + 25);
  nw_protocol_plugin_reset_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_encoding_create::$_1::__invoke);
  v6[11] = (char *)(v6 + 27);
  nw_protocol_plugin_retry_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_encoding_create::$_2::__invoke, (uint64_t)nw_protocol_http_encoding_create::$_3::__invoke, (uint64_t)nw_protocol_http_encoding_create::$_4::__invoke, (uint64_t)nw_protocol_http_encoding_create::$_5::__invoke);
  if (v13)
    os_release(v13);
  if (v12)
    os_release(v12);
  return v6;
}

uint64_t nw_protocol_http_encoding_create::$_0::__invoke(nw_protocol_http_encoding_create::$_0 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

void nw_protocol_http_encoding_create::$_1::__invoke(nw_protocol_http_encoding_create::$_1 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v3;
  char v4;
  void *v5;
  char v6;
  void *v7;
  void (***v8)(_QWORD, nw_protocol *, nw_protocol *);
  void (***v9)(_QWORD, nw_protocol *, nw_protocol *);
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "operator()";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v21 = "operator()";
      v13 = "%{public}s called with null protocol";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "operator()";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_42:
        if (!v10)
          return;
LABEL_43:
        free(v10);
        return;
      }
      if (!v15)
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v21 = "operator()";
      v13 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v21 = "operator()";
      v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_41:
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_42;
  }
  v3 = *((_QWORD *)this + 5);
  if (v3)
  {
    v4 = *(_BYTE *)(v3 + 488);
    if ((v4 & 1) != 0)
    {
      v5 = *(void **)(v3 + 480);
      if (v5)
      {
        os_release(v5);
        v4 = *(_BYTE *)(v3 + 488);
      }
    }
    *(_QWORD *)(v3 + 480) = 0;
    *(_BYTE *)(v3 + 488) = v4 | 1;
    v6 = *(_BYTE *)(v3 + 504);
    if ((v6 & 1) != 0)
    {
      v7 = *(void **)(v3 + 496);
      if (v7)
      {
        os_release(v7);
        v6 = *(_BYTE *)(v3 + 504);
      }
    }
    *(_QWORD *)(v3 + 496) = 0;
    *(_BYTE *)(v3 + 504) = v6 | 1;
    v8 = *(void (****)(_QWORD, nw_protocol *, nw_protocol *))(v3 + 544);
    if (v8)
    {
      (**v8)(*(_QWORD *)(v3 + 544), a2, a3);
      free(v8);
      *(_QWORD *)(v3 + 544) = 0;
    }
    v9 = *(void (****)(_QWORD, nw_protocol *, nw_protocol *))(v3 + 552);
    if (v9)
    {
      (**v9)(*(_QWORD *)(v3 + 552), a2, a3);
      free(v9);
      *(_QWORD *)(v3 + 552) = 0;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "operator()";
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v10, &type, &v18))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v21 = "operator()";
    v13 = "%{public}s called with null http_encoding";
    goto LABEL_41;
  }
  if (!v18)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v21 = "operator()";
    v13 = "%{public}s called with null http_encoding, backtrace limit exceeded";
    goto LABEL_41;
  }
  v16 = (char *)__nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v12 = type;
  v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17)
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v21 = "operator()";
    v13 = "%{public}s called with null http_encoding, no backtrace";
    goto LABEL_41;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "operator()";
    v22 = 2082;
    v23 = v16;
    _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null http_encoding, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v10)
    goto LABEL_43;
}

uint64_t nw_protocol_http_encoding_create::$_2::__invoke(nw_protocol_http_encoding_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v3;
  uint64_t result;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  const char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    v3 = *((_QWORD *)this + 5);
    if (v3)
    {
      result = 0;
      *(_BYTE *)(v3 + 648) |= 0x40u;
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "operator()";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_encoding";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v12 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_encoding, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "operator()";
      v17 = 2082;
      v18 = backtrace_string;
      v11 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "operator()";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "operator()";
      v17 = 2082;
      v18 = backtrace_string;
      v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v6, v7, v11, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v6 = __nwlog_obj();
  v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    v16 = "operator()";
    v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
  }
LABEL_32:
  if (v5)
    free(v5);
  return 1;
}

uint64_t nw_protocol_http_encoding_create::$_3::__invoke(nw_protocol_http_encoding_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_encoding_create::$_4::__invoke(nw_protocol_http_encoding_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_encoding_create::$_5::__invoke(nw_protocol_http_encoding_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v3;
  void *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  void *v9;
  NSObject *v10;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char *v18;
  _BOOL4 v19;
  _QWORD v20[5];
  os_log_type_t type[8];
  uint64_t v22;
  void (*v23)(uint64_t, char *);
  void *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  const char *v35;
  _BYTE v36[24];
  uint64_t (*v37)(uint64_t, uint64_t);
  void (*v38)(uint64_t);
  void *v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)v36 = 136446210;
    *(_QWORD *)&v36[4] = "operator()";
    v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v20[0]) = 0;
    if (!__nwlog_fault(v12, type, v20))
      goto LABEL_53;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (!os_log_type_enabled(v13, type[0]))
        goto LABEL_53;
      *(_DWORD *)v36 = 136446210;
      *(_QWORD *)&v36[4] = "operator()";
      v15 = "%{public}s called with null protocol";
      goto LABEL_52;
    }
    if (!LOBYTE(v20[0]))
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (!os_log_type_enabled(v13, type[0]))
        goto LABEL_53;
      *(_DWORD *)v36 = 136446210;
      *(_QWORD *)&v36[4] = "operator()";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type[0];
    v17 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (!v17)
        goto LABEL_53;
      *(_DWORD *)v36 = 136446210;
      *(_QWORD *)&v36[4] = "operator()";
      v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_52;
    }
    if (v17)
    {
      *(_DWORD *)v36 = 136446466;
      *(_QWORD *)&v36[4] = "operator()";
      *(_WORD *)&v36[12] = 2082;
      *(_QWORD *)&v36[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", v36, 0x16u);
    }
    free(backtrace_string);
LABEL_53:
    if (!v12)
      return 1;
LABEL_54:
    free(v12);
    return 1;
  }
  v3 = *((_QWORD *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)v36 = 136446210;
    *(_QWORD *)&v36[4] = "operator()";
    v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v20[0]) = 0;
    if (!__nwlog_fault(v12, type, v20))
      goto LABEL_53;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (!os_log_type_enabled(v13, type[0]))
        goto LABEL_53;
      *(_DWORD *)v36 = 136446210;
      *(_QWORD *)&v36[4] = "operator()";
      v15 = "%{public}s called with null http_encoding";
      goto LABEL_52;
    }
    if (!LOBYTE(v20[0]))
    {
      v13 = __nwlog_obj();
      v14 = type[0];
      if (!os_log_type_enabled(v13, type[0]))
        goto LABEL_53;
      *(_DWORD *)v36 = 136446210;
      *(_QWORD *)&v36[4] = "operator()";
      v15 = "%{public}s called with null http_encoding, backtrace limit exceeded";
      goto LABEL_52;
    }
    v18 = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type[0];
    v19 = os_log_type_enabled(v13, type[0]);
    if (v18)
    {
      if (v19)
      {
        *(_DWORD *)v36 = 136446466;
        *(_QWORD *)&v36[4] = "operator()";
        *(_WORD *)&v36[12] = 2082;
        *(_QWORD *)&v36[14] = v18;
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null http_encoding, dumping backtrace:%{public}s", v36, 0x16u);
      }
      free(v18);
      if (!v12)
        return 1;
      goto LABEL_54;
    }
    if (v19)
    {
      *(_DWORD *)v36 = 136446210;
      *(_QWORD *)&v36[4] = "operator()";
      v15 = "%{public}s called with null http_encoding, no backtrace";
LABEL_52:
      _os_log_impl(&dword_182FBE000, v13, v14, v15, v36, 0xCu);
      goto LABEL_53;
    }
    goto LABEL_53;
  }
  if ((_DWORD)a3 != 96)
    return 1;
  v4 = *(void **)(v3 + 496);
  if (!v4)
    return 1;
  v5 = nw_http_metadata_copy_response(v4);
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v6 = MEMORY[0x1E0C809B0];
  v29 = -1;
  *(_QWORD *)type = MEMORY[0x1E0C809B0];
  v22 = 0x40000000;
  v23 = ___ZZ32nw_protocol_http_encoding_createENK3__5clEP11nw_protocolS1_i_block_invoke;
  v24 = &unk_1E149FFE0;
  v25 = &v26;
  nw_http_fields_access_value_by_name(v5, (unint64_t)"Content-Length", type);
  v7 = v27[3];
  if (v7 == -1 || v7 != *(_QWORD *)(v3 + 472))
    goto LABEL_23;
  *(_QWORD *)v36 = 0;
  *(_QWORD *)&v36[8] = v36;
  *(_QWORD *)&v36[16] = 0x3802000000;
  v37 = __Block_byref_object_copy__33021;
  v38 = __Block_byref_object_dispose__33022;
  v39 = 0;
  v40 = -1;
  v8 = (unsigned __int8 *)nw_protocol_copy_info(*(_QWORD *)(v3 + 32), 255);
  v20[0] = v6;
  v20[1] = 0x40000000;
  v20[2] = ___ZZ32nw_protocol_http_encoding_createENK3__5clEP11nw_protocolS1_i_block_invoke_14;
  v20[3] = &unk_1E14A0008;
  v20[4] = v36;
  nw_array_apply(v8, (uint64_t)v20);
  v9 = *(void **)(*(_QWORD *)&v36[8] + 40);
  if (!v9 || nw_http_connection_metadata_get_version(v9) != 3)
  {
    if (v8)
      os_release(v8);
    _Block_object_dispose(v36, 8);
    if ((v40 & 1) != 0 && v39)
      os_release(v39);
LABEL_23:
    _Block_object_dispose(&v26, 8);
    return 1;
  }
  if ((*(_BYTE *)(v3 + 198) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v31 = "operator()";
      v32 = 2082;
      v33 = v3 + 114;
      v34 = 2080;
      v35 = " ";
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%saccepting invalid Content-Length matching decompressed body", buf, 0x20u);
    }
  }
  if (v8)
    os_release(v8);
  _Block_object_dispose(v36, 8);
  if ((v40 & 1) != 0)
  {
    if (v39)
      os_release(v39);
  }
  _Block_object_dispose(&v26, 8);
  return 0;
}

void ___ZZ32nw_protocol_http_encoding_createENK3__5clEP11nw_protocolS1_i_block_invoke(uint64_t a1, char *__s)
{
  size_t v4;
  std::string::size_type v5;
  std::string *p_dst;
  uint64_t v7;
  uint64_t v8;
  std::string __dst;

  if (__s)
  {
    v4 = strlen(__s);
    if (v4 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v5 = v4;
    if (v4 >= 0x17)
    {
      v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17)
        v7 = v4 | 7;
      v8 = v7 + 1;
      p_dst = (std::string *)operator new(v7 + 1);
      __dst.__r_.__value_.__l.__size_ = v5;
      __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v4;
      p_dst = &__dst;
      if (!v4)
      {
LABEL_10:
        p_dst->__r_.__value_.__s.__data_[v5] = 0;
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = std::stoull(&__dst, 0, 10);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__dst.__r_.__value_.__l.__data_);
        return;
      }
    }
    memcpy(p_dst, __s, v5);
    goto LABEL_10;
  }
}

uint64_t __Block_byref_object_copy__33021(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__33022(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

BOOL ___ZZ32nw_protocol_http_encoding_createENK3__5clEP11nw_protocolS1_i_block_invoke_14(uint64_t a1, uint64_t a2, void *a3)
{
  void *v3;
  _BOOL4 is_http_connection;
  uint64_t v6;
  char v7;
  void *v8;

  v3 = a3;
  is_http_connection = nw_protocol_metadata_is_http_connection(a3);
  if (is_http_connection)
  {
    if (v3)
      v3 = os_retain(v3);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(_BYTE *)(v6 + 48);
    if ((v7 & 1) != 0)
    {
      v8 = *(void **)(v6 + 40);
      if (v8)
      {
        os_release(v8);
        v7 = *(_BYTE *)(v6 + 48);
      }
    }
    *(_QWORD *)(v6 + 40) = v3;
    *(_BYTE *)(v6 + 48) = v7 | 1;
  }
  return !is_http_connection;
}

void ___ZL39nw_protocol_http_encoding_get_callbacksv_block_invoke()
{
  qword_1EDCE4378 = (uint64_t)nw_protocol_common_get_parameters;
  unk_1EDCE4380 = nw_protocol_common_get_path;
  qword_1EDCE4388 = (uint64_t)nw_protocol_common_get_local_endpoint;
  unk_1EDCE4390 = nw_protocol_common_get_remote_endpoint;
  qword_1EDCE4318 = (uint64_t)nw_protocol_common_replace_input_handler;
  unk_1EDCE4320 = nw_protocol_common_connect;
  qword_1EDCE4328 = (uint64_t)nw_protocol_common_disconnect;
  unk_1EDCE4330 = nw_protocol_common_connected;
  qword_1EDCE4348 = (uint64_t)nw_protocol_common_input_available;
  unk_1EDCE4350 = nw_protocol_common_output_available;
  qword_1EDCE43C8 = (uint64_t)nw_protocol_common_output_finished;
  unk_1EDCE43D0 = nw_protocol_common_get_output_local_endpoint;
  qword_1EDCE4410 = (uint64_t)nw_protocol_common_input_flush;
  qword_1EDCE4338 = (uint64_t)nw_protocol_common_disconnected;
  unk_1EDCE4340 = nw_protocol_common_error;
  qword_1EDCE4400 = (uint64_t)nw_protocol_common_get_message_properties;
  unk_1EDCE4408 = nw_protocol_common_reset;
  qword_1EDCE43E8 = (uint64_t)nw_protocol_common_copy_info;
  qword_1EDCE43B8 = (uint64_t)nw_protocol_common_supports_external_data;
  unk_1EDCE43C0 = nw_protocol_common_input_finished;
  qword_1EDCE43D8 = (uint64_t)nw_protocol_common_get_output_interface;
  unk_1EDCE43E0 = nw_protocol_common_waiting_for_output;
  qword_1EDCE4398 = (uint64_t)nw_protocol_common_register_notification;
  unk_1EDCE43A0 = nw_protocol_common_unregister_notification;
  qword_1EDCE43A8 = (uint64_t)nw_protocol_common_notify;
  unk_1EDCE43B0 = nw_protocol_common_updated_path;
  qword_1EDCE4358 = (uint64_t)nw_protocol_http_encoding_get_input_frames;
  unk_1EDCE4360 = nw_protocol_common_get_output_frames;
  qword_1EDCE4368 = (uint64_t)nw_protocol_http_encoding_finalize_output_frames;
  unk_1EDCE4370 = nw_protocol_common_link_state;
  nw_protocol_http_encoding_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  unk_1EDCE4310 = nw_protocol_http_encoding_remove_input_handler;
}

uint64_t nw_protocol_http_encoding_get_input_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  _BYTE *handle;
  int input_frames;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  NSObject *v18;
  void (*v19)(uint64_t);
  uint64_t v20;
  uint64_t v21;
  char v22;
  NSObject *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  NSObject *v29;
  char *backtrace_string;
  _BOOL4 v31;
  const char *v32;
  NSObject *v33;
  nw_frame *tqh_first;
  nw_frame *v35;
  char v36;
  _BOOL4 v37;
  NSObject *v38;
  int v39;
  _QWORD v40[2];
  uint64_t (*v41)(_QWORD *);
  void *v42;
  _BYTE *v43;
  _QWORD v44[2];
  uint64_t (*v45)(_QWORD *);
  void *v46;
  _BYTE *v47;
  uint64_t *v48;
  _BYTE *v49;
  _BYTE *v50;
  nw_protocol *v51;
  nw_frame_array_s *v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  int v56;
  _BYTE v57[24];
  uint64_t (*v58)(uint64_t, uint64_t);
  void (*v59)(uint64_t);
  void *object;
  char v61;
  _BYTE buf[24];
  __n128 (*v63)(uint64_t, uint64_t);
  uint64_t (*v64)();
  __int128 v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
    v25 = (char *)_os_log_send_and_compose_impl();
    v57[0] = 16;
    LOBYTE(v53) = 0;
    if (!__nwlog_fault(v25, v57, &v53))
      goto LABEL_72;
    if (v57[0] != 17)
    {
      if (!(_BYTE)v53)
      {
        v26 = __nwlog_obj();
        v27 = v57[0];
        if (!os_log_type_enabled(v26, (os_log_type_t)v57[0]))
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
        v28 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_71;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = v57[0];
      v31 = os_log_type_enabled(v26, (os_log_type_t)v57[0]);
      if (!backtrace_string)
      {
        if (!v31)
          goto LABEL_72;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
        v28 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_71;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v32 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_59:
        _os_log_impl(&dword_182FBE000, v26, v27, v32, buf, 0x16u);
      }
LABEL_60:
      free(backtrace_string);
      goto LABEL_72;
    }
    v26 = __nwlog_obj();
    v27 = v57[0];
    if (!os_log_type_enabled(v26, (os_log_type_t)v57[0]))
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
    v28 = "%{public}s called with null protocol";
LABEL_71:
    _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
LABEL_72:
    if (v25)
      free(v25);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
    v25 = (char *)_os_log_send_and_compose_impl();
    v57[0] = 16;
    LOBYTE(v53) = 0;
    if (!__nwlog_fault(v25, v57, &v53))
      goto LABEL_72;
    if (v57[0] == 17)
    {
      v26 = __nwlog_obj();
      v27 = v57[0];
      if (!os_log_type_enabled(v26, (os_log_type_t)v57[0]))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
      v28 = "%{public}s called with null http_encoding";
      goto LABEL_71;
    }
    if (!(_BYTE)v53)
    {
      v26 = __nwlog_obj();
      v27 = v57[0];
      if (!os_log_type_enabled(v26, (os_log_type_t)v57[0]))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
      v28 = "%{public}s called with null http_encoding, backtrace limit exceeded";
      goto LABEL_71;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = v57[0];
    v37 = os_log_type_enabled(v26, (os_log_type_t)v57[0]);
    if (backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v32 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (!v37)
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
    v28 = "%{public}s called with null http_encoding, no backtrace";
    goto LABEL_71;
  }
  if ((handle[198] & 1) == 0)
  {
    if (gLogDatapath)
    {
      v29 = __nwlog_obj();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 114;
        *(_WORD *)&buf[22] = 2080;
        v63 = (__n128 (*)(uint64_t, uint64_t))" ";
        LOWORD(v64) = 1024;
        *(_DWORD *)((char *)&v64 + 2) = a3;
        HIWORD(v64) = 1024;
        LODWORD(v65) = a4;
        WORD2(v65) = 1024;
        *(_DWORD *)((char *)&v65 + 6) = a5;
        _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sminimum bytes %u, maximum bytes %u, maximum frame count %u", buf, 0x32u);
      }
    }
  }
  if ((handle[428] & 1) != 0)
  {
    v17 = 0;
    if ((handle[198] & 1) != 0 || !gLogDatapath)
      return v17;
    v18 = __nwlog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 114;
      *(_WORD *)&buf[22] = 2080;
      v63 = (__n128 (*)(uint64_t, uint64_t))" ";
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%salready getting input frames, returning 0", buf, 0x20u);
      return 0;
    }
    return 0;
  }
  handle[428] |= 1u;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x3802000000;
  v63 = __Block_byref_object_copy__19_33137;
  v64 = __Block_byref_object_dispose__20_33138;
  *(_QWORD *)&v65 = 0;
  *((_QWORD *)&v65 + 1) = &v65;
  v53 = 0;
  v54 = &v53;
  v56 = 0;
  v55 = 0x2000000000;
  input_frames = nw_protocol_get_input_frames((uint64_t)a1->output_handler, (uint64_t)a1, a3, a4, a5, (uint64_t)&v65);
  v13 = MEMORY[0x1E0C809B0];
  if (input_frames && *(_QWORD *)(*(_QWORD *)&buf[8] + 40))
  {
    *(_QWORD *)v57 = 0;
    *(_QWORD *)&v57[8] = v57;
    *(_QWORD *)&v57[16] = 0x3802000000;
    v58 = __Block_byref_object_copy__21;
    v59 = __Block_byref_object_dispose__22;
    if (nw_protocol_copy_http_definition_onceToken != -1)
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72660);
    object = (id)nw_protocol_copy_http_definition_http_definition;
    v61 |= 1u;
    v44[0] = v13;
    v44[1] = 0x40000000;
    v45 = (uint64_t (*)(_QWORD *))___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    v46 = &unk_1E14A00A0;
    v51 = a1;
    v52 = a6;
    v47 = v57;
    v48 = &v53;
    v49 = buf;
    v50 = handle;
    v14 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
    do
    {
      if (!v14)
        break;
      v15 = *(_QWORD *)(v14 + 32);
      v16 = v45(v44);
      v14 = v15;
    }
    while ((v16 & 1) != 0);
    _Block_object_dispose(v57, 8);
    if ((v61 & 1) != 0 && object)
      os_release(object);
  }
  else if ((handle[648] & 0x40) != 0 && (handle[648] & 0x24) == 4)
  {
    if (*((_QWORD *)handle + 68))
    {
      if ((handle[198] & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v57 = 136446722;
          *(_QWORD *)&v57[4] = "nw_protocol_http_encoding_get_input_frames";
          *(_WORD *)&v57[12] = 2082;
          *(_QWORD *)&v57[14] = handle + 114;
          *(_WORD *)&v57[22] = 2080;
          v58 = (uint64_t (*)(uint64_t, uint64_t))" ";
          _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sinput finished before decoder completed", v57, 0x20u);
        }
      }
    }
  }
  v19 = (void (*)(uint64_t))(*(_QWORD *)&buf[8] + 40);
  if (gLogDatapath)
  {
    v33 = __nwlog_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v57 = 136446210;
      *(_QWORD *)&v57[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s called", v57, 0xCu);
    }
  }
  *(_QWORD *)v57 = v13;
  *(_QWORD *)&v57[8] = 0x40000000;
  *(_QWORD *)&v57[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33090;
  v58 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_38_33091;
  v59 = v19;
  LOBYTE(object) = 1;
  v20 = *(_QWORD *)v19;
  do
  {
    if (!v20)
      break;
    v21 = *(_QWORD *)(v20 + 32);
    v22 = (*(uint64_t (**)(_BYTE *))&v57[16])(v57);
    v20 = v21;
  }
  while ((v22 & 1) != 0);
  if (gLogDatapath)
  {
    v40[0] = v13;
    v40[1] = 0x40000000;
    v41 = (uint64_t (*)(_QWORD *))___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_32;
    v42 = &__block_descriptor_tmp_33_33141;
    v43 = handle;
    tqh_first = a6->tqh_first;
    do
    {
      if (!tqh_first)
        break;
      v35 = (nw_frame *)*((_QWORD *)tqh_first + 4);
      v36 = v41(v40);
      tqh_first = v35;
    }
    while ((v36 & 1) != 0);
  }
  if ((handle[198] & 1) == 0)
  {
    if (gLogDatapath)
    {
      v38 = __nwlog_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v39 = *((_DWORD *)v54 + 6);
        *(_DWORD *)v57 = 136446978;
        *(_QWORD *)&v57[4] = "nw_protocol_http_encoding_get_input_frames";
        *(_WORD *)&v57[12] = 2082;
        *(_QWORD *)&v57[14] = handle + 114;
        *(_WORD *)&v57[22] = 2080;
        v58 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v59) = 1024;
        *(_DWORD *)((char *)&v59 + 2) = v39;
        _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sreturning %u frames", v57, 0x26u);
      }
    }
  }
  nw_protocol_plugin_retry_set_getting_input_frames((uint64_t)(handle + 216), (uint64_t)a1, 0);
  v17 = *((unsigned int *)v54 + 6);
  _Block_object_dispose(&v53, 8);
  _Block_object_dispose(buf, 8);
  return v17;
}

uint64_t nw_protocol_http_encoding_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  char *handle;
  int v4;
  nw_frame *tqh_first;
  id v6;
  void *v7;
  id v8;
  char v9;
  void *parameters;
  id v11;
  const char *url_scheme;
  const char *v13;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  NSObject *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  _BOOL4 v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  const char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http_encoding_finalize_output_frames";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v15, &type, &v25))
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http_encoding_finalize_output_frames";
      v18 = "%{public}s called with null protocol";
LABEL_65:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      goto LABEL_66;
    }
    if (!v25)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_encoding_finalize_output_frames";
        v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v21 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_encoding_finalize_output_frames";
        v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    if (!v21)
      goto LABEL_52;
    *(_DWORD *)buf = 136446466;
    v28 = "nw_protocol_http_encoding_finalize_output_frames";
    v29 = 2082;
    v30 = backtrace_string;
    v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_51:
    _os_log_impl(&dword_182FBE000, v16, v17, v22, buf, 0x16u);
    goto LABEL_52;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http_encoding_finalize_output_frames";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v15, &type, &v25))
      goto LABEL_66;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_66;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http_encoding_finalize_output_frames";
      v18 = "%{public}s called with null http_encoding";
      goto LABEL_65;
    }
    if (!v25)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_encoding_finalize_output_frames";
        v18 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_encoding_finalize_output_frames";
        v18 = "%{public}s called with null http_encoding, no backtrace";
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    if (!v23)
      goto LABEL_52;
    *(_DWORD *)buf = 136446466;
    v28 = "nw_protocol_http_encoding_finalize_output_frames";
    v29 = 2082;
    v30 = backtrace_string;
    v22 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
    goto LABEL_51;
  }
  if (a2)
  {
    if ((handle[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        v19 = __nwlog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v28 = "nw_protocol_http_encoding_finalize_output_frames";
          v29 = 2082;
          v30 = handle + 114;
          v31 = 2080;
          v32 = " ";
          _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }
    v4 = handle[648];
    if ((v4 & 0x11111111) == 0)
    {
      handle[648] = v4 | 0x10;
      tqh_first = a2->tqh_first;
      if (nw_protocol_copy_http_definition_onceToken != -1)
        dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72660);
      v6 = (id)nw_protocol_copy_http_definition_http_definition;
      v7 = nw_frame_copy_metadata_for_protocol((uint64_t)tqh_first, (uint64_t)v6);
      v8 = nw_http_metadata_copy_request(v7);
      if (nw_http_request_has_method(v8, (uint64_t)"HEAD"))
        v9 = 2;
      else
        v9 = 0;
      handle[648] = handle[648] & 0xFD | v9;
      if (!nw_http_fields_have_field_with_name(v8, (unint64_t)"Accept-Encoding"))
      {
        parameters = (void *)nw_protocol_get_parameters((uint64_t)handle);
        v11 = nw_parameters_copy_url_endpoint(parameters);
        url_scheme = (const char *)nw_endpoint_get_url_scheme(v11);
        v13 = "gzip, deflate, br";
        if (strcasecmp(url_scheme, "https") && strcasecmp(url_scheme, "wss"))
          v13 = "gzip, deflate";
        nw_http_fields_append(v8, (uint64_t)"Accept-Encoding", (uint64_t)v13);
        if (v11)
          os_release(v11);
      }
      if (v8)
        os_release(v8);
      if (v7)
        os_release(v7);
      if (v6)
        os_release(v6);
    }
    return nw_protocol_finalize_output_frames(*((_QWORD *)handle + 4), (uint64_t)a2);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_protocol_http_encoding_finalize_output_frames";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v15, &type, &v25))
    goto LABEL_66;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v25)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_encoding_finalize_output_frames";
        v18 = "%{public}s called with null frames, backtrace limit exceeded";
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v24 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_encoding_finalize_output_frames";
        v18 = "%{public}s called with null frames, no backtrace";
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v28 = "nw_protocol_http_encoding_finalize_output_frames";
      v29 = 2082;
      v30 = backtrace_string;
      v22 = "%{public}s called with null frames, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
LABEL_52:
    free(backtrace_string);
    goto LABEL_66;
  }
  v16 = __nwlog_obj();
  v17 = type;
  if (os_log_type_enabled(v16, type))
  {
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http_encoding_finalize_output_frames";
    v18 = "%{public}s called with null frames";
    goto LABEL_65;
  }
LABEL_66:
  if (v15)
    free(v15);
  return 0;
}

uint64_t nw_protocol_http_encoding_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  void *handle;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  const char *v11;
  _BOOL4 v12;
  _QWORD v13[5];
  char v14;
  _QWORD v15[5];
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 0x40000000;
      v15[2] = ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v15[3] = &__block_descriptor_tmp_54_33074;
      v15[4] = handle;
      v13[0] = MEMORY[0x1E0C809B0];
      v13[1] = 0x40000000;
      v13[2] = ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
      v13[3] = &__block_descriptor_tmp_55_33075;
      v14 = a3;
      v13[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v15, (uint64_t)v13);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http_encoding_remove_input_handler";
    v5 = (char *)_os_log_send_and_compose_impl();
    v17 = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v5, &v17, &v16))
      goto LABEL_32;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_encoding_remove_input_handler";
        v8 = "%{public}s called with null http_encoding";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v16)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_encoding_remove_input_handler";
        v8 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = v17;
    v12 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_encoding_remove_input_handler";
        v8 = "%{public}s called with null http_encoding, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_http_encoding_remove_input_handler";
      v20 = 2082;
      v21 = backtrace_string;
      v11 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_http_encoding_remove_input_handler";
  v5 = (char *)_os_log_send_and_compose_impl();
  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v5, &v17, &v16))
    goto LABEL_32;
  if (v17 != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      v6 = __nwlog_obj();
      v7 = v17;
      if (os_log_type_enabled(v6, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_encoding_remove_input_handler";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = v17;
    v10 = os_log_type_enabled(v6, v17);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_http_encoding_remove_input_handler";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_http_encoding_remove_input_handler";
      v20 = 2082;
      v21 = backtrace_string;
      v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v6, v7, v11, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v6 = __nwlog_obj();
  v7 = v17;
  if (os_log_type_enabled(v6, v17))
  {
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_http_encoding_remove_input_handler";
    v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
  }
LABEL_32:
  if (v5)
    free(v5);
  return 0;
}

void ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  NSObject *v11;
  NSObject *v12;
  _BOOL4 v13;
  _QWORD v14[2];
  uint64_t (*v15)(_QWORD *);
  void *v16;
  uint64_t v17;
  _BYTE buf[24];
  const char *v19;
  _QWORD *v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 608);
  if (gLogDatapath)
  {
    v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  v3 = MEMORY[0x1E0C809B0];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33090;
  v19 = (const char *)&__block_descriptor_tmp_38_33091;
  v20 = v2;
  v21 = 0;
  v4 = *v2;
  do
  {
    if (!v4)
      break;
    v5 = *(_QWORD *)(v4 + 32);
    v6 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v4 = v5;
  }
  while ((v6 & 1) != 0);
  v7 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v7 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v12 = __nwlog_obj();
      v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
      v7 = *(_QWORD *)(a1 + 32);
      if (v13)
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_remove_input_handler_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v7 + 114;
        *(_WORD *)&buf[22] = 2080;
        v19 = " ";
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sremoving finalized_output_frames", buf, 0x20u);
        v7 = *(_QWORD *)(a1 + 32);
      }
    }
  }
  v14[0] = v3;
  v14[1] = 0x40000000;
  v15 = (uint64_t (*)(_QWORD *))___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_52;
  v16 = &__block_descriptor_tmp_53_33093;
  v17 = v7;
  v8 = *(_QWORD *)(v7 + 592);
  do
  {
    if (!v8)
      break;
    v9 = *(_QWORD *)(v8 + 32);
    v10 = v15(v14);
    v8 = v9;
  }
  while ((v10 & 1) != 0);
  nw_frame_cache_remove_all((uint64_t *)(*(_QWORD *)(a1 + 32) + 432));
}

void ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  void (***v12)(_QWORD);
  void (***v13)(_QWORD);
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  NSObject *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  NSObject *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  char *backtrace_string;
  _BOOL4 v36;
  char *v37;
  _BOOL4 v38;
  char *v39;
  _BOOL4 v40;
  char v41;
  os_log_type_t type;
  uint8_t v43[4];
  const char *v44;
  __int16 v45;
  char *v46;
  _BYTE buf[24];
  const char *v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 40))
    return;
  v1 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v1 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_encoding_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v1 + 114;
        *(_WORD *)&buf[22] = 2080;
        v48 = " ";
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
  }
  if ((*(_BYTE *)(v1 + 198) & 1) == 0)
  {
    if (!gLogDatapath)
      goto LABEL_6;
    v33 = __nwlog_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_http_encoding_destroy";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v1 + 114;
      *(_WORD *)&buf[22] = 2080;
      v48 = " ";
      _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sfinalizing frame arrays", buf, 0x20u);
    }
  }
  if (gLogDatapath)
  {
    v34 = __nwlog_obj();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s called", v43, 0xCu);
    }
  }
LABEL_6:
  v2 = MEMORY[0x1E0C809B0];
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33080;
  v48 = (const char *)&__block_descriptor_tmp_56_33081;
  v49 = 0;
  v3 = *(_QWORD *)(v1 + 560);
  do
  {
    if (!v3)
      break;
    v4 = *(_QWORD *)(v3 + 16);
    v5 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v3 = v4;
  }
  while ((v5 & 1) != 0);
  if (!*(_QWORD *)(v1 + 560))
    goto LABEL_10;
  __nwlog_obj();
  *(_DWORD *)v43 = 136446210;
  v44 = "nw_protocol_finalize_master_frame_array";
  v18 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v18, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_85;
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v21 = "%{public}s frame array is not empty after finalize";
      goto LABEL_84;
    }
    if (!v41)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_85;
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v21 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
      goto LABEL_84;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v36 = os_log_type_enabled(v19, type);
    if (backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)v43 = 136446466;
        v44 = "nw_protocol_finalize_master_frame_array";
        v45 = 2082;
        v46 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s", v43, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_85;
    }
    if (v36)
    {
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v21 = "%{public}s frame array is not empty after finalize, no backtrace";
LABEL_84:
      _os_log_impl(&dword_182FBE000, v19, v20, v21, v43, 0xCu);
    }
  }
LABEL_85:
  if (v18)
    free(v18);
LABEL_10:
  if (gLogDatapath)
  {
    v22 = __nwlog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_finalize_master_frame_array";
      _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  *(_QWORD *)buf = v2;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33080;
  v48 = (const char *)&__block_descriptor_tmp_56_33081;
  v49 = 0;
  v6 = *(_QWORD *)(v1 + 576);
  do
  {
    if (!v6)
      break;
    v7 = *(_QWORD *)(v6 + 16);
    v8 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v6 = v7;
  }
  while ((v8 & 1) != 0);
  if (*(_QWORD *)(v1 + 576))
  {
    __nwlog_obj();
    *(_DWORD *)v43 = 136446210;
    v44 = "nw_protocol_finalize_master_frame_array";
    v23 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v23, &type, &v41))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_90;
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v26 = "%{public}s frame array is not empty after finalize";
    }
    else if (v41)
    {
      v37 = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v38 = os_log_type_enabled(v24, type);
      if (v37)
      {
        if (v38)
        {
          *(_DWORD *)v43 = 136446466;
          v44 = "nw_protocol_finalize_master_frame_array";
          v45 = 2082;
          v46 = v37;
          _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s", v43, 0x16u);
        }
        free(v37);
        goto LABEL_90;
      }
      if (!v38)
      {
LABEL_90:
        if (v23)
          free(v23);
        goto LABEL_15;
      }
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v26 = "%{public}s frame array is not empty after finalize, no backtrace";
    }
    else
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_90;
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v26 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v24, v25, v26, v43, 0xCu);
    goto LABEL_90;
  }
LABEL_15:
  if (gLogDatapath)
  {
    v27 = __nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_finalize_master_frame_array";
      _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  *(_QWORD *)buf = v2;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33080;
  v48 = (const char *)&__block_descriptor_tmp_56_33081;
  v49 = 0;
  v9 = *(_QWORD *)(v1 + 624);
  do
  {
    if (!v9)
      break;
    v10 = *(_QWORD *)(v9 + 16);
    v11 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v9 = v10;
  }
  while ((v11 & 1) != 0);
  if (!*(_QWORD *)(v1 + 624))
    goto LABEL_20;
  __nwlog_obj();
  *(_DWORD *)v43 = 136446210;
  v44 = "nw_protocol_finalize_master_frame_array";
  v28 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v28, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_95;
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v31 = "%{public}s frame array is not empty after finalize";
      goto LABEL_94;
    }
    if (!v41)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_95;
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v31 = "%{public}s frame array is not empty after finalize, backtrace limit exceeded";
      goto LABEL_94;
    }
    v39 = (char *)__nw_create_backtrace_string();
    v29 = __nwlog_obj();
    v30 = type;
    v40 = os_log_type_enabled(v29, type);
    if (v39)
    {
      if (v40)
      {
        *(_DWORD *)v43 = 136446466;
        v44 = "nw_protocol_finalize_master_frame_array";
        v45 = 2082;
        v46 = v39;
        _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s frame array is not empty after finalize, dumping backtrace:%{public}s", v43, 0x16u);
      }
      free(v39);
      goto LABEL_95;
    }
    if (v40)
    {
      *(_DWORD *)v43 = 136446210;
      v44 = "nw_protocol_finalize_master_frame_array";
      v31 = "%{public}s frame array is not empty after finalize, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v29, v30, v31, v43, 0xCu);
    }
  }
LABEL_95:
  if (v28)
    free(v28);
LABEL_20:
  nw_frame_cache_destroy((uint64_t *)(v1 + 432));
  v12 = *(void (****)(_QWORD))(v1 + 552);
  if (v12)
  {
    (**v12)(*(_QWORD *)(v1 + 552));
    free(v12);
    *(_QWORD *)(v1 + 552) = 0;
  }
  v13 = *(void (****)(_QWORD))(v1 + 544);
  if (v13)
  {
    (**v13)(*(_QWORD *)(v1 + 544));
    free(v13);
    *(_QWORD *)(v1 + 544) = 0;
  }
  if ((*(_BYTE *)(v1 + 536) & 1) != 0)
  {
    v14 = *(void **)(v1 + 528);
    if (v14)
      os_release(v14);
  }
  *(_QWORD *)(v1 + 528) = 0;
  if ((*(_BYTE *)(v1 + 520) & 1) != 0)
  {
    v15 = *(void **)(v1 + 512);
    if (v15)
      os_release(v15);
  }
  *(_QWORD *)(v1 + 512) = 0;
  if ((*(_BYTE *)(v1 + 504) & 1) != 0)
  {
    v16 = *(void **)(v1 + 496);
    if (v16)
      os_release(v16);
  }
  *(_QWORD *)(v1 + 496) = 0;
  if ((*(_BYTE *)(v1 + 488) & 1) != 0)
  {
    v17 = *(void **)(v1 + 480);
    if (v17)
      os_release(v17);
  }
  *(_QWORD *)(v1 + 480) = 0;
  nw_protocol_plugin_retry::~nw_protocol_plugin_retry((nw_protocol_plugin_retry *)(v1 + 216));
  free((void *)v1);
}

uint64_t ___ZL39nw_protocol_finalize_master_frame_arrayP16nw_frame_array_sb_block_invoke_33080(uint64_t a1, uint64_t a2)
{
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33090(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL46nw_protocol_http_encoding_remove_input_handlerP11nw_protocolS0_b_block_invoke_52(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  _QWORD *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a2[4];
  v4 = (_QWORD *)a2[5];
  if (v3)
  {
    *(_QWORD *)(v3 + 40) = v4;
    v4 = (_QWORD *)a2[5];
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 600) = v4;
  }
  *v4 = v3;
  a2[4] = 0;
  a2[5] = 0;
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    if ((*(_BYTE *)(v5 + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v11 = __nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          v17 = "nw_http_encoding_outbound_frame_return_to_cache";
          v18 = 2082;
          v19 = (char *)(v5 + 114);
          v20 = 2080;
          v21 = " ";
          v22 = 2048;
          v23 = a2;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sreturning frame %p to cache", buf, 0x2Au);
        }
      }
    }
    a2[10] = 0;
    a2[11] = 0;
    nw_frame_cache_return_frame(v5 + 432, (uint64_t)a2);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_http_encoding_outbound_frame_return_to_cache";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_http_encoding_outbound_frame_return_to_cache";
      v10 = "%{public}s called with null http_encoding";
      goto LABEL_24;
    }
    if (!v14)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_http_encoding_outbound_frame_return_to_cache";
      v10 = "%{public}s called with null http_encoding, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v13 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v17 = "nw_http_encoding_outbound_frame_return_to_cache";
        v18 = 2082;
        v19 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null http_encoding, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_25;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_http_encoding_outbound_frame_return_to_cache";
      v10 = "%{public}s called with null http_encoding, no backtrace";
LABEL_24:
      _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    }
  }
LABEL_25:
  if (v7)
    free(v7);
  return 1;
}

__n128 __Block_byref_object_copy__19_33137(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t __Block_byref_object_copy__21(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

BOOL ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2)
{
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  char v8;
  void *v9;
  _BOOL4 status_code;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  _QWORD *v15;
  unsigned int v16;
  uint64_t v17;
  _BOOL8 gzip;
  void (***v19)(_QWORD);
  uint64_t v20;
  void (***v21)(_QWORD);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  char *backtrace_string;
  _BOOL4 v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  char v35;
  NSObject *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  _BOOL8 frame;
  uint64_t v50;
  _BOOL8 *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  NSObject *v60;
  _BOOL4 v61;
  uint64_t v62;
  const char *v63;
  int v64;
  _BOOL8 deflate;
  void (***v66)(_QWORD, uint64_t);
  void (***v67)(_QWORD, uint64_t);
  char *v68;
  NSObject *v69;
  os_log_type_t v70;
  NSObject *v71;
  os_log_type_t v72;
  const char *v73;
  NSObject *v74;
  os_log_type_t v75;
  NSObject *v76;
  _BOOL4 v77;
  uint64_t v78;
  uint64_t v79;
  NSObject *v80;
  char *v81;
  NSObject *v82;
  os_log_type_t v83;
  _BOOL4 v84;
  NSObject *v85;
  os_log_type_t v86;
  const char *v87;
  NSObject *v88;
  os_log_type_t v89;
  _BOOL4 v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  NSObject *v94;
  os_log_type_t v95;
  const char *v96;
  NSObject *v97;
  os_log_type_t v98;
  NSObject *v99;
  NSObject *v100;
  os_log_type_t v101;
  NSObject *v102;
  os_log_type_t v103;
  char *v104;
  NSObject *v105;
  os_log_type_t v106;
  _BOOL4 v107;
  NSObject *v108;
  os_log_type_t v109;
  const char *v110;
  NSObject *v111;
  os_log_type_t v112;
  _BOOL4 v113;
  NSObject *v114;
  os_log_type_t v115;
  NSObject *v116;
  os_log_type_t v117;
  uint64_t v118;
  uint64_t v119;
  const char *v120;
  uint64_t v121;
  char *v122;
  uint64_t v123;
  os_log_type_t v124;
  const char *v125;
  uint64_t v126;
  const char *v127;
  NSObject *v128;
  _BOOL4 v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  char *v136;
  uint64_t v137;
  os_log_type_t v138;
  uint64_t v139;
  const char *v140;
  char *v141;
  NSObject *v142;
  os_log_type_t v143;
  _BOOL4 v144;
  uint64_t v145;
  char *v146;
  NSObject *v147;
  os_log_type_t v148;
  _BOOL4 v149;
  const char *v150;
  uint64_t v151;
  uint64_t v152;
  NSObject *v153;
  os_log_type_t v154;
  _BOOL8 v155;
  uint64_t v156;
  const char *v157;
  uint64_t v158;
  NSObject *v159;
  os_log_type_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  char v166;
  uint64_t *v167;
  uint64_t v168;
  uint64_t v169;
  char v170;
  const char *v172;
  uint64_t v173;
  NSObject *v174;
  NSObject *v175;
  uint64_t v176;
  uint64_t v177;
  int v178;
  char *v179;
  NSObject *v180;
  os_log_type_t v181;
  const char *v182;
  char *v183;
  NSObject *v184;
  os_log_type_t v185;
  _BOOL4 v186;
  char *v187;
  NSObject *v188;
  os_log_type_t v189;
  const char *v190;
  NSObject *v191;
  uint64_t v192;
  uint64_t v193;
  const char *v194;
  char *v195;
  _BOOL4 v196;
  char *v197;
  _BOOL4 v198;
  NSObject *v199;
  os_log_type_t v200;
  uint64_t v201;
  const char *v202;
  os_log_t log;
  os_log_t loga;
  os_log_t logb;
  os_log_t logc;
  void *v207;
  uint64_t v208;
  unsigned int v209;
  _QWORD v210[2];
  uint64_t (*v211)(_QWORD *);
  void *v212;
  uint64_t *v213;
  _BYTE *v214;
  uint64_t v215;
  __int128 v216;
  uint64_t v217;
  _QWORD v218[7];
  uint64_t v219;
  uint64_t *v220;
  uint64_t v221;
  uint64_t v222;
  unsigned __int8 v223;
  _QWORD v224[6];
  char v225;
  os_log_type_t v226;
  _BYTE v227[24];
  const char *v228;
  _BYTE v229[12];
  char *v230;
  _BYTE buf[24];
  uint64_t v232;
  _BYTE v233[24];
  uint64_t v234;

  v234 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    v26 = (char *)_os_log_send_and_compose_impl();
    v227[0] = 16;
    LOBYTE(v224[0]) = 0;
    if (__nwlog_fault(v26, v227, v224))
    {
      if (v227[0] == 17)
      {
        v27 = __nwlog_obj();
        v28 = v227[0];
        if (os_log_type_enabled(v27, (os_log_type_t)v227[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          v29 = "%{public}s called with null frame";
LABEL_249:
          _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
        }
      }
      else if (LOBYTE(v224[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v27 = __nwlog_obj();
        v28 = v227[0];
        v31 = os_log_type_enabled(v27, (os_log_type_t)v227[0]);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_250;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          v29 = "%{public}s called with null frame, no backtrace";
          goto LABEL_249;
        }
      }
      else
      {
        v27 = __nwlog_obj();
        v28 = v227[0];
        if (os_log_type_enabled(v27, (os_log_type_t)v227[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          v29 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_249;
        }
      }
    }
LABEL_250:
    if (v26)
      free(v26);
    return 0;
  }
  v4 = nw_frame_copy_metadata_for_protocol(a2, *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 40));
  v5 = v4;
  if (*(void **)(a1[7] + 496) == v4)
    goto LABEL_26;
  v6 = nw_http_metadata_copy_response(v4);
  v7 = a1[7];
  v8 = *(_BYTE *)(v7 + 504);
  if ((v8 & 1) != 0)
  {
    v9 = *(void **)(v7 + 496);
    if (v9)
    {
      os_release(v9);
      v8 = *(_BYTE *)(v7 + 504);
    }
  }
  *(_QWORD *)(v7 + 496) = v5;
  *(_BYTE *)(v7 + 504) = v8 | 1;
  status_code = nw_http_response_get_status_code(v6);
  if (v6)
  {
    if ((status_code - 200) > 0xFFFFFF9B || (v11 = a1[7], (*(_BYTE *)(v11 + 648) & 2) != 0))
    {
LABEL_24:
      os_release(v6);
      goto LABEL_25;
    }
    v12 = *(void **)(v11 + 496);
    if (v12)
    {
      v13 = nw_http_metadata_copy_header_fields(v12);
      if (v13)
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        LODWORD(v232) = 1;
        *(_QWORD *)&buf[16] = 0x2000000000;
        v224[0] = MEMORY[0x1E0C809B0];
        v224[1] = 0x40000000;
        v224[2] = ___ZL33nw_http_encoding_get_content_typeP25nw_protocol_http_encodingP20nw_protocol_metadata_block_invoke;
        v224[3] = &unk_1E14A00E8;
        v224[4] = buf;
        v224[5] = v11;
        v14 = v13;
        v15 = v224;
        _nw_http_fields_access_value_by_name((uint64_t)v14, (unint64_t)"Content-Encoding", v15);

        v16 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
        _Block_object_dispose(buf, 8);
        os_release(v14);
        v17 = a1[7];
        *(_DWORD *)(v17 + 644) = 1;
        switch(v16)
        {
          case 2u:
            v16 = 2;
            gzip = nw_decoder_create_gzip();
            goto LABEL_17;
          case 3u:
            *(_DWORD *)(v17 + 644) = 4;
            v16 = 3;
            gzip = nw_decoder_create_deflate();
            goto LABEL_17;
          case 4u:
            v16 = 4;
            gzip = nw_decoder_create_raw_deflate();
            goto LABEL_17;
          case 5u:
            v16 = 5;
            gzip = nw_decoder_create_brotli();
LABEL_17:
            v19 = (void (***)(_QWORD))gzip;
            break;
          default:
            v19 = 0;
            break;
        }
        goto LABEL_18;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
      v187 = (char *)_os_log_send_and_compose_impl();
      v227[0] = 16;
      LOBYTE(v224[0]) = 0;
      if (__nwlog_fault(v187, v227, v224))
      {
        if (v227[0] == 17)
        {
          v188 = __nwlog_obj();
          v189 = v227[0];
          if (!os_log_type_enabled(v188, (os_log_type_t)v227[0]))
            goto LABEL_297;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
          v190 = "%{public}s called with null header_fields";
          goto LABEL_296;
        }
        if (!LOBYTE(v224[0]))
        {
          v188 = __nwlog_obj();
          v189 = v227[0];
          if (!os_log_type_enabled(v188, (os_log_type_t)v227[0]))
            goto LABEL_297;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
          v190 = "%{public}s called with null header_fields, backtrace limit exceeded";
          goto LABEL_296;
        }
        v197 = (char *)__nw_create_backtrace_string();
        v188 = __nwlog_obj();
        v189 = v227[0];
        v198 = os_log_type_enabled(v188, (os_log_type_t)v227[0]);
        if (!v197)
        {
          if (!v198)
            goto LABEL_297;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
          v190 = "%{public}s called with null header_fields, no backtrace";
          goto LABEL_296;
        }
        if (v198)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v197;
          _os_log_impl(&dword_182FBE000, v188, v189, "%{public}s called with null header_fields, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v197);
      }
LABEL_297:
      if (!v187)
      {
LABEL_299:
        v16 = 0;
        v19 = 0;
        *(_DWORD *)(a1[7] + 644) = 1;
LABEL_18:
        v20 = a1[7];
        v21 = *(void (****)(_QWORD))(v20 + 544);
        if (v21 != v19)
        {
          if (v21)
          {
            (**v21)(*(_QWORD *)(v20 + 544));
            free(v21);
          }
          *(_QWORD *)(v20 + 544) = v19;
          v20 = a1[7];
        }
        if ((*(_BYTE *)(v20 + 198) & 1) == 0)
        {
          if (gLogDatapath)
          {
            v191 = __nwlog_obj();
            if (os_log_type_enabled(v191, OS_LOG_TYPE_DEBUG))
            {
              v192 = a1[7];
              v193 = v192 + 114;
              if (v16 > 5)
                v194 = "<unknown>";
              else
                v194 = off_1E14AA448[v16];
              v201 = *(unsigned int *)(v192 + 644);
              if (v201 > 5)
                v202 = "<unknown>";
              else
                v202 = off_1E14AA448[v201];
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v193;
              *(_WORD *)&buf[22] = 2080;
              v232 = (uint64_t)" ";
              *(_WORD *)v233 = 2080;
              *(_QWORD *)&v233[2] = v194;
              *(_WORD *)&v233[10] = 2080;
              *(_QWORD *)&v233[12] = v202;
              _os_log_impl(&dword_182FBE000, v191, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sfound encoding %s, alternative encoding %s", buf, 0x34u);
            }
          }
        }
        goto LABEL_24;
      }
LABEL_298:
      free(v187);
      goto LABEL_299;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
    v187 = (char *)_os_log_send_and_compose_impl();
    v227[0] = 16;
    LOBYTE(v224[0]) = 0;
    if (!__nwlog_fault(v187, v227, v224))
      goto LABEL_297;
    if (v227[0] == 17)
    {
      v188 = __nwlog_obj();
      v189 = v227[0];
      if (!os_log_type_enabled(v188, (os_log_type_t)v227[0]))
        goto LABEL_297;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
      v190 = "%{public}s called with null http_metadata";
    }
    else
    {
      if (!LOBYTE(v224[0]))
      {
        v188 = __nwlog_obj();
        v189 = v227[0];
        if (!os_log_type_enabled(v188, (os_log_type_t)v227[0]))
          goto LABEL_297;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
        v190 = "%{public}s called with null http_metadata, backtrace limit exceeded";
        goto LABEL_296;
      }
      v195 = (char *)__nw_create_backtrace_string();
      v188 = __nwlog_obj();
      v189 = v227[0];
      v196 = os_log_type_enabled(v188, (os_log_type_t)v227[0]);
      if (v195)
      {
        if (v196)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v195;
          _os_log_impl(&dword_182FBE000, v188, v189, "%{public}s called with null http_metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v195);
        if (!v187)
          goto LABEL_299;
        goto LABEL_298;
      }
      if (!v196)
        goto LABEL_297;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_encoding_get_content_type";
      v190 = "%{public}s called with null http_metadata, no backtrace";
    }
LABEL_296:
    _os_log_impl(&dword_182FBE000, v188, v189, v190, buf, 0xCu);
    goto LABEL_297;
  }
LABEL_25:
  v5 = 0;
LABEL_26:
  v22 = *(_QWORD *)(a2 + 112);
  if (v22)
  {
    if ((*(_WORD *)(a2 + 204) & 0x100) == 0
      || !g_channel_check_validity
      || g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
    {
      LODWORD(v22) = *(_DWORD *)(a2 + 52);
      v23 = *(unsigned int *)(a2 + 56);
      if ((_DWORD)v22)
        LODWORD(v22) = v22 - (v23 + *(_DWORD *)(a2 + 60));
      v24 = *(_QWORD *)(a2 + 112) + v23;
      v25 = *(_QWORD *)(a2 + 64);
      if (v25)
        goto LABEL_33;
      goto LABEL_45;
    }
    LODWORD(v22) = 0;
  }
  v24 = 0;
  v25 = *(_QWORD *)(a2 + 64);
  if (v25)
  {
LABEL_33:
    v209 = (*(unsigned __int8 *)(v25 + 66) >> 6) & 1;
    goto LABEL_46;
  }
LABEL_45:
  v209 = 0;
LABEL_46:
  v32 = a1[7];
  v33 = *(_QWORD *)(v32 + 544);
  if (v33)
    v34 = (_DWORD)v22 == 0;
  else
    v34 = 1;
  if (v34)
  {
    v35 = v209 ^ 1;
    if (!v33)
      v35 = 1;
    if ((v35 & 1) == 0 && (*(_BYTE *)(v32 + 648) & 0x24) == 4 && (*(_BYTE *)(v32 + 198) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v37 = a1[7] + 114;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2080;
        v232 = (uint64_t)" ";
        _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%smetadata completed before decoder completed", buf, 0x20u);
      }
    }
    v39 = *(_QWORD *)(a2 + 32);
    v40 = *(_QWORD **)(a2 + 40);
    v38 = (_QWORD *)(a2 + 32);
    if (v39)
    {
      *(_QWORD *)(v39 + 40) = v40;
      v40 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 48) = v40;
    }
    *v40 = v39;
    *v38 = 0;
    *(_QWORD *)(a2 + 40) = 0;
    v130 = a1[9];
    v131 = *(uint64_t **)(v130 + 8);
    *(_QWORD *)(a2 + 40) = v131;
    *v131 = a2;
    *(_QWORD *)(v130 + 8) = v38;
    v132 = *(_QWORD *)(a1[5] + 8);
    v133 = *(unsigned int *)(v132 + 24) + 1;
    v134 = v133 << 31 >> 31;
    *(_DWORD *)(v132 + 24) = v133;
    if (v134 == v133 && (v134 & 0x8000000000000000) == 0)
    {
LABEL_202:
      v155 = 1;
      if (v5)
        goto LABEL_226;
      return v155;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v135 = *(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = "count";
    *(_WORD *)&buf[22] = 2048;
    v232 = 1;
    *(_WORD *)v233 = 2048;
    *(_QWORD *)&v233[2] = v135;
    v136 = (char *)_os_log_send_and_compose_impl();
    v227[0] = 16;
    LOBYTE(v219) = 0;
    if (__nwlog_fault(v136, v227, &v219))
    {
      if (v227[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v137 = gLogObj;
        v138 = v227[0];
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v227[0]))
        {
          v139 = *(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v232 = 1;
          *(_WORD *)v233 = 2048;
          *(_QWORD *)&v233[2] = v139;
          v140 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_197:
          v153 = v137;
          v154 = v138;
LABEL_198:
          _os_log_impl(&dword_182FBE000, v153, v154, v140, buf, 0x2Au);
        }
      }
      else if ((_BYTE)v219)
      {
        v141 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v142 = gLogObj;
        v143 = v227[0];
        v144 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v227[0]);
        if (v141)
        {
          if (v144)
          {
            v145 = *(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "count";
            *(_WORD *)&buf[22] = 2048;
            v232 = 1;
            *(_WORD *)v233 = 2048;
            *(_QWORD *)&v233[2] = v145;
            *(_WORD *)&v233[10] = 2082;
            *(_QWORD *)&v233[12] = v141;
            _os_log_impl(&dword_182FBE000, v142, v143, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v141);
          goto LABEL_199;
        }
        if (v144)
        {
          v156 = *(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v232 = 1;
          *(_WORD *)v233 = 2048;
          *(_QWORD *)&v233[2] = v156;
          v140 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          v153 = v142;
          v154 = v143;
          goto LABEL_198;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v137 = gLogObj;
        v138 = v227[0];
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v227[0]))
        {
          v152 = *(unsigned int *)(*(_QWORD *)(a1[5] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "count";
          *(_WORD *)&buf[22] = 2048;
          v232 = 1;
          *(_WORD *)v233 = 2048;
          *(_QWORD *)&v233[2] = v152;
          v140 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_197;
        }
      }
    }
LABEL_199:
    if (v136)
      free(v136);
    *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = -1;
    goto LABEL_202;
  }
  v207 = v5;
  *(_BYTE *)(v32 + 648) |= 4u;
  v41 = a1[7];
  v42 = (*(unsigned __int8 *)(v41 + 648) >> 5) & 1;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  v208 = v22;
  v43 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[16] = 0x3802000000;
  v232 = (uint64_t)__Block_byref_object_copy__19_33137;
  *(_QWORD *)v233 = __Block_byref_object_dispose__20_33138;
  *(_QWORD *)&v233[8] = 0;
  *(_QWORD *)&v233[16] = &v233[8];
  v223 = v42;
  v219 = 0;
  v220 = &v219;
  v221 = 0x2000000000;
  v222 = 0;
  while (1)
  {
    v44 = *(_QWORD *)(v41 + 544);
    v218[0] = v43;
    v218[1] = 0x40000000;
    v218[2] = ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_23;
    v218[3] = &unk_1E14A0050;
    v218[5] = v41;
    v218[6] = a2;
    v218[4] = buf;
    if (v44)
    {
      if (v24)
      {
        if (v223)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v45 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v227 = 136446210;
            *(_QWORD *)&v227[4] = "nw_decoder_decode";
            _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_ERROR, "%{public}s extra data", v227, 0xCu);
          }
          v46 = 0;
        }
        else
        {
          v46 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, unsigned __int8 *, _QWORD *))(*(_QWORD *)v44 + 16))(v44, v24, v208, v209, &v223, v218);
        }
        goto LABEL_68;
      }
      __nwlog_obj();
      *(_DWORD *)v227 = 136446210;
      *(_QWORD *)&v227[4] = "nw_decoder_decode";
      v68 = (char *)_os_log_send_and_compose_impl();
      v226 = OS_LOG_TYPE_ERROR;
      v225 = 0;
      if (!__nwlog_fault(v68, &v226, &v225))
        goto LABEL_144;
      if (v226 != OS_LOG_TYPE_FAULT)
      {
        if (!v225)
        {
          v102 = __nwlog_obj();
          v103 = v226;
          if (os_log_type_enabled(v102, v226))
          {
            *(_DWORD *)v227 = 136446210;
            *(_QWORD *)&v227[4] = "nw_decoder_decode";
            v71 = v102;
            v72 = v103;
            v73 = "%{public}s called with null in_bytes, backtrace limit exceeded";
            goto LABEL_143;
          }
          goto LABEL_144;
        }
        v81 = (char *)__nw_create_backtrace_string();
        v88 = __nwlog_obj();
        v89 = v226;
        loga = v88;
        v90 = os_log_type_enabled(v88, v226);
        if (!v81)
        {
          if (v90)
          {
            *(_DWORD *)v227 = 136446210;
            *(_QWORD *)&v227[4] = "nw_decoder_decode";
            v71 = loga;
            v72 = v89;
            v73 = "%{public}s called with null in_bytes, no backtrace";
            goto LABEL_143;
          }
          goto LABEL_144;
        }
        if (v90)
        {
          *(_DWORD *)v227 = 136446466;
          *(_QWORD *)&v227[4] = "nw_decoder_decode";
          *(_WORD *)&v227[12] = 2082;
          *(_QWORD *)&v227[14] = v81;
          v85 = loga;
          v86 = v89;
          v87 = "%{public}s called with null in_bytes, dumping backtrace:%{public}s";
LABEL_119:
          _os_log_impl(&dword_182FBE000, v85, v86, v87, v227, 0x16u);
        }
        goto LABEL_120;
      }
      v74 = __nwlog_obj();
      v75 = v226;
      if (os_log_type_enabled(v74, v226))
      {
        *(_DWORD *)v227 = 136446210;
        *(_QWORD *)&v227[4] = "nw_decoder_decode";
        v71 = v74;
        v72 = v75;
        v73 = "%{public}s called with null in_bytes";
        goto LABEL_143;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)v227 = 136446210;
      *(_QWORD *)&v227[4] = "nw_decoder_decode";
      v68 = (char *)_os_log_send_and_compose_impl();
      v226 = OS_LOG_TYPE_ERROR;
      v225 = 0;
      if (!__nwlog_fault(v68, &v226, &v225))
        goto LABEL_144;
      if (v226 == OS_LOG_TYPE_FAULT)
      {
        v69 = __nwlog_obj();
        v70 = v226;
        if (os_log_type_enabled(v69, v226))
        {
          *(_DWORD *)v227 = 136446210;
          *(_QWORD *)&v227[4] = "nw_decoder_decode";
          v71 = v69;
          v72 = v70;
          v73 = "%{public}s called with null decoder";
LABEL_143:
          _os_log_impl(&dword_182FBE000, v71, v72, v73, v227, 0xCu);
        }
      }
      else
      {
        if (v225)
        {
          v81 = (char *)__nw_create_backtrace_string();
          v82 = __nwlog_obj();
          v83 = v226;
          log = v82;
          v84 = os_log_type_enabled(v82, v226);
          if (!v81)
          {
            if (v84)
            {
              *(_DWORD *)v227 = 136446210;
              *(_QWORD *)&v227[4] = "nw_decoder_decode";
              v71 = log;
              v72 = v83;
              v73 = "%{public}s called with null decoder, no backtrace";
              goto LABEL_143;
            }
            goto LABEL_144;
          }
          if (v84)
          {
            *(_DWORD *)v227 = 136446466;
            *(_QWORD *)&v227[4] = "nw_decoder_decode";
            *(_WORD *)&v227[12] = 2082;
            *(_QWORD *)&v227[14] = v81;
            v85 = log;
            v86 = v83;
            v87 = "%{public}s called with null decoder, dumping backtrace:%{public}s";
            goto LABEL_119;
          }
LABEL_120:
          free(v81);
          goto LABEL_144;
        }
        v100 = __nwlog_obj();
        v101 = v226;
        if (os_log_type_enabled(v100, v226))
        {
          *(_DWORD *)v227 = 136446210;
          *(_QWORD *)&v227[4] = "nw_decoder_decode";
          v71 = v100;
          v72 = v101;
          v73 = "%{public}s called with null decoder, backtrace limit exceeded";
          goto LABEL_143;
        }
      }
    }
LABEL_144:
    if (v68)
      free(v68);
    v46 = -1;
LABEL_68:
    v220[3] = v46;
    v47 = v223;
    *(_BYTE *)(a1[7] + 648) = *(_BYTE *)(a1[7] + 648) & 0xDF | (32 * v223);
    if ((*(_BYTE *)(a1[7] + 198) & 1) == 0)
    {
      if (gLogDatapath)
      {
        v76 = __nwlog_obj();
        v77 = os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG);
        v47 = v223;
        if (v77)
        {
          v78 = a1[7] + 114;
          v79 = v220[3];
          *(_DWORD *)v227 = 136447234;
          *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&v227[12] = 2082;
          *(_QWORD *)&v227[14] = v78;
          *(_WORD *)&v227[22] = 2080;
          v228 = " ";
          *(_WORD *)v229 = 2048;
          *(_QWORD *)&v229[2] = v79;
          *(_WORD *)&v229[10] = 1024;
          LODWORD(v230) = v223;
          _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sdecoder decoded %zd bytes, complete %{BOOL}d", v227, 0x30u);
          v47 = v223;
        }
      }
    }
    if (v47 && !*(_QWORD *)(*(_QWORD *)&buf[8] + 40))
    {
      v48 = a1[7];
      if (v48)
      {
        if ((*(_BYTE *)(v48 + 198) & 1) == 0)
        {
          if (gLogDatapath)
          {
            v99 = __nwlog_obj();
            if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v227 = 136446978;
              *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
              *(_WORD *)&v227[12] = 2082;
              *(_QWORD *)&v227[14] = v48 + 114;
              *(_WORD *)&v227[22] = 2080;
              v228 = " ";
              *(_WORD *)v229 = 1024;
              *(_DWORD *)&v229[2] = 0;
              _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled for size %u", v227, 0x26u);
            }
          }
        }
        frame = nw_frame_cache_create_frame((uint64_t *)(v48 + 432), 0);
        if (frame)
        {
          v50 = frame;
          *(_QWORD *)(frame + 16) = 0;
          v51 = *(_BOOL8 **)(v48 + 568);
          *(_QWORD *)(frame + 24) = v51;
          *v51 = frame;
          *(_QWORD *)(v48 + 568) = frame + 16;
          *(_QWORD *)(frame + 80) = nw_http_encoding_inbound_frame_finalizer;
          *(_QWORD *)(frame + 88) = v48;
LABEL_77:
          nw_frame_inherit_metadata(a2, v50, 1);
          *(_BYTE *)(v50 + 186) |= 0x80u;
          v52 = *(_QWORD *)&buf[8];
          *(_QWORD *)(v50 + 32) = 0;
          v53 = *(uint64_t **)(v52 + 48);
          *(_QWORD *)(v50 + 40) = v53;
          *v53 = v50;
          *(_QWORD *)(v52 + 48) = v50 + 32;
          goto LABEL_78;
        }
        __nwlog_obj();
        *(_DWORD *)v227 = 136446210;
        *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
        v91 = (char *)_os_log_send_and_compose_impl();
        v226 = OS_LOG_TYPE_ERROR;
        v225 = 0;
        if (!__nwlog_fault(v91, &v226, &v225))
          goto LABEL_162;
        if (v226 == OS_LOG_TYPE_FAULT)
        {
          v97 = __nwlog_obj();
          v98 = v226;
          if (os_log_type_enabled(v97, v226))
          {
            *(_DWORD *)v227 = 136446210;
            *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
            v94 = v97;
            v95 = v98;
            v96 = "%{public}s called with null frame";
            goto LABEL_161;
          }
LABEL_162:
          if (v91)
            free(v91);
          v50 = 0;
          goto LABEL_77;
        }
        if (v225)
        {
          v104 = (char *)__nw_create_backtrace_string();
          v111 = __nwlog_obj();
          v112 = v226;
          logc = v111;
          v113 = os_log_type_enabled(v111, v226);
          if (v104)
          {
            if (v113)
            {
              *(_DWORD *)v227 = 136446466;
              *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
              *(_WORD *)&v227[12] = 2082;
              *(_QWORD *)&v227[14] = v104;
              v108 = logc;
              v109 = v112;
              v110 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_151:
              _os_log_impl(&dword_182FBE000, v108, v109, v110, v227, 0x16u);
            }
            goto LABEL_152;
          }
          if (!v113)
            goto LABEL_162;
          *(_DWORD *)v227 = 136446210;
          *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
          v94 = logc;
          v95 = v112;
          v96 = "%{public}s called with null frame, no backtrace";
        }
        else
        {
          v116 = __nwlog_obj();
          v117 = v226;
          if (!os_log_type_enabled(v116, v226))
            goto LABEL_162;
          *(_DWORD *)v227 = 136446210;
          *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
          v94 = v116;
          v95 = v117;
          v96 = "%{public}s called with null frame, backtrace limit exceeded";
        }
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)v227 = 136446210;
        *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
        v91 = (char *)_os_log_send_and_compose_impl();
        v226 = OS_LOG_TYPE_ERROR;
        v225 = 0;
        if (!__nwlog_fault(v91, &v226, &v225))
          goto LABEL_162;
        if (v226 == OS_LOG_TYPE_FAULT)
        {
          v92 = __nwlog_obj();
          v93 = v226;
          if (os_log_type_enabled(v92, v226))
          {
            *(_DWORD *)v227 = 136446210;
            *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
            v94 = v92;
            v95 = v93;
            v96 = "%{public}s called with null http_encoding";
            goto LABEL_161;
          }
          goto LABEL_162;
        }
        if (v225)
        {
          v104 = (char *)__nw_create_backtrace_string();
          v105 = __nwlog_obj();
          v106 = v226;
          logb = v105;
          v107 = os_log_type_enabled(v105, v226);
          if (v104)
          {
            if (v107)
            {
              *(_DWORD *)v227 = 136446466;
              *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
              *(_WORD *)&v227[12] = 2082;
              *(_QWORD *)&v227[14] = v104;
              v108 = logb;
              v109 = v106;
              v110 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
              goto LABEL_151;
            }
LABEL_152:
            free(v104);
            goto LABEL_162;
          }
          if (!v107)
            goto LABEL_162;
          *(_DWORD *)v227 = 136446210;
          *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
          v94 = logb;
          v95 = v106;
          v96 = "%{public}s called with null http_encoding, no backtrace";
        }
        else
        {
          v114 = __nwlog_obj();
          v115 = v226;
          if (!os_log_type_enabled(v114, v226))
            goto LABEL_162;
          *(_DWORD *)v227 = 136446210;
          *(_QWORD *)&v227[4] = "nw_http_encoding_create_inbound_frame";
          v94 = v114;
          v95 = v115;
          v96 = "%{public}s called with null http_encoding, backtrace limit exceeded";
        }
      }
LABEL_161:
      _os_log_impl(&dword_182FBE000, v94, v95, v96, v227, 0xCu);
      goto LABEL_162;
    }
LABEL_78:
    v54 = v220[3];
    if ((v54 & 0x8000000000000000) == 0)
      break;
    v55 = *(_QWORD *)&buf[8];
    if (gLogDatapath)
    {
      v80 = __nwlog_obj();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v227 = 136446210;
        *(_QWORD *)&v227[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_182FBE000, v80, OS_LOG_TYPE_DEBUG, "%{public}s called", v227, 0xCu);
      }
    }
    *(_QWORD *)v227 = v43;
    *(_QWORD *)&v227[8] = 0x40000000;
    *(_QWORD *)&v227[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33090;
    v228 = (const char *)&__block_descriptor_tmp_38_33091;
    *(_QWORD *)v229 = v55 + 40;
    v229[8] = 0;
    v56 = *(_QWORD *)(v55 + 40);
    do
    {
      if (!v56)
        break;
      v57 = *(_QWORD *)(v56 + 32);
      v58 = (*(uint64_t (**)(_BYTE *))&v227[16])(v227);
      v56 = v57;
    }
    while ((v58 & 1) != 0);
    v59 = a1[7];
    if (*(_DWORD *)(v59 + 644) == 1)
    {
      if ((*(_BYTE *)(v59 + 198) & 1) != 0)
        goto LABEL_175;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v128 = gLogObj;
      v129 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      v59 = a1[7];
      if (v129)
      {
        *(_DWORD *)v227 = 136446722;
        *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        *(_WORD *)&v227[12] = 2082;
        *(_QWORD *)&v227[14] = v59 + 114;
        *(_WORD *)&v227[22] = 2080;
        v228 = " ";
        _os_log_impl(&dword_182FBE000, v128, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sdecoding failed", v227, 0x20u);
        v59 = a1[7];
      }
      if (v59)
      {
LABEL_175:
        nw_protocol_error(*(_QWORD **)(v59 + 48), v59);
        nw_protocol_disconnect(*(_QWORD **)(v59 + 32), v59);
        v5 = v207;
        goto LABEL_225;
      }
      __nwlog_obj();
      *(_DWORD *)v227 = 136446210;
      *(_QWORD *)&v227[4] = "nw_http_encoding_close";
      v179 = (char *)_os_log_send_and_compose_impl();
      v226 = OS_LOG_TYPE_ERROR;
      v225 = 0;
      v5 = v207;
      if (!__nwlog_fault(v179, &v226, &v225))
        goto LABEL_279;
      if (v226 == OS_LOG_TYPE_FAULT)
      {
        v180 = __nwlog_obj();
        v181 = v226;
        if (os_log_type_enabled(v180, v226))
        {
          *(_DWORD *)v227 = 136446210;
          *(_QWORD *)&v227[4] = "nw_http_encoding_close";
          v182 = "%{public}s called with null http_encoding";
          goto LABEL_277;
        }
        goto LABEL_279;
      }
      if (v225)
      {
        v183 = (char *)__nw_create_backtrace_string();
        v184 = __nwlog_obj();
        v185 = v226;
        v186 = os_log_type_enabled(v184, v226);
        if (v183)
        {
          if (v186)
          {
            *(_DWORD *)v227 = 136446466;
            *(_QWORD *)&v227[4] = "nw_http_encoding_close";
            *(_WORD *)&v227[12] = 2082;
            *(_QWORD *)&v227[14] = v183;
            _os_log_impl(&dword_182FBE000, v184, v185, "%{public}s called with null http_encoding, dumping backtrace:%{public}s", v227, 0x16u);
          }
          free(v183);
          v5 = v207;
          goto LABEL_279;
        }
        v5 = v207;
        if (!v186)
        {
LABEL_279:
          if (v179)
            free(v179);
          goto LABEL_225;
        }
        *(_DWORD *)v227 = 136446210;
        *(_QWORD *)&v227[4] = "nw_http_encoding_close";
        v182 = "%{public}s called with null http_encoding, no backtrace";
        v199 = v184;
        v200 = v185;
      }
      else
      {
        v180 = __nwlog_obj();
        v181 = v226;
        v5 = v207;
        if (!os_log_type_enabled(v180, v226))
          goto LABEL_279;
        *(_DWORD *)v227 = 136446210;
        *(_QWORD *)&v227[4] = "nw_http_encoding_close";
        v182 = "%{public}s called with null http_encoding, backtrace limit exceeded";
LABEL_277:
        v199 = v180;
        v200 = v181;
      }
      _os_log_impl(&dword_182FBE000, v199, v200, v182, v227, 0xCu);
      goto LABEL_279;
    }
    if ((*(_BYTE *)(v59 + 198) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v60 = gLogObj;
      v61 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      v59 = a1[7];
      if (v61)
      {
        v62 = *(unsigned int *)(v59 + 644);
        v63 = "<unknown>";
        if (v62 <= 5)
          v63 = off_1E14AA448[v62];
        *(_DWORD *)v227 = 136446978;
        *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        *(_WORD *)&v227[12] = 2082;
        *(_QWORD *)&v227[14] = v59 + 114;
        *(_WORD *)&v227[22] = 2080;
        v228 = " ";
        *(_WORD *)v229 = 2080;
        *(_QWORD *)&v229[2] = v63;
        _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sdecoding failed, trying alternative encoding %s", v227, 0x2Au);
        v59 = a1[7];
      }
    }
    v64 = *(_DWORD *)(v59 + 644);
    *(_DWORD *)(v59 + 644) = 1;
    switch(v64)
    {
      case 2:
        deflate = nw_decoder_create_gzip();
        goto LABEL_95;
      case 3:
        *(_DWORD *)(v59 + 644) = 4;
        deflate = nw_decoder_create_deflate();
        goto LABEL_95;
      case 4:
        deflate = nw_decoder_create_raw_deflate();
        goto LABEL_95;
      case 5:
        deflate = nw_decoder_create_brotli();
LABEL_95:
        v66 = (void (***)(_QWORD, uint64_t))deflate;
        break;
      default:
        v66 = 0;
        break;
    }
    v41 = a1[7];
    v67 = *(void (****)(_QWORD, uint64_t))(v41 + 544);
    if (v67 != v66)
    {
      if (v67)
      {
        (**v67)(*(_QWORD *)(v41 + 544), v56);
        free(v67);
      }
      *(_QWORD *)(v41 + 544) = v66;
      v41 = a1[7];
    }
  }
  v118 = a1[7];
  v119 = *(_QWORD *)(v118 + 472);
  *(_QWORD *)(v118 + 472) = v119 + v54;
  if (__OFADD__(v119, v54))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v120 = (const char *)v220[3];
    v121 = *(_QWORD *)(a1[7] + 472);
    *(_DWORD *)v227 = 136446978;
    *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    *(_WORD *)&v227[12] = 2082;
    *(_QWORD *)&v227[14] = "http_encoding->decoded_length";
    *(_WORD *)&v227[22] = 2048;
    v228 = v120;
    *(_WORD *)v229 = 2048;
    *(_QWORD *)&v229[2] = v121;
    v122 = (char *)_os_log_send_and_compose_impl();
    v226 = OS_LOG_TYPE_ERROR;
    v225 = 0;
    v5 = v207;
    if (!__nwlog_fault(v122, &v226, &v225))
      goto LABEL_210;
    if (v226 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v123 = gLogObj;
      v124 = v226;
      if (!os_log_type_enabled((os_log_t)gLogObj, v226))
        goto LABEL_210;
      v125 = (const char *)v220[3];
      v126 = *(_QWORD *)(a1[7] + 472);
      *(_DWORD *)v227 = 136446978;
      *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
      *(_WORD *)&v227[12] = 2082;
      *(_QWORD *)&v227[14] = "http_encoding->decoded_length";
      *(_WORD *)&v227[22] = 2048;
      v228 = v125;
      *(_WORD *)v229 = 2048;
      *(_QWORD *)&v229[2] = v126;
      v127 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
    }
    else
    {
      if (v225)
      {
        v146 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v147 = gLogObj;
        v148 = v226;
        v149 = os_log_type_enabled((os_log_t)gLogObj, v226);
        if (v146)
        {
          if (v149)
          {
            v150 = (const char *)v220[3];
            v151 = *(_QWORD *)(a1[7] + 472);
            *(_DWORD *)v227 = 136447234;
            *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            *(_WORD *)&v227[12] = 2082;
            *(_QWORD *)&v227[14] = "http_encoding->decoded_length";
            *(_WORD *)&v227[22] = 2048;
            v228 = v150;
            *(_WORD *)v229 = 2048;
            *(_QWORD *)&v229[2] = v151;
            *(_WORD *)&v229[10] = 2082;
            v230 = v146;
            _os_log_impl(&dword_182FBE000, v147, v148, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", v227, 0x34u);
          }
          free(v146);
        }
        else if (v149)
        {
          v172 = (const char *)v220[3];
          v173 = *(_QWORD *)(a1[7] + 472);
          *(_DWORD *)v227 = 136446978;
          *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          *(_WORD *)&v227[12] = 2082;
          *(_QWORD *)&v227[14] = "http_encoding->decoded_length";
          *(_WORD *)&v227[22] = 2048;
          v228 = v172;
          *(_WORD *)v229 = 2048;
          *(_QWORD *)&v229[2] = v173;
          v127 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          v159 = v147;
          v160 = v148;
          goto LABEL_209;
        }
LABEL_210:
        if (v122)
          free(v122);
        v161 = a1[7];
        *(_QWORD *)(v161 + 472) = 0x7FFFFFFFFFFFFFFFLL;
        if ((*(_BYTE *)(v161 + 198) & 1) != 0)
          goto LABEL_214;
        goto LABEL_213;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v123 = gLogObj;
      v124 = v226;
      if (!os_log_type_enabled((os_log_t)gLogObj, v226))
        goto LABEL_210;
      v157 = (const char *)v220[3];
      v158 = *(_QWORD *)(a1[7] + 472);
      *(_DWORD *)v227 = 136446978;
      *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
      *(_WORD *)&v227[12] = 2082;
      *(_QWORD *)&v227[14] = "http_encoding->decoded_length";
      *(_WORD *)&v227[22] = 2048;
      v228 = v157;
      *(_WORD *)v229 = 2048;
      *(_QWORD *)&v229[2] = v158;
      v127 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
    }
    v159 = v123;
    v160 = v124;
LABEL_209:
    _os_log_impl(&dword_182FBE000, v159, v160, v127, v227, 0x2Au);
    goto LABEL_210;
  }
  v5 = v207;
  if ((*(_BYTE *)(a1[7] + 198) & 1) == 0)
  {
LABEL_213:
    if (gLogDatapath)
    {
      v175 = __nwlog_obj();
      if (os_log_type_enabled(v175, OS_LOG_TYPE_DEBUG))
      {
        v176 = a1[7] + 114;
        v177 = *(_QWORD *)(a2 + 64);
        if (v177)
          LODWORD(v177) = (*(unsigned __int8 *)(v177 + 66) >> 6) & 1;
        v178 = *(unsigned __int8 *)(a2 + 186) >> 7;
        *(_DWORD *)v227 = 136447234;
        *(_QWORD *)&v227[4] = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        *(_WORD *)&v227[12] = 2082;
        *(_QWORD *)&v227[14] = v176;
        *(_WORD *)&v227[22] = 2080;
        v228 = " ";
        *(_WORD *)v229 = 1024;
        *(_DWORD *)&v229[2] = v177;
        *(_WORD *)&v229[6] = 1024;
        *(_DWORD *)&v229[8] = v178;
        _os_log_impl(&dword_182FBE000, v175, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%smetadata complete %{BOOL}d, connection complete %{BOOL}d", v227, 0x2Cu);
        v5 = v207;
      }
    }
  }
LABEL_214:
  v162 = *(_QWORD *)(a2 + 64);
  if (v162)
  {
    if ((*(_BYTE *)(v162 + 66) & 0x40) != 0)
    {
      v163 = **(_QWORD **)(*(_QWORD *)(*(_QWORD *)&buf[8] + 48) + 8);
      if (v163)
        nw_frame_inherit_metadata(a2, v163, 1);
    }
  }
  v210[0] = v43;
  v210[1] = 0x40000000;
  v211 = (uint64_t (*)(_QWORD *))___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_27;
  v212 = &unk_1E14A0078;
  v216 = *(_OWORD *)(a1 + 7);
  v213 = &v219;
  v214 = buf;
  v217 = a1[9];
  v215 = a1[5];
  v164 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
  do
  {
    if (!v164)
      break;
    v165 = *(_QWORD *)(v164 + 32);
    v166 = v211(v210);
    v164 = v165;
  }
  while ((v166 & 1) != 0);
  v167 = (uint64_t *)(*(_QWORD *)&buf[8] + 40);
  if (gLogDatapath)
  {
    v174 = __nwlog_obj();
    if (os_log_type_enabled(v174, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v227 = 136446210;
      *(_QWORD *)&v227[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v174, OS_LOG_TYPE_DEBUG, "%{public}s called", v227, 0xCu);
    }
  }
  *(_QWORD *)v227 = v43;
  *(_QWORD *)&v227[8] = 0x40000000;
  *(_QWORD *)&v227[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_33090;
  v228 = (const char *)&__block_descriptor_tmp_38_33091;
  *(_QWORD *)v229 = v167;
  v229[8] = 0;
  v168 = *v167;
  do
  {
    if (!v168)
      break;
    v169 = *(_QWORD *)(v168 + 32);
    v170 = (*(uint64_t (**)(_BYTE *))&v227[16])(v227);
    v168 = v169;
  }
  while ((v170 & 1) != 0);
LABEL_225:
  v155 = v54 >= 0;
  _Block_object_dispose(&v219, 8);
  _Block_object_dispose(buf, 8);
  if (v5)
LABEL_226:
    os_release(v5);
  return v155;
}

uint64_t ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_32(uint64_t a1, _DWORD *a2)
{
  NSObject *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  _DWORD *v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 32) + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        v6 = *(_QWORD *)(a1 + 32) + 114;
        v7 = 136447234;
        v8 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        v9 = 2082;
        v10 = v6;
        v11 = 2080;
        v12 = " ";
        v13 = 2048;
        v14 = a2;
        v15 = 1024;
        v16 = nw_frame_unclaimed_length(a2);
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sframe %p unclaimed length %u", (uint8_t *)&v7, 0x30u);
      }
    }
  }
  return 1;
}

void ___ZL33nw_http_encoding_get_content_typeP25nw_protocol_http_encodingP20nw_protocol_metadata_block_invoke(uint64_t a1, char *a2)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  int v7;
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (!strcasecmp(a2, "gzip"))
    {
      v6 = 2;
    }
    else if (!strcasecmp(a2, "deflate"))
    {
      v6 = 3;
    }
    else if (!strcasecmp(a2, "br"))
    {
      v6 = 5;
    }
    else
    {
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 40) + 198) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v4 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v5 = *(_QWORD *)(a1 + 40) + 114;
          v7 = 136446978;
          v8 = "nw_http_encoding_get_content_type_block_invoke";
          v9 = 2082;
          v10 = v5;
          v11 = 2080;
          v12 = " ";
          v13 = 2080;
          v14 = a2;
          _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sunknown encoding type %s, ignoring", (uint8_t *)&v7, 0x2Au);
        }
      }
      v6 = 0;
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v6;
  }
}

uint64_t ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_23(_QWORD *a1, size_t size)
{
  uint64_t v4;
  char v5;
  _BOOL8 frame;
  uint64_t v7;
  _BOOL8 *v8;
  uint64_t v9;
  uint64_t *v10;
  NSObject *v12;
  _BOOL4 v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  NSObject *v18;
  char *backtrace_string;
  _BOOL4 v20;
  const char *v21;
  _BOOL4 v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  size_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = a1[5];
  v5 = *(_BYTE *)(v4 + 198);
  if ((v5 & 1) == 0)
  {
    if (gLogDatapath)
    {
      v12 = __nwlog_obj();
      v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
      v4 = a1[5];
      if (v13)
      {
        *(_DWORD *)buf = 136446978;
        v26 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        v27 = 2082;
        v28 = (char *)(v4 + 114);
        v29 = 2080;
        v30 = " ";
        v31 = 2048;
        v32 = size;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sdecoder asking for frame of size %zu", buf, 0x2Au);
        v4 = a1[5];
      }
      if (!v4)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v26 = "nw_http_encoding_create_inbound_frame";
        v14 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v23 = 0;
        if (!__nwlog_fault(v14, &type, &v23))
          goto LABEL_41;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v15 = __nwlog_obj();
          v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v26 = "nw_http_encoding_create_inbound_frame";
            v17 = "%{public}s called with null http_encoding";
LABEL_40:
            _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
            goto LABEL_41;
          }
          goto LABEL_41;
        }
        if (!v23)
        {
          v15 = __nwlog_obj();
          v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v26 = "nw_http_encoding_create_inbound_frame";
            v17 = "%{public}s called with null http_encoding, backtrace limit exceeded";
            goto LABEL_40;
          }
          goto LABEL_41;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v15 = __nwlog_obj();
        v16 = type;
        v22 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446210;
            v26 = "nw_http_encoding_create_inbound_frame";
            v17 = "%{public}s called with null http_encoding, no backtrace";
            goto LABEL_40;
          }
          goto LABEL_41;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_http_encoding_create_inbound_frame";
          v27 = 2082;
          v28 = backtrace_string;
          v21 = "%{public}s called with null http_encoding, dumping backtrace:%{public}s";
          goto LABEL_30;
        }
        goto LABEL_31;
      }
    }
    v5 = *(_BYTE *)(v4 + 198);
  }
  if ((v5 & 1) == 0)
  {
    if (gLogDatapath)
    {
      v18 = __nwlog_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v26 = "nw_http_encoding_create_inbound_frame";
        v27 = 2082;
        v28 = (char *)(v4 + 114);
        v29 = 2080;
        v30 = " ";
        v31 = 1024;
        LODWORD(v32) = size;
        _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled for size %u", buf, 0x26u);
      }
    }
  }
  frame = nw_frame_cache_create_frame((uint64_t *)(v4 + 432), size);
  if (frame)
  {
    v7 = frame;
    *(_QWORD *)(frame + 16) = 0;
    v8 = *(_BOOL8 **)(v4 + 568);
    *(_QWORD *)(frame + 24) = v8;
    *v8 = frame;
    *(_QWORD *)(v4 + 568) = frame + 16;
    *(_QWORD *)(frame + 80) = nw_http_encoding_inbound_frame_finalizer;
    *(_QWORD *)(frame + 88) = v4;
    goto LABEL_8;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_http_encoding_create_inbound_frame";
  v14 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v14, &type, &v23))
    goto LABEL_41;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v23)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_http_encoding_create_inbound_frame";
        v17 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = type;
    v20 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_http_encoding_create_inbound_frame";
        v17 = "%{public}s called with null frame, no backtrace";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v26 = "nw_http_encoding_create_inbound_frame";
      v27 = 2082;
      v28 = backtrace_string;
      v21 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_30:
      _os_log_impl(&dword_182FBE000, v15, v16, v21, buf, 0x16u);
    }
LABEL_31:
    free(backtrace_string);
    goto LABEL_41;
  }
  v15 = __nwlog_obj();
  v16 = type;
  if (os_log_type_enabled(v15, type))
  {
    *(_DWORD *)buf = 136446210;
    v26 = "nw_http_encoding_create_inbound_frame";
    v17 = "%{public}s called with null frame";
    goto LABEL_40;
  }
LABEL_41:
  if (v14)
    free(v14);
  v7 = 0;
LABEL_8:
  nw_frame_inherit_metadata(a1[6], v7, 0);
  v9 = *(_QWORD *)(a1[4] + 8);
  *(_QWORD *)(v7 + 32) = 0;
  v10 = *(uint64_t **)(v9 + 48);
  *(_QWORD *)(v7 + 40) = v10;
  *v10 = v7;
  *(_QWORD *)(v9 + 48) = v7 + 32;
  return nw_frame_unclaimed_bytes(v7, 0);
}

void nw_http_encoding_inbound_frame_finalizer(nw_frame *a1, int a2, _BYTE *a3)
{
  uint64_t v6;
  _QWORD *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  NSObject *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  nw_frame *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  _BYTE *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http_encoding_inbound_frame_finalizer";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v9, &type, &v18))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http_encoding_inbound_frame_finalizer";
      v12 = "%{public}s called with null frame";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v15 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_http_encoding_inbound_frame_finalizer";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_47:
        if (!v9)
          return;
LABEL_48:
        free(v9);
        return;
      }
      if (!v15)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http_encoding_inbound_frame_finalizer";
      v12 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http_encoding_inbound_frame_finalizer";
      v12 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_46:
    _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
    goto LABEL_47;
  }
  if (a3)
  {
    if ((a3[198] & 1) == 0)
    {
      if (gLogDatapath)
      {
        v13 = __nwlog_obj();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136447490;
          v21 = "nw_http_encoding_inbound_frame_finalizer";
          v22 = 2082;
          v23 = a3 + 114;
          v24 = 2080;
          v25 = " ";
          v26 = 2048;
          v27 = a1;
          v28 = 1024;
          v29 = a2;
          v30 = 2048;
          v31 = a3;
          _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sfinalizing inbound frame %p (success %u, context %p)", buf, 0x3Au);
        }
      }
    }
    v6 = *((_QWORD *)a1 + 2);
    v7 = (_QWORD *)*((_QWORD *)a1 + 3);
    if (v6)
    {
      *(_QWORD *)(v6 + 24) = v7;
      v7 = (_QWORD *)*((_QWORD *)a1 + 3);
    }
    else
    {
      *((_QWORD *)a3 + 71) = v7;
    }
    *v7 = v6;
    *((_QWORD *)a1 + 2) = 0;
    *((_QWORD *)a1 + 3) = 0;
    *((_QWORD *)a1 + 10) = 0;
    *((_QWORD *)a1 + 11) = 0;
    if (a2)
    {
      nw_frame_cache_return_frame((uint64_t)(a3 + 432), (uint64_t)a1);
    }
    else
    {
      if ((*((_WORD *)a1 + 102) & 0x100) == 0
        || !g_channel_check_validity
        || g_channel_check_validity(a1, 0))
      {
        v8 = (void *)*((_QWORD *)a1 + 14);
        if (v8)
          free(v8);
      }
      nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
      os_release(a1);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_http_encoding_inbound_frame_finalizer";
  v9 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v9, &type, &v18))
    goto LABEL_47;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http_encoding_inbound_frame_finalizer";
    v12 = "%{public}s called with null context";
    goto LABEL_46;
  }
  if (!v18)
  {
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http_encoding_inbound_frame_finalizer";
    v12 = "%{public}s called with null context, backtrace limit exceeded";
    goto LABEL_46;
  }
  v16 = (char *)__nw_create_backtrace_string();
  v10 = __nwlog_obj();
  v11 = type;
  v17 = os_log_type_enabled(v10, type);
  if (!v16)
  {
    if (!v17)
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http_encoding_inbound_frame_finalizer";
    v12 = "%{public}s called with null context, no backtrace";
    goto LABEL_46;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "nw_http_encoding_inbound_frame_finalizer";
    v22 = 2082;
    v23 = v16;
    _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v9)
    goto LABEL_48;
}

uint64_t ___ZL42nw_protocol_http_encoding_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_27(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint64_t v20;
  const char *v21;
  char *backtrace_string;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v28;
  _BOOL4 v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v5 = nw_frame_unclaimed_length((_DWORD *)a2);
  v6 = a1[7];
  if ((*(_BYTE *)(v6 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v28 = __nwlog_obj();
      v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG);
      v6 = a1[7];
      if (v29)
      {
        *(_DWORD *)buf = 136446978;
        v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        v39 = 2082;
        v40 = (const char *)(v6 + 114);
        v41 = 2080;
        v42 = (uint64_t)" ";
        v43 = 1024;
        LODWORD(v44) = v5;
        _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sunclaimed length %u", buf, 0x26u);
        v6 = a1[7];
      }
    }
  }
  if (v5 >= *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24))
    v5 = *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  if ((*(_BYTE *)(v6 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v30 = __nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        v31 = a1[7] + 114;
        *(_DWORD *)buf = 136446978;
        v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        v39 = 2082;
        v40 = (const char *)v31;
        v41 = 2080;
        v42 = (uint64_t)" ";
        v43 = 1024;
        LODWORD(v44) = v5;
        _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%u bytes to claim", buf, 0x26u);
      }
    }
  }
  nw_frame_claim(a2, v4, v5, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v7, v5, 0);
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) -= v5;
  if ((*(_BYTE *)(a1[7] + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        v33 = a1[7] + 114;
        v34 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
        *(_DWORD *)buf = 136446978;
        v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
        v39 = 2082;
        v40 = (const char *)v33;
        v41 = 2080;
        v42 = (uint64_t)" ";
        v43 = 2048;
        v44 = v34;
        _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%zu bytes decoded", buf, 0x2Au);
      }
    }
  }
  v9 = *(_QWORD *)(a2 + 32);
  v10 = *(_QWORD **)(a2 + 40);
  v8 = (_QWORD *)(a2 + 32);
  if (v9)
  {
    *(_QWORD *)(v9 + 40) = v10;
    v10 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 48) = v10;
  }
  *v10 = v9;
  *v8 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v11 = a1[9];
  v12 = *(uint64_t **)(v11 + 8);
  *(_QWORD *)(a2 + 40) = v12;
  *v12 = a2;
  *(_QWORD *)(v11 + 8) = v8;
  v13 = *(_QWORD *)(a1[6] + 8);
  v14 = *(unsigned int *)(v13 + 24) + 1;
  v15 = v14 << 31 >> 31;
  *(_DWORD *)(v13 + 24) = v14;
  if (v15 != v14 || v15 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
    *(_DWORD *)buf = 136446978;
    v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
    v39 = 2082;
    v40 = "count";
    v41 = 2048;
    v42 = 1;
    v43 = 2048;
    v44 = v16;
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v17, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v20 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          v39 = 2082;
          v40 = "count";
          v41 = 2048;
          v42 = 1;
          v43 = 2048;
          v44 = v20;
          v21 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_27:
          _os_log_impl(&dword_182FBE000, v18, v19, v21, buf, 0x2Au);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type;
        v23 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v23)
          {
            v24 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
            v39 = 2082;
            v40 = "count";
            v41 = 2048;
            v42 = 1;
            v43 = 2048;
            v44 = v24;
            v45 = 2082;
            v46 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          goto LABEL_28;
        }
        if (v23)
        {
          v26 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          v39 = 2082;
          v40 = "count";
          v41 = 2048;
          v42 = 1;
          v43 = 2048;
          v44 = v26;
          v21 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_27;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v25 = *(unsigned int *)(*(_QWORD *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v38 = "nw_protocol_http_encoding_get_input_frames_block_invoke";
          v39 = 2082;
          v40 = "count";
          v41 = 2048;
          v42 = 1;
          v43 = 2048;
          v44 = v25;
          v21 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_27;
        }
      }
    }
LABEL_28:
    if (v17)
      free(v17);
    *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = -1;
  }
  return 1;
}

double __nw_protocol_http_encoding_identifier_block_invoke()
{
  double result;

  strcpy((char *)nw_protocol_http_encoding_identifier::protocol_identifier, "http_encoding");
  *(_QWORD *)&result = 0x100000005;
  qword_1EDCE3D38 = 0x100000005;
  return result;
}

BOOL nw_link_set_flow_control_status(void *a1, int a2)
{
  id v3;
  void *v4;
  int v5;
  _BOOL8 v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = *((_DWORD *)v3 + 2);
    *((_DWORD *)v3 + 2) = a2;
    v6 = v5 != a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_link_set_flow_control_status";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_link_set_flow_control_status";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null link_info", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_link_set_flow_control_status";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null link_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_link_set_flow_control_status";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null link_info, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_link_set_flow_control_status";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null link_info, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_3:

  return v6;
}

uint64_t nw_link_get_flow_control_status(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[2];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_link_get_flow_control_status";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_link_get_flow_control_status";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null link_info", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_link_get_flow_control_status";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null link_info, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_link_get_flow_control_status";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null link_info, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_link_get_flow_control_status";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null link_info, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 1;
LABEL_3:

  return v3;
}

void nw_link_get_local_congestion_info(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  void *v8;
  void *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_link_get_local_congestion_info";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_48;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_link_get_local_congestion_info";
          v7 = "%{public}s called with null link_congestion_info, backtrace limit exceeded";
          goto LABEL_46;
        }
        goto LABEL_47;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_link_get_local_congestion_info";
          v7 = "%{public}s called with null link_congestion_info, no backtrace";
          goto LABEL_46;
        }
        goto LABEL_47;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_link_get_local_congestion_info";
        v20 = 2082;
        v21 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null link_congestion_info, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
      goto LABEL_48;
    }
    __nwlog_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_link_get_local_congestion_info";
    v7 = "%{public}s called with null link_congestion_info";
LABEL_46:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_47;
  }
  if (a2)
  {
    if (a3)
    {
      *a2 = *a1;
      *a3 = a1[1];
      return;
    }
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_link_get_local_congestion_info";
    v4 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v4, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_link_get_local_congestion_info";
          v7 = "%{public}s called with null pkt_count";
          goto LABEL_46;
        }
LABEL_47:

        goto LABEL_48;
      }
      if (!v16)
      {
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_link_get_local_congestion_info";
          v7 = "%{public}s called with null pkt_count, backtrace limit exceeded";
          goto LABEL_46;
        }
        goto LABEL_47;
      }
      v12 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      v15 = os_log_type_enabled(v5, type);
      if (!v12)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_link_get_local_congestion_info";
          v7 = "%{public}s called with null pkt_count, no backtrace";
          goto LABEL_46;
        }
        goto LABEL_47;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_link_get_local_congestion_info";
        v20 = 2082;
        v21 = v12;
        v14 = "%{public}s called with null pkt_count, dumping backtrace:%{public}s";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
LABEL_48:
    if (v4)
      goto LABEL_49;
    return;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_link_get_local_congestion_info";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_48;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_link_get_local_congestion_info";
    v7 = "%{public}s called with null ce_count";
    goto LABEL_46;
  }
  if (!v16)
  {
    __nwlog_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    v6 = type;
    if (os_log_type_enabled(v5, type))
    {
      *(_DWORD *)buf = 136446210;
      v19 = "nw_link_get_local_congestion_info";
      v7 = "%{public}s called with null ce_count, backtrace limit exceeded";
      goto LABEL_46;
    }
    goto LABEL_47;
  }
  v12 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = type;
  v13 = os_log_type_enabled(v5, type);
  if (!v12)
  {
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      v19 = "nw_link_get_local_congestion_info";
      v7 = "%{public}s called with null ce_count, no backtrace";
      goto LABEL_46;
    }
    goto LABEL_47;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_link_get_local_congestion_info";
    v20 = 2082;
    v21 = v12;
    v14 = "%{public}s called with null ce_count, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v5, v6, v14, buf, 0x16u);
  }
LABEL_32:

  free(v12);
  if (v4)
LABEL_49:
    free(v4);
}

void nw_link_set_local_congestion_info(_DWORD *a1, int a2, int a3)
{
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *a1 = a2;
    a1[1] = a3;
    return;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v13 = "nw_link_set_local_congestion_info";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_link_set_local_congestion_info";
        v7 = "%{public}s called with null link_congestion_info";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
    }
    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v5 = objc_claimAutoreleasedReturnValue();
        v6 = type;
        v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            v13 = "nw_link_set_local_congestion_info";
            v14 = 2082;
            v15 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null link_congestion_info, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v9)
          goto LABEL_18;
        *(_DWORD *)buf = 136446210;
        v13 = "nw_link_set_local_congestion_info";
        v7 = "%{public}s called with null link_congestion_info, no backtrace";
        goto LABEL_17;
      }
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v13 = "nw_link_set_local_congestion_info";
        v7 = "%{public}s called with null link_congestion_info, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:

  }
LABEL_19:
  if (v4)
    free(v4);
}

double __nw_protocol_webtransport_identifier_block_invoke()
{
  double result;

  unk_1EDCF1985 = 0;
  unk_1EDCF197D = 0;
  dword_1EDCF198C = 0;
  strcpy((char *)nw_protocol_webtransport_identifier::protocol_identifier, "webtransport");
  *(_QWORD *)&result = 0x200000004;
  qword_1EDCF1990 = 0x200000004;
  return result;
}

BOOL nw_protocol_webtransport_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  char *v7;
  char v8;
  void *v9;
  char v10;
  _BOOL8 result;
  NSObject *v12;
  void *v13;
  NSObject *v14;
  const char *v15;
  int v16;
  const char *v17;
  char v18;
  _QWORD aBlock[5];
  _BYTE buf[24];
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v7 = (char *)malloc_type_calloc(1uLL, 0x228uLL, 0xEAFB8F1AuLL);
  if (!v7)
  {
    v12 = __nwlog_obj();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = 1;
    *(_WORD *)&buf[22] = 2048;
    v21 = 552;
    v13 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v13);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v13);
  }
  bzero(v7, 0x228uLL);
  *((_QWORD *)v7 + 2) = a1;
  if (nw_protocol_webtransport_session_callbacks(void)::onceToken != -1)
    dispatch_once(&nw_protocol_webtransport_session_callbacks(void)::onceToken, &__block_literal_global_15_33403);
  *((_QWORD *)v7 + 3) = &nw_protocol_webtransport_session_callbacks(void)::protocol_callbacks;
  *((_QWORD *)v7 + 5) = v7;
  if (nw_protocol_webtransport_session_get_listen_callbacks(void)::onceToken != -1)
    dispatch_once(&nw_protocol_webtransport_session_get_listen_callbacks(void)::onceToken, &__block_literal_global_60);
  *((_QWORD *)v7 + 8) = &nw_protocol_webtransport_session_get_listen_callbacks(void)::listen_protocol_callbacks;
  *((_QWORD *)v7 + 11) = v7;
  *((_QWORD *)v7 + 12) = 0;
  *((_QWORD *)v7 + 13) = v7 + 96;
  *((_QWORD *)v7 + 14) = 0;
  *((_QWORD *)v7 + 17) = 0;
  *((_QWORD *)v7 + 18) = -1;
  *((_QWORD *)v7 + 15) = v7 + 112;
  *((_QWORD *)v7 + 16) = 0;
  *((_QWORD *)v7 + 19) = 0;
  *((_QWORD *)v7 + 20) = 0;
  *((_WORD *)v7 + 84) = 0;
  if (a3)
    a3 = os_retain(a3);
  v8 = v7[368];
  if ((v8 & 1) != 0)
  {
    v9 = (void *)*((_QWORD *)v7 + 45);
    if (v9)
    {
      os_release(v9);
      v8 = v7[368];
    }
  }
  *((_QWORD *)v7 + 45) = a3;
  v7[368] = v8 | 1;
  *((_DWORD *)v7 + 112) = 2;
  *((_QWORD *)v7 + 55) = 0;
  *((_QWORD *)v7 + 22) = -1;
  v7[548] = v7[548] & 0xFE | nw_parameters_get_server_mode(a4);
  *((_QWORD *)v7 + 23) = 0;
  *((_QWORD *)v7 + 24) = 0;
  *((_QWORD *)v7 + 41) = 0;
  *((_QWORD *)v7 + 42) = v7 + 328;
  *((_DWORD *)v7 + 114) = 0;
  if (nw_parameters_get_logging_disabled((uint64_t)a4))
    v10 = 2;
  else
    v10 = 0;
  v7[548] = v7[548] & 0xFD | v10;
  *((_QWORD *)v7 + 49) = nw_parameters_copy_context(a4);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2000000000;
  v21 = (uint64_t)v7;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 0x40000000;
  aBlock[2] = __nw_protocol_webtransport_create_block_invoke;
  aBlock[3] = &unk_1E14A03C8;
  aBlock[4] = buf;
  *((_QWORD *)v7 + 54) = _Block_copy(aBlock);
  _Block_object_dispose(buf, 8);
  if ((v7[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v15 = v7 + 464;
        v16 = *((_DWORD *)v7 + 115);
        v17 = " ";
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_create";
        *(_WORD *)&buf[12] = 2082;
        v18 = v7[548];
        if (!v7)
          v17 = "";
        *(_DWORD *)buf = 136447234;
        if (!v7)
          v15 = "";
        *(_QWORD *)&buf[14] = v15;
        *(_WORD *)&buf[22] = 2080;
        v21 = (uint64_t)v17;
        v22 = 1024;
        v23 = v16;
        v24 = 1024;
        v25 = v18 & 1;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Created webtransport, server mode: %d", buf, 0x2Cu);
      }
    }
  }
  return (BOOL)v7;
}

uint64_t __nw_protocol_webtransport_create_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void ___ZL53nw_protocol_webtransport_session_get_listen_callbacksv_block_invoke()
{
  nw_protocol_webtransport_session_get_listen_callbacks(void)::listen_protocol_callbacks = (uint64_t)nw_protocol_webtransport_session_listen_protocol_new_flow;
  *(_QWORD *)algn_1EDCF1E08 = nw_protocol_webtransport_session_listen_protocol_disconnected;
}

uint64_t nw_protocol_webtransport_session_listen_protocol_new_flow(nw_listen_protocol *a1, nw_endpoint *a2, nw_parameters *a3)
{
  char *handle;
  uint64_t v7;
  unsigned int v8;
  nw_protocol *protocol_handler;
  uint64_t v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t result;
  int v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *backtrace_string;
  _BOOL4 v22;
  const char *v23;
  char v24;
  void *v25;
  uint64_t last_application_stream_id;
  void *parameters;
  void *v28;
  id *v29;
  NSObject *v30;
  void *v31;
  id v32;
  _QWORD *v33;
  void *v34;
  id *v35;
  NSObject *v36;
  id *v37;
  NSObject *v38;
  NSObject *v39;
  nw_protocol_options_t v40;
  nw_protocol_options_t v41;
  nw_protocol_definition_t v42;
  uint64_t protocol_handle;
  uint64_t v44;
  NSObject *v45;
  int v46;
  void *v47;
  uint64_t v48;
  void *v49;
  NSObject *v50;
  int v51;
  uint64_t v52;
  int v53;
  NSObject *v54;
  int v55;
  char *v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  _QWORD *v63;
  NSObject *v64;
  int v65;
  _BOOL4 v66;
  _BOOL4 v67;
  char *v68;
  NSObject *v69;
  os_log_type_t v70;
  const char *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  const char *v75;
  char *v76;
  _BOOL4 v77;
  char *v78;
  NSObject *v79;
  os_log_type_t v80;
  const char *v81;
  NSObject *v82;
  int v83;
  char *v84;
  _BOOL4 v85;
  char *v86;
  _BOOL4 v87;
  char *v88;
  _BOOL4 v89;
  _QWORD v90[5];
  char v91;
  os_log_type_t v92;
  os_log_type_t type[8];
  uint64_t v94;
  void (*v95)(_QWORD *, void *);
  void *v96;
  _QWORD *v97;
  _BYTE *v98;
  char *v99;
  _QWORD v100[3];
  char v101;
  uint8_t v102[4];
  const char *v103;
  __int16 v104;
  char *v105;
  _BYTE buf[24];
  uint64_t (*v107)(uint64_t, uint64_t);
  void (*v108)(uint64_t);
  void *v109;
  __int16 v110;
  int v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
    v11 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v100[0]) = 0;
    if (__nwlog_fault(v11, type, v100))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          v14 = "%{public}s called with null listener";
LABEL_48:
          _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        }
      }
      else if (LOBYTE(v100[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v13 = type[0];
        v66 = os_log_type_enabled(v12, type[0]);
        if (backtrace_string)
        {
          if (!v66)
            goto LABEL_25;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          v23 = "%{public}s called with null listener, dumping backtrace:%{public}s";
          goto LABEL_24;
        }
        if (v66)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          v14 = "%{public}s called with null listener, no backtrace";
          goto LABEL_48;
        }
      }
      else
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          v14 = "%{public}s called with null listener, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }
LABEL_49:
    if (v11)
      free(v11);
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
    v11 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v100[0]) = 0;
    if (__nwlog_fault(v11, type, v100))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          v14 = "%{public}s called with null webtransport_session";
          goto LABEL_48;
        }
      }
      else if (LOBYTE(v100[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v12 = __nwlog_obj();
        v13 = type[0];
        v67 = os_log_type_enabled(v12, type[0]);
        if (backtrace_string)
        {
          if (!v67)
            goto LABEL_25;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          v23 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
          goto LABEL_24;
        }
        if (v67)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          v14 = "%{public}s called with null webtransport_session, no backtrace";
          goto LABEL_48;
        }
      }
      else
      {
        v12 = __nwlog_obj();
        v13 = type[0];
        if (os_log_type_enabled(v12, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
          v14 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }
    goto LABEL_49;
  }
  v7 = *((_QWORD *)handle + 50);
  if ((handle[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v64 = __nwlog_obj();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
      {
        v65 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v108) = 1024;
        *(_DWORD *)((char *)&v108 + 2) = v65;
        HIWORD(v108) = 2112;
        v109 = a2;
        _os_log_impl(&dword_182FBE000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> creating new inbound flow from %@", buf, 0x30u);
      }
    }
  }
  if (!v7)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
    v11 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v100[0]) = 0;
    if (!__nwlog_fault(v11, type, v100))
      goto LABEL_49;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
      v14 = "%{public}s No listener found for webtransport inbound stream";
      goto LABEL_48;
    }
    if (!LOBYTE(v100[0]))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
      v14 = "%{public}s No listener found for webtransport inbound stream, backtrace limit exceeded";
      goto LABEL_48;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type[0];
    v22 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (!v22)
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
      v14 = "%{public}s No listener found for webtransport inbound stream, no backtrace";
      goto LABEL_48;
    }
    if (!v22)
    {
LABEL_25:
      free(backtrace_string);
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v23 = "%{public}s No listener found for webtransport inbound stream, dumping backtrace:%{public}s";
LABEL_24:
    _os_log_impl(&dword_182FBE000, v12, v13, v23, buf, 0x16u);
    goto LABEL_25;
  }
  v8 = *((_DWORD *)handle + 112);
  if (v8 >= 2)
  {
    if (v8 != 2 || (handle[548] & 2) != 0)
      return 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v17 = *((_DWORD *)handle + 115);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 464;
    *(_WORD *)&buf[22] = 2080;
    v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
    LOWORD(v108) = 1024;
    *(_DWORD *)((char *)&v108 + 2) = v17;
    v18 = "%{public}s %{public}s%s<i%u> Cannot create new inbound flow with unknown transport mode";
    v19 = v15;
    v20 = OS_LOG_TYPE_ERROR;
    goto LABEL_19;
  }
  if (*((_DWORD *)handle + 111) != 2)
  {
    v24 = handle[548] | 0x20;
    handle[548] = v24;
    if (v8 != 1)
    {
LABEL_56:
      result = (**(uint64_t (***)(uint64_t, nw_endpoint *, nw_parameters *))v7)(v7, a2, a3);
      handle[548] &= ~0x20u;
      *((_QWORD *)handle + 22) = -1;
      return result;
    }
    if (*(_QWORD *)(v7 + 8))
    {
      v25 = (void *)*((_QWORD *)handle + 47);
      if (v25)
      {
        last_application_stream_id = nw_http_connection_metadata_get_last_application_stream_id(v25);
        if ((handle[548] & 2) != 0)
          goto LABEL_55;
      }
      else
      {
        last_application_stream_id = -1;
        if ((v24 & 2) != 0)
        {
LABEL_55:
          *((_QWORD *)handle + 22) = last_application_stream_id;
          goto LABEL_56;
        }
      }
      if (gLogDatapath)
      {
        v82 = __nwlog_obj();
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
        {
          v83 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_get_quic_stream_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v108) = 1024;
          *(_DWORD *)((char *)&v108 + 2) = v83;
          HIWORD(v108) = 2048;
          v109 = (void *)last_application_stream_id;
          v110 = 1024;
          v111 = 1;
          _os_log_impl(&dword_182FBE000, v82, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got stream ID: %llu from session: %u", buf, 0x36u);
        }
      }
      goto LABEL_55;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_http3_get_quic_stream_id";
    v72 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v100[0]) = 0;
    if (__nwlog_fault(v72, type, v100))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v73 = __nwlog_obj();
        v74 = type[0];
        if (os_log_type_enabled(v73, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_get_quic_stream_id";
          v75 = "%{public}s called with null output_protocol";
LABEL_171:
          _os_log_impl(&dword_182FBE000, v73, v74, v75, buf, 0xCu);
        }
      }
      else if (LOBYTE(v100[0]))
      {
        v84 = (char *)__nw_create_backtrace_string();
        v73 = __nwlog_obj();
        v74 = type[0];
        v85 = os_log_type_enabled(v73, type[0]);
        if (v84)
        {
          if (v85)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_http3_get_quic_stream_id";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v84;
            _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s called with null output_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v84);
          goto LABEL_172;
        }
        if (v85)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_get_quic_stream_id";
          v75 = "%{public}s called with null output_protocol, no backtrace";
          goto LABEL_171;
        }
      }
      else
      {
        v73 = __nwlog_obj();
        v74 = type[0];
        if (os_log_type_enabled(v73, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_get_quic_stream_id";
          v75 = "%{public}s called with null output_protocol, backtrace limit exceeded";
          goto LABEL_171;
        }
      }
    }
LABEL_172:
    if (v72)
      free(v72);
    last_application_stream_id = -1;
    goto LABEL_55;
  }
  protocol_handler = a1->protocol_handler;
  v10 = MEMORY[0x1E0C809B0];
  if (!protocol_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
    v68 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v100[0]) = 0;
    if (!__nwlog_fault(v68, type, v100))
      goto LABEL_178;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v69 = __nwlog_obj();
      v70 = type[0];
      if (!os_log_type_enabled(v69, type[0]))
        goto LABEL_178;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
      v71 = "%{public}s called with null transport_protocol";
    }
    else if (LOBYTE(v100[0]))
    {
      v76 = (char *)__nw_create_backtrace_string();
      v69 = __nwlog_obj();
      v70 = type[0];
      v77 = os_log_type_enabled(v69, type[0]);
      if (v76)
      {
        if (v77)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v76;
          _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s called with null transport_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v76);
LABEL_178:
        if (!v68)
          goto LABEL_69;
        goto LABEL_179;
      }
      if (!v77)
        goto LABEL_178;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
      v71 = "%{public}s called with null transport_protocol, no backtrace";
    }
    else
    {
      v69 = __nwlog_obj();
      v70 = type[0];
      if (!os_log_type_enabled(v69, type[0]))
        goto LABEL_178;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
      v71 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
    }
LABEL_177:
    _os_log_impl(&dword_182FBE000, v69, v70, v71, buf, 0xCu);
    goto LABEL_178;
  }
  if ((handle[548] & 0x40) == 0)
  {
    nw_protocol_add_input_handler((uint64_t)a1->protocol_handler, (uint64_t)handle);
    goto LABEL_69;
  }
  parameters = (void *)nw_protocol_get_parameters((uint64_t)handle);
  if (parameters)
  {
    v28 = parameters;
    nw_parameters_log_protocol_instances(parameters);
    v29 = v28;
    v30 = v29[19];

    v100[0] = 0;
    v100[1] = v100;
    v100[2] = 0x2000000000;
    v101 = 0;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3802000000;
    v107 = __Block_byref_object_copy__33462;
    v108 = __Block_byref_object_dispose__33463;
    v109 = 0;
    LOBYTE(v110) = v110 | 1;
    *(_QWORD *)type = v10;
    v94 = 0x40000000;
    v95 = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
    v96 = &unk_1E14A0660;
    v97 = v100;
    v98 = buf;
    v99 = handle;
    nw_protocol_stack_iterate_application_protocols(v30, type);
    v31 = *(void **)(*(_QWORD *)&buf[8] + 40);
    if (v31)
    {
      if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
        dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72293);
      v32 = (id)nw_protocol_copy_http_messaging_definition_definition;
      v33 = v31;
      v33[2] = protocol_handler;

      if (v32)
        os_release(v32);
      v34 = (void *)nw_protocol_get_parameters((uint64_t)protocol_handler);
      if (!v34)
        goto LABEL_63;
      v35 = v34;
      v36 = v35[19];

      v37 = v29;
      v38 = v29[19];

      v39 = nw_protocol_stack_copy_transport_protocol(v36);
      v40 = nw_protocol_stack_copy_transport_protocol(v38);
      v41 = v40;
      if (v39)
      {
        if (v40)
        {
          v42 = nw_protocol_options_copy_definition(v39);
          if (nw_protocol_options_matches_definition(v41, v42))
          {
            protocol_handle = nw_protocol_options_get_protocol_handle(v39);
            nw_parameters_set_protocol_instance(v41, v44, protocol_handle);
          }
          os_release(v41);
        }
        v41 = v39;
      }
      else if (!v40)
      {
LABEL_59:
        if (v38)
          os_release(v38);
        if (v36)
          os_release(v36);
LABEL_63:
        nw_protocol_set_output_handler((uint64_t)handle, 0);
        nw_protocol_add_input_handler((uint64_t)protocol_handler, (uint64_t)handle);
LABEL_64:
        _Block_object_dispose(buf, 8);
        if ((v110 & 1) != 0 && v109)
          os_release(v109);
        _Block_object_dispose(v100, 8);
        if (v30)
          os_release(v30);
        goto LABEL_69;
      }
      os_release(v41);
      goto LABEL_59;
    }
    __nwlog_obj();
    *(_DWORD *)v102 = 136446210;
    v103 = "nw_webtransport_session_add_to_http_messaging";
    v78 = (char *)_os_log_send_and_compose_impl();
    v92 = OS_LOG_TYPE_ERROR;
    v91 = 0;
    if (__nwlog_fault(v78, &v92, &v91))
    {
      if (v92 == OS_LOG_TYPE_FAULT)
      {
        v79 = __nwlog_obj();
        v80 = v92;
        if (!os_log_type_enabled(v79, v92))
          goto LABEL_183;
        *(_DWORD *)v102 = 136446210;
        v103 = "nw_webtransport_session_add_to_http_messaging";
        v81 = "%{public}s called with null options";
        goto LABEL_182;
      }
      if (!v91)
      {
        v79 = __nwlog_obj();
        v80 = v92;
        if (!os_log_type_enabled(v79, v92))
          goto LABEL_183;
        *(_DWORD *)v102 = 136446210;
        v103 = "nw_webtransport_session_add_to_http_messaging";
        v81 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_182;
      }
      v88 = (char *)__nw_create_backtrace_string();
      v79 = __nwlog_obj();
      v80 = v92;
      v89 = os_log_type_enabled(v79, v92);
      if (v88)
      {
        if (v89)
        {
          *(_DWORD *)v102 = 136446466;
          v103 = "nw_webtransport_session_add_to_http_messaging";
          v104 = 2082;
          v105 = v88;
          _os_log_impl(&dword_182FBE000, v79, v80, "%{public}s called with null options, dumping backtrace:%{public}s", v102, 0x16u);
        }
        free(v88);
        goto LABEL_183;
      }
      if (v89)
      {
        *(_DWORD *)v102 = 136446210;
        v103 = "nw_webtransport_session_add_to_http_messaging";
        v81 = "%{public}s called with null options, no backtrace";
LABEL_182:
        _os_log_impl(&dword_182FBE000, v79, v80, v81, v102, 0xCu);
      }
    }
LABEL_183:
    if (v78)
      free(v78);
    goto LABEL_64;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
  v68 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v100[0]) = 0;
  if (!__nwlog_fault(v68, type, v100))
    goto LABEL_178;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v69 = __nwlog_obj();
    v70 = type[0];
    if (!os_log_type_enabled(v69, type[0]))
      goto LABEL_178;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v71 = "%{public}s called with null parameters";
    goto LABEL_177;
  }
  if (!LOBYTE(v100[0]))
  {
    v69 = __nwlog_obj();
    v70 = type[0];
    if (!os_log_type_enabled(v69, type[0]))
      goto LABEL_178;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v71 = "%{public}s called with null parameters, backtrace limit exceeded";
    goto LABEL_177;
  }
  v86 = (char *)__nw_create_backtrace_string();
  v69 = __nwlog_obj();
  v70 = type[0];
  v87 = os_log_type_enabled(v69, type[0]);
  if (!v86)
  {
    if (!v87)
      goto LABEL_178;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v71 = "%{public}s called with null parameters, no backtrace";
    goto LABEL_177;
  }
  if (v87)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v86;
    _os_log_impl(&dword_182FBE000, v69, v70, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v86);
  if (v68)
LABEL_179:
    free(v68);
LABEL_69:
  if (!*((_QWORD *)handle + 4))
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v50 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v51 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v108) = 1024;
        *(_DWORD *)((char *)&v108 + 2) = v51;
        _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> failed to get output handler for HTTP/3 CONNECT stream, failing", buf, 0x26u);
      }
    }
    if (*((_DWORD *)handle + 111) != 5)
    {
      if ((handle[548] & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v54 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v55 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v108) = 1024;
          *(_DWORD *)((char *)&v108 + 2) = v55;
          HIWORD(v108) = 1024;
          LODWORD(v109) = 57;
          _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
        }
      }
      *((_DWORD *)handle + 111) = 5;
      v56 = (char *)*((_QWORD *)handle + 23);
      if (v56)
      {
        *(_QWORD *)buf = v10;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
        v107 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_22_33428;
        LODWORD(v108) = 57;
        nw_hash_table_apply(v56, (uint64_t)buf);
      }
      v57 = *((_QWORD *)handle + 53);
      if (v57)
      {
        v58 = *(_QWORD **)(v57 + 48);
        nw_protocol_error(v58, *((_QWORD *)handle + 53));
        nw_protocol_disconnected(v58, v57);
      }
      v59 = *((_QWORD *)handle + 41);
      if (v59)
      {
        do
        {
          v60 = *(_QWORD *)(v59 + 112);
          v61 = *(_QWORD **)(v59 + 48);
          nw_protocol_error(v61, v59);
          nw_protocol_disconnected(v61, v59);
          v59 = v60;
        }
        while (v60);
      }
      v62 = *((_QWORD *)handle + 52);
      if (v62)
      {
        v63 = *(_QWORD **)(v62 + 48);
        nw_protocol_error(v63, *((_QWORD *)handle + 52));
        nw_protocol_disconnected(v63, v62);
      }
      if (*((_QWORD *)handle + 4))
      {
        nw_protocol_remove_instance((uint64_t)handle);
        nw_protocol_disconnect(*((_QWORD **)handle + 4), (uint64_t)handle);
      }
      return 0;
    }
    if ((handle[548] & 2) != 0)
      return 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v52 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      return 0;
    v53 = *((_DWORD *)handle + 115);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 464;
    *(_WORD *)&buf[22] = 2080;
    v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
    LOWORD(v108) = 1024;
    *(_DWORD *)((char *)&v108 + 2) = v53;
    v18 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
    v19 = v52;
    v20 = OS_LOG_TYPE_INFO;
LABEL_19:
    _os_log_impl(&dword_182FBE000, v19, v20, v18, buf, 0x26u);
    return 0;
  }
  if ((handle[548] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v45 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v46 = *((_DWORD *)handle + 115);
      v47 = (void *)*((_QWORD *)handle + 4);
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_new_flow";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v107 = (uint64_t (*)(uint64_t, uint64_t))" ";
      LOWORD(v108) = 1024;
      *(_DWORD *)((char *)&v108 + 2) = v46;
      HIWORD(v108) = 2048;
      v109 = v47;
      _os_log_impl(&dword_182FBE000, v45, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Got output handler from new_flow %p for CONNECT stream, sending async connect and awaiting input for session", buf, 0x30u);
    }
  }
  *((_DWORD *)handle + 111) = 3;
  v48 = *((_QWORD *)handle + 54);
  v49 = (void *)*((_QWORD *)handle + 49);
  v90[0] = v10;
  v90[1] = 0x40000000;
  v90[2] = ___ZL57nw_protocol_webtransport_session_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke;
  v90[3] = &unk_1E14A07B8;
  v90[4] = v48;
  nw_queue_context_async(v49, v90);
  return 1;
}

void nw_protocol_webtransport_session_listen_protocol_disconnected(nw_listen_protocol *a1, nw_protocol *a2, int a3)
{
  char *handle;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  int v11;
  char *v12;
  _BOOL4 v13;
  const char *v14;
  uint64_t v15;
  int v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  int v21;
  char *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  NSObject *v32;
  int v33;
  char *backtrace_string;
  _BOOL4 v35;
  _BOOL4 v36;
  char v37;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v40;
  _BYTE v41[6];
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault(v6, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          v9 = "%{public}s called with null listener";
LABEL_29:
          _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v7 = __nwlog_obj();
        v8 = type;
        v35 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v35)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          v9 = "%{public}s called with null listener, no backtrace";
          goto LABEL_29;
        }
      }
      else
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          v9 = "%{public}s called with null listener, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }
LABEL_30:
    if (v6)
      goto LABEL_31;
    return;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        v32 = __nwlog_obj();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          v33 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v40 = " ";
          *(_WORD *)v41 = 1024;
          *(_DWORD *)&v41[2] = v33;
          _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> listen protocol is disconnected", buf, 0x26u);
        }
      }
    }
    if (*((nw_protocol **)handle + 4) != a2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      v6 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (!__nwlog_fault(v6, &type, &v37))
        goto LABEL_30;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_30;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler";
        goto LABEL_29;
      }
      if (!v37)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        v8 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_30;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, backtr"
             "ace limit exceeded";
        goto LABEL_29;
      }
      v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      v13 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v12)
      {
        if (!v13)
          goto LABEL_30;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        v9 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, no backtrace";
        goto LABEL_29;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v12;
        v14 = "%{public}s Ignoring webtransport listen protocol disconnected, not sent by connected output handler, dumpi"
              "ng backtrace:%{public}s";
LABEL_18:
        _os_log_impl(&dword_182FBE000, v7, v8, v14, buf, 0x16u);
        goto LABEL_19;
      }
      goto LABEL_19;
    }
    if (*((_DWORD *)handle + 111) == 5)
    {
      if ((handle[548] & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v11 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v40 = " ";
          *(_WORD *)v41 = 1024;
          *(_DWORD *)&v41[2] = v11;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Session already terminated, ignoring", buf, 0x26u);
        }
      }
      return;
    }
    if (a3)
    {
      if ((handle[548] & 2) != 0)
        goto LABEL_36;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        goto LABEL_36;
      v16 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v40 = " ";
      *(_WORD *)v41 = 1024;
      *(_DWORD *)&v41[2] = v16;
      v42 = 1024;
      v43 = a3;
      v17 = "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d";
      v18 = v15;
      v19 = 44;
    }
    else
    {
      if ((handle[548] & 2) != 0)
        goto LABEL_36;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        goto LABEL_36;
      v21 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v40 = " ";
      *(_WORD *)v41 = 1024;
      *(_DWORD *)&v41[2] = v21;
      v17 = "%{public}s %{public}s%s<i%u> Closing webtransport session without error";
      v18 = v20;
      v19 = 38;
    }
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_INFO, v17, buf, v19);
LABEL_36:
    *((_DWORD *)handle + 111) = 5;
    v22 = (char *)*((_QWORD *)handle + 23);
    if (v22)
    {
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
      v40 = (const char *)&__block_descriptor_tmp_22_33428;
      *(_DWORD *)v41 = a3;
      nw_hash_table_apply(v22, (uint64_t)buf);
    }
    v23 = *((_QWORD *)handle + 53);
    if (v23)
    {
      v24 = *(_QWORD **)(v23 + 48);
      if (a3)
        nw_protocol_error(*(_QWORD **)(v23 + 48), *((_QWORD *)handle + 53));
      nw_protocol_disconnected(v24, v23);
    }
    v25 = *((_QWORD *)handle + 41);
    if (v25)
    {
      if (a3)
      {
        do
        {
          v26 = *(_QWORD *)(v25 + 112);
          v27 = *(_QWORD **)(v25 + 48);
          nw_protocol_error(v27, v25);
          v28 = v25;
          v25 = v26;
          nw_protocol_disconnected(v27, v28);
        }
        while (v26);
      }
      else
      {
        do
        {
          v29 = *(_QWORD *)(v25 + 112);
          nw_protocol_disconnected(*(_QWORD **)(v25 + 48), v25);
          v25 = v29;
        }
        while (v29);
      }
    }
    v30 = *((_QWORD *)handle + 52);
    if (v30)
    {
      v31 = *(_QWORD **)(v30 + 48);
      if (a3)
        nw_protocol_error(*(_QWORD **)(v30 + 48), *((_QWORD *)handle + 52));
      nw_protocol_disconnected(v31, v30);
    }
    if (*((_QWORD *)handle + 4))
    {
      nw_protocol_remove_instance((uint64_t)handle);
      nw_protocol_disconnect(*((_QWORD **)handle + 4), (uint64_t)handle);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (!__nwlog_fault(v6, &type, &v37))
    goto LABEL_30;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      v9 = "%{public}s called with null webtransport_session";
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  if (!v37)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      v9 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v36 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (v36)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
      v9 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  if (v36)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_listen_protocol_disconnected";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v12;
    v14 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
    goto LABEL_18;
  }
LABEL_19:
  free(v12);
  if (v6)
LABEL_31:
    free(v6);
}

uint64_t ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t object;
  uint64_t v4;
  int v5;
  _QWORD *v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  object = nw_hash_node_get_object(a2);
  if (object)
  {
    v4 = object;
    v5 = *(_DWORD *)(a1 + 32);
    v6 = *(_QWORD **)(object + 48);
    if (v5)
      nw_protocol_error(*(_QWORD **)(object + 48), object);
    nw_protocol_disconnected(v6, v4);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_webtransport_stream_terminate";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_webtransport_stream_terminate";
      v11 = "%{public}s called with null webtransport_stream";
      goto LABEL_19;
    }
    if (!v14)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_webtransport_stream_terminate";
      v11 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_19;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v13 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v17 = "nw_webtransport_stream_terminate";
        v18 = 2082;
        v19 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_20;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      v17 = "nw_webtransport_stream_terminate";
      v11 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_19:
      _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    }
  }
LABEL_20:
  if (v8)
    free(v8);
  return 1;
}

uint64_t __Block_byref_object_copy__33462(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__33463(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

void ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke(_QWORD *a1, void *a2)
{
  void *v2;
  uint64_t v4;
  char v5;
  void *v6;

  v2 = a2;
  if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    if (!*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40) && nw_protocol_options_is_http_messaging(a2))
    {
      if (v2)
        v2 = os_retain(v2);
      v4 = *(_QWORD *)(a1[5] + 8);
      v5 = *(_BYTE *)(v4 + 48);
      if ((v5 & 1) != 0)
      {
        v6 = *(void **)(v4 + 40);
        if (v6)
        {
          os_release(v6);
          v5 = *(_BYTE *)(v4 + 48);
        }
      }
      *(_QWORD *)(v4 + 40) = v2;
      *(_BYTE *)(v4 + 48) = v5 | 1;
    }
  }
  else if (nw_protocol_options_get_protocol_handle(a2) == a1[6])
  {
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
  }
}

uint64_t ___ZL57nw_protocol_webtransport_session_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (result)
    return nw_protocol_connect(*(_QWORD *)(result + 32), result);
  return result;
}

void ___ZL42nw_protocol_webtransport_session_callbacksv_block_invoke()
{
  qword_1EDCF1AA0 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCF1AA8 = nw_protocol_default_input_flush;
  qword_1EDCF1A70 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCF1A78 = nw_protocol_default_waiting_for_output;
  qword_1EDCF1A30 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCF1A38 = nw_protocol_default_unregister_notification;
  nw_protocol_webtransport_session_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_session_add_input_handler;
  *(_QWORD *)algn_1EDCF19A8 = nw_protocol_webtransport_session_remove_input_handler;
  qword_1EDCF19B0 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1EDCF19B8 = nw_protocol_webtransport_session_connect;
  qword_1EDCF19C0 = (uint64_t)nw_protocol_webtransport_session_disconnect;
  unk_1EDCF19C8 = nw_protocol_webtransport_session_connected;
  qword_1EDCF19D0 = (uint64_t)nw_protocol_webtransport_session_disconnected;
  unk_1EDCF19D8 = nw_protocol_webtransport_session_error;
  qword_1EDCF19E0 = (uint64_t)nw_protocol_webtransport_session_input_available;
  unk_1EDCF19E8 = nw_protocol_webtransport_session_output_available;
  qword_1EDCF19F0 = (uint64_t)nw_protocol_webtransport_session_get_input_frames;
  unk_1EDCF19F8 = nw_protocol_webtransport_session_get_output_frames;
  qword_1EDCF1A00 = (uint64_t)nw_protocol_webtransport_session_finalize_output_frames;
  unk_1EDCF1A08 = nw_protocol_default_link_state;
  qword_1EDCF1A10 = (uint64_t)nw_protocol_webtransport_session_get_parameters;
  unk_1EDCF1A18 = nw_protocol_default_get_path;
  qword_1EDCF1A20 = (uint64_t)nw_protocol_default_get_local;
  unk_1EDCF1A28 = nw_protocol_webtransport_session_get_remote_endpoint;
  qword_1EDCF1A40 = (uint64_t)nw_protocol_webtransport_session_notify;
  unk_1EDCF1A48 = nw_protocol_default_updated_path;
  qword_1EDCF1A50 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1EDCF1A58 = nw_protocol_webtransport_session_input_finished;
  qword_1EDCF1A60 = (uint64_t)nw_protocol_webtransport_session_output_finished;
  unk_1EDCF1A68 = nw_protocol_default_get_output_local;
  qword_1EDCF1A80 = (uint64_t)nw_protocol_webtransport_session_copy_info;
  unk_1EDCF1A88 = nw_protocol_webtransport_session_add_listen_handler;
  qword_1EDCF1A90 = (uint64_t)nw_protocol_webtransport_session_remove_listen_handler;
  unk_1EDCF1A98 = nw_protocol_default_get_message_properties;
}

BOOL nw_protocol_webtransport_session_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  NSObject *v4;
  _BOOL8 result;
  int v6;
  nw_protocol *v7;
  uint64_t parameters;
  uint64_t *v9;
  uint64_t remote_endpoint;
  void *v11;
  uint64_t *v12;
  NSObject *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  NSObject *v18;
  int v19;
  nw_protocol_stack_t v20;
  NWConcrete_nw_protocol_options *v21;
  id v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  char v26;
  void *v27;
  nw_protocol_identifier *identifier;
  unsigned __int8 *v29;
  _QWORD *v30;
  void *v31;
  char v32;
  void *v33;
  void *v34;
  char v35;
  void *v36;
  id *singleton;
  char v38;
  void *v39;
  char v40;
  nw_protocol *v41;
  void *v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  id v45;
  unsigned __int8 *v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  unsigned __int8 *v49;
  uint64_t v50;
  char *v51;
  unint64_t v52;
  int v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  const char *v57;
  NSObject *v58;
  uint64_t v59;
  int v60;
  char *v61;
  _BOOL4 v62;
  uint64_t v63;
  _QWORD *v64;
  NSObject *v65;
  int v66;
  uint64_t v67;
  unsigned int v68;
  int v69;
  uint64_t v70;
  unsigned __int8 *v71;
  unsigned __int8 *v72;
  char v73;
  _BOOL4 is_unidirectional;
  char v75;
  char v76;
  NSObject *v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  NSObject *v81;
  uint64_t v82;
  int v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char *v88;
  NSObject *v89;
  os_log_type_t v90;
  uint64_t v91;
  const char *v92;
  void *v93;
  NSObject *v94;
  os_log_type_t v95;
  const char *v96;
  char *v97;
  _BOOL4 v98;
  NSObject *v99;
  uint64_t v100;
  int v101;
  NSObject *v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  unsigned __int8 *v106;
  unsigned __int8 *v107;
  char v108;
  _BOOL4 v109;
  char v110;
  char v111;
  NSObject *v112;
  uint64_t v113;
  int v114;
  NSObject *v115;
  uint64_t v116;
  int v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  NSObject *v121;
  uint64_t v122;
  int v123;
  char *v124;
  _BOOL4 v125;
  uint64_t v126;
  NSObject *v127;
  uint64_t v128;
  int v129;
  NSObject *v130;
  uint64_t v131;
  int v132;
  uint64_t v133;
  NSObject *v134;
  os_log_type_t v135;
  uint32_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  const char *v140;
  NSObject *v141;
  os_log_type_t v142;
  uint32_t v143;
  uint64_t v144;
  NSObject *v145;
  uint64_t v146;
  int v147;
  uint64_t v148;
  NSObject *v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  char v153;
  uint64_t v154;
  int v155;
  uint64_t v156;
  unsigned int v157;
  uint64_t v158;
  unsigned int v159;
  uint64_t v160;
  const char *v161;
  NSObject *v162;
  os_log_type_t v163;
  uint64_t v164;
  NSObject *v165;
  uint64_t v166;
  int v167;
  NSObject *v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  const char *v172;
  uint64_t v173;
  uint64_t v174;
  _QWORD *v175;
  uint64_t v176;
  char v177;
  NSObject *v178;
  uint64_t v179;
  int v180;
  NSObject *v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  unsigned int v185;
  uint64_t v186;
  uint64_t v187;
  void *v188;
  void *v189;
  NSObject *v190;
  NSObject *v191;
  void *v192;
  id v193;
  _QWORD *v194;
  NSObject *v195;
  unsigned __int8 *v196;
  NSObject *v197;
  NSObject *v198;
  NSObject *v199;
  nw_protocol_options_t v200;
  nw_protocol_options_t v201;
  nw_protocol_definition_t v202;
  uint64_t protocol_handle;
  uint64_t v204;
  char v205;
  uint64_t v206;
  void *v207;
  char *v208;
  NSObject *v209;
  os_log_type_t v210;
  const char *v211;
  nw_protocol *v212;
  NSObject *v213;
  _BOOL4 v214;
  int v215;
  char *backtrace_string;
  _BOOL4 v217;
  const char *v218;
  _BOOL4 v219;
  _BOOL4 v220;
  NSObject *v221;
  void *v222;
  char *v223;
  NSObject *v224;
  os_log_type_t v225;
  const char *v226;
  NSObject *v227;
  const char *v228;
  const char *v229;
  uint64_t v230;
  int v231;
  NSObject *v232;
  uint64_t v233;
  int v234;
  char *v235;
  NSObject *v236;
  os_log_type_t v237;
  const char *v238;
  NSObject *v239;
  uint64_t v240;
  int v241;
  _BOOL4 v242;
  _BOOL4 v243;
  NSObject *v244;
  uint64_t v245;
  int v246;
  void *v247;
  char *v248;
  NSObject *v249;
  os_log_type_t v250;
  char *v251;
  NSObject *v252;
  os_log_type_t v253;
  const char *v254;
  char *v255;
  NSObject *v256;
  os_log_type_t v257;
  const char *v258;
  NSObject *v259;
  os_log_type_t v260;
  NSObject *v261;
  uint64_t v262;
  int v263;
  NSObject *v264;
  uint64_t v265;
  int v266;
  char *v267;
  _BOOL4 v268;
  char *v269;
  _BOOL4 v270;
  char *v271;
  NSObject *v272;
  _BOOL4 v273;
  char *v274;
  _BOOL4 v275;
  char *v276;
  _BOOL4 v277;
  char *v278;
  _BOOL4 v279;
  NSObject *v280;
  uint64_t v281;
  int v282;
  NSObject *v283;
  uint64_t v284;
  int v285;
  char *v286;
  NSObject *v287;
  os_log_type_t v288;
  const char *v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  os_log_type_t v294;
  uint64_t v295;
  uint64_t v296;
  char *v297;
  NSObject *v298;
  os_log_type_t v299;
  _BOOL4 v300;
  char *v301;
  NSObject *v302;
  os_log_type_t v303;
  const char *v304;
  uint64_t v305;
  int v306;
  char *v307;
  _BOOL4 v308;
  char *v309;
  NSObject *v310;
  os_log_type_t v311;
  _BOOL4 v312;
  uint64_t v313;
  uint64_t v314;
  NSObject *v315;
  os_log_type_t v316;
  uint64_t v317;
  int v318;
  uint64_t v319;
  _QWORD *v320;
  NSObject *v321;
  int v322;
  NSObject *v323;
  os_log_type_t v324;
  uint64_t v325;
  os_log_type_t type;
  const char *v327;
  unsigned __int8 *v328;
  nw_protocol *v329;
  char v330;
  os_log_type_t v331;
  uint64_t aBlock;
  uint64_t v333;
  void *v334;
  void *v335;
  os_log_type_t *v336;
  _BYTE *v337;
  _QWORD *v338;
  os_log_type_t v339[8];
  os_log_type_t *v340;
  uint64_t v341;
  char v342;
  _BYTE buf[24];
  uint64_t v344;
  _BYTE v345[28];
  _QWORD *v346;
  __int16 v347;
  nw_protocol *v348;
  __int16 v349;
  void *v350;
  __int16 v351;
  unsigned __int8 *v352;
  int v353;
  const char *v354;
  __int16 v355;
  char *v356;
  uint64_t v357;

  v357 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v208, &aBlock, v339))
      goto LABEL_482;
    if (aBlock == 17)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null protocol";
      goto LABEL_481;
    }
    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_481;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v209 = __nwlog_obj();
    v210 = aBlock;
    v217 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v217)
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_481;
    }
    if (!v217)
      goto LABEL_394;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_393:
    _os_log_impl(&dword_182FBE000, v209, v210, v218, buf, 0x16u);
    goto LABEL_394;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v208, &aBlock, v339))
      goto LABEL_482;
    if (aBlock == 17)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null webtransport_session";
      goto LABEL_481;
    }
    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_481;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v209 = __nwlog_obj();
    v210 = aBlock;
    v219 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v219)
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_481;
    }
    if (!v219)
      goto LABEL_394;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
    goto LABEL_393;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v208, &aBlock, v339))
      goto LABEL_482;
    if (aBlock == 17)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null input_protocol";
      goto LABEL_481;
    }
    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_481;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v209 = __nwlog_obj();
    v210 = aBlock;
    v220 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v220)
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_481;
    }
    if (!v220)
      goto LABEL_394;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_393;
  }
  if ((handle[137] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v212 = a2;
      v213 = __nwlog_obj();
      v214 = os_log_type_enabled(v213, OS_LOG_TYPE_DEBUG);
      a2 = v212;
      if (v214)
      {
        v215 = handle[115];
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 116;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v215;
        _os_log_impl(&dword_182FBE000, v213, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        a2 = v212;
      }
    }
  }
  if (handle[111] == 5)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      if (result)
      {
        v6 = handle[115];
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 116;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v6;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> cannot add input handler to closed session", buf, 0x26u);
        return 0;
      }
      return result;
    }
    return 0;
  }
  v7 = a2;
  parameters = nw_protocol_get_parameters((uint64_t)a2);
  if (!parameters)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v208, &aBlock, v339))
      goto LABEL_482;
    if (aBlock == 17)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null parameters";
      goto LABEL_481;
    }
    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_481;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v209 = __nwlog_obj();
    v210 = aBlock;
    v242 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (!backtrace_string)
    {
      if (!v242)
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_481;
    }
    if (!v242)
      goto LABEL_394;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v218 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
    goto LABEL_393;
  }
  v9 = (uint64_t *)parameters;
  v329 = v7;
  remote_endpoint = nw_protocol_get_remote_endpoint((uint64_t)v7);
  if (!remote_endpoint)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    v208 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v208, &aBlock, v339))
      goto LABEL_482;
    if (aBlock == 17)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null remote_endpoint";
      goto LABEL_481;
    }
    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v209 = __nwlog_obj();
      v210 = aBlock;
      if (!os_log_type_enabled(v209, (os_log_type_t)aBlock))
        goto LABEL_482;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      v211 = "%{public}s called with null remote_endpoint, backtrace limit exceeded";
      goto LABEL_481;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v209 = __nwlog_obj();
    v210 = aBlock;
    v243 = os_log_type_enabled(v209, (os_log_type_t)aBlock);
    if (backtrace_string)
    {
      if (v243)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v218 = "%{public}s called with null remote_endpoint, dumping backtrace:%{public}s";
        goto LABEL_393;
      }
LABEL_394:
      free(backtrace_string);
      goto LABEL_482;
    }
    if (!v243)
      goto LABEL_482;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
    v211 = "%{public}s called with null remote_endpoint, no backtrace";
LABEL_481:
    _os_log_impl(&dword_182FBE000, v209, v210, v211, buf, 0xCu);
LABEL_482:
    if (v208)
      free(v208);
    return 0;
  }
  v11 = (void *)remote_endpoint;
  if (*((_QWORD *)handle + 43))
    goto LABEL_35;
  v12 = v9;
  v13 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v12, 0, 1);

  v14 = nw_parameters_copy_protocol_options_legacy(v13, (nw_protocol *)handle);
  nw_protocol_options_get_log_id_str(v14, (_BYTE *)handle + 464, 84);
  handle[115] = nw_protocol_get_next_instance_id();
  v15 = v14;
  v16 = v15;
  if (!v15)
  {
    __nwlog_obj();
    v247 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_options_get_top_id";
    v327 = (const char *)_os_log_send_and_compose_impl();

    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    v248 = (char *)v327;
    if (!__nwlog_fault(v327, &aBlock, v339))
    {
LABEL_537:
      if (v248)
        free(v248);
      v17 = 0;
      goto LABEL_15;
    }
    if (aBlock == 17)
    {
      __nwlog_obj();
      v249 = objc_claimAutoreleasedReturnValue();
      v250 = aBlock;
      if (os_log_type_enabled(v249, (os_log_type_t)aBlock))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_options_get_top_id";
        _os_log_impl(&dword_182FBE000, v249, v250, "%{public}s called with null options", buf, 0xCu);
      }

    }
    else
    {
      if (v339[0])
      {
        v271 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v272 = objc_claimAutoreleasedReturnValue();
        type = aBlock;
        v273 = os_log_type_enabled(v272, (os_log_type_t)aBlock);
        if (v271)
        {
          if (v273)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_options_get_top_id";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v271;
            _os_log_impl(&dword_182FBE000, v272, type, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v271);
          goto LABEL_536;
        }
        if (v273)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_options_get_top_id";
          _os_log_impl(&dword_182FBE000, v272, type, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v272 = objc_claimAutoreleasedReturnValue();
        v294 = aBlock;
        if (os_log_type_enabled(v272, (os_log_type_t)aBlock))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_options_get_top_id";
          _os_log_impl(&dword_182FBE000, v272, v294, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_536:
    v248 = (char *)v327;
    goto LABEL_537;
  }
  v17 = *((_DWORD *)v15 + 33);
LABEL_15:

  if ((handle[137] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v19 = handle[115];
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 116;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v19;
      *(_WORD *)&v345[6] = 1024;
      *(_DWORD *)&v345[8] = v19;
      *(_WORD *)&v345[12] = 1024;
      *(_DWORD *)&v345[14] = v17;
      _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> created WebTransport session and assigned instance ID: %u from C%u", buf, 0x32u);
    }
  }
  if (v16)
  {
    v20 = nw_parameters_copy_default_protocol_stack(v13);
    v21 = nw_protocol_options_copy(v16);
    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
    v22 = (id)nw_protocol_copy_webtransport_definition::definition;
    nw_parameters_set_protocol_instance(v21, v23, (uint64_t)handle);
    if (v22)
      os_release(v22);
    nw_protocol_stack_replace_protocol_with_handle(v20, (uint64_t)handle, v21);
    if (v21)
      os_release(v21);
    if (v20)
      os_release(v20);
  }
  else if ((handle[137] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v25 = handle[115];
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 116;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v25;
      *(_WORD *)&v345[6] = 2048;
      *(_QWORD *)&v345[8] = v13;
      *(_WORD *)&v345[16] = 2048;
      *(_QWORD *)&v345[18] = v12;
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> failed to find webtransport options in new parameters %p, copy of %p", buf, 0x3Au);
    }
  }
  v26 = *((_BYTE *)handle + 352);
  if ((v26 & 1) != 0)
  {
    v27 = (void *)*((_QWORD *)handle + 43);
    if (v27)
    {
      os_release(v27);
      v26 = *((_BYTE *)handle + 352);
    }
  }
  *((_QWORD *)handle + 43) = v13;
  *((_BYTE *)handle + 352) = v26 | 1;
  if (v16)
    os_release(v16);
LABEL_35:
  identifier = a1->identifier;
  v29 = nw_parameters_copy_protocol_options_legacy(v9, (nw_protocol *)handle);
  if (!v29)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
    v54 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v54, &aBlock, v339))
    {
      if (aBlock == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = gLogObj;
        v56 = aBlock;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
          v57 = "%{public}s called with null webtransport_stream";
LABEL_92:
          _os_log_impl(&dword_182FBE000, v55, v56, v57, buf, 0xCu);
        }
      }
      else if (v339[0])
      {
        v61 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = gLogObj;
        v56 = aBlock;
        v62 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock);
        if (v61)
        {
          if (v62)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v61;
            _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v61);
          goto LABEL_93;
        }
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
          v57 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_92;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = gLogObj;
        v56 = aBlock;
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
          v57 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_92;
        }
      }
    }
LABEL_93:
    if (v54)
      free(v54);
    v30 = 0;
    goto LABEL_98;
  }
  v30 = malloc_type_calloc(1uLL, 0x118uLL, 0xEAFB8F1AuLL);
  if (!v30)
  {
    v221 = __nwlog_obj();
    os_log_type_enabled(v221, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = 1;
    *(_WORD *)&buf[22] = 2048;
    v344 = 280;
    v222 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v222);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v222);
  }
  v30[34] = 0;
  *((_OWORD *)v30 + 15) = 0u;
  *((_OWORD *)v30 + 16) = 0u;
  *((_OWORD *)v30 + 13) = 0u;
  *((_OWORD *)v30 + 14) = 0u;
  *((_OWORD *)v30 + 11) = 0u;
  *((_OWORD *)v30 + 12) = 0u;
  *((_OWORD *)v30 + 9) = 0u;
  *((_OWORD *)v30 + 10) = 0u;
  *((_OWORD *)v30 + 7) = 0u;
  *((_OWORD *)v30 + 8) = 0u;
  *((_OWORD *)v30 + 5) = 0u;
  *((_OWORD *)v30 + 6) = 0u;
  *((_OWORD *)v30 + 3) = 0u;
  *((_OWORD *)v30 + 4) = 0u;
  *((_OWORD *)v30 + 1) = 0u;
  *((_OWORD *)v30 + 2) = 0u;
  *(_OWORD *)v30 = 0u;
  v30[2] = identifier;
  if (nw_protocol_webtransport_stream_callbacks(void)::onceToken != -1)
    dispatch_once(&nw_protocol_webtransport_stream_callbacks(void)::onceToken, &__block_literal_global_18_34349);
  v30[3] = &nw_protocol_webtransport_stream_callbacks(void)::protocol_callbacks;
  v30[5] = v30;
  v30[9] = 0;
  v30[10] = v30 + 9;
  v30[11] = handle;
  v31 = os_retain(v11);
  v32 = *((_BYTE *)v30 + 136);
  if ((v32 & 1) != 0)
  {
    v33 = (void *)v30[16];
    if (v33)
    {
      os_release(v33);
      v32 = *((_BYTE *)v30 + 136);
    }
  }
  v30[16] = v31;
  *((_BYTE *)v30 + 136) = v32 | 1;
  v34 = os_retain(v9);
  v35 = *((_BYTE *)v30 + 152);
  if ((v35 & 1) != 0)
  {
    v36 = (void *)v30[18];
    if (v36)
    {
      os_release(v36);
      v35 = *((_BYTE *)v30 + 152);
    }
  }
  v30[18] = v34;
  *((_BYTE *)v30 + 152) = v35 | 1;
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
  singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_webtransport_definition::definition);
  v38 = *((_BYTE *)v30 + 168);
  if ((v38 & 1) != 0)
  {
    v39 = (void *)v30[20];
    if (v39)
    {
      os_release(v39);
      v38 = *((_BYTE *)v30 + 168);
    }
  }
  v30[20] = singleton;
  *((_BYTE *)v30 + 168) = v38 | 1;
  if (nw_path_parameters_get_logging_disabled(v9[13]))
    v40 = 16;
  else
    v40 = 0;
  *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xEF | v40;
  v30[8] = -1;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2000000000;
  v344 = (uint64_t)v30;
  aBlock = MEMORY[0x1E0C809B0];
  v333 = 0x40000000;
  v334 = ___ZL38nw_protocol_webtransport_stream_createPK22nw_protocol_identifierP23nw_webtransport_sessionP11nw_endpointP13nw_parameters_block_invoke;
  v335 = &unk_1E14A0430;
  v336 = (os_log_type_t *)buf;
  v30[22] = _Block_copy(&aBlock);
  _Block_object_dispose(buf, 8);
  if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v227 = __nwlog_obj();
      if (os_log_type_enabled(v227, OS_LOG_TYPE_DEBUG))
      {
        if (v30)
          v228 = (const char *)(v30 + 24);
        else
          v228 = "";
        v229 = " ";
        if (!v30)
          v229 = "";
        v230 = v30[11];
        if (v230)
          v231 = *(_DWORD *)(v230 + 460);
        else
          v231 = -1;
        v290 = v30[8];
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_create";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v228;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)v229;
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v231;
        *(_WORD *)&v345[6] = 2048;
        *(_QWORD *)&v345[8] = v290;
        *(_WORD *)&v345[16] = 2048;
        *(_QWORD *)&v345[18] = v30;
        _os_log_impl(&dword_182FBE000, v227, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> created WebTransport stream with protocol pointer %p", buf, 0x3Au);
      }
    }
  }
  os_release(v29);
  if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v232 = __nwlog_obj();
      if (os_log_type_enabled(v232, OS_LOG_TYPE_DEBUG))
      {
        v233 = v30[11];
        if (v233)
          v234 = *(_DWORD *)(v233 + 460);
        else
          v234 = -1;
        v291 = v30[8];
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v30 + 24;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v234;
        *(_WORD *)&v345[6] = 2048;
        *(_QWORD *)&v345[8] = v291;
        _os_log_impl(&dword_182FBE000, v232, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  nw_protocol_set_input_handler((uint64_t)v30, (uint64_t)v329);
  *(_OWORD *)v30 = *(_OWORD *)v329->flow_id;
  nw_protocol_set_output_handler((uint64_t)v329, (uint64_t)v30);
  v41 = (nw_protocol *)v30[11];
  if (!v41)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
    v223 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v223, &aBlock, v339))
      goto LABEL_498;
    if (aBlock == 17)
    {
      v224 = __nwlog_obj();
      v225 = aBlock;
      if (!os_log_type_enabled(v224, (os_log_type_t)aBlock))
        goto LABEL_498;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
      v226 = "%{public}s called with null options_protocol";
    }
    else if (v339[0])
    {
      v267 = (char *)__nw_create_backtrace_string();
      v224 = __nwlog_obj();
      v225 = aBlock;
      v268 = os_log_type_enabled(v224, (os_log_type_t)aBlock);
      if (v267)
      {
        if (v268)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v267;
          _os_log_impl(&dword_182FBE000, v224, v225, "%{public}s called with null options_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v267);
        goto LABEL_498;
      }
      if (!v268)
      {
LABEL_498:
        if (v223)
          free(v223);
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
      v226 = "%{public}s called with null options_protocol, no backtrace";
    }
    else
    {
      v224 = __nwlog_obj();
      v225 = aBlock;
      if (!os_log_type_enabled(v224, (os_log_type_t)aBlock))
        goto LABEL_498;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
      v226 = "%{public}s called with null options_protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v224, v225, v226, buf, 0xCu);
    goto LABEL_498;
  }
  v42 = (void *)v30[18];
  if (v42)
  {
    if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v239 = __nwlog_obj();
        if (os_log_type_enabled(v239, OS_LOG_TYPE_DEBUG))
        {
          v240 = v30[11];
          if (v240)
            v241 = *(_DWORD *)(v240 + 460);
          else
            v241 = -1;
          v292 = v30[8];
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_replace_protocol_instance";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v30 + 24;
          *(_WORD *)&buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v241;
          *(_WORD *)&v345[6] = 2048;
          *(_QWORD *)&v345[8] = v292;
          _os_log_impl(&dword_182FBE000, v239, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    v43 = nw_parameters_copy_protocol_options_legacy(v42, v41);
    if (v43)
    {
      v44 = v43;
      if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v244 = __nwlog_obj();
          if (os_log_type_enabled(v244, OS_LOG_TYPE_DEBUG))
          {
            v245 = v30[11];
            if (v245)
              v246 = *(_DWORD *)(v245 + 460);
            else
              v246 = -1;
            v293 = v30[8];
            *(_DWORD *)buf = 136448514;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_replace_protocol_instance";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30 + 24;
            *(_WORD *)&buf[22] = 2080;
            v344 = (uint64_t)" ";
            *(_WORD *)v345 = 1024;
            *(_DWORD *)&v345[2] = v246;
            *(_WORD *)&v345[6] = 2048;
            *(_QWORD *)&v345[8] = v293;
            *(_WORD *)&v345[16] = 2048;
            *(_QWORD *)&v345[18] = v30;
            *(_WORD *)&v345[26] = 2048;
            v346 = v30;
            v347 = 2048;
            v348 = v41;
            v349 = 2048;
            v350 = v42;
            v351 = 2048;
            v352 = v44;
            _os_log_impl(&dword_182FBE000, v244, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> webtransport_stream protocol %p, set protocol instance to %p instead of %p in parameters %p options %p", buf, 0x62u);
          }
        }
      }
      if (nw_protocol_copy_webtransport_definition::onceToken != -1)
        dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
      v45 = (id)nw_protocol_copy_webtransport_definition::definition;
      v46 = v44;
      *((_QWORD *)v46 + 2) = v30;

      if (v45)
        os_release(v45);
      os_release(v46);
    }
    goto LABEL_69;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_webtransport_stream_replace_protocol_instance";
  v235 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(aBlock) = 16;
  v339[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v235, &aBlock, v339))
  {
    if (aBlock == 17)
    {
      v236 = __nwlog_obj();
      v237 = aBlock;
      if (!os_log_type_enabled(v236, (os_log_type_t)aBlock))
        goto LABEL_503;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_replace_protocol_instance";
      v238 = "%{public}s called with null parameters";
      goto LABEL_502;
    }
    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v236 = __nwlog_obj();
      v237 = aBlock;
      if (!os_log_type_enabled(v236, (os_log_type_t)aBlock))
        goto LABEL_503;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_replace_protocol_instance";
      v238 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_502;
    }
    v269 = (char *)__nw_create_backtrace_string();
    v236 = __nwlog_obj();
    v237 = aBlock;
    v270 = os_log_type_enabled(v236, (os_log_type_t)aBlock);
    if (v269)
    {
      if (v270)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_replace_protocol_instance";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v269;
        _os_log_impl(&dword_182FBE000, v236, v237, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v269);
      goto LABEL_503;
    }
    if (v270)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_replace_protocol_instance";
      v238 = "%{public}s called with null parameters, no backtrace";
LABEL_502:
      _os_log_impl(&dword_182FBE000, v236, v237, v238, buf, 0xCu);
    }
  }
LABEL_503:
  if (v235)
    free(v235);
LABEL_69:
  v47 = nw_parameters_copy_protocol_options_legacy((void *)v30[18], (nw_protocol *)v30);
  if (v47)
  {
    v48 = v47;
    v49 = v48;
    v50 = 0;
    *((_BYTE *)v30 + 192) = 0;
    v51 = (char *)(v30 + 24);
    v52 = 84;
    while (1)
    {
      v53 = v48[v50 + 48];
      v51[v50] = v53;
      if (!v53)
        break;
      --v52;
      ++v50;
      if (v52 <= 1)
      {
        v51[v50] = 0;
        break;
      }
    }

    os_release(v49);
  }
  else if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v58 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v59 = v30[11];
      if (v59)
        v60 = *(_DWORD *)(v59 + 460);
      else
        v60 = -1;
      v63 = v30[8];
      v64 = (_QWORD *)v30[18];
      *(_DWORD *)buf = 136447746;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v30 + 24;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v60;
      *(_WORD *)&v345[6] = 2048;
      *(_QWORD *)&v345[8] = v63;
      *(_WORD *)&v345[16] = 2048;
      *(_QWORD *)&v345[18] = v30;
      *(_WORD *)&v345[26] = 2048;
      v346 = v64;
      _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to access options for protocol %p, parameters %p", buf, 0x44u);
    }
  }
LABEL_98:
  if (!*((_QWORD *)handle + 6))
  {
    nw_protocol_set_input_handler((uint64_t)handle, (uint64_t)v30);
    *(_OWORD *)handle = *(_OWORD *)v329->flow_id;
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v65 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v66 = handle[115];
        v67 = *((_QWORD *)handle + 6);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 116;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v66;
        *(_WORD *)&v345[6] = 2048;
        *(_QWORD *)&v345[8] = v67;
        _os_log_impl(&dword_182FBE000, v65, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Set session default_input_handler: %p", buf, 0x30u);
      }
    }
  }
  v68 = handle[137] & 0x20;
  v69 = handle[112];
  if (v69 != 1)
  {
    if (!v69)
    {
      if (v29)
      {
        if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v261 = __nwlog_obj();
            if (os_log_type_enabled(v261, OS_LOG_TYPE_DEBUG))
            {
              v262 = v30[11];
              if (v262)
                v263 = *(_DWORD *)(v262 + 460);
              else
                v263 = -1;
              v295 = v30[8];
              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v30 + 24;
              *(_WORD *)&buf[22] = 2080;
              v344 = (uint64_t)" ";
              *(_WORD *)v345 = 1024;
              *(_DWORD *)&v345[2] = v263;
              *(_WORD *)&v345[6] = 2048;
              *(_QWORD *)&v345[8] = v295;
              *(_WORD *)&v345[16] = 2048;
              *(_QWORD *)&v345[18] = v30;
              *(_WORD *)&v345[26] = 1024;
              LODWORD(v346) = v68 >> 5;
              _os_log_impl(&dword_182FBE000, v261, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
            }
          }
        }
        v70 = v30[11];
        if (*(_QWORD **)(v70 + 416) == v30)
        {
          if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v283 = __nwlog_obj();
              if (os_log_type_enabled(v283, OS_LOG_TYPE_DEBUG))
              {
                v284 = v30[11];
                if (v284)
                  v285 = *(_DWORD *)(v284 + 460);
                else
                  v285 = -1;
                v313 = v30[8];
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v30 + 24;
                *(_WORD *)&buf[22] = 2080;
                v344 = (uint64_t)" ";
                *(_WORD *)v345 = 1024;
                *(_DWORD *)&v345[2] = v285;
                *(_WORD *)&v345[6] = 2048;
                *(_QWORD *)&v345[8] = v313;
                _os_log_impl(&dword_182FBE000, v283, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream", buf, 0x30u);
              }
            }
          }
          nw_protocol_connected((_QWORD *)v30[6], (uint64_t)v30);
          goto LABEL_256;
        }
        if (nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken != -1)
          dispatch_once(&nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken, &__block_literal_global_28);
        v30[3] = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
        nw_protocol_set_output_handler((uint64_t)v30, v70);
        v71 = nw_parameters_copy_protocol_options_legacy((void *)v30[18], (nw_protocol *)v30);
        if (!v71)
        {
          if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v99 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              v100 = v30[11];
              if (v100)
                v101 = *(_DWORD *)(v100 + 460);
              else
                v101 = -1;
              v138 = v30[8];
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v30 + 24;
              *(_WORD *)&buf[22] = 2080;
              v344 = (uint64_t)" ";
              *(_WORD *)v345 = 1024;
              *(_DWORD *)&v345[2] = v101;
              *(_WORD *)&v345[6] = 2048;
              *(_QWORD *)&v345[8] = v138;
              _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
            }
          }
          goto LABEL_256;
        }
        v72 = v71;
        if (v68)
        {
          if ((*((_BYTE *)v30 + 276) & 0x10) != 0)
            goto LABEL_255;
          if (!gLogDatapath)
            goto LABEL_255;
          v102 = __nwlog_obj();
          if (!os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
            goto LABEL_255;
          v103 = v30[11];
          if (v103)
            v104 = *(_DWORD *)(v103 + 460);
          else
            v104 = -1;
          v314 = v30[8];
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v30 + 24;
          *(_WORD *)&buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v104;
          *(_WORD *)&v345[6] = 2048;
          *(_QWORD *)&v345[8] = v314;
          v161 = "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment to setup metadata";
          v162 = v102;
          v163 = OS_LOG_TYPE_DEBUG;
        }
        else
        {
          if (nw_protocol_options_is_webtransport(v71))
          {
            *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xFC | 1;
            if (nw_webtransport_options_get_is_datagram(v72))
              v73 = 8;
            else
              v73 = 0;
            *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xF7 | v73;
            is_unidirectional = nw_webtransport_options_get_is_unidirectional(v72);
            v75 = *((_BYTE *)v30 + 276);
            if (is_unidirectional)
              v76 = 4;
            else
              v76 = 0;
            *((_BYTE *)v30 + 276) = v75 & 0xFB | v76;
            if ((v75 & 0x10) == 0)
            {
              v77 = __nwlog_obj();
              if (os_log_type_enabled(v77, OS_LOG_TYPE_INFO))
              {
                v78 = v30[11];
                if (v78)
                  v79 = *(_DWORD *)(v78 + 460);
                else
                  v79 = -1;
                v156 = v30[8];
                v157 = *((unsigned __int8 *)v30 + 276);
                *(_DWORD *)buf = 136448002;
                *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v30 + 24;
                *(_WORD *)&buf[22] = 2080;
                v344 = (uint64_t)" ";
                *(_WORD *)v345 = 1024;
                *(_DWORD *)&v345[2] = v79;
                *(_WORD *)&v345[6] = 2048;
                *(_QWORD *)&v345[8] = v156;
                *(_WORD *)&v345[16] = 1024;
                *(_DWORD *)&v345[18] = (v157 >> 1) & 1;
                *(_WORD *)&v345[22] = 1024;
                *(_DWORD *)&v345[24] = (v157 >> 3) & 1;
                LOWORD(v346) = 1024;
                *(_DWORD *)((char *)&v346 + 2) = (v157 >> 2) & 1;
                _os_log_impl(&dword_182FBE000, v77, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
              }
            }
            nw_webtransport_metadata_set_is_peer_initiated((void *)v30[20], (*((_BYTE *)v30 + 276) & 2) != 0);
            nw_webtransport_metadata_set_is_datagram((void *)v30[20], (*((_BYTE *)v30 + 276) & 8) != 0);
            nw_webtransport_metadata_set_is_unidirectional((void *)v30[20], (*((_BYTE *)v30 + 276) & 4) != 0);
            goto LABEL_255;
          }
          if ((*((_BYTE *)v30 + 276) & 0x10) != 0
            || (v127 = __nwlog_obj(), !os_log_type_enabled(v127, OS_LOG_TYPE_ERROR)))
          {
LABEL_255:
            os_release(v72);
LABEL_256:
            nw_protocol_connected(v30, (uint64_t)handle);
            goto LABEL_589;
          }
          v128 = v30[11];
          if (v128)
            v129 = *(_DWORD *)(v128 + 460);
          else
            v129 = -1;
          v160 = v30[8];
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v30 + 24;
          *(_WORD *)&buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v129;
          *(_WORD *)&v345[6] = 2048;
          *(_QWORD *)&v345[8] = v160;
          v161 = "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream";
          v162 = v127;
          v163 = OS_LOG_TYPE_ERROR;
        }
        _os_log_impl(&dword_182FBE000, v162, v163, v161, buf, 0x30u);
        goto LABEL_255;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
      v251 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(aBlock) = 16;
      v339[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v251, &aBlock, v339))
      {
        if (aBlock == 17)
        {
          v252 = __nwlog_obj();
          v253 = aBlock;
          if (!os_log_type_enabled(v252, (os_log_type_t)aBlock))
            goto LABEL_543;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          v254 = "%{public}s called with null webtransport_stream";
          goto LABEL_542;
        }
        if (v339[0] == OS_LOG_TYPE_DEFAULT)
        {
          v252 = __nwlog_obj();
          v253 = aBlock;
          if (!os_log_type_enabled(v252, (os_log_type_t)aBlock))
            goto LABEL_543;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          v254 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_542;
        }
        v274 = (char *)__nw_create_backtrace_string();
        v252 = __nwlog_obj();
        v253 = aBlock;
        v275 = os_log_type_enabled(v252, (os_log_type_t)aBlock);
        if (v274)
        {
          if (v275)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v274;
            _os_log_impl(&dword_182FBE000, v252, v253, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v274);
          goto LABEL_543;
        }
        if (v275)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
          v254 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_542:
          _os_log_impl(&dword_182FBE000, v252, v253, v254, buf, 0xCu);
        }
      }
LABEL_543:
      if (v251)
        free(v251);
      goto LABEL_256;
    }
    if (v29)
    {
      if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v264 = __nwlog_obj();
          if (os_log_type_enabled(v264, OS_LOG_TYPE_DEBUG))
          {
            v265 = v30[11];
            if (v265)
              v266 = *(_DWORD *)(v265 + 460);
            else
              v266 = -1;
            v296 = v30[8];
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30 + 24;
            *(_WORD *)&buf[22] = 2080;
            v344 = (uint64_t)" ";
            *(_WORD *)v345 = 1024;
            *(_DWORD *)&v345[2] = v266;
            *(_WORD *)&v345[6] = 2048;
            *(_QWORD *)&v345[8] = v296;
            *(_WORD *)&v345[16] = 2048;
            *(_QWORD *)&v345[18] = v30;
            _os_log_impl(&dword_182FBE000, v264, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called for stream (%p)", buf, 0x3Au);
          }
        }
      }
      if ((*((_BYTE *)v30 + 276) & 0x20) == 0)
      {
        v30[14] = 0;
        v84 = (_QWORD *)*((_QWORD *)handle + 42);
        v30[15] = v84;
        *v84 = v30;
        *((_QWORD *)handle + 42) = v30 + 14;
        v85 = handle[114] + 1;
        v86 = v85 << 31 >> 31;
        handle[114] = v85;
        if (v86 == v85 && (v86 & 0x8000000000000000) == 0)
        {
LABEL_240:
          v153 = *((_BYTE *)v30 + 276);
          *((_BYTE *)v30 + 276) = v153 | 0x20;
          if ((v153 & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v280 = __nwlog_obj();
              if (os_log_type_enabled(v280, OS_LOG_TYPE_DEBUG))
              {
                v281 = v30[11];
                if (v281)
                  v282 = *(_DWORD *)(v281 + 460);
                else
                  v282 = -1;
                v305 = v30[8];
                v306 = handle[114];
                *(_DWORD *)buf = 136447746;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v30 + 24;
                *(_WORD *)&buf[22] = 2080;
                v344 = (uint64_t)" ";
                *(_WORD *)v345 = 1024;
                *(_DWORD *)&v345[2] = v282;
                *(_WORD *)&v345[6] = 2048;
                *(_QWORD *)&v345[8] = v305;
                *(_WORD *)&v345[16] = 2048;
                *(_QWORD *)&v345[18] = v30;
                *(_WORD *)&v345[26] = 1024;
                LODWORD(v346) = v306;
                _os_log_impl(&dword_182FBE000, v280, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> added stream (%p), now have %u pending streams", buf, 0x40u);
              }
            }
          }
          goto LABEL_242;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v87 = handle[114];
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
        *(_WORD *)&buf[22] = 2048;
        v344 = 1;
        *(_WORD *)v345 = 2048;
        *(_QWORD *)&v345[2] = v87;
        v88 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(aBlock) = 16;
        v339[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v88, &aBlock, v339))
        {
          if (aBlock == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v89 = gLogObj;
            v90 = aBlock;
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock))
            {
              v91 = handle[114];
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v344 = 1;
              *(_WORD *)v345 = 2048;
              *(_QWORD *)&v345[2] = v91;
              v92 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_236:
              _os_log_impl(&dword_182FBE000, v89, v90, v92, buf, 0x2Au);
            }
          }
          else if (v339[0])
          {
            v124 = (char *)__nw_create_backtrace_string();
            v89 = __nwlog_obj();
            v90 = aBlock;
            v125 = os_log_type_enabled(v89, (os_log_type_t)aBlock);
            if (v124)
            {
              if (v125)
              {
                v126 = handle[114];
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                v344 = 1;
                *(_WORD *)v345 = 2048;
                *(_QWORD *)&v345[2] = v126;
                *(_WORD *)&v345[10] = 2082;
                *(_QWORD *)&v345[12] = v124;
                _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v124);
              goto LABEL_237;
            }
            if (v125)
            {
              v152 = handle[114];
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v344 = 1;
              *(_WORD *)v345 = 2048;
              *(_QWORD *)&v345[2] = v152;
              v92 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_236;
            }
          }
          else
          {
            v89 = __nwlog_obj();
            v90 = aBlock;
            if (os_log_type_enabled(v89, (os_log_type_t)aBlock))
            {
              v137 = handle[114];
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v344 = 1;
              *(_WORD *)v345 = 2048;
              *(_QWORD *)&v345[2] = v137;
              v92 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_236;
            }
          }
        }
LABEL_237:
        if (v88)
          free(v88);
        handle[114] = -1;
        goto LABEL_240;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v30;
      v93 = (void *)_os_log_send_and_compose_impl();
      LOBYTE(aBlock) = 16;
      v339[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault((const char *)v93, &aBlock, v339))
      {
        if (aBlock == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v94 = gLogObj;
          v95 = aBlock;
          if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock))
            goto LABEL_212;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v30;
          v96 = "%{public}s stream %p already in pending list, cannot add again";
          goto LABEL_210;
        }
        if (v339[0] == OS_LOG_TYPE_DEFAULT)
        {
          v94 = __nwlog_obj();
          v95 = aBlock;
          if (!os_log_type_enabled(v94, (os_log_type_t)aBlock))
            goto LABEL_212;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v30;
          v96 = "%{public}s stream %p already in pending list, cannot add again, backtrace limit exceeded";
          goto LABEL_210;
        }
        v97 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v94 = gLogObj;
        v95 = aBlock;
        v98 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)aBlock);
        if (v97)
        {
          if (v98)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v30;
            *(_WORD *)&buf[22] = 2082;
            v344 = (uint64_t)v97;
            _os_log_impl(&dword_182FBE000, v94, v95, "%{public}s stream %p already in pending list, cannot add again, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v97);
          if (!v93)
            goto LABEL_242;
LABEL_213:
          free(v93);
LABEL_242:
          if ((handle[137] & 2) != 0)
            goto LABEL_589;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v154 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            goto LABEL_589;
          v155 = handle[115];
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 116;
          *(_WORD *)&buf[22] = 2080;
          v344 = (uint64_t)" ";
          *(_WORD *)v345 = 1024;
          *(_DWORD *)&v345[2] = v155;
          v140 = "%{public}s %{public}s%s<i%u> Not reconfiguring stream, no transport mode determined yet";
          v141 = v154;
          v142 = OS_LOG_TYPE_INFO;
          v143 = 38;
          goto LABEL_245;
        }
        if (v98)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v30;
          v96 = "%{public}s stream %p already in pending list, cannot add again, no backtrace";
LABEL_210:
          v134 = v94;
          v135 = v95;
          v136 = 22;
LABEL_211:
          _os_log_impl(&dword_182FBE000, v134, v135, v96, buf, v136);
        }
      }
LABEL_212:
      if (!v93)
        goto LABEL_242;
      goto LABEL_213;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
    v93 = (void *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v93, &aBlock, v339))
      goto LABEL_212;
    if (aBlock == 17)
    {
      v259 = __nwlog_obj();
      v260 = aBlock;
      if (!os_log_type_enabled(v259, (os_log_type_t)aBlock))
        goto LABEL_212;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
      v96 = "%{public}s called with null webtransport_stream";
    }
    else if (v339[0])
    {
      v278 = (char *)__nw_create_backtrace_string();
      v259 = __nwlog_obj();
      v260 = aBlock;
      v279 = os_log_type_enabled(v259, (os_log_type_t)aBlock);
      if (v278)
      {
        if (v279)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v278;
          _os_log_impl(&dword_182FBE000, v259, v260, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v278);
        goto LABEL_212;
      }
      if (!v279)
        goto LABEL_212;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
      v96 = "%{public}s called with null webtransport_stream, no backtrace";
    }
    else
    {
      v259 = __nwlog_obj();
      v260 = aBlock;
      if (!os_log_type_enabled(v259, (os_log_type_t)aBlock))
        goto LABEL_212;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_pending_stream";
      v96 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    }
    v134 = v259;
    v135 = v260;
    v136 = 12;
    goto LABEL_211;
  }
  if (!v29)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
    v255 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v255, &aBlock, v339))
      goto LABEL_548;
    if (aBlock == 17)
    {
      v256 = __nwlog_obj();
      v257 = aBlock;
      if (!os_log_type_enabled(v256, (os_log_type_t)aBlock))
        goto LABEL_548;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
      v258 = "%{public}s called with null webtransport_stream";
    }
    else if (v339[0])
    {
      v276 = (char *)__nw_create_backtrace_string();
      v256 = __nwlog_obj();
      v257 = aBlock;
      v277 = os_log_type_enabled(v256, (os_log_type_t)aBlock);
      if (v276)
      {
        if (v277)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v276;
          _os_log_impl(&dword_182FBE000, v256, v257, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v276);
        goto LABEL_548;
      }
      if (!v277)
      {
LABEL_548:
        if (v255)
          free(v255);
        goto LABEL_589;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
      v258 = "%{public}s called with null webtransport_stream, no backtrace";
    }
    else
    {
      v256 = __nwlog_obj();
      v257 = aBlock;
      if (!os_log_type_enabled(v256, (os_log_type_t)aBlock))
        goto LABEL_548;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
      v258 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v256, v257, v258, buf, 0xCu);
    goto LABEL_548;
  }
  v80 = v30[11];
  if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v81 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v82 = v30[11];
      if (v82)
        v83 = *(_DWORD *)(v82 + 460);
      else
        v83 = -1;
      v105 = v30[8];
      *(_DWORD *)buf = 136447746;
      *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v30 + 24;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v83;
      *(_WORD *)&v345[6] = 2048;
      *(_QWORD *)&v345[8] = v105;
      *(_WORD *)&v345[16] = 2048;
      *(_QWORD *)&v345[18] = v30;
      *(_WORD *)&v345[26] = 1024;
      LODWORD(v346) = v68 >> 5;
      _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP3 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
    }
  }
  if (*(_QWORD **)(v80 + 416) == v30)
  {
    if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v115 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        v116 = v30[11];
        if (v116)
          v117 = *(_DWORD *)(v116 + 460);
        else
          v117 = -1;
        v133 = v30[8];
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v30 + 24;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v117;
        *(_WORD *)&v345[6] = 2048;
        *(_QWORD *)&v345[8] = v133;
        _os_log_impl(&dword_182FBE000, v115, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning connected without more reconfiguration for placeholder stream", buf, 0x30u);
      }
    }
    nw_protocol_connected((_QWORD *)v30[6], (uint64_t)v30);
    goto LABEL_589;
  }
  v106 = nw_parameters_copy_protocol_options_legacy((void *)v30[18], (nw_protocol *)v30);
  if (!v106)
  {
    if ((*((_BYTE *)v30 + 276) & 0x10) != 0)
      goto LABEL_589;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v118 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      goto LABEL_589;
    v119 = v30[11];
    if (v119)
      v120 = *(_DWORD *)(v119 + 460);
    else
      v120 = -1;
    v139 = v30[8];
    *(_DWORD *)buf = 136447234;
    *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v30 + 24;
    *(_WORD *)&buf[22] = 2080;
    v344 = (uint64_t)" ";
    *(_WORD *)v345 = 1024;
    *(_DWORD *)&v345[2] = v120;
    *(_WORD *)&v345[6] = 2048;
    *(_QWORD *)&v345[8] = v139;
    v140 = "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring";
    v141 = v118;
    v142 = OS_LOG_TYPE_ERROR;
    v143 = 48;
LABEL_245:
    _os_log_impl(&dword_182FBE000, v141, v142, v140, buf, v143);
    goto LABEL_589;
  }
  v107 = v106;
  if (nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken != -1)
    dispatch_once(&nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken, &__block_literal_global_42_33727);
  v30[3] = &nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks;
  if (v68)
  {
    if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v121 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        v122 = v30[11];
        if (v122)
          v123 = *(_DWORD *)(v122 + 460);
        else
          v123 = -1;
        v144 = v30[8];
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v30 + 24;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v123;
        *(_WORD *)&v345[6] = 2048;
        *(_QWORD *)&v345[8] = v144;
        _os_log_impl(&dword_182FBE000, v121, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Preemptively configuring metadata with incoming stream ID", buf, 0x30u);
      }
    }
    if (*(_QWORD *)(v80 + 176) != -1)
    {
      if (v30[8] == -1)
      {
        v148 = *(_QWORD *)(v30[11] + 176);
        if (v148 == -1)
        {
          if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
          {
            v168 = __nwlog_obj();
            if (os_log_type_enabled(v168, OS_LOG_TYPE_ERROR))
            {
              v169 = v30[11];
              if (v169)
                v170 = *(_DWORD *)(v169 + 460);
              else
                v170 = -1;
              v174 = v30[8];
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v30 + 24;
              *(_WORD *)&buf[22] = 2080;
              v344 = (uint64_t)" ";
              *(_WORD *)v345 = 1024;
              *(_DWORD *)&v345[2] = v170;
              *(_WORD *)&v345[6] = 2048;
              *(_QWORD *)&v345[8] = v174;
              _os_log_impl(&dword_182FBE000, v168, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing", buf, 0x30u);
            }
          }
          v175 = (_QWORD *)v30[6];
          nw_protocol_error(v175, (uint64_t)v30);
          nw_protocol_disconnected(v175, (uint64_t)v30);
        }
        else
        {
          v30[8] = v148;
          nw_webtransport_metadata_set_stream_id((void *)v30[20], v148);
          if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
          {
            v149 = __nwlog_obj();
            if (os_log_type_enabled(v149, OS_LOG_TYPE_INFO))
            {
              v150 = v30[11];
              if (v150)
                v151 = *(_DWORD *)(v150 + 460);
              else
                v151 = -1;
              v173 = v30[8];
              *(_DWORD *)buf = 136448002;
              *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v30 + 24;
              *(_WORD *)&buf[22] = 2080;
              v344 = (uint64_t)" ";
              *(_WORD *)v345 = 1024;
              *(_DWORD *)&v345[2] = v151;
              *(_WORD *)&v345[6] = 2048;
              *(_QWORD *)&v345[8] = v173;
              *(_WORD *)&v345[16] = 2048;
              *(_QWORD *)&v345[18] = v173;
              *(_WORD *)&v345[26] = 2048;
              v346 = v30;
              v347 = 1024;
              LODWORD(v348) = 1;
              _os_log_impl(&dword_182FBE000, v149, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u", buf, 0x4Au);
            }
          }
        }
      }
      else if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v145 = __nwlog_obj();
          if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
          {
            v146 = v30[11];
            if (v146)
              v147 = *(_DWORD *)(v146 + 460);
            else
              v147 = -1;
            v325 = v30[8];
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30 + 24;
            *(_WORD *)&buf[22] = 2080;
            v344 = (uint64_t)" ";
            *(_WORD *)v345 = 1024;
            *(_DWORD *)&v345[2] = v147;
            *(_WORD *)&v345[6] = 2048;
            *(_QWORD *)&v345[8] = v325;
            *(_WORD *)&v345[16] = 2048;
            *(_QWORD *)&v345[18] = v325;
            _os_log_impl(&dword_182FBE000, v145, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping", buf, 0x3Au);
          }
        }
      }
      v176 = v30[8];
      v177 = *((_BYTE *)v30 + 276);
      if (v176 == -1)
      {
        if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
        {
          v181 = __nwlog_obj();
          if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
          {
            v182 = v30[11];
            if (v182)
              v183 = *(_DWORD *)(v182 + 460);
            else
              v183 = -1;
            v186 = v30[8];
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30 + 24;
            *(_WORD *)&buf[22] = 2080;
            v344 = (uint64_t)" ";
            *(_WORD *)v345 = 1024;
            *(_DWORD *)&v345[2] = v183;
            *(_WORD *)&v345[6] = 2048;
            *(_QWORD *)&v345[8] = v186;
            _os_log_impl(&dword_182FBE000, v181, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set", buf, 0x30u);
          }
        }
      }
      else
      {
        *((_BYTE *)v30 + 276) = v177 & 0xF0 | (4 * ((v176 & 2) != 0)) | 3;
        if ((v177 & 0x10) == 0)
        {
          v178 = __nwlog_obj();
          if (os_log_type_enabled(v178, OS_LOG_TYPE_INFO))
          {
            v179 = v30[11];
            if (v179)
              v180 = *(_DWORD *)(v179 + 460);
            else
              v180 = -1;
            v184 = v30[8];
            v185 = *((unsigned __int8 *)v30 + 276);
            *(_DWORD *)buf = 136448002;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v30 + 24;
            *(_WORD *)&buf[22] = 2080;
            v344 = (uint64_t)" ";
            *(_WORD *)v345 = 1024;
            *(_DWORD *)&v345[2] = v180;
            *(_WORD *)&v345[6] = 2048;
            *(_QWORD *)&v345[8] = v184;
            *(_WORD *)&v345[16] = 1024;
            *(_DWORD *)&v345[18] = (v185 >> 1) & 1;
            *(_WORD *)&v345[22] = 1024;
            *(_DWORD *)&v345[24] = (v185 >> 3) & 1;
            LOWORD(v346) = 1024;
            *(_DWORD *)((char *)&v346 + 2) = (v185 >> 2) & 1;
            _os_log_impl(&dword_182FBE000, v178, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
          }
        }
        nw_webtransport_metadata_set_is_peer_initiated((void *)v30[20], (*((_BYTE *)v30 + 276) & 2) != 0);
        nw_webtransport_metadata_set_is_datagram((void *)v30[20], (*((_BYTE *)v30 + 276) & 8) != 0);
        nw_webtransport_metadata_set_is_unidirectional((void *)v30[20], (*((_BYTE *)v30 + 276) & 4) != 0);
      }
    }
    if ((*((_BYTE *)v30 + 276) & 0x40) != 0)
      goto LABEL_295;
LABEL_294:
    nw_webtransport_http3_stream_fix_http_parameters(v80, (uint64_t)v30);
    goto LABEL_295;
  }
  if (nw_protocol_options_is_webtransport(v107))
  {
    *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xFC | 1;
    if (nw_webtransport_options_get_is_datagram(v107))
      v108 = 8;
    else
      v108 = 0;
    *((_BYTE *)v30 + 276) = *((_BYTE *)v30 + 276) & 0xF7 | v108;
    v109 = nw_webtransport_options_get_is_unidirectional(v107);
    v110 = *((_BYTE *)v30 + 276);
    if (v109)
      v111 = 4;
    else
      v111 = 0;
    *((_BYTE *)v30 + 276) = v110 & 0xFB | v111;
    if ((v110 & 0x10) == 0)
    {
      v112 = __nwlog_obj();
      if (os_log_type_enabled(v112, OS_LOG_TYPE_INFO))
      {
        v113 = v30[11];
        if (v113)
          v114 = *(_DWORD *)(v113 + 460);
        else
          v114 = -1;
        v158 = v30[8];
        v159 = *((unsigned __int8 *)v30 + 276);
        *(_DWORD *)buf = 136448002;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v30 + 24;
        *(_WORD *)&buf[22] = 2080;
        v344 = (uint64_t)" ";
        *(_WORD *)v345 = 1024;
        *(_DWORD *)&v345[2] = v114;
        *(_WORD *)&v345[6] = 2048;
        *(_QWORD *)&v345[8] = v158;
        *(_WORD *)&v345[16] = 1024;
        *(_DWORD *)&v345[18] = (v159 >> 1) & 1;
        *(_WORD *)&v345[22] = 1024;
        *(_DWORD *)&v345[24] = (v159 >> 3) & 1;
        LOWORD(v346) = 1024;
        *(_DWORD *)((char *)&v346 + 2) = (v159 >> 2) & 1;
        _os_log_impl(&dword_182FBE000, v112, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
      }
    }
    nw_webtransport_metadata_set_is_peer_initiated((void *)v30[20], (*((_BYTE *)v30 + 276) & 2) != 0);
    nw_webtransport_metadata_set_is_datagram((void *)v30[20], (*((_BYTE *)v30 + 276) & 8) != 0);
    nw_webtransport_metadata_set_is_unidirectional((void *)v30[20], (*((_BYTE *)v30 + 276) & 4) != 0);
  }
  else if ((*((_BYTE *)v30 + 276) & 0x10) == 0)
  {
    v130 = __nwlog_obj();
    if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
    {
      v131 = v30[11];
      if (v131)
        v132 = *(_DWORD *)(v131 + 460);
      else
        v132 = -1;
      v164 = v30[8];
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v30 + 24;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v132;
      *(_WORD *)&v345[6] = 2048;
      *(_QWORD *)&v345[8] = v164;
      _os_log_impl(&dword_182FBE000, v130, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
    }
  }
  if ((*((_BYTE *)v30 + 276) & 8) != 0)
  {
    nw_protocol_connected(v30, v80);
    goto LABEL_295;
  }
  nw_protocol_set_output_handler((uint64_t)v30, 0);
  v30[7] = 0;
  if (!*(_QWORD *)(v80 + 376))
  {
    if ((*((_BYTE *)v30 + 276) & 0x10) != 0)
      goto LABEL_587;
    v165 = __nwlog_obj();
    if (!os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
      goto LABEL_587;
    v166 = v30[11];
    if (v166)
      v167 = *(_DWORD *)(v166 + 460);
    else
      v167 = -1;
    v171 = v30[8];
    *(_DWORD *)buf = 136447234;
    *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v30 + 24;
    *(_WORD *)&buf[22] = 2080;
    v344 = (uint64_t)" ";
    *(_WORD *)v345 = 1024;
    *(_DWORD *)&v345[2] = v167;
    *(_WORD *)&v345[6] = 2048;
    *(_QWORD *)&v345[8] = v171;
    v172 = "%{public}s %{public}s%s<i%u:s%lld> no http connection metadata when attempting to start webtransport http3 stream";
    goto LABEL_586;
  }
  if ((*((_BYTE *)v30 + 276) & 0x40) == 0)
    goto LABEL_294;
LABEL_295:
  v187 = *(_QWORD *)(v80 + 32);
  if (!v187)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
    v286 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(aBlock) = 16;
    v339[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v286, &aBlock, v339))
      goto LABEL_578;
    if (aBlock == 17)
    {
      v287 = __nwlog_obj();
      v288 = aBlock;
      if (!os_log_type_enabled(v287, (os_log_type_t)aBlock))
        goto LABEL_578;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
      v289 = "%{public}s called with null transport_protocol";
LABEL_576:
      v315 = v287;
      v316 = v288;
LABEL_577:
      _os_log_impl(&dword_182FBE000, v315, v316, v289, buf, 0xCu);
      goto LABEL_578;
    }
    if (v339[0] == OS_LOG_TYPE_DEFAULT)
    {
      v287 = __nwlog_obj();
      v288 = aBlock;
      if (!os_log_type_enabled(v287, (os_log_type_t)aBlock))
        goto LABEL_578;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
      v289 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
      goto LABEL_576;
    }
    v297 = (char *)__nw_create_backtrace_string();
    v298 = __nwlog_obj();
    v299 = aBlock;
    v300 = os_log_type_enabled(v298, (os_log_type_t)aBlock);
    if (!v297)
    {
      if (!v300)
        goto LABEL_578;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
      v289 = "%{public}s called with null transport_protocol, no backtrace";
      goto LABEL_603;
    }
    if (v300)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v297;
      _os_log_impl(&dword_182FBE000, v298, v299, "%{public}s called with null transport_protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v297);
LABEL_578:
    if (!v286)
      goto LABEL_580;
    goto LABEL_579;
  }
  if ((*(_BYTE *)(v80 + 548) & 0x40) != 0)
  {
    v188 = (void *)nw_protocol_get_parameters((uint64_t)v30);
    if (v188)
    {
      v189 = v188;
      nw_parameters_log_protocol_instances(v188);
      v190 = v189;
      v191 = v190[19].isa;

      *(_QWORD *)v339 = 0;
      v340 = v339;
      v341 = 0x2000000000;
      v342 = 0;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3802000000;
      v344 = (uint64_t)__Block_byref_object_copy__33462;
      *(_QWORD *)v345 = __Block_byref_object_dispose__33463;
      *(_QWORD *)&v345[8] = 0;
      v345[16] |= 1u;
      aBlock = MEMORY[0x1E0C809B0];
      v333 = 0x40000000;
      v334 = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
      v335 = &unk_1E14A0660;
      v336 = v339;
      v337 = buf;
      v338 = v30;
      nw_protocol_stack_iterate_application_protocols(v191, &aBlock);
      v192 = *(void **)(*(_QWORD *)&buf[8] + 40);
      if (v192)
      {
        if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72293);
        v193 = (id)nw_protocol_copy_http_messaging_definition_definition;
        v194 = v192;
        v194[2] = v187;

        if (v193)
          os_release(v193);
        v195 = nw_protocol_get_parameters(v187);
        if (!v195)
          goto LABEL_318;
        v196 = v107;
        v197 = nw_parameters_copy_default_protocol_stack(v195);
        v198 = nw_parameters_copy_default_protocol_stack(v190);
        v199 = nw_protocol_stack_copy_transport_protocol(v197);
        v200 = nw_protocol_stack_copy_transport_protocol(v198);
        v201 = v200;
        if (v199)
        {
          if (v200)
          {
            v202 = nw_protocol_options_copy_definition(v199);
            if (nw_protocol_options_matches_definition(v201, v202))
            {
              protocol_handle = nw_protocol_options_get_protocol_handle(v199);
              nw_parameters_set_protocol_instance(v201, v204, protocol_handle);
            }
            os_release(v201);
          }
          v201 = v199;
        }
        else if (!v200)
        {
LABEL_314:
          if (v198)
            os_release(v198);
          v107 = v196;
          if (v197)
            os_release(v197);
LABEL_318:
          nw_protocol_set_output_handler((uint64_t)v30, 0);
          v205 = nw_protocol_add_input_handler(v187, (uint64_t)v30);
          goto LABEL_319;
        }
        os_release(v201);
        goto LABEL_314;
      }
      v328 = v107;
      __nwlog_obj();
      v353 = 136446210;
      v354 = "nw_webtransport_session_add_to_http_messaging";
      v301 = (char *)_os_log_send_and_compose_impl();
      v331 = OS_LOG_TYPE_ERROR;
      v330 = 0;
      if (__nwlog_fault(v301, &v331, &v330))
      {
        if (v331 == OS_LOG_TYPE_FAULT)
        {
          v302 = __nwlog_obj();
          v303 = v331;
          if (os_log_type_enabled(v302, v331))
          {
            v353 = 136446210;
            v354 = "nw_webtransport_session_add_to_http_messaging";
            v304 = "%{public}s called with null options";
LABEL_596:
            v323 = v302;
            v324 = v303;
LABEL_597:
            _os_log_impl(&dword_182FBE000, v323, v324, v304, (uint8_t *)&v353, 0xCu);
          }
        }
        else if (v330)
        {
          v309 = (char *)__nw_create_backtrace_string();
          v310 = __nwlog_obj();
          v311 = v331;
          v312 = os_log_type_enabled(v310, v331);
          if (v309)
          {
            if (v312)
            {
              v353 = 136446466;
              v354 = "nw_webtransport_session_add_to_http_messaging";
              v355 = 2082;
              v356 = v309;
              _os_log_impl(&dword_182FBE000, v310, v311, "%{public}s called with null options, dumping backtrace:%{public}s", (uint8_t *)&v353, 0x16u);
            }
            free(v309);
            goto LABEL_598;
          }
          if (v312)
          {
            v353 = 136446210;
            v354 = "nw_webtransport_session_add_to_http_messaging";
            v304 = "%{public}s called with null options, no backtrace";
            v323 = v310;
            v324 = v311;
            goto LABEL_597;
          }
        }
        else
        {
          v302 = __nwlog_obj();
          v303 = v331;
          if (os_log_type_enabled(v302, v331))
          {
            v353 = 136446210;
            v354 = "nw_webtransport_session_add_to_http_messaging";
            v304 = "%{public}s called with null options, backtrace limit exceeded";
            goto LABEL_596;
          }
        }
      }
LABEL_598:
      if (v301)
        free(v301);
      v205 = 0;
      v107 = v328;
LABEL_319:
      _Block_object_dispose(buf, 8);
      if ((v345[16] & 1) != 0 && *(_QWORD *)&v345[8])
        os_release(*(void **)&v345[8]);
      _Block_object_dispose(v339, 8);
      if (v191)
        os_release(v191);
      if ((v205 & 1) == 0)
        goto LABEL_580;
      goto LABEL_325;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
    v286 = (char *)_os_log_send_and_compose_impl();
    v339[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v353) = 0;
    if (!__nwlog_fault(v286, v339, &v353))
      goto LABEL_578;
    if (v339[0] == OS_LOG_TYPE_FAULT)
    {
      v287 = __nwlog_obj();
      v288 = v339[0];
      if (!os_log_type_enabled(v287, v339[0]))
        goto LABEL_578;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
      v289 = "%{public}s called with null parameters";
      goto LABEL_576;
    }
    if (!(_BYTE)v353)
    {
      v287 = __nwlog_obj();
      v288 = v339[0];
      if (!os_log_type_enabled(v287, v339[0]))
        goto LABEL_578;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
      v289 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_576;
    }
    v307 = (char *)__nw_create_backtrace_string();
    v298 = __nwlog_obj();
    v299 = v339[0];
    v308 = os_log_type_enabled(v298, v339[0]);
    if (v307)
    {
      if (v308)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v307;
        _os_log_impl(&dword_182FBE000, v298, v299, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v307);
      if (!v286)
        goto LABEL_580;
LABEL_579:
      free(v286);
      goto LABEL_580;
    }
    if (v308)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
      v289 = "%{public}s called with null parameters, no backtrace";
LABEL_603:
      v315 = v298;
      v316 = v299;
      goto LABEL_577;
    }
    goto LABEL_578;
  }
  if (!nw_protocol_add_input_handler(*(_QWORD *)(v80 + 32), (uint64_t)v30))
  {
LABEL_580:
    if ((*((_BYTE *)v30 + 276) & 0x10) != 0)
      goto LABEL_587;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v165 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      goto LABEL_587;
    v317 = v30[11];
    if (v317)
      v318 = *(_DWORD *)(v317 + 460);
    else
      v318 = -1;
    v319 = v30[8];
    *(_DWORD *)buf = 136447234;
    *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v30 + 24;
    *(_WORD *)&buf[22] = 2080;
    v344 = (uint64_t)" ";
    *(_WORD *)v345 = 1024;
    *(_DWORD *)&v345[2] = v318;
    *(_WORD *)&v345[6] = 2048;
    *(_QWORD *)&v345[8] = v319;
    v172 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
LABEL_586:
    _os_log_impl(&dword_182FBE000, v165, OS_LOG_TYPE_ERROR, v172, buf, 0x30u);
LABEL_587:
    v320 = (_QWORD *)v30[6];
    nw_protocol_error(v320, (uint64_t)v30);
    nw_protocol_disconnected(v320, (uint64_t)v30);
    goto LABEL_588;
  }
LABEL_325:
  if (!v30[4])
    goto LABEL_580;
  v206 = v30[22];
  v207 = *(void **)(v80 + 392);
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
  v344 = (uint64_t)&unk_1E14A05F8;
  *(_QWORD *)v345 = v206;
  nw_queue_context_async(v207, buf);
LABEL_588:
  os_release(v107);
LABEL_589:
  if ((handle[137] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v321 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v322 = handle[115];
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 116;
      *(_WORD *)&buf[22] = 2080;
      v344 = (uint64_t)" ";
      *(_WORD *)v345 = 1024;
      *(_DWORD *)&v345[2] = v322;
      *(_WORD *)&v345[6] = 2048;
      *(_QWORD *)&v345[8] = v329;
      *(_WORD *)&v345[16] = 2082;
      *(_QWORD *)&v345[18] = v30 + 24;
      _os_log_impl(&dword_182FBE000, v321, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u> Added input handler %p from %{public}s", buf, 0x3Au);
    }
  }
  return 1;
}

void sub_18368F2C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_webtransport_session_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  char *v5;
  NSObject *v6;
  int v7;
  nw_protocol *default_input_handler;
  _BOOL8 node;
  uint64_t v10;
  int v11;
  const char *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  uint64_t v17;
  _QWORD *v18;
  char *v19;
  _BOOL4 v20;
  int v21;
  uint64_t v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  uint64_t v26;
  const char *v27;
  int v28;
  NSObject *v29;
  os_log_type_t v30;
  uint32_t v31;
  char *v32;
  _BOOL4 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  const char *v41;
  NSObject *v43;
  int v44;
  uint64_t v45;
  void *v46;
  os_unfair_lock_s *v47;
  _BOOL8 some_node;
  uint64_t object;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  NSObject *v55;
  int v56;
  __n128 v57;
  uint64_t v58;
  NSObject *v59;
  int v60;
  uint64_t v61;
  char *v62;
  uint64_t v63;
  os_unfair_lock_s *v64;
  uint64_t v65;
  NSObject *v66;
  int v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  os_log_type_t v71;
  NSObject *v72;
  os_log_type_t v73;
  const char *v74;
  char *v75;
  NSObject *v76;
  os_log_type_t v77;
  _BOOL4 v78;
  uint64_t v79;
  os_log_type_t v80;
  uint64_t v81;
  _QWORD *v82;
  uint64_t v83;
  NSObject *v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  NSObject *v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  const void *v94;
  void *v95;
  void *v96;
  void *v97;
  NSObject *v98;
  os_log_type_t v99;
  NSObject *v100;
  os_log_type_t v101;
  const char *v102;
  char *v103;
  NSObject *v104;
  os_log_type_t v105;
  _BOOL4 v106;
  NSObject *v107;
  os_log_type_t v108;
  const void *v109;
  char *v110;
  NSObject *v111;
  os_log_type_t v112;
  const char *v113;
  char *backtrace_string;
  _BOOL4 v115;
  const char *v116;
  _BOOL4 v117;
  _BOOL4 v118;
  _BOOL4 v119;
  NSObject *v120;
  int v121;
  NSObject *v122;
  uint64_t v123;
  int v124;
  NSObject *v125;
  int v126;
  NSObject *v127;
  int v128;
  uint64_t v129;
  int v130;
  NSObject *v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  const char *v135;
  char *v136;
  _QWORD v137[5];
  os_log_type_t type[8];
  uint64_t v139;
  uint64_t (*v140)(uint64_t, uint64_t);
  void *v141;
  uint64_t *v142;
  char *v143;
  uint64_t v144;
  uint64_t *v145;
  uint64_t v146;
  uint64_t v147;
  char v148;
  os_log_type_t v149;
  _BYTE buf[12];
  __int16 v151;
  const char *v152;
  __int16 v153;
  uint64_t v154;
  __int16 v155;
  _BYTE v156[24];
  __int16 v157;
  nw_protocol *v158;
  uint64_t v159;

  v159 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    v110 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (!__nwlog_fault(v110, type, v137))
      goto LABEL_244;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v137[0]))
      {
        v111 = __nwlog_obj();
        v112 = type[0];
        if (os_log_type_enabled(v111, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          v113 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_243;
        }
        goto LABEL_244;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v111 = __nwlog_obj();
      v112 = type[0];
      v115 = os_log_type_enabled(v111, type[0]);
      if (!backtrace_string)
      {
        if (v115)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          v113 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_243;
        }
        goto LABEL_244;
      }
      if (!v115)
        goto LABEL_219;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
      v151 = 2082;
      v152 = backtrace_string;
      v116 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_218;
    }
    v111 = __nwlog_obj();
    v112 = type[0];
    if (!os_log_type_enabled(v111, type[0]))
      goto LABEL_244;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    v113 = "%{public}s called with null protocol";
LABEL_243:
    _os_log_impl(&dword_182FBE000, v111, v112, v113, buf, 0xCu);
    goto LABEL_244;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    v110 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (!__nwlog_fault(v110, type, v137))
      goto LABEL_244;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v137[0]))
      {
        v111 = __nwlog_obj();
        v112 = type[0];
        if (os_log_type_enabled(v111, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          v113 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
          goto LABEL_243;
        }
        goto LABEL_244;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v111 = __nwlog_obj();
      v112 = type[0];
      v117 = os_log_type_enabled(v111, type[0]);
      if (!backtrace_string)
      {
        if (v117)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
          v113 = "%{public}s called with null webtransport_session, no backtrace";
          goto LABEL_243;
        }
        goto LABEL_244;
      }
      if (!v117)
        goto LABEL_219;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
      v151 = 2082;
      v152 = backtrace_string;
      v116 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_218;
    }
    v111 = __nwlog_obj();
    v112 = type[0];
    if (!os_log_type_enabled(v111, type[0]))
      goto LABEL_244;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    v113 = "%{public}s called with null webtransport_session";
    goto LABEL_243;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    v110 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (!__nwlog_fault(v110, type, v137))
      goto LABEL_244;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v111 = __nwlog_obj();
      v112 = type[0];
      if (!os_log_type_enabled(v111, type[0]))
        goto LABEL_244;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
      v113 = "%{public}s called with null input_protocol";
      goto LABEL_243;
    }
    if (!LOBYTE(v137[0]))
    {
      v111 = __nwlog_obj();
      v112 = type[0];
      if (os_log_type_enabled(v111, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        v113 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_243;
      }
      goto LABEL_244;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v111 = __nwlog_obj();
    v112 = type[0];
    v118 = os_log_type_enabled(v111, type[0]);
    if (!backtrace_string)
    {
      if (v118)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        v113 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_243;
      }
      goto LABEL_244;
    }
    if (!v118)
      goto LABEL_219;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    v151 = 2082;
    v152 = backtrace_string;
    v116 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_218:
    _os_log_impl(&dword_182FBE000, v111, v112, v116, buf, 0x16u);
    goto LABEL_219;
  }
  v5 = (char *)a2->handle;
  if (v5)
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v7 = *((_DWORD *)handle + 115);
        default_input_handler = a1->default_input_handler;
        *(_DWORD *)buf = 136447746;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        v151 = 2082;
        v152 = handle + 464;
        v153 = 2080;
        v154 = (uint64_t)" ";
        v155 = 1024;
        *(_DWORD *)v156 = v7;
        *(_WORD *)&v156[4] = 2048;
        *(_QWORD *)&v156[6] = a1;
        *(_WORD *)&v156[14] = 2048;
        *(_QWORD *)&v156[16] = default_input_handler;
        v157 = 2048;
        v158 = a2;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> called, protocol %p, default_input_handler %p, input protocol %p", buf, 0x44u);
      }
    }
    v136 = handle;
    if ((v5[276] & 0x20) == 0)
    {
      if (*((char **)handle + 52) == v5)
      {
        if ((handle[548] & 2) == 0)
        {
          if (gLogDatapath)
          {
            v125 = __nwlog_obj();
            if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
            {
              v126 = *((_DWORD *)handle + 115);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
              v151 = 2082;
              v152 = handle + 464;
              v153 = 2080;
              v154 = (uint64_t)" ";
              v155 = 1024;
              *(_DWORD *)v156 = v126;
              _os_log_impl(&dword_182FBE000, v125, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing placeholder stream for session", buf, 0x26u);
            }
          }
        }
        *((_QWORD *)handle + 52) = 0;
        goto LABEL_69;
      }
      if (*((char **)handle + 53) == v5)
      {
        if ((handle[548] & 2) == 0)
        {
          if (gLogDatapath)
          {
            v127 = __nwlog_obj();
            if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
            {
              v128 = *((_DWORD *)handle + 115);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
              v151 = 2082;
              v152 = handle + 464;
              v153 = 2080;
              v154 = (uint64_t)" ";
              v155 = 1024;
              *(_DWORD *)v156 = v128;
              _os_log_impl(&dword_182FBE000, v127, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing datagram stream for session", buf, 0x26u);
            }
          }
        }
        *((_QWORD *)handle + 53) = 0;
        goto LABEL_69;
      }
      *(_QWORD *)type = *((_QWORD *)v5 + 8);
      node = nw_hash_table_get_node(*((_QWORD *)handle + 23), (uint64_t)type, 8);
      if (node)
      {
        if (nw_hash_table_remove_node(*((_QWORD *)handle + 23), node))
          goto LABEL_69;
        if ((handle[548] & 2) != 0)
          goto LABEL_69;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          goto LABEL_69;
        v11 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v151 = 2082;
        v152 = handle + 464;
        v153 = 2080;
        v154 = (uint64_t)" ";
        v155 = 1024;
        *(_DWORD *)v156 = v11;
        *(_WORD *)&v156[4] = 2048;
        *(_QWORD *)&v156[6] = *(_QWORD *)type;
        v12 = "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table";
      }
      else
      {
        if ((handle[548] & 2) != 0)
          goto LABEL_69;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          goto LABEL_69;
        v28 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v151 = 2082;
        v152 = handle + 464;
        v153 = 2080;
        v154 = (uint64_t)" ";
        v155 = 1024;
        *(_DWORD *)v156 = v28;
        *(_WORD *)&v156[4] = 2048;
        *(_QWORD *)&v156[6] = *(_QWORD *)type;
        v12 = "%{public}s %{public}s%s<i%u> called remove_input_handler with stream id %lld, but no stream found";
      }
      v29 = v10;
      v30 = OS_LOG_TYPE_ERROR;
      v31 = 48;
LABEL_46:
      _os_log_impl(&dword_182FBE000, v29, v30, v12, buf, v31);
LABEL_69:
      *((_QWORD *)v5 + 11) = 0;
      if (*((char **)handle + 6) != v5)
        return 1;
      if (*((_DWORD *)handle + 111))
      {
        v38 = *((_QWORD *)handle + 53);
        if (v38)
        {
LABEL_72:
          nw_protocol_set_input_handler((uint64_t)handle, v38);
          if ((handle[548] & 2) != 0)
            return 1;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v39 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            return 1;
          v40 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v151 = 2082;
          v152 = handle + 464;
          v153 = 2080;
          v154 = (uint64_t)" ";
          v155 = 1024;
          *(_DWORD *)v156 = v40;
          v41 = "%{public}s %{public}s%s<i%u> not destroying, still have datagram stream";
          goto LABEL_75;
        }
      }
      else
      {
        if ((handle[548] & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v43 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v44 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
            v151 = 2082;
            v152 = handle + 464;
            v153 = 2080;
            v154 = (uint64_t)" ";
            v155 = 1024;
            *(_DWORD *)v156 = v44;
            _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> first input handler bailed, closing", buf, 0x26u);
          }
        }
        v45 = *((_QWORD *)handle + 54);
        v46 = (void *)*((_QWORD *)handle + 49);
        v137[0] = MEMORY[0x1E0C809B0];
        v137[1] = 0x40000000;
        v137[2] = ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke;
        v137[3] = &unk_1E14A0498;
        v137[4] = v45;
        nw_queue_context_async(v46, v137);
        v38 = *((_QWORD *)handle + 53);
        if (v38)
          goto LABEL_72;
      }
      v47 = (os_unfair_lock_s *)*((_QWORD *)handle + 23);
      if (v47 && v47[10]._os_unfair_lock_opaque)
      {
        some_node = nw_hash_table_get_some_node(v47);
        object = nw_hash_node_get_object(some_node);
        nw_protocol_set_input_handler((uint64_t)handle, object);
        if ((handle[548] & 2) != 0)
          return 1;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v39 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          return 1;
        v50 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v151 = 2082;
        v152 = handle + 464;
        v153 = 2080;
        v154 = (uint64_t)" ";
        v155 = 1024;
        *(_DWORD *)v156 = v50;
        v41 = "%{public}s %{public}s%s<i%u> not destroying, still have active streams";
        goto LABEL_75;
      }
      if (*((_DWORD *)handle + 114))
      {
        v51 = *((_QWORD *)handle + 41);
        if (v51)
        {
          if ((*(_BYTE *)(v51 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v131 = __nwlog_obj();
              if (os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG))
              {
                v132 = *(_QWORD *)(v51 + 88);
                if (v132)
                  v133 = *(_DWORD *)(v132 + 460);
                else
                  v133 = -1;
                v134 = *(_QWORD *)(v51 + 64);
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
                v151 = 2082;
                v152 = (const char *)(v51 + 192);
                v153 = 2080;
                v154 = (uint64_t)" ";
                v155 = 1024;
                *(_DWORD *)v156 = v133;
                *(_WORD *)&v156[4] = 2048;
                *(_QWORD *)&v156[6] = v134;
                *(_WORD *)&v156[14] = 2048;
                *(_QWORD *)&v156[16] = v51;
                _os_log_impl(&dword_182FBE000, v131, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
              }
            }
          }
        }
        nw_protocol_set_input_handler((uint64_t)handle, v51);
        if ((handle[548] & 2) != 0)
          return 1;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v39 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          return 1;
        v52 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v151 = 2082;
        v152 = handle + 464;
        v153 = 2080;
        v154 = (uint64_t)" ";
        v155 = 1024;
        *(_DWORD *)v156 = v52;
        v41 = "%{public}s %{public}s%s<i%u> not destroying, still have pending streams";
LABEL_75:
        _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_INFO, v41, buf, 0x26u);
        return 1;
      }
      v53 = *((_QWORD *)handle + 52);
      if (v53)
      {
        nw_protocol_set_input_handler((uint64_t)handle, v53);
        if ((handle[548] & 2) != 0)
          return 1;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v39 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          return 1;
        v54 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v151 = 2082;
        v152 = handle + 464;
        v153 = 2080;
        v154 = (uint64_t)" ";
        v155 = 1024;
        *(_DWORD *)v156 = v54;
        v41 = "%{public}s %{public}s%s<i%u> not destroying, still have placeholder stream";
        goto LABEL_75;
      }
      nw_protocol_set_input_handler((uint64_t)handle, 0);
      if ((handle[548] & 2) == 0)
      {
        v55 = __nwlog_obj();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
        {
          v56 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v151 = 2082;
          v152 = handle + 464;
          v153 = 2080;
          v154 = (uint64_t)" ";
          v155 = 1024;
          *(_DWORD *)v156 = v56;
          _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> called, destroying session", buf, 0x26u);
        }
      }
      *(_QWORD *)buf = 0;
      nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(handle + 344), buf);
      *(_QWORD *)buf = 0;
      nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(handle + 360), buf);
      *(_QWORD *)buf = 0;
      nw::retained_ptr<nw_endpoint *>::operator=((uint64_t)(handle + 376), buf);
      nw_http_capsule_framer_cleanup((_QWORD *)handle + 12, v57);
      v58 = *((_QWORD *)handle + 50);
      if (v58)
        (*(void (**)(uint64_t, char *, _QWORD))(*(_QWORD *)v58 + 8))(v58, handle, 0);
      if ((handle[548] & 4) != 0)
      {
        if ((nw_protocol_remove_listen_handler(*((_QWORD *)handle + 51), (uint64_t)(handle + 64)) & 1) == 0
          && (handle[548] & 2) == 0)
        {
          v59 = __nwlog_obj();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
          {
            v60 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
            v151 = 2082;
            v152 = handle + 464;
            v153 = 2080;
            v154 = (uint64_t)" ";
            v155 = 1024;
            *(_DWORD *)v156 = v60;
            _os_log_impl(&dword_182FBE000, v59, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> failed to remove listen handler", buf, 0x26u);
          }
        }
        *((_QWORD *)handle + 51) = 0;
      }
      v61 = *((_QWORD *)handle + 4);
      if (v61)
        nw_protocol_remove_input_handler(v61, (uint64_t)handle);
      v144 = 0;
      v145 = &v144;
      v146 = 0x2000000000;
      v147 = 0;
      v62 = (char *)*((_QWORD *)handle + 23);
      if (v62)
      {
        *(_QWORD *)type = MEMORY[0x1E0C809B0];
        v139 = 0x40000000;
        v140 = ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke;
        v141 = &unk_1E14A04E0;
        v142 = &v144;
        v143 = handle;
        nw_hash_table_apply(v62, (uint64_t)type);
        v64 = (os_unfair_lock_s *)*((_QWORD *)handle + 23);
        if (v64)
        {
          _nw_hash_table_release(v64, v63);
          *((_QWORD *)handle + 23) = 0;
        }
      }
      v65 = *((_QWORD *)handle + 41);
      v145[3] = v65;
      if (!v65)
      {
        (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)handle + 54) + 16))(*((_QWORD *)handle + 54), 0);
        v109 = (const void *)*((_QWORD *)handle + 54);
        if (v109)
        {
          _Block_release(v109);
          *((_QWORD *)handle + 54) = 0;
        }
        std::destroy_at[abi:nn180100]<nw_webtransport_session,0>((uint64_t)handle);
        free(handle);
        _Block_object_dispose(&v144, 8);
        return 1;
      }
      v135 = handle + 464;
      while (1)
      {
        v65 = *(_QWORD *)(v65 + 112);
        if ((handle[548] & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v66 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v67 = *((_DWORD *)handle + 115);
            v68 = v145[3];
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
            v151 = 2082;
            v152 = v135;
            v153 = 2080;
            v154 = (uint64_t)" ";
            v155 = 1024;
            *(_DWORD *)v156 = v67;
            *(_WORD *)&v156[4] = 2048;
            *(_QWORD *)&v156[6] = v68;
            _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways", buf, 0x30u);
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
        v69 = (char *)_os_log_send_and_compose_impl();
        v149 = OS_LOG_TYPE_ERROR;
        v148 = 0;
        if (__nwlog_fault(v69, &v149, &v148))
        {
          if (v149 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v70 = gLogObj;
            v71 = v149;
            if (!os_log_type_enabled((os_log_t)gLogObj, v149))
              goto LABEL_132;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
            v72 = v70;
            v73 = v71;
            v74 = "%{public}s should not have streams left when destroying";
LABEL_131:
            _os_log_impl(&dword_182FBE000, v72, v73, v74, buf, 0xCu);
            goto LABEL_132;
          }
          if (!v148)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v79 = gLogObj;
            v80 = v149;
            if (!os_log_type_enabled((os_log_t)gLogObj, v149))
              goto LABEL_132;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
            v72 = v79;
            v73 = v80;
            v74 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
            goto LABEL_131;
          }
          v75 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v76 = gLogObj;
          v77 = v149;
          v78 = os_log_type_enabled((os_log_t)gLogObj, v149);
          if (!v75)
          {
            if (!v78)
              goto LABEL_132;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
            v72 = v76;
            v73 = v77;
            v74 = "%{public}s should not have streams left when destroying, no backtrace";
            goto LABEL_131;
          }
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
            v151 = 2082;
            v152 = v75;
            _os_log_impl(&dword_182FBE000, v76, v77, "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v75);
        }
LABEL_132:
        if (v69)
          free(v69);
        v81 = *(_QWORD *)(v65 + 112);
        v82 = *(_QWORD **)(v65 + 120);
        handle = v136;
        if (v81)
        {
          *(_QWORD *)(v81 + 120) = v82;
          v82 = *(_QWORD **)(v65 + 120);
        }
        else
        {
          *((_QWORD *)v136 + 42) = v82;
        }
        *v82 = v81;
        *(_QWORD *)(v65 + 112) = 0;
        *(_QWORD *)(v65 + 120) = 0;
        v83 = v145[3];
        if (v83)
        {
          if ((*(_BYTE *)(v83 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v84 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              v85 = *(_QWORD *)(v83 + 88);
              if (v85)
                v86 = *(_DWORD *)(v85 + 460);
              else
                v86 = -1;
              v87 = *(_QWORD *)(v83 + 64);
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
              v151 = 2082;
              v152 = (const char *)(v83 + 192);
              v153 = 2080;
              v154 = (uint64_t)" ";
              v155 = 1024;
              *(_DWORD *)v156 = v86;
              *(_WORD *)&v156[4] = 2048;
              *(_QWORD *)&v156[6] = v87;
              *(_WORD *)&v156[14] = 2048;
              *(_QWORD *)&v156[16] = v83;
              _os_log_impl(&dword_182FBE000, v84, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
            }
          }
          if (*(_QWORD *)(v83 + 72))
          {
            if ((*(_BYTE *)(v83 + 276) & 0x10) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v88 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                v89 = *(_QWORD *)(v83 + 88);
                if (v89)
                  v90 = *(_DWORD *)(v89 + 460);
                else
                  v90 = -1;
                v91 = *(_QWORD *)(v83 + 64);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
                v151 = 2082;
                v152 = (const char *)(v83 + 192);
                v153 = 2080;
                v154 = (uint64_t)" ";
                v155 = 1024;
                *(_DWORD *)v156 = v90;
                *(_WORD *)&v156[4] = 2048;
                *(_QWORD *)&v156[6] = v91;
                _os_log_impl(&dword_182FBE000, v88, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
              }
            }
          }
          v92 = *(_QWORD *)(v83 + 72);
          if (v92)
          {
            do
            {
              v93 = *(_QWORD *)(v92 + 32);
              nw_frame_finalize(v92);
              v92 = v93;
            }
            while (v93);
          }
          (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v83 + 176) + 16))(*(_QWORD *)(v83 + 176), 0);
          v94 = *(const void **)(v83 + 176);
          if (v94)
          {
            _Block_release(v94);
            *(_QWORD *)(v83 + 176) = 0;
          }
          if ((*(_BYTE *)(v83 + 168) & 1) != 0)
          {
            v95 = *(void **)(v83 + 160);
            if (v95)
              os_release(v95);
          }
          *(_QWORD *)(v83 + 160) = 0;
          if ((*(_BYTE *)(v83 + 152) & 1) != 0)
          {
            v96 = *(void **)(v83 + 144);
            if (v96)
              os_release(v96);
          }
          *(_QWORD *)(v83 + 144) = 0;
          if ((*(_BYTE *)(v83 + 136) & 1) != 0)
          {
            v97 = *(void **)(v83 + 128);
            if (v97)
              os_release(v97);
          }
LABEL_164:
          free((void *)v83);
          goto LABEL_165;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v83 = _os_log_send_and_compose_impl();
        v149 = OS_LOG_TYPE_ERROR;
        v148 = 0;
        if (!__nwlog_fault((const char *)v83, &v149, &v148))
          goto LABEL_181;
        if (v149 == OS_LOG_TYPE_FAULT)
        {
          v98 = __nwlog_obj();
          v99 = v149;
          if (os_log_type_enabled(v98, v149))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
            v100 = v98;
            v101 = v99;
            v102 = "%{public}s called with null webtransport_stream";
            goto LABEL_180;
          }
LABEL_181:
          if (v83)
            goto LABEL_164;
          goto LABEL_165;
        }
        if (!v148)
        {
          v107 = __nwlog_obj();
          v108 = v149;
          if (!os_log_type_enabled(v107, v149))
            goto LABEL_181;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
          v100 = v107;
          v101 = v108;
          v102 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
LABEL_180:
          _os_log_impl(&dword_182FBE000, v100, v101, v102, buf, 0xCu);
          goto LABEL_181;
        }
        v103 = (char *)__nw_create_backtrace_string();
        v104 = __nwlog_obj();
        v105 = v149;
        v106 = os_log_type_enabled(v104, v149);
        if (!v103)
        {
          handle = v136;
          if (!v106)
            goto LABEL_181;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
          v100 = v104;
          v101 = v105;
          v102 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_180;
        }
        if (v106)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
          v151 = 2082;
          v152 = v103;
          _os_log_impl(&dword_182FBE000, v104, v105, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v103);
        handle = v136;
        if (v83)
          goto LABEL_164;
LABEL_165:
        v145[3] = v65;
      }
    }
    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        v120 = __nwlog_obj();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
        {
          v121 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = handle + 464;
          v153 = 2080;
          v154 = (uint64_t)" ";
          v155 = 1024;
          *(_DWORD *)v156 = v121;
          *(_WORD *)&v156[4] = 2048;
          *(_QWORD *)&v156[6] = v5;
          _os_log_impl(&dword_182FBE000, v120, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
        }
      }
    }
    if ((v5[276] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
      v151 = 2048;
      v152 = v5;
      v13 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v137[0]) = 0;
      if (!__nwlog_fault(v13, type, v137))
        goto LABEL_57;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_57;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
        v151 = 2048;
        v152 = v5;
        v16 = "%{public}s stream %p not in pending list, cannot remove";
      }
      else if (LOBYTE(v137[0]))
      {
        v19 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type[0];
        v20 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v19)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v151 = 2048;
            v152 = v5;
            v153 = 2082;
            v154 = (uint64_t)v19;
            _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v19);
          goto LABEL_57;
        }
        if (!v20)
        {
LABEL_57:
          if (v13)
            free(v13);
          goto LABEL_69;
        }
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
        v151 = 2048;
        v152 = v5;
        v16 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_57;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
        v151 = 2048;
        v152 = v5;
        v16 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0x16u);
      goto LABEL_57;
    }
    v17 = *((_QWORD *)v5 + 14);
    v18 = (_QWORD *)*((_QWORD *)v5 + 15);
    if (v17)
    {
      *(_QWORD *)(v17 + 120) = v18;
      v18 = (_QWORD *)*((_QWORD *)v5 + 15);
    }
    else
    {
      *((_QWORD *)handle + 42) = v18;
    }
    *v18 = v17;
    *((_QWORD *)v5 + 14) = 0;
    *((_QWORD *)v5 + 15) = 0;
    v21 = *((_DWORD *)handle + 114);
    *((_DWORD *)handle + 114) = v21 - 1;
    if (v21)
    {
LABEL_67:
      v37 = v5[276];
      v5[276] = v37 & 0xDF;
      if ((v37 & 0x10) != 0)
        goto LABEL_69;
      if (!gLogDatapath)
        goto LABEL_69;
      v122 = __nwlog_obj();
      if (!os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
        goto LABEL_69;
      v123 = *((_QWORD *)v5 + 11);
      if (v123)
        v124 = *(_DWORD *)(v123 + 460);
      else
        v124 = -1;
      v129 = *((_QWORD *)v5 + 8);
      v130 = *((_DWORD *)handle + 114);
      *(_DWORD *)buf = 136447746;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
      v151 = 2082;
      v152 = v5 + 192;
      v153 = 2080;
      v154 = (uint64_t)" ";
      v155 = 1024;
      *(_DWORD *)v156 = v124;
      *(_WORD *)&v156[4] = 2048;
      *(_QWORD *)&v156[6] = v129;
      *(_WORD *)&v156[14] = 2048;
      *(_QWORD *)&v156[16] = v5;
      v157 = 1024;
      LODWORD(v158) = v130;
      v12 = "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams";
      v29 = v122;
      v30 = OS_LOG_TYPE_DEBUG;
      v31 = 64;
      goto LABEL_46;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v22 = *((unsigned int *)handle + 114);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
    v151 = 2082;
    v152 = "webtransport_session->pending_stream_count";
    v153 = 2048;
    v154 = 1;
    v155 = 2048;
    *(_QWORD *)v156 = v22;
    v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v137[0]) = 0;
    if (__nwlog_fault(v23, type, v137))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = gLogObj;
        v25 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          v26 = *((unsigned int *)handle + 114);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = "webtransport_session->pending_stream_count";
          v153 = 2048;
          v154 = 1;
          v155 = 2048;
          *(_QWORD *)v156 = v26;
          v27 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_63:
          _os_log_impl(&dword_182FBE000, v24, v25, v27, buf, 0x2Au);
        }
      }
      else if (LOBYTE(v137[0]))
      {
        v32 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v24 = gLogObj;
        v25 = type[0];
        v33 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v32)
        {
          if (v33)
          {
            v34 = *((unsigned int *)handle + 114);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v151 = 2082;
            v152 = "webtransport_session->pending_stream_count";
            v153 = 2048;
            v154 = 1;
            v155 = 2048;
            *(_QWORD *)v156 = v34;
            *(_WORD *)&v156[8] = 2082;
            *(_QWORD *)&v156[10] = v32;
            _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v32);
          goto LABEL_64;
        }
        if (v33)
        {
          v36 = *((unsigned int *)handle + 114);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = "webtransport_session->pending_stream_count";
          v153 = 2048;
          v154 = 1;
          v155 = 2048;
          *(_QWORD *)v156 = v36;
          v27 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_63;
        }
      }
      else
      {
        v24 = __nwlog_obj();
        v25 = type[0];
        if (os_log_type_enabled(v24, type[0]))
        {
          v35 = *((unsigned int *)handle + 114);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v151 = 2082;
          v152 = "webtransport_session->pending_stream_count";
          v153 = 2048;
          v154 = 1;
          v155 = 2048;
          *(_QWORD *)v156 = v35;
          v27 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_63;
        }
      }
    }
LABEL_64:
    if (v23)
      free(v23);
    *((_DWORD *)handle + 114) = 0;
    goto LABEL_67;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
  v110 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v137[0]) = 0;
  if (!__nwlog_fault(v110, type, v137))
    goto LABEL_244;
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!LOBYTE(v137[0]))
    {
      v111 = __nwlog_obj();
      v112 = type[0];
      if (os_log_type_enabled(v111, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        v113 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_243;
      }
      goto LABEL_244;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v111 = __nwlog_obj();
    v112 = type[0];
    v119 = os_log_type_enabled(v111, type[0]);
    if (!backtrace_string)
    {
      if (v119)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
        v113 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_243;
      }
      goto LABEL_244;
    }
    if (v119)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
      v151 = 2082;
      v152 = backtrace_string;
      v116 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_218;
    }
LABEL_219:
    free(backtrace_string);
    goto LABEL_244;
  }
  v111 = __nwlog_obj();
  v112 = type[0];
  if (os_log_type_enabled(v111, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_input_handler";
    v113 = "%{public}s called with null webtransport_stream";
    goto LABEL_243;
  }
LABEL_244:
  if (v110)
    free(v110);
  return 0;
}

uint64_t nw_protocol_webtransport_session_connect(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  char v6;
  uint64_t result;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  int v13;
  char *backtrace_string;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  NSObject *v20;
  int v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_session_connect";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_77;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_protocol_webtransport_session_connect";
          v11 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_protocol_webtransport_session_connect";
          v11 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      if (!v15)
        goto LABEL_57;
      *(_DWORD *)buf = 136446466;
      v25 = "nw_protocol_webtransport_session_connect";
      v26 = 2082;
      v27 = backtrace_string;
      v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_56;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_session_connect";
    v11 = "%{public}s called with null protocol";
LABEL_76:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_77;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_session_connect";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_77;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_protocol_webtransport_session_connect";
          v11 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_protocol_webtransport_session_connect";
          v11 = "%{public}s called with null webtransport_session, no backtrace";
          goto LABEL_76;
        }
        goto LABEL_77;
      }
      if (!v17)
        goto LABEL_57;
      *(_DWORD *)buf = 136446466;
      v25 = "nw_protocol_webtransport_session_connect";
      v26 = 2082;
      v27 = backtrace_string;
      v16 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_56;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_session_connect";
    v11 = "%{public}s called with null webtransport_session";
    goto LABEL_76;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_session_connect";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_77;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_77;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_session_connect";
      v11 = "%{public}s called with null other_protocol";
      goto LABEL_76;
    }
    if (!v22)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_session_connect";
        v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v18 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_session_connect";
        v11 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    if (!v18)
      goto LABEL_57;
    *(_DWORD *)buf = 136446466;
    v25 = "nw_protocol_webtransport_session_connect";
    v26 = 2082;
    v27 = backtrace_string;
    v16 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_56:
    _os_log_impl(&dword_182FBE000, v9, v10, v16, buf, 0x16u);
    goto LABEL_57;
  }
  if (!a2->handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_session_connect";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22))
      goto LABEL_77;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_session_connect";
        v11 = "%{public}s called with null webtransport_stream";
        goto LABEL_76;
      }
LABEL_77:
      if (v8)
        free(v8);
      return 0;
    }
    if (!v22)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_session_connect";
        v11 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v19 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_session_connect";
        v11 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_76;
      }
      goto LABEL_77;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_protocol_webtransport_session_connect";
      v26 = 2082;
      v27 = backtrace_string;
      v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_56;
    }
LABEL_57:
    free(backtrace_string);
    goto LABEL_77;
  }
  if ((handle[137] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        v13 = handle[115];
        *(_DWORD *)buf = 136446978;
        v25 = "nw_protocol_webtransport_session_connect";
        v26 = 2082;
        v27 = (char *)(handle + 116);
        v28 = 2080;
        v29 = " ";
        v30 = 1024;
        v31 = v13;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
  }
  if ((handle[137] & 0x10) == 0)
  {
    output_handler = a1->output_handler;
    if ((handle[137] & 4) == 0)
    {
      if (*((_QWORD *)handle + 50))
      {
        if (output_handler)
        {
          callbacks = output_handler->callbacks;
          if (callbacks)
          {
            if (callbacks->add_listen_handler)
            {
              *((_QWORD *)handle + 51) = output_handler;
              if (nw_protocol_add_listen_handler((uint64_t)output_handler, (uint64_t)(handle + 16)))
                v6 = 4;
              else
                v6 = 0;
              *((_BYTE *)handle + 548) = handle[137] & 0xFB | v6;
              output_handler = a1->output_handler;
            }
          }
        }
      }
    }
    nw_protocol_connect((uint64_t)output_handler, (uint64_t)a1);
    *((_BYTE *)handle + 548) |= 0x10u;
    return 1;
  }
  result = 1;
  if ((handle[137] & 2) == 0 && gLogDatapath)
  {
    v20 = __nwlog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      v21 = handle[115];
      *(_DWORD *)buf = 136446978;
      v25 = "nw_protocol_webtransport_session_connect";
      v26 = 2082;
      v27 = (char *)(handle + 116);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v21;
      _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Skipping received connect callback, already sent to output_handler", buf, 0x26u);
    }
    return 1;
  }
  return result;
}

void nw_protocol_webtransport_session_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  NSObject *v8;
  int v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  nw_protocol *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_disconnect";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v3, &type, &v14))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_webtransport_session_disconnect";
      v6 = "%{public}s called with null protocol";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v11 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_webtransport_session_disconnect";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v3)
          return;
LABEL_37:
        free(v3);
        return;
      }
      if (!v11)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_webtransport_session_disconnect";
      v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_webtransport_session_disconnect";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_36;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0 && gLogDatapath)
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v9 = handle[115];
        *(_DWORD *)buf = 136447234;
        v17 = "nw_protocol_webtransport_session_disconnect";
        v18 = 2082;
        v19 = (char *)(handle + 116);
        v20 = 2080;
        v21 = " ";
        v22 = 1024;
        v23 = v9;
        v24 = 2048;
        v25 = a2;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called, with other_protocol: %p", buf, 0x30u);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_webtransport_session_disconnect";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v3, &type, &v14))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_disconnect";
    v6 = "%{public}s called with null webtransport_session";
    goto LABEL_35;
  }
  if (!v14)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_disconnect";
    v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_35;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v13 = os_log_type_enabled(v4, type);
  if (!v12)
  {
    if (!v13)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_disconnect";
    v6 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_35;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v17 = "nw_protocol_webtransport_session_disconnect";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v3)
    goto LABEL_37;
}

void nw_protocol_webtransport_session_connected(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unsigned __int8 *v9;
  void *v10;
  int version;
  int v12;
  int v13;
  _QWORD *v14;
  _BOOL4 v15;
  char v16;
  NSObject *v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  NSObject *v22;
  const char *hostname;
  int port;
  void *url_path;
  void *v26;
  const char *v27;
  void *v28;
  id *metadata_for_request;
  uint64_t v30;
  int output_frames;
  uint64_t v32;
  uint64_t v33;
  char v34;
  char v35;
  char v36;
  NSObject *v37;
  int v38;
  const char *v39;
  NSObject *v40;
  os_log_type_t v41;
  NSObject *v42;
  int v43;
  NSObject *v44;
  int v45;
  NSObject *v46;
  int v47;
  char *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  NSObject *v60;
  int v61;
  NSObject *v62;
  int v63;
  char *v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  uint64_t v70;
  _QWORD *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  const char *v75;
  NSObject *v76;
  int v77;
  NSObject *v78;
  int v79;
  nw_protocol_identifier *identifier;
  char *backtrace_string;
  _BOOL4 v82;
  char *v83;
  _BOOL4 v84;
  const char *v85;
  NSObject *v86;
  int v87;
  NSObject *v88;
  int v89;
  int v90;
  NSObject *v91;
  _BOOL4 v92;
  int v93;
  char *v94;
  NSObject *v95;
  os_log_type_t v96;
  const char *v97;
  char *v98;
  _BOOL4 v99;
  char *v100;
  _BOOL4 v101;
  _BOOL4 v102;
  _BOOL4 v103;
  _QWORD v104[5];
  char *v105;
  _QWORD v106[2];
  _BYTE buf[24];
  const char *v108;
  _BYTE *v109;
  nw_protocol *v110;
  __int128 v111;
  _BYTE v112[24];
  const char *v113;
  __int16 v114;
  int v115;
  __int16 v116;
  int v117;
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
    v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v104[0]) = 0;
    if (!__nwlog_fault(v72, v112, v104))
      goto LABEL_153;
    if (v112[0] == 17)
    {
      v73 = __nwlog_obj();
      v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null protocol";
      goto LABEL_152;
    }
    if (!LOBYTE(v104[0]))
    {
      v73 = __nwlog_obj();
      v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_152;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v73 = __nwlog_obj();
    v74 = v112[0];
    v82 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!backtrace_string)
    {
      if (!v82)
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_152;
    }
    if (v82)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
    goto LABEL_153;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
    v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v104[0]) = 0;
    if (!__nwlog_fault(v72, v112, v104))
      goto LABEL_153;
    if (v112[0] == 17)
    {
      v73 = __nwlog_obj();
      v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null webtransport_session";
      goto LABEL_152;
    }
    if (!LOBYTE(v104[0]))
    {
      v73 = __nwlog_obj();
      v74 = v112[0];
      if (!os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_152;
    }
    v83 = (char *)__nw_create_backtrace_string();
    v73 = __nwlog_obj();
    v74 = v112[0];
    v84 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!v83)
    {
      if (!v84)
        goto LABEL_153;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
      v75 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_152;
    }
    if (!v84)
      goto LABEL_142;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v83;
    v85 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
    goto LABEL_141;
  }
  if ((handle[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v76 = __nwlog_obj();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
      {
        v77 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v77;
        _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got a connected event from the lower layer", buf, 0x26u);
      }
    }
  }
  if (a1->output_handler != a2)
  {
    if ((handle[548] & 2) == 0 && gLogDatapath)
    {
      v78 = __nwlog_obj();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
      {
        v79 = *((_DWORD *)handle + 115);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v79;
        HIWORD(v109) = 2048;
        v110 = a2;
        LOWORD(v111) = 2080;
        *(_QWORD *)((char *)&v111 + 2) = identifier;
        _os_log_impl(&dword_182FBE000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> connected protocol %p (%s) is not our output_handler, ignoring", buf, 0x3Au);
      }
    }
    return;
  }
  v5 = *((_QWORD *)handle + 4);
  if (!v5 || *((_DWORD *)handle + 112) != 2)
    goto LABEL_40;
  v6 = *(_QWORD **)(v5 + 16);
  if (nw_protocol_http2_identifier::onceToken[0] != -1)
    dispatch_once(nw_protocol_http2_identifier::onceToken, &__block_literal_global_83230);
  if (!nw_protocols_are_equal(v6, &nw_protocol_http2_identifier::http2_protocol_identifier))
  {
    v7 = *(_QWORD **)(v5 + 16);
    if (nw_protocol_http3_identifier::onceToken[0] != -1)
      dispatch_once(nw_protocol_http3_identifier::onceToken, &__block_literal_global_10);
    if (!nw_protocols_are_equal(v7, &nw_protocol_http3_identifier::http3_protocol_identifier))
    {
      v8 = *(_QWORD **)(v5 + 16);
      if (nw_protocol_http_messaging_identifier::onceToken[0] != -1)
        dispatch_once(nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_75867);
      if (!nw_protocols_are_equal(v8, nw_protocol_http_messaging_identifier::protocol_identifier))
        goto LABEL_40;
    }
  }
  v9 = (unsigned __int8 *)nw_protocol_copy_info(v5, 255);
  v104[0] = MEMORY[0x1E0C809B0];
  v104[1] = 0x40000000;
  v104[2] = ___ZL33nw_webtransport_session_establishP23nw_webtransport_session_block_invoke;
  v104[3] = &__block_descriptor_tmp_45;
  v104[4] = handle;
  nw_array_apply(v9, (uint64_t)v104);
  v10 = (void *)*((_QWORD *)handle + 47);
  if (!v10)
  {
    if (v9)
      os_release(v9);
    goto LABEL_68;
  }
  version = nw_http_connection_metadata_get_version(v10);
  v12 = version;
  if (version == 4)
  {
    v13 = 0;
LABEL_27:
    *((_DWORD *)handle + 112) = v13;
    goto LABEL_28;
  }
  if (version == 5)
  {
    v13 = 1;
    goto LABEL_27;
  }
LABEL_28:
  v14 = *(_QWORD **)(v5 + 16);
  if (nw_protocol_http_messaging_identifier::onceToken[0] != -1)
    dispatch_once(nw_protocol_http_messaging_identifier::onceToken, &__block_literal_global_75867);
  v15 = nw_protocols_are_equal(v14, nw_protocol_http_messaging_identifier::protocol_identifier);
  v16 = handle[548];
  if (v15)
  {
    v16 |= 0x40u;
    handle[548] = v16;
  }
  if ((v16 & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v18 = *((_DWORD *)handle + 115);
      if (v12 == 4)
        v19 = 2;
      else
        v19 = 3;
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_establish";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v18;
      HIWORD(v109) = 1024;
      LODWORD(v110) = v19;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Establishing webtransport session for HTTP/%u", buf, 0x2Cu);
    }
  }
  if (v9)
    os_release(v9);
LABEL_40:
  v20 = *((_DWORD *)handle + 112);
  if (v20 <= 1)
  {
    v21 = *((_DWORD *)handle + 111);
    if ((handle[548] & 1) == 0)
    {
      if (v21)
        return;
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v86 = __nwlog_obj();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
          {
            v87 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_webtransport_http_send_connect";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            v108 = " ";
            LOWORD(v109) = 1024;
            *(_DWORD *)((char *)&v109 + 2) = v87;
            _os_log_impl(&dword_182FBE000, v86, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }
      if ((handle[548] & 1) != 0)
      {
LABEL_119:
        *((_DWORD *)handle + 111) = 1;
        return;
      }
      v22 = *((_QWORD *)handle + 45);
      v105 = 0;
      hostname = nw_endpoint_get_hostname(v22);
      port = nw_endpoint_get_port(v22);
      asprintf(&v105, "%s:%u", hostname, port);
      url_path = nw_parameters_copy_url_endpoint(*((void **)handle + 43));
      v26 = url_path;
      if (url_path)
        url_path = (void *)nw_endpoint_get_url_path(url_path);
      if (url_path)
        v27 = (const char *)url_path;
      else
        v27 = "/";
      v28 = (void *)_nw_http_request_create("CONNECT", "https", v105, v27);
      if (v105)
      {
        free(v105);
        v105 = 0;
      }
      nw_http_request_set_extended_connect_protocol(v28, (uint64_t)"webtransport");
      metadata_for_request = nw_http_create_metadata_for_request(v28);
      v30 = *((_QWORD *)handle + 4);
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v88 = __nwlog_obj();
          if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
          {
            v89 = *((_DWORD *)handle + 115);
            *(_DWORD *)v112 = 136446978;
            *(_QWORD *)&v112[4] = "nw_webtransport_session_send_metadata";
            *(_WORD *)&v112[12] = 2082;
            *(_QWORD *)&v112[14] = handle + 464;
            *(_WORD *)&v112[22] = 2080;
            v113 = " ";
            v114 = 1024;
            v115 = v89;
            _os_log_impl(&dword_182FBE000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", v112, 0x26u);
          }
        }
      }
      v106[0] = 0;
      v106[1] = v106;
      output_frames = nw_protocol_get_output_frames(v30, (uint64_t)handle, 0, 0, 1, (uint64_t)v106);
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v90 = output_frames;
          v91 = __nwlog_obj();
          v92 = os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG);
          output_frames = v90;
          if (v92)
          {
            v93 = *((_DWORD *)handle + 115);
            *(_DWORD *)v112 = 136447234;
            *(_QWORD *)&v112[4] = "nw_webtransport_session_send_metadata";
            *(_WORD *)&v112[12] = 2082;
            *(_QWORD *)&v112[14] = handle + 464;
            *(_WORD *)&v112[22] = 2080;
            v113 = " ";
            v114 = 1024;
            v115 = v93;
            v116 = 1024;
            v117 = v90;
            _os_log_impl(&dword_182FBE000, v91, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got %u output frames", v112, 0x2Cu);
            output_frames = v90;
          }
        }
      }
      if (output_frames)
      {
        *(_QWORD *)v112 = 0;
        *(_QWORD *)&v112[8] = v112;
        *(_QWORD *)&v112[16] = 0x2000000000;
        LOBYTE(v113) = 0;
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke;
        v108 = (const char *)&unk_1E14A06A8;
        v109 = v112;
        v110 = (nw_protocol *)v106;
        *(_QWORD *)&v111 = handle;
        *((_QWORD *)&v111 + 1) = metadata_for_request;
        v32 = v106[0];
        do
        {
          if (!v32)
            break;
          v33 = *(_QWORD *)(v32 + 32);
          v34 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          v32 = v33;
        }
        while ((v34 & 1) != 0);
        v35 = nw_protocol_finalize_output_frames(v30, (uint64_t)v106);
        _Block_object_dispose(v112, 8);
        v36 = handle[548];
        if ((v35 & 1) != 0)
        {
          if ((handle[548] & 2) != 0)
            goto LABEL_113;
          v37 = __nwlog_obj();
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
            goto LABEL_113;
          v38 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_http_send_connect";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v108 = " ";
          LOWORD(v109) = 1024;
          *(_DWORD *)((char *)&v109 + 2) = v38;
          v39 = "%{public}s %{public}s%s<i%u> Sent CONNECT request to WebTransport server";
          v40 = v37;
          v41 = OS_LOG_TYPE_DEBUG;
          goto LABEL_99;
        }
      }
      else
      {
        v36 = handle[548];
      }
      if (*((_DWORD *)handle + 111) != 5)
      {
        if ((v36 & 2) == 0)
        {
          v62 = __nwlog_obj();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_INFO))
          {
            v63 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            v108 = " ";
            LOWORD(v109) = 1024;
            *(_DWORD *)((char *)&v109 + 2) = v63;
            HIWORD(v109) = 1024;
            LODWORD(v110) = 12;
            _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
          }
        }
        *((_DWORD *)handle + 111) = 5;
        v64 = (char *)*((_QWORD *)handle + 23);
        if (v64)
        {
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
          v108 = (const char *)&__block_descriptor_tmp_22_33428;
          LODWORD(v109) = 12;
          nw_hash_table_apply(v64, (uint64_t)buf);
        }
        v65 = *((_QWORD *)handle + 53);
        if (v65)
        {
          v66 = *(_QWORD **)(v65 + 48);
          nw_protocol_error(v66, *((_QWORD *)handle + 53));
          nw_protocol_disconnected(v66, v65);
        }
        v67 = *((_QWORD *)handle + 41);
        if (v67)
        {
          do
          {
            v68 = *(_QWORD *)(v67 + 112);
            v69 = *(_QWORD **)(v67 + 48);
            nw_protocol_error(v69, v67);
            nw_protocol_disconnected(v69, v67);
            v67 = v68;
          }
          while (v68);
        }
        v70 = *((_QWORD *)handle + 52);
        if (v70)
        {
          v71 = *(_QWORD **)(v70 + 48);
          nw_protocol_error(v71, *((_QWORD *)handle + 52));
          nw_protocol_disconnected(v71, v70);
        }
        if (*((_QWORD *)handle + 4))
        {
          nw_protocol_remove_instance((uint64_t)handle);
          nw_protocol_disconnect(*((_QWORD **)handle + 4), (uint64_t)handle);
        }
        goto LABEL_113;
      }
      if ((v36 & 2) != 0 || (v60 = __nwlog_obj(), !os_log_type_enabled(v60, OS_LOG_TYPE_INFO)))
      {
LABEL_113:
        if (metadata_for_request)
          os_release(metadata_for_request);
        if (v28)
          os_release(v28);
        if (v26)
          os_release(v26);
        goto LABEL_119;
      }
      v61 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v61;
      v39 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
      v40 = v60;
      v41 = OS_LOG_TYPE_INFO;
LABEL_99:
      _os_log_impl(&dword_182FBE000, v40, v41, v39, buf, 0x26u);
      goto LABEL_113;
    }
    if (v21)
      return;
    if (v20 == 1)
    {
      v56 = *((_QWORD *)handle + 6);
      if (v56)
      {
        v57 = *(_QWORD *)(v56 + 40);
        if (v57)
        {
          nw_protocol_replace_input_handler(*((_QWORD *)handle + 4), (uint64_t)handle, *(_QWORD *)(v56 + 40));
          *((_QWORD *)handle + 52) = v57;
          nw_protocol_set_output_handler((uint64_t)handle, 0);
          nw_protocol_set_input_handler((uint64_t)handle, 0);
LABEL_90:
          *((_DWORD *)handle + 111) = 2;
          return;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
        v94 = (char *)_os_log_send_and_compose_impl();
        v112[0] = 16;
        LOBYTE(v106[0]) = 0;
        if (!__nwlog_fault(v94, v112, v106))
          goto LABEL_211;
        if (v112[0] == 17)
        {
          v95 = __nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0]))
            goto LABEL_211;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream";
          goto LABEL_210;
        }
        if (!LOBYTE(v106[0]))
        {
          v95 = __nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0]))
            goto LABEL_211;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_210;
        }
        v100 = (char *)__nw_create_backtrace_string();
        v95 = __nwlog_obj();
        v96 = v112[0];
        v101 = os_log_type_enabled(v95, (os_log_type_t)v112[0]);
        if (v100)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v100;
            _os_log_impl(&dword_182FBE000, v95, v96, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v100);
          if (!v94)
            goto LABEL_90;
          goto LABEL_212;
        }
        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_210:
          _os_log_impl(&dword_182FBE000, v95, v96, v97, buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
        v94 = (char *)_os_log_send_and_compose_impl();
        v112[0] = 16;
        LOBYTE(v106[0]) = 0;
        if (!__nwlog_fault(v94, v112, v106))
          goto LABEL_211;
        if (v112[0] == 17)
        {
          v95 = __nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0]))
            goto LABEL_211;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol";
          goto LABEL_210;
        }
        if (!LOBYTE(v106[0]))
        {
          v95 = __nwlog_obj();
          v96 = v112[0];
          if (!os_log_type_enabled(v95, (os_log_type_t)v112[0]))
            goto LABEL_211;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_210;
        }
        v98 = (char *)__nw_create_backtrace_string();
        v95 = __nwlog_obj();
        v96 = v112[0];
        v99 = os_log_type_enabled(v95, (os_log_type_t)v112[0]);
        if (!v98)
        {
          if (!v99)
            goto LABEL_211;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          v97 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_210;
        }
        if (v99)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_http3_setup_placeholder_stream";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v98;
          _os_log_impl(&dword_182FBE000, v95, v96, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v98);
      }
LABEL_211:
      if (!v94)
        goto LABEL_90;
LABEL_212:
      free(v94);
      goto LABEL_90;
    }
    *((_DWORD *)handle + 111) = 3;
    v58 = *((_QWORD *)handle + 6);
    if (v58)
    {
      v59 = *(_QWORD *)(v58 + 40);
      if (v59)
      {
        *((_QWORD *)handle + 52) = v59;
        return;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
      v72 = (char *)_os_log_send_and_compose_impl();
      v112[0] = 16;
      LOBYTE(v106[0]) = 0;
      if (!__nwlog_fault(v72, v112, v106))
        goto LABEL_153;
      if (v112[0] == 17)
      {
        v73 = __nwlog_obj();
        v74 = v112[0];
        if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
          v75 = "%{public}s called with null webtransport_stream";
          goto LABEL_152;
        }
        goto LABEL_153;
      }
      if (!LOBYTE(v106[0]))
      {
        v73 = __nwlog_obj();
        v74 = v112[0];
        if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
          v75 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_152;
        }
        goto LABEL_153;
      }
      v83 = (char *)__nw_create_backtrace_string();
      v73 = __nwlog_obj();
      v74 = v112[0];
      v103 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
      if (!v83)
      {
        if (v103)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
          v75 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_152;
        }
        goto LABEL_153;
      }
      if (v103)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v83;
        v85 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
        goto LABEL_141;
      }
LABEL_142:
      free(v83);
      if (!v72)
        return;
LABEL_154:
      free(v72);
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
    v72 = (char *)_os_log_send_and_compose_impl();
    v112[0] = 16;
    LOBYTE(v106[0]) = 0;
    if (!__nwlog_fault(v72, v112, v106))
      goto LABEL_153;
    if (v112[0] == 17)
    {
      v73 = __nwlog_obj();
      v74 = v112[0];
      if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        v75 = "%{public}s called with null input_protocol";
LABEL_152:
        _os_log_impl(&dword_182FBE000, v73, v74, v75, buf, 0xCu);
      }
LABEL_153:
      if (!v72)
        return;
      goto LABEL_154;
    }
    if (!LOBYTE(v106[0]))
    {
      v73 = __nwlog_obj();
      v74 = v112[0];
      if (os_log_type_enabled(v73, (os_log_type_t)v112[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        v75 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_152;
      }
      goto LABEL_153;
    }
    v83 = (char *)__nw_create_backtrace_string();
    v73 = __nwlog_obj();
    v74 = v112[0];
    v102 = os_log_type_enabled(v73, (os_log_type_t)v112[0]);
    if (!v83)
    {
      if (v102)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
        v75 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_152;
      }
      goto LABEL_153;
    }
    if (!v102)
      goto LABEL_142;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_webtransport_http2_setup_placeholder_stream";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v83;
    v85 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
LABEL_141:
    _os_log_impl(&dword_182FBE000, v73, v74, v85, buf, 0x16u);
    goto LABEL_142;
  }
  if ((handle[548] & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v42 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v43 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_establish";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v108 = " ";
      LOWORD(v109) = 1024;
      *(_DWORD *)((char *)&v109 + 2) = v43;
      _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Unknown webtransport session transport mode for establishment, failing", buf, 0x26u);
    }
  }
LABEL_68:
  if (*((_DWORD *)handle + 111) == 5)
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v44 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v45 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v45;
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Session already terminated, ignoring", buf, 0x26u);
      }
    }
  }
  else
  {
    if ((handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v46 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v47 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v108 = " ";
        LOWORD(v109) = 1024;
        *(_DWORD *)((char *)&v109 + 2) = v47;
        HIWORD(v109) = 1024;
        LODWORD(v110) = 57;
        _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
      }
    }
    *((_DWORD *)handle + 111) = 5;
    v48 = (char *)*((_QWORD *)handle + 23);
    if (v48)
    {
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
      v108 = (const char *)&__block_descriptor_tmp_22_33428;
      LODWORD(v109) = 57;
      nw_hash_table_apply(v48, (uint64_t)buf);
    }
    v49 = *((_QWORD *)handle + 53);
    if (v49)
    {
      v50 = *(_QWORD **)(v49 + 48);
      nw_protocol_error(v50, *((_QWORD *)handle + 53));
      nw_protocol_disconnected(v50, v49);
    }
    v51 = *((_QWORD *)handle + 41);
    if (v51)
    {
      do
      {
        v52 = *(_QWORD *)(v51 + 112);
        v53 = *(_QWORD **)(v51 + 48);
        nw_protocol_error(v53, v51);
        nw_protocol_disconnected(v53, v51);
        v51 = v52;
      }
      while (v52);
    }
    v54 = *((_QWORD *)handle + 52);
    if (v54)
    {
      v55 = *(_QWORD **)(v54 + 48);
      nw_protocol_error(v55, *((_QWORD *)handle + 52));
      nw_protocol_disconnected(v55, v54);
    }
    if (*((_QWORD *)handle + 4))
    {
      nw_protocol_remove_instance((uint64_t)handle);
      nw_protocol_disconnect(*((_QWORD **)handle + 4), (uint64_t)handle);
    }
  }
}

void nw_protocol_webtransport_session_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  NSObject *v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t v11;
  int v12;
  char *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  NSObject *v28;
  int v29;
  char *backtrace_string;
  _BOOL4 v31;
  char *v32;
  _BOOL4 v33;
  char v34;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v37;
  _BYTE v38[6];
  __int16 v39;
  nw_protocol *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
    v23 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (!__nwlog_fault(v23, &type, &v34))
      goto LABEL_65;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
      v26 = "%{public}s called with null protocol";
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v31 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_65:
        if (!v23)
          return;
LABEL_66:
        free(v23);
        return;
      }
      if (!v31)
        goto LABEL_65;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
      v26 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_65;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
      v26 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_64:
    _os_log_impl(&dword_182FBE000, v24, v25, v26, buf, 0xCu);
    goto LABEL_65;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        v28 = __nwlog_obj();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          v29 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v37 = " ";
          *(_WORD *)v38 = 1024;
          *(_DWORD *)&v38[2] = v29;
          v39 = 2048;
          v40 = a2;
          _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called, with other_protocol: %p", buf, 0x30u);
        }
      }
    }
    if (*((_DWORD *)handle + 111) == 5)
    {
      if ((handle[548] & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v4 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v37 = " ";
          *(_WORD *)v38 = 1024;
          *(_DWORD *)&v38[2] = v4;
          _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Session already terminated, ignoring", buf, 0x26u);
        }
      }
      return;
    }
    v5 = *((_DWORD *)handle + 113);
    if (v5)
    {
      if ((handle[548] & 2) != 0)
        goto LABEL_17;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        goto LABEL_17;
      v7 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v37 = " ";
      *(_WORD *)v38 = 1024;
      *(_DWORD *)&v38[2] = v7;
      v39 = 1024;
      LODWORD(v40) = v5;
      v8 = "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d";
      v9 = v6;
      v10 = 44;
    }
    else
    {
      if ((handle[548] & 2) != 0)
        goto LABEL_17;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        goto LABEL_17;
      v12 = *((_DWORD *)handle + 115);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 464;
      *(_WORD *)&buf[22] = 2080;
      v37 = " ";
      *(_WORD *)v38 = 1024;
      *(_DWORD *)&v38[2] = v12;
      v8 = "%{public}s %{public}s%s<i%u> Closing webtransport session without error";
      v9 = v11;
      v10 = 38;
    }
    _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_INFO, v8, buf, v10);
LABEL_17:
    *((_DWORD *)handle + 111) = 5;
    v13 = (char *)*((_QWORD *)handle + 23);
    if (v13)
    {
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
      v37 = (const char *)&__block_descriptor_tmp_22_33428;
      *(_DWORD *)v38 = v5;
      nw_hash_table_apply(v13, (uint64_t)buf);
    }
    v14 = *((_QWORD *)handle + 53);
    if (v14)
    {
      v15 = *(_QWORD **)(v14 + 48);
      if (v5)
        nw_protocol_error(*(_QWORD **)(v14 + 48), *((_QWORD *)handle + 53));
      nw_protocol_disconnected(v15, v14);
    }
    v16 = *((_QWORD *)handle + 41);
    if (v16)
    {
      if (v5)
      {
        do
        {
          v17 = *(_QWORD *)(v16 + 112);
          v18 = *(_QWORD **)(v16 + 48);
          nw_protocol_error(v18, v16);
          v19 = v16;
          v16 = v17;
          nw_protocol_disconnected(v18, v19);
        }
        while (v17);
      }
      else
      {
        do
        {
          v20 = *(_QWORD *)(v16 + 112);
          nw_protocol_disconnected(*(_QWORD **)(v16 + 48), v16);
          v16 = v20;
        }
        while (v20);
      }
    }
    v21 = *((_QWORD *)handle + 52);
    if (v21)
    {
      v22 = *(_QWORD **)(v21 + 48);
      if (v5)
        nw_protocol_error(*(_QWORD **)(v21 + 48), *((_QWORD *)handle + 52));
      nw_protocol_disconnected(v22, v21);
    }
    if (*((_QWORD *)handle + 4))
    {
      nw_protocol_remove_instance((uint64_t)handle);
      nw_protocol_disconnect(*((_QWORD **)handle + 4), (uint64_t)handle);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
  v23 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (!__nwlog_fault(v23, &type, &v34))
    goto LABEL_65;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
      goto LABEL_65;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
    v26 = "%{public}s called with null webtransport_session";
    goto LABEL_64;
  }
  if (!v34)
  {
    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
      goto LABEL_65;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
    v26 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_64;
  }
  v32 = (char *)__nw_create_backtrace_string();
  v24 = __nwlog_obj();
  v25 = type;
  v33 = os_log_type_enabled(v24, type);
  if (!v32)
  {
    if (!v33)
      goto LABEL_65;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
    v26 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_64;
  }
  if (v33)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_disconnected";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v32;
    _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v32);
  if (v23)
    goto LABEL_66;
}

void nw_protocol_webtransport_session_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  _DWORD *handle;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v10;
  int v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  nw_protocol *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_session_error";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v5, &type, &v16))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_session_error";
      v8 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v13 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_session_error";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v5)
          return;
LABEL_38:
        free(v5);
        return;
      }
      if (!v13)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_session_error";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_session_error";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_37;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0 && gLogDatapath)
    {
      v10 = __nwlog_obj();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v11 = handle[115];
        *(_DWORD *)buf = 136447234;
        v19 = "nw_protocol_webtransport_session_error";
        v20 = 2082;
        v21 = (char *)(handle + 116);
        v22 = 2080;
        v23 = " ";
        v24 = 1024;
        v25 = v11;
        v26 = 2048;
        v27 = a2;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called, with other_protocol: %p", buf, 0x30u);
      }
    }
    handle[113] = a3;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_session_error";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v5, &type, &v16))
    goto LABEL_37;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_session_error";
    v8 = "%{public}s called with null webtransport_session";
    goto LABEL_36;
  }
  if (!v16)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_session_error";
    v8 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_36;
  }
  v14 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v15 = os_log_type_enabled(v6, type);
  if (!v14)
  {
    if (!v15)
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_session_error";
    v8 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_36;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_session_error";
    v20 = 2082;
    v21 = v14;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v14);
  if (v5)
    goto LABEL_38;
}

void nw_protocol_webtransport_session_input_available(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  _BYTE *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  NSObject *v37;
  const char *v38;
  uint32_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  uint64_t stream;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  NSObject *v58;
  int v59;
  uint64_t v60;
  _QWORD **v61;
  _QWORD *v62;
  nw_parameters_t v63;
  int v64;
  uint64_t *v65;
  nw_protocol *v66;
  NSObject *v67;
  int v68;
  NSObject *v69;
  int v70;
  uint64_t v71;
  NSObject *v72;
  uint64_t v73;
  uint64_t (*v74)(uint64_t, uint64_t);
  char *v75;
  NSObject *v76;
  os_log_type_t v77;
  const char *v78;
  NSObject *v79;
  int v80;
  NSObject *v81;
  int v82;
  char *backtrace_string;
  _BOOL4 v84;
  char *v85;
  _BOOL4 v86;
  const char *v87;
  _BOOL4 v88;
  _BOOL4 v89;
  NSObject *v90;
  int v91;
  NSObject *log;
  char *v93;
  uint64_t v94;
  _QWORD v95[2];
  uint64_t (*v96)(_QWORD *);
  void *v97;
  _BYTE *v98;
  char *v99;
  _QWORD v100[2];
  uint64_t (*v101)(uint64_t, uint64_t);
  void *v102;
  _QWORD *v103;
  uint64_t v104;
  _QWORD v105[2];
  uint64_t (*v106)(uint64_t, uint64_t);
  void *v107;
  _QWORD *v108;
  _QWORD v109[2];
  uint64_t (*v110)(uint64_t, uint64_t);
  void *v111;
  _QWORD *v112;
  uint64_t v113;
  BOOL v114;
  _QWORD v115[2];
  uint64_t (*v116)(uint64_t, uint64_t);
  void *v117;
  _QWORD *v118;
  int v119;
  char v120;
  os_log_type_t type[8];
  uint64_t v122;
  uint64_t (*v123)(os_log_type_t *);
  void *v124;
  uint64_t *v125;
  _QWORD *v126;
  char *v127;
  int *v128;
  uint64_t v129;
  uint64_t *v130;
  uint64_t v131;
  BOOL v132;
  uint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  int v136;
  _QWORD v137[3];
  int v138;
  _QWORD v139[2];
  uint64_t (*v140)(uint64_t, _DWORD *);
  void *v141;
  uint64_t *v142;
  _QWORD *v143;
  _QWORD v144[3];
  int v145;
  uint64_t v146;
  uint64_t *v147;
  uint64_t v148;
  int v149;
  _BYTE buf[24];
  uint64_t (*v151)(uint64_t, uint64_t);
  void (*v152)(uint64_t);
  uint64_t *v153;
  _BYTE v154[20];
  __int16 v155;
  uint64_t v156;
  uint64_t v157;

  v157 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
    v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (!__nwlog_fault(v75, type, v109))
      goto LABEL_204;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v109[0]))
      {
        v76 = __nwlog_obj();
        v77 = type[0];
        if (!os_log_type_enabled(v76, type[0]))
          goto LABEL_204;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
        v78 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_203;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v76 = __nwlog_obj();
      v77 = type[0];
      v84 = os_log_type_enabled(v76, type[0]);
      if (!backtrace_string)
      {
        if (!v84)
          goto LABEL_204;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
        v78 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_203;
      }
      if (v84)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v76, v77, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_204;
    }
    v76 = __nwlog_obj();
    v77 = type[0];
    if (!os_log_type_enabled(v76, type[0]))
      goto LABEL_204;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
    v78 = "%{public}s called with null protocol";
LABEL_203:
    _os_log_impl(&dword_182FBE000, v76, v77, v78, buf, 0xCu);
    goto LABEL_204;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
    v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (!__nwlog_fault(v75, type, v109))
      goto LABEL_204;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!LOBYTE(v109[0]))
      {
        v76 = __nwlog_obj();
        v77 = type[0];
        if (!os_log_type_enabled(v76, type[0]))
          goto LABEL_204;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
        v78 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_203;
      }
      v85 = (char *)__nw_create_backtrace_string();
      v76 = __nwlog_obj();
      v77 = type[0];
      v86 = os_log_type_enabled(v76, type[0]);
      if (!v85)
      {
        if (!v86)
          goto LABEL_204;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
        v78 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_203;
      }
      if (v86)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v85;
        v87 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
LABEL_182:
        _os_log_impl(&dword_182FBE000, v76, v77, v87, buf, 0x16u);
      }
LABEL_183:
      free(v85);
      if (!v75)
        return;
LABEL_205:
      free(v75);
      return;
    }
    v76 = __nwlog_obj();
    v77 = type[0];
    if (!os_log_type_enabled(v76, type[0]))
      goto LABEL_204;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
    v78 = "%{public}s called with null webtransport_session";
    goto LABEL_203;
  }
  if ((handle[548] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v79 = __nwlog_obj();
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
      {
        v80 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v152) = 1024;
        *(_DWORD *)((char *)&v152 + 2) = v80;
        _os_log_impl(&dword_182FBE000, v79, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
  }
  if (*((_DWORD *)handle + 112) > 1u)
    return;
  v3 = *((_QWORD *)handle + 4);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
    v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (!__nwlog_fault(v75, type, v109))
      goto LABEL_204;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v76 = __nwlog_obj();
      v77 = type[0];
      if (!os_log_type_enabled(v76, type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
      v78 = "%{public}s called with null output_handler";
      goto LABEL_203;
    }
    if (!LOBYTE(v109[0]))
    {
      v76 = __nwlog_obj();
      v77 = type[0];
      if (!os_log_type_enabled(v76, type[0]))
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
      v78 = "%{public}s called with null output_handler, backtrace limit exceeded";
      goto LABEL_203;
    }
    v85 = (char *)__nw_create_backtrace_string();
    v76 = __nwlog_obj();
    v77 = type[0];
    v89 = os_log_type_enabled(v76, type[0]);
    if (!v85)
    {
      if (!v89)
        goto LABEL_204;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
      v78 = "%{public}s called with null output_handler, no backtrace";
      goto LABEL_203;
    }
    if (v89)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v85;
      v87 = "%{public}s called with null output_handler, dumping backtrace:%{public}s";
      goto LABEL_182;
    }
    goto LABEL_183;
  }
  v4 = *(_QWORD *)(v3 + 24);
  if (!v4 || !*(_QWORD *)(v4 + 80))
  {
    if ((handle[548] & 2) == 0)
    {
      v81 = __nwlog_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
      {
        v82 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
        LOWORD(v152) = 1024;
        *(_DWORD *)((char *)&v152 + 2) = v82;
        _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback", buf, 0x26u);
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
    v75 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v109[0]) = 0;
    if (__nwlog_fault(v75, type, v109))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v76 = __nwlog_obj();
        v77 = type[0];
        if (!os_log_type_enabled(v76, type[0]))
          goto LABEL_204;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
        v78 = "%{public}s output handler has no get_input_frames callback";
        goto LABEL_203;
      }
      if (!LOBYTE(v109[0]))
      {
        v76 = __nwlog_obj();
        v77 = type[0];
        if (!os_log_type_enabled(v76, type[0]))
          goto LABEL_204;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
        v78 = "%{public}s output handler has no get_input_frames callback, backtrace limit exceeded";
        goto LABEL_203;
      }
      v85 = (char *)__nw_create_backtrace_string();
      v76 = __nwlog_obj();
      v77 = type[0];
      v88 = os_log_type_enabled(v76, type[0]);
      if (!v85)
      {
        if (!v88)
          goto LABEL_204;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
        v78 = "%{public}s output handler has no get_input_frames callback, no backtrace";
        goto LABEL_203;
      }
      if (v88)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v85;
        v87 = "%{public}s output handler has no get_input_frames callback, dumping backtrace:%{public}s";
        goto LABEL_182;
      }
      goto LABEL_183;
    }
LABEL_204:
    if (!v75)
      return;
    goto LABEL_205;
  }
  v94 = (uint64_t)handle;
  while ((*((_DWORD *)handle + 111) | 2) == 3)
  {
    *(_QWORD *)type = 0;
    v122 = (uint64_t)type;
    if (!nw_protocol_get_input_frames(v3, (uint64_t)handle, 0, 0, 0xFFFFFFFFLL, (uint64_t)type))
      return;
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3802000000;
    v151 = __Block_byref_object_copy__50;
    v152 = __Block_byref_object_dispose__51;
    if (nw_protocol_copy_http_definition_onceToken != -1)
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_11_72660);
    v153 = (uint64_t *)(id)nw_protocol_copy_http_definition_http_definition;
    v154[0] |= 1u;
    v95[0] = MEMORY[0x1E0C809B0];
    v95[1] = 0x40000000;
    v96 = (uint64_t (*)(_QWORD *))___ZL38nw_webtransport_session_http_get_inputP23nw_webtransport_session_block_invoke;
    v97 = &unk_1E14A06D0;
    v98 = buf;
    v99 = handle;
    v5 = *(_QWORD *)type;
    do
    {
      if (!v5)
        break;
      v6 = *(_QWORD *)(v5 + 32);
      v7 = v96(v95);
      v5 = v6;
    }
    while ((v7 & 1) != 0);
    _Block_object_dispose(buf, 8);
    if ((v154[0] & 1) != 0)
    {
      if (v153)
        os_release(v153);
    }
    handle = (char *)v94;
  }
  if (!*((_DWORD *)handle + 112))
  {
    v8 = &unk_1ECD84000;
    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        v90 = __nwlog_obj();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
        {
          v91 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_handle_capsules";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v152) = 1024;
          *(_DWORD *)((char *)&v152 + 2) = v91;
          _os_log_impl(&dword_182FBE000, v90, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    if (*((_DWORD *)handle + 111) == 4)
    {
      v9 = handle + 96;
      v93 = handle + 464;
LABEL_26:
      v119 = 0;
      v129 = 0;
      v130 = &v129;
      v131 = 0x2000000000;
      v10 = *((_QWORD *)handle + 17);
      v132 = v10 != 0;
      if (!v10)
      {
        do
        {
          v23 = *v9;
          if (!*v9)
          {
            v24 = *((_QWORD *)handle + 4);
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = buf;
            if (!nw_protocol_get_input_frames(v24, (uint64_t)handle, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, (uint64_t)buf))goto LABEL_142;
            if (*(_QWORD *)buf)
            {
              **((_QWORD **)handle + 13) = *(_QWORD *)buf;
              v25 = *(_QWORD *)&buf[8];
              *(_QWORD *)(*(_QWORD *)buf + 40) = *((_QWORD *)handle + 13);
              *((_QWORD *)handle + 13) = v25;
            }
            v23 = *v9;
          }
          *(_QWORD *)type = MEMORY[0x1E0C809B0];
          v122 = 0x40000000;
          v123 = (uint64_t (*)(os_log_type_t *))__nw_http_capsule_framer_read_capsule_block_invoke;
          v124 = &unk_1E14A3A48;
          v125 = &v129;
          v126 = v9;
          v127 = handle;
          v128 = &v119;
          do
          {
            if (!v23)
              break;
            v26 = *(_QWORD *)(v23 + 32);
            v27 = v123(type);
            v23 = v26;
          }
          while ((v27 & 1) != 0);
          handle = (char *)v94;
        }
        while (!*((_BYTE *)v130 + 24));
      }
      v120 = 0;
      while (1)
      {
        v146 = 0;
        v147 = &v146;
        v149 = 0;
        v148 = 0x2000000000;
        v144[0] = 0;
        v144[1] = v144;
        v145 = 0;
        v144[2] = 0x2000000000;
        v139[0] = MEMORY[0x1E0C809B0];
        v139[1] = 0x40000000;
        v140 = ___ZL43nw_http_capsule_framer_process_capsule_bodyP22nw_http_capsule_framerP11nw_protocolPb_block_invoke;
        v141 = &unk_1E14A3B00;
        v142 = &v146;
        v143 = v144;
        v11 = *v9;
        do
        {
          if (!v11)
            break;
          v12 = *(_QWORD *)(v11 + 32);
          v13 = v140((uint64_t)v139, (_DWORD *)v11);
          v11 = v12;
        }
        while ((v13 & 1) != 0);
        v14 = v94;
        v15 = *(_QWORD *)(v94 + 32);
        if (*(_QWORD *)(v94 + 136) > (unint64_t)*((unsigned int *)v147 + 6) && v15 != 0)
        {
          v17 = *(_QWORD *)(v15 + 24);
          if (v17)
          {
            if (*(_QWORD *)(v17 + 80))
            {
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = buf;
              if (!nw_protocol_get_input_frames(v15, v94, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, (uint64_t)buf))
              {
                v22 = 0;
                goto LABEL_44;
              }
              if (*(_QWORD *)buf)
              {
                **(_QWORD **)(v94 + 104) = *(_QWORD *)buf;
                v18 = *(_QWORD *)&buf[8];
                *(_QWORD *)(*(_QWORD *)buf + 40) = *(_QWORD *)(v94 + 104);
                *(_QWORD *)(v94 + 104) = v18;
              }
            }
          }
        }
        v120 = 0;
        v137[0] = 0;
        v137[1] = v137;
        v138 = 0;
        v137[2] = 0x2000000000;
        v133 = 0;
        v134 = &v133;
        v136 = 0;
        v135 = 0x2000000000;
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL43nw_http_capsule_framer_process_capsule_bodyP22nw_http_capsule_framerP11nw_protocolPb_block_invoke_2;
        v151 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E14A3B28;
        v152 = (void (*)(uint64_t))v137;
        v153 = &v133;
        *(_QWORD *)v154 = v9;
        *(_QWORD *)&v154[8] = &v120;
        v19 = *v9;
        do
        {
          if (!v19)
            break;
          v20 = *(_QWORD *)(v19 + 32);
          v21 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          v19 = v20;
        }
        while ((v21 & 1) != 0);
        v22 = *((_DWORD *)v134 + 6);
        _Block_object_dispose(&v133, 8);
        _Block_object_dispose(v137, 8);
        v14 = v94;
LABEL_44:
        _Block_object_dispose(v144, 8);
        _Block_object_dispose(&v146, 8);
        if (!v22)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v72 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            v74 = *(uint64_t (**)(uint64_t, uint64_t))(v14 + 136);
            v73 = *(_QWORD *)(v14 + 144);
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http_capsule_framer_read_capsule";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v73;
            *(_WORD *)&buf[22] = 2048;
            v151 = v74;
            _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_DEBUG, "%{public}s Could not find all capsule data for type %llx. Remaining length: %lld", buf, 0x20u);
          }
LABEL_142:
          _Block_object_dispose(&v129, 8);
          return;
        }
        if (v120)
        {
          _Block_object_dispose(&v129, 8);
          v28 = *(_QWORD *)(v14 + 144);
          if ((*(_BYTE *)(v14 + 548) & 2) == 0)
          {
            if (v8[1345])
            {
              v69 = __nwlog_obj();
              if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
              {
                v70 = *(_DWORD *)(v14 + 460);
                v71 = *(_QWORD *)(v14 + 128);
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "nw_webtransport_http2_handle_capsules";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v93;
                *(_WORD *)&buf[22] = 2080;
                v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
                LOWORD(v152) = 1024;
                *(_DWORD *)((char *)&v152 + 2) = v70;
                HIWORD(v152) = 2048;
                v153 = (uint64_t *)v28;
                *(_WORD *)v154 = 2048;
                *(_QWORD *)&v154[2] = v71;
                _os_log_impl(&dword_182FBE000, v69, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Webtransport session received capsule type 0x%llx length %llu", buf, 0x3Au);
              }
            }
          }
          if (v28 <= 16770303)
          {
            if (v28 > 16770047)
            {
              if ((unint64_t)(v28 - 16770048) >= 6)
                goto LABEL_83;
LABEL_80:
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v36 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_webtransport_http2_handle_capsules";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v28;
                v37 = v36;
                v38 = "%{public}s Unexpected capsule type %llu received";
                v39 = 22;
                goto LABEL_82;
              }
LABEL_83:
              handle = (char *)v94;
              goto LABEL_26;
            }
            if ((unint64_t)(v28 - 1) < 3 || v28 == -1)
              goto LABEL_80;
            if (v28)
              goto LABEL_83;
            v32 = *(_QWORD *)(v94 + 424);
            if (!v32 || *(_DWORD *)(v32 + 184) == 3)
            {
              v105[0] = MEMORY[0x1E0C809B0];
              v105[1] = 0x40000000;
              v106 = ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_2;
              v107 = &__block_descriptor_tmp_56_33655;
              v108 = v9;
              v33 = *(_QWORD *)(v94 + 112);
              do
              {
                if (!v33)
                  break;
                v34 = *(_QWORD *)(v33 + 32);
                v35 = ((uint64_t (*)(_QWORD *))v106)(v105);
                v33 = v34;
              }
              while ((v35 & 1) != 0);
              goto LABEL_83;
            }
            v100[0] = MEMORY[0x1E0C809B0];
            v100[1] = 0x40000000;
            v101 = ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_3;
            v102 = &__block_descriptor_tmp_57_33656;
            v103 = v9;
            v104 = v32;
            v55 = *(_QWORD *)(v94 + 112);
            do
            {
              if (!v55)
                break;
              v56 = *(_QWORD *)(v55 + 32);
              v57 = ((uint64_t (*)(_QWORD *))v101)(v100);
              v55 = v56;
            }
            while ((v57 & 1) != 0);
            v54 = (_QWORD *)v32;
LABEL_116:
            nw_protocol_input_available(v54, v94);
            goto LABEL_83;
          }
          if (v28 <= 420171064)
          {
            if ((unint64_t)(v28 - 16770304) >= 4)
            {
              if (v28 == 420171064)
              {
                v115[0] = MEMORY[0x1E0C809B0];
                v115[1] = 0x40000000;
                v116 = ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke;
                v117 = &__block_descriptor_tmp_53_33647;
                v118 = v9;
                v29 = *(_QWORD *)(v94 + 112);
                do
                {
                  if (!v29)
                    break;
                  v30 = *(_QWORD *)(v29 + 32);
                  v31 = ((uint64_t (*)(_QWORD *))v116)(v115);
                  v29 = v30;
                }
                while ((v31 & 1) != 0);
              }
              goto LABEL_83;
            }
            goto LABEL_80;
          }
          if ((unint64_t)(v28 - 420171065) < 2)
          {
            *(_QWORD *)type = -1;
            v40 = v94;
            if ((nw_http_capsule_framer_parse_vle_value((uint64_t)v9, v94, (uint64_t)type) & 1) != 0)
            {
              stream = nw_webtransport_session_get_stream(v94, *(uint64_t *)type);
              if (!stream)
                goto LABEL_83;
              v45 = stream;
              v139[0] = -1;
              if ((nw_http_capsule_framer_parse_vle_value((uint64_t)v9, v94, (uint64_t)v139) & 1) != 0)
              {
                if ((*(_BYTE *)(v45 + 276) & 0x10) == 0)
                {
                  log = __nwlog_obj();
                  if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
                  {
                    v46 = *(_QWORD *)(v45 + 88);
                    if (v46)
                      v47 = *(_DWORD *)(v46 + 460);
                    else
                      v47 = -1;
                    v65 = *(uint64_t **)(v45 + 64);
                    *(_DWORD *)buf = 136448002;
                    *(_QWORD *)&buf[4] = "nw_webtransport_http2_handle_capsules";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v45 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
                    LOWORD(v152) = 1024;
                    *(_DWORD *)((char *)&v152 + 2) = v47;
                    HIWORD(v152) = 2048;
                    v153 = v65;
                    *(_WORD *)v154 = 2048;
                    *(_QWORD *)&v154[2] = v28;
                    *(_WORD *)&v154[10] = 2048;
                    *(_QWORD *)&v154[12] = v65;
                    v155 = 2048;
                    v156 = v139[0];
                    _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Received 0x%llx capsule for stream ID %llu with error code %llu", buf, 0x4Eu);
                  }
                }
                nw_protocol_webtransport_stream_error((nw_protocol *)v45, (nw_protocol *)v94);
                nw_protocol_webtransport_stream_disconnect((nw_protocol *)v45, v66);
                goto LABEL_83;
              }
              if ((*(_BYTE *)(v94 + 548) & 2) != 0)
                goto LABEL_83;
              v58 = __nwlog_obj();
              if (!os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                goto LABEL_83;
              v59 = *(_DWORD *)(v94 + 460);
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_webtransport_http2_handle_capsules";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v93;
              *(_WORD *)&buf[22] = 2080;
              v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
              LOWORD(v152) = 1024;
              *(_DWORD *)((char *)&v152 + 2) = v59;
              HIWORD(v152) = 2048;
              v153 = (uint64_t *)v28;
              v37 = v58;
              v38 = "%{public}s %{public}s%s<i%u> Failed to parse error code from capsule 0x%llx correctly";
              v39 = 48;
              goto LABEL_82;
            }
            if ((*(_BYTE *)(v94 + 548) & 2) != 0)
              goto LABEL_83;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_83;
          }
          else
          {
            if ((unint64_t)(v28 - 420171067) >= 2)
              goto LABEL_83;
            *(_QWORD *)type = -1;
            v40 = v94;
            if ((nw_http_capsule_framer_parse_vle_value((uint64_t)v9, v94, (uint64_t)type) & 1) != 0)
            {
              if (*(_QWORD *)type >> 60)
              {
                LOBYTE(v41) = *(_BYTE *)(v94 + 548);
                goto LABEL_89;
              }
              v50 = nw_webtransport_session_get_stream(v94, *(uint64_t *)type);
              if (v50)
              {
LABEL_106:
                if (*(_DWORD *)(v50 + 184) == 3)
                  goto LABEL_83;
                v109[0] = MEMORY[0x1E0C809B0];
                v109[1] = 0x40000000;
                v110 = ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_54;
                v111 = &__block_descriptor_tmp_55_33654;
                v114 = v28 == 420171068;
                v112 = v9;
                v113 = v50;
                v51 = *(_QWORD *)(v40 + 112);
                do
                {
                  if (!v51)
                    break;
                  v52 = *(_QWORD *)(v51 + 32);
                  v53 = ((uint64_t (*)(_QWORD *))v110)(v109);
                  v51 = v52;
                }
                while ((v53 & 1) != 0);
                v54 = (_QWORD *)v50;
                if (v28 == 420171068)
                {
                  nw_protocol_input_finished((_QWORD *)v50, v94);
                  goto LABEL_83;
                }
                goto LABEL_116;
              }
              v60 = *(_QWORD *)type;
              v41 = *(unsigned __int8 *)(v94 + 548);
              if (*(_QWORD *)type >> 60 || ((*(_DWORD *)type ^ v41) & 1) == 0)
              {
LABEL_89:
                if ((v41 & 2) != 0)
                  goto LABEL_83;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v42 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  goto LABEL_83;
                v43 = *(_DWORD *)(v94 + 460);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_create_incoming_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v93;
                *(_WORD *)&buf[22] = 2080;
                v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
                LOWORD(v152) = 1024;
                *(_DWORD *)((char *)&v152 + 2) = v43;
                v37 = v42;
                v38 = "%{public}s %{public}s%s<i%u> Invalid incoming stream ID";
                v39 = 38;
              }
              else
              {
                v61 = *(_QWORD ***)(v94 + 400);
                if (v61)
                {
                  v62 = *v61;
                  if (v62)
                  {
                    if (*v62)
                    {
                      v63 = nw_parameters_copy(*(nw_parameters_t *)(v94 + 344));
                      *(_BYTE *)(v94 + 548) |= 0x20u;
                      *(_QWORD *)(v94 + 176) = v60;
                      v64 = (***(uint64_t (****)(_QWORD, _QWORD, nw_parameters_t))(v94 + 400))(*(_QWORD *)(v94 + 400), *(_QWORD *)(v94 + 360), v63);
                      *(_QWORD *)(v94 + 176) = -1;
                      *(_BYTE *)(v94 + 548) &= ~0x20u;
                      if (v64)
                        v50 = nw_webtransport_session_get_stream(v94, v60);
                      else
                        v50 = 0;
                      if (v63)
                        os_release(v63);
                      v40 = v94;
                      v8 = (_BYTE *)&unk_1ECD84000;
                      if (!v50)
                        goto LABEL_83;
                      goto LABEL_106;
                    }
                  }
                }
                v8 = (_BYTE *)&unk_1ECD84000;
                if ((v41 & 2) != 0)
                  goto LABEL_83;
                v67 = __nwlog_obj();
                if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                  goto LABEL_83;
                v68 = *(_DWORD *)(v94 + 460);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_create_incoming_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v93;
                *(_WORD *)&buf[22] = 2080;
                v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
                LOWORD(v152) = 1024;
                *(_DWORD *)((char *)&v152 + 2) = v68;
                v37 = v67;
                v38 = "%{public}s %{public}s%s<i%u> Listen handler not setup to accept inbound stream";
                v39 = 38;
              }
LABEL_82:
              _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_ERROR, v38, buf, v39);
              goto LABEL_83;
            }
            if ((*(_BYTE *)(v94 + 548) & 2) != 0)
              goto LABEL_83;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v48 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_83;
          }
          v49 = *(_DWORD *)(v40 + 460);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_http2_handle_capsules";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v93;
          *(_WORD *)&buf[22] = 2080;
          v151 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v152) = 1024;
          *(_DWORD *)((char *)&v152 + 2) = v49;
          HIWORD(v152) = 2048;
          v153 = (uint64_t *)v28;
          v37 = v48;
          v38 = "%{public}s %{public}s%s<i%u> Failed to parse stream ID from capsule 0x%llx correctly.";
          v39 = 48;
          goto LABEL_82;
        }
      }
    }
  }
}

void nw_protocol_webtransport_session_output_available(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  NSObject *v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  unsigned __int8 *v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  NSObject *v17;
  int v18;
  char *backtrace_string;
  _BOOL4 v20;
  char *v21;
  _BOOL4 v22;
  _QWORD v23[5];
  char v24;
  os_log_type_t type[8];
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t, void *);
  void *v28;
  char *v29;
  _BYTE buf[24];
  const char *v31;
  char *v32;
  _BOOL8 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
    v13 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v13, type, &v24))
      goto LABEL_49;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (!os_log_type_enabled(v14, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
      v16 = "%{public}s called with null protocol";
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type[0];
      v20 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_49:
        if (!v13)
          return;
LABEL_50:
        free(v13);
        return;
      }
      if (!v20)
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
      v16 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v14 = __nwlog_obj();
      v15 = type[0];
      if (!os_log_type_enabled(v14, type[0]))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_48:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_49;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if ((handle[548] & 2) == 0)
    {
      if (gLogDatapath)
      {
        v17 = __nwlog_obj();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          v18 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v31 = " ";
          LOWORD(v32) = 1024;
          *(_DWORD *)((char *)&v32 + 2) = v18;
          _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    if (*((_DWORD *)handle + 111) != 4 && (handle[548] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        v5 = *((_DWORD *)handle + 115);
        v6 = *((_DWORD *)handle + 111);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v31 = " ";
        LOWORD(v32) = 1024;
        *(_DWORD *)((char *)&v32 + 2) = v5;
        HIWORD(v32) = 1024;
        LODWORD(v33) = v6;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> output_available called in state %d", buf, 0x2Cu);
      }
    }
    if (!*((_DWORD *)handle + 112))
    {
      v7 = *((_QWORD *)handle + 24);
      v8 = MEMORY[0x1E0C809B0];
      if (v7)
      {
        if (*(_QWORD *)(v7 + 16) != *(_QWORD *)(v7 + 24))
        {
          v9 = nw_array_create();
          v10 = (unsigned __int8 *)*((_QWORD *)handle + 24);
          *(_QWORD *)buf = v8;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke;
          v31 = (const char *)&__block_descriptor_tmp_37_33615;
          v32 = handle;
          v33 = v9;
          nw_array_apply(v10, (uint64_t)buf);
          *(_QWORD *)type = v8;
          v26 = 0x40000000;
          v27 = ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_38;
          v28 = &__block_descriptor_tmp_39_33616;
          v29 = handle;
          nw_array_apply((unsigned __int8 *)v9, (uint64_t)type);
          if (v9)
            os_release((void *)v9);
        }
      }
      v11 = (char *)*((_QWORD *)handle + 23);
      if (v11)
      {
        v23[0] = v8;
        v23[1] = 0x40000000;
        v23[2] = ___ZL49nw_protocol_webtransport_session_output_availableP11nw_protocolS0__block_invoke;
        v23[3] = &__block_descriptor_tmp_58_33617;
        v23[4] = a1;
        nw_hash_table_apply(v11, (uint64_t)v23);
      }
      v12 = (_QWORD *)*((_QWORD *)handle + 53);
      if (v12)
        nw_protocol_output_available(v12, (uint64_t)a1);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
  v13 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v24 = 0;
  if (!__nwlog_fault(v13, type, &v24))
    goto LABEL_49;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    v14 = __nwlog_obj();
    v15 = type[0];
    if (!os_log_type_enabled(v14, type[0]))
      goto LABEL_49;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
    v16 = "%{public}s called with null webtransport_session";
    goto LABEL_48;
  }
  if (!v24)
  {
    v14 = __nwlog_obj();
    v15 = type[0];
    if (!os_log_type_enabled(v14, type[0]))
      goto LABEL_49;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
    v16 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_48;
  }
  v21 = (char *)__nw_create_backtrace_string();
  v14 = __nwlog_obj();
  v15 = type[0];
  v22 = os_log_type_enabled(v14, type[0]);
  if (!v21)
  {
    if (!v22)
      goto LABEL_49;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
    v16 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_48;
  }
  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_output_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v21;
    _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v21);
  if (v13)
    goto LABEL_50;
}

uint64_t nw_protocol_webtransport_session_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _DWORD *handle;
  NSObject *v7;
  int v8;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_input_frames";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_webtransport_session_get_input_frames";
      v13 = "%{public}s called with null protocol";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_protocol_webtransport_session_get_input_frames";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_35:
        if (!v10)
          return 0;
LABEL_36:
        free(v10);
        return 0;
      }
      if (!v15)
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_webtransport_session_get_input_frames";
      v13 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_webtransport_session_get_input_frames";
      v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_34:
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_35;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        v21 = "nw_protocol_webtransport_session_get_input_frames";
        v22 = 2082;
        v23 = (char *)(handle + 116);
        v24 = 2080;
        v25 = " ";
        v26 = 1024;
        v27 = v8;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> called, ignoring", buf, 0x26u);
      }
    }
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_protocol_webtransport_session_get_input_frames";
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v10, &type, &v18))
    goto LABEL_35;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_input_frames";
    v13 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }
  if (!v18)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_input_frames";
    v13 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }
  v16 = (char *)__nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v12 = type;
  v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17)
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_input_frames";
    v13 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "nw_protocol_webtransport_session_get_input_frames";
    v22 = 2082;
    v23 = v16;
    _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v10)
    goto LABEL_36;
  return 0;
}

uint64_t nw_protocol_webtransport_session_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _DWORD *handle;
  NSObject *v7;
  int v8;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_output_frames";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_webtransport_session_get_output_frames";
      v13 = "%{public}s called with null protocol";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_protocol_webtransport_session_get_output_frames";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_35:
        if (!v10)
          return 0;
LABEL_36:
        free(v10);
        return 0;
      }
      if (!v15)
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_webtransport_session_get_output_frames";
      v13 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_protocol_webtransport_session_get_output_frames";
      v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_34:
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_35;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        v21 = "nw_protocol_webtransport_session_get_output_frames";
        v22 = 2082;
        v23 = (char *)(handle + 116);
        v24 = 2080;
        v25 = " ";
        v26 = 1024;
        v27 = v8;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> called, ignoring", buf, 0x26u);
      }
    }
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_protocol_webtransport_session_get_output_frames";
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v10, &type, &v18))
    goto LABEL_35;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_output_frames";
    v13 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }
  if (!v18)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_output_frames";
    v13 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }
  v16 = (char *)__nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v12 = type;
  v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17)
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v21 = "nw_protocol_webtransport_session_get_output_frames";
    v13 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "nw_protocol_webtransport_session_get_output_frames";
    v22 = 2082;
    v23 = v16;
    _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v10)
    goto LABEL_36;
  return 0;
}

uint64_t nw_protocol_webtransport_session_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _DWORD *handle;
  NSObject *v3;
  int v4;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_webtransport_session_finalize_output_frames";
      v9 = "%{public}s called with null protocol";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_webtransport_session_finalize_output_frames";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_35:
        if (!v6)
          return 0;
LABEL_36:
        free(v6);
        return 0;
      }
      if (!v11)
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_webtransport_session_finalize_output_frames";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_webtransport_session_finalize_output_frames";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_34:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_35;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v4 = handle[115];
        *(_DWORD *)buf = 136446978;
        v17 = "nw_protocol_webtransport_session_finalize_output_frames";
        v18 = 2082;
        v19 = (char *)(handle + 116);
        v20 = 2080;
        v21 = " ";
        v22 = 1024;
        v23 = v4;
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> called, ignoring", buf, 0x26u);
      }
    }
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_webtransport_session_finalize_output_frames";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14))
    goto LABEL_35;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    v9 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }
  if (!v14)
  {
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    v9 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v7 = __nwlog_obj();
  v8 = type;
  v13 = os_log_type_enabled(v7, type);
  if (!v12)
  {
    if (!v13)
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    v9 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v17 = "nw_protocol_webtransport_session_finalize_output_frames";
    v18 = 2082;
    v19 = v12;
    _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v6)
    goto LABEL_36;
  return 0;
}

uint64_t nw_protocol_webtransport_session_get_parameters(nw_protocol *a1)
{
  _QWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
      return handle[43];
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_webtransport_session_get_parameters";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_parameters";
        v6 = "%{public}s called with null webtransport_session";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_parameters";
        v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_parameters";
        v6 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_webtransport_session_get_parameters";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_webtransport_session_get_parameters";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_parameters";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_parameters";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_webtransport_session_get_parameters";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_webtransport_session_get_parameters";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_protocol_webtransport_session_get_remote_endpoint(nw_protocol *a1)
{
  _QWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
      return handle[45];
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        v6 = "%{public}s called with null webtransport_session";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        v6 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_webtransport_session_get_remote_endpoint";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3)
    free(v3);
  return 0;
}

void nw_protocol_webtransport_session_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  int v12;
  char *backtrace_string;
  _BOOL4 v14;
  char *v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_session_notify";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v7, &type, &v17))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_webtransport_session_notify";
      v10 = "%{public}s called with null protocol";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_protocol_webtransport_session_notify";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v7)
          return;
LABEL_38:
        free(v7);
        return;
      }
      if (!v14)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_webtransport_session_notify";
      v10 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_webtransport_session_notify";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_37;
  }
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(v4 + 548) & 2) == 0 && gLogDatapath)
    {
      v11 = __nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v12 = *(_DWORD *)(v4 + 460);
        *(_DWORD *)buf = 136446978;
        v20 = "nw_protocol_webtransport_session_notify";
        v21 = 2082;
        v22 = (char *)(v4 + 464);
        v23 = 2080;
        v24 = " ";
        v25 = 1024;
        v26 = v12;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    nw_protocol_common_notify(a1, a2, a3);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_webtransport_session_notify";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v7, &type, &v17))
    goto LABEL_37;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_session_notify";
    v10 = "%{public}s called with null webtransport_session";
    goto LABEL_36;
  }
  if (!v17)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_session_notify";
    v10 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_36;
  }
  v15 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v16 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (!v16)
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_session_notify";
    v10 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_36;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v20 = "nw_protocol_webtransport_session_notify";
    v21 = 2082;
    v22 = v15;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v15);
  if (v7)
    goto LABEL_38;
}

void nw_protocol_webtransport_session_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  NSObject *v7;
  int v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_input_finished";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v3, &type, &v13))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_session_input_finished";
      v6 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_webtransport_session_input_finished";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v3)
          return;
LABEL_37:
        free(v3);
        return;
      }
      if (!v10)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_session_input_finished";
      v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_session_input_finished";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_36;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0 && gLogDatapath)
    {
      v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        v16 = "nw_protocol_webtransport_session_input_finished";
        v17 = 2082;
        v18 = (char *)(handle + 116);
        v19 = 2080;
        v20 = " ";
        v21 = 1024;
        v22 = v8;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_webtransport_session_input_finished";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v3, &type, &v13))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_input_finished";
    v6 = "%{public}s called with null webtransport_session";
    goto LABEL_35;
  }
  if (!v13)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_input_finished";
    v6 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_35;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v12 = os_log_type_enabled(v4, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_input_finished";
    v6 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_35;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_protocol_webtransport_session_input_finished";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v3)
    goto LABEL_37;
}

void nw_protocol_webtransport_session_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  _DWORD *handle;
  NSObject *v3;
  int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_output_finished";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_session_output_finished";
      v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_webtransport_session_output_finished";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_35:
        if (!v5)
          return;
LABEL_36:
        free(v5);
        return;
      }
      if (!v10)
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_session_output_finished";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_session_output_finished";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_34:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_35;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v4 = handle[115];
        *(_DWORD *)buf = 136446978;
        v16 = "nw_protocol_webtransport_session_output_finished";
        v17 = 2082;
        v18 = (char *)(handle + 116);
        v19 = 2080;
        v20 = " ";
        v21 = 1024;
        v22 = v4;
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_webtransport_session_output_finished";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13))
    goto LABEL_35;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_output_finished";
    v8 = "%{public}s called with null webtransport_session";
    goto LABEL_34;
  }
  if (!v13)
  {
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_output_finished";
    v8 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    goto LABEL_34;
  }
  v11 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  v7 = type;
  v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12)
      goto LABEL_35;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_session_output_finished";
    v8 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_34;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    v16 = "nw_protocol_webtransport_session_output_finished";
    v17 = 2082;
    v18 = v11;
    _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5)
    goto LABEL_36;
}

uint64_t nw_protocol_webtransport_session_copy_info(uint64_t a1, int a2)
{
  uint64_t v3;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  int v11;
  char *backtrace_string;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 40);
    if (v3)
    {
      if ((*(_BYTE *)(v3 + 548) & 2) == 0 && gLogDatapath)
      {
        v10 = __nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v11 = *(_DWORD *)(v3 + 460);
          *(_DWORD *)buf = 136446978;
          v19 = "nw_protocol_webtransport_session_copy_info";
          v20 = 2082;
          v21 = (char *)(v3 + 464);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v11;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
      return nw_protocol_common_copy_info(a1, a2);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_session_copy_info";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v6, &type, &v16))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_webtransport_session_copy_info";
        v9 = "%{public}s called with null webtransport_session";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (!v16)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_webtransport_session_copy_info";
        v9 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v15 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_webtransport_session_copy_info";
        v9 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_webtransport_session_copy_info";
      v20 = 2082;
      v21 = backtrace_string;
      v14 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_session_copy_info";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v6, &type, &v16))
    goto LABEL_36;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v16)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_webtransport_session_copy_info";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_webtransport_session_copy_info";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_webtransport_session_copy_info";
      v20 = 2082;
      v21 = backtrace_string;
      v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_182FBE000, v7, v8, v14, buf, 0x16u);
    }
LABEL_26:
    free(backtrace_string);
    goto LABEL_36;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_session_copy_info";
    v9 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
  }
LABEL_36:
  if (v6)
    free(v6);
  return 0;
}

BOOL nw_protocol_webtransport_session_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  _DWORD *handle;
  NSObject *v6;
  _BOOL8 result;
  int v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  NSObject *v13;
  int v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  _BOOL4 v18;
  NSObject *v19;
  int v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  nw_listen_protocol *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_session_add_listen_handler";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v9, &type, &v21))
      goto LABEL_46;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        v10 = __nwlog_obj();
        v11 = type;
        if (!os_log_type_enabled(v10, type))
          goto LABEL_46;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_webtransport_session_add_listen_handler";
        v12 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_45;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v16)
          goto LABEL_46;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_webtransport_session_add_listen_handler";
        v12 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_45;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_webtransport_session_add_listen_handler";
        v25 = 2082;
        v26 = backtrace_string;
        v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v10, v11, v17, buf, 0x16u);
      }
LABEL_33:
      free(backtrace_string);
      goto LABEL_46;
    }
    v10 = __nwlog_obj();
    v11 = type;
    if (!os_log_type_enabled(v10, type))
      goto LABEL_46;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_session_add_listen_handler";
    v12 = "%{public}s called with null protocol";
LABEL_45:
    _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
LABEL_46:
    if (v9)
      free(v9);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_session_add_listen_handler";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v9, &type, &v21))
      goto LABEL_46;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_webtransport_session_add_listen_handler";
      v12 = "%{public}s called with null webtransport_session";
      goto LABEL_45;
    }
    if (!v21)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_46;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_webtransport_session_add_listen_handler";
      v12 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v18 = os_log_type_enabled(v10, type);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_webtransport_session_add_listen_handler";
        v25 = 2082;
        v26 = backtrace_string;
        v17 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v18)
      goto LABEL_46;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_session_add_listen_handler";
    v12 = "%{public}s called with null webtransport_session, no backtrace";
    goto LABEL_45;
  }
  if ((handle[137] & 2) == 0)
  {
    if (gLogDatapath)
    {
      v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v14 = handle[115];
        *(_DWORD *)buf = 136446978;
        v24 = "nw_protocol_webtransport_session_add_listen_handler";
        v25 = 2082;
        v26 = (char *)(handle + 116);
        v27 = 2080;
        v28 = " ";
        v29 = 1024;
        v30 = v14;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
  }
  if (*((_QWORD *)handle + 50))
  {
    if ((handle[137] & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        v8 = handle[115];
        *(_DWORD *)buf = 136446978;
        v24 = "nw_protocol_webtransport_session_add_listen_handler";
        v25 = 2082;
        v26 = (char *)(handle + 116);
        v27 = 2080;
        v28 = " ";
        v29 = 1024;
        v30 = v8;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Already have a listen handler, ignoring add", buf, 0x26u);
        return 0;
      }
      return result;
    }
    return 0;
  }
  *((_QWORD *)handle + 50) = a2;
  a2->protocol_handler = (nw_protocol *)handle;
  if ((a3 & 1) != 0)
  {
    *((_BYTE *)handle + 548) |= 8u;
    nw_protocol_remove_instance((uint64_t)handle);
  }
  result = 1;
  if ((handle[137] & 2) == 0 && gLogDatapath)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      v20 = handle[115];
      *(_DWORD *)buf = 136447234;
      v24 = "nw_protocol_webtransport_session_add_listen_handler";
      v25 = 2082;
      v26 = (char *)(handle + 116);
      v27 = 2080;
      v28 = " ";
      v29 = 1024;
      v30 = v20;
      v31 = 2048;
      v32 = a2;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> added protocol listen handler %p", buf, 0x30u);
    }
    return 1;
  }
  return result;
}

uint64_t nw_protocol_webtransport_session_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  char *handle;
  int v4;
  uint64_t v6;
  int v7;
  const char *v8;
  NSObject *v9;
  os_log_type_t v10;
  int v11;
  uint64_t v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  int v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  int v36;
  char *backtrace_string;
  _BOOL4 v38;
  const char *v39;
  _BOOL4 v40;
  NSObject *v41;
  int v42;
  char v43;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v46;
  _BYTE v47[6];
  __int16 v48;
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if ((handle[548] & 2) == 0)
      {
        if (gLogDatapath)
        {
          v33 = __nwlog_obj();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          {
            v34 = *((_DWORD *)handle + 115);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 464;
            *(_WORD *)&buf[22] = 2080;
            v46 = " ";
            *(_WORD *)v47 = 1024;
            *(_DWORD *)&v47[2] = v34;
            _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }
      v4 = (handle[548] >> 1) & 1;
      if (!gLogDatapath)
        LOBYTE(v4) = 1;
      if (*((nw_listen_protocol **)handle + 50) != a2)
      {
        if ((v4 & 1) != 0)
          return 1;
        v35 = __nwlog_obj();
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
          return 1;
        v36 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v46 = " ";
        *(_WORD *)v47 = 1024;
        *(_DWORD *)&v47[2] = v36;
        v8 = "%{public}s %{public}s%s<i%u> ignoring request to remove webtransport listen handler, does not match our handler";
        v9 = v35;
        v10 = OS_LOG_TYPE_DEBUG;
LABEL_15:
        _os_log_impl(&dword_182FBE000, v9, v10, v8, buf, 0x26u);
        return 1;
      }
      if ((v4 & 1) == 0)
      {
        v41 = __nwlog_obj();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          v42 = *((_DWORD *)handle + 115);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 464;
          *(_WORD *)&buf[22] = 2080;
          v46 = " ";
          *(_WORD *)v47 = 1024;
          *(_DWORD *)&v47[2] = v42;
          _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removing protocol listen handler", buf, 0x26u);
        }
      }
      handle[548] |= 8u;
      *((_QWORD *)handle + 50) = 0;
      a2->protocol_handler = 0;
      if (*((_DWORD *)handle + 111) == 5)
      {
        if ((handle[548] & 2) != 0)
          return 1;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          return 1;
        v7 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v46 = " ";
        *(_WORD *)v47 = 1024;
        *(_DWORD *)&v47[2] = v7;
        v8 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
        v9 = v6;
        v10 = OS_LOG_TYPE_INFO;
        goto LABEL_15;
      }
      v11 = *((_DWORD *)handle + 113);
      if (v11)
      {
        if ((handle[548] & 2) != 0)
          goto LABEL_24;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          goto LABEL_24;
        v13 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v46 = " ";
        *(_WORD *)v47 = 1024;
        *(_DWORD *)&v47[2] = v13;
        v48 = 1024;
        v49 = v11;
        v14 = "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d";
        v15 = v12;
        v16 = 44;
      }
      else
      {
        if ((handle[548] & 2) != 0)
          goto LABEL_24;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v17 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          goto LABEL_24;
        v18 = *((_DWORD *)handle + 115);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 464;
        *(_WORD *)&buf[22] = 2080;
        v46 = " ";
        *(_WORD *)v47 = 1024;
        *(_DWORD *)&v47[2] = v18;
        v14 = "%{public}s %{public}s%s<i%u> Closing webtransport session without error";
        v15 = v17;
        v16 = 38;
      }
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_INFO, v14, buf, v16);
LABEL_24:
      *((_DWORD *)handle + 111) = 5;
      v19 = (char *)*((_QWORD *)handle + 23);
      if (v19)
      {
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
        v46 = (const char *)&__block_descriptor_tmp_22_33428;
        *(_DWORD *)v47 = v11;
        nw_hash_table_apply(v19, (uint64_t)buf);
      }
      v20 = *((_QWORD *)handle + 53);
      if (v20)
      {
        v21 = *(_QWORD **)(v20 + 48);
        if (v11)
          nw_protocol_error(*(_QWORD **)(v20 + 48), *((_QWORD *)handle + 53));
        nw_protocol_disconnected(v21, v20);
      }
      v22 = *((_QWORD *)handle + 41);
      if (v22)
      {
        if (v11)
        {
          do
          {
            v23 = *(_QWORD *)(v22 + 112);
            v24 = *(_QWORD **)(v22 + 48);
            nw_protocol_error(v24, v22);
            v25 = v22;
            v22 = v23;
            nw_protocol_disconnected(v24, v25);
          }
          while (v23);
        }
        else
        {
          do
          {
            v26 = *(_QWORD *)(v22 + 112);
            nw_protocol_disconnected(*(_QWORD **)(v22 + 48), v22);
            v22 = v26;
          }
          while (v26);
        }
      }
      v27 = *((_QWORD *)handle + 52);
      if (v27)
      {
        v28 = *(_QWORD **)(v27 + 48);
        if (v11)
          nw_protocol_error(*(_QWORD **)(v27 + 48), *((_QWORD *)handle + 52));
        nw_protocol_disconnected(v28, v27);
      }
      if (*((_QWORD *)handle + 4))
      {
        nw_protocol_remove_instance((uint64_t)handle);
        nw_protocol_disconnect(*((_QWORD **)handle + 4), (uint64_t)handle);
      }
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (!__nwlog_fault(v29, &type, &v43))
      goto LABEL_74;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        v32 = "%{public}s called with null webtransport_session";
        goto LABEL_73;
      }
      goto LABEL_74;
    }
    if (!v43)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        v32 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_73;
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v31 = type;
    v40 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        v32 = "%{public}s called with null webtransport_session, no backtrace";
        goto LABEL_73;
      }
      goto LABEL_74;
    }
    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v39 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_61;
    }
    goto LABEL_62;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
  v29 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v43 = 0;
  if (!__nwlog_fault(v29, &type, &v43))
    goto LABEL_74;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v43)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        v32 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_73;
      }
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v31 = type;
    v38 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
        v32 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_73;
      }
      goto LABEL_74;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v39 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_61:
      _os_log_impl(&dword_182FBE000, v30, v31, v39, buf, 0x16u);
    }
LABEL_62:
    free(backtrace_string);
    goto LABEL_74;
  }
  v30 = __nwlog_obj();
  v31 = type;
  if (os_log_type_enabled(v30, type))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_session_remove_listen_handler";
    v32 = "%{public}s called with null protocol";
LABEL_73:
    _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0xCu);
  }
LABEL_74:
  if (v29)
    free(v29);
  return 0;
}

BOOL ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  int v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  int v25;
  int v26;
  _BOOL4 output_frames;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _QWORD v32[2];
  uint64_t (*v33)(_QWORD *);
  void *v34;
  _QWORD *v35;
  uint64_t *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t *v45;
  _QWORD v46[3];
  char v47;
  uint64_t v48[2];
  _QWORD v49[3];
  char v50;
  _QWORD v51[3];
  unint64_t v52;
  _QWORD v53[3];
  char v54;
  _QWORD v55[3];
  unint64_t v56;

  v55[0] = 0;
  v55[1] = v55;
  v55[2] = 0x2000000000;
  v56 = 0;
  v53[0] = 0;
  v53[1] = v53;
  v53[2] = 0x2000000000;
  v5 = a3[1];
  if (v5 >> 62)
  {
    v15 = 0;
  }
  else
  {
    v6 = v5 >> 14;
    v7 = bswap64(v5 | 0xC000000000000000);
    v8 = bswap32(v5 | 0x80000000);
    if (v5 >> 30)
      v9 = v7;
    else
      v9 = v8;
    if (v5 >> 30)
      v10 = 8;
    else
      v10 = 4;
    v11 = bswap32(v5 | 0x4000) >> 16;
    v12 = v6 == 0;
    if (v6)
      v13 = v9;
    else
      v13 = v11;
    if (v12)
      v14 = 2;
    else
      v14 = v10;
    if (v5 >= 0x40)
    {
      v15 = v14;
    }
    else
    {
      v13 = a3[1];
      v15 = 1;
    }
    v56 = v13;
  }
  v54 = v15;
  v51[0] = 0;
  v51[1] = v51;
  v51[2] = 0x2000000000;
  v52 = 0;
  v49[0] = 0;
  v49[1] = v49;
  v49[2] = 0x2000000000;
  v16 = a3[2];
  if (v16 >> 62)
  {
    v26 = 0;
  }
  else
  {
    v17 = v16 >> 14;
    v18 = bswap64(v16 | 0xC000000000000000);
    v19 = bswap32(v16 | 0x80000000);
    if (v16 >> 30)
      v20 = v18;
    else
      v20 = v19;
    if (v16 >> 30)
      v21 = 8;
    else
      v21 = 4;
    v22 = bswap32(v16 | 0x4000) >> 16;
    v23 = v17 == 0;
    if (v17)
      v24 = v20;
    else
      v24 = v22;
    if (v23)
      v25 = 2;
    else
      v25 = v21;
    if (v16 >= 0x40)
    {
      v26 = v25;
    }
    else
    {
      v24 = a3[2];
      v26 = 1;
    }
    v52 = v24;
  }
  v50 = v26;
  v48[0] = 0;
  v48[1] = (uint64_t)v48;
  output_frames = nw_http_capsule_framer_get_output_frames(*(_QWORD *)(a1 + 32) + 96, *(_QWORD *)(a1 + 32), *a3, v26 + v15, v26 + v15, 1, v48);
  if (output_frames)
  {
    v46[0] = 0;
    v46[1] = v46;
    v46[2] = 0x2000000000;
    v47 = 0;
    v42 = 0;
    v43 = &v42;
    v44 = 0x2000000000;
    v45 = v48;
    v32[0] = MEMORY[0x1E0C809B0];
    v32[1] = 0x40000000;
    v33 = (uint64_t (*)(_QWORD *))___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_2;
    v34 = &unk_1E14A0590;
    v35 = v46;
    v36 = &v42;
    v41 = *(_QWORD *)(a1 + 32);
    v37 = v55;
    v38 = v53;
    v39 = v51;
    v40 = v49;
    v28 = v48[0];
    do
    {
      if (!v28)
        break;
      v29 = *(_QWORD *)(v28 + 32);
      v30 = v33(v32);
      v28 = v29;
    }
    while ((v30 & 1) != 0);
    nw_http_capsule_framer_finalize_output_frames(*(_QWORD *)(a1 + 32) + 96, *(_QWORD *)(a1 + 32), *a3, (uint64_t *)v43[3]);
    nw_array_append(*(_QWORD *)(a1 + 40), a3);
    _Block_object_dispose(&v42, 8);
    _Block_object_dispose(v46, 8);
  }
  _Block_object_dispose(v49, 8);
  _Block_object_dispose(v51, 8);
  _Block_object_dispose(v53, 8);
  _Block_object_dispose(v55, 8);
  return output_frames;
}

uint64_t ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_38(uint64_t a1, uint64_t a2, void *a3)
{
  nw_array_remove_object(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 192), (uint64_t)a3);
  if (a3)
    free(a3);
  return 1;
}

uint64_t ___ZL49nw_protocol_webtransport_session_output_availableP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *object;

  object = (_QWORD *)nw_hash_node_get_object(a2);
  nw_protocol_output_available(object, *(_QWORD *)(a1 + 32));
  return 1;
}

uint64_t ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_2(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  uint64_t v7;
  NSObject *v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  BOOL v13;
  int v14;
  int v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    nw_frame_finalize(a2);
    v4 = *(_QWORD *)(a2 + 32);
    v5 = *(_QWORD **)(a2 + 40);
    if (v4)
    {
      *(_QWORD *)(v4 + 40) = v5;
      v5 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) + 8) = v5;
    }
    *v5 = v4;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    v7 = a1[10];
    if (!v7 || (*(_BYTE *)(v7 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v9 = __nwlog_obj();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          v10 = a1[10];
          v11 = (const char *)(v10 + 464);
          v12 = "";
          v13 = v10 == 0;
          v14 = *(_DWORD *)(v10 + 460);
          if (v13)
            v11 = "";
          v16 = "nw_webtransport_http2_send_pending_control_capsules_block_invoke_2";
          v17 = 2082;
          v15 = 136446978;
          if (!v13)
            v12 = " ";
          v18 = v11;
          v19 = 2080;
          v20 = v12;
          v21 = 1024;
          v22 = v14;
          _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Dropping unneeded output frame", (uint8_t *)&v15, 0x26u);
        }
      }
    }
  }
  else
  {
    v15 = 0;
    v6 = (char *)nw_frame_unclaimed_bytes(a2, &v15);
    memcpy(v6, (const void *)(*(_QWORD *)(a1[6] + 8) + 24), *(unsigned __int8 *)(*(_QWORD *)(a1[7] + 8) + 24));
    memcpy(&v6[*(unsigned __int8 *)(*(_QWORD *)(a1[7] + 8) + 24)], (const void *)(*(_QWORD *)(a1[8] + 8) + 24), *(unsigned __int8 *)(*(_QWORD *)(a1[9] + 8) + 24));
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
  }
  return 1;
}

uint64_t __Block_byref_object_copy__50(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(result + 48) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(_QWORD *)(a2 + 40) = 0;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__51(uint64_t a1)
{
  void *v2;

  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    v2 = *(void **)(a1 + 40);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

uint64_t ___ZL38nw_webtransport_session_http_get_inputP23nw_webtransport_session_block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  int v9;
  BOOL v10;
  int v11;
  void *v12;
  uint64_t v13;
  void *v14;
  int v15;
  id v16;
  id v17;
  int status_code;
  uint64_t v19;
  int v20;
  int v21;
  const char *v22;
  NSObject *v23;
  os_log_type_t v24;
  uint32_t v25;
  NSObject *v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  BOOL v30;
  int v31;
  void *well_known;
  id *metadata_for_response;
  uint64_t v34;
  int output_frames;
  uint64_t v36;
  uint64_t v37;
  char v38;
  char v39;
  uint64_t v40;
  int v41;
  int v42;
  const char *v43;
  NSObject *v44;
  os_log_type_t v45;
  uint32_t v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  NSObject *v51;
  int v52;
  char *v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  _QWORD *v60;
  NSObject *v61;
  int v62;
  uint64_t v63;
  int v64;
  char *v65;
  uint64_t v66;
  os_log_type_t v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  uint64_t v71;
  _QWORD *v72;
  char *backtrace_string;
  NSObject *v74;
  os_log_type_t v75;
  _BOOL4 v76;
  int v77;
  uint64_t v78;
  char *v79;
  uint64_t v80;
  os_log_type_t v81;
  uint64_t v82;
  NSObject *v83;
  os_log_type_t v84;
  const char *v85;
  uint64_t v86;
  os_log_type_t v87;
  char *v88;
  NSObject *v89;
  os_log_type_t v90;
  _BOOL4 v91;
  uint64_t v92;
  uint64_t v93;
  os_log_type_t v94;
  uint64_t v95;
  uint64_t v96;
  char v97;
  int v98;
  uint64_t v99;
  unsigned __int8 *v100;
  unsigned __int8 *v101;
  char v102;
  _BOOL4 is_unidirectional;
  char v104;
  char v105;
  NSObject *v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  NSObject *v110;
  uint64_t v111;
  int v112;
  NSObject *v113;
  uint64_t v114;
  int v115;
  NSObject *v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  unsigned __int8 *v120;
  unsigned __int8 *v121;
  char v122;
  _BOOL4 v123;
  char v124;
  char v125;
  NSObject *v126;
  uint64_t v127;
  int v128;
  NSObject *v129;
  uint64_t v130;
  int v131;
  NSObject *v132;
  uint64_t v133;
  int v134;
  NSObject *v135;
  uint64_t v136;
  int v137;
  NSObject *v138;
  uint64_t v139;
  int v140;
  NSObject *v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  NSObject *v148;
  uint64_t v149;
  int v150;
  uint64_t v151;
  NSObject *v152;
  uint64_t v153;
  int v154;
  uint64_t v155;
  unsigned int v156;
  uint64_t v157;
  unsigned int v158;
  NSObject *v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  NSObject *v163;
  uint64_t v164;
  int v165;
  uint64_t v166;
  NSObject *v167;
  uint64_t v168;
  int v169;
  uint64_t v170;
  NSObject *v171;
  const char *v172;
  uint64_t v173;
  uint64_t v174;
  _QWORD *v175;
  uint64_t v176;
  char v177;
  NSObject *v178;
  uint64_t v179;
  int v180;
  NSObject *v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  unsigned int v185;
  uint64_t v186;
  void *parameters;
  void *v188;
  id *v189;
  void *v190;
  id v191;
  _QWORD *v192;
  void *v193;
  id *v194;
  NSObject *v195;
  id *v196;
  NSObject *v197;
  uint64_t v198;
  void *v199;
  NSObject *v200;
  nw_protocol_options_t v201;
  nw_protocol_options_t v202;
  nw_protocol_definition_t v203;
  uint64_t protocol_handle;
  uint64_t v205;
  char v206;
  uint64_t v207;
  void *v208;
  uint64_t v209;
  NSObject *v210;
  int v211;
  NSObject *v212;
  uint64_t v213;
  int v214;
  NSObject *v215;
  uint64_t v216;
  int v217;
  uint64_t v218;
  NSObject *v219;
  uint64_t v220;
  int v221;
  unsigned __int8 *v222;
  char *v223;
  NSObject *v224;
  os_log_type_t v225;
  NSObject *v226;
  os_log_type_t v227;
  const char *v228;
  uint64_t v229;
  int v230;
  uint64_t v231;
  char *v232;
  NSObject *v233;
  os_log_type_t v234;
  NSObject *v235;
  os_log_type_t v236;
  const char *v237;
  char *v238;
  NSObject *v239;
  os_log_type_t v240;
  NSObject *v241;
  os_log_type_t v242;
  const char *v243;
  char *v244;
  NSObject *v245;
  os_log_type_t v246;
  _BOOL4 v247;
  char *v248;
  NSObject *v249;
  os_log_type_t v250;
  _BOOL4 v251;
  char *v252;
  NSObject *v253;
  os_log_type_t v254;
  _BOOL4 v255;
  uint64_t v256;
  NSObject *v257;
  os_log_type_t v258;
  uint64_t v259;
  NSObject *v260;
  os_log_type_t v261;
  NSObject *v262;
  os_log_type_t v263;
  uint64_t v264;
  uint64_t v265;
  int v266;
  uint64_t v267;
  _QWORD *v268;
  uint64_t v269;
  NSObject *v270;
  int v271;
  char *v272;
  uint64_t v273;
  _QWORD *v274;
  uint64_t v275;
  uint64_t v276;
  _QWORD *v277;
  uint64_t v278;
  _QWORD *v279;
  NSObject *v280;
  int v281;
  uint64_t v282;
  char *v283;
  uint64_t v284;
  os_log_type_t v285;
  NSObject *v286;
  os_log_type_t v287;
  const char *v288;
  uint64_t v289;
  _QWORD *v290;
  char *v291;
  NSObject *v292;
  os_log_type_t v293;
  _BOOL4 v294;
  int v295;
  uint64_t v296;
  char *v297;
  uint64_t v298;
  os_log_type_t v299;
  uint64_t v300;
  NSObject *v301;
  os_log_type_t v302;
  const char *v303;
  uint64_t v304;
  os_log_type_t v305;
  char *v306;
  NSObject *v307;
  os_log_type_t v308;
  _BOOL4 v309;
  uint64_t v310;
  uint64_t v311;
  os_log_type_t v312;
  uint64_t v313;
  uint64_t v314;
  char v315;
  int v316;
  uint64_t v317;
  unsigned __int8 *v318;
  unsigned __int8 *v319;
  char v320;
  _BOOL4 v321;
  char v322;
  char v323;
  NSObject *v324;
  uint64_t v325;
  int v326;
  uint64_t v327;
  NSObject *v328;
  uint64_t v329;
  int v330;
  NSObject *v331;
  uint64_t v332;
  int v333;
  NSObject *v334;
  uint64_t v335;
  int v336;
  uint64_t v337;
  unsigned __int8 *v338;
  NSObject *v339;
  char v340;
  _BOOL4 v341;
  char v342;
  char v343;
  NSObject *v344;
  uint64_t v345;
  int v346;
  NSObject *v347;
  uint64_t v348;
  int v349;
  NSObject *v350;
  uint64_t v351;
  int v352;
  NSObject *v353;
  uint64_t v354;
  int v355;
  NSObject *v356;
  uint64_t v357;
  int v358;
  NSObject *v359;
  uint64_t v360;
  int v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  NSObject *v366;
  uint64_t v367;
  int v368;
  uint64_t v369;
  NSObject *v370;
  uint64_t v371;
  int v372;
  uint64_t v373;
  unsigned int v374;
  uint64_t v375;
  unsigned int v376;
  NSObject *v377;
  uint64_t v378;
  int v379;
  uint64_t v380;
  NSObject *v381;
  uint64_t v382;
  int v383;
  uint64_t v384;
  NSObject *v385;
  uint64_t v386;
  int v387;
  uint64_t v388;
  NSObject *v389;
  const char *v390;
  uint64_t v391;
  uint64_t v392;
  _QWORD *v393;
  uint64_t v394;
  char v395;
  NSObject *v396;
  uint64_t v397;
  int v398;
  NSObject *v399;
  uint64_t v400;
  int v401;
  uint64_t v402;
  unsigned int v403;
  uint64_t v404;
  uint64_t v405;
  void *v406;
  void *v407;
  id *v408;
  void *v409;
  id v410;
  _QWORD *v411;
  void *v412;
  id *v413;
  NSObject *v414;
  id *v415;
  NSObject *v416;
  uint64_t v417;
  void *v418;
  NSObject *v419;
  nw_protocol_options_t v420;
  nw_protocol_options_t v421;
  nw_protocol_definition_t v422;
  uint64_t v423;
  uint64_t v424;
  char v425;
  uint64_t v426;
  void *v427;
  NSObject *v428;
  int v429;
  NSObject *v430;
  uint64_t v431;
  int v432;
  NSObject *v433;
  uint64_t v434;
  int v435;
  uint64_t v436;
  NSObject *v437;
  uint64_t v438;
  int v439;
  char *v440;
  NSObject *v441;
  os_log_type_t v442;
  NSObject *v443;
  os_log_type_t v444;
  const char *v445;
  uint64_t v446;
  int v447;
  uint64_t v448;
  NSObject *v449;
  os_log_type_t v450;
  char *v451;
  NSObject *v452;
  os_log_type_t v453;
  NSObject *v454;
  os_log_type_t v455;
  const char *v456;
  char *v457;
  NSObject *v458;
  os_log_type_t v459;
  _BOOL4 v460;
  char *v461;
  NSObject *v462;
  os_log_type_t v463;
  _BOOL4 v464;
  char *v465;
  NSObject *v466;
  os_log_type_t v467;
  _BOOL4 v468;
  uint64_t v469;
  NSObject *v470;
  os_log_type_t v471;
  uint64_t v472;
  NSObject *v473;
  os_log_type_t v474;
  NSObject *v475;
  os_log_type_t v476;
  uint64_t v477;
  uint64_t v478;
  int v479;
  uint64_t v480;
  _QWORD *v481;
  uint64_t v482;
  char *v484;
  NSObject *v485;
  os_log_type_t v486;
  const char *v487;
  NSObject *v488;
  int v489;
  NSObject *v490;
  int v491;
  NSObject *v492;
  int v493;
  NSObject *v494;
  int v495;
  char *v496;
  NSObject *v497;
  os_log_type_t v498;
  _BOOL4 v499;
  char *v500;
  _BOOL4 v501;
  const char *v502;
  _BOOL4 v503;
  _BOOL4 v504;
  NSObject *v505;
  os_log_type_t v506;
  NSObject *v507;
  uint64_t v508;
  int v509;
  NSObject *v510;
  uint64_t v511;
  int v512;
  uint64_t v513;
  uint64_t v514;
  void *v515;
  NSObject *v516;
  unsigned __int8 *v517;
  NSObject *stack;
  nw_protocol_stack_t stacka;
  int v520;
  int v521;
  id *v522;
  id v523;
  char v524;
  os_log_type_t v525;
  os_log_type_t type[8];
  os_log_type_t *v527;
  uint64_t v528;
  char v529;
  _BYTE buf[24];
  uint64_t v531;
  _BYTE v532[36];
  __int16 v533;
  int v534;
  uint8_t v535[4];
  const char *v536;
  __int16 v537;
  char *v538;
  _BYTE iterate_block[24];
  const char *v540;
  os_log_type_t *v541;
  _BYTE *v542;
  uint64_t v543;
  uint64_t v544;

  v2 = (uint64_t)a2;
  v544 = *MEMORY[0x1E0C80C00];
  if (nw_frame_unclaimed_length(a2))
  {
    v4 = *(_QWORD *)(a1 + 40);
    if (!v4 || (*(_BYTE *)(v4 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v6 = *(_QWORD *)(a1 + 40);
        v7 = (const char *)(v6 + 464);
        v8 = "";
        v9 = *(_DWORD *)(v6 + 460);
        v10 = v6 == 0;
        if (!v6)
          v7 = "";
        v11 = *(_DWORD *)(v6 + 444);
        if (!v10)
          v8 = " ";
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v7;
        *(_WORD *)&buf[22] = 2080;
        v531 = (uint64_t)v8;
        *(_WORD *)v532 = 1024;
        *(_DWORD *)&v532[2] = v9;
        *(_WORD *)&v532[6] = 1024;
        *(_DWORD *)&v532[8] = v11;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Unexpected data received in state: %d", buf, 0x2Cu);
      }
    }
  }
  v12 = nw_frame_copy_metadata_for_protocol(v2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
  v13 = *(_QWORD *)(a1 + 40);
  if (v12)
  {
    v14 = v12;
    v15 = *(_DWORD *)(v13 + 444);
    if (v15 != 3)
    {
      if (v15 != 1)
      {
LABEL_721:
        nw_frame_finalize(v2);
        os_release(v14);
        return 1;
      }
      if (nw_protocol_metadata_is_http(v12))
      {
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v488 = __nwlog_obj();
            if (os_log_type_enabled(v488, OS_LOG_TYPE_DEBUG))
            {
              v489 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v13 + 464;
              *(_WORD *)&buf[22] = 2080;
              v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v489;
              _os_log_impl(&dword_182FBE000, v488, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
            }
          }
        }
        v16 = nw_http_metadata_copy_response(v14);
        if (v16)
        {
          v17 = v16;
          status_code = _nw_http_response_get_status_code();
          v523 = v17;

          if ((status_code - 200) > 0x63)
          {
            if (*(_DWORD *)(v13 + 444) != 5)
            {
              if ((*(_BYTE *)(v13 + 548) & 2) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v270 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                {
                  v271 = *(_DWORD *)(v13 + 460);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v13 + 464;
                  *(_WORD *)&buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v271;
                  *(_WORD *)&v532[6] = 1024;
                  *(_DWORD *)&v532[8] = 57;
                  _os_log_impl(&dword_182FBE000, v270, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
                }
              }
              *(_DWORD *)(v13 + 444) = 5;
              v272 = *(char **)(v13 + 184);
              if (v272)
              {
                *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                *(_QWORD *)&buf[8] = 0x40000000;
                *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
                v531 = (uint64_t)&__block_descriptor_tmp_22_33428;
                *(_DWORD *)v532 = 57;
                nw_hash_table_apply(v272, (uint64_t)buf);
              }
              v273 = *(_QWORD *)(v13 + 424);
              if (v273)
              {
                v274 = *(_QWORD **)(v273 + 48);
                nw_protocol_error(v274, *(_QWORD *)(v13 + 424));
                nw_protocol_disconnected(v274, v273);
              }
              v275 = *(_QWORD *)(v13 + 328);
              if (v275)
              {
                do
                {
                  v276 = *(_QWORD *)(v275 + 112);
                  v277 = *(_QWORD **)(v275 + 48);
                  nw_protocol_error(v277, v275);
                  nw_protocol_disconnected(v277, v275);
                  v275 = v276;
                }
                while (v276);
              }
              v278 = *(_QWORD *)(v13 + 416);
              if (v278)
              {
                v279 = *(_QWORD **)(v278 + 48);
                nw_protocol_error(v279, *(_QWORD *)(v13 + 416));
                nw_protocol_disconnected(v279, v278);
              }
              if (*(_QWORD *)(v13 + 32))
              {
                nw_protocol_remove_instance(v13);
                nw_protocol_disconnect(*(_QWORD **)(v13 + 32), v13);
              }
              goto LABEL_720;
            }
            if ((*(_BYTE *)(v13 + 548) & 2) != 0
              || (pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once),
                  networkd_settings_init(),
                  v49 = gLogObj,
                  !os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)))
            {
LABEL_720:
              os_release(v523);
              goto LABEL_721;
            }
            v50 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v50;
            v22 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
            v23 = v49;
            v24 = OS_LOG_TYPE_INFO;
            v25 = 38;
LABEL_57:
            _os_log_impl(&dword_182FBE000, v23, v24, v22, buf, v25);
            goto LABEL_720;
          }
          if (*(_DWORD *)(v13 + 444) == 4)
          {
            if ((*(_BYTE *)(v13 + 548) & 2) != 0)
              goto LABEL_720;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v19 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_720;
            v20 = *(_DWORD *)(v13 + 460);
            v21 = *(_DWORD *)(v13 + 444);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_streams_ready";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v20;
            *(_WORD *)&v532[6] = 1024;
            *(_DWORD *)&v532[8] = v21;
            v22 = "%{public}s %{public}s%s<i%u> Tried to ready streams with incorrect state: %d, ignoring";
            v23 = v19;
            v24 = OS_LOG_TYPE_ERROR;
            v25 = 44;
            goto LABEL_57;
          }
          *(_DWORD *)(v13 + 444) = 4;
          if ((*(_BYTE *)(v13 + 548) & 2) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v61 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              v62 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_streams_ready";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v13 + 464;
              *(_WORD *)&buf[22] = 2080;
              v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v62;
              _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Webtransport session established, reconfiguring streams", buf, 0x26u);
            }
          }
          v63 = *(_QWORD *)(v13 + 328);
          if (!v63)
            goto LABEL_720;
          if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v507 = __nwlog_obj();
              if (os_log_type_enabled(v507, OS_LOG_TYPE_DEBUG))
              {
                v508 = *(_QWORD *)(v63 + 88);
                if (v508)
                  v509 = *(_DWORD *)(v508 + 460);
                else
                  v509 = -1;
                v513 = *(_QWORD *)(v63 + 64);
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v63 + 192;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v509;
                *(_WORD *)&v532[6] = 2048;
                *(_QWORD *)&v532[8] = v513;
                *(_WORD *)&v532[16] = 2048;
                *(_QWORD *)&v532[18] = v63;
                _os_log_impl(&dword_182FBE000, v507, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
              }
            }
          }
          v64 = *(_BYTE *)(v13 + 548) & 1;
          v520 = v64;
          while (1)
          {
            if ((*(_BYTE *)(v13 + 548) & 2) == 0)
            {
              if (gLogDatapath)
              {
                v210 = __nwlog_obj();
                if (os_log_type_enabled(v210, OS_LOG_TYPE_DEBUG))
                {
                  v211 = *(_DWORD *)(v13 + 460);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v13 + 464;
                  *(_WORD *)&buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v211;
                  *(_WORD *)&v532[6] = 2048;
                  *(_QWORD *)&v532[8] = v63;
                  _os_log_impl(&dword_182FBE000, v210, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
                }
              }
            }
            if ((*(_BYTE *)(v63 + 276) & 0x20) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v63;
              v65 = (char *)_os_log_send_and_compose_impl();
              iterate_block[0] = 16;
              type[0] = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v65, iterate_block, type))
                goto LABEL_108;
              if (iterate_block[0] == 17)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v66 = gLogObj;
                v67 = iterate_block[0];
                if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v63;
                  v68 = v66;
                  v69 = v67;
                  v70 = "%{public}s stream %p not in pending list, cannot remove";
                  goto LABEL_107;
                }
                goto LABEL_108;
              }
              if (type[0])
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v74 = gLogObj;
                v75 = iterate_block[0];
                v76 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
                if (backtrace_string)
                {
                  if (v76)
                  {
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v63;
                    *(_WORD *)&buf[22] = 2082;
                    v531 = (uint64_t)backtrace_string;
                    _os_log_impl(&dword_182FBE000, v74, v75, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
                  }
                  free(backtrace_string);
                  goto LABEL_108;
                }
                if (!v76)
                {
LABEL_108:
                  if (v65)
                    free(v65);
                  goto LABEL_120;
                }
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v63;
                v68 = v74;
                v69 = v75;
                v70 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v86 = gLogObj;
                v87 = iterate_block[0];
                if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
                  goto LABEL_108;
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v63;
                v68 = v86;
                v69 = v87;
                v70 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
              }
LABEL_107:
              _os_log_impl(&dword_182FBE000, v68, v69, v70, buf, 0x16u);
              goto LABEL_108;
            }
            v71 = *(_QWORD *)(v63 + 112);
            v72 = *(_QWORD **)(v63 + 120);
            if (v71)
            {
              *(_QWORD *)(v71 + 120) = v72;
              v72 = *(_QWORD **)(v63 + 120);
            }
            else
            {
              *(_QWORD *)(v13 + 336) = v72;
            }
            *v72 = v71;
            *(_QWORD *)(v63 + 112) = 0;
            *(_QWORD *)(v63 + 120) = 0;
            v77 = *(_DWORD *)(v13 + 456);
            *(_DWORD *)(v13 + 456) = v77 - 1;
            if (!v77)
              break;
LABEL_118:
            v97 = *(_BYTE *)(v63 + 276);
            *(_BYTE *)(v63 + 276) = v97 & 0xDF;
            if ((v97 & 0x10) == 0)
            {
              if (gLogDatapath)
              {
                v212 = __nwlog_obj();
                if (os_log_type_enabled(v212, OS_LOG_TYPE_DEBUG))
                {
                  v213 = *(_QWORD *)(v63 + 88);
                  if (v213)
                    v214 = *(_DWORD *)(v213 + 460);
                  else
                    v214 = -1;
                  v229 = *(_QWORD *)(v63 + 64);
                  v230 = *(_DWORD *)(v13 + 456);
                  *(_DWORD *)buf = 136447746;
                  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v214;
                  *(_WORD *)&v532[6] = 2048;
                  *(_QWORD *)&v532[8] = v229;
                  *(_WORD *)&v532[16] = 2048;
                  *(_QWORD *)&v532[18] = v63;
                  *(_WORD *)&v532[26] = 1024;
                  *(_DWORD *)&v532[28] = v230;
                  _os_log_impl(&dword_182FBE000, v212, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams", buf, 0x40u);
                }
              }
            }
LABEL_120:
            v98 = *(_DWORD *)(v13 + 448);
            if (v98 != 1)
            {
              if (!v98)
              {
                if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                {
                  if (gLogDatapath)
                  {
                    v215 = __nwlog_obj();
                    if (os_log_type_enabled(v215, OS_LOG_TYPE_DEBUG))
                    {
                      v216 = *(_QWORD *)(v63 + 88);
                      if (v216)
                        v217 = *(_DWORD *)(v216 + 460);
                      else
                        v217 = -1;
                      v231 = *(_QWORD *)(v63 + 64);
                      *(_DWORD *)buf = 136447746;
                      *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v63 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v217;
                      *(_WORD *)&v532[6] = 2048;
                      *(_QWORD *)&v532[8] = v231;
                      *(_WORD *)&v532[16] = 2048;
                      *(_QWORD *)&v532[18] = v63;
                      *(_WORD *)&v532[26] = 1024;
                      v64 = v520;
                      *(_DWORD *)&v532[28] = v520;
                      _os_log_impl(&dword_182FBE000, v215, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
                    }
                  }
                }
                v99 = *(_QWORD *)(v63 + 88);
                if (*(_QWORD *)(v99 + 416) == v63)
                {
                  if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v219 = __nwlog_obj();
                      if (os_log_type_enabled(v219, OS_LOG_TYPE_DEBUG))
                      {
                        v220 = *(_QWORD *)(v63 + 88);
                        if (v220)
                          v221 = *(_DWORD *)(v220 + 460);
                        else
                          v221 = -1;
                        v256 = *(_QWORD *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v221;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v256;
                        _os_log_impl(&dword_182FBE000, v219, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream", buf, 0x30u);
                        v64 = v520;
                      }
                    }
                  }
                  nw_protocol_connected(*(_QWORD **)(v63 + 48), v63);
                }
                else
                {
                  if (nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken != -1)
                    dispatch_once(&nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken, &__block_literal_global_28);
                  *(_QWORD *)(v63 + 24) = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
                  nw_protocol_set_output_handler(v63, v99);
                  v100 = nw_parameters_copy_protocol_options_legacy(*(void **)(v63 + 144), (nw_protocol *)v63);
                  if (v100)
                  {
                    v101 = v100;
                    if (v64)
                    {
                      if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                      {
                        if (gLogDatapath)
                        {
                          v116 = __nwlog_obj();
                          if (os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG))
                          {
                            v117 = *(_QWORD *)(v63 + 88);
                            if (v117)
                              v118 = *(_DWORD *)(v117 + 460);
                            else
                              v118 = -1;
                            v259 = *(_QWORD *)(v63 + 64);
                            *(_DWORD *)buf = 136447234;
                            *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                            *(_WORD *)&buf[12] = 2082;
                            *(_QWORD *)&buf[14] = v63 + 192;
                            *(_WORD *)&buf[22] = 2080;
                            v531 = (uint64_t)" ";
                            *(_WORD *)v532 = 1024;
                            *(_DWORD *)&v532[2] = v118;
                            *(_WORD *)&v532[6] = 2048;
                            *(_QWORD *)&v532[8] = v259;
                            _os_log_impl(&dword_182FBE000, v116, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment to setup metadata", buf, 0x30u);
                            v64 = v520;
                          }
                        }
                      }
                    }
                    else if (nw_protocol_options_is_webtransport(v100))
                    {
                      *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xFC | 1;
                      if (nw_webtransport_options_get_is_datagram(v101))
                        v102 = 8;
                      else
                        v102 = 0;
                      *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xF7 | v102;
                      is_unidirectional = nw_webtransport_options_get_is_unidirectional(v101);
                      v104 = *(_BYTE *)(v63 + 276);
                      if (is_unidirectional)
                        v105 = 4;
                      else
                        v105 = 0;
                      *(_BYTE *)(v63 + 276) = v104 & 0xFB | v105;
                      if ((v104 & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v106 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                        {
                          v107 = *(_QWORD *)(v63 + 88);
                          if (v107)
                            v108 = *(_DWORD *)(v107 + 460);
                          else
                            v108 = -1;
                          v155 = *(_QWORD *)(v63 + 64);
                          v156 = *(unsigned __int8 *)(v63 + 276);
                          *(_DWORD *)buf = 136448002;
                          *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v108;
                          *(_WORD *)&v532[6] = 2048;
                          *(_QWORD *)&v532[8] = v155;
                          *(_WORD *)&v532[16] = 1024;
                          *(_DWORD *)&v532[18] = (v156 >> 1) & 1;
                          *(_WORD *)&v532[22] = 1024;
                          *(_DWORD *)&v532[24] = (v156 >> 3) & 1;
                          *(_WORD *)&v532[28] = 1024;
                          *(_DWORD *)&v532[30] = (v156 >> 2) & 1;
                          _os_log_impl(&dword_182FBE000, v106, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                        }
                      }
                      nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 2) != 0);
                      nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 8) != 0);
                      nw_webtransport_metadata_set_is_unidirectional(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 4) != 0);
                    }
                    else if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v138 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                      {
                        v139 = *(_QWORD *)(v63 + 88);
                        if (v139)
                          v140 = *(_DWORD *)(v139 + 460);
                        else
                          v140 = -1;
                        v162 = *(_QWORD *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v140;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v162;
                        _os_log_impl(&dword_182FBE000, v138, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                      }
                    }
                    os_release(v101);
                  }
                  else if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v113 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                    {
                      v114 = *(_QWORD *)(v63 + 88);
                      if (v114)
                        v115 = *(_DWORD *)(v114 + 460);
                      else
                        v115 = -1;
                      v145 = *(_QWORD *)(v63 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v63 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v115;
                      *(_WORD *)&v532[6] = 2048;
                      *(_QWORD *)&v532[8] = v145;
                      _os_log_impl(&dword_182FBE000, v113, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
                    }
                  }
                }
                if (v63 != *(_QWORD *)(v13 + 416))
                  nw_protocol_connected((_QWORD *)v63, v13);
              }
LABEL_236:
              v63 = *(_QWORD *)(v13 + 328);
              if (!v63)
                goto LABEL_720;
              goto LABEL_237;
            }
            v109 = *(_QWORD *)(v63 + 88);
            if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v110 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
              {
                v111 = *(_QWORD *)(v63 + 88);
                if (v111)
                  v112 = *(_DWORD *)(v111 + 460);
                else
                  v112 = -1;
                v119 = *(_QWORD *)(v63 + 64);
                *(_DWORD *)buf = 136447746;
                *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v63 + 192;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v112;
                *(_WORD *)&v532[6] = 2048;
                *(_QWORD *)&v532[8] = v119;
                *(_WORD *)&v532[16] = 2048;
                *(_QWORD *)&v532[18] = v63;
                *(_WORD *)&v532[26] = 1024;
                *(_DWORD *)&v532[28] = v64;
                _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP3 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
              }
            }
            if (*(_QWORD *)(v109 + 416) == v63)
            {
              if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v129 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                {
                  v130 = *(_QWORD *)(v63 + 88);
                  if (v130)
                    v131 = *(_DWORD *)(v130 + 460);
                  else
                    v131 = -1;
                  v144 = *(_QWORD *)(v63 + 64);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v131;
                  *(_WORD *)&v532[6] = 2048;
                  *(_QWORD *)&v532[8] = v144;
                  _os_log_impl(&dword_182FBE000, v129, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning connected without more reconfiguration for placeholder stream", buf, 0x30u);
                }
              }
              nw_protocol_connected(*(_QWORD **)(v63 + 48), v63);
              v63 = *(_QWORD *)(v13 + 328);
              if (!v63)
                goto LABEL_720;
            }
            else
            {
              v120 = nw_parameters_copy_protocol_options_legacy(*(void **)(v63 + 144), (nw_protocol *)v63);
              if (v120)
              {
                v121 = v120;
                if (nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken != -1)
                  dispatch_once(&nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken, &__block_literal_global_42_33727);
                *(_QWORD *)(v63 + 24) = &nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks;
                if (!v64)
                {
                  if (nw_protocol_options_is_webtransport(v121))
                  {
                    *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xFC | 1;
                    if (nw_webtransport_options_get_is_datagram(v121))
                      v122 = 8;
                    else
                      v122 = 0;
                    *(_BYTE *)(v63 + 276) = *(_BYTE *)(v63 + 276) & 0xF7 | v122;
                    v123 = nw_webtransport_options_get_is_unidirectional(v121);
                    v124 = *(_BYTE *)(v63 + 276);
                    if (v123)
                      v125 = 4;
                    else
                      v125 = 0;
                    *(_BYTE *)(v63 + 276) = v124 & 0xFB | v125;
                    if ((v124 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v126 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        v127 = *(_QWORD *)(v63 + 88);
                        if (v127)
                          v128 = *(_DWORD *)(v127 + 460);
                        else
                          v128 = -1;
                        v157 = *(_QWORD *)(v63 + 64);
                        v158 = *(unsigned __int8 *)(v63 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v128;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v157;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v158 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v158 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v158 >> 2) & 1;
                        _os_log_impl(&dword_182FBE000, v126, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 4) != 0);
LABEL_223:
                    if ((*(_BYTE *)(v63 + 276) & 8) == 0)
                      goto LABEL_224;
LABEL_244:
                    nw_protocol_connected((_QWORD *)v63, v109);
LABEL_270:
                    v186 = *(_QWORD *)(v109 + 32);
                    if (v186)
                    {
                      if ((*(_BYTE *)(v109 + 548) & 0x40) == 0)
                      {
                        v64 = v520;
                        if (!nw_protocol_add_input_handler(*(_QWORD *)(v109 + 32), v63))
                          goto LABEL_371;
LABEL_300:
                        if (*(_QWORD *)(v63 + 32))
                        {
                          v207 = *(_QWORD *)(v63 + 176);
                          v208 = *(void **)(v109 + 392);
                          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                          *(_QWORD *)&buf[8] = 0x40000000;
                          *(_QWORD *)&buf[16] = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
                          v531 = (uint64_t)&unk_1E14A05F8;
                          *(_QWORD *)v532 = v207;
                          nw_queue_context_async(v208, buf);
                          goto LABEL_379;
                        }
LABEL_371:
                        if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          v264 = gLogObj;
                          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                          {
                            v265 = *(_QWORD *)(v63 + 88);
                            if (v265)
                              v266 = *(_DWORD *)(v265 + 460);
                            else
                              v266 = -1;
                            v267 = *(_QWORD *)(v63 + 64);
                            *(_DWORD *)buf = 136447234;
                            *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                            *(_WORD *)&buf[12] = 2082;
                            *(_QWORD *)&buf[14] = v63 + 192;
                            *(_WORD *)&buf[22] = 2080;
                            v531 = (uint64_t)" ";
                            *(_WORD *)v532 = 1024;
                            *(_DWORD *)&v532[2] = v266;
                            *(_WORD *)&v532[6] = 2048;
                            *(_QWORD *)&v532[8] = v267;
                            v171 = v264;
                            v172 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
                            goto LABEL_377;
                          }
                        }
                        goto LABEL_378;
                      }
                      v517 = v121;
                      parameters = (void *)nw_protocol_get_parameters(v63);
                      if (parameters)
                      {
                        v188 = parameters;
                        nw_parameters_log_protocol_instances(parameters);
                        v189 = v188;
                        stack = v189[19];

                        *(_QWORD *)type = 0;
                        v527 = type;
                        v528 = 0x2000000000;
                        v529 = 0;
                        *(_QWORD *)buf = 0;
                        *(_QWORD *)&buf[8] = buf;
                        *(_QWORD *)&buf[16] = 0x3802000000;
                        v531 = (uint64_t)__Block_byref_object_copy__33462;
                        *(_QWORD *)v532 = __Block_byref_object_dispose__33463;
                        *(_QWORD *)&v532[8] = 0;
                        v532[16] |= 1u;
                        *(_QWORD *)iterate_block = MEMORY[0x1E0C809B0];
                        *(_QWORD *)&iterate_block[8] = 0x40000000;
                        *(_QWORD *)&iterate_block[16] = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
                        v540 = (const char *)&unk_1E14A0660;
                        v541 = type;
                        v542 = buf;
                        v543 = v63;
                        nw_protocol_stack_iterate_application_protocols(stack, iterate_block);
                        v190 = *(void **)(*(_QWORD *)&buf[8] + 40);
                        if (v190)
                        {
                          if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
                            dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72293);
                          v191 = (id)nw_protocol_copy_http_messaging_definition_definition;
                          v192 = v190;
                          v192[2] = v186;

                          if (v191)
                            os_release(v191);
                          v193 = (void *)nw_protocol_get_parameters(v186);
                          if (v193)
                          {
                            v194 = v193;
                            v195 = v194[19];

                            v196 = v189;
                            v197 = v189[19];

                            v198 = v2;
                            v199 = v14;
                            v200 = nw_protocol_stack_copy_transport_protocol(v195);
                            v201 = nw_protocol_stack_copy_transport_protocol(v197);
                            v202 = v201;
                            if (v200)
                            {
                              if (v201)
                              {
                                v203 = nw_protocol_options_copy_definition(v200);
                                if (nw_protocol_options_matches_definition(v202, v203))
                                {
                                  protocol_handle = nw_protocol_options_get_protocol_handle(v200);
                                  nw_parameters_set_protocol_instance(v202, v205, protocol_handle);
                                }
                                os_release(v202);
                              }
                              v202 = v200;
LABEL_288:
                              os_release(v202);
                            }
                            else if (v201)
                            {
                              goto LABEL_288;
                            }
                            v14 = v199;
                            if (v197)
                              os_release(v197);
                            v2 = v198;
                            if (v195)
                              os_release(v195);
                          }
                          nw_protocol_set_output_handler(v63, 0);
                          v206 = nw_protocol_add_input_handler(v186, v63);
LABEL_294:
                          _Block_object_dispose(buf, 8);
                          v64 = v520;
                          v121 = v517;
                          if ((v532[16] & 1) != 0 && *(_QWORD *)&v532[8])
                            os_release(*(void **)&v532[8]);
                          _Block_object_dispose(type, 8);
                          if (stack)
                            os_release(stack);
                          if ((v206 & 1) != 0)
                            goto LABEL_300;
                          goto LABEL_371;
                        }
                        __nwlog_obj();
                        *(_DWORD *)v535 = 136446210;
                        v536 = "nw_webtransport_session_add_to_http_messaging";
                        v238 = (char *)_os_log_send_and_compose_impl();
                        v525 = OS_LOG_TYPE_ERROR;
                        v524 = 0;
                        if (!__nwlog_fault(v238, &v525, &v524))
                          goto LABEL_384;
                        if (v525 == OS_LOG_TYPE_FAULT)
                        {
                          v239 = __nwlog_obj();
                          v240 = v525;
                          if (os_log_type_enabled(v239, v525))
                          {
                            *(_DWORD *)v535 = 136446210;
                            v536 = "nw_webtransport_session_add_to_http_messaging";
                            v241 = v239;
                            v242 = v240;
                            v243 = "%{public}s called with null options";
                            goto LABEL_383;
                          }
                          goto LABEL_384;
                        }
                        if (v524)
                        {
                          v252 = (char *)__nw_create_backtrace_string();
                          v253 = __nwlog_obj();
                          v254 = v525;
                          v255 = os_log_type_enabled(v253, v525);
                          if (v252)
                          {
                            if (v255)
                            {
                              *(_DWORD *)v535 = 136446466;
                              v536 = "nw_webtransport_session_add_to_http_messaging";
                              v537 = 2082;
                              v538 = v252;
                              _os_log_impl(&dword_182FBE000, v253, v254, "%{public}s called with null options, dumping backtrace:%{public}s", v535, 0x16u);
                            }
                            free(v252);
                            goto LABEL_384;
                          }
                          if (!v255)
                          {
LABEL_384:
                            if (v238)
                              free(v238);
                            v206 = 0;
                            goto LABEL_294;
                          }
                          *(_DWORD *)v535 = 136446210;
                          v536 = "nw_webtransport_session_add_to_http_messaging";
                          v241 = v253;
                          v242 = v254;
                          v243 = "%{public}s called with null options, no backtrace";
                        }
                        else
                        {
                          v262 = __nwlog_obj();
                          v263 = v525;
                          if (!os_log_type_enabled(v262, v525))
                            goto LABEL_384;
                          *(_DWORD *)v535 = 136446210;
                          v536 = "nw_webtransport_session_add_to_http_messaging";
                          v241 = v262;
                          v242 = v263;
                          v243 = "%{public}s called with null options, backtrace limit exceeded";
                        }
LABEL_383:
                        _os_log_impl(&dword_182FBE000, v241, v242, v243, v535, 0xCu);
                        goto LABEL_384;
                      }
                      __nwlog_obj();
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v232 = (char *)_os_log_send_and_compose_impl();
                      type[0] = OS_LOG_TYPE_ERROR;
                      v535[0] = 0;
                      if (!__nwlog_fault(v232, type, v535))
                        goto LABEL_368;
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        v233 = __nwlog_obj();
                        v234 = type[0];
                        if (os_log_type_enabled(v233, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                          v235 = v233;
                          v236 = v234;
                          v237 = "%{public}s called with null parameters";
                          goto LABEL_367;
                        }
                        goto LABEL_368;
                      }
                      if (v535[0])
                      {
                        v248 = (char *)__nw_create_backtrace_string();
                        v249 = __nwlog_obj();
                        v250 = type[0];
                        v251 = os_log_type_enabled(v249, type[0]);
                        if (v248)
                        {
                          if (v251)
                          {
                            *(_DWORD *)buf = 136446466;
                            *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                            *(_WORD *)&buf[12] = 2082;
                            *(_QWORD *)&buf[14] = v248;
                            _os_log_impl(&dword_182FBE000, v249, v250, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
                          }
                          free(v248);
                          goto LABEL_368;
                        }
                        if (!v251)
                        {
LABEL_368:
                          if (v232)
                            free(v232);
                          v64 = v520;
                          v121 = v517;
                          goto LABEL_371;
                        }
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v235 = v249;
                        v236 = v250;
                        v237 = "%{public}s called with null parameters, no backtrace";
                      }
                      else
                      {
                        v260 = __nwlog_obj();
                        v261 = type[0];
                        if (!os_log_type_enabled(v260, type[0]))
                          goto LABEL_368;
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v235 = v260;
                        v236 = v261;
                        v237 = "%{public}s called with null parameters, backtrace limit exceeded";
                      }
LABEL_367:
                      _os_log_impl(&dword_182FBE000, v235, v236, v237, buf, 0xCu);
                      goto LABEL_368;
                    }
                    v222 = v121;
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                    v223 = (char *)_os_log_send_and_compose_impl();
                    iterate_block[0] = 16;
                    type[0] = OS_LOG_TYPE_DEFAULT;
                    if (!__nwlog_fault(v223, iterate_block, type))
                      goto LABEL_356;
                    if (iterate_block[0] == 17)
                    {
                      v224 = __nwlog_obj();
                      v225 = iterate_block[0];
                      if (os_log_type_enabled(v224, (os_log_type_t)iterate_block[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                        v226 = v224;
                        v227 = v225;
                        v228 = "%{public}s called with null transport_protocol";
                        goto LABEL_355;
                      }
                      goto LABEL_356;
                    }
                    if (type[0])
                    {
                      v244 = (char *)__nw_create_backtrace_string();
                      v245 = __nwlog_obj();
                      v246 = iterate_block[0];
                      v247 = os_log_type_enabled(v245, (os_log_type_t)iterate_block[0]);
                      if (v244)
                      {
                        if (v247)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v244;
                          _os_log_impl(&dword_182FBE000, v245, v246, "%{public}s called with null transport_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                        }
                        free(v244);
                        goto LABEL_356;
                      }
                      if (!v247)
                      {
LABEL_356:
                        if (v223)
                          free(v223);
                        v64 = v520;
                        v121 = v222;
                        goto LABEL_371;
                      }
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                      v226 = v245;
                      v227 = v246;
                      v228 = "%{public}s called with null transport_protocol, no backtrace";
                    }
                    else
                    {
                      v257 = __nwlog_obj();
                      v258 = iterate_block[0];
                      if (!os_log_type_enabled(v257, (os_log_type_t)iterate_block[0]))
                        goto LABEL_356;
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                      v226 = v257;
                      v227 = v258;
                      v228 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
                    }
LABEL_355:
                    _os_log_impl(&dword_182FBE000, v226, v227, v228, buf, 0xCu);
                    goto LABEL_356;
                  }
                  if ((*(_BYTE *)(v63 + 276) & 0x10) != 0)
                    goto LABEL_223;
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v141 = gLogObj;
                  if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                    goto LABEL_223;
                  v142 = *(_QWORD *)(v63 + 88);
                  if (v142)
                    v143 = *(_DWORD *)(v142 + 460);
                  else
                    v143 = -1;
                  v166 = *(_QWORD *)(v63 + 64);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v143;
                  *(_WORD *)&v532[6] = 2048;
                  *(_QWORD *)&v532[8] = v166;
                  _os_log_impl(&dword_182FBE000, v141, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                  if ((*(_BYTE *)(v63 + 276) & 8) != 0)
                    goto LABEL_244;
LABEL_224:
                  nw_protocol_set_output_handler(v63, 0);
                  *(_QWORD *)(v63 + 56) = 0;
                  if (!*(_QWORD *)(v109 + 376))
                  {
                    if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                    {
                      v159 = __nwlog_obj();
                      if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
                      {
                        v160 = *(_QWORD *)(v63 + 88);
                        if (v160)
                          v161 = *(_DWORD *)(v160 + 460);
                        else
                          v161 = -1;
                        v170 = *(_QWORD *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v161;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v170;
                        v171 = v159;
                        v172 = "%{public}s %{public}s%s<i%u:s%lld> no http connection metadata when attempting to start w"
                               "ebtransport http3 stream";
LABEL_377:
                        _os_log_impl(&dword_182FBE000, v171, OS_LOG_TYPE_ERROR, v172, buf, 0x30u);
                      }
                    }
LABEL_378:
                    v268 = *(_QWORD **)(v63 + 48);
                    nw_protocol_error(v268, v63);
                    nw_protocol_disconnected(v268, v63);
LABEL_379:
                    os_release(v121);
                    v63 = *(_QWORD *)(v13 + 328);
                    if (!v63)
                      goto LABEL_720;
                    goto LABEL_237;
                  }
                  if ((*(_BYTE *)(v63 + 276) & 0x40) != 0)
                    goto LABEL_270;
LABEL_269:
                  nw_webtransport_http3_stream_fix_http_parameters(v109, v63);
                  goto LABEL_270;
                }
                if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v135 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    v136 = *(_QWORD *)(v63 + 88);
                    if (v136)
                      v137 = *(_DWORD *)(v136 + 460);
                    else
                      v137 = -1;
                    v147 = *(_QWORD *)(v63 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v63 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v137;
                    *(_WORD *)&v532[6] = 2048;
                    *(_QWORD *)&v532[8] = v147;
                    _os_log_impl(&dword_182FBE000, v135, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Preemptively configuring metadata with incoming stream ID", buf, 0x30u);
                  }
                }
                if (*(_QWORD *)(v109 + 176) != -1)
                {
                  if (*(_QWORD *)(v63 + 64) == -1)
                  {
                    v151 = *(_QWORD *)(*(_QWORD *)(v63 + 88) + 176);
                    if (v151 == -1)
                    {
                      if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                      {
                        v167 = __nwlog_obj();
                        if (os_log_type_enabled(v167, OS_LOG_TYPE_ERROR))
                        {
                          v168 = *(_QWORD *)(v63 + 88);
                          if (v168)
                            v169 = *(_DWORD *)(v168 + 460);
                          else
                            v169 = -1;
                          v174 = *(_QWORD *)(v63 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v169;
                          *(_WORD *)&v532[6] = 2048;
                          *(_QWORD *)&v532[8] = v174;
                          _os_log_impl(&dword_182FBE000, v167, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing", buf, 0x30u);
                        }
                      }
                      v175 = *(_QWORD **)(v63 + 48);
                      nw_protocol_error(v175, v63);
                      nw_protocol_disconnected(v175, v63);
                    }
                    else
                    {
                      *(_QWORD *)(v63 + 64) = v151;
                      nw_webtransport_metadata_set_stream_id(*(void **)(v63 + 160), v151);
                      if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                      {
                        v152 = __nwlog_obj();
                        if (os_log_type_enabled(v152, OS_LOG_TYPE_INFO))
                        {
                          v153 = *(_QWORD *)(v63 + 88);
                          if (v153)
                            v154 = *(_DWORD *)(v153 + 460);
                          else
                            v154 = -1;
                          v173 = *(_QWORD *)(v63 + 64);
                          *(_DWORD *)buf = 136448002;
                          *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v63 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v154;
                          *(_WORD *)&v532[6] = 2048;
                          *(_QWORD *)&v532[8] = v173;
                          *(_WORD *)&v532[16] = 2048;
                          *(_QWORD *)&v532[18] = v173;
                          *(_WORD *)&v532[26] = 2048;
                          *(_QWORD *)&v532[28] = v63;
                          v533 = 1024;
                          v534 = 1;
                          _os_log_impl(&dword_182FBE000, v152, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u", buf, 0x4Au);
                        }
                      }
                    }
                  }
                  else if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v148 = __nwlog_obj();
                      if (os_log_type_enabled(v148, OS_LOG_TYPE_DEBUG))
                      {
                        v149 = *(_QWORD *)(v63 + 88);
                        if (v149)
                          v150 = *(_DWORD *)(v149 + 460);
                        else
                          v150 = -1;
                        v269 = *(_QWORD *)(v63 + 64);
                        *(_DWORD *)buf = 136447490;
                        *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v150;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v269;
                        *(_WORD *)&v532[16] = 2048;
                        *(_QWORD *)&v532[18] = v269;
                        _os_log_impl(&dword_182FBE000, v148, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping", buf, 0x3Au);
                      }
                    }
                  }
                  v176 = *(_QWORD *)(v63 + 64);
                  v177 = *(_BYTE *)(v63 + 276);
                  if (v176 == -1)
                  {
                    if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
                    {
                      v181 = __nwlog_obj();
                      if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
                      {
                        v182 = *(_QWORD *)(v63 + 88);
                        if (v182)
                          v183 = *(_DWORD *)(v182 + 460);
                        else
                          v183 = -1;
                        v209 = *(_QWORD *)(v63 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v183;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v209;
                        _os_log_impl(&dword_182FBE000, v181, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set", buf, 0x30u);
                        if ((*(_BYTE *)(v63 + 276) & 0x40) != 0)
                          goto LABEL_270;
                        goto LABEL_269;
                      }
                    }
                  }
                  else
                  {
                    *(_BYTE *)(v63 + 276) = v177 & 0xF0 | (4 * ((v176 & 2) != 0)) | 3;
                    if ((v177 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v178 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        v179 = *(_QWORD *)(v63 + 88);
                        if (v179)
                          v180 = *(_DWORD *)(v179 + 460);
                        else
                          v180 = -1;
                        v184 = *(_QWORD *)(v63 + 64);
                        v185 = *(unsigned __int8 *)(v63 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v63 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v180;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v184;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v185 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v185 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v185 >> 2) & 1;
                        _os_log_impl(&dword_182FBE000, v178, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v63 + 160), (*(_BYTE *)(v63 + 276) & 4) != 0);
                  }
                }
                if ((*(_BYTE *)(v63 + 276) & 0x40) != 0)
                  goto LABEL_270;
                goto LABEL_269;
              }
              if ((*(_BYTE *)(v63 + 276) & 0x10) != 0)
                goto LABEL_236;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v132 = gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                goto LABEL_236;
              v133 = *(_QWORD *)(v63 + 88);
              if (v133)
                v134 = *(_DWORD *)(v133 + 460);
              else
                v134 = -1;
              v146 = *(_QWORD *)(v63 + 64);
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v63 + 192;
              *(_WORD *)&buf[22] = 2080;
              v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v134;
              *(_WORD *)&v532[6] = 2048;
              *(_QWORD *)&v532[8] = v146;
              _os_log_impl(&dword_182FBE000, v132, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
              v63 = *(_QWORD *)(v13 + 328);
              if (!v63)
                goto LABEL_720;
            }
LABEL_237:
            if ((*(_BYTE *)(v63 + 276) & 0x10) == 0)
            {
              if (gLogDatapath)
              {
                v163 = __nwlog_obj();
                if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
                {
                  v164 = *(_QWORD *)(v63 + 88);
                  if (v164)
                    v165 = *(_DWORD *)(v164 + 460);
                  else
                    v165 = -1;
                  v218 = *(_QWORD *)(v63 + 64);
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v63 + 192;
                  *(_WORD *)&buf[22] = 2080;
                  v531 = (uint64_t)" ";
                  *(_WORD *)v532 = 1024;
                  *(_DWORD *)&v532[2] = v165;
                  *(_WORD *)&v532[6] = 2048;
                  *(_QWORD *)&v532[8] = v218;
                  *(_WORD *)&v532[16] = 2048;
                  *(_QWORD *)&v532[18] = v63;
                  _os_log_impl(&dword_182FBE000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
                }
              }
            }
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v78 = *(unsigned int *)(v13 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
          *(_WORD *)&buf[22] = 2048;
          v531 = 1;
          *(_WORD *)v532 = 2048;
          *(_QWORD *)&v532[2] = v78;
          v79 = (char *)_os_log_send_and_compose_impl();
          iterate_block[0] = 16;
          type[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v79, iterate_block, type))
          {
            if (iterate_block[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v80 = gLogObj;
              v81 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                v82 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                v531 = 1;
                *(_WORD *)v532 = 2048;
                *(_QWORD *)&v532[2] = v82;
                v83 = v80;
                v84 = v81;
                v85 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_114:
                _os_log_impl(&dword_182FBE000, v83, v84, v85, buf, 0x2Au);
              }
            }
            else if (type[0])
            {
              v88 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v89 = gLogObj;
              v90 = iterate_block[0];
              v91 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
              if (v88)
              {
                if (v91)
                {
                  v92 = *(unsigned int *)(v13 + 456);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
                  *(_WORD *)&buf[22] = 2048;
                  v531 = 1;
                  *(_WORD *)v532 = 2048;
                  *(_QWORD *)&v532[2] = v92;
                  *(_WORD *)&v532[10] = 2082;
                  *(_QWORD *)&v532[12] = v88;
                  _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v88);
                v64 = v520;
                goto LABEL_115;
              }
              v64 = v520;
              if (v91)
              {
                v96 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                v531 = 1;
                *(_WORD *)v532 = 2048;
                *(_QWORD *)&v532[2] = v96;
                v83 = v89;
                v84 = v90;
                v85 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                goto LABEL_114;
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v93 = gLogObj;
              v94 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                v95 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                v531 = 1;
                *(_WORD *)v532 = 2048;
                *(_QWORD *)&v532[2] = v95;
                v83 = v93;
                v84 = v94;
                v85 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_114;
              }
            }
          }
LABEL_115:
          if (v79)
            free(v79);
          *(_DWORD *)(v13 + 456) = 0;
          goto LABEL_118;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
        v484 = (char *)_os_log_send_and_compose_impl();
        iterate_block[0] = 16;
        type[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v484, iterate_block, type))
          goto LABEL_777;
        if (iterate_block[0] == 17)
        {
          v485 = __nwlog_obj();
          v486 = iterate_block[0];
          if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
            goto LABEL_777;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
          v487 = "%{public}s called with null response";
          goto LABEL_775;
        }
        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          v485 = __nwlog_obj();
          v486 = iterate_block[0];
          if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
            goto LABEL_777;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
          v487 = "%{public}s called with null response, backtrace limit exceeded";
          goto LABEL_775;
        }
        v500 = (char *)__nw_create_backtrace_string();
        v497 = __nwlog_obj();
        v498 = iterate_block[0];
        v503 = os_log_type_enabled(v497, (os_log_type_t)iterate_block[0]);
        if (v500)
        {
          if (!v503)
            goto LABEL_765;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v500;
          v502 = "%{public}s called with null response, dumping backtrace:%{public}s";
          goto LABEL_764;
        }
        if (v503)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
          v487 = "%{public}s called with null response, no backtrace";
          goto LABEL_790;
        }
LABEL_777:
        if (!v484)
          goto LABEL_721;
LABEL_778:
        free(v484);
        goto LABEL_721;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
      v484 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v484, iterate_block, type))
        goto LABEL_777;
      if (iterate_block[0] == 17)
      {
        v485 = __nwlog_obj();
        v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
          goto LABEL_777;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
LABEL_775:
        v505 = v485;
        v506 = v486;
LABEL_776:
        _os_log_impl(&dword_182FBE000, v505, v506, v487, buf, 0xCu);
        goto LABEL_777;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v485 = __nwlog_obj();
        v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
          goto LABEL_777;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_775;
      }
      v496 = (char *)__nw_create_backtrace_string();
      v497 = __nwlog_obj();
      v498 = iterate_block[0];
      v499 = os_log_type_enabled(v497, (os_log_type_t)iterate_block[0]);
      if (v496)
      {
        if (v499)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v496;
          _os_log_impl(&dword_182FBE000, v497, v498, "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v496);
        goto LABEL_777;
      }
      if (!v499)
        goto LABEL_777;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_response";
      v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
LABEL_790:
      v505 = v497;
      v506 = v498;
      goto LABEL_776;
    }
    if (nw_protocol_metadata_is_http(v12))
    {
      if ((*(_BYTE *)(v13 + 548) & 2) == 0)
      {
        if (gLogDatapath)
        {
          v490 = __nwlog_obj();
          if (os_log_type_enabled(v490, OS_LOG_TYPE_DEBUG))
          {
            v491 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v491;
            _os_log_impl(&dword_182FBE000, v490, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
          }
        }
      }
      v523 = nw_http_metadata_copy_request(v14);
      if (v523)
      {
        well_known = (void *)_nw_http_response_create_well_known(200);
        metadata_for_response = nw_http_create_metadata_for_response(well_known);
        v34 = *(_QWORD *)(v13 + 32);
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v492 = __nwlog_obj();
            if (os_log_type_enabled(v492, OS_LOG_TYPE_DEBUG))
            {
              v493 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)iterate_block = 136446978;
              *(_QWORD *)&iterate_block[4] = "nw_webtransport_session_send_metadata";
              *(_WORD *)&iterate_block[12] = 2082;
              *(_QWORD *)&iterate_block[14] = v13 + 464;
              *(_WORD *)&iterate_block[22] = 2080;
              v540 = " ";
              LOWORD(v541) = 1024;
              *(_DWORD *)((char *)&v541 + 2) = v493;
              _os_log_impl(&dword_182FBE000, v492, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", iterate_block, 0x26u);
            }
          }
        }
        *(_QWORD *)type = 0;
        v527 = type;
        output_frames = nw_protocol_get_output_frames(v34, v13, 0, 0, 1, (uint64_t)type);
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v494 = __nwlog_obj();
            if (os_log_type_enabled(v494, OS_LOG_TYPE_DEBUG))
            {
              v495 = *(_DWORD *)(v13 + 460);
              *(_DWORD *)iterate_block = 136447234;
              *(_QWORD *)&iterate_block[4] = "nw_webtransport_session_send_metadata";
              *(_WORD *)&iterate_block[12] = 2082;
              *(_QWORD *)&iterate_block[14] = v13 + 464;
              *(_WORD *)&iterate_block[22] = 2080;
              v540 = " ";
              LOWORD(v541) = 1024;
              *(_DWORD *)((char *)&v541 + 2) = v495;
              HIWORD(v541) = 1024;
              LODWORD(v542) = output_frames;
              _os_log_impl(&dword_182FBE000, v494, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got %u output frames", iterate_block, 0x2Cu);
            }
          }
        }
        v522 = metadata_for_response;
        if (!output_frames)
          goto LABEL_48;
        *(_QWORD *)iterate_block = 0;
        *(_QWORD *)&iterate_block[8] = iterate_block;
        *(_QWORD *)&iterate_block[16] = 0x2000000000;
        LOBYTE(v540) = 0;
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke;
        v531 = (uint64_t)&unk_1E14A06A8;
        *(_QWORD *)v532 = iterate_block;
        *(_QWORD *)&v532[8] = type;
        *(_QWORD *)&v532[16] = v13;
        *(_QWORD *)&v532[24] = metadata_for_response;
        v36 = *(_QWORD *)type;
        do
        {
          if (!v36)
            break;
          v37 = *(_QWORD *)(v36 + 32);
          v38 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
          v36 = v37;
        }
        while ((v38 & 1) != 0);
        v39 = nw_protocol_finalize_output_frames(v34, (uint64_t)type);
        _Block_object_dispose(iterate_block, 8);
        if ((v39 & 1) == 0)
        {
LABEL_48:
          if (*(_DWORD *)(v13 + 444) != 5)
          {
            if ((*(_BYTE *)(v13 + 548) & 2) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v51 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
              {
                v52 = *(_DWORD *)(v13 + 460);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v13 + 464;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v52;
                *(_WORD *)&v532[6] = 1024;
                *(_DWORD *)&v532[8] = 57;
                _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", buf, 0x2Cu);
              }
            }
            *(_DWORD *)(v13 + 444) = 5;
            v53 = *(char **)(v13 + 184);
            if (v53)
            {
              *(_QWORD *)buf = MEMORY[0x1E0C809B0];
              *(_QWORD *)&buf[8] = 0x40000000;
              *(_QWORD *)&buf[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
              v531 = (uint64_t)&__block_descriptor_tmp_22_33428;
              *(_DWORD *)v532 = 57;
              nw_hash_table_apply(v53, (uint64_t)buf);
            }
            v54 = *(_QWORD *)(v13 + 424);
            if (v54)
            {
              v55 = *(_QWORD **)(v54 + 48);
              nw_protocol_error(v55, *(_QWORD *)(v13 + 424));
              nw_protocol_disconnected(v55, v54);
            }
            v56 = *(_QWORD *)(v13 + 328);
            if (v56)
            {
              do
              {
                v57 = *(_QWORD *)(v56 + 112);
                v58 = *(_QWORD **)(v56 + 48);
                nw_protocol_error(v58, v56);
                nw_protocol_disconnected(v58, v56);
                v56 = v57;
              }
              while (v57);
            }
            v59 = *(_QWORD *)(v13 + 416);
            if (v59)
            {
              v60 = *(_QWORD **)(v59 + 48);
              nw_protocol_error(v60, *(_QWORD *)(v13 + 416));
              nw_protocol_disconnected(v60, v59);
            }
            if (*(_QWORD *)(v13 + 32))
            {
              nw_protocol_remove_instance(v13);
              nw_protocol_disconnect(*(_QWORD **)(v13 + 32), v13);
            }
            goto LABEL_716;
          }
          if ((*(_BYTE *)(v13 + 548) & 2) != 0
            || (pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once),
                networkd_settings_init(),
                v47 = gLogObj,
                !os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)))
          {
LABEL_716:
            if (v522)
              os_release(v522);
            if (well_known)
              os_release(well_known);
            goto LABEL_720;
          }
          v48 = *(_DWORD *)(v13 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v13 + 464;
          *(_WORD *)&buf[22] = 2080;
          v531 = (uint64_t)" ";
          *(_WORD *)v532 = 1024;
          *(_DWORD *)&v532[2] = v48;
          v43 = "%{public}s %{public}s%s<i%u> Session already terminated, ignoring";
          v44 = v47;
          v45 = OS_LOG_TYPE_INFO;
          v46 = 38;
LABEL_52:
          _os_log_impl(&dword_182FBE000, v44, v45, v43, buf, v46);
          goto LABEL_716;
        }
        if (*(_DWORD *)(v13 + 444) == 4)
        {
          if ((*(_BYTE *)(v13 + 548) & 2) != 0)
            goto LABEL_716;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v40 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            goto LABEL_716;
          v41 = *(_DWORD *)(v13 + 460);
          v42 = *(_DWORD *)(v13 + 444);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_streams_ready";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v13 + 464;
          *(_WORD *)&buf[22] = 2080;
          v531 = (uint64_t)" ";
          *(_WORD *)v532 = 1024;
          *(_DWORD *)&v532[2] = v41;
          *(_WORD *)&v532[6] = 1024;
          *(_DWORD *)&v532[8] = v42;
          v43 = "%{public}s %{public}s%s<i%u> Tried to ready streams with incorrect state: %d, ignoring";
          v44 = v40;
          v45 = OS_LOG_TYPE_ERROR;
          v46 = 44;
          goto LABEL_52;
        }
        *(_DWORD *)(v13 + 444) = 4;
        if ((*(_BYTE *)(v13 + 548) & 2) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v280 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            v281 = *(_DWORD *)(v13 + 460);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_streams_ready";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v13 + 464;
            *(_WORD *)&buf[22] = 2080;
            v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v281;
            _os_log_impl(&dword_182FBE000, v280, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Webtransport session established, reconfiguring streams", buf, 0x26u);
          }
        }
        v282 = *(_QWORD *)(v13 + 328);
        if (!v282)
          goto LABEL_716;
        v515 = well_known;
        if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v510 = __nwlog_obj();
            if (os_log_type_enabled(v510, OS_LOG_TYPE_DEBUG))
            {
              v511 = *(_QWORD *)(v282 + 88);
              if (v511)
                v512 = *(_DWORD *)(v511 + 460);
              else
                v512 = -1;
              v514 = *(_QWORD *)(v282 + 64);
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v282 + 192;
              *(_WORD *)&buf[22] = 2080;
              v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v512;
              *(_WORD *)&v532[6] = 2048;
              *(_QWORD *)&v532[8] = v514;
              *(_WORD *)&v532[16] = 2048;
              *(_QWORD *)&v532[18] = v282;
              _os_log_impl(&dword_182FBE000, v510, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
            }
          }
        }
        v521 = *(_BYTE *)(v13 + 548) & 1;
        while (1)
        {
          if ((*(_BYTE *)(v13 + 548) & 2) == 0)
          {
            if (gLogDatapath)
            {
              v428 = __nwlog_obj();
              if (os_log_type_enabled(v428, OS_LOG_TYPE_DEBUG))
              {
                v429 = *(_DWORD *)(v13 + 460);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v13 + 464;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v429;
                *(_WORD *)&v532[6] = 2048;
                *(_QWORD *)&v532[8] = v282;
                _os_log_impl(&dword_182FBE000, v428, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
              }
            }
          }
          if ((*(_BYTE *)(v282 + 276) & 0x20) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v282;
            v283 = (char *)_os_log_send_and_compose_impl();
            iterate_block[0] = 16;
            type[0] = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v283, iterate_block, type))
              goto LABEL_439;
            if (iterate_block[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v284 = gLogObj;
              v285 = iterate_block[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v282;
                v286 = v284;
                v287 = v285;
                v288 = "%{public}s stream %p not in pending list, cannot remove";
                goto LABEL_438;
              }
              goto LABEL_439;
            }
            if (type[0])
            {
              v291 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v292 = gLogObj;
              v293 = iterate_block[0];
              v294 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
              if (v291)
              {
                if (v294)
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v282;
                  *(_WORD *)&buf[22] = 2082;
                  v531 = (uint64_t)v291;
                  _os_log_impl(&dword_182FBE000, v292, v293, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
                }
                free(v291);
                goto LABEL_439;
              }
              if (!v294)
              {
LABEL_439:
                if (v283)
                  free(v283);
                goto LABEL_451;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v282;
              v286 = v292;
              v287 = v293;
              v288 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v304 = gLogObj;
              v305 = iterate_block[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
                goto LABEL_439;
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v282;
              v286 = v304;
              v287 = v305;
              v288 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            }
LABEL_438:
            _os_log_impl(&dword_182FBE000, v286, v287, v288, buf, 0x16u);
            goto LABEL_439;
          }
          v289 = *(_QWORD *)(v282 + 112);
          v290 = *(_QWORD **)(v282 + 120);
          if (v289)
          {
            *(_QWORD *)(v289 + 120) = v290;
            v290 = *(_QWORD **)(v282 + 120);
          }
          else
          {
            *(_QWORD *)(v13 + 336) = v290;
          }
          *v290 = v289;
          *(_QWORD *)(v282 + 112) = 0;
          *(_QWORD *)(v282 + 120) = 0;
          v295 = *(_DWORD *)(v13 + 456);
          *(_DWORD *)(v13 + 456) = v295 - 1;
          if (!v295)
            break;
LABEL_449:
          v315 = *(_BYTE *)(v282 + 276);
          *(_BYTE *)(v282 + 276) = v315 & 0xDF;
          if ((v315 & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v430 = __nwlog_obj();
              if (os_log_type_enabled(v430, OS_LOG_TYPE_DEBUG))
              {
                v431 = *(_QWORD *)(v282 + 88);
                if (v431)
                  v432 = *(_DWORD *)(v431 + 460);
                else
                  v432 = -1;
                v446 = *(_QWORD *)(v282 + 64);
                v447 = *(_DWORD *)(v13 + 456);
                *(_DWORD *)buf = 136447746;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v432;
                *(_WORD *)&v532[6] = 2048;
                *(_QWORD *)&v532[8] = v446;
                *(_WORD *)&v532[16] = 2048;
                *(_QWORD *)&v532[18] = v282;
                *(_WORD *)&v532[26] = 1024;
                *(_DWORD *)&v532[28] = v447;
                _os_log_impl(&dword_182FBE000, v430, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams", buf, 0x40u);
                well_known = v515;
              }
            }
          }
LABEL_451:
          v316 = *(_DWORD *)(v13 + 448);
          if (v316 != 1)
          {
            if (!v316)
            {
              if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
              {
                if (gLogDatapath)
                {
                  v433 = __nwlog_obj();
                  if (os_log_type_enabled(v433, OS_LOG_TYPE_DEBUG))
                  {
                    v434 = *(_QWORD *)(v282 + 88);
                    if (v434)
                      v435 = *(_DWORD *)(v434 + 460);
                    else
                      v435 = -1;
                    v448 = *(_QWORD *)(v282 + 64);
                    *(_DWORD *)buf = 136447746;
                    *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v435;
                    *(_WORD *)&v532[6] = 2048;
                    *(_QWORD *)&v532[8] = v448;
                    *(_WORD *)&v532[16] = 2048;
                    *(_QWORD *)&v532[18] = v282;
                    *(_WORD *)&v532[26] = 1024;
                    *(_DWORD *)&v532[28] = v521;
                    _os_log_impl(&dword_182FBE000, v433, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP2 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
                    well_known = v515;
                  }
                }
              }
              v317 = *(_QWORD *)(v282 + 88);
              if (*(_QWORD *)(v317 + 416) == v282)
              {
                if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                {
                  if (gLogDatapath)
                  {
                    v437 = __nwlog_obj();
                    if (os_log_type_enabled(v437, OS_LOG_TYPE_DEBUG))
                    {
                      v438 = *(_QWORD *)(v282 + 88);
                      if (v438)
                        v439 = *(_DWORD *)(v438 + 460);
                      else
                        v439 = -1;
                      v469 = *(_QWORD *)(v282 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v439;
                      *(_WORD *)&v532[6] = 2048;
                      *(_QWORD *)&v532[8] = v469;
                      _os_log_impl(&dword_182FBE000, v437, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning without more reconfiguration for placeholder stream", buf, 0x30u);
                      well_known = v515;
                    }
                  }
                }
                nw_protocol_connected(*(_QWORD **)(v282 + 48), v282);
              }
              else
              {
                if (nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken != -1)
                  dispatch_once(&nw_protocol_webtransport_http2_stream_callbacks(void)::onceToken, &__block_literal_global_28);
                *(_QWORD *)(v282 + 24) = &nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks;
                nw_protocol_set_output_handler(v282, v317);
                v318 = nw_parameters_copy_protocol_options_legacy(*(void **)(v282 + 144), (nw_protocol *)v282);
                if (v318)
                {
                  v319 = v318;
                  if (v521)
                  {
                    if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                    {
                      if (gLogDatapath)
                      {
                        v334 = __nwlog_obj();
                        if (os_log_type_enabled(v334, OS_LOG_TYPE_DEBUG))
                        {
                          v335 = *(_QWORD *)(v282 + 88);
                          if (v335)
                            v336 = *(_DWORD *)(v335 + 460);
                          else
                            v336 = -1;
                          v472 = *(_QWORD *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v336;
                          *(_WORD *)&v532[6] = 2048;
                          *(_QWORD *)&v532[8] = v472;
                          _os_log_impl(&dword_182FBE000, v334, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Waiting for connected callback and stream ID assignment to setup metadata", buf, 0x30u);
                          well_known = v515;
                        }
                      }
                    }
                  }
                  else if (nw_protocol_options_is_webtransport(v318))
                  {
                    *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xFC | 1;
                    if (nw_webtransport_options_get_is_datagram(v319))
                      v320 = 8;
                    else
                      v320 = 0;
                    *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xF7 | v320;
                    v321 = nw_webtransport_options_get_is_unidirectional(v319);
                    v322 = *(_BYTE *)(v282 + 276);
                    if (v321)
                      v323 = 4;
                    else
                      v323 = 0;
                    *(_BYTE *)(v282 + 276) = v322 & 0xFB | v323;
                    if ((v322 & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      v324 = gLogObj;
                      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                      {
                        v325 = *(_QWORD *)(v282 + 88);
                        if (v325)
                          v326 = *(_DWORD *)(v325 + 460);
                        else
                          v326 = -1;
                        v373 = *(_QWORD *)(v282 + 64);
                        v374 = *(unsigned __int8 *)(v282 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v326;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v373;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v374 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v374 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v374 >> 2) & 1;
                        _os_log_impl(&dword_182FBE000, v324, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 4) != 0);
                  }
                  else if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v356 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                    {
                      v357 = *(_QWORD *)(v282 + 88);
                      if (v357)
                        v358 = *(_DWORD *)(v357 + 460);
                      else
                        v358 = -1;
                      v380 = *(_QWORD *)(v282 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v358;
                      *(_WORD *)&v532[6] = 2048;
                      *(_QWORD *)&v532[8] = v380;
                      _os_log_impl(&dword_182FBE000, v356, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                    }
                  }
                  os_release(v319);
                }
                else if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v331 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  {
                    v332 = *(_QWORD *)(v282 + 88);
                    if (v332)
                      v333 = *(_DWORD *)(v332 + 460);
                    else
                      v333 = -1;
                    v363 = *(_QWORD *)(v282 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "nw_webtransport_http2_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v333;
                    *(_WORD *)&v532[6] = 2048;
                    *(_QWORD *)&v532[8] = v363;
                    _os_log_impl(&dword_182FBE000, v331, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
                  }
                }
              }
              if (v282 != *(_QWORD *)(v13 + 416))
                nw_protocol_connected((_QWORD *)v282, v13);
            }
LABEL_567:
            v282 = *(_QWORD *)(v13 + 328);
            if (!v282)
              goto LABEL_716;
            goto LABEL_568;
          }
          v327 = *(_QWORD *)(v282 + 88);
          if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v328 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              v329 = *(_QWORD *)(v282 + 88);
              if (v329)
                v330 = *(_DWORD *)(v329 + 460);
              else
                v330 = -1;
              v337 = *(_QWORD *)(v282 + 64);
              *(_DWORD *)buf = 136447746;
              *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v282 + 192;
              *(_WORD *)&buf[22] = 2080;
              v531 = (uint64_t)" ";
              *(_WORD *)v532 = 1024;
              *(_DWORD *)&v532[2] = v330;
              *(_WORD *)&v532[6] = 2048;
              *(_QWORD *)&v532[8] = v337;
              *(_WORD *)&v532[16] = 2048;
              *(_QWORD *)&v532[18] = v282;
              *(_WORD *)&v532[26] = 1024;
              *(_DWORD *)&v532[28] = v521;
              _os_log_impl(&dword_182FBE000, v328, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Reconfiguring HTTP3 stream with protocol: %p, peer_initiated: %u", buf, 0x40u);
            }
          }
          if (*(_QWORD *)(v327 + 416) == v282)
          {
            if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v347 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
              {
                v348 = *(_QWORD *)(v282 + 88);
                if (v348)
                  v349 = *(_DWORD *)(v348 + 460);
                else
                  v349 = -1;
                v362 = *(_QWORD *)(v282 + 64);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v349;
                *(_WORD *)&v532[6] = 2048;
                *(_QWORD *)&v532[8] = v362;
                _os_log_impl(&dword_182FBE000, v347, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Returning connected without more reconfiguration for placeholder stream", buf, 0x30u);
              }
            }
            nw_protocol_connected(*(_QWORD **)(v282 + 48), v282);
            v282 = *(_QWORD *)(v13 + 328);
            if (!v282)
              goto LABEL_716;
          }
          else
          {
            v338 = nw_parameters_copy_protocol_options_legacy(*(void **)(v282 + 144), (nw_protocol *)v282);
            if (v338)
            {
              v339 = v338;
              if (nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken != -1)
                dispatch_once(&nw_protocol_webtransport_http3_stream_callbacks(void)::onceToken, &__block_literal_global_42_33727);
              *(_QWORD *)(v282 + 24) = &nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks;
              stacka = v339;
              if (v521)
              {
                if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v353 = gLogObj;
                  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    v354 = *(_QWORD *)(v282 + 88);
                    if (v354)
                      v355 = *(_DWORD *)(v354 + 460);
                    else
                      v355 = -1;
                    v365 = *(_QWORD *)(v282 + 64);
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v282 + 192;
                    *(_WORD *)&buf[22] = 2080;
                    v531 = (uint64_t)" ";
                    *(_WORD *)v532 = 1024;
                    *(_DWORD *)&v532[2] = v355;
                    *(_WORD *)&v532[6] = 2048;
                    *(_QWORD *)&v532[8] = v365;
                    _os_log_impl(&dword_182FBE000, v353, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Preemptively configuring metadata with incoming stream ID", buf, 0x30u);
                  }
                }
                if (*(_QWORD *)(v327 + 176) != -1)
                {
                  if (*(_QWORD *)(v282 + 64) == -1)
                  {
                    v369 = *(_QWORD *)(*(_QWORD *)(v282 + 88) + 176);
                    if (v369 == -1)
                    {
                      if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                      {
                        v385 = __nwlog_obj();
                        if (os_log_type_enabled(v385, OS_LOG_TYPE_ERROR))
                        {
                          v386 = *(_QWORD *)(v282 + 88);
                          if (v386)
                            v387 = *(_DWORD *)(v386 + 460);
                          else
                            v387 = -1;
                          v392 = *(_QWORD *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v387;
                          *(_WORD *)&v532[6] = 2048;
                          *(_QWORD *)&v532[8] = v392;
                          _os_log_impl(&dword_182FBE000, v385, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing", buf, 0x30u);
                        }
                      }
                      v393 = *(_QWORD **)(v282 + 48);
                      nw_protocol_error(v393, v282);
                      nw_protocol_disconnected(v393, v282);
                    }
                    else
                    {
                      *(_QWORD *)(v282 + 64) = v369;
                      nw_webtransport_metadata_set_stream_id(*(void **)(v282 + 160), v369);
                      if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                      {
                        v370 = __nwlog_obj();
                        if (os_log_type_enabled(v370, OS_LOG_TYPE_INFO))
                        {
                          v371 = *(_QWORD *)(v282 + 88);
                          if (v371)
                            v372 = *(_DWORD *)(v371 + 460);
                          else
                            v372 = -1;
                          v391 = *(_QWORD *)(v282 + 64);
                          *(_DWORD *)buf = 136448002;
                          *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v372;
                          *(_WORD *)&v532[6] = 2048;
                          *(_QWORD *)&v532[8] = v391;
                          *(_WORD *)&v532[16] = 2048;
                          *(_QWORD *)&v532[18] = v391;
                          *(_WORD *)&v532[26] = 2048;
                          *(_QWORD *)&v532[28] = v282;
                          v533 = 1024;
                          v534 = 1;
                          _os_log_impl(&dword_182FBE000, v370, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u", buf, 0x4Au);
                        }
                      }
                    }
                  }
                  else if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                  {
                    if (gLogDatapath)
                    {
                      v366 = __nwlog_obj();
                      if (os_log_type_enabled(v366, OS_LOG_TYPE_DEBUG))
                      {
                        v367 = *(_QWORD *)(v282 + 88);
                        if (v367)
                          v368 = *(_DWORD *)(v367 + 460);
                        else
                          v368 = -1;
                        v482 = *(_QWORD *)(v282 + 64);
                        *(_DWORD *)buf = 136447490;
                        *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_assign_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v368;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v482;
                        *(_WORD *)&v532[16] = 2048;
                        *(_QWORD *)&v532[18] = v482;
                        _os_log_impl(&dword_182FBE000, v366, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping", buf, 0x3Au);
                        well_known = v515;
                      }
                    }
                  }
                  v394 = *(_QWORD *)(v282 + 64);
                  v395 = *(_BYTE *)(v282 + 276);
                  if (v394 == -1)
                  {
                    if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                    {
                      v399 = __nwlog_obj();
                      if (os_log_type_enabled(v399, OS_LOG_TYPE_ERROR))
                      {
                        v400 = *(_QWORD *)(v282 + 88);
                        if (v400)
                          v401 = *(_DWORD *)(v400 + 460);
                        else
                          v401 = -1;
                        v404 = *(_QWORD *)(v282 + 64);
                        *(_DWORD *)buf = 136447234;
                        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v401;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v404;
                        _os_log_impl(&dword_182FBE000, v399, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set", buf, 0x30u);
                      }
                    }
                  }
                  else
                  {
                    *(_BYTE *)(v282 + 276) = v395 & 0xF0 | (4 * ((v394 & 2) != 0)) | 3;
                    if ((v395 & 0x10) == 0)
                    {
                      v396 = __nwlog_obj();
                      if (os_log_type_enabled(v396, OS_LOG_TYPE_INFO))
                      {
                        v397 = *(_QWORD *)(v282 + 88);
                        if (v397)
                          v398 = *(_DWORD *)(v397 + 460);
                        else
                          v398 = -1;
                        v402 = *(_QWORD *)(v282 + 64);
                        v403 = *(unsigned __int8 *)(v282 + 276);
                        *(_DWORD *)buf = 136448002;
                        *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_stream_id";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v282 + 192;
                        *(_WORD *)&buf[22] = 2080;
                        v531 = (uint64_t)" ";
                        *(_WORD *)v532 = 1024;
                        *(_DWORD *)&v532[2] = v398;
                        *(_WORD *)&v532[6] = 2048;
                        *(_QWORD *)&v532[8] = v402;
                        *(_WORD *)&v532[16] = 1024;
                        *(_DWORD *)&v532[18] = (v403 >> 1) & 1;
                        *(_WORD *)&v532[22] = 1024;
                        *(_DWORD *)&v532[24] = (v403 >> 3) & 1;
                        *(_WORD *)&v532[28] = 1024;
                        *(_DWORD *)&v532[30] = (v403 >> 2) & 1;
                        _os_log_impl(&dword_182FBE000, v396, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                      }
                    }
                    nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 2) != 0);
                    nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 8) != 0);
                    nw_webtransport_metadata_set_is_unidirectional(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 4) != 0);
                  }
                }
                if ((*(_BYTE *)(v282 + 276) & 0x40) != 0)
                  goto LABEL_603;
              }
              else
              {
                if (nw_protocol_options_is_webtransport(v339))
                {
                  *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xFC | 1;
                  if (nw_webtransport_options_get_is_datagram(v339))
                    v340 = 8;
                  else
                    v340 = 0;
                  *(_BYTE *)(v282 + 276) = *(_BYTE *)(v282 + 276) & 0xF7 | v340;
                  v341 = nw_webtransport_options_get_is_unidirectional(v339);
                  v342 = *(_BYTE *)(v282 + 276);
                  if (v341)
                    v343 = 4;
                  else
                    v343 = 0;
                  *(_BYTE *)(v282 + 276) = v342 & 0xFB | v343;
                  if ((v342 & 0x10) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v344 = gLogObj;
                    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                    {
                      v345 = *(_QWORD *)(v282 + 88);
                      if (v345)
                        v346 = *(_DWORD *)(v345 + 460);
                      else
                        v346 = -1;
                      v375 = *(_QWORD *)(v282 + 64);
                      v376 = *(unsigned __int8 *)(v282 + 276);
                      *(_DWORD *)buf = 136448002;
                      *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v346;
                      *(_WORD *)&v532[6] = 2048;
                      *(_QWORD *)&v532[8] = v375;
                      *(_WORD *)&v532[16] = 1024;
                      *(_DWORD *)&v532[18] = (v376 >> 1) & 1;
                      *(_WORD *)&v532[22] = 1024;
                      *(_DWORD *)&v532[24] = (v376 >> 3) & 1;
                      *(_WORD *)&v532[28] = 1024;
                      *(_DWORD *)&v532[30] = (v376 >> 2) & 1;
                      _os_log_impl(&dword_182FBE000, v344, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                    }
                  }
                  nw_webtransport_metadata_set_is_peer_initiated(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 2) != 0);
                  nw_webtransport_metadata_set_is_datagram(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 8) != 0);
                  nw_webtransport_metadata_set_is_unidirectional(*(void **)(v282 + 160), (*(_BYTE *)(v282 + 276) & 4) != 0);
LABEL_554:
                  if ((*(_BYTE *)(v282 + 276) & 8) == 0)
                    goto LABEL_555;
LABEL_575:
                  nw_protocol_connected((_QWORD *)v282, v327);
LABEL_603:
                  v405 = *(_QWORD *)(v327 + 32);
                  if (v405)
                  {
                    if ((*(_BYTE *)(v327 + 548) & 0x40) == 0)
                    {
                      v339 = stacka;
                      if (!nw_protocol_add_input_handler(*(_QWORD *)(v327 + 32), v282))
                        goto LABEL_698;
LABEL_633:
                      if (*(_QWORD *)(v282 + 32))
                      {
                        v426 = *(_QWORD *)(v282 + 176);
                        v427 = *(void **)(v327 + 392);
                        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                        *(_QWORD *)&buf[8] = 0x40000000;
                        *(_QWORD *)&buf[16] = ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke;
                        v531 = (uint64_t)&unk_1E14A05F8;
                        *(_QWORD *)v532 = v426;
                        nw_queue_context_async(v427, buf);
                        goto LABEL_706;
                      }
LABEL_698:
                      if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v477 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                        {
                          v478 = *(_QWORD *)(v282 + 88);
                          if (v478)
                            v479 = *(_DWORD *)(v478 + 460);
                          else
                            v479 = -1;
                          v480 = *(_QWORD *)(v282 + 64);
                          *(_DWORD *)buf = 136447234;
                          *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v282 + 192;
                          *(_WORD *)&buf[22] = 2080;
                          v531 = (uint64_t)" ";
                          *(_WORD *)v532 = 1024;
                          *(_DWORD *)&v532[2] = v479;
                          *(_WORD *)&v532[6] = 2048;
                          *(_QWORD *)&v532[8] = v480;
                          v389 = v477;
                          v390 = "%{public}s %{public}s%s<i%u:s%lld> no http3 output handler for webtransport http3 stream";
                          goto LABEL_704;
                        }
                      }
                      goto LABEL_705;
                    }
                    v406 = (void *)nw_protocol_get_parameters(v282);
                    if (v406)
                    {
                      v407 = v406;
                      nw_parameters_log_protocol_instances(v406);
                      v408 = v407;
                      v516 = v408[19];

                      *(_QWORD *)type = 0;
                      v527 = type;
                      v528 = 0x2000000000;
                      v529 = 0;
                      *(_QWORD *)buf = 0;
                      *(_QWORD *)&buf[8] = buf;
                      *(_QWORD *)&buf[16] = 0x3802000000;
                      v531 = (uint64_t)__Block_byref_object_copy__33462;
                      *(_QWORD *)v532 = __Block_byref_object_dispose__33463;
                      *(_QWORD *)&v532[8] = 0;
                      v532[16] |= 1u;
                      *(_QWORD *)iterate_block = MEMORY[0x1E0C809B0];
                      *(_QWORD *)&iterate_block[8] = 0x40000000;
                      *(_QWORD *)&iterate_block[16] = ___ZL45nw_webtransport_session_add_to_http_messagingP23nw_webtransport_sessionP11nw_protocolS2__block_invoke;
                      v540 = (const char *)&unk_1E14A0660;
                      v541 = type;
                      v542 = buf;
                      v543 = v282;
                      nw_protocol_stack_iterate_application_protocols(v516, iterate_block);
                      v409 = *(void **)(*(_QWORD *)&buf[8] + 40);
                      if (v409)
                      {
                        if (nw_protocol_copy_http_messaging_definition_onceToken != -1)
                          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_57_72293);
                        v410 = (id)nw_protocol_copy_http_messaging_definition_definition;
                        v411 = v409;
                        v411[2] = v405;

                        if (v410)
                          os_release(v410);
                        v412 = (void *)nw_protocol_get_parameters(v405);
                        if (v412)
                        {
                          v413 = v412;
                          v414 = v413[19];

                          v415 = v408;
                          v416 = v408[19];

                          v417 = v2;
                          v418 = v14;
                          v419 = nw_protocol_stack_copy_transport_protocol(v414);
                          v420 = nw_protocol_stack_copy_transport_protocol(v416);
                          v421 = v420;
                          if (v419)
                          {
                            if (v420)
                            {
                              v422 = nw_protocol_options_copy_definition(v419);
                              if (nw_protocol_options_matches_definition(v421, v422))
                              {
                                v423 = nw_protocol_options_get_protocol_handle(v419);
                                nw_parameters_set_protocol_instance(v421, v424, v423);
                              }
                              os_release(v421);
                            }
                            v421 = v419;
LABEL_621:
                            os_release(v421);
                          }
                          else if (v420)
                          {
                            goto LABEL_621;
                          }
                          v14 = v418;
                          if (v416)
                            os_release(v416);
                          v2 = v417;
                          if (v414)
                            os_release(v414);
                        }
                        nw_protocol_set_output_handler(v282, 0);
                        v425 = nw_protocol_add_input_handler(v405, v282);
LABEL_627:
                        _Block_object_dispose(buf, 8);
                        well_known = v515;
                        v339 = stacka;
                        if ((v532[16] & 1) != 0 && *(_QWORD *)&v532[8])
                          os_release(*(void **)&v532[8]);
                        _Block_object_dispose(type, 8);
                        if (v516)
                          os_release(v516);
                        if ((v425 & 1) != 0)
                          goto LABEL_633;
                        goto LABEL_698;
                      }
                      __nwlog_obj();
                      *(_DWORD *)v535 = 136446210;
                      v536 = "nw_webtransport_session_add_to_http_messaging";
                      v451 = (char *)_os_log_send_and_compose_impl();
                      v525 = OS_LOG_TYPE_ERROR;
                      v524 = 0;
                      if (!__nwlog_fault(v451, &v525, &v524))
                        goto LABEL_711;
                      if (v525 == OS_LOG_TYPE_FAULT)
                      {
                        v452 = __nwlog_obj();
                        v453 = v525;
                        if (os_log_type_enabled(v452, v525))
                        {
                          *(_DWORD *)v535 = 136446210;
                          v536 = "nw_webtransport_session_add_to_http_messaging";
                          v454 = v452;
                          v455 = v453;
                          v456 = "%{public}s called with null options";
                          goto LABEL_710;
                        }
                        goto LABEL_711;
                      }
                      if (v524)
                      {
                        v465 = (char *)__nw_create_backtrace_string();
                        v466 = __nwlog_obj();
                        v467 = v525;
                        v468 = os_log_type_enabled(v466, v525);
                        if (v465)
                        {
                          if (v468)
                          {
                            *(_DWORD *)v535 = 136446466;
                            v536 = "nw_webtransport_session_add_to_http_messaging";
                            v537 = 2082;
                            v538 = v465;
                            _os_log_impl(&dword_182FBE000, v466, v467, "%{public}s called with null options, dumping backtrace:%{public}s", v535, 0x16u);
                          }
                          free(v465);
                          goto LABEL_711;
                        }
                        if (!v468)
                        {
LABEL_711:
                          if (v451)
                            free(v451);
                          v425 = 0;
                          goto LABEL_627;
                        }
                        *(_DWORD *)v535 = 136446210;
                        v536 = "nw_webtransport_session_add_to_http_messaging";
                        v454 = v466;
                        v455 = v467;
                        v456 = "%{public}s called with null options, no backtrace";
                      }
                      else
                      {
                        v475 = __nwlog_obj();
                        v476 = v525;
                        if (!os_log_type_enabled(v475, v525))
                          goto LABEL_711;
                        *(_DWORD *)v535 = 136446210;
                        v536 = "nw_webtransport_session_add_to_http_messaging";
                        v454 = v475;
                        v455 = v476;
                        v456 = "%{public}s called with null options, backtrace limit exceeded";
                      }
LABEL_710:
                      _os_log_impl(&dword_182FBE000, v454, v455, v456, v535, 0xCu);
                      goto LABEL_711;
                    }
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                    v440 = (char *)_os_log_send_and_compose_impl();
                    type[0] = OS_LOG_TYPE_ERROR;
                    v535[0] = 0;
                    if (!__nwlog_fault(v440, type, v535))
                      goto LABEL_695;
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v449 = __nwlog_obj();
                      v450 = type[0];
                      if (os_log_type_enabled(v449, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                        v443 = v449;
                        v444 = v450;
                        v445 = "%{public}s called with null parameters";
                        goto LABEL_694;
                      }
LABEL_695:
                      if (v440)
LABEL_696:
                        free(v440);
LABEL_697:
                      well_known = v515;
                      v339 = stacka;
                      goto LABEL_698;
                    }
                    if (v535[0])
                    {
                      v461 = (char *)__nw_create_backtrace_string();
                      v462 = __nwlog_obj();
                      v463 = type[0];
                      v464 = os_log_type_enabled(v462, type[0]);
                      if (v461)
                      {
                        if (v464)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v461;
                          _os_log_impl(&dword_182FBE000, v462, v463, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
                        }
                        free(v461);
                        if (v440)
                          goto LABEL_696;
                        goto LABEL_697;
                      }
                      if (!v464)
                        goto LABEL_695;
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v443 = v462;
                      v444 = v463;
                      v445 = "%{public}s called with null parameters, no backtrace";
                    }
                    else
                    {
                      v473 = __nwlog_obj();
                      v474 = type[0];
                      if (!os_log_type_enabled(v473, type[0]))
                        goto LABEL_695;
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_http_messaging";
                      v443 = v473;
                      v444 = v474;
                      v445 = "%{public}s called with null parameters, backtrace limit exceeded";
                    }
                  }
                  else
                  {
                    __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                    v440 = (char *)_os_log_send_and_compose_impl();
                    iterate_block[0] = 16;
                    type[0] = OS_LOG_TYPE_DEFAULT;
                    if (!__nwlog_fault(v440, iterate_block, type))
                      goto LABEL_695;
                    if (iterate_block[0] == 17)
                    {
                      v441 = __nwlog_obj();
                      v442 = iterate_block[0];
                      if (os_log_type_enabled(v441, (os_log_type_t)iterate_block[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                        v443 = v441;
                        v444 = v442;
                        v445 = "%{public}s called with null transport_protocol";
                        goto LABEL_694;
                      }
                      goto LABEL_695;
                    }
                    if (type[0])
                    {
                      v457 = (char *)__nw_create_backtrace_string();
                      v458 = __nwlog_obj();
                      v459 = iterate_block[0];
                      v460 = os_log_type_enabled(v458, (os_log_type_t)iterate_block[0]);
                      if (v457)
                      {
                        if (v460)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v457;
                          _os_log_impl(&dword_182FBE000, v458, v459, "%{public}s called with null transport_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                        }
                        free(v457);
                        goto LABEL_695;
                      }
                      if (!v460)
                        goto LABEL_695;
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                      v443 = v458;
                      v444 = v459;
                      v445 = "%{public}s called with null transport_protocol, no backtrace";
                    }
                    else
                    {
                      v470 = __nwlog_obj();
                      v471 = iterate_block[0];
                      if (!os_log_type_enabled(v470, (os_log_type_t)iterate_block[0]))
                        goto LABEL_695;
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_webtransport_session_add_to_transport";
                      v443 = v470;
                      v444 = v471;
                      v445 = "%{public}s called with null transport_protocol, backtrace limit exceeded";
                    }
                  }
LABEL_694:
                  _os_log_impl(&dword_182FBE000, v443, v444, v445, buf, 0xCu);
                  goto LABEL_695;
                }
                if ((*(_BYTE *)(v282 + 276) & 0x10) != 0)
                  goto LABEL_554;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v359 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  goto LABEL_554;
                v360 = *(_QWORD *)(v282 + 88);
                if (v360)
                  v361 = *(_DWORD *)(v360 + 460);
                else
                  v361 = -1;
                v384 = *(_QWORD *)(v282 + 64);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_stream_configure_metadata_with_options";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v361;
                *(_WORD *)&v532[6] = 2048;
                *(_QWORD *)&v532[8] = v384;
                _os_log_impl(&dword_182FBE000, v359, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Invalid protocol options for webtransport stream", buf, 0x30u);
                if ((*(_BYTE *)(v282 + 276) & 8) != 0)
                  goto LABEL_575;
LABEL_555:
                nw_protocol_set_output_handler(v282, 0);
                *(_QWORD *)(v282 + 56) = 0;
                if (!*(_QWORD *)(v327 + 376))
                {
                  if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
                  {
                    v377 = __nwlog_obj();
                    if (os_log_type_enabled(v377, OS_LOG_TYPE_ERROR))
                    {
                      v378 = *(_QWORD *)(v282 + 88);
                      if (v378)
                        v379 = *(_DWORD *)(v378 + 460);
                      else
                        v379 = -1;
                      v388 = *(_QWORD *)(v282 + 64);
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v282 + 192;
                      *(_WORD *)&buf[22] = 2080;
                      v531 = (uint64_t)" ";
                      *(_WORD *)v532 = 1024;
                      *(_DWORD *)&v532[2] = v379;
                      *(_WORD *)&v532[6] = 2048;
                      *(_QWORD *)&v532[8] = v388;
                      v389 = v377;
                      v390 = "%{public}s %{public}s%s<i%u:s%lld> no http connection metadata when attempting to start web"
                             "transport http3 stream";
LABEL_704:
                      _os_log_impl(&dword_182FBE000, v389, OS_LOG_TYPE_ERROR, v390, buf, 0x30u);
                    }
                  }
LABEL_705:
                  v481 = *(_QWORD **)(v282 + 48);
                  nw_protocol_error(v481, v282);
                  nw_protocol_disconnected(v481, v282);
LABEL_706:
                  os_release(v339);
                  v282 = *(_QWORD *)(v13 + 328);
                  if (!v282)
                    goto LABEL_716;
                  goto LABEL_568;
                }
                if ((*(_BYTE *)(v282 + 276) & 0x40) != 0)
                  goto LABEL_603;
              }
              nw_webtransport_http3_stream_fix_http_parameters(v327, v282);
              goto LABEL_603;
            }
            if ((*(_BYTE *)(v282 + 276) & 0x10) != 0)
              goto LABEL_567;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v350 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              goto LABEL_567;
            v351 = *(_QWORD *)(v282 + 88);
            if (v351)
              v352 = *(_DWORD *)(v351 + 460);
            else
              v352 = -1;
            v364 = *(_QWORD *)(v282 + 64);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_http3_stream_reconfigure_and_start";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v282 + 192;
            *(_WORD *)&buf[22] = 2080;
            v531 = (uint64_t)" ";
            *(_WORD *)v532 = 1024;
            *(_DWORD *)&v532[2] = v352;
            *(_WORD *)&v532[6] = 2048;
            *(_QWORD *)&v532[8] = v364;
            _os_log_impl(&dword_182FBE000, v350, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Could not find options for stream when reconfiguring", buf, 0x30u);
            v282 = *(_QWORD *)(v13 + 328);
            if (!v282)
              goto LABEL_716;
          }
LABEL_568:
          if ((*(_BYTE *)(v282 + 276) & 0x10) == 0)
          {
            if (gLogDatapath)
            {
              v381 = __nwlog_obj();
              if (os_log_type_enabled(v381, OS_LOG_TYPE_DEBUG))
              {
                v382 = *(_QWORD *)(v282 + 88);
                if (v382)
                  v383 = *(_DWORD *)(v382 + 460);
                else
                  v383 = -1;
                v436 = *(_QWORD *)(v282 + 64);
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v282 + 192;
                *(_WORD *)&buf[22] = 2080;
                v531 = (uint64_t)" ";
                *(_WORD *)v532 = 1024;
                *(_DWORD *)&v532[2] = v383;
                *(_WORD *)&v532[6] = 2048;
                *(_QWORD *)&v532[8] = v436;
                *(_WORD *)&v532[16] = 2048;
                *(_QWORD *)&v532[18] = v282;
                _os_log_impl(&dword_182FBE000, v381, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
              }
            }
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v296 = *(unsigned int *)(v13 + 456);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
        *(_WORD *)&buf[22] = 2048;
        v531 = 1;
        *(_WORD *)v532 = 2048;
        *(_QWORD *)&v532[2] = v296;
        v297 = (char *)_os_log_send_and_compose_impl();
        iterate_block[0] = 16;
        type[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v297, iterate_block, type))
        {
          if (iterate_block[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v298 = gLogObj;
            v299 = iterate_block[0];
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
            {
              v300 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v531 = 1;
              *(_WORD *)v532 = 2048;
              *(_QWORD *)&v532[2] = v300;
              v301 = v298;
              v302 = v299;
              v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_445:
              _os_log_impl(&dword_182FBE000, v301, v302, v303, buf, 0x2Au);
            }
          }
          else if (type[0])
          {
            v306 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v307 = gLogObj;
            v308 = iterate_block[0];
            v309 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]);
            if (v306)
            {
              if (v309)
              {
                v310 = *(unsigned int *)(v13 + 456);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
                *(_WORD *)&buf[22] = 2048;
                v531 = 1;
                *(_WORD *)v532 = 2048;
                *(_QWORD *)&v532[2] = v310;
                *(_WORD *)&v532[10] = 2082;
                *(_QWORD *)&v532[12] = v306;
                _os_log_impl(&dword_182FBE000, v307, v308, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v306);
              well_known = v515;
              goto LABEL_446;
            }
            well_known = v515;
            if (v309)
            {
              v314 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v531 = 1;
              *(_WORD *)v532 = 2048;
              *(_QWORD *)&v532[2] = v314;
              v301 = v307;
              v302 = v308;
              v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_445;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v311 = gLogObj;
            v312 = iterate_block[0];
            if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)iterate_block[0]))
            {
              v313 = *(unsigned int *)(v13 + 456);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = "webtransport_session->pending_stream_count";
              *(_WORD *)&buf[22] = 2048;
              v531 = 1;
              *(_WORD *)v532 = 2048;
              *(_QWORD *)&v532[2] = v313;
              v301 = v311;
              v302 = v312;
              v303 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_445;
            }
          }
        }
LABEL_446:
        if (v297)
          free(v297);
        *(_DWORD *)(v13 + 456) = 0;
        goto LABEL_449;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
      v484 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v484, iterate_block, type))
        goto LABEL_777;
      if (iterate_block[0] == 17)
      {
        v485 = __nwlog_obj();
        v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
          goto LABEL_777;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null request";
        goto LABEL_775;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v485 = __nwlog_obj();
        v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
          goto LABEL_777;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null request, backtrace limit exceeded";
        goto LABEL_775;
      }
      v500 = (char *)__nw_create_backtrace_string();
      v497 = __nwlog_obj();
      v498 = iterate_block[0];
      v504 = os_log_type_enabled(v497, (os_log_type_t)iterate_block[0]);
      if (!v500)
      {
        if (v504)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
          v487 = "%{public}s called with null request, no backtrace";
          goto LABEL_790;
        }
        goto LABEL_777;
      }
      if (!v504)
        goto LABEL_765;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v500;
      v502 = "%{public}s called with null request, dumping backtrace:%{public}s";
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
      v484 = (char *)_os_log_send_and_compose_impl();
      iterate_block[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v484, iterate_block, type))
        goto LABEL_777;
      if (iterate_block[0] == 17)
      {
        v485 = __nwlog_obj();
        v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
          goto LABEL_777;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata)";
        goto LABEL_775;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v485 = __nwlog_obj();
        v486 = iterate_block[0];
        if (!os_log_type_enabled(v485, (os_log_type_t)iterate_block[0]))
          goto LABEL_777;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), backtrace limit exceeded";
        goto LABEL_775;
      }
      v500 = (char *)__nw_create_backtrace_string();
      v497 = __nwlog_obj();
      v498 = iterate_block[0];
      v501 = os_log_type_enabled(v497, (os_log_type_t)iterate_block[0]);
      if (!v500)
      {
        if (!v501)
          goto LABEL_777;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
        v487 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), no backtrace";
        goto LABEL_790;
      }
      if (!v501)
        goto LABEL_765;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_handle_connect_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v500;
      v502 = "%{public}s called with null nw_protocol_metadata_is_http(metadata), dumping backtrace:%{public}s";
    }
LABEL_764:
    _os_log_impl(&dword_182FBE000, v497, v498, v502, buf, 0x16u);
LABEL_765:
    free(v500);
    if (!v484)
      goto LABEL_721;
    goto LABEL_778;
  }
  if (!v13 || (*(_BYTE *)(v13 + 548) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v26 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v27 = *(_QWORD *)(a1 + 40);
      v28 = (const char *)(v27 + 464);
      v29 = "";
      v30 = v27 == 0;
      v31 = *(_DWORD *)(v27 + 460);
      if (v30)
        v28 = "";
      *(_QWORD *)&buf[4] = "nw_webtransport_session_http_get_input_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(_DWORD *)buf = 136446978;
      if (!v30)
        v29 = " ";
      *(_QWORD *)&buf[14] = v28;
      *(_WORD *)&buf[22] = 2080;
      v531 = (uint64_t)v29;
      *(_WORD *)v532 = 1024;
      *(_DWORD *)&v532[2] = v31;
      _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Received unexpected input frame without HTTP metadata", buf, 0x26u);
    }
  }
  nw_frame_finalize(v2);
  return 1;
}

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t nw_webtransport_session_get_stream(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;

  v3 = a2;
  result = *(_QWORD *)(a1 + 184);
  if (result)
  {
    result = nw_hash_table_get_node(result, (uint64_t)&v3, 8);
    if (result)
      return *(_QWORD *)(result + 16);
  }
  return result;
}

void nw_protocol_webtransport_stream_error(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  uint64_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_error";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_error";
      v8 = "%{public}s called with null protocol";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v13 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_webtransport_stream_error";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_54:
        if (!v5)
          return;
        goto LABEL_55;
      }
      if (!v13)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_error";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_error";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_53;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_error";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_54;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v19)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_error";
        v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_53;
      }
      v14 = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v15 = os_log_type_enabled(v6, type);
      if (!v14)
      {
        if (!v15)
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_error";
        v8 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_53;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_protocol_webtransport_stream_error";
        v23 = 2082;
        v24 = v14;
        v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v6, v7, v16, buf, 0x16u);
      }
LABEL_37:
      free(v14);
      if (!v5)
        return;
LABEL_55:
      free(v5);
      return;
    }
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_54;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_error";
    v8 = "%{public}s called with null webtransport_stream";
LABEL_53:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_54;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_error";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_error";
      v8 = "%{public}s called with null other_protocol";
      goto LABEL_53;
    }
    if (!v19)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_error";
      v8 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_53;
    }
    v14 = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v17 = os_log_type_enabled(v6, type);
    if (!v14)
    {
      if (!v17)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_error";
      v8 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_53;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_webtransport_stream_error";
      v23 = 2082;
      v24 = v14;
      v16 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v9 = __nwlog_obj();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v10 = handle[11];
        if (v10)
          v11 = *(_DWORD *)(v10 + 460);
        else
          v11 = -1;
        v18 = handle[8];
        *(_DWORD *)buf = 136447234;
        v22 = "nw_protocol_webtransport_stream_error";
        v23 = 2082;
        v24 = (char *)(handle + 24);
        v25 = 2080;
        v26 = " ";
        v27 = 1024;
        v28 = v11;
        v29 = 2048;
        v30 = v18;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  nw_protocol_error(a1->default_input_handler->flow_id, (uint64_t)a2);
}

void nw_protocol_webtransport_stream_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnect";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_disconnect";
      v7 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_stream_disconnect";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_43:
        if (!v4)
          return;
LABEL_44:
        free(v4);
        return;
      }
      if (!v12)
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_disconnect";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_disconnect";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_42:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_43;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = handle[11];
          if (v9)
            v10 = *(_DWORD *)(v9 + 460);
          else
            v10 = -1;
          v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          v19 = "nw_protocol_webtransport_stream_disconnect";
          v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    if (*((_DWORD *)handle + 46) != 3 || *((_DWORD *)handle + 47) != 3)
      handle[23] = 0x300000003;
    nw_protocol_disconnected(a1->default_input_handler->flow_id, (uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_stream_disconnect";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_43;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnect";
    v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_42;
  }
  if (!v16)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnect";
    v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_42;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnect";
    v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_42;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_stream_disconnect";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v4)
    goto LABEL_44;
}

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_54(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  int is_metadata_complete;
  int v8;
  int v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;

  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  v6 = (_QWORD *)(a2 + 32);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = v5;
  }
  *v5 = v4;
  *v6 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  is_metadata_complete = nw_frame_is_metadata_complete(a2);
  v8 = is_metadata_complete;
  if (*(_BYTE *)(a1 + 48))
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16))
      v8 = is_metadata_complete;
    else
      v8 = 1;
  }
  v9 = *(_WORD *)(a2 + 204) & 0xFFC7 | (*(unsigned __int8 *)(a2 + 206) << 16);
  *(_WORD *)(a2 + 204) &= 0xFFC7u;
  *(_BYTE *)(a2 + 206) = BYTE2(v9);
  v10 = *(_QWORD **)(a2 + 64);
  if (v10)
  {
    do
    {
      v11 = (_QWORD *)*v10;
      v12 = (void *)v10[6];
      v13 = (_QWORD *)*v10;
      if (v12)
      {
        os_release(v12);
        v10[6] = 0;
        v13 = (_QWORD *)*v10;
      }
      v14 = (_QWORD *)v10[1];
      if (v13)
      {
        v13[1] = v14;
        v14 = (_QWORD *)v10[1];
      }
      else
      {
        *(_QWORD *)(a2 + 72) = v14;
      }
      *v14 = v13;
      if (v10 != (_QWORD *)(a2 + 120))
        free(v10);
      v10 = v11;
    }
    while (v11);
  }
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = a2 + 64;
  v15 = *(void **)(a2 + 168);
  if (v15)
    os_release(v15);
  *(_QWORD *)(a2 + 184) = 0;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  nw_frame_set_metadata(a2, *(NSObject **)(*(_QWORD *)(a1 + 40) + 160), 1, v8);
  v16 = *(_QWORD *)(a1 + 40);
  v17 = *(uint64_t **)(v16 + 80);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = v17;
  *v17 = a2;
  *(_QWORD *)(v16 + 80) = v6;
  return 1;
}

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL37nw_webtransport_http2_handle_capsulesP23nw_webtransport_session_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  int is_metadata_complete;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;

  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  v6 = (_QWORD *)(a2 + 32);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = v5;
  }
  *v5 = v4;
  *v6 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  is_metadata_complete = nw_frame_is_metadata_complete(a2);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
  v9 = *(_WORD *)(a2 + 204) & 0xFFC7 | (*(unsigned __int8 *)(a2 + 206) << 16);
  *(_WORD *)(a2 + 204) &= 0xFFC7u;
  *(_BYTE *)(a2 + 206) = BYTE2(v9);
  v10 = *(_QWORD **)(a2 + 64);
  if (v10)
  {
    do
    {
      v11 = (_QWORD *)*v10;
      v12 = (void *)v10[6];
      v13 = (_QWORD *)*v10;
      if (v12)
      {
        os_release(v12);
        v10[6] = 0;
        v13 = (_QWORD *)*v10;
      }
      v14 = (_QWORD *)v10[1];
      if (v13)
      {
        v13[1] = v14;
        v14 = (_QWORD *)v10[1];
      }
      else
      {
        *(_QWORD *)(a2 + 72) = v14;
      }
      *v14 = v13;
      if (v10 != (_QWORD *)(a2 + 120))
        free(v10);
      v10 = v11;
    }
    while (v11);
  }
  *(_QWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 72) = a2 + 64;
  v15 = *(void **)(a2 + 168);
  if (v15)
    os_release(v15);
  if (v8)
    v16 = is_metadata_complete;
  else
    v16 = 1;
  *(_QWORD *)(a2 + 184) = 0;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  nw_frame_set_metadata(a2, *(NSObject **)(*(_QWORD *)(a1 + 40) + 160), 1, v16);
  v17 = *(_QWORD *)(a1 + 40);
  v18 = *(uint64_t **)(v17 + 80);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = v18;
  *v18 = a2;
  *(_QWORD *)(v17 + 80) = v6;
  return 1;
}

void nw_webtransport_http3_stream_fix_http_parameters(uint64_t a1, uint64_t a2)
{
  void *v4;
  nw_protocol *v5;
  BOOL v6;
  NSObject *v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  char *v21;
  _BOOL4 v22;
  NSObject *v23;
  uint64_t v24;
  int v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  char v29;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  unsigned __int8 *v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v32 = "nw_webtransport_http3_stream_fix_http_parameters";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v29 = 0;
    if (!__nwlog_fault(v15, &type, &v29))
      goto LABEL_61;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_webtransport_http3_stream_fix_http_parameters";
      v18 = "%{public}s called with null webtransport_session";
    }
    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v32 = "nw_webtransport_http3_stream_fix_http_parameters";
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_61:
        if (!v15)
          return;
LABEL_62:
        free(v15);
        return;
      }
      if (!v20)
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_webtransport_http3_stream_fix_http_parameters";
      v18 = "%{public}s called with null webtransport_session, no backtrace";
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_61;
      *(_DWORD *)buf = 136446210;
      v32 = "nw_webtransport_http3_stream_fix_http_parameters";
      v18 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }
LABEL_60:
    _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
    goto LABEL_61;
  }
  if (a2)
  {
    v4 = *(void **)(a2 + 144);
    v5 = *(nw_protocol **)(a1 + 32);
    if (v5)
      v6 = v4 == 0;
    else
      v6 = 1;
    if (v6)
    {
      if ((*(_BYTE *)(a1 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v7 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        {
          v8 = *(_DWORD *)(a1 + 460);
          *(_DWORD *)buf = 136446978;
          v32 = "nw_webtransport_http3_stream_fix_http_parameters";
          v33 = 2082;
          v34 = (char *)(a1 + 464);
          v35 = 2080;
          v36 = " ";
          v37 = 1024;
          v38 = v8;
          _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u> webtransport stream not fully setup, cannot fix parameters", buf, 0x26u);
        }
      }
    }
    else
    {
      v9 = nw_parameters_copy_protocol_options_legacy(v4, v5);
      if (v9)
      {
        v10 = v9;
        if ((*(_BYTE *)(a2 + 276) & 4) != 0)
          v11 = 1;
        else
          v11 = 2;
        if ((*(_BYTE *)(a2 + 276) & 8) != 0)
          v12 = 3;
        else
          v12 = v11;
        if ((*(_BYTE *)(a2 + 276) & 1) != 0)
          v13 = v12;
        else
          v13 = 0;
        if ((*(_BYTE *)(a2 + 276) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v23 = __nwlog_obj();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              v24 = *(_QWORD *)(a2 + 88);
              if (v24)
                v25 = *(_DWORD *)(v24 + 460);
              else
                v25 = -1;
              v28 = *(_QWORD *)(a2 + 64);
              *(_DWORD *)buf = 136447746;
              v32 = "nw_webtransport_http3_stream_fix_http_parameters";
              v33 = 2082;
              v34 = (char *)(a2 + 192);
              v35 = 2080;
              v36 = " ";
              v37 = 1024;
              v38 = v25;
              v39 = 2048;
              v40 = v28;
              v41 = 2048;
              v42 = v10;
              v43 = 1024;
              v44 = v13;
              _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Adjusting HTTP options for webtransport: %p with mode: %u", buf, 0x40u);
            }
          }
        }
        nw_http3_set_stream_mode(v10, v13);
        *(_BYTE *)(a2 + 276) |= 0x40u;
        os_release(v10);
      }
      else
      {
        if ((*(_BYTE *)(a1 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v26 = __nwlog_obj();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              v27 = *(_DWORD *)(a1 + 460);
              *(_DWORD *)buf = 136446978;
              v32 = "nw_webtransport_http3_stream_fix_http_parameters";
              v33 = 2082;
              v34 = (char *)(a1 + 464);
              v35 = 2080;
              v36 = " ";
              v37 = 1024;
              v38 = v27;
              _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Received HTTP options are NULL, failing", buf, 0x26u);
            }
          }
        }
        v14 = *(_QWORD **)(a2 + 48);
        nw_protocol_error(v14, a2);
        nw_protocol_disconnected(v14, a2);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v32 = "nw_webtransport_http3_stream_fix_http_parameters";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v29 = 0;
  if (!__nwlog_fault(v15, &type, &v29))
    goto LABEL_61;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v16 = __nwlog_obj();
    v17 = type;
    if (!os_log_type_enabled(v16, type))
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_webtransport_http3_stream_fix_http_parameters";
    v18 = "%{public}s called with null webtransport_stream";
    goto LABEL_60;
  }
  if (!v29)
  {
    v16 = __nwlog_obj();
    v17 = type;
    if (!os_log_type_enabled(v16, type))
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_webtransport_http3_stream_fix_http_parameters";
    v18 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_60;
  }
  v21 = (char *)__nw_create_backtrace_string();
  v16 = __nwlog_obj();
  v17 = type;
  v22 = os_log_type_enabled(v16, type);
  if (!v21)
  {
    if (!v22)
      goto LABEL_61;
    *(_DWORD *)buf = 136446210;
    v32 = "nw_webtransport_http3_stream_fix_http_parameters";
    v18 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_60;
  }
  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    v32 = "nw_webtransport_http3_stream_fix_http_parameters";
    v33 = 2082;
    v34 = v21;
    _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v21);
  if (v15)
    goto LABEL_62;
}

uint64_t ___ZL50nw_webtransport_http3_stream_reconfigure_and_startP22nw_webtransport_streamb_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (result)
    return nw_protocol_connect(*(_QWORD *)(result + 32), result);
  return result;
}

uint64_t ___ZL37nw_webtransport_session_send_metadataP23nw_webtransport_sessionP20nw_protocol_metadataP11nw_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  BOOL v12;
  int v13;
  int v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    nw_frame_finalize(a2);
    v4 = *(_QWORD *)(a2 + 32);
    v5 = *(_QWORD **)(a2 + 40);
    if (v4)
    {
      *(_QWORD *)(v4 + 40) = v5;
      v5 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) = v5;
    }
    *v5 = v4;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    v6 = *(_QWORD *)(a1 + 48);
    if (!v6 || (*(_BYTE *)(v6 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = *(_QWORD *)(a1 + 48);
          v10 = (const char *)(v9 + 464);
          v11 = "";
          v12 = v9 == 0;
          v13 = *(_DWORD *)(v9 + 460);
          if (v12)
            v10 = "";
          v15 = "nw_webtransport_session_send_metadata_block_invoke";
          v16 = 2082;
          v14 = 136446978;
          if (!v12)
            v11 = " ";
          v17 = v10;
          v18 = 2080;
          v19 = v11;
          v20 = 1024;
          v21 = v13;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Dropping unneeded output frame", (uint8_t *)&v14, 0x26u);
        }
      }
    }
  }
  else
  {
    nw_frame_collapse(a2);
    nw_frame_set_metadata(a2, *(NSObject **)(a1 + 56), 0, 0);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  return 1;
}

void ___ZL47nw_protocol_webtransport_http3_stream_callbacksv_block_invoke()
{
  qword_1EDCF1DE8 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCF1DF0 = nw_protocol_default_input_flush;
  qword_1EDCF1DB8 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCF1DC0 = nw_protocol_default_waiting_for_output;
  qword_1EDCF1D78 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCF1D80 = nw_protocol_default_unregister_notification;
  qword_1EDCF1D58 = (uint64_t)nw_protocol_webtransport_stream_get_parameters;
  unk_1EDCF1D60 = nw_protocol_default_get_path;
  qword_1EDCF1D68 = (uint64_t)nw_protocol_default_get_local;
  unk_1EDCF1D70 = nw_protocol_webtransport_stream_get_remote_endpoint;
  qword_1EDCF1D18 = (uint64_t)nw_protocol_webtransport_stream_disconnected;
  unk_1EDCF1D20 = nw_protocol_webtransport_stream_error;
  qword_1EDCF1D28 = (uint64_t)nw_protocol_webtransport_stream_input_available;
  unk_1EDCF1D30 = nw_protocol_webtransport_stream_output_available;
  qword_1EDCF1D88 = (uint64_t)nw_protocol_webtransport_stream_notify;
  unk_1EDCF1D90 = nw_protocol_default_updated_path;
  qword_1EDCF1DC8 = (uint64_t)nw_protocol_webtransport_stream_copy_info;
  unk_1EDCF1DD0 = nw_protocol_webtransport_stream_add_listen_handler;
  qword_1EDCF1DD8 = (uint64_t)nw_protocol_webtransport_stream_remove_listen_handler;
  unk_1EDCF1DE0 = nw_protocol_webtransport_stream_get_message_properties;
  nw_protocol_webtransport_http3_stream_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_stream_add_input_handler;
  unk_1EDCF1CF0 = nw_protocol_webtransport_http3_stream_remove_input_handler;
  qword_1EDCF1CF8 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1EDCF1D00 = nw_protocol_webtransport_http3_stream_connect;
  qword_1EDCF1D08 = (uint64_t)nw_protocol_webtransport_stream_disconnect;
  unk_1EDCF1D10 = nw_protocol_webtransport_http3_stream_connected;
  qword_1EDCF1D38 = (uint64_t)nw_protocol_webtransport_http3_stream_get_input_frames;
  unk_1EDCF1D40 = nw_protocol_webtransport_http3_stream_get_output_frames;
  qword_1EDCF1D48 = (uint64_t)nw_protocol_webtransport_http3_stream_finalize_output_frames;
  unk_1EDCF1D50 = nw_protocol_default_link_state;
  qword_1EDCF1D98 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1EDCF1DA0 = nw_protocol_webtransport_http3_stream_input_finished;
  qword_1EDCF1DA8 = (uint64_t)nw_protocol_webtransport_http3_stream_output_finished;
  unk_1EDCF1DB0 = nw_protocol_default_get_output_local;
}

uint64_t nw_protocol_webtransport_stream_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *handle;
  uint64_t v5;
  BOOL v6;
  NSObject *v7;
  uint64_t result;
  uint64_t parameters;
  nw_protocol *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  id v13;
  unsigned __int8 *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  NSObject *v19;
  nw_protocol_callbacks *callbacks;
  int input_finished_high;
  char *backtrace_string;
  _BOOL4 v23;
  char *v24;
  _BOOL4 v25;
  NSObject *v26;
  nw_protocol_callbacks *v27;
  int v28;
  NSObject *v29;
  nw_protocol_callbacks *v30;
  int v31;
  NSObject *v32;
  nw_protocol_callbacks *v33;
  int v34;
  NSObject *v35;
  nw_protocol_callbacks *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char v43;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  char *v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  nw_protocol *v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  nw_protocol *v60;
  __int16 v61;
  nw_protocol *v62;
  __int16 v63;
  unsigned __int8 *v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_webtransport_stream_add_input_handler";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (!__nwlog_fault(v15, &type, &v43))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      v18 = "%{public}s called with null protocol";
      goto LABEL_74;
    }
    if (!v43)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v23)
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_74;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      v47 = 2082;
      v48 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_75:
    if (!v15)
      return 0;
LABEL_76:
    free(v15);
    return 0;
  }
  handle = (nw_protocol *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_protocol_webtransport_stream_add_input_handler";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v43 = 0;
    if (!__nwlog_fault(v15, &type, &v43))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      v18 = "%{public}s called with null webtransport_stream";
      goto LABEL_74;
    }
    if (!v43)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      v18 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_74;
    }
    v24 = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v25 = os_log_type_enabled(v16, type);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        v46 = "nw_protocol_webtransport_stream_add_input_handler";
        v47 = 2082;
        v48 = v24;
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v24);
      if (!v15)
        return 0;
      goto LABEL_76;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      v18 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_74:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      goto LABEL_75;
    }
    goto LABEL_75;
  }
  if ((BYTE4(handle[4].identifier) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v19 = __nwlog_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        callbacks = handle[1].callbacks;
        if (callbacks)
          input_finished_high = HIDWORD(callbacks[1].input_finished);
        else
          input_finished_high = -1;
        v38 = *(_QWORD *)handle[1].flow_id;
        *(_DWORD *)buf = 136447234;
        v46 = "nw_protocol_webtransport_stream_add_input_handler";
        v47 = 2082;
        v48 = (char *)&handle[3];
        v49 = 2080;
        v50 = " ";
        v51 = 1024;
        v52 = input_finished_high;
        v53 = 2048;
        v54 = v38;
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  v5 = (uint64_t)handle[1].callbacks;
  if (v5)
    v6 = a1->default_input_handler == a2;
  else
    v6 = 1;
  if (v6)
  {
    if (gLogDatapath)
    {
      v7 = __nwlog_obj();
      result = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result)
        return result;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_protocol_webtransport_stream_add_input_handler";
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s Rejecting duplicate request for a webtransport stream", buf, 0xCu);
    }
  }
  else
  {
    if ((BYTE4(handle[4].identifier) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v26 = __nwlog_obj();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          v27 = handle[1].callbacks;
          if (v27)
            v28 = HIDWORD(v27[1].input_finished);
          else
            v28 = -1;
          v39 = *(_QWORD *)handle[1].flow_id;
          *(_DWORD *)buf = 136447490;
          v46 = "nw_protocol_webtransport_stream_add_input_handler";
          v47 = 2082;
          v48 = (char *)&handle[3];
          v49 = 2080;
          v50 = " ";
          v51 = 1024;
          v52 = v28;
          v53 = 2048;
          v54 = v39;
          v55 = 2048;
          v56 = handle;
          _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Peeling off a new stream from %p", buf, 0x3Au);
        }
      }
    }
    parameters = nw_protocol_get_parameters((uint64_t)a2);
    if (parameters)
    {
      v10 = (nw_protocol *)parameters;
      if ((BYTE4(handle[4].identifier) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v29 = __nwlog_obj();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
          {
            v30 = handle[1].callbacks;
            if (v30)
              v31 = HIDWORD(v30[1].input_finished);
            else
              v31 = -1;
            v40 = *(_QWORD *)handle[1].flow_id;
            *(_DWORD *)buf = 136447234;
            v46 = "nw_webtransport_stream_replace_protocol_instance";
            v47 = 2082;
            v48 = (char *)&handle[3];
            v49 = 2080;
            v50 = " ";
            v51 = 1024;
            v52 = v31;
            v53 = 2048;
            v54 = v40;
            _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
          }
        }
      }
      v11 = nw_parameters_copy_protocol_options_legacy(v10, handle);
      if (v11)
      {
        v12 = v11;
        if ((BYTE4(handle[4].identifier) & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v35 = __nwlog_obj();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
            {
              v36 = handle[1].callbacks;
              if (v36)
                v37 = HIDWORD(v36[1].input_finished);
              else
                v37 = -1;
              v42 = *(_QWORD *)handle[1].flow_id;
              *(_DWORD *)buf = 136448514;
              v46 = "nw_webtransport_stream_replace_protocol_instance";
              v47 = 2082;
              v48 = (char *)&handle[3];
              v49 = 2080;
              v50 = " ";
              v51 = 1024;
              v52 = v37;
              v53 = 2048;
              v54 = v42;
              v55 = 2048;
              v56 = handle;
              v57 = 2048;
              v58 = v5;
              v59 = 2048;
              v60 = handle;
              v61 = 2048;
              v62 = v10;
              v63 = 2048;
              v64 = v12;
              _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> webtransport_stream protocol %p, set protocol instance to %p instead of %p in parameters %p options %p", buf, 0x62u);
            }
          }
        }
        if (nw_protocol_copy_webtransport_definition::onceToken != -1)
          dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
        v13 = (id)nw_protocol_copy_webtransport_definition::definition;
        v14 = v12;
        *((_QWORD *)v14 + 2) = v5;

        if (v13)
          os_release(v13);
        os_release(v14);
      }
      if ((BYTE4(handle[4].identifier) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v32 = __nwlog_obj();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            v33 = handle[1].callbacks;
            if (v33)
              v34 = HIDWORD(v33[1].input_finished);
            else
              v34 = -1;
            v41 = *(_QWORD *)handle[1].flow_id;
            *(_DWORD *)buf = 136447490;
            v46 = "nw_protocol_webtransport_stream_add_input_handler";
            v47 = 2082;
            v48 = (char *)&handle[3];
            v49 = 2080;
            v50 = " ";
            v51 = 1024;
            v52 = v34;
            v53 = 2048;
            v54 = v41;
            v55 = 2048;
            v56 = v10;
            _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Set connection protocol as instance in peeled off parameters %p", buf, 0x3Au);
          }
        }
      }
    }
    if (handle[1].callbacks)
      return nw_protocol_add_input_handler(v5, (uint64_t)a2);
  }
  return 0;
}

uint64_t nw_protocol_webtransport_stream_get_parameters(nw_protocol *a1)
{
  _QWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
      return handle[18];
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_webtransport_stream_get_parameters";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_stream_get_parameters";
        v6 = "%{public}s called with null webtransport_stream";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_stream_get_parameters";
        v6 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_stream_get_parameters";
        v6 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_webtransport_stream_get_parameters";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_webtransport_stream_get_parameters";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_stream_get_parameters";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_webtransport_stream_get_parameters";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_webtransport_stream_get_parameters";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_webtransport_stream_get_parameters";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_protocol_webtransport_stream_get_remote_endpoint(nw_protocol *a1)
{
  _QWORD *handle;
  uint64_t v2;
  uint64_t v3;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      v8 = "%{public}s called with null protocol";
      goto LABEL_34;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_34;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (!v10)
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      v8 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_34;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      v17 = 2082;
      v18 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_35:
    if (!v5)
      return 0;
LABEL_36:
    free(v5);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      v8 = "%{public}s called with null webtransport_stream";
      goto LABEL_34;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_35;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_34;
    }
    v11 = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v12 = os_log_type_enabled(v6, type);
    if (v11)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
        v17 = 2082;
        v18 = v11;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v11);
      if (!v5)
        return 0;
      goto LABEL_36;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_stream_get_remote_endpoint";
      v8 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_34:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      goto LABEL_35;
    }
    goto LABEL_35;
  }
  v2 = handle[6];
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 24);
    if (v3)
    {
      if (*(_QWORD *)(v3 + 136))
        return nw_protocol_get_remote_endpoint((uint64_t)a1->default_input_handler);
    }
  }
  return 0;
}

void nw_protocol_webtransport_stream_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnected";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_disconnected";
      v7 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_stream_disconnected";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_40:
        if (!v4)
          return;
LABEL_41:
        free(v4);
        return;
      }
      if (!v12)
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_disconnected";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_disconnected";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_39:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_40;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = handle[11];
          if (v9)
            v10 = *(_DWORD *)(v9 + 460);
          else
            v10 = -1;
          v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          v19 = "nw_protocol_webtransport_stream_disconnected";
          v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    nw_protocol_disconnected(a1->default_input_handler->flow_id, (uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_stream_disconnected";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnected";
    v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_39;
  }
  if (!v16)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnected";
    v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_39;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_disconnected";
    v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_39;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_stream_disconnected";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v4)
    goto LABEL_41;
}

void nw_protocol_webtransport_stream_input_available(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_input_available";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_input_available";
      v7 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_stream_input_available";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_41:
        if (!v4)
          return;
LABEL_42:
        free(v4);
        return;
      }
      if (!v12)
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_input_available";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_input_available";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_40:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_41;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = handle[11];
          if (v9)
            v10 = *(_DWORD *)(v9 + 460);
          else
            v10 = -1;
          v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          v19 = "nw_protocol_webtransport_stream_input_available";
          v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    if (*((_DWORD *)handle + 46) == 2)
      nw_protocol_input_available((_QWORD *)handle[6], (uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_stream_input_available";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_input_available";
    v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_40;
  }
  if (!v16)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_input_available";
    v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_40;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_input_available";
    v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_40;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_stream_input_available";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v4)
    goto LABEL_42;
}

void nw_protocol_webtransport_stream_output_available(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_output_available";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_output_available";
      v7 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_stream_output_available";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_41:
        if (!v4)
          return;
LABEL_42:
        free(v4);
        return;
      }
      if (!v12)
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_output_available";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_output_available";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_40:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_41;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = handle[11];
          if (v9)
            v10 = *(_DWORD *)(v9 + 460);
          else
            v10 = -1;
          v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          v19 = "nw_protocol_webtransport_stream_output_available";
          v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    if (*((_DWORD *)handle + 47) == 2)
      nw_protocol_output_available((_QWORD *)handle[6], (uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_stream_output_available";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_output_available";
    v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_40;
  }
  if (!v16)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_output_available";
    v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_40;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_output_available";
    v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_40;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_stream_output_available";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v4)
    goto LABEL_42;
}

void nw_protocol_webtransport_stream_notify(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  uint64_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_notify";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v7, &type, &v19))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_notify";
      v10 = "%{public}s called with null protocol";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v15 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_protocol_webtransport_stream_notify";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_40:
        if (!v7)
          return;
LABEL_41:
        free(v7);
        return;
      }
      if (!v15)
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_notify";
      v10 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_notify";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_39:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_40;
  }
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    if ((*(_BYTE *)(v4 + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v11 = __nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          v12 = *(_QWORD *)(v4 + 88);
          if (v12)
            v13 = *(_DWORD *)(v12 + 460);
          else
            v13 = -1;
          v18 = *(_QWORD *)(v4 + 64);
          *(_DWORD *)buf = 136447234;
          v22 = "nw_protocol_webtransport_stream_notify";
          v23 = 2082;
          v24 = (char *)(v4 + 192);
          v25 = 2080;
          v26 = " ";
          v27 = 1024;
          v28 = v13;
          v29 = 2048;
          v30 = v18;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    nw_protocol_common_notify(a1, a2, a3);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_webtransport_stream_notify";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v7, &type, &v19))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_notify";
    v10 = "%{public}s called with null webtransport_stream";
    goto LABEL_39;
  }
  if (!v19)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_notify";
    v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_39;
  }
  v16 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v16)
  {
    if (!v17)
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_notify";
    v10 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_39;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_webtransport_stream_notify";
    v23 = 2082;
    v24 = v16;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v7)
    goto LABEL_41;
}

uint64_t nw_protocol_webtransport_stream_copy_info(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  char *backtrace_string;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  uint64_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 40);
    if (v3)
    {
      if ((*(_BYTE *)(v3 + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v11 = __nwlog_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            v12 = *(_QWORD *)(v3 + 88);
            if (v12)
              v13 = *(_DWORD *)(v12 + 460);
            else
              v13 = -1;
            v18 = *(_QWORD *)(v3 + 64);
            *(_DWORD *)buf = 136447234;
            v22 = "nw_protocol_webtransport_stream_copy_info";
            v23 = 2082;
            v24 = (char *)(v3 + 192);
            v25 = 2080;
            v26 = " ";
            v27 = 1024;
            v28 = v13;
            v29 = 2048;
            v30 = v18;
            _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
          }
        }
      }
      if (*(_QWORD *)(v3 + 32))
        v5 = a1;
      else
        v5 = *(_QWORD *)(v3 + 88);
      return nw_protocol_common_copy_info(v5, a2);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_copy_info";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v7, &type, &v19))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_copy_info";
        v10 = "%{public}s called with null webtransport_stream";
        goto LABEL_41;
      }
      goto LABEL_42;
    }
    if (!v19)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_copy_info";
        v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_41;
      }
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v17 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_copy_info";
        v10 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_41;
      }
      goto LABEL_42;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_webtransport_stream_copy_info";
      v23 = 2082;
      v24 = backtrace_string;
      v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_webtransport_stream_copy_info";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v7, &type, &v19))
    goto LABEL_42;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_copy_info";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_41;
      }
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v15 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_copy_info";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_41;
      }
      goto LABEL_42;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_webtransport_stream_copy_info";
      v23 = 2082;
      v24 = backtrace_string;
      v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_29:
      _os_log_impl(&dword_182FBE000, v8, v9, v16, buf, 0x16u);
    }
LABEL_30:
    free(backtrace_string);
    goto LABEL_42;
  }
  v8 = __nwlog_obj();
  v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_copy_info";
    v10 = "%{public}s called with null protocol";
LABEL_41:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
  }
LABEL_42:
  if (v7)
    free(v7);
  return 0;
}

uint64_t nw_protocol_webtransport_stream_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  _QWORD *handle;
  uint64_t v3;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  _BOOL4 v11;
  int v12;
  char *backtrace_string;
  _BOOL4 v14;
  const char *v15;
  _BOOL4 v16;
  _BOOL4 v17;
  uint64_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_add_listen_handler";
      v9 = "%{public}s called with null protocol";
LABEL_51:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      goto LABEL_52;
    }
    if (!v19)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v14)
      goto LABEL_36;
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    v23 = 2082;
    v24 = backtrace_string;
    v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
    _os_log_impl(&dword_182FBE000, v7, v8, v15, buf, 0x16u);
    goto LABEL_36;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_add_listen_handler";
      v9 = "%{public}s called with null webtransport_stream";
      goto LABEL_51;
    }
    if (!v19)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        v9 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v16 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        v9 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v16)
      goto LABEL_36;
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    v23 = 2082;
    v24 = backtrace_string;
    v15 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_35;
  }
  v3 = handle[11];
  if (v3)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v10 = __nwlog_obj();
        v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        v3 = handle[11];
        if (v11)
        {
          if (v3)
            v12 = *(_DWORD *)(v3 + 460);
          else
            v12 = -1;
          v18 = handle[8];
          *(_DWORD *)buf = 136447234;
          v22 = "nw_protocol_webtransport_stream_add_listen_handler";
          v23 = 2082;
          v24 = (char *)(handle + 24);
          v25 = 2080;
          v26 = " ";
          v27 = 1024;
          v28 = v12;
          v29 = 2048;
          v30 = v18;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
          v3 = handle[11];
        }
      }
    }
    return nw_protocol_add_listen_handler(v3, (uint64_t)a2);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_webtransport_stream_add_listen_handler";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_52;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        v9 = "%{public}s called with null webtransport_stream->webtransport_session, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_add_listen_handler";
        v9 = "%{public}s called with null webtransport_stream->webtransport_session, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_webtransport_stream_add_listen_handler";
      v23 = 2082;
      v24 = backtrace_string;
      v15 = "%{public}s called with null webtransport_stream->webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
LABEL_36:
    free(backtrace_string);
    goto LABEL_52;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_add_listen_handler";
    v9 = "%{public}s called with null webtransport_stream->webtransport_session";
    goto LABEL_51;
  }
LABEL_52:
  if (v6)
    free(v6);
  return 0;
}

uint64_t nw_protocol_webtransport_stream_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  _QWORD *handle;
  uint64_t v3;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  _BOOL4 v11;
  int v12;
  char *backtrace_string;
  _BOOL4 v14;
  const char *v15;
  _BOOL4 v16;
  _BOOL4 v17;
  uint64_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
      v9 = "%{public}s called with null protocol";
LABEL_51:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
      goto LABEL_52;
    }
    if (!v19)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v14)
      goto LABEL_36;
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    v23 = 2082;
    v24 = backtrace_string;
    v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
    _os_log_impl(&dword_182FBE000, v7, v8, v15, buf, 0x16u);
    goto LABEL_36;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
      v9 = "%{public}s called with null webtransport_stream";
      goto LABEL_51;
    }
    if (!v19)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        v9 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v16 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        v9 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v16)
      goto LABEL_36;
    *(_DWORD *)buf = 136446466;
    v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    v23 = 2082;
    v24 = backtrace_string;
    v15 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_35;
  }
  v3 = handle[11];
  if (v3)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v10 = __nwlog_obj();
        v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        v3 = handle[11];
        if (v11)
        {
          if (v3)
            v12 = *(_DWORD *)(v3 + 460);
          else
            v12 = -1;
          v18 = handle[8];
          *(_DWORD *)buf = 136447234;
          v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
          v23 = 2082;
          v24 = (char *)(handle + 24);
          v25 = 2080;
          v26 = " ";
          v27 = 1024;
          v28 = v12;
          v29 = 2048;
          v30 = v18;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
          v3 = handle[11];
        }
      }
    }
    return nw_protocol_remove_listen_handler(v3, (uint64_t)a2);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19))
    goto LABEL_52;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        v9 = "%{public}s called with null webtransport_stream->webtransport_session, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
        v9 = "%{public}s called with null webtransport_stream->webtransport_session, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
      v23 = 2082;
      v24 = backtrace_string;
      v15 = "%{public}s called with null webtransport_stream->webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
LABEL_36:
    free(backtrace_string);
    goto LABEL_52;
  }
  v7 = __nwlog_obj();
  v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_stream_remove_listen_handler";
    v9 = "%{public}s called with null webtransport_stream->webtransport_session";
    goto LABEL_51;
  }
LABEL_52:
  if (v6)
    free(v6);
  return 0;
}

void nw_protocol_webtransport_stream_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_get_message_properties";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v6, &type, &v16))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_get_message_properties";
      v9 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_stream_get_message_properties";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_50:
        if (!v6)
          return;
        goto LABEL_51;
      }
      if (!v11)
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_get_message_properties";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_get_message_properties";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_49;
  }
  v3 = *(_QWORD *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_get_message_properties";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v6, &type, &v16))
      goto LABEL_50;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v16)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_50;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_webtransport_stream_get_message_properties";
        v9 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_49;
      }
      v12 = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!v12)
      {
        if (!v13)
          goto LABEL_50;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_protocol_webtransport_stream_get_message_properties";
        v9 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_49;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_protocol_webtransport_stream_get_message_properties";
        v20 = 2082;
        v21 = v12;
        v14 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_34:
        _os_log_impl(&dword_182FBE000, v7, v8, v14, buf, 0x16u);
      }
LABEL_35:
      free(v12);
      if (!v6)
        return;
LABEL_51:
      free(v6);
      return;
    }
    v7 = __nwlog_obj();
    v8 = type;
    if (!os_log_type_enabled(v7, type))
      goto LABEL_50;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_get_message_properties";
    v9 = "%{public}s called with null webtransport_stream";
LABEL_49:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_50;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_get_message_properties";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v6, &type, &v16))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_get_message_properties";
      v9 = "%{public}s called with null message_properties";
      goto LABEL_49;
    }
    if (!v16)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_get_message_properties";
      v9 = "%{public}s called with null message_properties, backtrace limit exceeded";
      goto LABEL_49;
    }
    v12 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v15 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v15)
        goto LABEL_50;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_get_message_properties";
      v9 = "%{public}s called with null message_properties, no backtrace";
      goto LABEL_49;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_protocol_webtransport_stream_get_message_properties";
      v20 = 2082;
      v21 = v12;
      v14 = "%{public}s called with null message_properties, dumping backtrace:%{public}s";
      goto LABEL_34;
    }
    goto LABEL_35;
  }
  v4 = a3[1] & 0xFFFFFFF8;
  if (*(_QWORD *)(v3 + 64) == -2)
    v5 = 1;
  else
    v5 = 4;
  *a3 = -1;
  a3[1] = v4 | v5;
}

uint64_t nw_protocol_webtransport_http3_stream_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  void *v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  nw_protocol *default_input_handler;
  _BOOL8 node;
  uint64_t v13;
  int v14;
  const char *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  int v27;
  uint64_t v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  uint64_t v32;
  const char *v33;
  int v34;
  NSObject *v35;
  os_log_type_t v36;
  uint32_t v37;
  NSObject *v38;
  os_log_type_t v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  os_log_type_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  int v52;
  const char *v53;
  NSObject *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  int v60;
  NSObject *v61;
  int v62;
  uint64_t v63;
  void *v64;
  os_unfair_lock_s *v65;
  _BOOL8 some_node;
  uint64_t object;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const void *v72;
  void *v73;
  void *v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  int v80;
  NSObject *v81;
  int v82;
  __n128 v83;
  uint64_t v84;
  NSObject *v85;
  int v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  os_unfair_lock_s *v90;
  uint64_t v91;
  NSObject *v92;
  int v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  os_log_type_t v97;
  NSObject *v98;
  os_log_type_t v99;
  const char *v100;
  char *v101;
  NSObject *v102;
  os_log_type_t v103;
  _BOOL4 v104;
  uint64_t v105;
  os_log_type_t v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  NSObject *v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  NSObject *v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  const void *v120;
  void *v121;
  void *v122;
  void *v123;
  NSObject *v124;
  os_log_type_t v125;
  NSObject *v126;
  os_log_type_t v127;
  const char *v128;
  char *v129;
  NSObject *v130;
  os_log_type_t v131;
  _BOOL4 v132;
  NSObject *v133;
  os_log_type_t v134;
  uint64_t v135;
  const void *v136;
  char *v137;
  NSObject *v138;
  os_log_type_t v139;
  const char *v140;
  NSObject *v141;
  uint64_t v142;
  int v143;
  char *backtrace_string;
  _BOOL4 v145;
  const char *v146;
  _BOOL4 v147;
  _BOOL4 v148;
  char *v149;
  NSObject *v150;
  os_log_type_t v151;
  const char *v152;
  NSObject *v153;
  int v154;
  uint64_t v155;
  char *v156;
  _BOOL4 v157;
  NSObject *v158;
  uint64_t v159;
  int v160;
  NSObject *v161;
  int v162;
  NSObject *v163;
  int v164;
  uint64_t v165;
  int v166;
  NSObject *v167;
  uint64_t v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  _QWORD v172[5];
  os_log_type_t type[8];
  uint64_t v174;
  uint64_t (*v175)(uint64_t, uint64_t);
  void *v176;
  uint64_t *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t *v180;
  uint64_t v181;
  uint64_t v182;
  char v183;
  os_log_type_t v184;
  _BYTE buf[12];
  __int16 v186;
  const char *v187;
  __int16 v188;
  uint64_t v189;
  __int16 v190;
  _BYTE v191[24];
  __int16 v192;
  nw_protocol *v193;
  __int16 v194;
  nw_protocol *v195;
  uint64_t v196;

  v196 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v137, type, v172))
      goto LABEL_278;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null protocol";
      goto LABEL_277;
    }
    if (!LOBYTE(v172[0]))
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_277;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = type[0];
    v145 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v145)
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_277;
    }
    if (!v145)
      goto LABEL_251;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    v186 = 2082;
    v187 = backtrace_string;
    v146 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_250:
    _os_log_impl(&dword_182FBE000, v138, v139, v146, buf, 0x16u);
    goto LABEL_251;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v137, type, v172))
      goto LABEL_278;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null webtransport_stream";
      goto LABEL_277;
    }
    if (!LOBYTE(v172[0]))
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_277;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = type[0];
    v147 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v147)
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_277;
    }
    if (!v147)
      goto LABEL_251;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    v186 = 2082;
    v187 = backtrace_string;
    v146 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_250;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v137, type, v172))
      goto LABEL_278;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null input_protocol";
      goto LABEL_277;
    }
    if (!LOBYTE(v172[0]))
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v140 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_277;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = type[0];
    v148 = os_log_type_enabled(v138, type[0]);
    if (backtrace_string)
    {
      if (v148)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
        v186 = 2082;
        v187 = backtrace_string;
        v146 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_250;
      }
LABEL_251:
      free(backtrace_string);
      goto LABEL_278;
    }
    if (!v148)
      goto LABEL_278;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
    v140 = "%{public}s called with null input_protocol, no backtrace";
LABEL_277:
    _os_log_impl(&dword_182FBE000, v138, v139, v140, buf, 0xCu);
LABEL_278:
    if (v137)
      free(v137);
    return 0;
  }
  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v141 = __nwlog_obj();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
      {
        v142 = *((_QWORD *)handle + 11);
        if (v142)
          v143 = *(_DWORD *)(v142 + 460);
        else
          v143 = -1;
        v155 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
        v186 = 2082;
        v187 = handle + 192;
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v143;
        *(_WORD *)&v191[4] = 2048;
        *(_QWORD *)&v191[6] = v155;
        _os_log_impl(&dword_182FBE000, v141, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  v5 = &unk_1ECD84000;
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *((_QWORD *)handle + 11);
      if (v7)
        v8 = *(_DWORD *)(v7 + 460);
      else
        v8 = -1;
      v9 = *((_QWORD *)handle + 8);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136448002;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http3_stream_remove_input_handler";
      v186 = 2082;
      v187 = handle + 192;
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v8;
      *(_WORD *)&v191[4] = 2048;
      *(_QWORD *)&v191[6] = v9;
      *(_WORD *)&v191[14] = 2048;
      *(_QWORD *)&v191[16] = a1;
      v192 = 2048;
      v193 = default_input_handler;
      v194 = 2048;
      v195 = a2;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%lld> protocol %p, default_input_handler %p, input protocol %p", buf, 0x4Eu);
    }
  }
  if (a2->output_handler == a1)
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  if (a1->default_input_handler != a2)
    return 0;
  nw_protocol_remove_input_handler(*((_QWORD *)handle + 4), (uint64_t)a1);
  v171 = *((_QWORD *)handle + 11);
  if (!v171)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
    v149 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v149, type, v172))
      goto LABEL_292;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v150 = __nwlog_obj();
      v151 = type[0];
      if (!os_log_type_enabled(v150, type[0]))
        goto LABEL_292;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v152 = "%{public}s called with null webtransport_session";
    }
    else if (LOBYTE(v172[0]))
    {
      v156 = (char *)__nw_create_backtrace_string();
      v150 = __nwlog_obj();
      v151 = type[0];
      v157 = os_log_type_enabled(v150, type[0]);
      if (v156)
      {
        if (v157)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = v156;
          _os_log_impl(&dword_182FBE000, v150, v151, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v156);
        goto LABEL_292;
      }
      if (!v157)
      {
LABEL_292:
        if (v149)
          free(v149);
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v152 = "%{public}s called with null webtransport_session, no backtrace";
    }
    else
    {
      v150 = __nwlog_obj();
      v151 = type[0];
      if (!os_log_type_enabled(v150, type[0]))
        goto LABEL_292;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v152 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v150, v151, v152, buf, 0xCu);
    goto LABEL_292;
  }
  if ((handle[276] & 0x20) != 0)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v153 = __nwlog_obj();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEBUG))
        {
          v154 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v154;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = handle;
          _os_log_impl(&dword_182FBE000, v153, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
        }
      }
    }
    if ((handle[276] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
      v186 = 2048;
      v187 = handle;
      v16 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v172[0]) = 0;
      if (__nwlog_fault(v16, type, v172))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = gLogObj;
          v18 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2048;
            v187 = handle;
            v19 = "%{public}s stream %p not in pending list, cannot remove";
LABEL_58:
            v38 = v17;
            v39 = v18;
LABEL_59:
            _os_log_impl(&dword_182FBE000, v38, v39, v19, buf, 0x16u);
          }
        }
        else if (LOBYTE(v172[0]))
        {
          v23 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = gLogObj;
          v25 = type[0];
          v26 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v23)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              v186 = 2048;
              v187 = handle;
              v188 = 2082;
              v189 = (uint64_t)v23;
              _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v23);
            goto LABEL_60;
          }
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2048;
            v187 = handle;
            v19 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            v38 = v24;
            v39 = v25;
            goto LABEL_59;
          }
        }
        else
        {
          v17 = __nwlog_obj();
          v18 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2048;
            v187 = handle;
            v19 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            goto LABEL_58;
          }
        }
      }
LABEL_60:
      if (v16)
        free(v16);
      v5 = &unk_1ECD84000;
      goto LABEL_79;
    }
    v20 = *((_QWORD *)handle + 14);
    v21 = (_QWORD *)*((_QWORD *)handle + 15);
    if (v20)
    {
      *(_QWORD *)(v20 + 120) = v21;
      v21 = (_QWORD *)*((_QWORD *)handle + 15);
      v22 = v171;
    }
    else
    {
      v22 = v171;
      *(_QWORD *)(v171 + 336) = v21;
    }
    *v21 = v20;
    *((_QWORD *)handle + 14) = 0;
    *((_QWORD *)handle + 15) = 0;
    v27 = *(_DWORD *)(v22 + 456);
    *(_DWORD *)(v22 + 456) = v27 - 1;
    if (v27)
    {
LABEL_77:
      v48 = handle[276];
      handle[276] = v48 & 0xDF;
      if ((v48 & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v158 = __nwlog_obj();
          if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
          {
            v159 = *((_QWORD *)handle + 11);
            if (v159)
              v160 = *(_DWORD *)(v159 + 460);
            else
              v160 = -1;
            v165 = *((_QWORD *)handle + 8);
            v166 = *(_DWORD *)(v171 + 456);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2082;
            v187 = handle + 192;
            v188 = 2080;
            v189 = (uint64_t)" ";
            v190 = 1024;
            *(_DWORD *)v191 = v160;
            *(_WORD *)&v191[4] = 2048;
            *(_QWORD *)&v191[6] = v165;
            *(_WORD *)&v191[14] = 2048;
            *(_QWORD *)&v191[16] = handle;
            v192 = 1024;
            LODWORD(v193) = v166;
            v15 = "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams";
            v35 = v158;
            v36 = OS_LOG_TYPE_DEBUG;
            v37 = 64;
            goto LABEL_55;
          }
        }
      }
      goto LABEL_79;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = *(unsigned int *)(v171 + 456);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
    v186 = 2082;
    v187 = "webtransport_session->pending_stream_count";
    v188 = 2048;
    v189 = 1;
    v190 = 2048;
    *(_QWORD *)v191 = v28;
    v29 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (__nwlog_fault(v29, type, v172))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v30 = __nwlog_obj();
        v31 = type[0];
        if (os_log_type_enabled(v30, type[0]))
        {
          v32 = *(unsigned int *)(v171 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = "webtransport_session->pending_stream_count";
          v188 = 2048;
          v189 = 1;
          v190 = 2048;
          *(_QWORD *)v191 = v32;
          v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_72:
          v46 = v30;
          v47 = v31;
LABEL_73:
          _os_log_impl(&dword_182FBE000, v46, v47, v33, buf, 0x2Au);
        }
      }
      else if (LOBYTE(v172[0]))
      {
        v40 = (char *)__nw_create_backtrace_string();
        v41 = __nwlog_obj();
        v42 = type[0];
        v43 = os_log_type_enabled(v41, type[0]);
        if (v40)
        {
          if (v43)
          {
            v44 = *(unsigned int *)(v171 + 456);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2082;
            v187 = "webtransport_session->pending_stream_count";
            v188 = 2048;
            v189 = 1;
            v190 = 2048;
            *(_QWORD *)v191 = v44;
            *(_WORD *)&v191[8] = 2082;
            *(_QWORD *)&v191[10] = v40;
            _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v40);
          goto LABEL_74;
        }
        if (v43)
        {
          v135 = *(unsigned int *)(v171 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = "webtransport_session->pending_stream_count";
          v188 = 2048;
          v189 = 1;
          v190 = 2048;
          *(_QWORD *)v191 = v135;
          v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          v46 = v41;
          v47 = v42;
          goto LABEL_73;
        }
      }
      else
      {
        v30 = __nwlog_obj();
        v31 = type[0];
        if (os_log_type_enabled(v30, type[0]))
        {
          v45 = *(unsigned int *)(v171 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = "webtransport_session->pending_stream_count";
          v188 = 2048;
          v189 = 1;
          v190 = 2048;
          *(_QWORD *)v191 = v45;
          v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_72;
        }
      }
    }
LABEL_74:
    if (v29)
      free(v29);
    *(_DWORD *)(v171 + 456) = 0;
    v5 = &unk_1ECD84000;
    goto LABEL_77;
  }
  if (*(char **)(v171 + 416) == handle)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v161 = __nwlog_obj();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
        {
          v162 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v162;
          _os_log_impl(&dword_182FBE000, v161, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing placeholder stream for session", buf, 0x26u);
        }
      }
    }
    *(_QWORD *)(v171 + 416) = 0;
  }
  else if (*(char **)(v171 + 424) == handle)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v163 = __nwlog_obj();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
        {
          v164 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v164;
          _os_log_impl(&dword_182FBE000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing datagram stream for session", buf, 0x26u);
        }
      }
    }
    *(_QWORD *)(v171 + 424) = 0;
  }
  else
  {
    *(_QWORD *)type = *((_QWORD *)handle + 8);
    node = nw_hash_table_get_node(*(_QWORD *)(v171 + 184), (uint64_t)type, 8);
    if (node)
    {
      if (!nw_hash_table_remove_node(*(_QWORD *)(v171 + 184), node) && (*(_BYTE *)(v171 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v14 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v14;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = *(_QWORD *)type;
          v15 = "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table";
LABEL_54:
          v35 = v13;
          v36 = OS_LOG_TYPE_ERROR;
          v37 = 48;
LABEL_55:
          _os_log_impl(&dword_182FBE000, v35, v36, v15, buf, v37);
        }
      }
    }
    else if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v34 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v34;
        *(_WORD *)&v191[4] = 2048;
        *(_QWORD *)&v191[6] = *(_QWORD *)type;
        v15 = "%{public}s %{public}s%s<i%u> called remove_input_handler with stream id %lld, but no stream found";
        goto LABEL_54;
      }
    }
  }
LABEL_79:
  *((_QWORD *)handle + 11) = 0;
  v49 = v171;
  if (*(char **)(v171 + 48) != handle)
    goto LABEL_86;
  if (*(_DWORD *)(v171 + 444))
  {
    v50 = *(_QWORD *)(v171 + 424);
    if (v50)
    {
LABEL_82:
      nw_protocol_set_input_handler(v49, v50);
      if ((*(_BYTE *)(v49 + 548) & 2) != 0)
        goto LABEL_86;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = *((_QWORD *)v5 + 463);
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
        goto LABEL_86;
      v52 = *(_DWORD *)(v49 + 460);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v49 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v52;
      v53 = "%{public}s %{public}s%s<i%u> not destroying, still have datagram stream";
      goto LABEL_85;
    }
  }
  else
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v61 = *((_QWORD *)v5 + 463);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        v62 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v62;
        _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> first input handler bailed, closing", buf, 0x26u);
      }
    }
    v49 = v171;
    v63 = *(_QWORD *)(v171 + 432);
    v64 = *(void **)(v171 + 392);
    v172[0] = MEMORY[0x1E0C809B0];
    v172[1] = 0x40000000;
    v172[2] = ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke;
    v172[3] = &unk_1E14A0498;
    v172[4] = v63;
    nw_queue_context_async(v64, v172);
    v50 = *(_QWORD *)(v171 + 424);
    if (v50)
      goto LABEL_82;
  }
  v65 = *(os_unfair_lock_s **)(v49 + 184);
  if (v65 && v65[10]._os_unfair_lock_opaque)
  {
    some_node = nw_hash_table_get_some_node(v65);
    object = nw_hash_node_get_object(some_node);
    nw_protocol_set_input_handler(v171, object);
    if ((*(_BYTE *)(v171 + 548) & 2) != 0)
      goto LABEL_86;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = *((_QWORD *)v5 + 463);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
      goto LABEL_86;
    v68 = *(_DWORD *)(v171 + 460);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
    v186 = 2082;
    v187 = (const char *)(v171 + 464);
    v188 = 2080;
    v189 = (uint64_t)" ";
    v190 = 1024;
    *(_DWORD *)v191 = v68;
    v53 = "%{public}s %{public}s%s<i%u> not destroying, still have active streams";
    goto LABEL_85;
  }
  v76 = v171;
  if (!*(_DWORD *)(v171 + 456))
  {
    v79 = *(_QWORD *)(v171 + 416);
    if (v79)
    {
      nw_protocol_set_input_handler(v171, v79);
      if ((*(_BYTE *)(v171 + 548) & 2) != 0)
        goto LABEL_86;
      v51 = __nwlog_obj();
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
        goto LABEL_86;
      v80 = *(_DWORD *)(v171 + 460);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v171 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v80;
      v53 = "%{public}s %{public}s%s<i%u> not destroying, still have placeholder stream";
      goto LABEL_85;
    }
    nw_protocol_set_input_handler(v171, 0);
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      v81 = __nwlog_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
      {
        v82 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v82;
        _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> called, destroying session", buf, 0x26u);
      }
    }
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 344, buf);
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 360, buf);
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 376, buf);
    nw_http_capsule_framer_cleanup((_QWORD *)(v171 + 96), v83);
    v84 = *(_QWORD *)(v171 + 400);
    if (v84)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v84 + 8))(v84, v171, 0);
    if ((*(_BYTE *)(v171 + 548) & 4) != 0)
    {
      if ((nw_protocol_remove_listen_handler(*(_QWORD *)(v171 + 408), v171 + 64) & 1) == 0
        && (*(_BYTE *)(v171 + 548) & 2) == 0)
      {
        v85 = __nwlog_obj();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
        {
          v86 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v86;
          _os_log_impl(&dword_182FBE000, v85, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> failed to remove listen handler", buf, 0x26u);
        }
      }
      *(_QWORD *)(v171 + 408) = 0;
    }
    v87 = *(_QWORD *)(v171 + 32);
    if (v87)
      nw_protocol_remove_input_handler(v87, v171);
    v179 = 0;
    v180 = &v179;
    v181 = 0x2000000000;
    v182 = 0;
    v88 = *(char **)(v171 + 184);
    if (v88)
    {
      *(_QWORD *)type = MEMORY[0x1E0C809B0];
      v174 = 0x40000000;
      v175 = ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke;
      v176 = &unk_1E14A04E0;
      v177 = &v179;
      v178 = v171;
      nw_hash_table_apply(v88, (uint64_t)type);
      v90 = *(os_unfair_lock_s **)(v171 + 184);
      if (v90)
      {
        _nw_hash_table_release(v90, v89);
        *(_QWORD *)(v171 + 184) = 0;
      }
    }
    v91 = *(_QWORD *)(v171 + 328);
    v180[3] = v91;
    if (!v91)
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v171 + 432) + 16))(*(_QWORD *)(v171 + 432), 0);
      v136 = *(const void **)(v171 + 432);
      if (v136)
      {
        _Block_release(v136);
        *(_QWORD *)(v171 + 432) = 0;
      }
      std::destroy_at[abi:nn180100]<nw_webtransport_session,0>(v171);
      free((void *)v171);
      _Block_object_dispose(&v179, 8);
      goto LABEL_86;
    }
    while (1)
    {
      v91 = *(_QWORD *)(v91 + 112);
      if ((*(_BYTE *)(v76 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v92 = *((_QWORD *)v5 + 463);
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          v93 = *(_DWORD *)(v76 + 460);
          v94 = v180[3];
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v93;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = v94;
          _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways", buf, 0x30u);
        }
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
      v95 = (char *)_os_log_send_and_compose_impl();
      v184 = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (__nwlog_fault(v95, &v184, &v183))
      {
        if (v184 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v96 = gLogObj;
          v97 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184))
            goto LABEL_167;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v98 = v96;
          v99 = v97;
          v100 = "%{public}s should not have streams left when destroying";
LABEL_166:
          _os_log_impl(&dword_182FBE000, v98, v99, v100, buf, 0xCu);
          goto LABEL_167;
        }
        if (!v183)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v105 = gLogObj;
          v106 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184))
            goto LABEL_167;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v98 = v105;
          v99 = v106;
          v100 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
          goto LABEL_166;
        }
        v101 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v102 = gLogObj;
        v103 = v184;
        v104 = os_log_type_enabled((os_log_t)gLogObj, v184);
        if (!v101)
        {
          if (!v104)
            goto LABEL_167;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v98 = v102;
          v99 = v103;
          v100 = "%{public}s should not have streams left when destroying, no backtrace";
          goto LABEL_166;
        }
        if (v104)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = v101;
          _os_log_impl(&dword_182FBE000, v102, v103, "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v101);
      }
LABEL_167:
      if (v95)
        free(v95);
      v107 = *(_QWORD *)(v91 + 112);
      v108 = *(_QWORD **)(v91 + 120);
      if (v107)
      {
        *(_QWORD *)(v107 + 120) = v108;
        v108 = *(_QWORD **)(v91 + 120);
      }
      else
      {
        *(_QWORD *)(v171 + 336) = v108;
      }
      *v108 = v107;
      *(_QWORD *)(v91 + 112) = 0;
      *(_QWORD *)(v91 + 120) = 0;
      v109 = v180[3];
      v5 = &unk_1ECD84000;
      if (v109)
      {
        if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v110 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            v111 = *(_QWORD *)(v109 + 88);
            if (v111)
              v112 = *(_DWORD *)(v111 + 460);
            else
              v112 = -1;
            v113 = *(_QWORD *)(v109 + 64);
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
            v186 = 2082;
            v187 = (const char *)(v109 + 192);
            v188 = 2080;
            v189 = (uint64_t)" ";
            v190 = 1024;
            *(_DWORD *)v191 = v112;
            *(_WORD *)&v191[4] = 2048;
            *(_QWORD *)&v191[6] = v113;
            *(_WORD *)&v191[14] = 2048;
            *(_QWORD *)&v191[16] = v109;
            _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
          }
        }
        if (*(_QWORD *)(v109 + 72))
        {
          if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v114 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              v115 = *(_QWORD *)(v109 + 88);
              if (v115)
                v116 = *(_DWORD *)(v115 + 460);
              else
                v116 = -1;
              v117 = *(_QWORD *)(v109 + 64);
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
              v186 = 2082;
              v187 = (const char *)(v109 + 192);
              v188 = 2080;
              v189 = (uint64_t)" ";
              v190 = 1024;
              *(_DWORD *)v191 = v116;
              *(_WORD *)&v191[4] = 2048;
              *(_QWORD *)&v191[6] = v117;
              _os_log_impl(&dword_182FBE000, v114, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
            }
          }
        }
        v118 = *(_QWORD *)(v109 + 72);
        if (v118)
        {
          do
          {
            v119 = *(_QWORD *)(v118 + 32);
            nw_frame_finalize(v118);
            v118 = v119;
          }
          while (v119);
        }
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v109 + 176) + 16))(*(_QWORD *)(v109 + 176), 0);
        v120 = *(const void **)(v109 + 176);
        if (v120)
        {
          _Block_release(v120);
          *(_QWORD *)(v109 + 176) = 0;
        }
        if ((*(_BYTE *)(v109 + 168) & 1) != 0)
        {
          v121 = *(void **)(v109 + 160);
          if (v121)
            os_release(v121);
        }
        *(_QWORD *)(v109 + 160) = 0;
        if ((*(_BYTE *)(v109 + 152) & 1) != 0)
        {
          v122 = *(void **)(v109 + 144);
          if (v122)
            os_release(v122);
        }
        *(_QWORD *)(v109 + 144) = 0;
        if ((*(_BYTE *)(v109 + 136) & 1) != 0)
        {
          v123 = *(void **)(v109 + 128);
          if (v123)
            os_release(v123);
        }
LABEL_199:
        free((void *)v109);
        goto LABEL_200;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
      v109 = _os_log_send_and_compose_impl();
      v184 = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (!__nwlog_fault((const char *)v109, &v184, &v183))
        goto LABEL_216;
      if (v184 == OS_LOG_TYPE_FAULT)
      {
        v124 = __nwlog_obj();
        v125 = v184;
        if (os_log_type_enabled(v124, v184))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
          v126 = v124;
          v127 = v125;
          v128 = "%{public}s called with null webtransport_stream";
          goto LABEL_215;
        }
LABEL_216:
        if (v109)
          goto LABEL_199;
        goto LABEL_200;
      }
      if (!v183)
      {
        v133 = __nwlog_obj();
        v134 = v184;
        if (!os_log_type_enabled(v133, v184))
          goto LABEL_216;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v126 = v133;
        v127 = v134;
        v128 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
LABEL_215:
        _os_log_impl(&dword_182FBE000, v126, v127, v128, buf, 0xCu);
        goto LABEL_216;
      }
      v129 = (char *)__nw_create_backtrace_string();
      v130 = __nwlog_obj();
      v131 = v184;
      v132 = os_log_type_enabled(v130, v184);
      if (!v129)
      {
        v5 = &unk_1ECD84000;
        if (!v132)
          goto LABEL_216;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v126 = v130;
        v127 = v131;
        v128 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_215;
      }
      if (v132)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v186 = 2082;
        v187 = v129;
        _os_log_impl(&dword_182FBE000, v130, v131, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v129);
      v5 = &unk_1ECD84000;
      if (v109)
        goto LABEL_199;
LABEL_200:
      v180[3] = v91;
      v76 = v171;
    }
  }
  v77 = *(_QWORD *)(v171 + 328);
  if (v77)
  {
    if ((*(_BYTE *)(v77 + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v167 = __nwlog_obj();
        if (os_log_type_enabled(v167, OS_LOG_TYPE_DEBUG))
        {
          v168 = *(_QWORD *)(v77 + 88);
          if (v168)
            v169 = *(_DWORD *)(v168 + 460);
          else
            v169 = -1;
          v170 = *(_QWORD *)(v77 + 64);
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
          v186 = 2082;
          v187 = (const char *)(v77 + 192);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v169;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = v170;
          *(_WORD *)&v191[14] = 2048;
          *(_QWORD *)&v191[16] = v77;
          _os_log_impl(&dword_182FBE000, v167, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
        }
      }
    }
  }
  nw_protocol_set_input_handler(v171, v77);
  if ((*(_BYTE *)(v171 + 548) & 2) != 0)
    goto LABEL_86;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v51 = *((_QWORD *)v5 + 463);
  if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
    goto LABEL_86;
  v78 = *(_DWORD *)(v171 + 460);
  *(_DWORD *)buf = 136446978;
  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
  v186 = 2082;
  v187 = (const char *)(v171 + 464);
  v188 = 2080;
  v189 = (uint64_t)" ";
  v190 = 1024;
  *(_DWORD *)v191 = v78;
  v53 = "%{public}s %{public}s%s<i%u> not destroying, still have pending streams";
LABEL_85:
  _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_INFO, v53, buf, 0x26u);
LABEL_86:
  nw_protocol_set_output_handler((uint64_t)a1, 0);
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v54 = *((_QWORD *)v5 + 463);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
    {
      v55 = *((_QWORD *)handle + 11);
      if (v55)
        v56 = *(_DWORD *)(v55 + 460);
      else
        v56 = -1;
      v57 = *((_QWORD *)handle + 8);
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
      v186 = 2082;
      v187 = handle + 192;
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v56;
      *(_WORD *)&v191[4] = 2048;
      *(_QWORD *)&v191[6] = v57;
      *(_WORD *)&v191[14] = 2048;
      *(_QWORD *)&v191[16] = handle;
      _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
    }
  }
  if (*((_QWORD *)handle + 9))
  {
    if ((handle[276] & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v58 = *((_QWORD *)v5 + 463);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        v59 = *((_QWORD *)handle + 11);
        if (v59)
          v60 = *(_DWORD *)(v59 + 460);
        else
          v60 = -1;
        v69 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v186 = 2082;
        v187 = handle + 192;
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v60;
        *(_WORD *)&v191[4] = 2048;
        *(_QWORD *)&v191[6] = v69;
        _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
      }
    }
  }
  v70 = *((_QWORD *)handle + 9);
  if (v70)
  {
    do
    {
      v71 = *(_QWORD *)(v70 + 32);
      nw_frame_finalize(v70);
      v70 = v71;
    }
    while (v71);
  }
  (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)handle + 22) + 16))(*((_QWORD *)handle + 22), 0);
  v72 = (const void *)*((_QWORD *)handle + 22);
  if (v72)
  {
    _Block_release(v72);
    *((_QWORD *)handle + 22) = 0;
  }
  if ((handle[168] & 1) != 0)
  {
    v73 = (void *)*((_QWORD *)handle + 20);
    if (v73)
      os_release(v73);
  }
  *((_QWORD *)handle + 20) = 0;
  if ((handle[152] & 1) != 0)
  {
    v74 = (void *)*((_QWORD *)handle + 18);
    if (v74)
      os_release(v74);
  }
  *((_QWORD *)handle + 18) = 0;
  if ((handle[136] & 1) != 0)
  {
    v75 = (void *)*((_QWORD *)handle + 16);
    if (v75)
      os_release(v75);
  }
  free(handle);
  return 1;
}

uint64_t nw_protocol_webtransport_http3_stream_connect(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  char *backtrace_string;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  uint64_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((*((_BYTE *)handle + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v9 = __nwlog_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            v10 = handle[11];
            if (v10)
              v11 = *(_DWORD *)(v10 + 460);
            else
              v11 = -1;
            v16 = handle[8];
            *(_DWORD *)buf = 136447234;
            v20 = "nw_protocol_webtransport_http3_stream_connect";
            v21 = 2082;
            v22 = (char *)(handle + 24);
            v23 = 2080;
            v24 = " ";
            v25 = 1024;
            v26 = v11;
            v27 = 2048;
            v28 = v16;
            _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
          }
        }
      }
      return nw_protocol_connect((uint64_t)a1->output_handler, (uint64_t)a1);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_http3_stream_connect";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http3_stream_connect";
        v8 = "%{public}s called with null webtransport_stream";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v17)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http3_stream_connect";
        v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v15 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http3_stream_connect";
        v8 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_webtransport_http3_stream_connect";
      v21 = 2082;
      v22 = backtrace_string;
      v14 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_webtransport_http3_stream_connect";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v5, &type, &v17))
    goto LABEL_39;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http3_stream_connect";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v13 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http3_stream_connect";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_webtransport_http3_stream_connect";
      v21 = 2082;
      v22 = backtrace_string;
      v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_182FBE000, v6, v7, v14, buf, 0x16u);
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_39;
  }
  v6 = __nwlog_obj();
  v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_http3_stream_connect";
    v8 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
  }
LABEL_39:
  if (v5)
    free(v5);
  return 0;
}

void nw_protocol_webtransport_http3_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  unsigned __int8 *handle;
  nw_protocol *v4;
  int v5;
  _BYTE *v6;
  NSObject *v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  void *v23;
  uint64_t last_application_stream_id;
  NSObject *v25;
  uint64_t v26;
  int v27;
  nw_protocol *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  NSObject *v33;
  uint64_t v34;
  int v35;
  char *backtrace_string;
  _BOOL4 v37;
  char *v38;
  _BOOL4 v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  nw_protocol_identifier *identifier;
  const char *v45;
  NSObject *v46;
  os_log_type_t v47;
  uint32_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  NSObject *v55;
  int v56;
  char *v57;
  _BOOL4 v58;
  char *v59;
  _BOOL4 v60;
  nw_protocol *v61;
  uint64_t v62;
  NSObject *v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  NSObject *v69;
  int v70;
  const char *v71;
  NSObject *v72;
  os_log_type_t v73;
  uint32_t v74;
  uint64_t no_lock;
  NSObject *v76;
  int v77;
  uint64_t v78;
  nw_protocol *default_input_handler;
  int v80;
  NSObject *v81;
  uint64_t v82;
  int v83;
  NSObject *v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  char *v88;
  NSObject *v89;
  os_log_type_t v90;
  const char *v91;
  NSObject *v92;
  int v93;
  uint64_t v94;
  char *v95;
  _BOOL4 v96;
  nw_protocol_identifier *v97;
  char v98;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v101;
  __int16 v102;
  char *v103;
  __int16 v104;
  const char *v105;
  __int16 v106;
  int v107;
  __int16 v108;
  uint64_t v109;
  __int16 v110;
  nw_protocol *v111;
  __int16 v112;
  nw_protocol_identifier *v113;
  __int16 v114;
  nw_protocol *v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v101 = "nw_protocol_webtransport_http3_stream_connected";
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (!__nwlog_fault(v29, &type, &v98))
      goto LABEL_87;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v32 = "%{public}s called with null protocol";
      goto LABEL_86;
    }
    if (!v98)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v32 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_86;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v31 = type;
    v37 = os_log_type_enabled(v30, type);
    if (!backtrace_string)
    {
      if (!v37)
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v32 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_86;
    }
    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v102 = 2082;
      v103 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_87:
    if (!v29)
      return;
    goto LABEL_88;
  }
  handle = (unsigned __int8 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v101 = "nw_protocol_webtransport_http3_stream_connected";
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (!__nwlog_fault(v29, &type, &v98))
      goto LABEL_87;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v32 = "%{public}s called with null webtransport_stream";
      goto LABEL_86;
    }
    if (!v98)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v32 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_86;
    }
    v38 = (char *)__nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v31 = type;
    v39 = os_log_type_enabled(v30, type);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446466;
        v101 = "nw_protocol_webtransport_http3_stream_connected";
        v102 = 2082;
        v103 = v38;
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v38);
      if (!v29)
        return;
LABEL_88:
      free(v29);
      return;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446210;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v32 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_86:
      _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0xCu);
      goto LABEL_87;
    }
    goto LABEL_87;
  }
  v4 = (nw_protocol *)*((_QWORD *)handle + 11);
  v5 = (handle[276] >> 4) & 1;
  v6 = &unk_1ECD84000;
  if (!gLogDatapath)
    LOBYTE(v5) = 1;
  if (!v4)
  {
    if ((v5 & 1) != 0)
      return;
    v11 = __nwlog_obj();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      return;
    v40 = *((_QWORD *)handle + 11);
    if (v40)
      v41 = *(_DWORD *)(v40 + 460);
    else
      v41 = -1;
    v49 = *((_QWORD *)handle + 8);
    *(_DWORD *)buf = 136447234;
    v101 = "nw_protocol_webtransport_http3_stream_connected";
    v102 = 2082;
    v103 = (char *)(handle + 192);
    v104 = 2080;
    v105 = " ";
    v106 = 1024;
    v107 = v41;
    v108 = 2048;
    v109 = v49;
    v45 = "%{public}s %{public}s%s<i%u:s%lld> Stream is not fully setup. Ignoring connected.";
    goto LABEL_95;
  }
  if ((v5 & 1) == 0)
  {
    v33 = __nwlog_obj();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      v34 = *((_QWORD *)handle + 11);
      if (v34)
        v35 = *(_DWORD *)(v34 + 460);
      else
        v35 = -1;
      v42 = *((_QWORD *)handle + 8);
      *(_DWORD *)buf = 136447234;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v102 = 2082;
      v103 = (char *)(handle + 192);
      v104 = 2080;
      v105 = " ";
      v106 = 1024;
      v107 = v35;
      v108 = 2048;
      v109 = v42;
      _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Got a connected event from the lower layer", buf, 0x30u);
    }
  }
  nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a2);
  if (a1->output_handler == a2)
  {
    if (*((_DWORD *)handle + 46) == 2 || *((_DWORD *)handle + 47) == 2)
    {
      if ((handle[276] & 0x10) != 0)
        return;
      if (!gLogDatapath)
        return;
      v11 = __nwlog_obj();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        return;
      v12 = *((_QWORD *)handle + 11);
      if (v12)
        v13 = *(_DWORD *)(v12 + 460);
      else
        v13 = -1;
      v50 = *((_QWORD *)handle + 8);
      *(_DWORD *)buf = 136447234;
      v101 = "nw_protocol_webtransport_http3_stream_connected";
      v102 = 2082;
      v103 = (char *)(handle + 192);
      v104 = 2080;
      v105 = " ";
      v106 = 1024;
      v107 = v13;
      v108 = 2048;
      v109 = v50;
      v45 = "%{public}s %{public}s%s<i%u:s%lld> stream is already connected, not forwarding";
LABEL_95:
      v46 = v11;
      v47 = OS_LOG_TYPE_DEBUG;
      goto LABEL_177;
    }
    if ((handle[276] & 8) != 0)
    {
      if (v4 != a2)
      {
        if ((handle[276] & 0x10) == 0)
        {
          if (gLogDatapath)
          {
            v17 = __nwlog_obj();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              v18 = *((_QWORD *)handle + 11);
              if (v18)
                v19 = *(_DWORD *)(v18 + 460);
              else
                v19 = -1;
              v62 = *((_QWORD *)handle + 8);
              *(_DWORD *)buf = 136447490;
              v101 = "nw_protocol_webtransport_http3_stream_connected";
              v102 = 2082;
              v103 = (char *)(handle + 192);
              v104 = 2080;
              v105 = " ";
              v106 = 1024;
              v107 = v19;
              v108 = 2048;
              v109 = v62;
              v110 = 2048;
              v111 = v4;
              v45 = "%{public}s %{public}s%s<i%u:s%lld> connected protocol is not our WebTransport session (%p), ignoring";
              v46 = v17;
              v47 = OS_LOG_TYPE_DEBUG;
              v48 = 58;
              goto LABEL_178;
            }
          }
        }
        return;
      }
      goto LABEL_157;
    }
    if (*((_QWORD *)handle + 8) != -1)
    {
      if ((handle[276] & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v14 = __nwlog_obj();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            v15 = *((_QWORD *)handle + 11);
            if (v15)
              v16 = *(_DWORD *)(v15 + 460);
            else
              v16 = -1;
            v61 = (nw_protocol *)*((_QWORD *)handle + 8);
            *(_DWORD *)buf = 136447490;
            v101 = "nw_webtransport_http3_stream_assign_stream_id";
            v102 = 2082;
            v103 = (char *)(handle + 192);
            v104 = 2080;
            v105 = " ";
            v106 = 1024;
            v107 = v16;
            v108 = 2048;
            v109 = (uint64_t)v61;
            v110 = 2048;
            v111 = v61;
            _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Stream ID %llu already set, skipping", buf, 0x3Au);
          }
        }
      }
      goto LABEL_140;
    }
    v20 = *((_QWORD *)handle + 11);
    if (v20)
    {
      v21 = *((_QWORD *)handle + 4);
      if (v21)
      {
        v22 = (void *)nw_protocol_copy_info(v21, 255);
        if (v22)
          os_release(v22);
        v23 = *(void **)(v20 + 376);
        if (v23)
          last_application_stream_id = nw_http_connection_metadata_get_last_application_stream_id(v23);
        else
          last_application_stream_id = -1;
        if ((*(_BYTE *)(v20 + 548) & 2) == 0)
        {
          if (gLogDatapath)
          {
            v55 = __nwlog_obj();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
            {
              v56 = *(_DWORD *)(v20 + 460);
              *(_DWORD *)buf = 136447490;
              v101 = "nw_webtransport_http3_get_quic_stream_id";
              v102 = 2082;
              v103 = (char *)(v20 + 464);
              v104 = 2080;
              v105 = " ";
              v106 = 1024;
              v107 = v56;
              v108 = 2048;
              v109 = last_application_stream_id;
              v110 = 1024;
              LODWORD(v111) = 0;
              _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Got stream ID: %llu from session: %u", buf, 0x36u);
            }
          }
        }
        if (last_application_stream_id != -1)
        {
          *((_QWORD *)handle + 8) = last_application_stream_id;
          nw_webtransport_metadata_set_stream_id(*((void **)handle + 20), last_application_stream_id);
          if ((handle[276] & 0x10) == 0)
          {
            v25 = __nwlog_obj();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
            {
              v26 = *((_QWORD *)handle + 11);
              if (v26)
                v27 = *(_DWORD *)(v26 + 460);
              else
                v27 = -1;
              v28 = (nw_protocol *)*((_QWORD *)handle + 8);
              *(_DWORD *)buf = 136448002;
              v101 = "nw_webtransport_http3_stream_assign_stream_id";
              v102 = 2082;
              v103 = (char *)(handle + 192);
              v104 = 2080;
              v105 = " ";
              v106 = 1024;
              v107 = v27;
              v108 = 2048;
              v109 = (uint64_t)v28;
              v110 = 2048;
              v111 = v28;
              v112 = 2048;
              v113 = (nw_protocol_identifier *)handle;
              v114 = 1024;
              LODWORD(v115) = 0;
              _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Assigned stream ID: %llu to stream with protocol %p, incoming: %u", buf, 0x4Au);
            }
          }
          goto LABEL_140;
        }
LABEL_133:
        if ((handle[276] & 0x10) == 0)
        {
          v63 = __nwlog_obj();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            v64 = *((_QWORD *)handle + 11);
            if (v64)
              v65 = *(_DWORD *)(v64 + 460);
            else
              v65 = -1;
            v66 = *((_QWORD *)handle + 8);
            *(_DWORD *)buf = 136447234;
            v101 = "nw_webtransport_http3_stream_assign_stream_id";
            v102 = 2082;
            v103 = (char *)(handle + 192);
            v104 = 2080;
            v105 = " ";
            v106 = 1024;
            v107 = v65;
            v108 = 2048;
            v109 = v66;
            _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Failed to get stream ID for HTTP/3 webtransport stream, failing", buf, 0x30u);
          }
        }
        v67 = (_QWORD *)*((_QWORD *)handle + 6);
        nw_protocol_error(v67, (uint64_t)handle);
        nw_protocol_disconnected(v67, (uint64_t)handle);
LABEL_140:
        v68 = *((_QWORD *)handle + 11);
        if (v68)
        {
          if (*((_QWORD *)handle + 8) == -2)
          {
            if (*(_QWORD *)(v68 + 424))
            {
              if ((*(_BYTE *)(v68 + 548) & 2) == 0)
              {
                v69 = __nwlog_obj();
                if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                {
                  v70 = *(_DWORD *)(v68 + 460);
                  *(_DWORD *)buf = 136446978;
                  v101 = "nw_webtransport_session_add_stream";
                  v102 = 2082;
                  v103 = (char *)(v68 + 464);
                  v104 = 2080;
                  v105 = " ";
                  v106 = 1024;
                  v107 = v70;
                  v71 = "%{public}s %{public}s%s<i%u> WebTransport already has datagram stream registered";
                  v72 = v69;
                  v73 = OS_LOG_TYPE_ERROR;
                  v74 = 38;
LABEL_153:
                  _os_log_impl(&dword_182FBE000, v72, v73, v71, buf, v74);
                }
              }
LABEL_157:
              default_input_handler = a1->default_input_handler;
              if (!default_input_handler)
              {
                if ((handle[276] & 0x10) != 0)
                  return;
                v84 = __nwlog_obj();
                if (!os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                  return;
                v85 = *((_QWORD *)handle + 11);
                if (v85)
                  v86 = *(_DWORD *)(v85 + 460);
                else
                  v86 = -1;
                v87 = *((_QWORD *)handle + 8);
                *(_DWORD *)buf = 136447234;
                v101 = "nw_protocol_webtransport_http3_stream_connected";
                v102 = 2082;
                v103 = (char *)(handle + 192);
                v104 = 2080;
                v105 = " ";
                v106 = 1024;
                v107 = v86;
                v108 = 2048;
                v109 = v87;
                v45 = "%{public}s %{public}s%s<i%u:s%lld> No input handler found, ignoring connected call";
                v46 = v84;
                v47 = OS_LOG_TYPE_ERROR;
LABEL_177:
                v48 = 48;
LABEL_178:
                _os_log_impl(&dword_182FBE000, v46, v47, v45, buf, v48);
                return;
              }
              if ((handle[276] & 4) != 0)
              {
                v80 = 3;
                if ((handle[276] & 2) != 0)
                  goto LABEL_163;
                *((_DWORD *)handle + 46) = 3;
              }
              if (*((_DWORD *)handle + 47))
                goto LABEL_164;
              v80 = 2;
LABEL_163:
              *((_DWORD *)handle + 47) = v80;
LABEL_164:
              if (!*((_DWORD *)handle + 46))
                *((_DWORD *)handle + 46) = 2;
              nw_protocol_connected(default_input_handler, (uint64_t)a1);
              if ((handle[276] & 0x10) == 0)
              {
                if (v6[1345])
                {
                  v81 = __nwlog_obj();
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
                  {
                    v82 = *((_QWORD *)handle + 11);
                    if (v82)
                      v83 = *(_DWORD *)(v82 + 460);
                    else
                      v83 = -1;
                    v97 = (nw_protocol_identifier *)*((_QWORD *)handle + 8);
                    *(_DWORD *)buf = 136448002;
                    v101 = "nw_protocol_webtransport_http3_stream_connected";
                    v102 = 2082;
                    v103 = (char *)(handle + 192);
                    v104 = 2080;
                    v105 = " ";
                    v106 = 1024;
                    v107 = v83;
                    v108 = 2048;
                    v109 = (uint64_t)v97;
                    v110 = 2048;
                    v111 = a1;
                    v112 = 2048;
                    v113 = v97;
                    v114 = 2048;
                    v115 = a2;
                    v45 = "%{public}s %{public}s%s<i%u:s%lld> webtransport http3 stream %p with id %llu connected with output_handler %p";
                    v46 = v81;
                    v47 = OS_LOG_TYPE_DEBUG;
                    v48 = 78;
                    goto LABEL_178;
                  }
                }
              }
              return;
            }
            *(_QWORD *)(v68 + 424) = handle;
          }
          else
          {
            no_lock = *(_QWORD *)(v68 + 184);
            if (!no_lock)
            {
              no_lock = nw_hash_table_create_no_lock(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_webtransport_stream_get_key, (unsigned int (*)(const void *, unsigned int))nw_webtransport_stream_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_webtransport_stream_matches_key, 0);
              *(_QWORD *)(v68 + 184) = no_lock;
            }
            type = OS_LOG_TYPE_DEFAULT;
            nw_hash_table_add_object(no_lock, (uint64_t)handle, (char *)&type);
            if (type == OS_LOG_TYPE_DEFAULT)
            {
              if ((*(_BYTE *)(v68 + 548) & 2) != 0)
                goto LABEL_157;
              v76 = __nwlog_obj();
              if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
                goto LABEL_157;
              v77 = *(_DWORD *)(v68 + 460);
              v78 = *((_QWORD *)handle + 8);
              *(_DWORD *)buf = 136447234;
              v101 = "nw_webtransport_session_add_stream";
              v102 = 2082;
              v103 = (char *)(v68 + 464);
              v104 = 2080;
              v105 = " ";
              v106 = 1024;
              v107 = v77;
              v108 = 2048;
              v109 = v78;
              v71 = "%{public}s %{public}s%s<i%u> WebTransport already has stream id registered for %llu";
              v72 = v76;
              v73 = OS_LOG_TYPE_ERROR;
LABEL_152:
              v74 = 48;
              goto LABEL_153;
            }
          }
          if ((*(_BYTE *)(v68 + 548) & 2) != 0)
            goto LABEL_157;
          if (!gLogDatapath)
            goto LABEL_157;
          v92 = __nwlog_obj();
          if (!os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
            goto LABEL_157;
          v93 = *(_DWORD *)(v68 + 460);
          v94 = *((_QWORD *)handle + 8);
          *(_DWORD *)buf = 136447234;
          v101 = "nw_webtransport_session_add_stream";
          v102 = 2082;
          v103 = (char *)(v68 + 464);
          v104 = 2080;
          v105 = " ";
          v106 = 1024;
          v107 = v93;
          v108 = 2048;
          v109 = v94;
          v71 = "%{public}s %{public}s%s<i%u> Added stream %llu to WebTransport streams";
          v72 = v92;
          v73 = OS_LOG_TYPE_DEBUG;
          goto LABEL_152;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v101 = "nw_webtransport_session_add_stream";
        v88 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v98 = 0;
        if (__nwlog_fault(v88, &type, &v98))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v89 = __nwlog_obj();
            v90 = type;
            if (os_log_type_enabled(v89, type))
            {
              *(_DWORD *)buf = 136446210;
              v101 = "nw_webtransport_session_add_stream";
              v91 = "%{public}s called with null webtransport_session";
LABEL_196:
              _os_log_impl(&dword_182FBE000, v89, v90, v91, buf, 0xCu);
            }
          }
          else if (v98)
          {
            v95 = (char *)__nw_create_backtrace_string();
            v89 = __nwlog_obj();
            v90 = type;
            v96 = os_log_type_enabled(v89, type);
            if (v95)
            {
              if (v96)
              {
                *(_DWORD *)buf = 136446466;
                v101 = "nw_webtransport_session_add_stream";
                v102 = 2082;
                v103 = v95;
                _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v95);
              goto LABEL_197;
            }
            if (v96)
            {
              *(_DWORD *)buf = 136446210;
              v101 = "nw_webtransport_session_add_stream";
              v91 = "%{public}s called with null webtransport_session, no backtrace";
              goto LABEL_196;
            }
          }
          else
          {
            v89 = __nwlog_obj();
            v90 = type;
            if (os_log_type_enabled(v89, type))
            {
              *(_DWORD *)buf = 136446210;
              v101 = "nw_webtransport_session_add_stream";
              v91 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
              goto LABEL_196;
            }
          }
        }
LABEL_197:
        if (v88)
          free(v88);
        v6 = (_BYTE *)&unk_1ECD84000;
        goto LABEL_157;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v101 = "nw_webtransport_http3_get_quic_stream_id";
      v51 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v98 = 0;
      if (__nwlog_fault(v51, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v52 = __nwlog_obj();
          v53 = type;
          if (!os_log_type_enabled(v52, type))
            goto LABEL_130;
          *(_DWORD *)buf = 136446210;
          v101 = "nw_webtransport_http3_get_quic_stream_id";
          v54 = "%{public}s called with null output_protocol";
          goto LABEL_129;
        }
        if (!v98)
        {
          v52 = __nwlog_obj();
          v53 = type;
          if (!os_log_type_enabled(v52, type))
            goto LABEL_130;
          *(_DWORD *)buf = 136446210;
          v101 = "nw_webtransport_http3_get_quic_stream_id";
          v54 = "%{public}s called with null output_protocol, backtrace limit exceeded";
          goto LABEL_129;
        }
        v59 = (char *)__nw_create_backtrace_string();
        v52 = __nwlog_obj();
        v53 = type;
        v60 = os_log_type_enabled(v52, type);
        if (!v59)
        {
          if (!v60)
            goto LABEL_130;
          *(_DWORD *)buf = 136446210;
          v101 = "nw_webtransport_http3_get_quic_stream_id";
          v54 = "%{public}s called with null output_protocol, no backtrace";
          goto LABEL_129;
        }
        if (v60)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "nw_webtransport_http3_get_quic_stream_id";
          v102 = 2082;
          v103 = v59;
          _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null output_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v59);
      }
LABEL_130:
      if (!v51)
      {
LABEL_132:
        v6 = &unk_1ECD84000;
        goto LABEL_133;
      }
LABEL_131:
      free(v51);
      goto LABEL_132;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v101 = "nw_webtransport_http3_get_quic_stream_id";
    v51 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v98 = 0;
    if (!__nwlog_fault(v51, &type, &v98))
      goto LABEL_130;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v52 = __nwlog_obj();
      v53 = type;
      if (!os_log_type_enabled(v52, type))
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      v101 = "nw_webtransport_http3_get_quic_stream_id";
      v54 = "%{public}s called with null webtransport_session";
    }
    else
    {
      if (!v98)
      {
        v52 = __nwlog_obj();
        v53 = type;
        if (!os_log_type_enabled(v52, type))
          goto LABEL_130;
        *(_DWORD *)buf = 136446210;
        v101 = "nw_webtransport_http3_get_quic_stream_id";
        v54 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
        goto LABEL_129;
      }
      v57 = (char *)__nw_create_backtrace_string();
      v52 = __nwlog_obj();
      v53 = type;
      v58 = os_log_type_enabled(v52, type);
      if (v57)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446466;
          v101 = "nw_webtransport_http3_get_quic_stream_id";
          v102 = 2082;
          v103 = v57;
          _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v57);
        if (!v51)
          goto LABEL_132;
        goto LABEL_131;
      }
      if (!v58)
        goto LABEL_130;
      *(_DWORD *)buf = 136446210;
      v101 = "nw_webtransport_http3_get_quic_stream_id";
      v54 = "%{public}s called with null webtransport_session, no backtrace";
    }
LABEL_129:
    _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0xCu);
    goto LABEL_130;
  }
  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v9 = *((_QWORD *)handle + 11);
        if (v9)
          v10 = *(_DWORD *)(v9 + 460);
        else
          v10 = -1;
        v43 = *((_QWORD *)handle + 8);
        identifier = a2->identifier;
        *(_DWORD *)buf = 136447746;
        v101 = "nw_protocol_webtransport_http3_stream_connected";
        v102 = 2082;
        v103 = (char *)(handle + 192);
        v104 = 2080;
        v105 = " ";
        v106 = 1024;
        v107 = v10;
        v108 = 2048;
        v109 = v43;
        v110 = 2048;
        v111 = a2;
        v112 = 2080;
        v113 = identifier;
        v45 = "%{public}s %{public}s%s<i%u:s%lld> connected protocol %p (%s) is not our output_handler, ignoring";
        v46 = v8;
        v47 = OS_LOG_TYPE_DEBUG;
        v48 = 68;
        goto LABEL_178;
      }
    }
  }
}

uint64_t nw_protocol_webtransport_http3_stream_get_input_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  uint64_t input_frames;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  char *backtrace_string;
  _BOOL4 v23;
  const char *v24;
  _BOOL4 v25;
  _BOOL4 v26;
  uint64_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  nw_protocol *v41;
  __int16 v42;
  nw_protocol *v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
      goto LABEL_53;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
      v18 = "%{public}s called with null protocol";
LABEL_52:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      goto LABEL_53;
    }
    if (!v28)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        v18 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        v18 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v23)
      goto LABEL_37;
    *(_DWORD *)buf = 136446466;
    v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    v32 = 2082;
    v33 = backtrace_string;
    v24 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_36:
    _os_log_impl(&dword_182FBE000, v16, v17, v24, buf, 0x16u);
    goto LABEL_37;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (!__nwlog_fault(v15, &type, &v28))
      goto LABEL_53;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
      v18 = "%{public}s called with null webtransport_stream";
      goto LABEL_52;
    }
    if (!v28)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        v18 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v25 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        v18 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v25)
      goto LABEL_37;
    *(_DWORD *)buf = 136446466;
    v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    v32 = 2082;
    v33 = backtrace_string;
    v24 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_36;
  }
  if (a2)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v19 = __nwlog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          v20 = handle[11];
          if (v20)
            v21 = *(_DWORD *)(v20 + 460);
          else
            v21 = -1;
          v27 = handle[8];
          *(_DWORD *)buf = 136447746;
          v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
          v32 = 2082;
          v33 = (char *)(handle + 24);
          v34 = 2080;
          v35 = " ";
          v36 = 1024;
          v37 = v21;
          v38 = 2048;
          v39 = v27;
          v40 = 2048;
          v41 = a1;
          v42 = 2048;
          v43 = a2;
          _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called with protocol %p and input protocol %p", buf, 0x44u);
        }
      }
    }
    input_frames = nw_protocol_common_get_input_frames((uint64_t)a1, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
    if ((_DWORD)input_frames)
      nw_protocol_input_finished(a2, (uint64_t)a1);
    return input_frames;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v28 = 0;
  if (!__nwlog_fault(v15, &type, &v28))
    goto LABEL_53;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v28)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        v18 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v26 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
        v18 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
      v32 = 2082;
      v33 = backtrace_string;
      v24 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
LABEL_37:
    free(backtrace_string);
    goto LABEL_53;
  }
  v16 = __nwlog_obj();
  v17 = type;
  if (os_log_type_enabled(v16, type))
  {
    *(_DWORD *)buf = 136446210;
    v31 = "nw_protocol_webtransport_http3_stream_get_input_frames";
    v18 = "%{public}s called with null input_protocol";
    goto LABEL_52;
  }
LABEL_53:
  if (v15)
    free(v15);
  return 0;
}

uint64_t nw_protocol_webtransport_http3_stream_get_output_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  NSObject *v18;
  uint64_t v19;
  int v20;
  char *backtrace_string;
  _BOOL4 v22;
  const char *v23;
  _BOOL4 v24;
  _BOOL4 v25;
  uint64_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  nw_protocol *v40;
  __int16 v41;
  nw_protocol *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v13, &type, &v27))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
      v16 = "%{public}s called with null protocol";
LABEL_51:
      _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
      goto LABEL_52;
    }
    if (!v27)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v22)
      goto LABEL_36;
    *(_DWORD *)buf = 136446466;
    v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    v31 = 2082;
    v32 = backtrace_string;
    v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_35:
    _os_log_impl(&dword_182FBE000, v14, v15, v23, buf, 0x16u);
    goto LABEL_36;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v13, &type, &v27))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
      v16 = "%{public}s called with null webtransport_stream";
      goto LABEL_51;
    }
    if (!v27)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        v16 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        v16 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (!v24)
      goto LABEL_36;
    *(_DWORD *)buf = 136446466;
    v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    v31 = 2082;
    v32 = backtrace_string;
    v23 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_35;
  }
  if (a6)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v18 = __nwlog_obj();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v19 = handle[11];
          if (v19)
            v20 = *(_DWORD *)(v19 + 460);
          else
            v20 = -1;
          v26 = handle[8];
          *(_DWORD *)buf = 136447746;
          v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
          v31 = 2082;
          v32 = (char *)(handle + 24);
          v33 = 2080;
          v34 = " ";
          v35 = 1024;
          v36 = v20;
          v37 = 2048;
          v38 = v26;
          v39 = 2048;
          v40 = a1;
          v41 = 2048;
          v42 = a2;
          _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called with protocol %p and input protocol %p", buf, 0x44u);
        }
      }
    }
    return nw_protocol_common_get_output_frames((uint64_t)a1, (uint64_t)a1, a3, a4, a5, (uint64_t)a6);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
  v13 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v13, &type, &v27))
    goto LABEL_52;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v27)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        v16 = "%{public}s called with null return_array, backtrace limit exceeded";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v25 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
        v16 = "%{public}s called with null return_array, no backtrace";
        goto LABEL_51;
      }
      goto LABEL_52;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
      v31 = 2082;
      v32 = backtrace_string;
      v23 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
LABEL_36:
    free(backtrace_string);
    goto LABEL_52;
  }
  v14 = __nwlog_obj();
  v15 = type;
  if (os_log_type_enabled(v14, type))
  {
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_webtransport_http3_stream_get_output_frames";
    v16 = "%{public}s called with null return_array";
    goto LABEL_51;
  }
LABEL_52:
  if (v13)
    free(v13);
  return 0;
}

uint64_t nw_protocol_webtransport_http3_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _QWORD *handle;
  uint64_t v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  char *backtrace_string;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  uint64_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((*((_BYTE *)handle + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v11 = __nwlog_obj();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          {
            v12 = handle[11];
            if (v12)
              v13 = *(_DWORD *)(v12 + 460);
            else
              v13 = -1;
            v18 = handle[8];
            *(_DWORD *)buf = 136447234;
            v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
            v23 = 2082;
            v24 = (char *)(handle + 24);
            v25 = 2080;
            v26 = " ";
            v27 = 1024;
            v28 = v13;
            v29 = 2048;
            v30 = v18;
            _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
          }
        }
      }
      v5 = nw_protocol_common_finalize_output_frames((uint64_t)a1, (uint64_t)a2);
      nw_protocol_output_finished(a1->output_handler->flow_id, (uint64_t)a1);
      return v5;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v7, &type, &v19))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        v10 = "%{public}s called with null webtransport_stream";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v19)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v17 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        v10 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
      v23 = 2082;
      v24 = backtrace_string;
      v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v7, &type, &v19))
    goto LABEL_39;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v15 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
        v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
      v23 = 2082;
      v24 = backtrace_string;
      v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_182FBE000, v8, v9, v16, buf, 0x16u);
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_39;
  }
  v8 = __nwlog_obj();
  v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    v22 = "nw_protocol_webtransport_http3_stream_finalize_output_frames";
    v10 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
  }
LABEL_39:
  if (v7)
    free(v7);
  return 0;
}

void nw_protocol_webtransport_http3_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_input_finished";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http3_stream_input_finished";
      v7 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_http3_stream_input_finished";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_41:
        if (!v4)
          return;
LABEL_42:
        free(v4);
        return;
      }
      if (!v12)
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http3_stream_input_finished";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http3_stream_input_finished";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_40:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_41;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = handle[11];
          if (v9)
            v10 = *(_DWORD *)(v9 + 460);
          else
            v10 = -1;
          v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          v19 = "nw_protocol_webtransport_http3_stream_input_finished";
          v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    if (*((_DWORD *)handle + 46) == 2)
      nw_protocol_input_finished((_QWORD *)handle[6], (uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_http3_stream_input_finished";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_input_finished";
    v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_40;
  }
  if (!v16)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_input_finished";
    v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_40;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_input_finished";
    v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_40;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_http3_stream_input_finished";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v4)
    goto LABEL_42;
}

void nw_protocol_webtransport_http3_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_output_finished";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http3_stream_output_finished";
      v7 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_http3_stream_output_finished";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_42:
        if (!v4)
          return;
LABEL_43:
        free(v4);
        return;
      }
      if (!v12)
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http3_stream_output_finished";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http3_stream_output_finished";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_41:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_42;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = handle[11];
          if (v9)
            v10 = *(_DWORD *)(v9 + 460);
          else
            v10 = -1;
          v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          v19 = "nw_protocol_webtransport_http3_stream_output_finished";
          v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    if (*((_DWORD *)handle + 47) == 2 && (*((_BYTE *)handle + 276) & 8) == 0)
      nw_protocol_output_finished((_QWORD *)handle[4], (uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_http3_stream_output_finished";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_42;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_output_finished";
    v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_41;
  }
  if (!v16)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_output_finished";
    v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_41;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_42;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http3_stream_output_finished";
    v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_41;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_http3_stream_output_finished";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v4)
    goto LABEL_43;
}

uint64_t nw_webtransport_stream_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 8;
  return (uint64_t)a1 + 64;
}

uint64_t nw_webtransport_stream_key_hash(_DWORD *a1)
{
  return (a1[1] + *a1);
}

BOOL nw_webtransport_stream_matches_key(_QWORD *a1, _QWORD *a2)
{
  return a1[8] == *a2;
}

void ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  int v4;
  NSObject *v5;
  int v6;
  char *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _BYTE v15[24];
  const char *v16;
  _BYTE v17[6];
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v1)
  {
    v2 = v1;
    if (*(_DWORD *)(v1 + 444) == 5)
    {
      if ((*(_BYTE *)(v1 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v4 = *(_DWORD *)(v2 + 460);
          *(_DWORD *)v15 = 136446978;
          *(_QWORD *)&v15[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&v15[12] = 2082;
          *(_QWORD *)&v15[14] = v2 + 464;
          *(_WORD *)&v15[22] = 2080;
          v16 = " ";
          *(_WORD *)v17 = 1024;
          *(_DWORD *)&v17[2] = v4;
          _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Session already terminated, ignoring", v15, 0x26u);
        }
      }
    }
    else
    {
      if ((*(_BYTE *)(v1 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v6 = *(_DWORD *)(v2 + 460);
          *(_DWORD *)v15 = 136447234;
          *(_QWORD *)&v15[4] = "nw_webtransport_session_terminate";
          *(_WORD *)&v15[12] = 2082;
          *(_QWORD *)&v15[14] = v2 + 464;
          *(_WORD *)&v15[22] = 2080;
          v16 = " ";
          *(_WORD *)v17 = 1024;
          *(_DWORD *)&v17[2] = v6;
          v18 = 1024;
          v19 = 57;
          _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Closing webtransport session with error %{darwin.errno}d", v15, 0x2Cu);
        }
      }
      *(_DWORD *)(v2 + 444) = 5;
      v7 = *(char **)(v2 + 184);
      if (v7)
      {
        *(_QWORD *)v15 = MEMORY[0x1E0C809B0];
        *(_QWORD *)&v15[8] = 0x40000000;
        *(_QWORD *)&v15[16] = ___ZL33nw_webtransport_session_terminateP23nw_webtransport_sessioni_block_invoke;
        v16 = (const char *)&__block_descriptor_tmp_22_33428;
        *(_DWORD *)v17 = 57;
        nw_hash_table_apply(v7, (uint64_t)v15);
      }
      v8 = *(_QWORD *)(v2 + 424);
      if (v8)
      {
        v9 = *(_QWORD **)(v8 + 48);
        nw_protocol_error(v9, *(_QWORD *)(v2 + 424));
        nw_protocol_disconnected(v9, v8);
      }
      v10 = *(_QWORD *)(v2 + 328);
      if (v10)
      {
        do
        {
          v11 = *(_QWORD *)(v10 + 112);
          v12 = *(_QWORD **)(v10 + 48);
          nw_protocol_error(v12, v10);
          nw_protocol_disconnected(v12, v10);
          v10 = v11;
        }
        while (v11);
      }
      v13 = *(_QWORD *)(v2 + 416);
      if (v13)
      {
        v14 = *(_QWORD **)(v13 + 48);
        nw_protocol_error(v14, *(_QWORD *)(v2 + 416));
        nw_protocol_disconnected(v14, v13);
      }
      if (*(_QWORD *)(v2 + 32))
      {
        nw_protocol_remove_instance(v2);
        nw_protocol_disconnect(*(_QWORD **)(v2 + 32), v2);
      }
    }
  }
}

uint64_t ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  void *v37;
  void *v38;
  void *v39;
  NSObject *v41;
  os_log_type_t v42;
  const char *v43;
  char *v44;
  _BOOL4 v45;
  char v46;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  void *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = nw_hash_node_get_object(a2);
  v4 = *(_QWORD *)(a1 + 40);
  if (!v4 || (*(_BYTE *)(v4 + 548) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v6 = *(_QWORD *)(a1 + 40);
      v7 = (const char *)(v6 + 464);
      v8 = "";
      v9 = v6 == 0;
      if (!v6)
        v7 = "";
      v10 = *(_DWORD *)(v6 + 460);
      if (!v9)
        v8 = " ";
      v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      *(_DWORD *)buf = 136447234;
      v49 = "nw_webtransport_session_destroy_block_invoke";
      v50 = 2082;
      v51 = (void *)v7;
      v52 = 2080;
      v53 = v8;
      v54 = 1024;
      v55 = v10;
      v56 = 2048;
      v57 = v11;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways", buf, 0x30u);
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v49 = "nw_webtransport_session_destroy_block_invoke";
  v12 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v46 = 0;
  if (__nwlog_fault(v12, &type, &v46))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_23;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_webtransport_session_destroy_block_invoke";
      v15 = "%{public}s should not have streams left when destroying";
LABEL_22:
      _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
      goto LABEL_23;
    }
    if (!v46)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_23;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_webtransport_session_destroy_block_invoke";
      v15 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
      goto LABEL_22;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    v14 = type;
    v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v17)
        goto LABEL_23;
      *(_DWORD *)buf = 136446210;
      v49 = "nw_webtransport_session_destroy_block_invoke";
      v15 = "%{public}s should not have streams left when destroying, no backtrace";
      goto LABEL_22;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v49 = "nw_webtransport_session_destroy_block_invoke";
      v50 = 2082;
      v51 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
  }
LABEL_23:
  if (v12)
    free(v12);
  if (!nw_hash_table_remove_node(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 184), a2))
  {
    v18 = *(_QWORD *)(a1 + 40);
    if (!v18 || (*(_BYTE *)(v18 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v20 = *(_QWORD *)(a1 + 40);
        v21 = (const char *)(v20 + 464);
        v22 = "";
        if (v20)
          v22 = " ";
        else
          v21 = "";
        v23 = *(_DWORD *)(v20 + 460);
        v24 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 64);
        *(_DWORD *)buf = 136447234;
        v49 = "nw_webtransport_session_destroy_block_invoke";
        v50 = 2082;
        v51 = (void *)v21;
        v52 = 2080;
        v53 = v22;
        v54 = 1024;
        v55 = v23;
        v56 = 2048;
        v57 = v24;
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table", buf, 0x30u);
      }
    }
  }
  v25 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v25)
  {
    if ((*(_BYTE *)(v25 + 276) & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v27 = *(_QWORD *)(v25 + 88);
        if (v27)
          v28 = *(_DWORD *)(v27 + 460);
        else
          v28 = -1;
        v29 = *(_QWORD *)(v25 + 64);
        *(_DWORD *)buf = 136447490;
        v49 = "nw_webtransport_stream_destroy";
        v50 = 2082;
        v51 = (void *)(v25 + 192);
        v52 = 2080;
        v53 = " ";
        v54 = 1024;
        v55 = v28;
        v56 = 2048;
        v57 = v29;
        v58 = 2048;
        v59 = v25;
        _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
      }
    }
    if (*(_QWORD *)(v25 + 72))
    {
      if ((*(_BYTE *)(v25 + 276) & 0x10) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v30 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v31 = *(_QWORD *)(v25 + 88);
          if (v31)
            v32 = *(_DWORD *)(v31 + 460);
          else
            v32 = -1;
          v33 = *(_QWORD *)(v25 + 64);
          *(_DWORD *)buf = 136447234;
          v49 = "nw_webtransport_stream_destroy";
          v50 = 2082;
          v51 = (void *)(v25 + 192);
          v52 = 2080;
          v53 = " ";
          v54 = 1024;
          v55 = v32;
          v56 = 2048;
          v57 = v33;
          _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
        }
      }
    }
    v34 = *(_QWORD *)(v25 + 72);
    if (v34)
    {
      do
      {
        v35 = *(_QWORD *)(v34 + 32);
        nw_frame_finalize(v34);
        v34 = v35;
      }
      while (v35);
    }
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v25 + 176) + 16))(*(_QWORD *)(v25 + 176), 0);
    v36 = *(const void **)(v25 + 176);
    if (v36)
    {
      _Block_release(v36);
      *(_QWORD *)(v25 + 176) = 0;
    }
    if ((*(_BYTE *)(v25 + 168) & 1) != 0)
    {
      v37 = *(void **)(v25 + 160);
      if (v37)
        os_release(v37);
    }
    *(_QWORD *)(v25 + 160) = 0;
    if ((*(_BYTE *)(v25 + 152) & 1) != 0)
    {
      v38 = *(void **)(v25 + 144);
      if (v38)
        os_release(v38);
    }
    *(_QWORD *)(v25 + 144) = 0;
    if ((*(_BYTE *)(v25 + 136) & 1) != 0)
    {
      v39 = *(void **)(v25 + 128);
      if (v39)
        os_release(v39);
    }
LABEL_60:
    free((void *)v25);
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v49 = "nw_webtransport_stream_destroy";
  v25 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v46 = 0;
  if (!__nwlog_fault((const char *)v25, &type, &v46))
  {
LABEL_77:
    if (!v25)
      return 1;
    goto LABEL_60;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    v41 = __nwlog_obj();
    v42 = type;
    if (!os_log_type_enabled(v41, type))
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_webtransport_stream_destroy";
    v43 = "%{public}s called with null webtransport_stream";
LABEL_76:
    _os_log_impl(&dword_182FBE000, v41, v42, v43, buf, 0xCu);
    goto LABEL_77;
  }
  if (!v46)
  {
    v41 = __nwlog_obj();
    v42 = type;
    if (!os_log_type_enabled(v41, type))
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_webtransport_stream_destroy";
    v43 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_76;
  }
  v44 = (char *)__nw_create_backtrace_string();
  v41 = __nwlog_obj();
  v42 = type;
  v45 = os_log_type_enabled(v41, type);
  if (!v44)
  {
    if (!v45)
      goto LABEL_77;
    *(_DWORD *)buf = 136446210;
    v49 = "nw_webtransport_stream_destroy";
    v43 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_76;
  }
  if (v45)
  {
    *(_DWORD *)buf = 136446466;
    v49 = "nw_webtransport_stream_destroy";
    v50 = 2082;
    v51 = v44;
    _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v44);
  if (v25)
    goto LABEL_60;
  return 1;
}

void std::destroy_at[abi:nn180100]<nw_webtransport_session,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  if ((*(_BYTE *)(a1 + 384) & 1) != 0)
  {
    v2 = *(void **)(a1 + 376);
    if (v2)
      os_release(v2);
  }
  *(_QWORD *)(a1 + 376) = 0;
  if ((*(_BYTE *)(a1 + 368) & 1) != 0)
  {
    v3 = *(void **)(a1 + 360);
    if (v3)
      os_release(v3);
  }
  *(_QWORD *)(a1 + 360) = 0;
  if ((*(_BYTE *)(a1 + 352) & 1) != 0)
  {
    v4 = *(void **)(a1 + 344);
    if (v4)
      os_release(v4);
  }
  *(_QWORD *)(a1 + 344) = 0;
}

void ___ZL47nw_protocol_webtransport_http2_stream_callbacksv_block_invoke()
{
  qword_1EDCF1CD0 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCF1CD8 = nw_protocol_default_input_flush;
  qword_1EDCF1CA0 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCF1CA8 = nw_protocol_default_waiting_for_output;
  qword_1EDCF1C60 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCF1C68 = nw_protocol_default_unregister_notification;
  qword_1EDCF1C40 = (uint64_t)nw_protocol_webtransport_stream_get_parameters;
  unk_1EDCF1C48 = nw_protocol_default_get_path;
  qword_1EDCF1C50 = (uint64_t)nw_protocol_default_get_local;
  unk_1EDCF1C58 = nw_protocol_webtransport_stream_get_remote_endpoint;
  qword_1EDCF1C00 = (uint64_t)nw_protocol_webtransport_stream_disconnected;
  unk_1EDCF1C08 = nw_protocol_webtransport_stream_error;
  qword_1EDCF1C10 = (uint64_t)nw_protocol_webtransport_stream_input_available;
  unk_1EDCF1C18 = nw_protocol_webtransport_stream_output_available;
  qword_1EDCF1C70 = (uint64_t)nw_protocol_webtransport_stream_notify;
  unk_1EDCF1C78 = nw_protocol_default_updated_path;
  qword_1EDCF1CB0 = (uint64_t)nw_protocol_webtransport_stream_copy_info;
  unk_1EDCF1CB8 = nw_protocol_webtransport_stream_add_listen_handler;
  qword_1EDCF1CC0 = (uint64_t)nw_protocol_webtransport_stream_remove_listen_handler;
  unk_1EDCF1CC8 = nw_protocol_webtransport_stream_get_message_properties;
  nw_protocol_webtransport_http2_stream_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_stream_add_input_handler;
  *(_QWORD *)algn_1EDCF1BD8 = nw_protocol_webtransport_http2_stream_remove_input_handler;
  qword_1EDCF1BE0 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1EDCF1BE8 = nw_protocol_webtransport_http2_stream_connect;
  qword_1EDCF1BF0 = (uint64_t)nw_protocol_webtransport_stream_disconnect;
  unk_1EDCF1BF8 = nw_protocol_webtransport_http2_stream_connected;
  qword_1EDCF1C20 = (uint64_t)nw_protocol_webtransport_http2_stream_get_input_frames;
  unk_1EDCF1C28 = nw_protocol_webtransport_http2_stream_get_output_frames;
  qword_1EDCF1C30 = (uint64_t)nw_protocol_webtransport_http2_stream_finalize_output_frames;
  unk_1EDCF1C38 = nw_protocol_default_link_state;
  qword_1EDCF1C80 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1EDCF1C88 = nw_protocol_webtransport_http2_stream_input_finished;
  qword_1EDCF1C90 = (uint64_t)nw_protocol_webtransport_http2_stream_output_finished;
  unk_1EDCF1C98 = nw_protocol_default_get_output_local;
}

uint64_t nw_protocol_webtransport_http2_stream_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  void *v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  nw_protocol *default_input_handler;
  _BOOL8 node;
  uint64_t v13;
  int v14;
  const char *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  int v27;
  uint64_t v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  uint64_t v32;
  const char *v33;
  int v34;
  NSObject *v35;
  os_log_type_t v36;
  uint32_t v37;
  NSObject *v38;
  os_log_type_t v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  os_log_type_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  int v52;
  const char *v53;
  NSObject *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  NSObject *v58;
  uint64_t v59;
  int v60;
  NSObject *v61;
  int v62;
  uint64_t v63;
  void *v64;
  os_unfair_lock_s *v65;
  _BOOL8 some_node;
  uint64_t object;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const void *v72;
  void *v73;
  void *v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  int v80;
  NSObject *v81;
  int v82;
  __n128 v83;
  uint64_t v84;
  NSObject *v85;
  int v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  os_unfair_lock_s *v90;
  uint64_t v91;
  NSObject *v92;
  int v93;
  uint64_t v94;
  char *v95;
  uint64_t v96;
  os_log_type_t v97;
  NSObject *v98;
  os_log_type_t v99;
  const char *v100;
  char *v101;
  NSObject *v102;
  os_log_type_t v103;
  _BOOL4 v104;
  uint64_t v105;
  os_log_type_t v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  NSObject *v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  NSObject *v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  const void *v120;
  void *v121;
  void *v122;
  void *v123;
  NSObject *v124;
  os_log_type_t v125;
  NSObject *v126;
  os_log_type_t v127;
  const char *v128;
  char *v129;
  NSObject *v130;
  os_log_type_t v131;
  _BOOL4 v132;
  NSObject *v133;
  os_log_type_t v134;
  uint64_t v135;
  const void *v136;
  char *v137;
  NSObject *v138;
  os_log_type_t v139;
  const char *v140;
  NSObject *v141;
  uint64_t v142;
  int v143;
  char *backtrace_string;
  _BOOL4 v145;
  const char *v146;
  _BOOL4 v147;
  _BOOL4 v148;
  char *v149;
  NSObject *v150;
  os_log_type_t v151;
  const char *v152;
  NSObject *v153;
  int v154;
  uint64_t v155;
  char *v156;
  _BOOL4 v157;
  NSObject *v158;
  uint64_t v159;
  int v160;
  NSObject *v161;
  int v162;
  NSObject *v163;
  int v164;
  uint64_t v165;
  int v166;
  NSObject *v167;
  uint64_t v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  _QWORD v172[5];
  os_log_type_t type[8];
  uint64_t v174;
  uint64_t (*v175)(uint64_t, uint64_t);
  void *v176;
  uint64_t *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t *v180;
  uint64_t v181;
  uint64_t v182;
  char v183;
  os_log_type_t v184;
  _BYTE buf[12];
  __int16 v186;
  const char *v187;
  __int16 v188;
  uint64_t v189;
  __int16 v190;
  _BYTE v191[24];
  __int16 v192;
  nw_protocol *v193;
  __int16 v194;
  nw_protocol *v195;
  uint64_t v196;

  v196 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v137, type, v172))
      goto LABEL_278;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null protocol";
      goto LABEL_277;
    }
    if (!LOBYTE(v172[0]))
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_277;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = type[0];
    v145 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v145)
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_277;
    }
    if (!v145)
      goto LABEL_251;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    v186 = 2082;
    v187 = backtrace_string;
    v146 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_250:
    _os_log_impl(&dword_182FBE000, v138, v139, v146, buf, 0x16u);
    goto LABEL_251;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v137, type, v172))
      goto LABEL_278;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null webtransport_stream";
      goto LABEL_277;
    }
    if (!LOBYTE(v172[0]))
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_277;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = type[0];
    v147 = os_log_type_enabled(v138, type[0]);
    if (!backtrace_string)
    {
      if (!v147)
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_277;
    }
    if (!v147)
      goto LABEL_251;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    v186 = 2082;
    v187 = backtrace_string;
    v146 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_250;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    v137 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v137, type, v172))
      goto LABEL_278;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null input_protocol";
      goto LABEL_277;
    }
    if (!LOBYTE(v172[0]))
    {
      v138 = __nwlog_obj();
      v139 = type[0];
      if (!os_log_type_enabled(v138, type[0]))
        goto LABEL_278;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v140 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_277;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = type[0];
    v148 = os_log_type_enabled(v138, type[0]);
    if (backtrace_string)
    {
      if (v148)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
        v186 = 2082;
        v187 = backtrace_string;
        v146 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_250;
      }
LABEL_251:
      free(backtrace_string);
      goto LABEL_278;
    }
    if (!v148)
      goto LABEL_278;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
    v140 = "%{public}s called with null input_protocol, no backtrace";
LABEL_277:
    _os_log_impl(&dword_182FBE000, v138, v139, v140, buf, 0xCu);
LABEL_278:
    if (v137)
      free(v137);
    return 0;
  }
  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v141 = __nwlog_obj();
      if (os_log_type_enabled(v141, OS_LOG_TYPE_DEBUG))
      {
        v142 = *((_QWORD *)handle + 11);
        if (v142)
          v143 = *(_DWORD *)(v142 + 460);
        else
          v143 = -1;
        v155 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
        v186 = 2082;
        v187 = handle + 192;
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v143;
        *(_WORD *)&v191[4] = 2048;
        *(_QWORD *)&v191[6] = v155;
        _os_log_impl(&dword_182FBE000, v141, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  v5 = &unk_1ECD84000;
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *((_QWORD *)handle + 11);
      if (v7)
        v8 = *(_DWORD *)(v7 + 460);
      else
        v8 = -1;
      v9 = *((_QWORD *)handle + 8);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136448002;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_remove_input_handler";
      v186 = 2082;
      v187 = handle + 192;
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v8;
      *(_WORD *)&v191[4] = 2048;
      *(_QWORD *)&v191[6] = v9;
      *(_WORD *)&v191[14] = 2048;
      *(_QWORD *)&v191[16] = a1;
      v192 = 2048;
      v193 = default_input_handler;
      v194 = 2048;
      v195 = a2;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%lld> protocol %p, default_input_handler %p, input protocol %p", buf, 0x4Eu);
    }
  }
  if (a2->output_handler == a1)
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  if (a1->default_input_handler != a2)
    return 0;
  v171 = *((_QWORD *)handle + 11);
  if (!v171)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
    v149 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (!__nwlog_fault(v149, type, v172))
      goto LABEL_292;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v150 = __nwlog_obj();
      v151 = type[0];
      if (!os_log_type_enabled(v150, type[0]))
        goto LABEL_292;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v152 = "%{public}s called with null webtransport_session";
    }
    else if (LOBYTE(v172[0]))
    {
      v156 = (char *)__nw_create_backtrace_string();
      v150 = __nwlog_obj();
      v151 = type[0];
      v157 = os_log_type_enabled(v150, type[0]);
      if (v156)
      {
        if (v157)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = v156;
          _os_log_impl(&dword_182FBE000, v150, v151, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v156);
        goto LABEL_292;
      }
      if (!v157)
      {
LABEL_292:
        if (v149)
          free(v149);
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v152 = "%{public}s called with null webtransport_session, no backtrace";
    }
    else
    {
      v150 = __nwlog_obj();
      v151 = type[0];
      if (!os_log_type_enabled(v150, type[0]))
        goto LABEL_292;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v152 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v150, v151, v152, buf, 0xCu);
    goto LABEL_292;
  }
  if ((handle[276] & 0x20) != 0)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v153 = __nwlog_obj();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEBUG))
        {
          v154 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v154;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = handle;
          _os_log_impl(&dword_182FBE000, v153, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
        }
      }
    }
    if ((handle[276] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
      v186 = 2048;
      v187 = handle;
      v16 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v172[0]) = 0;
      if (__nwlog_fault(v16, type, v172))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = gLogObj;
          v18 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2048;
            v187 = handle;
            v19 = "%{public}s stream %p not in pending list, cannot remove";
LABEL_58:
            v38 = v17;
            v39 = v18;
LABEL_59:
            _os_log_impl(&dword_182FBE000, v38, v39, v19, buf, 0x16u);
          }
        }
        else if (LOBYTE(v172[0]))
        {
          v23 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = gLogObj;
          v25 = type[0];
          v26 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v23)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              v186 = 2048;
              v187 = handle;
              v188 = 2082;
              v189 = (uint64_t)v23;
              _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v23);
            goto LABEL_60;
          }
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2048;
            v187 = handle;
            v19 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            v38 = v24;
            v39 = v25;
            goto LABEL_59;
          }
        }
        else
        {
          v17 = __nwlog_obj();
          v18 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2048;
            v187 = handle;
            v19 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            goto LABEL_58;
          }
        }
      }
LABEL_60:
      if (v16)
        free(v16);
      v5 = &unk_1ECD84000;
      goto LABEL_79;
    }
    v20 = *((_QWORD *)handle + 14);
    v21 = (_QWORD *)*((_QWORD *)handle + 15);
    if (v20)
    {
      *(_QWORD *)(v20 + 120) = v21;
      v21 = (_QWORD *)*((_QWORD *)handle + 15);
      v22 = v171;
    }
    else
    {
      v22 = v171;
      *(_QWORD *)(v171 + 336) = v21;
    }
    *v21 = v20;
    *((_QWORD *)handle + 14) = 0;
    *((_QWORD *)handle + 15) = 0;
    v27 = *(_DWORD *)(v22 + 456);
    *(_DWORD *)(v22 + 456) = v27 - 1;
    if (v27)
    {
LABEL_77:
      v48 = handle[276];
      handle[276] = v48 & 0xDF;
      if ((v48 & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v158 = __nwlog_obj();
          if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
          {
            v159 = *((_QWORD *)handle + 11);
            if (v159)
              v160 = *(_DWORD *)(v159 + 460);
            else
              v160 = -1;
            v165 = *((_QWORD *)handle + 8);
            v166 = *(_DWORD *)(v171 + 456);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2082;
            v187 = handle + 192;
            v188 = 2080;
            v189 = (uint64_t)" ";
            v190 = 1024;
            *(_DWORD *)v191 = v160;
            *(_WORD *)&v191[4] = 2048;
            *(_QWORD *)&v191[6] = v165;
            *(_WORD *)&v191[14] = 2048;
            *(_QWORD *)&v191[16] = handle;
            v192 = 1024;
            LODWORD(v193) = v166;
            v15 = "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams";
            v35 = v158;
            v36 = OS_LOG_TYPE_DEBUG;
            v37 = 64;
            goto LABEL_55;
          }
        }
      }
      goto LABEL_79;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = *(unsigned int *)(v171 + 456);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
    v186 = 2082;
    v187 = "webtransport_session->pending_stream_count";
    v188 = 2048;
    v189 = 1;
    v190 = 2048;
    *(_QWORD *)v191 = v28;
    v29 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v172[0]) = 0;
    if (__nwlog_fault(v29, type, v172))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v30 = __nwlog_obj();
        v31 = type[0];
        if (os_log_type_enabled(v30, type[0]))
        {
          v32 = *(unsigned int *)(v171 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = "webtransport_session->pending_stream_count";
          v188 = 2048;
          v189 = 1;
          v190 = 2048;
          *(_QWORD *)v191 = v32;
          v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_72:
          v46 = v30;
          v47 = v31;
LABEL_73:
          _os_log_impl(&dword_182FBE000, v46, v47, v33, buf, 0x2Au);
        }
      }
      else if (LOBYTE(v172[0]))
      {
        v40 = (char *)__nw_create_backtrace_string();
        v41 = __nwlog_obj();
        v42 = type[0];
        v43 = os_log_type_enabled(v41, type[0]);
        if (v40)
        {
          if (v43)
          {
            v44 = *(unsigned int *)(v171 + 456);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v186 = 2082;
            v187 = "webtransport_session->pending_stream_count";
            v188 = 2048;
            v189 = 1;
            v190 = 2048;
            *(_QWORD *)v191 = v44;
            *(_WORD *)&v191[8] = 2082;
            *(_QWORD *)&v191[10] = v40;
            _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v40);
          goto LABEL_74;
        }
        if (v43)
        {
          v135 = *(unsigned int *)(v171 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = "webtransport_session->pending_stream_count";
          v188 = 2048;
          v189 = 1;
          v190 = 2048;
          *(_QWORD *)v191 = v135;
          v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          v46 = v41;
          v47 = v42;
          goto LABEL_73;
        }
      }
      else
      {
        v30 = __nwlog_obj();
        v31 = type[0];
        if (os_log_type_enabled(v30, type[0]))
        {
          v45 = *(unsigned int *)(v171 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v186 = 2082;
          v187 = "webtransport_session->pending_stream_count";
          v188 = 2048;
          v189 = 1;
          v190 = 2048;
          *(_QWORD *)v191 = v45;
          v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_72;
        }
      }
    }
LABEL_74:
    if (v29)
      free(v29);
    *(_DWORD *)(v171 + 456) = 0;
    v5 = &unk_1ECD84000;
    goto LABEL_77;
  }
  if (*(char **)(v171 + 416) == handle)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v161 = __nwlog_obj();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
        {
          v162 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v162;
          _os_log_impl(&dword_182FBE000, v161, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing placeholder stream for session", buf, 0x26u);
        }
      }
    }
    *(_QWORD *)(v171 + 416) = 0;
  }
  else if (*(char **)(v171 + 424) == handle)
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v163 = __nwlog_obj();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
        {
          v164 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v164;
          _os_log_impl(&dword_182FBE000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing datagram stream for session", buf, 0x26u);
        }
      }
    }
    *(_QWORD *)(v171 + 424) = 0;
  }
  else
  {
    *(_QWORD *)type = *((_QWORD *)handle + 8);
    node = nw_hash_table_get_node(*(_QWORD *)(v171 + 184), (uint64_t)type, 8);
    if (node)
    {
      if (!nw_hash_table_remove_node(*(_QWORD *)(v171 + 184), node) && (*(_BYTE *)(v171 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v14 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v14;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = *(_QWORD *)type;
          v15 = "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table";
LABEL_54:
          v35 = v13;
          v36 = OS_LOG_TYPE_ERROR;
          v37 = 48;
LABEL_55:
          _os_log_impl(&dword_182FBE000, v35, v36, v15, buf, v37);
        }
      }
    }
    else if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v34 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v34;
        *(_WORD *)&v191[4] = 2048;
        *(_QWORD *)&v191[6] = *(_QWORD *)type;
        v15 = "%{public}s %{public}s%s<i%u> called remove_input_handler with stream id %lld, but no stream found";
        goto LABEL_54;
      }
    }
  }
LABEL_79:
  *((_QWORD *)handle + 11) = 0;
  v49 = v171;
  if (*(char **)(v171 + 48) != handle)
    goto LABEL_86;
  if (*(_DWORD *)(v171 + 444))
  {
    v50 = *(_QWORD *)(v171 + 424);
    if (v50)
    {
LABEL_82:
      nw_protocol_set_input_handler(v49, v50);
      if ((*(_BYTE *)(v49 + 548) & 2) != 0)
        goto LABEL_86;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v51 = *((_QWORD *)v5 + 463);
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
        goto LABEL_86;
      v52 = *(_DWORD *)(v49 + 460);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v49 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v52;
      v53 = "%{public}s %{public}s%s<i%u> not destroying, still have datagram stream";
      goto LABEL_85;
    }
  }
  else
  {
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v61 = *((_QWORD *)v5 + 463);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        v62 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v62;
        _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> first input handler bailed, closing", buf, 0x26u);
      }
    }
    v49 = v171;
    v63 = *(_QWORD *)(v171 + 432);
    v64 = *(void **)(v171 + 392);
    v172[0] = MEMORY[0x1E0C809B0];
    v172[1] = 0x40000000;
    v172[2] = ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke;
    v172[3] = &unk_1E14A0498;
    v172[4] = v63;
    nw_queue_context_async(v64, v172);
    v50 = *(_QWORD *)(v171 + 424);
    if (v50)
      goto LABEL_82;
  }
  v65 = *(os_unfair_lock_s **)(v49 + 184);
  if (v65 && v65[10]._os_unfair_lock_opaque)
  {
    some_node = nw_hash_table_get_some_node(v65);
    object = nw_hash_node_get_object(some_node);
    nw_protocol_set_input_handler(v171, object);
    if ((*(_BYTE *)(v171 + 548) & 2) != 0)
      goto LABEL_86;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = *((_QWORD *)v5 + 463);
    if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
      goto LABEL_86;
    v68 = *(_DWORD *)(v171 + 460);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
    v186 = 2082;
    v187 = (const char *)(v171 + 464);
    v188 = 2080;
    v189 = (uint64_t)" ";
    v190 = 1024;
    *(_DWORD *)v191 = v68;
    v53 = "%{public}s %{public}s%s<i%u> not destroying, still have active streams";
    goto LABEL_85;
  }
  v76 = v171;
  if (!*(_DWORD *)(v171 + 456))
  {
    v79 = *(_QWORD *)(v171 + 416);
    if (v79)
    {
      nw_protocol_set_input_handler(v171, v79);
      if ((*(_BYTE *)(v171 + 548) & 2) != 0)
        goto LABEL_86;
      v51 = __nwlog_obj();
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
        goto LABEL_86;
      v80 = *(_DWORD *)(v171 + 460);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v186 = 2082;
      v187 = (const char *)(v171 + 464);
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v80;
      v53 = "%{public}s %{public}s%s<i%u> not destroying, still have placeholder stream";
      goto LABEL_85;
    }
    nw_protocol_set_input_handler(v171, 0);
    if ((*(_BYTE *)(v171 + 548) & 2) == 0)
    {
      v81 = __nwlog_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_INFO))
      {
        v82 = *(_DWORD *)(v171 + 460);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
        v186 = 2082;
        v187 = (const char *)(v171 + 464);
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v82;
        _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> called, destroying session", buf, 0x26u);
      }
    }
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 344, buf);
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 360, buf);
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v171 + 376, buf);
    nw_http_capsule_framer_cleanup((_QWORD *)(v171 + 96), v83);
    v84 = *(_QWORD *)(v171 + 400);
    if (v84)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v84 + 8))(v84, v171, 0);
    if ((*(_BYTE *)(v171 + 548) & 4) != 0)
    {
      if ((nw_protocol_remove_listen_handler(*(_QWORD *)(v171 + 408), v171 + 64) & 1) == 0
        && (*(_BYTE *)(v171 + 548) & 2) == 0)
      {
        v85 = __nwlog_obj();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
        {
          v86 = *(_DWORD *)(v171 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v86;
          _os_log_impl(&dword_182FBE000, v85, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> failed to remove listen handler", buf, 0x26u);
        }
      }
      *(_QWORD *)(v171 + 408) = 0;
    }
    v87 = *(_QWORD *)(v171 + 32);
    if (v87)
      nw_protocol_remove_input_handler(v87, v171);
    v179 = 0;
    v180 = &v179;
    v181 = 0x2000000000;
    v182 = 0;
    v88 = *(char **)(v171 + 184);
    if (v88)
    {
      *(_QWORD *)type = MEMORY[0x1E0C809B0];
      v174 = 0x40000000;
      v175 = ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke;
      v176 = &unk_1E14A04E0;
      v177 = &v179;
      v178 = v171;
      nw_hash_table_apply(v88, (uint64_t)type);
      v90 = *(os_unfair_lock_s **)(v171 + 184);
      if (v90)
      {
        _nw_hash_table_release(v90, v89);
        *(_QWORD *)(v171 + 184) = 0;
      }
    }
    v91 = *(_QWORD *)(v171 + 328);
    v180[3] = v91;
    if (!v91)
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v171 + 432) + 16))(*(_QWORD *)(v171 + 432), 0);
      v136 = *(const void **)(v171 + 432);
      if (v136)
      {
        _Block_release(v136);
        *(_QWORD *)(v171 + 432) = 0;
      }
      std::destroy_at[abi:nn180100]<nw_webtransport_session,0>(v171);
      free((void *)v171);
      _Block_object_dispose(&v179, 8);
      goto LABEL_86;
    }
    while (1)
    {
      v91 = *(_QWORD *)(v91 + 112);
      if ((*(_BYTE *)(v76 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v92 = *((_QWORD *)v5 + 463);
        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          v93 = *(_DWORD *)(v76 + 460);
          v94 = v180[3];
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = (const char *)(v171 + 464);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v93;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = v94;
          _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways", buf, 0x30u);
        }
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
      v95 = (char *)_os_log_send_and_compose_impl();
      v184 = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (__nwlog_fault(v95, &v184, &v183))
      {
        if (v184 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v96 = gLogObj;
          v97 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184))
            goto LABEL_167;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v98 = v96;
          v99 = v97;
          v100 = "%{public}s should not have streams left when destroying";
LABEL_166:
          _os_log_impl(&dword_182FBE000, v98, v99, v100, buf, 0xCu);
          goto LABEL_167;
        }
        if (!v183)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v105 = gLogObj;
          v106 = v184;
          if (!os_log_type_enabled((os_log_t)gLogObj, v184))
            goto LABEL_167;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v98 = v105;
          v99 = v106;
          v100 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
          goto LABEL_166;
        }
        v101 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v102 = gLogObj;
        v103 = v184;
        v104 = os_log_type_enabled((os_log_t)gLogObj, v184);
        if (!v101)
        {
          if (!v104)
            goto LABEL_167;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v98 = v102;
          v99 = v103;
          v100 = "%{public}s should not have streams left when destroying, no backtrace";
          goto LABEL_166;
        }
        if (v104)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v186 = 2082;
          v187 = v101;
          _os_log_impl(&dword_182FBE000, v102, v103, "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v101);
      }
LABEL_167:
      if (v95)
        free(v95);
      v107 = *(_QWORD *)(v91 + 112);
      v108 = *(_QWORD **)(v91 + 120);
      if (v107)
      {
        *(_QWORD *)(v107 + 120) = v108;
        v108 = *(_QWORD **)(v91 + 120);
      }
      else
      {
        *(_QWORD *)(v171 + 336) = v108;
      }
      *v108 = v107;
      *(_QWORD *)(v91 + 112) = 0;
      *(_QWORD *)(v91 + 120) = 0;
      v109 = v180[3];
      v5 = &unk_1ECD84000;
      if (v109)
      {
        if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v110 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            v111 = *(_QWORD *)(v109 + 88);
            if (v111)
              v112 = *(_DWORD *)(v111 + 460);
            else
              v112 = -1;
            v113 = *(_QWORD *)(v109 + 64);
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
            v186 = 2082;
            v187 = (const char *)(v109 + 192);
            v188 = 2080;
            v189 = (uint64_t)" ";
            v190 = 1024;
            *(_DWORD *)v191 = v112;
            *(_WORD *)&v191[4] = 2048;
            *(_QWORD *)&v191[6] = v113;
            *(_WORD *)&v191[14] = 2048;
            *(_QWORD *)&v191[16] = v109;
            _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
          }
        }
        if (*(_QWORD *)(v109 + 72))
        {
          if ((*(_BYTE *)(v109 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v114 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              v115 = *(_QWORD *)(v109 + 88);
              if (v115)
                v116 = *(_DWORD *)(v115 + 460);
              else
                v116 = -1;
              v117 = *(_QWORD *)(v109 + 64);
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
              v186 = 2082;
              v187 = (const char *)(v109 + 192);
              v188 = 2080;
              v189 = (uint64_t)" ";
              v190 = 1024;
              *(_DWORD *)v191 = v116;
              *(_WORD *)&v191[4] = 2048;
              *(_QWORD *)&v191[6] = v117;
              _os_log_impl(&dword_182FBE000, v114, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
            }
          }
        }
        v118 = *(_QWORD *)(v109 + 72);
        if (v118)
        {
          do
          {
            v119 = *(_QWORD *)(v118 + 32);
            nw_frame_finalize(v118);
            v118 = v119;
          }
          while (v119);
        }
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v109 + 176) + 16))(*(_QWORD *)(v109 + 176), 0);
        v120 = *(const void **)(v109 + 176);
        if (v120)
        {
          _Block_release(v120);
          *(_QWORD *)(v109 + 176) = 0;
        }
        if ((*(_BYTE *)(v109 + 168) & 1) != 0)
        {
          v121 = *(void **)(v109 + 160);
          if (v121)
            os_release(v121);
        }
        *(_QWORD *)(v109 + 160) = 0;
        if ((*(_BYTE *)(v109 + 152) & 1) != 0)
        {
          v122 = *(void **)(v109 + 144);
          if (v122)
            os_release(v122);
        }
        *(_QWORD *)(v109 + 144) = 0;
        if ((*(_BYTE *)(v109 + 136) & 1) != 0)
        {
          v123 = *(void **)(v109 + 128);
          if (v123)
            os_release(v123);
        }
LABEL_199:
        free((void *)v109);
        goto LABEL_200;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
      v109 = _os_log_send_and_compose_impl();
      v184 = OS_LOG_TYPE_ERROR;
      v183 = 0;
      if (!__nwlog_fault((const char *)v109, &v184, &v183))
        goto LABEL_216;
      if (v184 == OS_LOG_TYPE_FAULT)
      {
        v124 = __nwlog_obj();
        v125 = v184;
        if (os_log_type_enabled(v124, v184))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
          v126 = v124;
          v127 = v125;
          v128 = "%{public}s called with null webtransport_stream";
          goto LABEL_215;
        }
LABEL_216:
        if (v109)
          goto LABEL_199;
        goto LABEL_200;
      }
      if (!v183)
      {
        v133 = __nwlog_obj();
        v134 = v184;
        if (!os_log_type_enabled(v133, v184))
          goto LABEL_216;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v126 = v133;
        v127 = v134;
        v128 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
LABEL_215:
        _os_log_impl(&dword_182FBE000, v126, v127, v128, buf, 0xCu);
        goto LABEL_216;
      }
      v129 = (char *)__nw_create_backtrace_string();
      v130 = __nwlog_obj();
      v131 = v184;
      v132 = os_log_type_enabled(v130, v184);
      if (!v129)
      {
        v5 = &unk_1ECD84000;
        if (!v132)
          goto LABEL_216;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v126 = v130;
        v127 = v131;
        v128 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_215;
      }
      if (v132)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v186 = 2082;
        v187 = v129;
        _os_log_impl(&dword_182FBE000, v130, v131, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v129);
      v5 = &unk_1ECD84000;
      if (v109)
        goto LABEL_199;
LABEL_200:
      v180[3] = v91;
      v76 = v171;
    }
  }
  v77 = *(_QWORD *)(v171 + 328);
  if (v77)
  {
    if ((*(_BYTE *)(v77 + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v167 = __nwlog_obj();
        if (os_log_type_enabled(v167, OS_LOG_TYPE_DEBUG))
        {
          v168 = *(_QWORD *)(v77 + 88);
          if (v168)
            v169 = *(_DWORD *)(v168 + 460);
          else
            v169 = -1;
          v170 = *(_QWORD *)(v77 + 64);
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
          v186 = 2082;
          v187 = (const char *)(v77 + 192);
          v188 = 2080;
          v189 = (uint64_t)" ";
          v190 = 1024;
          *(_DWORD *)v191 = v169;
          *(_WORD *)&v191[4] = 2048;
          *(_QWORD *)&v191[6] = v170;
          *(_WORD *)&v191[14] = 2048;
          *(_QWORD *)&v191[16] = v77;
          _os_log_impl(&dword_182FBE000, v167, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
        }
      }
    }
  }
  nw_protocol_set_input_handler(v171, v77);
  if ((*(_BYTE *)(v171 + 548) & 2) != 0)
    goto LABEL_86;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v51 = *((_QWORD *)v5 + 463);
  if (!os_log_type_enabled(v51, OS_LOG_TYPE_INFO))
    goto LABEL_86;
  v78 = *(_DWORD *)(v171 + 460);
  *(_DWORD *)buf = 136446978;
  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
  v186 = 2082;
  v187 = (const char *)(v171 + 464);
  v188 = 2080;
  v189 = (uint64_t)" ";
  v190 = 1024;
  *(_DWORD *)v191 = v78;
  v53 = "%{public}s %{public}s%s<i%u> not destroying, still have pending streams";
LABEL_85:
  _os_log_impl(&dword_182FBE000, v51, OS_LOG_TYPE_INFO, v53, buf, 0x26u);
LABEL_86:
  nw_protocol_set_output_handler((uint64_t)a1, 0);
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v54 = *((_QWORD *)v5 + 463);
    if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
    {
      v55 = *((_QWORD *)handle + 11);
      if (v55)
        v56 = *(_DWORD *)(v55 + 460);
      else
        v56 = -1;
      v57 = *((_QWORD *)handle + 8);
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
      v186 = 2082;
      v187 = handle + 192;
      v188 = 2080;
      v189 = (uint64_t)" ";
      v190 = 1024;
      *(_DWORD *)v191 = v56;
      *(_WORD *)&v191[4] = 2048;
      *(_QWORD *)&v191[6] = v57;
      *(_WORD *)&v191[14] = 2048;
      *(_QWORD *)&v191[16] = handle;
      _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
    }
  }
  if (*((_QWORD *)handle + 9))
  {
    if ((handle[276] & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v58 = *((_QWORD *)v5 + 463);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        v59 = *((_QWORD *)handle + 11);
        if (v59)
          v60 = *(_DWORD *)(v59 + 460);
        else
          v60 = -1;
        v69 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v186 = 2082;
        v187 = handle + 192;
        v188 = 2080;
        v189 = (uint64_t)" ";
        v190 = 1024;
        *(_DWORD *)v191 = v60;
        *(_WORD *)&v191[4] = 2048;
        *(_QWORD *)&v191[6] = v69;
        _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
      }
    }
  }
  v70 = *((_QWORD *)handle + 9);
  if (v70)
  {
    do
    {
      v71 = *(_QWORD *)(v70 + 32);
      nw_frame_finalize(v70);
      v70 = v71;
    }
    while (v71);
  }
  (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)handle + 22) + 16))(*((_QWORD *)handle + 22), 0);
  v72 = (const void *)*((_QWORD *)handle + 22);
  if (v72)
  {
    _Block_release(v72);
    *((_QWORD *)handle + 22) = 0;
  }
  if ((handle[168] & 1) != 0)
  {
    v73 = (void *)*((_QWORD *)handle + 20);
    if (v73)
      os_release(v73);
  }
  *((_QWORD *)handle + 20) = 0;
  if ((handle[152] & 1) != 0)
  {
    v74 = (void *)*((_QWORD *)handle + 18);
    if (v74)
      os_release(v74);
  }
  *((_QWORD *)handle + 18) = 0;
  if ((handle[136] & 1) != 0)
  {
    v75 = (void *)*((_QWORD *)handle + 16);
    if (v75)
      os_release(v75);
  }
  free(handle);
  return 1;
}

uint64_t nw_protocol_webtransport_http2_stream_connect(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  char *backtrace_string;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  uint64_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((*((_BYTE *)handle + 276) & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v9 = __nwlog_obj();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            v10 = handle[11];
            if (v10)
              v11 = *(_DWORD *)(v10 + 460);
            else
              v11 = -1;
            v16 = handle[8];
            *(_DWORD *)buf = 136447234;
            v20 = "nw_protocol_webtransport_http2_stream_connect";
            v21 = 2082;
            v22 = (char *)(handle + 24);
            v23 = 2080;
            v24 = " ";
            v25 = 1024;
            v26 = v11;
            v27 = 2048;
            v28 = v16;
            _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
          }
        }
      }
      nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a1);
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_http2_stream_connect";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http2_stream_connect";
        v8 = "%{public}s called with null webtransport_stream";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v17)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http2_stream_connect";
        v8 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v15 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http2_stream_connect";
        v8 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_webtransport_http2_stream_connect";
      v21 = 2082;
      v22 = backtrace_string;
      v14 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_protocol_webtransport_http2_stream_connect";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (!__nwlog_fault(v5, &type, &v17))
    goto LABEL_39;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http2_stream_connect";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v13 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_webtransport_http2_stream_connect";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_webtransport_http2_stream_connect";
      v21 = 2082;
      v22 = backtrace_string;
      v14 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_182FBE000, v6, v7, v14, buf, 0x16u);
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_39;
  }
  v6 = __nwlog_obj();
  v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_webtransport_http2_stream_connect";
    v8 = "%{public}s called with null protocol";
LABEL_38:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
  }
LABEL_39:
  if (v5)
    free(v5);
  return 0;
}

void nw_protocol_webtransport_http2_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  unsigned __int8 *handle;
  int v4;
  nw_protocol *v6;
  unsigned __int8 v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t default_input_handler;
  NSObject *v17;
  int v18;
  const char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  uint32_t v29;
  uint64_t internal;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  uint64_t v43;
  int v44;
  char v45;
  unint64_t v46;
  nw_protocol *output_handler;
  int v48;
  uint64_t v49;
  const char *v50;
  NSObject *v51;
  os_log_type_t v52;
  nw_protocol *v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  const char *v61;
  NSObject *v62;
  uint64_t v63;
  int v64;
  char *backtrace_string;
  _BOOL4 v66;
  char *v67;
  _BOOL4 v68;
  const char *v69;
  NSObject *v70;
  os_log_type_t v71;
  const char *v72;
  NSObject *v73;
  uint64_t v74;
  int v75;
  char *v76;
  _BOOL4 v77;
  NSObject *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  _BOOL4 v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  char *v88;
  char v89;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v92;
  __int16 v93;
  char *p_identifier;
  __int16 v95;
  const char *v96;
  __int16 v97;
  int v98;
  __int16 v99;
  uint64_t v100;
  __int16 v101;
  _BYTE v102[10];
  uint64_t v103;
  __int16 v104;
  nw_protocol *v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v92 = "nw_protocol_webtransport_http2_stream_connected";
    v58 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v89 = 0;
    if (!__nwlog_fault(v58, &type, &v89))
      goto LABEL_142;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v59 = __nwlog_obj();
      v60 = type;
      if (!os_log_type_enabled(v59, type))
        goto LABEL_142;
      *(_DWORD *)buf = 136446210;
      v92 = "nw_protocol_webtransport_http2_stream_connected";
      v61 = "%{public}s called with null protocol";
    }
    else if (v89)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v59 = __nwlog_obj();
      v60 = type;
      v66 = os_log_type_enabled(v59, type);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          v92 = "nw_protocol_webtransport_http2_stream_connected";
          v93 = 2082;
          p_identifier = backtrace_string;
          _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_142:
        if (!v58)
          return;
LABEL_143:
        free(v58);
        return;
      }
      if (!v66)
        goto LABEL_142;
      *(_DWORD *)buf = 136446210;
      v92 = "nw_protocol_webtransport_http2_stream_connected";
      v61 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v59 = __nwlog_obj();
      v60 = type;
      if (!os_log_type_enabled(v59, type))
        goto LABEL_142;
      *(_DWORD *)buf = 136446210;
      v92 = "nw_protocol_webtransport_http2_stream_connected";
      v61 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_141:
    _os_log_impl(&dword_182FBE000, v59, v60, v61, buf, 0xCu);
    goto LABEL_142;
  }
  handle = (unsigned __int8 *)a1->handle;
  if (handle)
  {
    v4 = (handle[276] >> 4) & 1;
    if (!gLogDatapath)
      LOBYTE(v4) = 1;
    if (!*((_QWORD *)handle + 11))
    {
      if ((v4 & 1) != 0)
        return;
      v11 = __nwlog_obj();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        return;
      v12 = *((_QWORD *)handle + 11);
      if (v12)
        v13 = *(_DWORD *)(v12 + 460);
      else
        v13 = -1;
      v85 = *((_QWORD *)handle + 8);
      *(_DWORD *)buf = 136447234;
      v92 = "nw_protocol_webtransport_http2_stream_connected";
      v93 = 2082;
      p_identifier = (char *)(handle + 192);
      v95 = 2080;
      v96 = " ";
      v97 = 1024;
      v98 = v13;
      v99 = 2048;
      v100 = v85;
      v50 = "%{public}s %{public}s%s<i%u:s%lld> Stream is not fully setup. Ignoring connected.";
      v51 = v11;
      v52 = OS_LOG_TYPE_DEBUG;
      goto LABEL_81;
    }
    if ((v4 & 1) == 0)
    {
      v62 = __nwlog_obj();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
      {
        v63 = *((_QWORD *)handle + 11);
        if (v63)
          v64 = *(_DWORD *)(v63 + 460);
        else
          v64 = -1;
        v81 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        v92 = "nw_protocol_webtransport_http2_stream_connected";
        v93 = 2082;
        p_identifier = (char *)(handle + 192);
        v95 = 2080;
        v96 = " ";
        v97 = 1024;
        v98 = v64;
        v99 = 2048;
        v100 = v81;
        _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> Got a connected event from the lower layer", buf, 0x30u);
      }
    }
    nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a2);
    v6 = (nw_protocol *)*((_QWORD *)handle + 11);
    v7 = handle[276];
    if (v6 != a2)
    {
      if ((handle[276] & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v8 = __nwlog_obj();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            v9 = *((_QWORD *)handle + 11);
            if (v9)
              v10 = *(_DWORD *)(v9 + 460);
            else
              v10 = -1;
            v84 = *((_QWORD *)handle + 8);
            *(_DWORD *)buf = 136447490;
            v92 = "nw_protocol_webtransport_http2_stream_connected";
            v93 = 2082;
            p_identifier = (char *)(handle + 192);
            v95 = 2080;
            v96 = " ";
            v97 = 1024;
            v98 = v10;
            v99 = 2048;
            v100 = v84;
            v101 = 2048;
            *(_QWORD *)v102 = v6;
            _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> connected protocol is not our WebTransport session (%p), ignoring", buf, 0x3Au);
          }
        }
      }
      return;
    }
    if ((handle[276] & 4) == 0)
    {
      v14 = *((_DWORD *)handle + 47);
      if (v14)
        goto LABEL_19;
LABEL_33:
      v14 = 2;
      *((_DWORD *)handle + 47) = 2;
      v15 = *((_DWORD *)handle + 46);
      if (v15)
      {
LABEL_20:
        if (a2)
          goto LABEL_21;
        goto LABEL_35;
      }
LABEL_34:
      v15 = 2;
      *((_DWORD *)handle + 46) = 2;
      if (a2)
      {
LABEL_21:
        default_input_handler = (uint64_t)a2[2].default_input_handler;
        if (default_input_handler == -1)
        {
          if ((v7 & 8) != 0)
          {
            default_input_handler = -2;
            goto LABEL_40;
          }
          if (v14 == 3)
          {
            default_input_handler = -1;
            goto LABEL_40;
          }
          v45 = BYTE4(a2[8].output_handler);
          v46 = v45 & 1;
          if (v15 == 3)
          {
            output_handler = a2[4].output_handler;
            default_input_handler = v46 | (4 * (_QWORD)output_handler) | 2;
            a2[4].output_handler = (nw_protocol *)&output_handler->flow_id[1];
            a2[4].handle = (void *)default_input_handler;
            if ((v45 & 2) != 0)
              goto LABEL_40;
            v17 = __nwlog_obj();
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              goto LABEL_40;
            v48 = *(_DWORD *)&a2[7].flow_id[12];
            *(_DWORD *)buf = 136447234;
            v92 = "nw_webtransport_stream_allocate_new_id";
            v93 = 2082;
            p_identifier = (char *)&a2[7].identifier;
            v95 = 2080;
            v96 = " ";
            v97 = 1024;
            v98 = v48;
            v99 = 2048;
            v100 = default_input_handler;
            v19 = "%{public}s %{public}s%s<i%u> allocated new stream id %llu for unidirectional stream";
          }
          else
          {
            v53 = a2[3].output_handler;
            default_input_handler = (4 * (_DWORD)v53) | v46;
            a2[3].output_handler = (nw_protocol *)&v53->flow_id[1];
            a2[3].handle = (void *)default_input_handler;
            if ((v45 & 2) != 0)
              goto LABEL_40;
            v17 = __nwlog_obj();
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              goto LABEL_40;
            v54 = *(_DWORD *)&a2[7].flow_id[12];
            *(_DWORD *)buf = 136447234;
            v92 = "nw_webtransport_stream_allocate_new_id";
            v93 = 2082;
            p_identifier = (char *)&a2[7].identifier;
            v95 = 2080;
            v96 = " ";
            v97 = 1024;
            v98 = v54;
            v99 = 2048;
            v100 = default_input_handler;
            v19 = "%{public}s %{public}s%s<i%u> allocated new stream id %llu for bidirectional stream";
          }
        }
        else
        {
          if ((BYTE4(a2[8].output_handler) & 2) != 0)
            goto LABEL_40;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            goto LABEL_40;
          v18 = *(_DWORD *)&a2[7].flow_id[12];
          *(_DWORD *)buf = 136447234;
          v92 = "nw_webtransport_stream_allocate_new_id";
          v93 = 2082;
          p_identifier = (char *)&a2[7].identifier;
          v95 = 2080;
          v96 = " ";
          v97 = 1024;
          v98 = v18;
          v99 = 2048;
          v100 = default_input_handler;
          v19 = "%{public}s %{public}s%s<i%u> new incoming stream id %llu";
        }
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, v19, buf, 0x30u);
LABEL_40:
        *((_QWORD *)handle + 8) = default_input_handler;
        goto LABEL_41;
      }
LABEL_35:
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v92 = "nw_webtransport_stream_allocate_new_id";
      type = OS_LOG_TYPE_ERROR;
      v89 = 0;
      v87 = (char *)_os_log_send_and_compose_impl();
      if (!__nwlog_fault(v87, &type, &v89))
        goto LABEL_162;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v20 = __nwlog_obj();
        v21 = type;
        if (!os_log_type_enabled(v20, type))
          goto LABEL_162;
        *(_DWORD *)buf = 136446210;
        v92 = "nw_webtransport_stream_allocate_new_id";
        v22 = "%{public}s called with null webtransport_session";
      }
      else if (v89)
      {
        v76 = (char *)__nw_create_backtrace_string();
        v20 = __nwlog_obj();
        v21 = type;
        v77 = os_log_type_enabled(v20, type);
        if (v76)
        {
          if (v77)
          {
            *(_DWORD *)buf = 136446466;
            v92 = "nw_webtransport_stream_allocate_new_id";
            v93 = 2082;
            p_identifier = v76;
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v76);
          goto LABEL_162;
        }
        if (!v77)
        {
LABEL_162:
          if (v87)
            free(v87);
LABEL_41:
          v23 = *((_QWORD *)handle + 11);
          if (v23)
          {
            if (*((_QWORD *)handle + 8) == -2)
            {
              if (*(_QWORD *)(v23 + 424))
              {
                if ((*(_BYTE *)(v23 + 548) & 2) != 0)
                  goto LABEL_60;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v24 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  goto LABEL_60;
                v25 = *(_DWORD *)(v23 + 460);
                *(_DWORD *)buf = 136446978;
                v92 = "nw_webtransport_session_add_stream";
                v93 = 2082;
                p_identifier = (char *)(v23 + 464);
                v95 = 2080;
                v96 = " ";
                v97 = 1024;
                v98 = v25;
                v26 = "%{public}s %{public}s%s<i%u> WebTransport already has datagram stream registered";
                v27 = v24;
                v28 = OS_LOG_TYPE_ERROR;
                v29 = 38;
LABEL_56:
                _os_log_impl(&dword_182FBE000, v27, v28, v26, buf, v29);
LABEL_60:
                v34 = handle[276];
                if (a1->default_input_handler)
                {
                  if ((handle[276] & 1) == 0)
                  {
                    v35 = *((_QWORD *)handle + 8);
                    if (v35 == -1)
                    {
                      if ((handle[276] & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v42 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                        {
                          v43 = *((_QWORD *)handle + 11);
                          if (v43)
                            v44 = *(_DWORD *)(v43 + 460);
                          else
                            v44 = -1;
                          v57 = *((_QWORD *)handle + 8);
                          *(_DWORD *)buf = 136447234;
                          v92 = "nw_webtransport_stream_configure_metadata_with_stream_id";
                          v93 = 2082;
                          p_identifier = (char *)(handle + 192);
                          v95 = 2080;
                          v96 = " ";
                          v97 = 1024;
                          v98 = v44;
                          v99 = 2048;
                          v100 = v57;
                          _os_log_impl(&dword_182FBE000, v42, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> Not configuring webtransport stream metadata with no stream ID set", buf, 0x30u);
                          if ((handle[276] & 0x10) == 0)
                          {
LABEL_89:
                            if (gLogDatapath)
                            {
                              v73 = __nwlog_obj();
                              if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
                              {
                                v74 = *((_QWORD *)handle + 11);
                                if (v74)
                                  v75 = *(_DWORD *)(v74 + 460);
                                else
                                  v75 = -1;
                                v86 = *((_QWORD *)handle + 8);
                                *(_DWORD *)buf = 136448002;
                                v92 = "nw_protocol_webtransport_http2_stream_connected";
                                v93 = 2082;
                                p_identifier = (char *)(handle + 192);
                                v95 = 2080;
                                v96 = " ";
                                v97 = 1024;
                                v98 = v75;
                                v99 = 2048;
                                v100 = v86;
                                v101 = 2048;
                                *(_QWORD *)v102 = a1;
                                *(_WORD *)&v102[8] = 2048;
                                v103 = v86;
                                v104 = 2048;
                                v105 = a2;
                                _os_log_impl(&dword_182FBE000, v73, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> webtransport http2 stream %p with id %llu connected with output_handler %p", buf, 0x4Eu);
                              }
                            }
                          }
LABEL_90:
                          nw_protocol_connected(a1->default_input_handler->flow_id, (uint64_t)a1);
                          return;
                        }
                      }
                    }
                    else
                    {
                      handle[276] = v34 & 0xF0 | (4 * ((v35 & 2) != 0)) | 3;
                      if ((v34 & 0x10) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v36 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
                        {
                          v37 = *((_QWORD *)handle + 11);
                          if (v37)
                            v38 = *(_DWORD *)(v37 + 460);
                          else
                            v38 = -1;
                          v55 = *((_QWORD *)handle + 8);
                          v56 = handle[276];
                          *(_DWORD *)buf = 136448002;
                          v92 = "nw_webtransport_stream_configure_metadata_with_stream_id";
                          v93 = 2082;
                          p_identifier = (char *)(handle + 192);
                          v95 = 2080;
                          v96 = " ";
                          v97 = 1024;
                          v98 = v38;
                          v99 = 2048;
                          v100 = v55;
                          v101 = 1024;
                          *(_DWORD *)v102 = (v56 >> 1) & 1;
                          *(_WORD *)&v102[4] = 1024;
                          *(_DWORD *)&v102[6] = (v56 >> 3) & 1;
                          LOWORD(v103) = 1024;
                          *(_DWORD *)((char *)&v103 + 2) = (v56 >> 2) & 1;
                          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> Configuring metadata with flags: peer_initiated: %u, datagram: %u, unidirectional: %u", buf, 0x42u);
                        }
                      }
                      nw_webtransport_metadata_set_is_peer_initiated(*((void **)handle + 20), (handle[276] & 2) != 0);
                      nw_webtransport_metadata_set_is_datagram(*((void **)handle + 20), (handle[276] & 8) != 0);
                      nw_webtransport_metadata_set_is_unidirectional(*((void **)handle + 20), (handle[276] & 4) != 0);
                    }
                  }
                  if ((handle[276] & 0x10) == 0)
                    goto LABEL_89;
                  goto LABEL_90;
                }
                if ((handle[276] & 0x10) != 0)
                  return;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v39 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  return;
                v40 = *((_QWORD *)handle + 11);
                if (v40)
                  v41 = *(_DWORD *)(v40 + 460);
                else
                  v41 = -1;
                v49 = *((_QWORD *)handle + 8);
                *(_DWORD *)buf = 136447234;
                v92 = "nw_protocol_webtransport_http2_stream_connected";
                v93 = 2082;
                p_identifier = (char *)(handle + 192);
                v95 = 2080;
                v96 = " ";
                v97 = 1024;
                v98 = v41;
                v99 = 2048;
                v100 = v49;
                v50 = "%{public}s %{public}s%s<i%u:s%lld> No input handler found, ignoring connected call";
                v51 = v39;
                v52 = OS_LOG_TYPE_ERROR;
LABEL_81:
                _os_log_impl(&dword_182FBE000, v51, v52, v50, buf, 0x30u);
                return;
              }
              *(_QWORD *)(v23 + 424) = handle;
            }
            else
            {
              internal = *(_QWORD *)(v23 + 184);
              if (!internal)
              {
                internal = nw_hash_table_create_internal(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_webtransport_stream_get_key, (unsigned int (*)(const void *, unsigned int))nw_webtransport_stream_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_webtransport_stream_matches_key, 0);
                if (internal)
                  *(_DWORD *)(internal + 48) &= ~2u;
                *(_QWORD *)(v23 + 184) = internal;
              }
              type = OS_LOG_TYPE_DEFAULT;
              nw_hash_table_add_object(internal, (uint64_t)handle, (char *)&type);
              if (type == OS_LOG_TYPE_DEFAULT)
              {
                if ((*(_BYTE *)(v23 + 548) & 2) != 0)
                  goto LABEL_60;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v31 = gLogObj;
                if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  goto LABEL_60;
                v32 = *(_DWORD *)(v23 + 460);
                v33 = *((_QWORD *)handle + 8);
                *(_DWORD *)buf = 136447234;
                v92 = "nw_webtransport_session_add_stream";
                v93 = 2082;
                p_identifier = (char *)(v23 + 464);
                v95 = 2080;
                v96 = " ";
                v97 = 1024;
                v98 = v32;
                v99 = 2048;
                v100 = v33;
                v26 = "%{public}s %{public}s%s<i%u> WebTransport already has stream id registered for %llu";
                v27 = v31;
                v28 = OS_LOG_TYPE_ERROR;
LABEL_55:
                v29 = 48;
                goto LABEL_56;
              }
            }
            if ((*(_BYTE *)(v23 + 548) & 2) != 0)
              goto LABEL_60;
            if (!gLogDatapath)
              goto LABEL_60;
            v78 = __nwlog_obj();
            if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
              goto LABEL_60;
            v79 = *(_DWORD *)(v23 + 460);
            v80 = *((_QWORD *)handle + 8);
            *(_DWORD *)buf = 136447234;
            v92 = "nw_webtransport_session_add_stream";
            v93 = 2082;
            p_identifier = (char *)(v23 + 464);
            v95 = 2080;
            v96 = " ";
            v97 = 1024;
            v98 = v79;
            v99 = 2048;
            v100 = v80;
            v26 = "%{public}s %{public}s%s<i%u> Added stream %llu to WebTransport streams";
            v27 = v78;
            v28 = OS_LOG_TYPE_DEBUG;
            goto LABEL_55;
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v92 = "nw_webtransport_session_add_stream";
          v69 = (const char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v89 = 0;
          v88 = (char *)v69;
          if (__nwlog_fault(v69, &type, &v89))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v70 = __nwlog_obj();
              v71 = type;
              if (!os_log_type_enabled(v70, type))
                goto LABEL_167;
              *(_DWORD *)buf = 136446210;
              v92 = "nw_webtransport_session_add_stream";
              v72 = "%{public}s called with null webtransport_session";
              goto LABEL_166;
            }
            if (!v89)
            {
              v70 = __nwlog_obj();
              v71 = type;
              if (!os_log_type_enabled(v70, type))
                goto LABEL_167;
              *(_DWORD *)buf = 136446210;
              v92 = "nw_webtransport_session_add_stream";
              v72 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
              goto LABEL_166;
            }
            v82 = (char *)__nw_create_backtrace_string();
            v70 = __nwlog_obj();
            v71 = type;
            v83 = os_log_type_enabled(v70, type);
            if (v82)
            {
              if (v83)
              {
                *(_DWORD *)buf = 136446466;
                v92 = "nw_webtransport_session_add_stream";
                v93 = 2082;
                p_identifier = v82;
                _os_log_impl(&dword_182FBE000, v70, v71, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v82);
              goto LABEL_167;
            }
            if (v83)
            {
              *(_DWORD *)buf = 136446210;
              v92 = "nw_webtransport_session_add_stream";
              v72 = "%{public}s called with null webtransport_session, no backtrace";
LABEL_166:
              _os_log_impl(&dword_182FBE000, v70, v71, v72, buf, 0xCu);
            }
          }
LABEL_167:
          if (v88)
            free(v88);
          goto LABEL_60;
        }
        *(_DWORD *)buf = 136446210;
        v92 = "nw_webtransport_stream_allocate_new_id";
        v22 = "%{public}s called with null webtransport_session, no backtrace";
      }
      else
      {
        v20 = __nwlog_obj();
        v21 = type;
        if (!os_log_type_enabled(v20, type))
          goto LABEL_162;
        *(_DWORD *)buf = 136446210;
        v92 = "nw_webtransport_stream_allocate_new_id";
        v22 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
      goto LABEL_162;
    }
    if ((handle[276] & 2) != 0)
    {
      *((_DWORD *)handle + 47) = 3;
      v14 = *((_DWORD *)handle + 47);
      if (!v14)
        goto LABEL_33;
    }
    else
    {
      *((_DWORD *)handle + 46) = 3;
      v14 = *((_DWORD *)handle + 47);
      if (!v14)
        goto LABEL_33;
    }
LABEL_19:
    v15 = *((_DWORD *)handle + 46);
    if (v15)
      goto LABEL_20;
    goto LABEL_34;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v92 = "nw_protocol_webtransport_http2_stream_connected";
  v58 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v89 = 0;
  if (!__nwlog_fault(v58, &type, &v89))
    goto LABEL_142;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v59 = __nwlog_obj();
    v60 = type;
    if (!os_log_type_enabled(v59, type))
      goto LABEL_142;
    *(_DWORD *)buf = 136446210;
    v92 = "nw_protocol_webtransport_http2_stream_connected";
    v61 = "%{public}s called with null webtransport_stream";
    goto LABEL_141;
  }
  if (!v89)
  {
    v59 = __nwlog_obj();
    v60 = type;
    if (!os_log_type_enabled(v59, type))
      goto LABEL_142;
    *(_DWORD *)buf = 136446210;
    v92 = "nw_protocol_webtransport_http2_stream_connected";
    v61 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_141;
  }
  v67 = (char *)__nw_create_backtrace_string();
  v59 = __nwlog_obj();
  v60 = type;
  v68 = os_log_type_enabled(v59, type);
  if (!v67)
  {
    if (!v68)
      goto LABEL_142;
    *(_DWORD *)buf = 136446210;
    v92 = "nw_protocol_webtransport_http2_stream_connected";
    v61 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_141;
  }
  if (v68)
  {
    *(_DWORD *)buf = 136446466;
    v92 = "nw_protocol_webtransport_http2_stream_connected";
    v93 = 2082;
    p_identifier = v67;
    _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v67);
  if (v58)
    goto LABEL_143;
}

uint64_t nw_protocol_webtransport_http2_stream_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  _BOOL4 v24;
  uint64_t v25;
  _QWORD v27[2];
  uint64_t (*v28)(_QWORD *);
  void *v29;
  _BYTE *v30;
  _QWORD *v31;
  nw_frame_array_s *v32;
  char v33;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33))
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null protocol";
      goto LABEL_55;
    }
    if (!v33)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v21)
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_55;
    }
    if (!v21)
      goto LABEL_40;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_39:
    _os_log_impl(&dword_182FBE000, v14, v15, v22, buf, 0x16u);
    goto LABEL_40;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33))
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null webtransport_stream";
      goto LABEL_55;
    }
    if (!v33)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v23 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v23)
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_55;
    }
    if (!v23)
      goto LABEL_40;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = backtrace_string;
    v22 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_39;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33))
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null input_protocol";
      goto LABEL_55;
    }
    if (!v33)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
      v16 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v24 = os_log_type_enabled(v14, type);
    if (backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v22 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_39;
      }
LABEL_40:
      free(backtrace_string);
      goto LABEL_56;
    }
    if (!v24)
      goto LABEL_56;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
    v16 = "%{public}s called with null input_protocol, no backtrace";
LABEL_55:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
LABEL_56:
    if (v13)
      free(v13);
    return 0;
  }
  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v17 = __nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v18 = handle[11];
        if (v18)
          v19 = *(_DWORD *)(v18 + 460);
        else
          v19 = -1;
        v25 = handle[8];
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 24;
        *(_WORD *)&buf[22] = 2080;
        v36 = " ";
        v37 = 1024;
        v38 = v19;
        v39 = 2048;
        v40 = v25;
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  if ((nw_protocol *)handle[6] != a2 || *((_DWORD *)handle + 46) != 2)
    return 0;
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  LODWORD(v36) = 0;
  *(_QWORD *)&buf[16] = 0x2000000000;
  v27[0] = MEMORY[0x1E0C809B0];
  v27[1] = 0x40000000;
  v28 = (uint64_t (*)(_QWORD *))___ZL54nw_protocol_webtransport_http2_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
  v29 = &unk_1E14A0528;
  v31 = handle;
  v32 = a6;
  v30 = buf;
  v9 = handle[9];
  do
  {
    if (!v9)
      break;
    v10 = *(_QWORD *)(v9 + 32);
    v11 = v28(v27);
    v9 = v10;
  }
  while ((v11 & 1) != 0);
  v12 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  return v12;
}

BOOL nw_protocol_webtransport_http2_stream_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, uint64_t a5, nw_frame_array_s *a6)
{
  char *handle;
  unint64_t v13;
  char v14;
  unsigned int v15;
  _BOOL8 output_frames;
  NSObject *v17;
  void *v18;
  _BOOL8 result;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  nw_frame *tqh_first;
  nw_frame *v24;
  char v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  char *backtrace_string;
  _BOOL4 v34;
  const char *v35;
  _BOOL4 v36;
  _BOOL4 v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  char v42;
  _QWORD v43[2];
  uint64_t (*v44)(uint64_t, uint64_t);
  void *v45;
  nw_protocol *v46;
  unsigned int v47;
  char v48;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  _WORD v57[15];

  *(_QWORD *)&v57[11] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    v26 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v26, &type, &v48))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null protocol";
      goto LABEL_75;
    }
    if (!v48)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v34 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v34)
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_75;
    }
    if (!v34)
      goto LABEL_60;
    *(_DWORD *)buf = 136446466;
    v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    v52 = 2082;
    v53 = backtrace_string;
    v35 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_59:
    _os_log_impl(&dword_182FBE000, v27, v28, v35, buf, 0x16u);
    goto LABEL_60;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    v26 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v26, &type, &v48))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null webtransport_stream";
      goto LABEL_75;
    }
    if (!v48)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v36 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (!v36)
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_75;
    }
    if (!v36)
      goto LABEL_60;
    *(_DWORD *)buf = 136446466;
    v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    v52 = 2082;
    v53 = backtrace_string;
    v35 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_59;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    v26 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v26, &type, &v48))
      goto LABEL_76;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null return_array";
      goto LABEL_75;
    }
    if (!v48)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_76;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
      v29 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_75;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v37 = os_log_type_enabled(v27, type);
    if (backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
        v52 = 2082;
        v53 = backtrace_string;
        v35 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_59;
      }
LABEL_60:
      free(backtrace_string);
      goto LABEL_76;
    }
    if (!v37)
      goto LABEL_76;
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
    v29 = "%{public}s called with null return_array, no backtrace";
LABEL_75:
    _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
LABEL_76:
    if (v26)
      free(v26);
    return 0;
  }
  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v30 = __nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        v31 = *((_QWORD *)handle + 11);
        if (v31)
          v32 = *(_DWORD *)(v31 + 460);
        else
          v32 = -1;
        v38 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
        v52 = 2082;
        v53 = handle + 192;
        v54 = 2080;
        v55 = " ";
        v56 = 1024;
        *(_DWORD *)v57 = v32;
        v57[2] = 2048;
        *(_QWORD *)&v57[3] = v38;
        _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  if (*((nw_protocol **)handle + 6) != a2 || *((_DWORD *)handle + 47) != 2)
    return 0;
  if ((handle[276] & 8) != 0)
    return nw_http_capsule_framer_get_output_frames(*((_QWORD *)handle + 11) + 96, *((_QWORD *)handle + 11), 0, a3, 0xF4240u, a5, (uint64_t *)a6);
  v13 = *((_QWORD *)handle + 8);
  if (v13 < 0x40)
  {
    v14 = 0;
    v15 = 1;
    goto LABEL_20;
  }
  if (v13 < 0x4000)
  {
    v14 = 0;
    v15 = 2;
    goto LABEL_20;
  }
  if (!(v13 >> 30))
  {
    v14 = 0;
    v15 = 4;
    goto LABEL_20;
  }
  if (!(v13 >> 62))
  {
    v14 = 0;
    v15 = 8;
    goto LABEL_20;
  }
  v17 = __nwlog_obj();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v51 = "_http_vle_length";
  v52 = 2048;
  v53 = (const char *)v13;
  v18 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v18);
  if (!result)
  {
    free(v18);
    v15 = 0;
    v14 = 1;
LABEL_20:
    v20 = __CFADD__(a3, v15);
    v21 = a3 + v15;
    if (v20)
    {
      if (gLogDatapath)
      {
        v42 = v14;
        v39 = __nwlog_obj();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
          v52 = 2082;
          v53 = "minimum_bytes";
          v54 = 2048;
          v55 = (const char *)v15;
          v56 = 2048;
          *(_QWORD *)v57 = v21;
          _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
        }
        LODWORD(v21) = -1;
        v14 = v42;
        v22 = a4 + v15;
        if (!__CFADD__(a4, v15))
          goto LABEL_27;
        goto LABEL_26;
      }
      LODWORD(v21) = -1;
    }
    v22 = a4 + v15;
    if (!__CFADD__(a4, v15))
    {
LABEL_27:
      output_frames = nw_http_capsule_framer_get_output_frames(*((_QWORD *)handle + 11) + 96, *((_QWORD *)handle + 11), 0x190B4D3BuLL, v21, 0xF4240u, a5, (uint64_t *)a6);
      if ((v14 & 1) == 0)
      {
        v43[0] = MEMORY[0x1E0C809B0];
        v43[1] = 0x40000000;
        v44 = ___ZL55nw_protocol_webtransport_http2_stream_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
        v45 = &__block_descriptor_tmp_33_34130;
        v46 = a1;
        v47 = v15;
        tqh_first = a6->tqh_first;
        do
        {
          if (!tqh_first)
            break;
          v24 = (nw_frame *)*((_QWORD *)tqh_first + 4);
          v25 = ((uint64_t (*)(_QWORD *))v44)(v43);
          tqh_first = v24;
        }
        while ((v25 & 1) != 0);
      }
      return output_frames;
    }
LABEL_26:
    if (gLogDatapath)
    {
      v40 = v22;
      v41 = __nwlog_obj();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v51 = "nw_protocol_webtransport_http2_stream_get_output_frames";
        v52 = 2082;
        v53 = "maximum_bytes";
        v54 = 2048;
        v55 = (const char *)v15;
        v56 = 2048;
        *(_QWORD *)v57 = v40;
        _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
      }
    }
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_webtransport_http2_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _QWORD *handle;
  unint64_t v5;
  char v6;
  uint64_t v7;
  void *v8;
  uint64_t result;
  nw_frame *tqh_first;
  nw_frame *v11;
  char v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  uint64_t v24;
  _QWORD v25[2];
  uint64_t (*v26)(uint64_t, uint64_t);
  void *v27;
  nw_protocol *v28;
  unint64_t v29;
  _QWORD *v30;
  char v31;
  char v32;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v13, &type, &v32))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v16 = "%{public}s called with null protocol";
LABEL_53:
        _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
      }
LABEL_54:
      if (v13)
        free(v13);
      return 0;
    }
    if (!v32)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
      v36 = 2082;
      v37 = backtrace_string;
      v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_41:
      _os_log_impl(&dword_182FBE000, v14, v15, v22, buf, 0x16u);
    }
LABEL_42:
    free(backtrace_string);
    goto LABEL_54;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v13, &type, &v32))
      goto LABEL_54;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v16 = "%{public}s called with null webtransport_stream";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (!v32)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v16 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v23 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v16 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
      v36 = 2082;
      v37 = backtrace_string;
      v22 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_41;
    }
    goto LABEL_42;
  }
  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v17 = __nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v18 = handle[11];
        if (v18)
          v19 = *(_DWORD *)(v18 + 460);
        else
          v19 = -1;
        v24 = handle[8];
        *(_DWORD *)buf = 136447234;
        v35 = "nw_protocol_webtransport_http2_stream_finalize_output_frames";
        v36 = 2082;
        v37 = (char *)(handle + 24);
        v38 = 2080;
        v39 = " ";
        v40 = 1024;
        v41 = v19;
        v42 = 2048;
        v43 = v24;
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  if ((*((_BYTE *)handle + 276) & 8) != 0)
  {
    v7 = 0;
  }
  else
  {
    v5 = handle[8];
    if (v5 >= 0x40)
    {
      if (v5 >> 14)
      {
        if (v5 >> 30)
        {
          if (v5 >> 62)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446466;
            v35 = "_http_vle_encode";
            v36 = 2048;
            v37 = (char *)v5;
            v8 = (void *)_os_log_send_and_compose_impl();
            result = __nwlog_abort((uint64_t)v8);
            if ((_DWORD)result)
            {
              __break(1u);
              return result;
            }
            free(v8);
            v5 = 0;
            v6 = 0;
          }
          else
          {
            v5 = bswap64(v5 | 0xC000000000000000);
            v6 = 8;
          }
        }
        else
        {
          v5 = bswap32(v5 | 0x80000000);
          v6 = 4;
        }
      }
      else
      {
        v5 = bswap32(v5 | 0x4000) >> 16;
        v6 = 2;
      }
    }
    else
    {
      v6 = 1;
    }
    v25[0] = MEMORY[0x1E0C809B0];
    v25[1] = 0x40000000;
    v26 = ___ZL60nw_protocol_webtransport_http2_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
    v27 = &__block_descriptor_tmp_34_34108;
    v31 = v6;
    v28 = a1;
    v29 = v5;
    v30 = handle;
    tqh_first = a2->tqh_first;
    v7 = 420171067;
    do
    {
      if (!tqh_first)
        break;
      v11 = (nw_frame *)*((_QWORD *)tqh_first + 4);
      v12 = ((uint64_t (*)(_QWORD *))v26)(v25);
      tqh_first = v11;
    }
    while ((v12 & 1) != 0);
  }
  return nw_http_capsule_framer_finalize_output_frames(handle[11] + 96, handle[11], v7, (uint64_t *)a2);
}

void nw_protocol_webtransport_http2_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http2_stream_input_finished";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v4, &type, &v16))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http2_stream_input_finished";
      v7 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v12 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_http2_stream_input_finished";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_41:
        if (!v4)
          return;
LABEL_42:
        free(v4);
        return;
      }
      if (!v12)
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http2_stream_input_finished";
      v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_41;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_http2_stream_input_finished";
      v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_40:
    _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    goto LABEL_41;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v8 = __nwlog_obj();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = handle[11];
          if (v9)
            v10 = *(_DWORD *)(v9 + 460);
          else
            v10 = -1;
          v15 = handle[8];
          *(_DWORD *)buf = 136447234;
          v19 = "nw_protocol_webtransport_http2_stream_input_finished";
          v20 = 2082;
          v21 = (char *)(handle + 24);
          v22 = 2080;
          v23 = " ";
          v24 = 1024;
          v25 = v10;
          v26 = 2048;
          v27 = v15;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
        }
      }
    }
    if (*((_DWORD *)handle + 46) == 2)
      nw_protocol_input_finished((_QWORD *)handle[6], (uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_http2_stream_input_finished";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v4, &type, &v16))
    goto LABEL_41;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http2_stream_input_finished";
    v7 = "%{public}s called with null webtransport_stream";
    goto LABEL_40;
  }
  if (!v16)
  {
    v5 = __nwlog_obj();
    v6 = type;
    if (!os_log_type_enabled(v5, type))
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http2_stream_input_finished";
    v7 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_40;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v5 = __nwlog_obj();
  v6 = type;
  v14 = os_log_type_enabled(v5, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_41;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_http2_stream_input_finished";
    v7 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_40;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_http2_stream_input_finished";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v4)
    goto LABEL_42;
}

void nw_protocol_webtransport_http2_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _BOOL8 v7;
  unsigned __int8 *v8;
  uint64_t v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  _BOOL4 v20;
  const char *v21;
  NSObject *v22;
  void *v23;
  uint64_t v24;
  _BOOL4 v25;
  char v26;
  os_log_type_t type[8];
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t, void *);
  void *v30;
  uint64_t v31;
  _BYTE buf[24];
  uint64_t v33;
  uint64_t v34;
  _BOOL8 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
    v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v10, type, &v26))
      goto LABEL_64;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (!os_log_type_enabled(v11, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
      v13 = "%{public}s called with null protocol";
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type[0];
      v18 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_64:
        if (!v10)
          return;
        goto LABEL_65;
      }
      if (!v18)
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
      v13 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (!os_log_type_enabled(v11, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
      v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_63;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
    v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v10, type, &v26))
      goto LABEL_64;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        v11 = __nwlog_obj();
        v12 = type[0];
        if (!os_log_type_enabled(v11, type[0]))
          goto LABEL_64;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
        v13 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_63;
      }
      v19 = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type[0];
      v20 = os_log_type_enabled(v11, type[0]);
      if (!v19)
      {
        if (!v20)
          goto LABEL_64;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
        v13 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_63;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v19;
        v21 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v11, v12, v21, buf, 0x16u);
      }
LABEL_37:
      free(v19);
      if (!v10)
        return;
LABEL_65:
      free(v10);
      return;
    }
    v11 = __nwlog_obj();
    v12 = type[0];
    if (!os_log_type_enabled(v11, type[0]))
      goto LABEL_64;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
    v13 = "%{public}s called with null webtransport_stream";
LABEL_63:
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_64;
  }
  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v14 = __nwlog_obj();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        v15 = handle[11];
        if (v15)
          v16 = *(_DWORD *)(v15 + 460);
        else
          v16 = -1;
        v24 = handle[8];
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_http2_stream_output_finished";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 24;
        *(_WORD *)&buf[22] = 2080;
        v33 = (uint64_t)" ";
        LOWORD(v34) = 1024;
        *(_DWORD *)((char *)&v34 + 2) = v16;
        HIWORD(v34) = 2048;
        v35 = v24;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  if (*((_DWORD *)handle + 47) != 2 || (*((_BYTE *)handle + 276) & 8) != 0)
    return;
  v3 = handle[11];
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_http2_send_control_capsule";
    v10 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v10, type, &v26))
      goto LABEL_64;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (!os_log_type_enabled(v11, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http2_send_control_capsule";
      v13 = "%{public}s called with null webtransport_session";
      goto LABEL_63;
    }
    if (!v26)
    {
      v11 = __nwlog_obj();
      v12 = type[0];
      if (!os_log_type_enabled(v11, type[0]))
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http2_send_control_capsule";
      v13 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_63;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type[0];
    v25 = os_log_type_enabled(v11, type[0]);
    if (!v19)
    {
      if (!v25)
        goto LABEL_64;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_http2_send_control_capsule";
      v13 = "%{public}s called with null webtransport_session, no backtrace";
      goto LABEL_63;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_http2_send_control_capsule";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v19;
      v21 = "%{public}s called with null webtransport_session, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  v4 = handle[8];
  if (!*(_QWORD *)(v3 + 192))
    *(_QWORD *)(v3 + 192) = nw_array_create();
  v5 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (!v5)
  {
    v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "strict_calloc";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = 1;
    *(_WORD *)&buf[22] = 2048;
    v33 = 24;
    v23 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v23))
    {
      __break(1u);
      return;
    }
    free(v23);
  }
  *v5 = 420171068;
  v5[1] = v4;
  v5[2] = -1;
  nw_array_append(*(_QWORD *)(v3 + 192), v5);
  v6 = *(_QWORD *)(v3 + 192);
  if (v6 && *(_QWORD *)(v6 + 16) != *(_QWORD *)(v6 + 24))
  {
    v7 = nw_array_create();
    v8 = *(unsigned __int8 **)(v3 + 192);
    v9 = MEMORY[0x1E0C809B0];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke;
    v33 = (uint64_t)&__block_descriptor_tmp_37_33615;
    v34 = v3;
    v35 = v7;
    nw_array_apply(v8, (uint64_t)buf);
    *(_QWORD *)type = v9;
    v28 = 0x40000000;
    v29 = ___ZL51nw_webtransport_http2_send_pending_control_capsulesP23nw_webtransport_session_block_invoke_38;
    v30 = &__block_descriptor_tmp_39_33616;
    v31 = v3;
    nw_array_apply((unsigned __int8 *)v7, (uint64_t)type);
    if (v7)
      os_release((void *)v7);
  }
}

uint64_t ___ZL60nw_protocol_webtransport_http2_stream_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  int v6;

  nw_frame_unclaim(a2, a2, *(unsigned __int8 *)(a1 + 56), 0);
  v6 = 0;
  v4 = (void *)nw_frame_unclaimed_bytes(a2, &v6);
  memcpy(v4, (const void *)(a1 + 40), *(unsigned __int8 *)(a1 + 56));
  if (nw_frame_is_metadata_complete(a2))
    *(_DWORD *)(*(_QWORD *)(a1 + 48) + 188) = 3;
  return 1;
}

uint64_t ___ZL55nw_protocol_webtransport_http2_stream_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_frame_claim(a2, a2, *(_DWORD *)(a1 + 40), 0);
  return 1;
}

uint64_t ___ZL54nw_protocol_webtransport_http2_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  uint64_t v16;
  const char *v17;
  char *backtrace_string;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD **)(a2 + 40);
  v3 = (_QWORD *)(a2 + 32);
  if (v4)
  {
    *(_QWORD *)(v4 + 40) = v5;
    v5 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(a1[5] + 80) = v5;
  }
  *v5 = v4;
  *v3 = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v6 = a1[6];
  v7 = *(uint64_t **)(v6 + 8);
  *(_QWORD *)(a2 + 40) = v7;
  *v7 = a2;
  *(_QWORD *)(v6 + 8) = v3;
  if (nw_frame_is_metadata_complete(a2))
  {
    v8 = a1[5];
    if ((*(_BYTE *)(v8 + 276) & 8) == 0)
      *(_DWORD *)(v8 + 184) = 3;
  }
  v9 = *(_QWORD *)(a1[4] + 8);
  v10 = *(unsigned int *)(v9 + 24) + 1;
  v11 = v10 << 31 >> 31;
  *(_DWORD *)(v9 + 24) = v10;
  if (v11 != v10 || v11 < 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24);
    *(_DWORD *)buf = 136446978;
    v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
    v28 = 2082;
    v29 = "count";
    v30 = 2048;
    v31 = 1;
    v32 = 2048;
    v33 = v12;
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v13, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v16 = *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
          v28 = 2082;
          v29 = "count";
          v30 = 2048;
          v31 = 1;
          v32 = 2048;
          v33 = v16;
          v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_22:
          _os_log_impl(&dword_182FBE000, v14, v15, v17, buf, 0x2Au);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        v19 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v19)
          {
            v20 = *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
            v28 = 2082;
            v29 = "count";
            v30 = 2048;
            v31 = 1;
            v32 = 2048;
            v33 = v20;
            v34 = 2082;
            v35 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          goto LABEL_23;
        }
        if (v19)
        {
          v22 = *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
          v28 = 2082;
          v29 = "count";
          v30 = 2048;
          v31 = 1;
          v32 = 2048;
          v33 = v22;
          v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
          goto LABEL_22;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = gLogObj;
        v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v21 = *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          v27 = "nw_protocol_webtransport_http2_stream_get_input_frames_block_invoke";
          v28 = 2082;
          v29 = "count";
          v30 = 2048;
          v31 = 1;
          v32 = 2048;
          v33 = v21;
          v17 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
          goto LABEL_22;
        }
      }
    }
LABEL_23:
    if (v13)
      free(v13);
    *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = -1;
  }
  return 1;
}

BOOL ___ZL33nw_webtransport_session_establishP23nw_webtransport_session_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  void *v3;
  _BOOL4 is_http_connection;
  uint64_t v6;
  char v7;
  void *v8;

  v3 = a3;
  is_http_connection = nw_protocol_metadata_is_http_connection(a3);
  if (is_http_connection)
  {
    if (v3)
      v3 = os_retain(v3);
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(_BYTE *)(v6 + 384);
    if ((v7 & 1) != 0)
    {
      v8 = *(void **)(v6 + 376);
      if (v8)
      {
        os_release(v8);
        v7 = *(_BYTE *)(v6 + 384);
      }
    }
    *(_QWORD *)(v6 + 376) = v3;
    *(_BYTE *)(v6 + 384) = v7 | 1;
  }
  return !is_http_connection;
}

uint64_t ___ZL38nw_protocol_webtransport_stream_createPK22nw_protocol_identifierP23nw_webtransport_sessionP11nw_endpointP13nw_parameters_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void ___ZL41nw_protocol_webtransport_stream_callbacksv_block_invoke()
{
  qword_1EDCF1BB8 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCF1BC0 = nw_protocol_default_input_flush;
  qword_1EDCF1B88 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCF1B90 = nw_protocol_default_waiting_for_output;
  qword_1EDCF1B48 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCF1B50 = nw_protocol_default_unregister_notification;
  qword_1EDCF1B28 = (uint64_t)nw_protocol_webtransport_stream_get_parameters;
  unk_1EDCF1B30 = nw_protocol_default_get_path;
  qword_1EDCF1B38 = (uint64_t)nw_protocol_default_get_local;
  unk_1EDCF1B40 = nw_protocol_webtransport_stream_get_remote_endpoint;
  qword_1EDCF1AE8 = (uint64_t)nw_protocol_webtransport_stream_disconnected;
  unk_1EDCF1AF0 = nw_protocol_webtransport_stream_error;
  qword_1EDCF1AF8 = (uint64_t)nw_protocol_webtransport_stream_input_available;
  unk_1EDCF1B00 = nw_protocol_webtransport_stream_output_available;
  qword_1EDCF1B58 = (uint64_t)nw_protocol_webtransport_stream_notify;
  unk_1EDCF1B60 = nw_protocol_default_updated_path;
  qword_1EDCF1B98 = (uint64_t)nw_protocol_webtransport_stream_copy_info;
  unk_1EDCF1BA0 = nw_protocol_webtransport_stream_add_listen_handler;
  qword_1EDCF1BA8 = (uint64_t)nw_protocol_webtransport_stream_remove_listen_handler;
  unk_1EDCF1BB0 = nw_protocol_webtransport_stream_get_message_properties;
  nw_protocol_webtransport_stream_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_webtransport_stream_add_input_handler;
  unk_1EDCF1AC0 = nw_protocol_webtransport_stream_remove_input_handler;
  qword_1EDCF1AC8 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1EDCF1AD0 = nw_protocol_webtransport_stream_connect;
  qword_1EDCF1AD8 = (uint64_t)nw_protocol_webtransport_stream_disconnect;
  unk_1EDCF1AE0 = nw_protocol_webtransport_stream_connected;
  qword_1EDCF1B08 = (uint64_t)nw_protocol_webtransport_stream_get_input_frames;
  unk_1EDCF1B10 = nw_protocol_webtransport_stream_get_output_frames;
  qword_1EDCF1B18 = (uint64_t)nw_protocol_webtransport_stream_finalize_output_frames;
  unk_1EDCF1B20 = nw_protocol_default_link_state;
  qword_1EDCF1B68 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1EDCF1B70 = nw_protocol_webtransport_stream_input_finished;
  qword_1EDCF1B78 = (uint64_t)nw_protocol_webtransport_stream_output_finished;
  unk_1EDCF1B80 = nw_protocol_default_get_output_local;
}

uint64_t nw_protocol_webtransport_stream_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  void *v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  nw_protocol *default_input_handler;
  uint64_t v11;
  uint64_t v13;
  _BOOL8 node;
  uint64_t v15;
  int v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  int v29;
  uint64_t v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  uint64_t v34;
  const char *v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  uint32_t v39;
  NSObject *v40;
  os_log_type_t v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  _BOOL4 v45;
  uint64_t v46;
  uint64_t v47;
  NSObject *v48;
  os_log_type_t v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  int v54;
  const char *v55;
  NSObject *v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  NSObject *v60;
  uint64_t v61;
  int v62;
  NSObject *v63;
  int v64;
  uint64_t v65;
  void *v66;
  os_unfair_lock_s *v67;
  _BOOL8 some_node;
  uint64_t object;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  const void *v74;
  void *v75;
  void *v76;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  int v82;
  NSObject *v83;
  int v84;
  __n128 v85;
  uint64_t v86;
  NSObject *v87;
  int v88;
  uint64_t v89;
  char *v90;
  uint64_t v91;
  os_unfair_lock_s *v92;
  uint64_t v93;
  NSObject *v94;
  int v95;
  uint64_t v96;
  char *v97;
  uint64_t v98;
  os_log_type_t v99;
  NSObject *v100;
  os_log_type_t v101;
  const char *v102;
  char *v103;
  NSObject *v104;
  os_log_type_t v105;
  _BOOL4 v106;
  uint64_t v107;
  os_log_type_t v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t v111;
  NSObject *v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  NSObject *v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  const void *v122;
  void *v123;
  void *v124;
  void *v125;
  NSObject *v126;
  os_log_type_t v127;
  NSObject *v128;
  os_log_type_t v129;
  const char *v130;
  char *v131;
  NSObject *v132;
  os_log_type_t v133;
  _BOOL4 v134;
  NSObject *v135;
  os_log_type_t v136;
  uint64_t v137;
  const void *v138;
  char *v139;
  NSObject *v140;
  os_log_type_t v141;
  const char *v142;
  NSObject *v143;
  uint64_t v144;
  int v145;
  char *backtrace_string;
  _BOOL4 v147;
  const char *v148;
  _BOOL4 v149;
  _BOOL4 v150;
  char *v151;
  NSObject *v152;
  os_log_type_t v153;
  const char *v154;
  NSObject *v155;
  int v156;
  uint64_t v157;
  char *v158;
  _BOOL4 v159;
  NSObject *v160;
  uint64_t v161;
  int v162;
  NSObject *v163;
  int v164;
  NSObject *v165;
  int v166;
  uint64_t v167;
  int v168;
  NSObject *v169;
  uint64_t v170;
  int v171;
  uint64_t v172;
  uint64_t v173;
  _QWORD v174[5];
  os_log_type_t type[8];
  uint64_t v176;
  uint64_t (*v177)(uint64_t, uint64_t);
  void *v178;
  uint64_t *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t *v182;
  uint64_t v183;
  uint64_t v184;
  char v185;
  os_log_type_t v186;
  _BYTE buf[12];
  __int16 v188;
  const char *v189;
  __int16 v190;
  uint64_t v191;
  __int16 v192;
  _BYTE v193[24];
  __int16 v194;
  nw_protocol *v195;
  __int16 v196;
  nw_protocol *v197;
  uint64_t v198;

  v198 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    v139 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (!__nwlog_fault(v139, type, v174))
      goto LABEL_281;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v140 = __nwlog_obj();
      v141 = type[0];
      if (!os_log_type_enabled(v140, type[0]))
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null protocol";
      goto LABEL_280;
    }
    if (!LOBYTE(v174[0]))
    {
      v140 = __nwlog_obj();
      v141 = type[0];
      if (!os_log_type_enabled(v140, type[0]))
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_280;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v140 = __nwlog_obj();
    v141 = type[0];
    v147 = os_log_type_enabled(v140, type[0]);
    if (!backtrace_string)
    {
      if (!v147)
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_280;
    }
    if (!v147)
      goto LABEL_254;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    v188 = 2082;
    v189 = backtrace_string;
    v148 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_253:
    _os_log_impl(&dword_182FBE000, v140, v141, v148, buf, 0x16u);
    goto LABEL_254;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    v139 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (!__nwlog_fault(v139, type, v174))
      goto LABEL_281;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v140 = __nwlog_obj();
      v141 = type[0];
      if (!os_log_type_enabled(v140, type[0]))
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null webtransport_stream";
      goto LABEL_280;
    }
    if (!LOBYTE(v174[0]))
    {
      v140 = __nwlog_obj();
      v141 = type[0];
      if (!os_log_type_enabled(v140, type[0]))
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_280;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v140 = __nwlog_obj();
    v141 = type[0];
    v149 = os_log_type_enabled(v140, type[0]);
    if (!backtrace_string)
    {
      if (!v149)
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null webtransport_stream, no backtrace";
      goto LABEL_280;
    }
    if (!v149)
      goto LABEL_254;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    v188 = 2082;
    v189 = backtrace_string;
    v148 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
    goto LABEL_253;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    v139 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (!__nwlog_fault(v139, type, v174))
      goto LABEL_281;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v140 = __nwlog_obj();
      v141 = type[0];
      if (!os_log_type_enabled(v140, type[0]))
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null input_protocol";
      goto LABEL_280;
    }
    if (!LOBYTE(v174[0]))
    {
      v140 = __nwlog_obj();
      v141 = type[0];
      if (!os_log_type_enabled(v140, type[0]))
        goto LABEL_281;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v142 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_280;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v140 = __nwlog_obj();
    v141 = type[0];
    v150 = os_log_type_enabled(v140, type[0]);
    if (backtrace_string)
    {
      if (v150)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
        v188 = 2082;
        v189 = backtrace_string;
        v148 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_253;
      }
LABEL_254:
      free(backtrace_string);
      goto LABEL_281;
    }
    if (!v150)
      goto LABEL_281;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
    v142 = "%{public}s called with null input_protocol, no backtrace";
LABEL_280:
    _os_log_impl(&dword_182FBE000, v140, v141, v142, buf, 0xCu);
LABEL_281:
    if (v139)
      free(v139);
    return 0;
  }
  if ((handle[276] & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v143 = __nwlog_obj();
      if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
      {
        v144 = *((_QWORD *)handle + 11);
        if (v144)
          v145 = *(_DWORD *)(v144 + 460);
        else
          v145 = -1;
        v157 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
        v188 = 2082;
        v189 = handle + 192;
        v190 = 2080;
        v191 = (uint64_t)" ";
        v192 = 1024;
        *(_DWORD *)v193 = v145;
        *(_WORD *)&v193[4] = 2048;
        *(_QWORD *)&v193[6] = v157;
        _os_log_impl(&dword_182FBE000, v143, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  v5 = &unk_1ECD84000;
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *((_QWORD *)handle + 11);
      if (v7)
        v8 = *(_DWORD *)(v7 + 460);
      else
        v8 = -1;
      v9 = *((_QWORD *)handle + 8);
      default_input_handler = a1->default_input_handler;
      *(_DWORD *)buf = 136448002;
      *(_QWORD *)&buf[4] = "nw_protocol_webtransport_stream_remove_input_handler";
      v188 = 2082;
      v189 = handle + 192;
      v190 = 2080;
      v191 = (uint64_t)" ";
      v192 = 1024;
      *(_DWORD *)v193 = v8;
      *(_WORD *)&v193[4] = 2048;
      *(_QWORD *)&v193[6] = v9;
      *(_WORD *)&v193[14] = 2048;
      *(_QWORD *)&v193[16] = a1;
      v194 = 2048;
      v195 = default_input_handler;
      v196 = 2048;
      v197 = a2;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%lld> protocol %p, default_input_handler %p, input protocol %p", buf, 0x4Eu);
    }
  }
  v11 = *((_QWORD *)handle + 11);
  if (a2->output_handler == a1)
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  if (a1->default_input_handler != a2)
    return 0;
  if (handle == *(char **)(v11 + 416))
  {
    v13 = *((_QWORD *)handle + 4);
    if (v13)
      nw_protocol_remove_input_handler(v13, (uint64_t)handle);
  }
  v173 = *((_QWORD *)handle + 11);
  if (!v173)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
    v151 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (!__nwlog_fault(v151, type, v174))
      goto LABEL_295;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v152 = __nwlog_obj();
      v153 = type[0];
      if (!os_log_type_enabled(v152, type[0]))
        goto LABEL_295;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v154 = "%{public}s called with null webtransport_session";
    }
    else if (LOBYTE(v174[0]))
    {
      v158 = (char *)__nw_create_backtrace_string();
      v152 = __nwlog_obj();
      v153 = type[0];
      v159 = os_log_type_enabled(v152, type[0]);
      if (v158)
      {
        if (v159)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v188 = 2082;
          v189 = v158;
          _os_log_impl(&dword_182FBE000, v152, v153, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v158);
        goto LABEL_295;
      }
      if (!v159)
      {
LABEL_295:
        if (v151)
          free(v151);
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v154 = "%{public}s called with null webtransport_session, no backtrace";
    }
    else
    {
      v152 = __nwlog_obj();
      v153 = type[0];
      if (!os_log_type_enabled(v152, type[0]))
        goto LABEL_295;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v154 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v152, v153, v154, buf, 0xCu);
    goto LABEL_295;
  }
  if ((handle[276] & 0x20) != 0)
  {
    if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v155 = __nwlog_obj();
        if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG))
        {
          v156 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v156;
          *(_WORD *)&v193[4] = 2048;
          *(_QWORD *)&v193[6] = handle;
          _os_log_impl(&dword_182FBE000, v155, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for stream (%p)", buf, 0x30u);
        }
      }
    }
    if ((handle[276] & 0x20) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
      v188 = 2048;
      v189 = handle;
      v18 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v174[0]) = 0;
      if (__nwlog_fault(v18, type, v174))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v19 = gLogObj;
          v20 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v188 = 2048;
            v189 = handle;
            v21 = "%{public}s stream %p not in pending list, cannot remove";
LABEL_61:
            v40 = v19;
            v41 = v20;
LABEL_62:
            _os_log_impl(&dword_182FBE000, v40, v41, v21, buf, 0x16u);
          }
        }
        else if (LOBYTE(v174[0]))
        {
          v25 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = gLogObj;
          v27 = type[0];
          v28 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v25)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
              v188 = 2048;
              v189 = handle;
              v190 = 2082;
              v191 = (uint64_t)v25;
              _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s stream %p not in pending list, cannot remove, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v25);
            goto LABEL_63;
          }
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v188 = 2048;
            v189 = handle;
            v21 = "%{public}s stream %p not in pending list, cannot remove, no backtrace";
            v40 = v26;
            v41 = v27;
            goto LABEL_62;
          }
        }
        else
        {
          v19 = __nwlog_obj();
          v20 = type[0];
          if (os_log_type_enabled(v19, type[0]))
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v188 = 2048;
            v189 = handle;
            v21 = "%{public}s stream %p not in pending list, cannot remove, backtrace limit exceeded";
            goto LABEL_61;
          }
        }
      }
LABEL_63:
      if (v18)
        free(v18);
      v5 = &unk_1ECD84000;
      goto LABEL_82;
    }
    v22 = *((_QWORD *)handle + 14);
    v23 = (_QWORD *)*((_QWORD *)handle + 15);
    if (v22)
    {
      *(_QWORD *)(v22 + 120) = v23;
      v23 = (_QWORD *)*((_QWORD *)handle + 15);
      v24 = v173;
    }
    else
    {
      v24 = v173;
      *(_QWORD *)(v173 + 336) = v23;
    }
    *v23 = v22;
    *((_QWORD *)handle + 14) = 0;
    *((_QWORD *)handle + 15) = 0;
    v29 = *(_DWORD *)(v24 + 456);
    *(_DWORD *)(v24 + 456) = v29 - 1;
    if (v29)
    {
LABEL_80:
      v50 = handle[276];
      handle[276] = v50 & 0xDF;
      if ((v50 & 0x10) == 0)
      {
        if (gLogDatapath)
        {
          v160 = __nwlog_obj();
          if (os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
          {
            v161 = *((_QWORD *)handle + 11);
            if (v161)
              v162 = *(_DWORD *)(v161 + 460);
            else
              v162 = -1;
            v167 = *((_QWORD *)handle + 8);
            v168 = *(_DWORD *)(v173 + 456);
            *(_DWORD *)buf = 136447746;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v188 = 2082;
            v189 = handle + 192;
            v190 = 2080;
            v191 = (uint64_t)" ";
            v192 = 1024;
            *(_DWORD *)v193 = v162;
            *(_WORD *)&v193[4] = 2048;
            *(_QWORD *)&v193[6] = v167;
            *(_WORD *)&v193[14] = 2048;
            *(_QWORD *)&v193[16] = handle;
            v194 = 1024;
            LODWORD(v195) = v168;
            v17 = "%{public}s %{public}s%s<i%u:s%lld> removed pending stream (%p), now have %u pending streams";
            v37 = v160;
            v38 = OS_LOG_TYPE_DEBUG;
            v39 = 64;
            goto LABEL_58;
          }
        }
      }
      goto LABEL_82;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = *(unsigned int *)(v173 + 456);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
    v188 = 2082;
    v189 = "webtransport_session->pending_stream_count";
    v190 = 2048;
    v191 = 1;
    v192 = 2048;
    *(_QWORD *)v193 = v30;
    v31 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v174[0]) = 0;
    if (__nwlog_fault(v31, type, v174))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v32 = __nwlog_obj();
        v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          v34 = *(unsigned int *)(v173 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v188 = 2082;
          v189 = "webtransport_session->pending_stream_count";
          v190 = 2048;
          v191 = 1;
          v192 = 2048;
          *(_QWORD *)v193 = v34;
          v35 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_75:
          v48 = v32;
          v49 = v33;
LABEL_76:
          _os_log_impl(&dword_182FBE000, v48, v49, v35, buf, 0x2Au);
        }
      }
      else if (LOBYTE(v174[0]))
      {
        v42 = (char *)__nw_create_backtrace_string();
        v43 = __nwlog_obj();
        v44 = type[0];
        v45 = os_log_type_enabled(v43, type[0]);
        if (v42)
        {
          if (v45)
          {
            v46 = *(unsigned int *)(v173 + 456);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
            v188 = 2082;
            v189 = "webtransport_session->pending_stream_count";
            v190 = 2048;
            v191 = 1;
            v192 = 2048;
            *(_QWORD *)v193 = v46;
            *(_WORD *)&v193[8] = 2082;
            *(_QWORD *)&v193[10] = v42;
            _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v42);
          goto LABEL_77;
        }
        if (v45)
        {
          v137 = *(unsigned int *)(v173 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v188 = 2082;
          v189 = "webtransport_session->pending_stream_count";
          v190 = 2048;
          v191 = 1;
          v192 = 2048;
          *(_QWORD *)v193 = v137;
          v35 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          v48 = v43;
          v49 = v44;
          goto LABEL_76;
        }
      }
      else
      {
        v32 = __nwlog_obj();
        v33 = type[0];
        if (os_log_type_enabled(v32, type[0]))
        {
          v47 = *(unsigned int *)(v173 + 456);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_pending_stream";
          v188 = 2082;
          v189 = "webtransport_session->pending_stream_count";
          v190 = 2048;
          v191 = 1;
          v192 = 2048;
          *(_QWORD *)v193 = v47;
          v35 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_75;
        }
      }
    }
LABEL_77:
    if (v31)
      free(v31);
    *(_DWORD *)(v173 + 456) = 0;
    v5 = &unk_1ECD84000;
    goto LABEL_80;
  }
  if (*(char **)(v173 + 416) == handle)
  {
    if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v163 = __nwlog_obj();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
        {
          v164 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v164;
          _os_log_impl(&dword_182FBE000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing placeholder stream for session", buf, 0x26u);
        }
      }
    }
    *(_QWORD *)(v173 + 416) = 0;
  }
  else if (*(char **)(v173 + 424) == handle)
  {
    if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      if (gLogDatapath)
      {
        v165 = __nwlog_obj();
        if (os_log_type_enabled(v165, OS_LOG_TYPE_DEBUG))
        {
          v166 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v166;
          _os_log_impl(&dword_182FBE000, v165, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Removing datagram stream for session", buf, 0x26u);
        }
      }
    }
    *(_QWORD *)(v173 + 424) = 0;
  }
  else
  {
    *(_QWORD *)type = *((_QWORD *)handle + 8);
    node = nw_hash_table_get_node(*(_QWORD *)(v173 + 184), (uint64_t)type, 8);
    if (node)
    {
      if (!nw_hash_table_remove_node(*(_QWORD *)(v173 + 184), node) && (*(_BYTE *)(v173 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v16 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v16;
          *(_WORD *)&v193[4] = 2048;
          *(_QWORD *)&v193[6] = *(_QWORD *)type;
          v17 = "%{public}s %{public}s%s<i%u> Failed to remove stream %lld from hash table";
LABEL_57:
          v37 = v15;
          v38 = OS_LOG_TYPE_ERROR;
          v39 = 48;
LABEL_58:
          _os_log_impl(&dword_182FBE000, v37, v38, v17, buf, v39);
        }
      }
    }
    else if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v36 = *(_DWORD *)(v173 + 460);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v188 = 2082;
        v189 = (const char *)(v173 + 464);
        v190 = 2080;
        v191 = (uint64_t)" ";
        v192 = 1024;
        *(_DWORD *)v193 = v36;
        *(_WORD *)&v193[4] = 2048;
        *(_QWORD *)&v193[6] = *(_QWORD *)type;
        v17 = "%{public}s %{public}s%s<i%u> called remove_input_handler with stream id %lld, but no stream found";
        goto LABEL_57;
      }
    }
  }
LABEL_82:
  *((_QWORD *)handle + 11) = 0;
  v51 = v173;
  if (*(char **)(v173 + 48) != handle)
    goto LABEL_89;
  if (*(_DWORD *)(v173 + 444))
  {
    v52 = *(_QWORD *)(v173 + 424);
    if (v52)
    {
LABEL_85:
      nw_protocol_set_input_handler(v51, v52);
      if ((*(_BYTE *)(v51 + 548) & 2) != 0)
        goto LABEL_89;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v53 = *((_QWORD *)v5 + 463);
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
        goto LABEL_89;
      v54 = *(_DWORD *)(v51 + 460);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v188 = 2082;
      v189 = (const char *)(v51 + 464);
      v190 = 2080;
      v191 = (uint64_t)" ";
      v192 = 1024;
      *(_DWORD *)v193 = v54;
      v55 = "%{public}s %{public}s%s<i%u> not destroying, still have datagram stream";
      goto LABEL_88;
    }
  }
  else
  {
    if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v63 = *((_QWORD *)v5 + 463);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        v64 = *(_DWORD *)(v173 + 460);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
        v188 = 2082;
        v189 = (const char *)(v173 + 464);
        v190 = 2080;
        v191 = (uint64_t)" ";
        v192 = 1024;
        *(_DWORD *)v193 = v64;
        _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> first input handler bailed, closing", buf, 0x26u);
      }
    }
    v51 = v173;
    v65 = *(_QWORD *)(v173 + 432);
    v66 = *(void **)(v173 + 392);
    v174[0] = MEMORY[0x1E0C809B0];
    v174[1] = 0x40000000;
    v174[2] = ___ZL37nw_webtransport_session_remove_streamP23nw_webtransport_sessionP22nw_webtransport_stream_block_invoke;
    v174[3] = &unk_1E14A0498;
    v174[4] = v65;
    nw_queue_context_async(v66, v174);
    v52 = *(_QWORD *)(v173 + 424);
    if (v52)
      goto LABEL_85;
  }
  v67 = *(os_unfair_lock_s **)(v51 + 184);
  if (v67 && v67[10]._os_unfair_lock_opaque)
  {
    some_node = nw_hash_table_get_some_node(v67);
    object = nw_hash_node_get_object(some_node);
    nw_protocol_set_input_handler(v173, object);
    if ((*(_BYTE *)(v173 + 548) & 2) != 0)
      goto LABEL_89;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v53 = *((_QWORD *)v5 + 463);
    if (!os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
      goto LABEL_89;
    v70 = *(_DWORD *)(v173 + 460);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
    v188 = 2082;
    v189 = (const char *)(v173 + 464);
    v190 = 2080;
    v191 = (uint64_t)" ";
    v192 = 1024;
    *(_DWORD *)v193 = v70;
    v55 = "%{public}s %{public}s%s<i%u> not destroying, still have active streams";
    goto LABEL_88;
  }
  v78 = v173;
  if (!*(_DWORD *)(v173 + 456))
  {
    v81 = *(_QWORD *)(v173 + 416);
    if (v81)
    {
      nw_protocol_set_input_handler(v173, v81);
      if ((*(_BYTE *)(v173 + 548) & 2) != 0)
        goto LABEL_89;
      v53 = __nwlog_obj();
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
        goto LABEL_89;
      v82 = *(_DWORD *)(v173 + 460);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
      v188 = 2082;
      v189 = (const char *)(v173 + 464);
      v190 = 2080;
      v191 = (uint64_t)" ";
      v192 = 1024;
      *(_DWORD *)v193 = v82;
      v55 = "%{public}s %{public}s%s<i%u> not destroying, still have placeholder stream";
      goto LABEL_88;
    }
    nw_protocol_set_input_handler(v173, 0);
    if ((*(_BYTE *)(v173 + 548) & 2) == 0)
    {
      v83 = __nwlog_obj();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_INFO))
      {
        v84 = *(_DWORD *)(v173 + 460);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
        v188 = 2082;
        v189 = (const char *)(v173 + 464);
        v190 = 2080;
        v191 = (uint64_t)" ";
        v192 = 1024;
        *(_DWORD *)v193 = v84;
        _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> called, destroying session", buf, 0x26u);
      }
    }
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v173 + 344, buf);
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v173 + 360, buf);
    *(_QWORD *)buf = 0;
    nw::retained_ptr<nw_endpoint *>::operator=(v173 + 376, buf);
    nw_http_capsule_framer_cleanup((_QWORD *)(v173 + 96), v85);
    v86 = *(_QWORD *)(v173 + 400);
    if (v86)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v86 + 8))(v86, v173, 0);
    if ((*(_BYTE *)(v173 + 548) & 4) != 0)
    {
      if ((nw_protocol_remove_listen_handler(*(_QWORD *)(v173 + 408), v173 + 64) & 1) == 0
        && (*(_BYTE *)(v173 + 548) & 2) == 0)
      {
        v87 = __nwlog_obj();
        if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
        {
          v88 = *(_DWORD *)(v173 + 460);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v88;
          _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> failed to remove listen handler", buf, 0x26u);
        }
      }
      *(_QWORD *)(v173 + 408) = 0;
    }
    v89 = *(_QWORD *)(v173 + 32);
    if (v89)
      nw_protocol_remove_input_handler(v89, v173);
    v181 = 0;
    v182 = &v181;
    v183 = 0x2000000000;
    v184 = 0;
    v90 = *(char **)(v173 + 184);
    if (v90)
    {
      *(_QWORD *)type = MEMORY[0x1E0C809B0];
      v176 = 0x40000000;
      v177 = ___ZL31nw_webtransport_session_destroyP23nw_webtransport_session_block_invoke;
      v178 = &unk_1E14A04E0;
      v179 = &v181;
      v180 = v173;
      nw_hash_table_apply(v90, (uint64_t)type);
      v92 = *(os_unfair_lock_s **)(v173 + 184);
      if (v92)
      {
        _nw_hash_table_release(v92, v91);
        *(_QWORD *)(v173 + 184) = 0;
      }
    }
    v93 = *(_QWORD *)(v173 + 328);
    v182[3] = v93;
    if (!v93)
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v173 + 432) + 16))(*(_QWORD *)(v173 + 432), 0);
      v138 = *(const void **)(v173 + 432);
      if (v138)
      {
        _Block_release(v138);
        *(_QWORD *)(v173 + 432) = 0;
      }
      std::destroy_at[abi:nn180100]<nw_webtransport_session,0>(v173);
      free((void *)v173);
      _Block_object_dispose(&v181, 8);
      goto LABEL_89;
    }
    while (1)
    {
      v93 = *(_QWORD *)(v93 + 112);
      if ((*(_BYTE *)(v78 + 548) & 2) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v94 = *((_QWORD *)v5 + 463);
        if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
        {
          v95 = *(_DWORD *)(v78 + 460);
          v96 = v182[3];
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v188 = 2082;
          v189 = (const char *)(v173 + 464);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v95;
          *(_WORD *)&v193[4] = 2048;
          *(_QWORD *)&v193[6] = v96;
          _os_log_impl(&dword_182FBE000, v94, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways", buf, 0x30u);
        }
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
      v97 = (char *)_os_log_send_and_compose_impl();
      v186 = OS_LOG_TYPE_ERROR;
      v185 = 0;
      if (__nwlog_fault(v97, &v186, &v185))
      {
        if (v186 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v98 = gLogObj;
          v99 = v186;
          if (!os_log_type_enabled((os_log_t)gLogObj, v186))
            goto LABEL_170;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v100 = v98;
          v101 = v99;
          v102 = "%{public}s should not have streams left when destroying";
LABEL_169:
          _os_log_impl(&dword_182FBE000, v100, v101, v102, buf, 0xCu);
          goto LABEL_170;
        }
        if (!v185)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v107 = gLogObj;
          v108 = v186;
          if (!os_log_type_enabled((os_log_t)gLogObj, v186))
            goto LABEL_170;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v100 = v107;
          v101 = v108;
          v102 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
          goto LABEL_169;
        }
        v103 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v104 = gLogObj;
        v105 = v186;
        v106 = os_log_type_enabled((os_log_t)gLogObj, v186);
        if (!v103)
        {
          if (!v106)
            goto LABEL_170;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v100 = v104;
          v101 = v105;
          v102 = "%{public}s should not have streams left when destroying, no backtrace";
          goto LABEL_169;
        }
        if (v106)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_destroy";
          v188 = 2082;
          v189 = v103;
          _os_log_impl(&dword_182FBE000, v104, v105, "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v103);
      }
LABEL_170:
      if (v97)
        free(v97);
      v109 = *(_QWORD *)(v93 + 112);
      v110 = *(_QWORD **)(v93 + 120);
      if (v109)
      {
        *(_QWORD *)(v109 + 120) = v110;
        v110 = *(_QWORD **)(v93 + 120);
      }
      else
      {
        *(_QWORD *)(v173 + 336) = v110;
      }
      *v110 = v109;
      *(_QWORD *)(v93 + 112) = 0;
      *(_QWORD *)(v93 + 120) = 0;
      v111 = v182[3];
      v5 = &unk_1ECD84000;
      if (v111)
      {
        if ((*(_BYTE *)(v111 + 276) & 0x10) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v112 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            v113 = *(_QWORD *)(v111 + 88);
            if (v113)
              v114 = *(_DWORD *)(v113 + 460);
            else
              v114 = -1;
            v115 = *(_QWORD *)(v111 + 64);
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
            v188 = 2082;
            v189 = (const char *)(v111 + 192);
            v190 = 2080;
            v191 = (uint64_t)" ";
            v192 = 1024;
            *(_DWORD *)v193 = v114;
            *(_WORD *)&v193[4] = 2048;
            *(_QWORD *)&v193[6] = v115;
            *(_WORD *)&v193[14] = 2048;
            *(_QWORD *)&v193[16] = v111;
            _os_log_impl(&dword_182FBE000, v112, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
          }
        }
        if (*(_QWORD *)(v111 + 72))
        {
          if ((*(_BYTE *)(v111 + 276) & 0x10) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v116 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              v117 = *(_QWORD *)(v111 + 88);
              if (v117)
                v118 = *(_DWORD *)(v117 + 460);
              else
                v118 = -1;
              v119 = *(_QWORD *)(v111 + 64);
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
              v188 = 2082;
              v189 = (const char *)(v111 + 192);
              v190 = 2080;
              v191 = (uint64_t)" ";
              v192 = 1024;
              *(_DWORD *)v193 = v118;
              *(_WORD *)&v193[4] = 2048;
              *(_QWORD *)&v193[6] = v119;
              _os_log_impl(&dword_182FBE000, v116, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
            }
          }
        }
        v120 = *(_QWORD *)(v111 + 72);
        if (v120)
        {
          do
          {
            v121 = *(_QWORD *)(v120 + 32);
            nw_frame_finalize(v120);
            v120 = v121;
          }
          while (v121);
        }
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v111 + 176) + 16))(*(_QWORD *)(v111 + 176), 0);
        v122 = *(const void **)(v111 + 176);
        if (v122)
        {
          _Block_release(v122);
          *(_QWORD *)(v111 + 176) = 0;
        }
        if ((*(_BYTE *)(v111 + 168) & 1) != 0)
        {
          v123 = *(void **)(v111 + 160);
          if (v123)
            os_release(v123);
        }
        *(_QWORD *)(v111 + 160) = 0;
        if ((*(_BYTE *)(v111 + 152) & 1) != 0)
        {
          v124 = *(void **)(v111 + 144);
          if (v124)
            os_release(v124);
        }
        *(_QWORD *)(v111 + 144) = 0;
        if ((*(_BYTE *)(v111 + 136) & 1) != 0)
        {
          v125 = *(void **)(v111 + 128);
          if (v125)
            os_release(v125);
        }
LABEL_202:
        free((void *)v111);
        goto LABEL_203;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
      v111 = _os_log_send_and_compose_impl();
      v186 = OS_LOG_TYPE_ERROR;
      v185 = 0;
      if (!__nwlog_fault((const char *)v111, &v186, &v185))
        goto LABEL_219;
      if (v186 == OS_LOG_TYPE_FAULT)
      {
        v126 = __nwlog_obj();
        v127 = v186;
        if (os_log_type_enabled(v126, v186))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
          v128 = v126;
          v129 = v127;
          v130 = "%{public}s called with null webtransport_stream";
          goto LABEL_218;
        }
LABEL_219:
        if (v111)
          goto LABEL_202;
        goto LABEL_203;
      }
      if (!v185)
      {
        v135 = __nwlog_obj();
        v136 = v186;
        if (!os_log_type_enabled(v135, v186))
          goto LABEL_219;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v128 = v135;
        v129 = v136;
        v130 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
LABEL_218:
        _os_log_impl(&dword_182FBE000, v128, v129, v130, buf, 0xCu);
        goto LABEL_219;
      }
      v131 = (char *)__nw_create_backtrace_string();
      v132 = __nwlog_obj();
      v133 = v186;
      v134 = os_log_type_enabled(v132, v186);
      if (!v131)
      {
        v5 = &unk_1ECD84000;
        if (!v134)
          goto LABEL_219;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v128 = v132;
        v129 = v133;
        v130 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_218;
      }
      if (v134)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v188 = 2082;
        v189 = v131;
        _os_log_impl(&dword_182FBE000, v132, v133, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v131);
      v5 = &unk_1ECD84000;
      if (v111)
        goto LABEL_202;
LABEL_203:
      v182[3] = v93;
      v78 = v173;
    }
  }
  v79 = *(_QWORD *)(v173 + 328);
  if (v79)
  {
    if ((*(_BYTE *)(v79 + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v169 = __nwlog_obj();
        if (os_log_type_enabled(v169, OS_LOG_TYPE_DEBUG))
        {
          v170 = *(_QWORD *)(v79 + 88);
          if (v170)
            v171 = *(_DWORD *)(v170 + 460);
          else
            v171 = -1;
          v172 = *(_QWORD *)(v79 + 64);
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_webtransport_session_get_next_pending_stream";
          v188 = 2082;
          v189 = (const char *)(v79 + 192);
          v190 = 2080;
          v191 = (uint64_t)" ";
          v192 = 1024;
          *(_DWORD *)v193 = v171;
          *(_WORD *)&v193[4] = 2048;
          *(_QWORD *)&v193[6] = v172;
          *(_WORD *)&v193[14] = 2048;
          *(_QWORD *)&v193[16] = v79;
          _os_log_impl(&dword_182FBE000, v169, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> found stream (%p)", buf, 0x3Au);
        }
      }
    }
  }
  nw_protocol_set_input_handler(v173, v79);
  if ((*(_BYTE *)(v173 + 548) & 2) != 0)
    goto LABEL_89;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v53 = *((_QWORD *)v5 + 463);
  if (!os_log_type_enabled(v53, OS_LOG_TYPE_INFO))
    goto LABEL_89;
  v80 = *(_DWORD *)(v173 + 460);
  *(_DWORD *)buf = 136446978;
  *(_QWORD *)&buf[4] = "nw_webtransport_session_remove_stream";
  v188 = 2082;
  v189 = (const char *)(v173 + 464);
  v190 = 2080;
  v191 = (uint64_t)" ";
  v192 = 1024;
  *(_DWORD *)v193 = v80;
  v55 = "%{public}s %{public}s%s<i%u> not destroying, still have pending streams";
LABEL_88:
  _os_log_impl(&dword_182FBE000, v53, OS_LOG_TYPE_INFO, v55, buf, 0x26u);
LABEL_89:
  nw_protocol_set_output_handler((uint64_t)a1, 0);
  if ((handle[276] & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v56 = *((_QWORD *)v5 + 463);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
    {
      v57 = *((_QWORD *)handle + 11);
      if (v57)
        v58 = *(_DWORD *)(v57 + 460);
      else
        v58 = -1;
      v59 = *((_QWORD *)handle + 8);
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
      v188 = 2082;
      v189 = handle + 192;
      v190 = 2080;
      v191 = (uint64_t)" ";
      v192 = 1024;
      *(_DWORD *)v193 = v58;
      *(_WORD *)&v193[4] = 2048;
      *(_QWORD *)&v193[6] = v59;
      *(_WORD *)&v193[14] = 2048;
      *(_QWORD *)&v193[16] = handle;
      _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%lld> destroying stream %p", buf, 0x3Au);
    }
  }
  if (*((_QWORD *)handle + 9))
  {
    if ((handle[276] & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v60 = *((_QWORD *)v5 + 463);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        v61 = *((_QWORD *)handle + 11);
        if (v61)
          v62 = *(_DWORD *)(v61 + 460);
        else
          v62 = -1;
        v71 = *((_QWORD *)handle + 8);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_webtransport_stream_destroy";
        v188 = 2082;
        v189 = handle + 192;
        v190 = 2080;
        v191 = (uint64_t)" ";
        v192 = 1024;
        *(_DWORD *)v193 = v62;
        *(_WORD *)&v193[4] = 2048;
        *(_QWORD *)&v193[6] = v71;
        _os_log_impl(&dword_182FBE000, v60, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> input_frames has unread frames before destroying", buf, 0x30u);
      }
    }
  }
  v72 = *((_QWORD *)handle + 9);
  if (v72)
  {
    do
    {
      v73 = *(_QWORD *)(v72 + 32);
      nw_frame_finalize(v72);
      v72 = v73;
    }
    while (v73);
  }
  (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)handle + 22) + 16))(*((_QWORD *)handle + 22), 0);
  v74 = (const void *)*((_QWORD *)handle + 22);
  if (v74)
  {
    _Block_release(v74);
    *((_QWORD *)handle + 22) = 0;
  }
  if ((handle[168] & 1) != 0)
  {
    v75 = (void *)*((_QWORD *)handle + 20);
    if (v75)
      os_release(v75);
  }
  *((_QWORD *)handle + 20) = 0;
  if ((handle[152] & 1) != 0)
  {
    v76 = (void *)*((_QWORD *)handle + 18);
    if (v76)
      os_release(v76);
  }
  *((_QWORD *)handle + 18) = 0;
  if ((handle[136] & 1) != 0)
  {
    v77 = (void *)*((_QWORD *)handle + 16);
    if (v77)
      os_release(v77);
  }
  free(handle);
  return 1;
}

uint64_t nw_protocol_webtransport_stream_connect(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v4;
  uint64_t v5;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  char *backtrace_string;
  _BOOL4 v15;
  const char *v16;
  _BOOL4 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  uint64_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_stream_connect";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21))
      goto LABEL_67;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_webtransport_stream_connect";
          v10 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_66;
        }
        goto LABEL_67;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v15 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_webtransport_stream_connect";
          v10 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_66;
        }
        goto LABEL_67;
      }
      if (!v15)
        goto LABEL_47;
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_webtransport_stream_connect";
      v25 = 2082;
      v26 = backtrace_string;
      v16 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_67;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_stream_connect";
    v10 = "%{public}s called with null protocol";
LABEL_66:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_67;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_stream_connect";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21))
      goto LABEL_67;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        v8 = __nwlog_obj();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_webtransport_stream_connect";
          v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
          goto LABEL_66;
        }
        goto LABEL_67;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v17 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_protocol_webtransport_stream_connect";
          v10 = "%{public}s called with null webtransport_stream, no backtrace";
          goto LABEL_66;
        }
        goto LABEL_67;
      }
      if (!v17)
        goto LABEL_47;
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_webtransport_stream_connect";
      v25 = 2082;
      v26 = backtrace_string;
      v16 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_67;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_stream_connect";
    v10 = "%{public}s called with null webtransport_stream";
    goto LABEL_66;
  }
  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    if (gLogDatapath)
    {
      v11 = __nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v12 = handle[11];
        if (v12)
          v13 = *(_DWORD *)(v12 + 460);
        else
          v13 = -1;
        v20 = handle[8];
        *(_DWORD *)buf = 136447234;
        v24 = "nw_protocol_webtransport_stream_connect";
        v25 = 2082;
        v26 = (char *)(handle + 24);
        v27 = 2080;
        v28 = " ";
        v29 = 1024;
        v30 = v13;
        v31 = 2048;
        v32 = v20;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called", buf, 0x30u);
      }
    }
  }
  v4 = handle[4];
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_stream_connect";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21))
      goto LABEL_67;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_webtransport_stream_connect";
      v10 = "%{public}s called with null output_protocol";
      goto LABEL_66;
    }
    if (!v21)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_webtransport_stream_connect";
        v10 = "%{public}s called with null output_protocol, backtrace limit exceeded";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v18 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_webtransport_stream_connect";
        v10 = "%{public}s called with null output_protocol, no backtrace";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    if (!v18)
      goto LABEL_47;
    *(_DWORD *)buf = 136446466;
    v24 = "nw_protocol_webtransport_stream_connect";
    v25 = 2082;
    v26 = backtrace_string;
    v16 = "%{public}s called with null output_protocol, dumping backtrace:%{public}s";
LABEL_46:
    _os_log_impl(&dword_182FBE000, v8, v9, v16, buf, 0x16u);
    goto LABEL_47;
  }
  v5 = handle[11];
  if (v5)
  {
    if (!*(_QWORD *)(v5 + 32))
      nw_protocol_replace_input_handler(handle[4], (uint64_t)a1, handle[11]);
    nw_protocol_set_output_handler(v5, v4);
    return nw_protocol_connect(v5, (uint64_t)a1);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_protocol_webtransport_stream_connect";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v7, &type, &v21))
    goto LABEL_67;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v21)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_webtransport_stream_connect";
        v10 = "%{public}s called with null session_protocol, backtrace limit exceeded";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v19 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_webtransport_stream_connect";
        v10 = "%{public}s called with null session_protocol, no backtrace";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_protocol_webtransport_stream_connect";
      v25 = 2082;
      v26 = backtrace_string;
      v16 = "%{public}s called with null session_protocol, dumping backtrace:%{public}s";
      goto LABEL_46;
    }
LABEL_47:
    free(backtrace_string);
    goto LABEL_67;
  }
  v8 = __nwlog_obj();
  v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_webtransport_stream_connect";
    v10 = "%{public}s called with null session_protocol";
    goto LABEL_66;
  }
LABEL_67:
  if (v7)
    free(v7);
  return 0;
}

void nw_protocol_webtransport_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  int v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_webtransport_stream_connected";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_webtransport_stream_connected";
      v10 = "%{public}s called with null protocol";
      goto LABEL_44;
    }
    if (!v20)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_webtransport_stream_connected";
      v10 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (!v12)
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_webtransport_stream_connected";
      v10 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_44;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_webtransport_stream_connected";
      v24 = 2082;
      v25 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_45:
    if (!v7)
      return;
    goto LABEL_46;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_webtransport_stream_connected";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_45;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_webtransport_stream_connected";
      v10 = "%{public}s called with null webtransport_stream";
      goto LABEL_44;
    }
    if (!v20)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_45;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_webtransport_stream_connected";
      v10 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
      goto LABEL_44;
    }
    v13 = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v14 = os_log_type_enabled(v8, type);
    if (v13)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_protocol_webtransport_stream_connected";
        v24 = 2082;
        v25 = v13;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v13);
      if (!v7)
        return;
LABEL_46:
      free(v7);
      return;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_webtransport_stream_connected";
      v10 = "%{public}s called with null webtransport_stream, no backtrace";
LABEL_44:
      _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
      goto LABEL_45;
    }
    goto LABEL_45;
  }
  v3 = (*((unsigned __int8 *)handle + 276) >> 4) & 1;
  if (!gLogDatapath)
    LOBYTE(v3) = 1;
  if (handle[11])
  {
    if ((v3 & 1) == 0)
    {
      v4 = __nwlog_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        v5 = handle[11];
        if (v5)
          v6 = *(_DWORD *)(v5 + 460);
        else
          v6 = -1;
        v17 = handle[8];
        *(_DWORD *)buf = 136447234;
        v23 = "nw_protocol_webtransport_stream_connected";
        v24 = 2082;
        v25 = (char *)(handle + 24);
        v26 = 2080;
        v27 = " ";
        v28 = 1024;
        v29 = v6;
        v30 = 2048;
        v31 = v17;
        v18 = "%{public}s %{public}s%s<i%u:s%lld> Forwarding connect from lower layer, stream not reconfigured yet";
LABEL_49:
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, v18, buf, 0x30u);
      }
    }
  }
  else if ((v3 & 1) == 0)
  {
    v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v15 = handle[11];
      if (v15)
        v16 = *(_DWORD *)(v15 + 460);
      else
        v16 = -1;
      v19 = handle[8];
      *(_DWORD *)buf = 136447234;
      v23 = "nw_protocol_webtransport_stream_connected";
      v24 = 2082;
      v25 = (char *)(handle + 24);
      v26 = 2080;
      v27 = " ";
      v28 = 1024;
      v29 = v16;
      v30 = 2048;
      v31 = v19;
      v18 = "%{public}s %{public}s%s<i%u:s%lld> Stream is not fully setup, ignoring connected event";
      goto LABEL_49;
    }
  }
}

uint64_t nw_protocol_webtransport_stream_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char *v18;
  _BOOL4 v19;
  const char *v20;
  _BOOL4 v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_input_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v15 = "%{public}s called with null protocol";
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_webtransport_stream_get_input_frames";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_52:
        if (!v12)
          return 0;
LABEL_53:
        free(v12);
        return 0;
      }
      if (!v17)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v15 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_51;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_input_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22))
      goto LABEL_52;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_52;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_stream_get_input_frames";
        v15 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }
      v18 = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v19 = os_log_type_enabled(v13, type);
      if (!v18)
      {
        if (!v19)
          goto LABEL_52;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_stream_get_input_frames";
        v15 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_protocol_webtransport_stream_get_input_frames";
        v26 = 2082;
        v27 = v18;
        v20 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v13, v14, v20, buf, 0x16u);
      }
LABEL_37:
      free(v18);
      if (!v12)
        return 0;
      goto LABEL_53;
    }
    v13 = __nwlog_obj();
    v14 = type;
    if (!os_log_type_enabled(v13, type))
      goto LABEL_52;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_input_frames";
    v15 = "%{public}s called with null webtransport_stream";
LABEL_51:
    _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
    goto LABEL_52;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_input_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v15 = "%{public}s called with null input_protocol";
      goto LABEL_51;
    }
    if (!v22)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v15 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    v18 = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v21 = os_log_type_enabled(v13, type);
    if (!v18)
    {
      if (!v21)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v15 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_51;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v26 = 2082;
      v27 = v18;
      v20 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      v8 = handle[11];
      if (v8)
        v9 = *(_DWORD *)(v8 + 460);
      else
        v9 = -1;
      v10 = handle[8];
      *(_DWORD *)buf = 136447234;
      v25 = "nw_protocol_webtransport_stream_get_input_frames";
      v26 = 2082;
      v27 = (char *)(handle + 24);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v9;
      v32 = 2048;
      v33 = v10;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called, stream transport mode not yet set, returning 0 frames", buf, 0x30u);
    }
  }
  return 0;
}

uint64_t nw_protocol_webtransport_stream_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  char *v18;
  _BOOL4 v19;
  const char *v20;
  _BOOL4 v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v15 = "%{public}s called with null protocol";
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_webtransport_stream_get_output_frames";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_52:
        if (!v12)
          return 0;
LABEL_53:
        free(v12);
        return 0;
      }
      if (!v17)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v15 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_51;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22))
      goto LABEL_52;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v22)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_52;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_stream_get_output_frames";
        v15 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
        goto LABEL_51;
      }
      v18 = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v19 = os_log_type_enabled(v13, type);
      if (!v18)
      {
        if (!v19)
          goto LABEL_52;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_webtransport_stream_get_output_frames";
        v15 = "%{public}s called with null webtransport_stream, no backtrace";
        goto LABEL_51;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_protocol_webtransport_stream_get_output_frames";
        v26 = 2082;
        v27 = v18;
        v20 = "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v13, v14, v20, buf, 0x16u);
      }
LABEL_37:
      free(v18);
      if (!v12)
        return 0;
      goto LABEL_53;
    }
    v13 = __nwlog_obj();
    v14 = type;
    if (!os_log_type_enabled(v13, type))
      goto LABEL_52;
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_output_frames";
    v15 = "%{public}s called with null webtransport_stream";
LABEL_51:
    _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
    goto LABEL_52;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_webtransport_stream_get_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v12, &type, &v22))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v15 = "%{public}s called with null return_array";
      goto LABEL_51;
    }
    if (!v22)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v15 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_51;
    }
    v18 = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v21 = os_log_type_enabled(v13, type);
    if (!v18)
    {
      if (!v21)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v15 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_51;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v26 = 2082;
      v27 = v18;
      v20 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if ((*((_BYTE *)handle + 276) & 0x10) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      v8 = handle[11];
      if (v8)
        v9 = *(_DWORD *)(v8 + 460);
      else
        v9 = -1;
      v10 = handle[8];
      *(_DWORD *)buf = 136447234;
      v25 = "nw_protocol_webtransport_stream_get_output_frames";
      v26 = 2082;
      v27 = (char *)(handle + 24);
      v28 = 2080;
      v29 = " ";
      v30 = 1024;
      v31 = v9;
      v32 = 2048;
      v33 = v10;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called, stream transport mode not yet set, returning 0 frames", buf, 0x30u);
    }
  }
  return 0;
}

uint64_t nw_protocol_webtransport_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _QWORD *handle;
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  char *v14;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
      v11 = "%{public}s called with null protocol";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_38:
        if (!v8)
          return 0;
LABEL_39:
        free(v8);
        return 0;
      }
      if (!v13)
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
      v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_37:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_38;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v4 = handle[11];
        if (v4)
          v5 = *(_DWORD *)(v4 + 460);
        else
          v5 = -1;
        v6 = handle[8];
        *(_DWORD *)buf = 136447234;
        v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
        v20 = 2082;
        v21 = (char *)(handle + 24);
        v22 = 2080;
        v23 = " ";
        v24 = 1024;
        v25 = v5;
        v26 = 2048;
        v27 = v6;
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%lld> finalize_output_frames called on stream with no transport mode", buf, 0x30u);
      }
    }
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v8, &type, &v16))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
    v11 = "%{public}s called with null webtransport_stream";
    goto LABEL_37;
  }
  if (!v16)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
    v11 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v10 = type;
  v15 = os_log_type_enabled(v9, type);
  if (!v14)
  {
    if (!v15)
      goto LABEL_38;
    *(_DWORD *)buf = 136446210;
    v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
    v11 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_37;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_protocol_webtransport_stream_finalize_output_frames";
    v20 = 2082;
    v21 = v14;
    _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v14);
  if (v8)
    goto LABEL_39;
  return 0;
}

void nw_protocol_webtransport_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  uint64_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_input_finished";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v3, &type, &v15))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_webtransport_stream_input_finished";
      v6 = "%{public}s called with null protocol";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v11 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_webtransport_stream_input_finished";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_39:
        if (!v3)
          return;
LABEL_40:
        free(v3);
        return;
      }
      if (!v11)
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_webtransport_stream_input_finished";
      v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_webtransport_stream_input_finished";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_38:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_39;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v7 = __nwlog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          v8 = handle[11];
          if (v8)
            v9 = *(_DWORD *)(v8 + 460);
          else
            v9 = -1;
          v14 = handle[8];
          *(_DWORD *)buf = 136447234;
          v18 = "nw_protocol_webtransport_stream_input_finished";
          v19 = 2082;
          v20 = (char *)(handle + 24);
          v21 = 2080;
          v22 = " ";
          v23 = 1024;
          v24 = v9;
          v25 = 2048;
          v26 = v14;
          _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called on stream without transport mode set, ignoring", buf, 0x30u);
        }
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_webtransport_stream_input_finished";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v3, &type, &v15))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_input_finished";
    v6 = "%{public}s called with null webtransport_stream";
    goto LABEL_38;
  }
  if (!v15)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_input_finished";
    v6 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_38;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v13 = os_log_type_enabled(v4, type);
  if (!v12)
  {
    if (!v13)
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_input_finished";
    v6 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_38;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v18 = "nw_protocol_webtransport_stream_input_finished";
    v19 = 2082;
    v20 = v12;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v3)
    goto LABEL_40;
}

void nw_protocol_webtransport_stream_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  uint64_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_output_finished";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v3, &type, &v15))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_webtransport_stream_output_finished";
      v6 = "%{public}s called with null protocol";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v4 = __nwlog_obj();
      v5 = type;
      v11 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_webtransport_stream_output_finished";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_39:
        if (!v3)
          return;
LABEL_40:
        free(v3);
        return;
      }
      if (!v11)
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_webtransport_stream_output_finished";
      v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (!os_log_type_enabled(v4, type))
        goto LABEL_39;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_protocol_webtransport_stream_output_finished";
      v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_38:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    goto LABEL_39;
  }
  handle = a1->handle;
  if (handle)
  {
    if ((*((_BYTE *)handle + 276) & 0x10) == 0)
    {
      if (gLogDatapath)
      {
        v7 = __nwlog_obj();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          v8 = handle[11];
          if (v8)
            v9 = *(_DWORD *)(v8 + 460);
          else
            v9 = -1;
          v14 = handle[8];
          *(_DWORD *)buf = 136447234;
          v18 = "nw_protocol_webtransport_stream_output_finished";
          v19 = 2082;
          v20 = (char *)(handle + 24);
          v21 = 2080;
          v22 = " ";
          v23 = 1024;
          v24 = v9;
          v25 = 2048;
          v26 = v14;
          _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%lld> called on stream without transport mode set, ignoring", buf, 0x30u);
        }
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_webtransport_stream_output_finished";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v3, &type, &v15))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_output_finished";
    v6 = "%{public}s called with null webtransport_stream";
    goto LABEL_38;
  }
  if (!v15)
  {
    v4 = __nwlog_obj();
    v5 = type;
    if (!os_log_type_enabled(v4, type))
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_output_finished";
    v6 = "%{public}s called with null webtransport_stream, backtrace limit exceeded";
    goto LABEL_38;
  }
  v12 = (char *)__nw_create_backtrace_string();
  v4 = __nwlog_obj();
  v5 = type;
  v13 = os_log_type_enabled(v4, type);
  if (!v12)
  {
    if (!v13)
      goto LABEL_39;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_webtransport_stream_output_finished";
    v6 = "%{public}s called with null webtransport_stream, no backtrace";
    goto LABEL_38;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    v18 = "nw_protocol_webtransport_stream_output_finished";
    v19 = 2082;
    v20 = v12;
    _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null webtransport_stream, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v12);
  if (v3)
    goto LABEL_40;
}

BOOL nw_protocol_webtransport_accept(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 result;
  int v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_accept";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_accept";
      v8 = "%{public}s called with null protocol";
      goto LABEL_37;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_accept";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (!v10)
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_accept";
      v8 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_37;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "nw_protocol_webtransport_accept";
      v17 = 2082;
      v18 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_38:
    if (!v5)
      return 0;
LABEL_39:
    free(v5);
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 40);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_webtransport_accept";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_accept";
      v8 = "%{public}s called with null webtransport_session";
      goto LABEL_37;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_accept";
      v8 = "%{public}s called with null webtransport_session, backtrace limit exceeded";
      goto LABEL_37;
    }
    v11 = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v12 = os_log_type_enabled(v6, type);
    if (v11)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v16 = "nw_protocol_webtransport_accept";
        v17 = 2082;
        v18 = v11;
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null webtransport_session, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v11);
      if (!v5)
        return 0;
      goto LABEL_39;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_webtransport_accept";
      v8 = "%{public}s called with null webtransport_session, no backtrace";
LABEL_37:
      _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      goto LABEL_38;
    }
    goto LABEL_38;
  }
  if (*(_DWORD *)(v1 + 444) != 5)
    return 1;
  if ((*(_BYTE *)(v1 + 548) & 2) != 0)
    return 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
  if (result)
  {
    v4 = *(_DWORD *)(v1 + 460);
    *(_DWORD *)buf = 136446978;
    v16 = "nw_protocol_webtransport_accept";
    v17 = 2082;
    v18 = (char *)(v1 + 464);
    v19 = 2080;
    v20 = " ";
    v21 = 1024;
    v22 = v4;
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> cannot accept new streams after the session was closed", buf, 0x26u);
    return 0;
  }
  return result;
}

uint64_t tcp_listener_create(NSObject *a1)
{
  uint64_t v2;
  uint64_t v3;
  xpc_object_t v4;
  NSObject *v5;
  dispatch_queue_t v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *v11;
  _BOOL4 v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  _BOOL4 v21;
  char v22;
  os_log_type_t type;
  char __str[4];
  const char *v25;
  __int16 v26;
  char *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  nw_allow_use_of_dispatch_internal();
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__str = 136446210;
    v25 = "tcp_listener_create";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v13, &type, &v22))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_38;
      *(_DWORD *)__str = 136446210;
      v25 = "tcp_listener_create";
      v16 = "%{public}s called with null queue";
      goto LABEL_37;
    }
    if (!v22)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_38;
      *(_DWORD *)__str = 136446210;
      v25 = "tcp_listener_create";
      v16 = "%{public}s called with null queue, backtrace limit exceeded";
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v21)
        goto LABEL_38;
      *(_DWORD *)__str = 136446210;
      v25 = "tcp_listener_create";
      v16 = "%{public}s called with null queue, no backtrace";
      goto LABEL_37;
    }
    if (!v21)
      goto LABEL_32;
    *(_DWORD *)__str = 136446466;
    v25 = "tcp_listener_create";
    v26 = 2082;
    v27 = backtrace_string;
    v19 = "%{public}s called with null queue, dumping backtrace:%{public}s";
    goto LABEL_31;
  }
  objc_opt_class();
  v2 = _os_object_alloc();
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__str = 136446210;
    v25 = "tcp_listener_allocate";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_21;
      *(_DWORD *)__str = 136446210;
      v25 = "tcp_listener_allocate";
      v10 = "%{public}s tcp_listener_obj_alloc failed";
    }
    else if (v22)
    {
      v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v11)
      {
        if (v12)
        {
          *(_DWORD *)__str = 136446466;
          v25 = "tcp_listener_allocate";
          v26 = 2082;
          v27 = v11;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s tcp_listener_obj_alloc failed, dumping backtrace:%{public}s", (uint8_t *)__str, 0x16u);
        }
        free(v11);
        goto LABEL_21;
      }
      if (!v12)
      {
LABEL_21:
        if (v7)
          free(v7);
        goto LABEL_23;
      }
      *(_DWORD *)__str = 136446210;
      v25 = "tcp_listener_allocate";
      v10 = "%{public}s tcp_listener_obj_alloc failed, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_21;
      *(_DWORD *)__str = 136446210;
      v25 = "tcp_listener_allocate";
      v10 = "%{public}s tcp_listener_obj_alloc failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v8, v9, v10, (uint8_t *)__str, 0xCu);
    goto LABEL_21;
  }
  v3 = v2;
  *(_DWORD *)(v2 + 72) = 0;
  *(_QWORD *)(v2 + 64) = 0;
  v4 = xpc_dictionary_create(0, 0, 0);
  *(_QWORD *)(v3 + 16) = v4;
  if (v4)
  {
    snprintf(__str, 0x35uLL, "com.apple.networking.tcp_listener.%p", (const void *)v3);
    v28 = 0;
    v5 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v6 = dispatch_queue_create(__str, v5);
    *(_QWORD *)(v3 + 24) = v6;
    if (v6)
    {
      *(_DWORD *)(v3 + 80) = 1;
      *(_QWORD *)(v3 + 32) = a1;
      dispatch_retain(a1);
      return v3;
    }
  }
  os_release((void *)v3);
LABEL_23:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)__str = 136446210;
  v25 = "tcp_listener_create";
  v13 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v13, &type, &v22))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)__str = 136446210;
      v25 = "tcp_listener_create";
      v16 = "%{public}s tcp_listener_allocate failed";
LABEL_37:
      _os_log_impl(&dword_182FBE000, v14, v15, v16, (uint8_t *)__str, 0xCu);
      goto LABEL_38;
    }
    goto LABEL_38;
  }
  if (v22)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)__str = 136446210;
        v25 = "tcp_listener_create";
        v16 = "%{public}s tcp_listener_allocate failed, no backtrace";
        goto LABEL_37;
      }
      goto LABEL_38;
    }
    if (!v18)
    {
LABEL_32:
      free(backtrace_string);
      goto LABEL_38;
    }
    *(_DWORD *)__str = 136446466;
    v25 = "tcp_listener_create";
    v26 = 2082;
    v27 = backtrace_string;
    v19 = "%{public}s tcp_listener_allocate failed, dumping backtrace:%{public}s";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v14, v15, v19, (uint8_t *)__str, 0x16u);
    goto LABEL_32;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = gLogObj;
  v15 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)__str = 136446210;
    v25 = "tcp_listener_create";
    v16 = "%{public}s tcp_listener_allocate failed, backtrace limit exceeded";
    goto LABEL_37;
  }
LABEL_38:
  if (v13)
    free(v13);
  return 0;
}

uint64_t tcp_listener_create_launchd(NSObject *a1, const char *a2)
{
  uint64_t v3;
  uint64_t v4;

  if (!a2)
    return 0;
  v3 = tcp_listener_create(a1);
  v4 = v3;
  if (v3)
    xpc_dictionary_set_string(*(xpc_object_t *)(v3 + 16), "launchd", a2);
  return v4;
}

void tcp_listener_start(uint64_t a1)
{
  os_unfair_lock_s *v2;
  NSObject *v3;
  size_t v4;
  const char *string;
  const char *v6;
  int v7;
  size_t v8;
  int v9;
  BOOL v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  const char *v16;
  const char *v17;
  unsigned int v18;
  NSObject *v19;
  int v20;
  int v21;
  unsigned __int16 uint64;
  uint64_t v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL8 v29;
  NSObject *v30;
  int v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  uint64_t v36;
  NSObject *v37;
  char *v38;
  _BOOL4 v39;
  NSObject *v40;
  int v41;
  const char *v42;
  const char *v43;
  NSObject *v44;
  char *v45;
  const char *v46;
  uint32_t v47;
  const char *v48;
  const char *v49;
  const char *v50;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  char *backtrace_string;
  _BOOL4 v56;
  socklen_t v57;
  size_t cnt;
  char v59;
  socklen_t v60;
  _BYTE buf[24];
  size_t v62;
  _BYTE fds[12];
  __int16 v64;
  int v65;
  __int16 v66;
  char *v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_listener_start";
    v51 = (char *)_os_log_send_and_compose_impl();
    fds[0] = 16;
    LOBYTE(cnt) = 0;
    if (!__nwlog_fault(v51, fds, &cnt))
      goto LABEL_116;
    if (fds[0] == 17)
    {
      v52 = __nwlog_obj();
      v53 = fds[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)fds[0]))
        goto LABEL_116;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_start";
      v54 = "%{public}s called with null listener";
    }
    else if ((_BYTE)cnt)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v52 = __nwlog_obj();
      v53 = fds[0];
      v56 = os_log_type_enabled(v52, (os_log_type_t)fds[0]);
      if (backtrace_string)
      {
        if (v56)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_listener_start";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_116;
      }
      if (!v56)
      {
LABEL_116:
        if (v51)
          free(v51);
        return;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_start";
      v54 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v52 = __nwlog_obj();
      v53 = fds[0];
      if (!os_log_type_enabled(v52, (os_log_type_t)fds[0]))
        goto LABEL_116;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_start";
      v54 = "%{public}s called with null listener, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v52, v53, v54, buf, 0xCu);
    goto LABEL_116;
  }
  v2 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  if (*(_DWORD *)(a1 + 80) != 1)
    goto LABEL_82;
  if (!*(_QWORD *)(a1 + 40))
  {
    v14 = (_QWORD *)a1;
    v15 = 22;
    goto LABEL_81;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    v4 = *(_QWORD *)(a1 + 16);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "tcp_listener_start_locked";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = a1;
    *(_WORD *)&buf[22] = 2114;
    v62 = v4;
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %p: %{public}@", buf, 0x20u);
  }
  string = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "launchd");
  if (!string)
  {
    v16 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "interface");
    if (v16)
    {
      v17 = v16;
      if (!strcasecmp(v16, (const char *)kTCPListenerInterfaceAll))
      {
        v21 = 1;
        goto LABEL_40;
      }
      v18 = if_nametoindex(v17);
      *(_DWORD *)(a1 + 76) = v18;
      if (!v18)
      {
        v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        v37 = __nwlog_obj();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_listener_setup_sockets";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v17;
          _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s could not find interface %{public}s", buf, 0x16u);
        }
        goto LABEL_79;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        v20 = *(_DWORD *)(a1 + 76);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_setup_sockets";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s ifindex %u", buf, 0x12u);
      }
    }
    v21 = 0;
LABEL_40:
    uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 16), "port");
    v23 = uint64;
    v24 = -9;
    v25 = uint64;
    while (1)
    {
      v26 = v24;
      LODWORD(cnt) = 0;
      v27 = tcp_listener_socket_create(a1, 2, v25, *(_DWORD *)(a1 + 76), v21, (unsigned int *)&cnt);
      if (!v27)
        goto LABEL_58;
      v28 = v27;
      memset(buf, 0, sizeof(buf));
      LODWORD(v62) = 0;
      v60 = 28;
      if (getsockname(*(_DWORD *)(v27 + 16), (sockaddr *)buf, &v60))
        break;
      v29 = tcp_listener_socket_create(a1, 30, *(__int16 *)&buf[2], *(_DWORD *)(a1 + 76), v21, (unsigned int *)&cnt);
      if (v29)
      {
        v36 = v29;
        *(_WORD *)(a1 + 84) = *(_WORD *)&buf[2];
        dispatch_resume(*(dispatch_object_t *)(v28 + 8));
        *(_BYTE *)(v28 + 20) = 1;
        *(_QWORD *)v28 = *(_QWORD *)(a1 + 64);
        *(_QWORD *)(a1 + 64) = v28;
        dispatch_resume(*(dispatch_object_t *)(v36 + 8));
        *(_BYTE *)(v36 + 20) = 1;
        *(_QWORD *)v36 = *(_QWORD *)(a1 + 64);
        *(_QWORD *)(a1 + 64) = v36;
LABEL_58:
        v7 = cnt;
LABEL_79:
        if (!v7)
        {
          if (!xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvtype"))
            goto LABEL_38;
          v42 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "interface");
          v43 = v42;
          if (v42)
          {
            if (!strcasecmp(v42, (const char *)kTCPListenerInterfaceAll) || !strcasecmp(v43, "awdl0"))
              LODWORD(v43) = 0x100000;
            else
              LODWORD(v43) = 0;
          }
          if (xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 16), "registerp2p"))
          {
            LODWORD(v43) = v43 | 0x20000;
            if (*(_DWORD *)(a1 + 76))
            {
              v44 = __nwlog_obj();
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                v45 = if_indextoname(*(_DWORD *)(a1 + 76), fds);
                v46 = "?";
                if (v45)
                  v46 = fds;
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "tcp_listener_setup_bonjour";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v46;
                _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s Client specified an interface (%{public}s) and RegisterP2P", buf, 0x16u);
              }
            }
          }
          v47 = *(_DWORD *)(a1 + 76);
          v48 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvname");
          v49 = xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvtype");
          v50 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 16), "localonly")
              ? "local."
              : xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "srvdomain");
          v7 = DNSServiceRegister((DNSServiceRef *)(a1 + 56), (DNSServiceFlags)v43, v47, v48, v49, v50, 0, *(_WORD *)(a1 + 84), 0, 0, (DNSServiceRegisterReply)tcp_listener_dns_handler, (void *)a1);
          if (!v7)
          {
            v7 = DNSServiceSetDispatchQueue(*(DNSServiceRef *)(a1 + 56), *(dispatch_queue_t *)(a1 + 24));
            if (!v7)
              goto LABEL_38;
          }
        }
        goto LABEL_80;
      }
      v30 = *(NSObject **)(v28 + 8);
      if (v30)
      {
        dispatch_source_cancel(v30);
        if (!*(_BYTE *)(v28 + 20))
          dispatch_resume(*(dispatch_object_t *)(v28 + 8));
      }
      else
      {
        v31 = *(_DWORD *)(v28 + 16);
        if (v31 != -1)
          close(v31);
      }
      free((void *)v28);
      if (!v23 && (_DWORD)cnt == 48)
      {
        v24 = v26 + 1;
        if (v26)
          continue;
      }
      goto LABEL_58;
    }
    v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)fds = 136446466;
    *(_QWORD *)&fds[4] = "tcp_listener_setup_sockets";
    v64 = 1024;
    v65 = v7;
    v32 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v57) = 16;
    v59 = 0;
    if (__nwlog_fault(v32, &v57, &v59))
    {
      if (v57 == 17)
      {
        v33 = __nwlog_obj();
        v34 = v57;
        if (os_log_type_enabled(v33, (os_log_type_t)v57))
        {
          *(_DWORD *)fds = 136446466;
          *(_QWORD *)&fds[4] = "tcp_listener_setup_sockets";
          v64 = 1024;
          v65 = v7;
          v35 = "%{public}s getsockname failed %{darwin.errno}d";
LABEL_70:
          _os_log_impl(&dword_182FBE000, v33, v34, v35, fds, 0x12u);
        }
      }
      else if (v59)
      {
        v38 = (char *)__nw_create_backtrace_string();
        v33 = __nwlog_obj();
        v34 = v57;
        v39 = os_log_type_enabled(v33, (os_log_type_t)v57);
        if (v38)
        {
          if (v39)
          {
            *(_DWORD *)fds = 136446722;
            *(_QWORD *)&fds[4] = "tcp_listener_setup_sockets";
            v64 = 1024;
            v65 = v7;
            v66 = 2082;
            v67 = v38;
            _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s getsockname failed %{darwin.errno}d, dumping backtrace:%{public}s", fds, 0x1Cu);
          }
          free(v38);
          goto LABEL_71;
        }
        if (v39)
        {
          *(_DWORD *)fds = 136446466;
          *(_QWORD *)&fds[4] = "tcp_listener_setup_sockets";
          v64 = 1024;
          v65 = v7;
          v35 = "%{public}s getsockname failed %{darwin.errno}d, no backtrace";
          goto LABEL_70;
        }
      }
      else
      {
        v33 = __nwlog_obj();
        v34 = v57;
        if (os_log_type_enabled(v33, (os_log_type_t)v57))
        {
          *(_DWORD *)fds = 136446466;
          *(_QWORD *)&fds[4] = "tcp_listener_setup_sockets";
          v64 = 1024;
          v65 = v7;
          v35 = "%{public}s getsockname failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_70;
        }
      }
    }
LABEL_71:
    if (v32)
      free(v32);
    v40 = *(NSObject **)(v28 + 8);
    if (v40)
    {
      dispatch_source_cancel(v40);
      if (!*(_BYTE *)(v28 + 20))
        dispatch_resume(*(dispatch_object_t *)(v28 + 8));
    }
    else
    {
      v41 = *(_DWORD *)(v28 + 16);
      if (v41 != -1)
        close(v41);
    }
    free((void *)v28);
    goto LABEL_79;
  }
  v6 = string;
  *(_QWORD *)fds = 0;
  cnt = 0;
  v7 = launch_activate_socket(string, (int **)fds, &cnt);
  if (v7 || !*(_QWORD *)fds || !cnt)
    goto LABEL_35;
  v8 = 0;
  v9 = 2;
  do
  {
    v60 = 0;
    v57 = 4;
    if (getsockopt(*(_DWORD *)(*(_QWORD *)fds + 4 * v8), 0xFFFF, 4104, &v60, &v57))
      v10 = 0;
    else
      v10 = v60 == 1;
    if (!v10)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "tcp_listener_setup_sockets_launchd";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v6;
        *(_WORD *)&buf[22] = 2048;
        v62 = v8;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s Sockets:%{public}s[%zu] is not SOCK_STREAM - not supported", buf, 0x20u);
      }
LABEL_11:
      close(*(_DWORD *)(*(_QWORD *)fds + 4 * v8));
      goto LABEL_12;
    }
    if (!*(_WORD *)(a1 + 84))
    {
      memset(buf, 0, sizeof(buf));
      LODWORD(v62) = 0;
      v57 = 28;
      if (!getsockname(*(_DWORD *)(*(_QWORD *)fds + 4 * v8), (sockaddr *)buf, &v57))
      {
        v9 = buf[1];
        if (buf[1] == 2 || buf[1] == 30)
          *(_WORD *)(a1 + 84) = *(_WORD *)&buf[2];
      }
    }
    v12 = tcp_listener_socket_create_with_fd(v9, a1, *(_DWORD *)(*(_QWORD *)fds + 4 * v8));
    if (!v12)
      goto LABEL_11;
    v13 = v12;
    *(_QWORD *)v12 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 64) = v12;
    dispatch_resume(*(dispatch_object_t *)(v12 + 8));
    *(_BYTE *)(v13 + 20) = 1;
LABEL_12:
    ++v8;
  }
  while (v8 < cnt);
  if (*(_QWORD *)fds)
    free(*(void **)fds);
LABEL_35:
  if (!v7)
    v7 = 2;
  if (*(_QWORD *)(a1 + 64))
  {
LABEL_38:
    *(_DWORD *)(a1 + 80) = 2;
    goto LABEL_82;
  }
LABEL_80:
  v14 = (_QWORD *)a1;
  v15 = v7;
LABEL_81:
  tcp_listener_call_error_handler_locked(v14, v15);
LABEL_82:
  os_unfair_lock_unlock(v2);
}

void tcp_listener_call_error_handler_locked(_QWORD *a1, int a2)
{
  const void *v3;
  NSObject *v5;
  _QWORD block[6];
  int v7;
  _QWORD v8[3];
  void *v9;
  _QWORD v10[5];
  void *v11;

  v3 = (const void *)a1[6];
  if (v3)
  {
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x3002000000;
    v10[3] = __Block_byref_object_copy__34667;
    v10[4] = __Block_byref_object_dispose__34668;
    v11 = 0;
    v11 = _Block_copy(v3);
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2000000000;
    v9 = 0;
    v9 = os_retain(a1);
    v5 = a1[4];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __tcp_listener_call_error_handler_locked_block_invoke;
    block[3] = &unk_1E14A0868;
    block[4] = v8;
    block[5] = v10;
    v7 = a2;
    dispatch_async(v5, block);
    _Block_object_dispose(v8, 8);
    _Block_object_dispose(v10, 8);
  }
  tcp_listener_cancel_locked(a1);
}

BOOL tcp_listener_socket_create_with_fd(int a1, uint64_t a2, int a3)
{
  int v6;
  const char *v7;
  uint64_t v8;
  os_log_type_t v9;
  const char *v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  _BOOL4 v20;
  NSObject *v21;
  os_log_type_t v22;
  uint32_t v23;
  int v24;
  _DWORD *v25;
  dispatch_source_t v26;
  NSObject *v27;
  uint64_t v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  NSObject *v33;
  os_log_type_t v34;
  uint32_t v35;
  void *v36;
  _BOOL8 result;
  char *v38;
  _BOOL4 v39;
  const char *v40;
  char *v41;
  _BOOL4 v42;
  _BOOL4 v43;
  NSObject *v44;
  void *v45;
  NSObject *v46;
  os_log_type_t v47;
  _BOOL4 v48;
  _QWORD v49[6];
  int v50;
  _QWORD handler[5];
  int v52;
  char v53;
  os_log_type_t type;
  int v55;
  _BYTE buf[34];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v55 = 1;
  if (ioctl(a3, 0x8004667EuLL, &v55) < 0)
  {
    v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v11;
    v7 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v7, &type, &v53))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        v10 = "%{public}s FIONBIO failed %{darwin.errno}d";
        goto LABEL_50;
      }
LABEL_52:
      if (!v7)
        return 0;
      v36 = (void *)v7;
LABEL_54:
      free(v36);
      return 0;
    }
    if (!v53)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        v10 = "%{public}s FIONBIO failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        v10 = "%{public}s FIONBIO failed %{darwin.errno}d, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_52;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v11;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = backtrace_string;
      v19 = "%{public}s FIONBIO failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_25;
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_52;
  }
  if (setsockopt(a3, 0xFFFF, 4130, &v55, 4u))
  {
    v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v6;
    v7 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v7, &type, &v53))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        v10 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d";
LABEL_50:
        v33 = v8;
        v34 = v9;
        v35 = 18;
LABEL_51:
        _os_log_impl(&dword_182FBE000, v33, v34, v10, buf, v35);
        goto LABEL_52;
      }
      goto LABEL_52;
    }
    if (!v53)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      v9 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        v10 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    v9 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        v10 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_52;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = backtrace_string;
      v19 = "%{public}s SO_NOSIGPIPE failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_25:
      v21 = v8;
      v22 = v9;
      v23 = 28;
LABEL_26:
      _os_log_impl(&dword_182FBE000, v21, v22, v19, buf, v23);
      goto LABEL_27;
    }
    goto LABEL_27;
  }
  if (xpc_dictionary_get_BOOL(*(xpc_object_t *)(a2 + 16), "tfo") && setsockopt(a3, 6, 261, &v55, 4u))
  {
    v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v12;
    v13 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault((const char *)v13, &type, &v53))
      goto LABEL_88;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_88;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      v16 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d";
      goto LABEL_87;
    }
    if (!v53)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_88;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      v16 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_87;
    }
    v38 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v39 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v38)
    {
      if (!v39)
        goto LABEL_88;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      v16 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d, no backtrace";
      goto LABEL_87;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      *(_WORD *)&buf[24] = 2082;
      *(_QWORD *)&buf[26] = v38;
      v40 = "%{public}s setsockopt(%d, TCP_FASTOPEN, 1) failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_72:
      _os_log_impl(&dword_182FBE000, v14, v15, v40, buf, 0x22u);
      goto LABEL_73;
    }
    goto LABEL_73;
  }
  if (a1 == 30
    && xpc_dictionary_get_BOOL(*(xpc_object_t *)(a2 + 16), "coproc")
    && setsockopt(a3, 0xFFFF, 4376, &v55, 4u))
  {
    v24 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v24;
    v13 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault((const char *)v13, &type, &v53))
      goto LABEL_88;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_88;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      v16 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d";
      goto LABEL_87;
    }
    if (!v53)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_88;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      v16 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_87;
    }
    v38 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v43 = os_log_type_enabled(v14, type);
    if (!v38)
    {
      if (!v43)
        goto LABEL_88;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      v16 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, no backtrace";
LABEL_87:
      _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0x18u);
LABEL_88:
      if (!v13)
        return 0;
      goto LABEL_89;
    }
    if (v43)
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a3;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      *(_WORD *)&buf[24] = 2082;
      *(_QWORD *)&buf[26] = v38;
      v40 = "%{public}s setsockopt(%d, SO_INTCOPROC_ALLOW, 1) failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_72;
    }
LABEL_73:
    free(v38);
    goto LABEL_88;
  }
  v25 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (v25)
  {
    v13 = (uint64_t)v25;
    v25[4] = a3;
    v26 = dispatch_source_create(MEMORY[0x1E0C80DB8], a3, 0, *(dispatch_queue_t *)(a2 + 24));
    *(_QWORD *)(v13 + 8) = v26;
    if (v26)
    {
      os_retain((void *)a2);
      v27 = *(NSObject **)(v13 + 8);
      v28 = MEMORY[0x1E0C809B0];
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 0x40000000;
      handler[2] = __tcp_listener_socket_create_with_fd_block_invoke;
      handler[3] = &__block_descriptor_tmp_9_34649;
      handler[4] = a2;
      v52 = a3;
      dispatch_source_set_event_handler(v27, handler);
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2000000000;
      *(_QWORD *)&buf[24] = *(_QWORD *)(v13 + 8);
      v49[0] = v28;
      v49[1] = 0x40000000;
      v49[2] = __tcp_listener_socket_create_with_fd_block_invoke_2;
      v49[3] = &unk_1E14A08B0;
      v50 = a3;
      v49[4] = buf;
      v49[5] = a2;
      dispatch_source_set_cancel_handler(*(dispatch_source_t *)&buf[24], v49);
      _Block_object_dispose(buf, 8);
      return v13;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v29, &type, &v53))
      goto LABEL_81;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = gLogObj;
      v31 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      v32 = "%{public}s dispatch_source_create failed";
    }
    else if (v53)
    {
      v41 = (char *)__nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v42 = os_log_type_enabled(v30, type);
      if (v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v41;
          _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v41);
        goto LABEL_81;
      }
      if (!v42)
      {
LABEL_81:
        if (v29)
          free(v29);
LABEL_89:
        v36 = (void *)v13;
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      v32 = "%{public}s dispatch_source_create failed, no backtrace";
    }
    else
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
        goto LABEL_81;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      v32 = "%{public}s dispatch_source_create failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0xCu);
    goto LABEL_81;
  }
  v44 = __nwlog_obj();
  os_log_type_enabled(v44, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "strict_calloc";
  *(_WORD *)&buf[12] = 2048;
  *(_QWORD *)&buf[14] = 1;
  *(_WORD *)&buf[22] = 2048;
  *(_QWORD *)&buf[24] = 24;
  v45 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v45);
  if (!result)
  {
    free(v45);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
    v7 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v53 = 0;
    if (!__nwlog_fault(v7, &type, &v53))
      goto LABEL_52;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v46 = __nwlog_obj();
      v47 = type;
      if (!os_log_type_enabled(v46, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      v10 = "%{public}s malloc failed";
    }
    else if (v53)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v46 = __nwlog_obj();
      v47 = type;
      v48 = os_log_type_enabled(v46, type);
      if (backtrace_string)
      {
        if (!v48)
          goto LABEL_27;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v19 = "%{public}s malloc failed, dumping backtrace:%{public}s";
        v21 = v46;
        v22 = v47;
        v23 = 22;
        goto LABEL_26;
      }
      if (!v48)
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      v10 = "%{public}s malloc failed, no backtrace";
    }
    else
    {
      v46 = __nwlog_obj();
      v47 = type;
      if (!os_log_type_enabled(v46, type))
        goto LABEL_52;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_socket_create_with_fd";
      v10 = "%{public}s malloc failed, backtrace limit exceeded";
    }
    v33 = v46;
    v34 = v47;
    v35 = 12;
    goto LABEL_51;
  }
  __break(1u);
  return result;
}

BOOL tcp_listener_socket_create(uint64_t a1, int a2, __int16 a3, int a4, int a5, unsigned int *a6)
{
  int v11;
  int v12;
  unsigned int v13;
  char *v14;
  NSObject *v15;
  os_log_type_t sa_len;
  const char *v17;
  unsigned int v18;
  unsigned int v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  NSObject *v24;
  os_log_type_t v25;
  uint32_t v26;
  unsigned int v27;
  unsigned int v28;
  socklen_t v29;
  _BOOL4 v30;
  unsigned int v31;
  _BOOL4 v32;
  unsigned int v33;
  NSObject *v35;
  unsigned int v36;
  _BOOL4 v37;
  NSObject *v38;
  os_log_type_t v39;
  _BOOL8 v40;
  _BOOL4 v41;
  _BOOL4 v42;
  _BOOL4 v43;
  NSObject *v44;
  os_log_type_t v45;
  uint32_t v46;
  char v48;
  sockaddr type;
  os_log_type_t v50;
  int v51;
  int v52;
  uint8_t buf[4];
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  _DWORD v58[7];

  *(_QWORD *)&v58[5] = *MEMORY[0x1E0C80C00];
  v52 = a4;
  v11 = socket(a2, 1, 6);
  v12 = v11;
  if (v11 < 0)
  {
    v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v18;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v18;
    v14 = (char *)_os_log_send_and_compose_impl();
    type.sa_len = 16;
    LOBYTE(v51) = 0;
    if (!__nwlog_fault(v14, &type, &v51))
      goto LABEL_124;
    if (type.sa_len == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v18;
      v17 = "%{public}s socket failed %{darwin.errno}d";
      goto LABEL_122;
    }
    if (!(_BYTE)v51)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v18;
      v17 = "%{public}s socket failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_122;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    sa_len = type.sa_len;
    v23 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len);
    if (!backtrace_string)
    {
      if (!v23)
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v18;
      v17 = "%{public}s socket failed %{darwin.errno}d, no backtrace";
      goto LABEL_122;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446722;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v18;
      v57 = 2082;
      *(_QWORD *)v58 = backtrace_string;
      v22 = "%{public}s socket failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_25;
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_124;
  }
  v51 = 1;
  if (setsockopt(v11, 0xFFFF, 4, &v51, 4u))
  {
    v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v13;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v13;
    v14 = (char *)_os_log_send_and_compose_impl();
    type.sa_len = 16;
    v50 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v14, &type, &v50))
      goto LABEL_124;
    if (type.sa_len == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      v17 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d";
LABEL_122:
      v44 = v15;
      v45 = sa_len;
      v46 = 18;
LABEL_123:
      _os_log_impl(&dword_182FBE000, v44, v45, v17, buf, v46);
      goto LABEL_124;
    }
    if (v50 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      v17 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_122;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    sa_len = type.sa_len;
    v21 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len);
    if (!backtrace_string)
    {
      if (!v21)
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      v17 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d, no backtrace";
      goto LABEL_122;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446722;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v13;
      v57 = 2082;
      *(_QWORD *)v58 = backtrace_string;
      v22 = "%{public}s SO_REUSEADDR failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_25:
      v24 = v15;
      v25 = sa_len;
      v26 = 28;
LABEL_26:
      _os_log_impl(&dword_182FBE000, v24, v25, v22, buf, v26);
      goto LABEL_27;
    }
    goto LABEL_27;
  }
  if (a5 && setsockopt(v12, 0xFFFF, 4356, &v51, 4u))
  {
    v19 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v19;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v19;
    v14 = (char *)_os_log_send_and_compose_impl();
    type.sa_len = 16;
    v50 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v14, &type, &v50))
      goto LABEL_124;
    if (type.sa_len == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      sa_len = type.sa_len;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      v17 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d";
      goto LABEL_122;
    }
    if (v50 == OS_LOG_TYPE_DEFAULT)
    {
      v15 = __nwlog_obj();
      sa_len = type.sa_len;
      if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      v17 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_122;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    sa_len = type.sa_len;
    v30 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len);
    if (!backtrace_string)
    {
      if (!v30)
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      v17 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace";
      goto LABEL_122;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446722;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v19;
      v57 = 2082;
      *(_QWORD *)v58 = backtrace_string;
      v22 = "%{public}s SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_25;
    }
    goto LABEL_27;
  }
  if (a2 == 30)
  {
    if (setsockopt(v12, 41, 27, &v51, 4u))
    {
      v27 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      *a6 = v27;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v27;
      v14 = (char *)_os_log_send_and_compose_impl();
      type.sa_len = 16;
      v50 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v14, &type, &v50))
        goto LABEL_124;
      if (type.sa_len == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = gLogObj;
        sa_len = type.sa_len;
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type.sa_len))
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        v17 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d";
        goto LABEL_122;
      }
      if (v50 == OS_LOG_TYPE_DEFAULT)
      {
        v15 = __nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len))
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        v17 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_122;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      sa_len = type.sa_len;
      v32 = os_log_type_enabled(v15, (os_log_type_t)type.sa_len);
      if (!backtrace_string)
      {
        if (!v32)
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        v17 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d, no backtrace";
        goto LABEL_122;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v27;
        v57 = 2082;
        *(_QWORD *)v58 = backtrace_string;
        v22 = "%{public}s IPV6_V6ONLY failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_25;
      }
      goto LABEL_27;
    }
    if (v52 && setsockopt(v12, 41, 125, &v52, 4u))
    {
      v31 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      *a6 = v31;
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v31;
      v14 = (char *)_os_log_send_and_compose_impl();
      type.sa_len = 16;
      v50 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v14, &type, &v50))
        goto LABEL_124;
      if (type.sa_len == 17)
      {
        v15 = __nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len))
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        v17 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d";
        goto LABEL_122;
      }
      if (v50 == OS_LOG_TYPE_DEFAULT)
      {
        v15 = __nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len))
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        v17 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_122;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      sa_len = type.sa_len;
      v42 = os_log_type_enabled(v15, (os_log_type_t)type.sa_len);
      if (!backtrace_string)
      {
        if (!v42)
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        v17 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d, no backtrace";
        goto LABEL_122;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v31;
        v57 = 2082;
        *(_QWORD *)v58 = backtrace_string;
        v22 = "%{public}s IPV6_BOUND_IF failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_25;
      }
      goto LABEL_27;
    }
    memset(&type.sa_data[2], 0, 24);
  }
  else
  {
    if (v52 && setsockopt(v12, 0, 25, &v52, 4u))
    {
      v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      *a6 = v28;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v28;
      v14 = (char *)_os_log_send_and_compose_impl();
      type.sa_len = 16;
      v50 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v14, &type, &v50))
        goto LABEL_124;
      if (type.sa_len == 17)
      {
        v15 = __nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len))
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        v17 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d";
        goto LABEL_122;
      }
      if (v50 == OS_LOG_TYPE_DEFAULT)
      {
        v15 = __nwlog_obj();
        sa_len = type.sa_len;
        if (!os_log_type_enabled(v15, (os_log_type_t)type.sa_len))
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        v17 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_122;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      sa_len = type.sa_len;
      v37 = os_log_type_enabled(v15, (os_log_type_t)type.sa_len);
      if (!backtrace_string)
      {
        if (!v37)
          goto LABEL_124;
        *(_DWORD *)buf = 136446466;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        v17 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d, no backtrace";
        goto LABEL_122;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v28;
        v57 = 2082;
        *(_QWORD *)v58 = backtrace_string;
        v22 = "%{public}s IP_BOUND_IF failed %{darwin.errno}d, dumping backtrace:%{public}s";
        goto LABEL_25;
      }
      goto LABEL_27;
    }
    memset(&type, 0, 28);
    if (a2 == 2)
    {
      *(_WORD *)&type.sa_len = 528;
      v29 = 16;
      goto LABEL_66;
    }
  }
  *(_WORD *)&type.sa_len = 7708;
  v29 = 28;
LABEL_66:
  *(_WORD *)type.sa_data = a3;
  if (bind(v12, &type, v29))
  {
    v33 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v33;
    if (v33 <= 0x31 && ((1 << v33) & 0x2000000002002) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_ERROR, "%{public}s bind(fd %d) failed %{darwin.errno}d", buf, 0x18u);
      }
      goto LABEL_126;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v12;
    v57 = 1024;
    v58[0] = v33;
    v14 = (char *)_os_log_send_and_compose_impl();
    v50 = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if ((__nwlog_fault(v14, &v50, &v48) & 1) != 0)
    {
      if (v50 == OS_LOG_TYPE_FAULT)
      {
        v38 = __nwlog_obj();
        v39 = v50;
        if (!os_log_type_enabled(v38, v50))
          goto LABEL_124;
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        v17 = "%{public}s bind(fd %d) failed %{darwin.errno}d";
        goto LABEL_133;
      }
      if (!v48)
      {
        v38 = __nwlog_obj();
        v39 = v50;
        if (!os_log_type_enabled(v38, v50))
          goto LABEL_124;
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        v17 = "%{public}s bind(fd %d) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_133;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = __nwlog_obj();
      v39 = v50;
      v43 = os_log_type_enabled(v38, v50);
      if (backtrace_string)
      {
        if (!v43)
          goto LABEL_27;
        *(_DWORD *)buf = 136446978;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        LOWORD(v58[1]) = 2082;
        *(_QWORD *)((char *)&v58[1] + 2) = backtrace_string;
        v22 = "%{public}s bind(fd %d) failed %{darwin.errno}d, dumping backtrace:%{public}s";
        v24 = v38;
        v25 = v39;
        v26 = 34;
        goto LABEL_26;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446722;
        v54 = "tcp_listener_socket_create";
        v55 = 1024;
        v56 = v12;
        v57 = 1024;
        v58[0] = v33;
        v17 = "%{public}s bind(fd %d) failed %{darwin.errno}d, no backtrace";
LABEL_133:
        v44 = v38;
        v45 = v39;
        v46 = 24;
        goto LABEL_123;
      }
    }
LABEL_124:
    if (v14)
      free(v14);
LABEL_126:
    v40 = 0;
    goto LABEL_127;
  }
  if (listen(v12, 10))
  {
    v36 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    *a6 = v36;
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v54 = "tcp_listener_socket_create";
    v55 = 1024;
    v56 = v36;
    v14 = (char *)_os_log_send_and_compose_impl();
    v50 = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v14, &v50, &v48))
      goto LABEL_124;
    if (v50 == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      sa_len = v50;
      if (!os_log_type_enabled(v15, v50))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v36;
      v17 = "%{public}s listen failed %{darwin.errno}d";
      goto LABEL_122;
    }
    if (!v48)
    {
      v15 = __nwlog_obj();
      sa_len = v50;
      if (!os_log_type_enabled(v15, v50))
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v36;
      v17 = "%{public}s listen failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_122;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    sa_len = v50;
    v41 = os_log_type_enabled(v15, v50);
    if (!backtrace_string)
    {
      if (!v41)
        goto LABEL_124;
      *(_DWORD *)buf = 136446466;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v36;
      v17 = "%{public}s listen failed %{darwin.errno}d, no backtrace";
      goto LABEL_122;
    }
    if (v41)
    {
      *(_DWORD *)buf = 136446722;
      v54 = "tcp_listener_socket_create";
      v55 = 1024;
      v56 = v36;
      v57 = 2082;
      *(_QWORD *)v58 = backtrace_string;
      v22 = "%{public}s listen failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_25;
    }
    goto LABEL_27;
  }
  v40 = tcp_listener_socket_create_with_fd(a2, a1, v12);
  if (!v40)
    *a6 = 12;
LABEL_127:
  if (v12 != -1 && !v40)
    close(v12);
  return v40;
}

void tcp_listener_dns_handler(uint64_t a1, int a2, int a3, const char *a4, const char *a5, const char *a6, uint64_t a7)
{
  NSObject *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    v18 = "tcp_listener_dns_handler";
    v14 = "<NULL>";
    v17 = 136447490;
    if (a4)
      v14 = a4;
    v19 = 1024;
    v20 = a2;
    v15 = "NULL";
    v21 = 1024;
    if (a5)
      v16 = a5;
    else
      v16 = "NULL";
    v22 = a3;
    if (a6)
      v15 = a6;
    v23 = 2082;
    v24 = v14;
    v25 = 2082;
    v26 = v16;
    v27 = 2082;
    v28 = v15;
    _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s flags=0x%x, errorCode=%d, name=%{public}s, type=%{public}s, domain=%{public}s", (uint8_t *)&v17, 0x36u);
  }
  if (a3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a7 + 72));
    tcp_listener_call_error_handler_locked((_QWORD *)a7, a3);
    os_unfair_lock_unlock((os_unfair_lock_t)(a7 + 72));
  }
}

void __tcp_listener_socket_create_with_fd_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  void *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  int v8;
  pid_t v9;
  NSObject *v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  size_t v15;
  ssize_t v16;
  char *v17;
  char *v18;
  nw_endpoint_t v19;
  NSObject *v20;
  uint64_t v21;
  const char *v22;
  int v23;
  NSObject *v24;
  nw_endpoint_t v25;
  NSObject *v26;
  const char *logging_description;
  NSObject *v28;
  NSObject *v29;
  int v30;
  NSObject *v31;
  int v32;
  const char *v33;
  int v34;
  BOOL v35;
  NSObject *v36;
  const char *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  char *backtrace_string;
  _BOOL4 v43;
  uint64_t v44;
  _QWORD block[7];
  socklen_t v46;
  sockaddr address;
  uint64_t v48;
  int v49;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  uint64_t v53;
  int __buf;
  _BYTE v55[48];
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  _BYTE v83[28];
  uint64_t v84;

  v1 = a1;
  v84 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 72));
  v2 = *(_QWORD *)(v1 + 32);
  if (!v2)
  {
    __nwlog_obj();
    __buf = 136446210;
    *(_QWORD *)v55 = "tcp_listener_accept_locked";
    v38 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(block[0]) = 16;
    address.sa_len = 0;
    if (!__nwlog_fault(v38, block, &address))
      goto LABEL_68;
    if (LOBYTE(block[0]) == 17)
    {
      v39 = __nwlog_obj();
      v40 = block[0];
      if (!os_log_type_enabled(v39, block[0]))
        goto LABEL_68;
      __buf = 136446210;
      *(_QWORD *)v55 = "tcp_listener_accept_locked";
      v41 = "%{public}s called with null listener";
    }
    else if (address.sa_len)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v39 = __nwlog_obj();
      v40 = block[0];
      v43 = os_log_type_enabled(v39, block[0]);
      if (backtrace_string)
      {
        if (v43)
        {
          __buf = 136446466;
          *(_QWORD *)v55 = "tcp_listener_accept_locked";
          *(_WORD *)&v55[8] = 2082;
          *(_QWORD *)&v55[10] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s called with null listener, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_68;
      }
      if (!v43)
      {
LABEL_68:
        if (v38)
          free(v38);
        goto LABEL_53;
      }
      __buf = 136446210;
      *(_QWORD *)v55 = "tcp_listener_accept_locked";
      v41 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v39 = __nwlog_obj();
      v40 = block[0];
      if (!os_log_type_enabled(v39, block[0]))
        goto LABEL_68;
      __buf = 136446210;
      *(_QWORD *)v55 = "tcp_listener_accept_locked";
      v41 = "%{public}s called with null listener, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v39, v40, v41, (uint8_t *)&__buf, 0xCu);
    goto LABEL_68;
  }
  v44 = v1;
  v3 = *(_DWORD *)(v1 + 40);
  v4 = &unk_1ECD84000;
  while (1)
  {
    *(_QWORD *)&address.sa_len = 0;
    *(_QWORD *)&address.sa_data[6] = 0;
    v49 = 0;
    v48 = 0;
    v46 = 28;
    v7 = accept(v3, &address, &v46);
    if (v7 < 0)
      break;
    v8 = v7;
    if (setsockopt(v7, 0xFFFF, 4130, &tcp_listener_accept_locked_on, 4u))
    {
      v25 = nw_endpoint_create_address(&address);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = *((_QWORD *)v4 + 463);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        logging_description = nw_endpoint_get_logging_description(v25);
        __buf = 136446466;
        *(_QWORD *)v55 = "tcp_listener_accept_locked";
        *(_WORD *)&v55[8] = 2082;
        *(_QWORD *)&v55[10] = logging_description;
        _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_ERROR, "%{public}s Failed to set SO_NOSIGPIPE on new connection from %{public}s", (uint8_t *)&__buf, 0x16u);
      }
      v1 = v44;
      if (v25)
        goto LABEL_51;
      goto LABEL_52;
    }
    if (xpc_dictionary_get_BOOL(*(xpc_object_t *)(v2 + 16), "localonly"))
    {
      v9 = getpid();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = *((_QWORD *)v4 + 463);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v51 = "tcp_listener_verify_local";
        v52 = 2048;
        v53 = v2;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %p", buf, 0x16u);
      }
      v11 = socket(17, 3, 0);
      if (v11 < 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = *((_QWORD *)v4 + 463);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          v30 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          *(_DWORD *)buf = 136446466;
          v51 = "tcp_listener_verify_local";
          v52 = 1024;
          LODWORD(v53) = v30;
          _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s failure to create routing socket %d", buf, 0x12u);
        }
      }
      else
      {
        v12 = v11;
        do
        {
          v13 = __ldxr((unsigned int *)&tcp_listener_verify_local_seq);
          v14 = v13 + 1;
        }
        while (__stxr(v14, (unsigned int *)&tcp_listener_verify_local_seq));
        tcp_listener_verify_local_seq = v14;
        *(_DWORD *)v55 = 0;
        memset(&v55[16], 0, 32);
        v56 = 0u;
        v57 = 0u;
        v58 = 0u;
        v59 = 0u;
        v60 = 0u;
        v61 = 0u;
        v62 = 0u;
        v63 = 0u;
        v64 = 0u;
        v65 = 0u;
        v66 = 0u;
        v67 = 0u;
        v68 = 0u;
        v69 = 0u;
        v70 = 0u;
        v71 = 0u;
        v72 = 0u;
        v73 = 0u;
        v74 = 0u;
        v75 = 0u;
        v76 = 0u;
        v77 = 0u;
        v78 = 0u;
        v79 = 0u;
        v80 = 0u;
        v81 = 0u;
        v82 = 0u;
        memset(v83, 0, sizeof(v83));
        HIWORD(__buf) = 4357;
        *(_QWORD *)&v55[4] = 0x100000807;
        v15 = address.sa_len + 92;
        LOWORD(__buf) = address.sa_len + 92;
        *(_DWORD *)&v55[12] = v9;
        *(_DWORD *)&v55[16] = v14;
        __memcpy_chk();
        if (write(v12, &__buf, v15) < 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = *((_QWORD *)v4 + 463);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          {
            v32 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            *(_DWORD *)buf = 136446466;
            v51 = "tcp_listener_verify_local";
            v52 = 1024;
            LODWORD(v53) = v32;
            v33 = "%{public}s failure while writing to the routing socket %d";
            goto LABEL_44;
          }
        }
        else
        {
          while (1)
          {
            v16 = read(v12, &__buf, 0x200uLL);
            if (v16 < 1)
              break;
            if (*(_DWORD *)&v55[16] == tcp_listener_verify_local_seq && *(_DWORD *)&v55[12] == v9)
              goto LABEL_20;
          }
          if ((v16 & 0x8000000000000000) == 0)
          {
LABEL_20:
            close(v12);
            if ((*(_DWORD *)&v55[4] & 0x200400) == 0)
              goto LABEL_46;
            goto LABEL_21;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = *((_QWORD *)v4 + 463);
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
            goto LABEL_45;
          v34 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          *(_DWORD *)buf = 136446466;
          v51 = "tcp_listener_verify_local";
          v52 = 1024;
          LODWORD(v53) = v34;
          v33 = "%{public}s failure reading from the routing socket %d";
LABEL_44:
          _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, v33, buf, 0x12u);
        }
LABEL_45:
        close(v12);
      }
LABEL_46:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = os_log_type_enabled(*((os_log_t *)v4 + 463), OS_LOG_TYPE_DEBUG);
      v1 = v44;
      if (v35 || gLogFDOverride != -1)
      {
        v25 = nw_endpoint_create_address(&address);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v36 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          v37 = nw_endpoint_get_logging_description(v25);
          __buf = 136446466;
          *(_QWORD *)v55 = "tcp_listener_accept_locked";
          *(_WORD *)&v55[8] = 2082;
          *(_QWORD *)&v55[10] = v37;
          _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s Ignoring non-local connection from %{public}s", (uint8_t *)&__buf, 0x16u);
        }
        if (v25)
LABEL_51:
          os_release(v25);
      }
LABEL_52:
      close(v8);
      goto LABEL_53;
    }
LABEL_21:
    v17 = tcp_connection_create_with_connected_fd_inner(v8, 1);
    if (!v17)
    {
      close(v8);
      tcp_listener_call_error_handler_locked((_QWORD *)v2, 12);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v28 = *((_QWORD *)v4 + 463);
      v1 = v44;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        __buf = 136446210;
        *(_QWORD *)v55 = "tcp_listener_accept_locked";
        _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_ERROR, "%{public}s tcp_connection_create_inbound() returned non-zero", (uint8_t *)&__buf, 0xCu);
      }
      goto LABEL_53;
    }
    v18 = v17;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    if (os_log_type_enabled(*((os_log_t *)v4 + 463), OS_LOG_TYPE_DEBUG) || gLogFDOverride != -1)
    {
      v19 = nw_endpoint_create_address(&address);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = *((_QWORD *)v4 + 463);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v21 = tcp_connection_id(v18);
        v22 = nw_endpoint_get_logging_description(v19);
        __buf = 136446978;
        *(_QWORD *)v55 = "tcp_listener_accept_locked";
        *(_WORD *)&v55[8] = 2048;
        *(_QWORD *)&v55[10] = v21;
        v4 = &unk_1ECD84000;
        *(_WORD *)&v55[18] = 1024;
        *(_DWORD *)&v55[20] = v8;
        *(_WORD *)&v55[24] = 2082;
        *(_QWORD *)&v55[26] = v22;
        _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s client connection %llu fd=%d from %{public}s", (uint8_t *)&__buf, 0x26u);
      }
      if (v19)
        os_release(v19);
    }
    v5 = *(_QWORD *)(v2 + 40);
    if (v5)
    {
      v6 = *(NSObject **)(v2 + 32);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __tcp_listener_accept_locked_block_invoke;
      block[3] = &unk_1E14A08D8;
      block[5] = v18;
      block[6] = v2;
      block[4] = v5;
      dispatch_async(v6, block);
    }
    else
    {
      os_release(v18);
    }
  }
  v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  v1 = v44;
  if (v23 != 35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      __buf = 136446466;
      *(_QWORD *)v55 = "tcp_listener_accept_locked";
      *(_WORD *)&v55[8] = 1024;
      *(_DWORD *)&v55[10] = v23;
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s accept failed %{darwin.errno}d", (uint8_t *)&__buf, 0x12u);
    }
    tcp_listener_call_error_handler_locked((_QWORD *)v2, v23);
  }
LABEL_53:
  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(v1 + 32) + 72));
}

void __tcp_listener_socket_create_with_fd_block_invoke_2(uint64_t a1)
{
  void *v2;
  NSObject *v3;

  v2 = *(void **)(a1 + 40);
  close(*(_DWORD *)(a1 + 48));
  v3 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v3)
  {
    dispatch_release(v3);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  if (v2)
    os_release(v2);
}

void __tcp_listener_accept_locked_block_invoke(_QWORD *a1)
{
  void *v1;

  v1 = (void *)a1[5];
  if (*(_DWORD *)(a1[6] + 80) != 3)
    (*(void (**)(void))(a1[4] + 16))();
  if (v1)
    os_release(v1);
}

void __Block_byref_object_copy__34667(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 135);
}

void __Block_byref_object_dispose__34668(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 135);
}

void __tcp_listener_call_error_handler_locked_block_invoke(uint64_t a1)
{
  _DWORD *v2;
  const void *v3;

  v2 = *(_DWORD **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2[20] == 3
    || ((*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) + 16))(),
        (v2 = *(_DWORD **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)) != 0))
  {
    os_release(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  v3 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  if (v3)
  {
    _Block_release(v3);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = 0;
  }
}

void tcp_listener_cancel_locked(_QWORD *a1)
{
  NSObject *v2;
  void *v3;
  NSObject *v4;
  int v5;
  const void *v6;
  const void *v7;
  _DNSServiceRef_t *v8;
  int v9;
  const char *v10;
  __int16 v11;
  _QWORD *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    v9 = 136446466;
    v10 = "tcp_listener_cancel_locked";
    v11 = 2048;
    v12 = a1;
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %p", (uint8_t *)&v9, 0x16u);
  }
  while (1)
  {
    v3 = (void *)a1[8];
    if (!v3)
      break;
    a1[8] = *(_QWORD *)v3;
    v4 = *((_QWORD *)v3 + 1);
    if (v4)
    {
      dispatch_source_cancel(v4);
      if (!*((_BYTE *)v3 + 20))
        dispatch_resume(*((dispatch_object_t *)v3 + 1));
    }
    else
    {
      v5 = *((_DWORD *)v3 + 4);
      if (v5 != -1)
        close(v5);
    }
    free(v3);
  }
  v6 = (const void *)a1[5];
  if (v6)
  {
    _Block_release(v6);
    a1[5] = 0;
  }
  v7 = (const void *)a1[6];
  if (v7)
  {
    _Block_release(v7);
    a1[6] = 0;
  }
  v8 = (_DNSServiceRef_t *)a1[7];
  if (v8)
  {
    DNSServiceRefDeallocate(v8);
    a1[7] = 0;
  }
}

void tcp_listener_cancel(uint64_t a1)
{
  os_unfair_lock_s *v2;
  NSObject *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  _BOOL4 v9;
  _QWORD block[5];
  char v11;
  os_log_type_t type;
  _BYTE buf[24];
  void *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    *(_DWORD *)(a1 + 80) = 3;
    os_unfair_lock_unlock(v2);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v14 = 0;
    v14 = os_retain((void *)a1);
    v3 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __tcp_listener_cancel_block_invoke;
    block[3] = &unk_1E14A07E0;
    block[4] = buf;
    dispatch_async(v3, block);
    _Block_object_dispose(buf, 8);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "tcp_listener_cancel";
  v4 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_cancel";
      v7 = "%{public}s called with null listener";
      goto LABEL_17;
    }
    if (!v11)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_cancel";
      v7 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "tcp_listener_cancel";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "tcp_listener_cancel";
      v7 = "%{public}s called with null listener, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_18:
  if (v4)
    free(v4);
}

void __tcp_listener_cancel_block_invoke(uint64_t a1)
{
  void *v2;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 72));
  tcp_listener_cancel_locked(*(_QWORD **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 72));
  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

uint64_t tcp_listener_get_dns_service_ref(uint64_t a1)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    v3 = *(_QWORD *)(a1 + 56);
    os_unfair_lock_unlock(v2);
    return v3;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "tcp_listener_get_dns_service_ref";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "tcp_listener_get_dns_service_ref";
        v8 = "%{public}s called with null listener";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "tcp_listener_get_dns_service_ref";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "tcp_listener_get_dns_service_ref";
        v8 = "%{public}s called with null listener, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "tcp_listener_get_dns_service_ref";
        v8 = "%{public}s called with null listener, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v5)
    free(v5);
  return 0;
}

void tcp_listener_set_accept_handler(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  const void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_accept_handler";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_listener_set_accept_handler";
      v10 = "%{public}s called with null listener";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "tcp_listener_set_accept_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v7)
          return;
        goto LABEL_37;
      }
      if (!v12)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_listener_set_accept_handler";
      v10 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_listener_set_accept_handler";
      v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_36;
  }
  if (a2)
  {
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(const void **)(a1 + 40) != a2)
    {
      v5 = _Block_copy(a2);
      v6 = *(const void **)(a1 + 40);
      if (v6)
        _Block_release(v6);
      *(_QWORD *)(a1 + 40) = v5;
    }
    os_unfair_lock_unlock(v4);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "tcp_listener_set_accept_handler";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_accept_handler";
    v10 = "%{public}s called with null acceptblk";
    goto LABEL_35;
  }
  if (!v15)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_accept_handler";
    v10 = "%{public}s called with null acceptblk, backtrace limit exceeded";
    goto LABEL_35;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_accept_handler";
    v10 = "%{public}s called with null acceptblk, no backtrace";
    goto LABEL_35;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v18 = "tcp_listener_set_accept_handler";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null acceptblk, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v7)
LABEL_37:
    free(v7);
}

void tcp_listener_set_accept_handler_f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v4;
  void *v5;
  const void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  _QWORD aBlock[6];
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_accept_handler_f";
    v7 = (char *)_os_log_send_and_compose_impl();
    v17 = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &v17, &v16))
      goto LABEL_37;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v17;
      if (!os_log_type_enabled(v8, v17))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_listener_set_accept_handler_f";
      v10 = "%{public}s called with null listener";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = v17;
      v12 = os_log_type_enabled(v8, v17);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "tcp_listener_set_accept_handler_f";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v7)
          return;
LABEL_38:
        free(v7);
        return;
      }
      if (!v12)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_listener_set_accept_handler_f";
      v10 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = v17;
      if (!os_log_type_enabled(v8, v17))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_listener_set_accept_handler_f";
      v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_37;
  }
  if (a3)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 0x40000000;
    aBlock[2] = __tcp_listener_set_accept_handler_f_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_3_34702;
    aBlock[4] = a3;
    aBlock[5] = a2;
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_QWORD **)(a1 + 40) != aBlock)
    {
      v5 = _Block_copy(aBlock);
      v6 = *(const void **)(a1 + 40);
      if (v6)
        _Block_release(v6);
      *(_QWORD *)(a1 + 40) = v5;
    }
    os_unfair_lock_unlock(v4);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "tcp_listener_set_accept_handler_f";
  v7 = (char *)_os_log_send_and_compose_impl();
  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v7, &v17, &v16))
    goto LABEL_37;
  if (v17 == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = v17;
    if (!os_log_type_enabled(v8, v17))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_accept_handler_f";
    v10 = "%{public}s called with null acceptfnc";
    goto LABEL_36;
  }
  if (!v16)
  {
    v8 = __nwlog_obj();
    v9 = v17;
    if (!os_log_type_enabled(v8, v17))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_accept_handler_f";
    v10 = "%{public}s called with null acceptfnc, backtrace limit exceeded";
    goto LABEL_36;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = v17;
  v14 = os_log_type_enabled(v8, v17);
  if (!v13)
  {
    if (!v14)
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_accept_handler_f";
    v10 = "%{public}s called with null acceptfnc, no backtrace";
    goto LABEL_36;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "tcp_listener_set_accept_handler_f";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null acceptfnc, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v7)
    goto LABEL_38;
}

uint64_t __tcp_listener_set_accept_handler_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

void tcp_listener_set_error_handler(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  void *v5;
  const void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_error_handler";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15))
      goto LABEL_36;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_listener_set_error_handler";
      v10 = "%{public}s called with null listener";
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "tcp_listener_set_error_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v7)
          return;
        goto LABEL_37;
      }
      if (!v12)
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_listener_set_error_handler";
      v10 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v18 = "tcp_listener_set_error_handler";
      v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_36;
  }
  if (a2)
  {
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(const void **)(a1 + 48) != a2)
    {
      v5 = _Block_copy(a2);
      v6 = *(const void **)(a1 + 48);
      if (v6)
        _Block_release(v6);
      *(_QWORD *)(a1 + 48) = v5;
    }
    os_unfair_lock_unlock(v4);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "tcp_listener_set_error_handler";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15))
    goto LABEL_36;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_error_handler";
    v10 = "%{public}s called with null handler";
    goto LABEL_35;
  }
  if (!v15)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_error_handler";
    v10 = "%{public}s called with null handler, backtrace limit exceeded";
    goto LABEL_35;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v14 = os_log_type_enabled(v8, type);
  if (!v13)
  {
    if (!v14)
      goto LABEL_36;
    *(_DWORD *)buf = 136446210;
    v18 = "tcp_listener_set_error_handler";
    v10 = "%{public}s called with null handler, no backtrace";
    goto LABEL_35;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v18 = "tcp_listener_set_error_handler";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v7)
LABEL_37:
    free(v7);
}

void tcp_listener_set_error_handler_f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v4;
  void *v5;
  const void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char *v13;
  _BOOL4 v14;
  _QWORD aBlock[6];
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_error_handler_f";
    v7 = (char *)_os_log_send_and_compose_impl();
    v17 = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &v17, &v16))
      goto LABEL_37;
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = v17;
      if (!os_log_type_enabled(v8, v17))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_listener_set_error_handler_f";
      v10 = "%{public}s called with null listener";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = v17;
      v12 = os_log_type_enabled(v8, v17);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "tcp_listener_set_error_handler_f";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v7)
          return;
LABEL_38:
        free(v7);
        return;
      }
      if (!v12)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_listener_set_error_handler_f";
      v10 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = v17;
      if (!os_log_type_enabled(v8, v17))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v19 = "tcp_listener_set_error_handler_f";
      v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_37;
  }
  if (a3)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 0x40000000;
    aBlock[2] = __tcp_listener_set_error_handler_f_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_5_34724;
    aBlock[4] = a3;
    aBlock[5] = a2;
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_QWORD **)(a1 + 48) != aBlock)
    {
      v5 = _Block_copy(aBlock);
      v6 = *(const void **)(a1 + 48);
      if (v6)
        _Block_release(v6);
      *(_QWORD *)(a1 + 48) = v5;
    }
    os_unfair_lock_unlock(v4);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v19 = "tcp_listener_set_error_handler_f";
  v7 = (char *)_os_log_send_and_compose_impl();
  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (!__nwlog_fault(v7, &v17, &v16))
    goto LABEL_37;
  if (v17 == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = v17;
    if (!os_log_type_enabled(v8, v17))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_error_handler_f";
    v10 = "%{public}s called with null handler";
    goto LABEL_36;
  }
  if (!v16)
  {
    v8 = __nwlog_obj();
    v9 = v17;
    if (!os_log_type_enabled(v8, v17))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_error_handler_f";
    v10 = "%{public}s called with null handler, backtrace limit exceeded";
    goto LABEL_36;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = v17;
  v14 = os_log_type_enabled(v8, v17);
  if (!v13)
  {
    if (!v14)
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v19 = "tcp_listener_set_error_handler_f";
    v10 = "%{public}s called with null handler, no backtrace";
    goto LABEL_36;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    v19 = "tcp_listener_set_error_handler_f";
    v20 = 2082;
    v21 = v13;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v7)
    goto LABEL_38;
}

uint64_t __tcp_listener_set_error_handler_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

uint64_t tcp_listener_set_port(uint64_t a1, const char *a2)
{
  uint64_t v4;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  os_log_type_t type[8];
  char v15;
  addrinfo v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v16.ai_flags = 136446210;
    *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
    v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, type, &v15))
      goto LABEL_39;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v15)
      {
        v7 = __nwlog_obj();
        v8 = type[0];
        if (!os_log_type_enabled(v7, type[0]))
          goto LABEL_39;
        v16.ai_flags = 136446210;
        *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
        v9 = "%{public}s called with null listener, backtrace limit exceeded";
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type[0];
      v11 = os_log_type_enabled(v7, type[0]);
      if (!backtrace_string)
      {
        if (!v11)
          goto LABEL_39;
        v16.ai_flags = 136446210;
        *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
        v9 = "%{public}s called with null listener, no backtrace";
        goto LABEL_38;
      }
      if (v11)
      {
        v16.ai_flags = 136446466;
        *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
        LOWORD(v16.ai_protocol) = 2082;
        *(_QWORD *)((char *)&v16.ai_protocol + 2) = backtrace_string;
        v12 = "%{public}s called with null listener, dumping backtrace:%{public}s";
LABEL_28:
        _os_log_impl(&dword_182FBE000, v7, v8, v12, (uint8_t *)&v16, 0x16u);
      }
LABEL_29:
      free(backtrace_string);
      goto LABEL_39;
    }
    v7 = __nwlog_obj();
    v8 = type[0];
    if (!os_log_type_enabled(v7, type[0]))
      goto LABEL_39;
    v16.ai_flags = 136446210;
    *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
    v9 = "%{public}s called with null listener";
LABEL_38:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, (uint8_t *)&v16, 0xCu);
LABEL_39:
    if (v6)
      free(v6);
    return 22;
  }
  if (!a2)
  {
    __nwlog_obj();
    v16.ai_flags = 136446210;
    *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
    v6 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (!__nwlog_fault(v6, type, &v15))
      goto LABEL_39;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type[0];
      if (!os_log_type_enabled(v7, type[0]))
        goto LABEL_39;
      v16.ai_flags = 136446210;
      *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
      v9 = "%{public}s called with null portstr";
      goto LABEL_38;
    }
    if (!v15)
    {
      v7 = __nwlog_obj();
      v8 = type[0];
      if (!os_log_type_enabled(v7, type[0]))
        goto LABEL_39;
      v16.ai_flags = 136446210;
      *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
      v9 = "%{public}s called with null portstr, backtrace limit exceeded";
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type[0];
    v13 = os_log_type_enabled(v7, type[0]);
    if (backtrace_string)
    {
      if (v13)
      {
        v16.ai_flags = 136446466;
        *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
        LOWORD(v16.ai_protocol) = 2082;
        *(_QWORD *)((char *)&v16.ai_protocol + 2) = backtrace_string;
        v12 = "%{public}s called with null portstr, dumping backtrace:%{public}s";
        goto LABEL_28;
      }
      goto LABEL_29;
    }
    if (!v13)
      goto LABEL_39;
    v16.ai_flags = 136446210;
    *(_QWORD *)&v16.ai_family = "tcp_listener_set_port";
    v9 = "%{public}s called with null portstr, no backtrace";
    goto LABEL_38;
  }
  if (xpc_dictionary_get_string(*(xpc_object_t *)(a1 + 16), "launchd"))
    return 22;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  if (*(_DWORD *)(a1 + 80) == 1)
  {
    memset(&v16.ai_addrlen, 0, 32);
    v16.ai_flags = 0;
    v16.ai_protocol = 6;
    *(_QWORD *)&v16.ai_family = 0x100000002;
    *(_QWORD *)type = 0;
    v4 = getaddrinfo(0, a2, &v16, (addrinfo **)type);
    if (!(_DWORD)v4)
    {
      xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 16), "port", *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)type + 32) + 2));
      if (*(_QWORD *)type)
        freeaddrinfo(*(addrinfo **)type);
    }
  }
  else
  {
    v4 = 16;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 72));
  return v4;
}

uint64_t tcp_listener_get_port(uint64_t a1)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    v3 = *(unsigned __int16 *)(a1 + 84);
    os_unfair_lock_unlock(v2);
    return v3;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "tcp_listener_get_port";
  v5 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "tcp_listener_get_port";
        v8 = "%{public}s called with null listener";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "tcp_listener_get_port";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "tcp_listener_get_port";
        v8 = "%{public}s called with null listener, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "tcp_listener_get_port";
        v8 = "%{public}s called with null listener, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v5)
    free(v5);
  return 0;
}

void tcp_listener_set_local_only(uint64_t a1, BOOL a2)
{
  os_unfair_lock_s *v4;
  NSObject *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 16), "localonly", a2);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "tcp_listener_set_local_only";
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s listener is already running", buf, 0xCu);
      }
    }
    os_unfair_lock_unlock(v4);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_listener_set_local_only";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_local_only";
      v9 = "%{public}s called with null listener";
      goto LABEL_21;
    }
    if (!v12)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_local_only";
      v9 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_21;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v15 = "tcp_listener_set_local_only";
        v16 = 2082;
        v17 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_22;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_local_only";
      v9 = "%{public}s called with null listener, no backtrace";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_22:
  if (v6)
    free(v6);
}

void tcp_listener_set_tfo(uint64_t a1, BOOL a2)
{
  os_unfair_lock_s *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 16), "tfo", a2);
LABEL_20:
      os_unfair_lock_unlock(v4);
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v20 = "tcp_listener_set_tfo";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v5, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v7 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_18;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_listener_set_tfo";
        v8 = "%{public}s listener is already running";
        goto LABEL_17;
      }
      if (!v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v6 = gLogObj;
        v7 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_18;
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_listener_set_tfo";
        v8 = "%{public}s listener is already running, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      v10 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "tcp_listener_set_tfo";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s listener is already running, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "tcp_listener_set_tfo";
        v8 = "%{public}s listener is already running, no backtrace";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
LABEL_18:
    if (v5)
      free(v5);
    goto LABEL_20;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v20 = "tcp_listener_set_tfo";
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_listener_set_tfo";
      v14 = "%{public}s called with null listener";
      goto LABEL_35;
    }
    if (!v17)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_listener_set_tfo";
      v14 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_35;
    }
    v15 = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v16 = os_log_type_enabled(v12, type);
    if (v15)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "tcp_listener_set_tfo";
        v21 = 2082;
        v22 = v15;
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v15);
      goto LABEL_36;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v20 = "tcp_listener_set_tfo";
      v14 = "%{public}s called with null listener, no backtrace";
LABEL_35:
      _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
    }
  }
LABEL_36:
  if (v11)
    free(v11);
}

void tcp_listener_enable_coprocessor_interface(uint64_t a1, char a2)
{
  NSObject *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  _QWORD block[5];
  char v10;
  char v11;
  os_log_type_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(NSObject **)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __tcp_listener_enable_coprocessor_interface_block_invoke;
    block[3] = &__block_descriptor_tmp_6_34762;
    block[4] = a1;
    v10 = a2;
    dispatch_sync(v2, block);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "tcp_listener_enable_coprocessor_interface";
  v3 = (char *)_os_log_send_and_compose_impl();
  v12 = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v3, &v12, &v11))
  {
    if (v12 == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = v12;
      if (!os_log_type_enabled(v4, v12))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v14 = "tcp_listener_enable_coprocessor_interface";
      v6 = "%{public}s called with null listener";
      goto LABEL_17;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = v12;
      if (!os_log_type_enabled(v4, v12))
        goto LABEL_18;
      *(_DWORD *)buf = 136446210;
      v14 = "tcp_listener_enable_coprocessor_interface";
      v6 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = v12;
    v8 = os_log_type_enabled(v4, v12);
    if (backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446466;
        v14 = "tcp_listener_enable_coprocessor_interface";
        v15 = 2082;
        v16 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      v14 = "tcp_listener_enable_coprocessor_interface";
      v6 = "%{public}s called with null listener, no backtrace";
LABEL_17:
      _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
    }
  }
LABEL_18:
  if (v3)
    free(v3);
}

void __tcp_listener_enable_coprocessor_interface_block_invoke(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v1 + 80) == 1)
  {
    xpc_dictionary_set_BOOL(*(xpc_object_t *)(v1 + 16), "coproc", *(_BYTE *)(a1 + 40));
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
      v5 = "%{public}s listener is already running";
      goto LABEL_16;
    }
    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
      v5 = "%{public}s listener is already running, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = type;
    v7 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
        v12 = 2082;
        v13 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s listener is already running, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_17;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      v11 = "tcp_listener_enable_coprocessor_interface_block_invoke";
      v5 = "%{public}s listener is already running, no backtrace";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_17:
  if (v2)
    free(v2);
}

void tcp_listener_set_service(uint64_t a1, const char *a2, const char *a3, const char *a4)
{
  os_unfair_lock_s *v8;
  NSObject *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "tcp_listener_set_service";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v21 = "tcp_listener_set_service";
      v13 = "%{public}s called with null listener";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "tcp_listener_set_service";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_40:
        if (!v10)
          return;
LABEL_41:
        free(v10);
        return;
      }
      if (!v15)
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v21 = "tcp_listener_set_service";
      v13 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_40;
      *(_DWORD *)buf = 136446210;
      v21 = "tcp_listener_set_service";
      v13 = "%{public}s called with null listener, backtrace limit exceeded";
    }
LABEL_39:
    _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    goto LABEL_40;
  }
  if (a3)
  {
    v8 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      if (a2)
        xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 16), "srvname", a2);
      xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 16), "srvtype", a3);
      if (a4)
        xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 16), "srvdomain", a4);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "tcp_listener_set_service";
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s listener is already running", buf, 0xCu);
      }
    }
    os_unfair_lock_unlock(v8);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "tcp_listener_set_service";
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v10, &type, &v18))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v21 = "tcp_listener_set_service";
    v13 = "%{public}s called with null regtype";
    goto LABEL_39;
  }
  if (!v18)
  {
    v11 = __nwlog_obj();
    v12 = type;
    if (!os_log_type_enabled(v11, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v21 = "tcp_listener_set_service";
    v13 = "%{public}s called with null regtype, backtrace limit exceeded";
    goto LABEL_39;
  }
  v16 = (char *)__nw_create_backtrace_string();
  v11 = __nwlog_obj();
  v12 = type;
  v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17)
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v21 = "tcp_listener_set_service";
    v13 = "%{public}s called with null regtype, no backtrace";
    goto LABEL_39;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v21 = "tcp_listener_set_service";
    v22 = 2082;
    v23 = v16;
    _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null regtype, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v10)
    goto LABEL_41;
}

void tcp_listener_set_register_p2p(uint64_t a1, BOOL a2)
{
  os_unfair_lock_s *v4;
  NSObject *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 16), "registerp2p", a2);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "tcp_listener_set_register_p2p";
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s listener is already running", buf, 0xCu);
      }
    }
    os_unfair_lock_unlock(v4);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_listener_set_register_p2p";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_register_p2p";
      v9 = "%{public}s called with null listener";
      goto LABEL_21;
    }
    if (!v12)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_register_p2p";
      v9 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_21;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v15 = "tcp_listener_set_register_p2p";
        v16 = 2082;
        v17 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_22;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_register_p2p";
      v9 = "%{public}s called with null listener, no backtrace";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_22:
  if (v6)
    free(v6);
}

void tcp_listener_set_interface(uint64_t a1, const char *a2)
{
  os_unfair_lock_s *v4;
  NSObject *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = (os_unfair_lock_s *)(a1 + 72);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
    if (*(_DWORD *)(a1 + 80) == 1)
    {
      xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 16), "interface", a2);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "tcp_listener_set_interface";
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, "%{public}s listener is already running", buf, 0xCu);
      }
    }
    os_unfair_lock_unlock(v4);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v15 = "tcp_listener_set_interface";
  v6 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_interface";
      v9 = "%{public}s called with null listener";
      goto LABEL_21;
    }
    if (!v12)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_22;
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_interface";
      v9 = "%{public}s called with null listener, backtrace limit exceeded";
      goto LABEL_21;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        v15 = "tcp_listener_set_interface";
        v16 = 2082;
        v17 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_22;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      v15 = "tcp_listener_set_interface";
      v9 = "%{public}s called with null listener, no backtrace";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_22:
  if (v6)
    free(v6);
}

void *tcp_listener_retain(void *object)
{
  if (object)
    return os_retain(object);
  return object;
}

void tcp_listener_release(void *object)
{
  if (object)
    os_release(object);
}

void tcp_connection_retain(void *a1)
{
  char *v1;
  NSObject *v2;
  os_log_type_t v3;
  const char *v4;
  char *backtrace_string;
  _BOOL4 v6;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    os_retain(a1);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "tcp_connection_retain";
  v1 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v1, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v10 = "tcp_connection_retain";
      v4 = "%{public}s called with null connection";
      goto LABEL_16;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v10 = "tcp_connection_retain";
      v4 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    v3 = type;
    v6 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v6)
      {
        *(_DWORD *)buf = 136446466;
        v10 = "tcp_connection_retain";
        v11 = 2082;
        v12 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v2, v3, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_17;
    }
    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      v10 = "tcp_connection_retain";
      v4 = "%{public}s called with null connection, no backtrace";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v2, v3, v4, buf, 0xCu);
    }
  }
LABEL_17:
  if (v1)
    free(v1);
}

void tcp_connection_release(void *a1)
{
  char *v1;
  NSObject *v2;
  os_log_type_t v3;
  const char *v4;
  char *backtrace_string;
  _BOOL4 v6;
  char v7;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    os_release(a1);
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v10 = "tcp_connection_release";
  v1 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v7 = 0;
  if (__nwlog_fault(v1, &type, &v7))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v10 = "tcp_connection_release";
      v4 = "%{public}s called with null connection";
      goto LABEL_16;
    }
    if (!v7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      v3 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_17;
      *(_DWORD *)buf = 136446210;
      v10 = "tcp_connection_release";
      v4 = "%{public}s called with null connection, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = gLogObj;
    v3 = type;
    v6 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v6)
      {
        *(_DWORD *)buf = 136446466;
        v10 = "tcp_connection_release";
        v11 = 2082;
        v12 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v2, v3, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_17;
    }
    if (v6)
    {
      *(_DWORD *)buf = 136446210;
      v10 = "tcp_connection_release";
      v4 = "%{public}s called with null connection, no backtrace";
LABEL_16:
      _os_log_impl(&dword_182FBE000, v2, v3, v4, buf, 0xCu);
    }
  }
LABEL_17:
  if (v1)
    free(v1);
}

void sub_1836BE170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_authentication_challenge;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

NWConcrete_nw_authentication_protection_space *nw_authentication_protection_space_create(int a1)
{
  NWConcrete_nw_authentication_protection_space *result;
  id v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  objc_super v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  result = [NWConcrete_nw_authentication_protection_space alloc];
  if (!result)
    return result;
  v13.receiver = result;
  v13.super_class = (Class)NWConcrete_nw_authentication_protection_space;
  result = (NWConcrete_nw_authentication_protection_space *)objc_msgSendSuper2(&v13, sel_init);
  if (result)
  {
    result->type = a1;
    return result;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s [super init] failed", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "-[NWConcrete_nw_authentication_protection_space initWithType:]";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v4)
    free(v4);
  return 0;
}

void nw_authentication_protection_space_set_is_proxy(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 28) = *((_BYTE *)v3 + 28) & 0xFE | a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_protection_space_set_is_proxy";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_set_is_proxy";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_protection_space_set_is_proxy";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_set_is_proxy";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_set_is_proxy";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null protection_space, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_authentication_protection_space_get_is_proxy(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 28) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_protection_space_get_is_proxy";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_get_is_proxy";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_protection_space_get_is_proxy";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_get_is_proxy";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_get_is_proxy";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null protection_space, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_authentication_protection_space_set_endpoint(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 1, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_protection_space_set_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_set_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_protection_space_set_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_set_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_set_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null protection_space, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

id nw_authentication_protection_space_copy_endpoint(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[1];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_protection_space_copy_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_protection_space_copy_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_copy_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null protection_space, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_authentication_protection_space_set_realm(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  NSObject *v11;
  void *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_authentication_protection_space_set_realm";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_authentication_protection_space_set_realm";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protection_space", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_authentication_protection_space_set_realm";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null protection_space, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_authentication_protection_space_set_realm";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_authentication_protection_space_set_realm";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null protection_space, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v8)
      free(v8);
    goto LABEL_7;
  }
  v5 = (void *)v3[2];
  if (v5)
  {
    free(v5);
    v4[2] = 0;
  }
  if (!a2)
    goto LABEL_7;
  v6 = strdup(a2);
  if (v6)
  {
LABEL_6:
    v4[2] = v6;
LABEL_7:

    return;
  }
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    goto LABEL_6;
  }
  __break(1u);
}

uint64_t nw_authentication_protection_space_get_type(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[6];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_protection_space_get_type";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_get_type";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_protection_space_get_type";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_get_type";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_protection_space_get_type";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null protection_space, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_authentication_protection_space_set_proxy_origin_is_cleartext(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 2;
    else
      v5 = 0;
    *((_BYTE *)v3 + 28) = *((_BYTE *)v3 + 28) & 0xFD | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null protection_space", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null protection_space, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null protection_space, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_authentication_protection_space_set_proxy_origin_is_cleartext";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null protection_space, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

NWConcrete_nw_authentication_challenge *nw_authentication_challenge_create()
{
  return objc_alloc_init(NWConcrete_nw_authentication_challenge);
}

uint64_t nw_authentication_challenge_get_type(void *a1)
{
  id v1;
  unint64_t *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (unint64_t *)v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_authentication_challenge_get_type";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null challenge", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v20)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_authentication_challenge_get_type";
      v24 = 2082;
      v25 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  v3 = *((_QWORD *)v1 + 3);
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_authentication_challenge_get_type";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null challenge->protection_space_array", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v7)
        free(v7);
      goto LABEL_39;
    }
    if (!v20)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null challenge->protection_space_array, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    v16 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_authentication_challenge_get_type";
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null challenge->protection_space_array, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_authentication_challenge_get_type";
      v24 = 2082;
      v25 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null challenge->protection_space_array, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  if (*(_QWORD *)(v3 + 24) == *(_QWORD *)(v3 + 16))
  {
LABEL_39:
    v5 = 0;
    goto LABEL_40;
  }
  nw_array_get_object_at_index(v3, v2[4]);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = nw_authentication_protection_space_get_type(v4);

LABEL_40:
  return v5;
}

void nw_authentication_challenge_set_http_message(void *a1, const void *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  const void *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = (const void *)v3[2];
    if (v5)
    {
      CFRelease(v5);
      v4[2] = 0;
    }
    if (a2)
      v4[2] = CFRetain(a2);
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_authentication_challenge_set_http_message";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_authentication_challenge_set_http_message";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null challenge", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_authentication_challenge_set_http_message";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_authentication_challenge_set_http_message";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_authentication_challenge_set_http_message";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

void sub_1836C0010(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

CFTypeRef nw_authentication_challenge_copy_http_message(void *a1)
{
  id v1;
  void *v2;
  const void *v3;
  CFTypeRef v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_authentication_challenge_copy_http_message";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_authentication_challenge_copy_http_message";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_authentication_challenge_copy_http_message";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_authentication_challenge_copy_http_message";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_authentication_challenge_copy_http_message";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_20:
    if (v6)
      free(v6);
    goto LABEL_22;
  }
  v3 = (const void *)*((_QWORD *)v1 + 2);
  if (!v3)
  {
LABEL_22:
    v4 = 0;
    goto LABEL_23;
  }
  v4 = CFRetain(v3);
LABEL_23:

  return v4;
}

void sub_1836C02BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_authentication_challenge_set_protection_space(void *a1, void *a2)
{
  uint64_t *v3;
  id v4;
  _BOOL8 v5;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    v5 = nw_array_create();
    v6 = (void *)v3[3];
    v3[3] = v5;

    v3[4] = 0;
    nw_array_append(v3[3], v4);
    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_authentication_challenge_set_protection_space";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_authentication_challenge_set_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null challenge", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_authentication_challenge_set_protection_space";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_authentication_challenge_set_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_authentication_challenge_set_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

}

uint64_t nw_authentication_challenge_copy_protection_space(void *a1)
{
  id v1;
  unint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (unint64_t *)v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 3);
    if (v3)
    {
      nw_array_get_object_at_index(v3, v2[4]);
      v4 = objc_claimAutoreleasedReturnValue();
      goto LABEL_4;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_authentication_challenge_copy_protection_space";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_authentication_challenge_copy_protection_space";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null challenge->protection_space_array", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v19)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_authentication_challenge_copy_protection_space";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null challenge->protection_space_array, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_authentication_challenge_copy_protection_space";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null challenge->protection_space_array, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_authentication_challenge_copy_protection_space";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null challenge->protection_space_array, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_authentication_challenge_copy_protection_space";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_authentication_challenge_copy_protection_space";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null challenge", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v19)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_authentication_challenge_copy_protection_space";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_authentication_challenge_copy_protection_space";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_authentication_challenge_copy_protection_space";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_4:

  return v4;
}

void nw_authentication_challenge_set_attempt_count(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 10) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_challenge_set_attempt_count";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_attempt_count";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_challenge_set_attempt_count";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_attempt_count";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_attempt_count";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_authentication_challenge_get_attempt_count(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[10];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_challenge_get_attempt_count";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_get_attempt_count";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_challenge_get_attempt_count";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_get_attempt_count";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_get_attempt_count";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_authentication_challenge_set_proposed_credential(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 1, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_challenge_set_proposed_credential";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_proposed_credential";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_challenge_set_proposed_credential";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_proposed_credential";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_proposed_credential";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

id nw_authentication_challenge_get_proposed_credential(void *a1)
{
  id *v1;
  id *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[1];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_challenge_get_proposed_credential";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_get_proposed_credential";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_challenge_get_proposed_credential";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_get_proposed_credential";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_get_proposed_credential";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_authentication_challenge_set_protection_space_array(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 3, a2);
    v3[4] = 0;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_challenge_set_protection_space_array";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_protection_space_array";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null challenge", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_challenge_set_protection_space_array";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_protection_space_array";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_challenge_set_protection_space_array";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

BOOL nw_authentication_challenge_try_next_protection_space(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  void *v5;
  _BOOL8 v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_authentication_challenge_try_next_protection_space";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null challenge", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v18, "%{public}s called with null challenge, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null challenge, no backtrace", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_authentication_challenge_try_next_protection_space";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null challenge, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_26;
  }
  v3 = v1[3];
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_authentication_challenge_try_next_protection_space";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null challenge->protection_space_array", buf, 0xCu);
      }
LABEL_38:

LABEL_39:
      if (v8)
        free(v8);
      goto LABEL_41;
    }
    if (!v21)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null challenge->protection_space_array, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_authentication_challenge_try_next_protection_space";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null challenge->protection_space_array, no backtrace", buf, 0xCu);
      }
      goto LABEL_38;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v24 = "nw_authentication_challenge_try_next_protection_space";
      v25 = 2082;
      v26 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null challenge->protection_space_array, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_26:

    free(backtrace_string);
    goto LABEL_39;
  }
  v4 = v2[4] + 1;
  if (v4 >= (uint64_t)(*(_QWORD *)(v3 + 24) - *(_QWORD *)(v3 + 16)) >> 3)
  {
LABEL_41:
    v6 = 0;
    goto LABEL_42;
  }
  nw_array_get_object_at_index(v3, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5 != 0;
  if (v5)
    ++v2[4];

LABEL_42:
  return v6;
}

_DWORD *nw_authentication_credential_create(int a1)
{
  return -[NWConcrete_nw_authentication_credential initWithType:]([NWConcrete_nw_authentication_credential alloc], a1);
}

void nw_authentication_credential_set_persistence(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 3) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_credential_set_persistence";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_set_persistence";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_credential_set_persistence";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_set_persistence";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_set_persistence";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_authentication_credential_set_username(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  NSObject *v11;
  void *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_authentication_credential_set_username";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_authentication_credential_set_username";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null credential", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_authentication_credential_set_username";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_authentication_credential_set_username";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null credential, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_authentication_credential_set_username";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v8)
      free(v8);
    goto LABEL_7;
  }
  v5 = (void *)v3[2];
  if (v5)
  {
    free(v5);
    v4[2] = 0;
  }
  if (!a2)
    goto LABEL_7;
  v6 = strdup(a2);
  if (v6)
  {
LABEL_6:
    v4[2] = v6;
LABEL_7:

    return;
  }
  __nwlog_obj();
  v11 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v20 = "strict_strdup";
  v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    goto LABEL_6;
  }
  __break(1u);
}

void nw_authentication_credential_set_password(void *a1, const char *a2)
{
  id v3;
  void *v4;
  id v5;
  _QWORD *v6;
  void *v7;
  size_t v8;
  void *v9;
  char *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  NSObject *v15;
  void *v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_authentication_credential_set_password";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v12, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_authentication_credential_set_password";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null credential", buf, 0xCu);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        v19 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            v24 = "nw_authentication_credential_set_password";
            v25 = 2082;
            v26 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_authentication_credential_set_password";
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null credential, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v24 = "nw_authentication_credential_set_password";
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v12)
      free(v12);
    goto LABEL_8;
  }
  v5 = v3;
  v6 = v5;
  v7 = (void *)*((_QWORD *)v5 + 3);
  if (v7)
  {
    v8 = strlen(*((const char **)v5 + 3));
    bzero(v7, v8);
    v9 = (void *)v6[3];
    if (v9)
    {
      free(v9);
      v6[3] = 0;
    }
  }

  if (!a2)
    goto LABEL_8;
  v10 = strdup(a2);
  if (v10)
  {
LABEL_7:
    v6[3] = v10;
LABEL_8:

    return;
  }
  __nwlog_obj();
  v15 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v24 = "strict_strdup";
  v16 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v16))
  {
    free(v16);
    goto LABEL_7;
  }
  __break(1u);
}

void nw_authentication_credential_add_valid_authentication_type(void *a1, unsigned int a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  xpc_object_t v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v5 = (void *)v3[5];
    if (!v5)
    {
      v6 = xpc_array_create(0, 0);
      v7 = (void *)v4[5];
      v4[5] = v6;

      v5 = (void *)v4[5];
    }
    xpc_array_set_uint64(v5, 0xFFFFFFFFFFFFFFFFLL, a2);
    goto LABEL_5;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_authentication_credential_add_valid_authentication_type";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_authentication_credential_add_valid_authentication_type";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null credential", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_authentication_credential_add_valid_authentication_type";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_authentication_credential_add_valid_authentication_type";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_authentication_credential_add_valid_authentication_type";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v9)
    free(v9);
LABEL_5:

}

void sub_1836C2AE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_authentication_credential_add_to_tlv_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))++ = xpc_uint64_get_value(v4);

  return 1;
}

void sub_1836C2B48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_authentication_credential_is_equal(void *a1, void *a2)
{
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  _BOOL8 v6;
  int v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  void *v16;

  v3 = a1;
  v4 = a2;
  v5 = (_QWORD *)v4;
  if (!(v3 | v4))
  {
    v6 = 1;
    goto LABEL_29;
  }
  v6 = 0;
  if (v3 && v4)
  {
    v7 = *(_DWORD *)(v3 + 8);
    if (v7 != *(_DWORD *)(v4 + 8) || *(_DWORD *)(v3 + 12) != *(_DWORD *)(v4 + 12))
      goto LABEL_28;
    if (v7 == 1)
    {
      v8 = *(const char **)(v3 + 16);
      v9 = (const char *)v5[2];
      if (v8 != v9 && v8 && v9)
      {
        if (strcmp(v8, v9))
          goto LABEL_28;
      }
      else if (v8 != v9)
      {
        goto LABEL_28;
      }
      v10 = *(const char **)(v3 + 24);
      v11 = (const char *)v5[3];
      if (v10 != v11 && v10 && v11)
      {
        if (strcmp(v10, v11))
          goto LABEL_28;
      }
      else if (v10 != v11)
      {
        goto LABEL_28;
      }
    }
    v12 = v5[4];
    if (*(_QWORD *)(v3 + 32))
    {
      if (v12)
        goto LABEL_22;
    }
    else if (!v12)
    {
LABEL_22:
      v13 = (void *)v5[5];
      v14 = *(id *)(v3 + 40);
      v15 = v13;
      v16 = v15;
      v6 = v14 == v15;
      if (v14 != v15 && v14 && v15)
        v6 = xpc_equal(v14, v15);

      goto LABEL_29;
    }
LABEL_28:
    v6 = 0;
  }
LABEL_29:

  return v6;
}

void sub_1836C2C9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void nw_authentication_credential_iterate_valid_authentication_types(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD applier[4];
  id v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_authentication_credential_iterate_valid_authentication_types";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v8, &type, &v23))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_authentication_credential_iterate_valid_authentication_types";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null credential", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_authentication_credential_iterate_valid_authentication_types";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v8)
          goto LABEL_5;
LABEL_40:
        free(v8);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_authentication_credential_iterate_valid_authentication_types";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_authentication_credential_iterate_valid_authentication_types";
        _os_log_impl(&dword_182FBE000, v9, v19, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v4)
  {
    v6 = (void *)v3[5];
    if (v6)
    {
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = __nw_authentication_credential_iterate_valid_authentication_types_block_invoke;
      applier[3] = &unk_1E14A4E60;
      v22 = v4;
      xpc_array_apply(v6, applier);

    }
    goto LABEL_5;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_authentication_credential_iterate_valid_authentication_types";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (!__nwlog_fault(v8, &type, &v23))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v12 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_authentication_credential_iterate_valid_authentication_types";
      _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null iterator", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v23)
  {
    __nwlog_obj();
    v9 = objc_claimAutoreleasedReturnValue();
    v20 = type;
    if (os_log_type_enabled(v9, type))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_authentication_credential_iterate_valid_authentication_types";
      _os_log_impl(&dword_182FBE000, v9, v20, "%{public}s called with null iterator, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v9 = objc_claimAutoreleasedReturnValue();
  v17 = type;
  v18 = os_log_type_enabled(v9, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v26 = "nw_authentication_credential_iterate_valid_authentication_types";
      _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null iterator, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v26 = "nw_authentication_credential_iterate_valid_authentication_types";
    v27 = 2082;
    v28 = v16;
    _os_log_impl(&dword_182FBE000, v9, v17, "%{public}s called with null iterator, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8)
    goto LABEL_40;
LABEL_5:

}

void sub_1836C31B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_authentication_credential_iterate_valid_authentication_types_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;

  v4 = a3;
  xpc_uint64_get_value(v4);
  v5 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

  return v5;
}

void sub_1836C3218(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_authentication_credential_get_username(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_credential_get_username";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_get_username";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_credential_get_username";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_get_username";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_get_username";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_authentication_credential_get_password(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 3);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_credential_get_password";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_get_password";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_credential_get_password";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_get_password";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_get_password";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_authentication_credential_set_identity(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 4, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_authentication_credential_set_identity";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_set_identity";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null credential", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_authentication_credential_set_identity";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_set_identity";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null credential, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_authentication_credential_set_identity";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null credential, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t __nw_proxy_options_authbroker_is_available_block_invoke()
{
  uint64_t result;
  BOOL v1;
  mach_port_t sp;

  sp = 0;
  result = bootstrap_look_up(*MEMORY[0x1E0C81720], "com.apple.cfnetwork.AuthBrokerAgent", &sp);
  if ((_DWORD)result)
    v1 = 1;
  else
    v1 = sp == 0;
  if (!v1)
  {
    nw_proxy_options_authbroker_is_available::available = 1;
    return mach_port_deallocate(*MEMORY[0x1E0C83DA0], sp);
  }
  return result;
}

BOOL nw_proxy_allocate_options(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 result;
  NSObject *v4;
  void *v5;

  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (v2)
    goto LABEL_2;
  __nwlog_obj();
  v4 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  v5 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_1836C3B88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_proxy_copy_options(void *a1, uint64_t a2)
{
  id v3;
  void **v4;
  void *v5;
  void *v6;
  const char *v7;
  char *v8;
  _BOOL8 result;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_proxy_copy_options";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (__nwlog_fault(v11, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_proxy_copy_options";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        v20 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v25 = "nw_proxy_copy_options";
            v26 = 2082;
            v27 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_proxy_copy_options";
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v25 = "nw_proxy_copy_options";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v11)
      free(v11);
    v4 = 0;
    goto LABEL_6;
  }
  v4 = (void **)malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (!v4)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v25 = "strict_calloc";
    v26 = 2048;
    v27 = 1;
    v28 = 2048;
    v29 = 16;
    v15 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v15);
    if (result)
      goto LABEL_30;
    free(v15);
  }
  v5 = _Block_copy(*(const void **)a2);
  v6 = *v4;
  *v4 = v5;

  v7 = *(const char **)(a2 + 8);
  if (!v7)
  {
LABEL_6:

    return (BOOL)v4;
  }
  v8 = strdup(v7);
  if (v8)
  {
LABEL_5:
    v4[1] = v8;
    goto LABEL_6;
  }
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v25 = "strict_strdup";
  v17 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_5;
  }
LABEL_30:
  __break(1u);
  return result;
}

void sub_1836C3FB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_proxy_deallocate_options(uint64_t a1, void **a2)
{
  void *v3;
  void *v4;

  v3 = *a2;
  *a2 = 0;

  v4 = a2[1];
  if (v4)
    free(v4);
  free(a2);
}

BOOL nw_proxy_option_is_equal(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

void *nw_proxy_options_copy_authentication_challenge_handler(void *a1)
{
  id v1;
  void *v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void *(*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t);
  id v10;

  v1 = a1;
  v5 = 0;
  v6 = &v5;
  v7 = 0x3032000000;
  v8 = __Block_byref_object_copy__35271;
  v9 = __Block_byref_object_dispose__35272;
  v10 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __nw_proxy_options_copy_authentication_challenge_handler_block_invoke;
  v4[3] = &unk_1E14A9D68;
  v4[4] = &v5;
  nw_protocol_options_access_handle(v1, v4);
  v2 = _Block_copy((const void *)v6[5]);
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1836C40D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  void *v20;

  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__35271(uint64_t a1, uint64_t a2)
{
  void *result;

  result = _Block_copy(*(const void **)(a2 + 40));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__35272(uint64_t a1)
{

}

uint64_t __nw_proxy_options_copy_authentication_challenge_handler_block_invoke(uint64_t a1, const void **a2)
{
  void *v3;
  uint64_t v4;
  void *v5;

  v3 = _Block_copy(*a2);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  return 1;
}

void nw_proxy_options_set_http_proxy_authorization_header(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[5];
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_proxy_options_set_http_proxy_authorization_header_block_invoke;
    v13[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v13[4] = a2;
    nw_protocol_options_access_handle(v3, v13);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_proxy_options_set_http_proxy_authorization_header";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v6, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_proxy_options_set_http_proxy_authorization_header";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_proxy_options_set_http_proxy_authorization_header";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_proxy_options_set_http_proxy_authorization_header";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_proxy_options_set_http_proxy_authorization_header";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1836C4424(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL __nw_proxy_options_set_http_proxy_authorization_header_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  const char *v5;
  char *v6;
  _BOOL8 result;
  NSObject *v8;
  void *v9;

  v4 = *(void **)(a2 + 8);
  if (v4)
  {
    free(v4);
    *(_QWORD *)(a2 + 8) = 0;
  }
  v5 = *(const char **)(a1 + 32);
  if (!v5)
    return 1;
  v6 = strdup(v5);
  if (v6)
  {
LABEL_5:
    *(_QWORD *)(a2 + 8) = v6;
    return 1;
  }
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  v9 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v9);
  if (!result)
  {
    free(v9);
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

uint64_t __nw_proxy_options_get_http_proxy_authorization_header_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 8);
  return 1;
}

void *nw_proxy_copy_shoes_definition()
{
  void *result;

  if (nw_protocol_shoes_get_definition(void)::onceToken != -1)
    dispatch_once(&nw_protocol_shoes_get_definition(void)::onceToken, &__block_literal_global_30);
  result = (void *)nw_protocol_shoes_get_definition(void)::proxy_definition;
  if (nw_protocol_shoes_get_definition(void)::proxy_definition)
    return os_retain((void *)nw_protocol_shoes_get_definition(void)::proxy_definition);
  return result;
}

_QWORD *nw_protocol_http_connect_create()
{
  _QWORD *v0;
  _QWORD *result;
  NSObject *v2;
  NSObject *v3;
  void *v4;
  uint8_t buf[4];
  const char *v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v2 = __nwlog_obj();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v6 = "nw_protocol_http_connect_create";
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  v0 = malloc_type_calloc(1uLL, 0x178uLL, 0xEAFB8F1AuLL);
  if (v0)
    goto LABEL_3;
  v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v6 = "strict_calloc";
  v7 = 2048;
  v8 = 1;
  v9 = 2048;
  v10 = 376;
  v4 = (void *)_os_log_send_and_compose_impl();
  result = (_QWORD *)__nwlog_abort((uint64_t)v4);
  if (!(_DWORD)result)
  {
    free(v4);
LABEL_3:
    v0[5] = &g_http_connect_protocol_identifier;
    v0[6] = &g_http_connect_protocol_callbacks;
    v0[8] = v0;
    return v0 + 3;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_http_connect_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_parameters)(nw_protocol *);
  uint64_t *v7;
  uint64_t *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  nw_protocol_callbacks *v20;
  uint64_t (*get_path)(nw_protocol *);
  void *v22;
  void *v23;
  void *v24;
  id v25;
  int v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  const char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *v35;
  _BOOL4 v36;
  char *v37;
  _BOOL4 v38;
  const char *v39;
  _BOOL4 v40;
  void *v41;
  void *v42;
  id *v43;
  _QWORD *v44;
  id v45;
  _BOOL4 v46;
  id *v47;
  id *v48;
  _BOOL4 v49;
  void *v50;
  char *v51;
  _BOOL4 v52;
  void *v53;
  NSObject *v54;
  const char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  id v59;
  uint64_t *v60;
  id v61;
  void *v62;
  unsigned __int8 *v63;
  void *v64;
  char *v65;
  _BOOL4 v66;
  id v67;
  id *v68;
  id v69;
  _DWORD *v70;
  void *v71;
  int v72;
  __int16 v73;
  id *v74;
  id v75;
  const char *username;
  const char *password;
  const char *v78;
  void *v79;
  _DWORD *v80;
  NSObject *v81;
  id *v82;
  id v83;
  char *v84;
  char *v86;
  _BOOL4 v87;
  NSObject *v88;
  char *v89;
  NSObject *v90;
  os_log_type_t v91;
  const char *v92;
  char *backtrace_string;
  _BOOL4 v94;
  const char *v95;
  _BOOL4 v96;
  void *v97;
  char *v98;
  NSObject *v99;
  os_log_type_t v100;
  char *v101;
  os_log_type_t v102;
  _BOOL4 v103;
  os_log_type_t v104;
  os_log_type_t type[8];
  uint64_t v106;
  BOOL (*v107)(uint64_t, uint64_t, void *);
  void *v108;
  id v109;
  _BYTE *v110;
  char v111;
  _BYTE buf[24];
  uint64_t (*v113)(uint64_t, uint64_t);
  __int128 v114;
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v88 = __nwlog_obj();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
      _os_log_impl(&dword_182FBE000, v88, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
    v89 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v111 = 0;
    if (!__nwlog_fault(v89, type, &v111))
      goto LABEL_207;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v111)
      {
        v90 = __nwlog_obj();
        v91 = type[0];
        if (!os_log_type_enabled(v90, type[0]))
          goto LABEL_207;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
        v92 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_206;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v90 = __nwlog_obj();
      v91 = type[0];
      v94 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (!v94)
          goto LABEL_207;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
        v92 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_206;
      }
      if (v94)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v95 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_196:
        _os_log_impl(&dword_182FBE000, v90, v91, v95, buf, 0x16u);
      }
LABEL_197:
      free(backtrace_string);
      goto LABEL_207;
    }
    v90 = __nwlog_obj();
    v91 = type[0];
    if (!os_log_type_enabled(v90, type[0]))
      goto LABEL_207;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
    v92 = "%{public}s called with null protocol";
LABEL_206:
    _os_log_impl(&dword_182FBE000, v90, v91, v92, buf, 0xCu);
LABEL_207:
    if (v89)
      free(v89);
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
    v89 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v111 = 0;
    if (!__nwlog_fault(v89, type, &v111))
      goto LABEL_207;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v90 = __nwlog_obj();
      v91 = type[0];
      if (!os_log_type_enabled(v90, type[0]))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
      v92 = "%{public}s called with null http_connect";
      goto LABEL_206;
    }
    if (!v111)
    {
      v90 = __nwlog_obj();
      v91 = type[0];
      if (!os_log_type_enabled(v90, type[0]))
        goto LABEL_207;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
      v92 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_206;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v90 = __nwlog_obj();
    v91 = type[0];
    v96 = os_log_type_enabled(v90, type[0]);
    if (backtrace_string)
    {
      if (v96)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v95 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_196;
      }
      goto LABEL_197;
    }
    if (!v96)
      goto LABEL_207;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
    v92 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_206;
  }
  if (a2)
  {
    callbacks = a2->callbacks;
    if (callbacks)
    {
      get_parameters = (uint64_t (*)(nw_protocol *))callbacks->get_parameters;
      if (get_parameters)
      {
        v7 = (uint64_t *)get_parameters(a2);
        if (v7)
        {
          v8 = v7;
          v9 = nw_parameters_copy_protocol_options_legacy(v7, a1);
          v10 = v9;
          if (v9)
          {
            v11 = v9;
            v12 = v11;
            handle[284] = 0;
            v13 = 84;
            v14 = 284;
            while (1)
            {
              v15 = v11[v14 - 236];
              handle[v14] = v15;
              if (!v15)
                break;
              --v13;
              ++v14;
              if (v13 <= 1)
              {
                handle[v14] = 0;
                break;
              }
            }
            v16 = v11[48];

            if (!v16)
            {
              v17 = v12;
              v18 = *((unsigned __int16 *)v17 + 68);

              if ((_DWORD)v18)
                snprintf(handle + 284, 0x54uLL, "C%llu", v18);
            }
          }
          if (!handle[284])
            snprintf(handle + 284, 0x54uLL, "http_connect[%llu]", ++nw_protocol_http_connect_add_input_handler(nw_protocol *,nw_protocol *)::http_connect_count);
          if (nw_path_parameters_get_logging_disabled(v8[13]))
            v19 = 128;
          else
            v19 = 0;
          *((_WORD *)handle + 184) = *((_WORD *)handle + 184) & 0xFF7F | v19;
          v20 = a2->callbacks;
          if (v20)
          {
            get_path = (uint64_t (*)(nw_protocol *))v20->get_path;
            if (get_path)
            {
              v22 = (void *)get_path(a2);
              if (v22)
              {
                *((_WORD *)handle + 184) = *((_WORD *)handle + 184) & 0xFFFE | nw_path_get_nexus_agent_uuid(v22, (_OWORD *)handle + 15);
                v23 = (void *)((uint64_t (*)(nw_protocol *))a2->callbacks->get_remote_endpoint)(a2);
                if (v23)
                {
                  v24 = os_retain(v23);
                  *((_QWORD *)handle + 17) = v24;
                  if (v24)
                  {
                    v25 = v24;
                    v26 = objc_msgSend(v25, "type");

                    if ((v26 - 3) <= 0xFFFFFFFD)
                    {
                      if ((*((_WORD *)handle + 184) & 0x80) == 0)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = handle + 284;
                        *(_WORD *)&buf[22] = 2080;
                        v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                        v27 = (char *)_os_log_send_and_compose_impl();
                        type[0] = OS_LOG_TYPE_ERROR;
                        v111 = 0;
                        if (!__nwlog_fault(v27, type, &v111))
                          goto LABEL_157;
                        if (type[0] == OS_LOG_TYPE_FAULT)
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          v28 = gLogObj;
                          v29 = type[0];
                          if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                            goto LABEL_157;
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          v30 = "%{public}s %{public}s%sRemote endpoint is wrong type";
                          goto LABEL_156;
                        }
                        if (!v111)
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          v28 = gLogObj;
                          v29 = type[0];
                          if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                            goto LABEL_157;
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          v30 = "%{public}s %{public}s%sRemote endpoint is wrong type, backtrace limit exceeded";
                          goto LABEL_156;
                        }
                        v37 = (char *)__nw_create_backtrace_string();
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v28 = gLogObj;
                        v29 = type[0];
                        v52 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
                        if (!v37)
                        {
                          if (!v52)
                            goto LABEL_157;
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          v30 = "%{public}s %{public}s%sRemote endpoint is wrong type, no backtrace";
LABEL_156:
                          _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0x20u);
LABEL_157:
                          if (v27)
                            free(v27);
                          goto LABEL_159;
                        }
                        if (v52)
                        {
                          *(_DWORD *)buf = 136446978;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          LOWORD(v114) = 2082;
                          *(_QWORD *)((char *)&v114 + 2) = v37;
                          v39 = "%{public}s %{public}s%sRemote endpoint is wrong type, dumping backtrace:%{public}s";
                          goto LABEL_89;
                        }
LABEL_90:
                        free(v37);
                        goto LABEL_157;
                      }
LABEL_159:
                      nw_http_connect_destroy((uint64_t)handle);
                      if (v10)
                        os_release(v10);
                      return 0;
                    }
                    v41 = (void *)*((_QWORD *)handle + 20);
                    if (v41)
                    {
                      os_release(v41);
                      *((_QWORD *)handle + 20) = 0;
                    }
                    v42 = (void *)*((_QWORD *)handle + 19);
                    if (v42)
                    {
                      os_release(v42);
                      *((_QWORD *)handle + 19) = 0;
                    }
                    if (!v10)
                    {
                      v46 = 0;
                      *((_QWORD *)handle + 19) = nw_endpoint_copy_without_proxy_parent(*((void **)handle + 17));
                      goto LABEL_101;
                    }
                    v43 = v10;
                    v44 = v43 + 3;
                    v45 = v43[3];

                    *((_QWORD *)handle + 20) = v45;
                    v46 = v45 != 0;
                    v47 = v43;
                    v48 = v47;
                    if (*v44)
                    {
                      v49 = *((_BYTE *)v47 + 152) == 0;

                      if (!v49)
                      {
                        v50 = (void *)*((_QWORD *)handle + 20);
                        if (v50)
                          v50 = os_retain(v50);
                        *((_QWORD *)handle + 19) = v50;
                        goto LABEL_98;
                      }
                    }
                    else
                    {

                    }
                    v50 = (void *)*((_QWORD *)handle + 19);
LABEL_98:
                    if (!v50)
                      *((_QWORD *)handle + 19) = nw_endpoint_copy_without_proxy_parent(*((void **)handle + 17));
                    os_release(v48);
LABEL_101:
                    v53 = (void *)*((_QWORD *)handle + 18);
                    if (v53)
                    {
                      os_release(v53);
                      *((_QWORD *)handle + 18) = 0;
                    }
                    v54 = nw_endpoint_copy_proxy_original_endpoint(*((void **)handle + 17));
                    *((_QWORD *)handle + 18) = v54;
                    if (!v54)
                    {
                      if (!v46)
                      {
                        if ((*((_WORD *)handle + 184) & 0x80) != 0)
                          goto LABEL_82;
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = handle + 284;
                        *(_WORD *)&buf[22] = 2080;
                        v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                        v55 = (const char *)_os_log_send_and_compose_impl();
                        type[0] = OS_LOG_TYPE_ERROR;
                        v111 = 0;
                        if (!__nwlog_fault(v55, type, &v111))
                          goto LABEL_176;
                        if (type[0] == OS_LOG_TYPE_FAULT)
                        {
                          v56 = __nwlog_obj();
                          v57 = type[0];
                          if (!os_log_type_enabled(v56, type[0]))
                            goto LABEL_176;
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          v58 = "%{public}s %{public}s%sNo proxy original endpoint";
                          goto LABEL_175;
                        }
                        if (!v111)
                        {
                          v56 = __nwlog_obj();
                          v57 = type[0];
                          if (!os_log_type_enabled(v56, type[0]))
                            goto LABEL_176;
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          v58 = "%{public}s %{public}s%sNo proxy original endpoint, backtrace limit exceeded";
                          goto LABEL_175;
                        }
                        v86 = (char *)__nw_create_backtrace_string();
                        v56 = __nwlog_obj();
                        v57 = type[0];
                        v87 = os_log_type_enabled(v56, type[0]);
                        if (!v86)
                        {
                          if (!v87)
                            goto LABEL_176;
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          v58 = "%{public}s %{public}s%sNo proxy original endpoint, no backtrace";
                          goto LABEL_175;
                        }
                        if (v87)
                        {
                          *(_DWORD *)buf = 136446978;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          LOWORD(v114) = 2082;
                          *(_QWORD *)((char *)&v114 + 2) = v86;
                          _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s %{public}s%sNo proxy original endpoint, dumping backtrace:%{public}s", buf, 0x2Au);
                        }
                        free(v86);
                        goto LABEL_176;
                      }
                      v54 = *((_QWORD *)handle + 17);
                      if (v54)
                        v54 = os_retain(v54);
                      *((_QWORD *)handle + 18) = v54;
                    }
                    if (nw_endpoint_get_type(v54) - 3 <= 0xFFFFFFFD)
                    {
                      if ((*((_WORD *)handle + 184) & 0x80) != 0)
                        goto LABEL_82;
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      *(_DWORD *)buf = 136446722;
                      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = handle + 284;
                      *(_WORD *)&buf[22] = 2080;
                      v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                      v55 = (const char *)_os_log_send_and_compose_impl();
                      type[0] = OS_LOG_TYPE_ERROR;
                      v111 = 0;
                      if (!__nwlog_fault(v55, type, &v111))
                        goto LABEL_176;
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v56 = gLogObj;
                        v57 = type[0];
                        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                          goto LABEL_176;
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = handle + 284;
                        *(_WORD *)&buf[22] = 2080;
                        v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                        v58 = "%{public}s %{public}s%sProxy original endpoint is wrong type";
                        goto LABEL_175;
                      }
                      if (!v111)
                      {
                        v56 = __nwlog_obj();
                        v57 = type[0];
                        if (!os_log_type_enabled(v56, type[0]))
                          goto LABEL_176;
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = handle + 284;
                        *(_WORD *)&buf[22] = 2080;
                        v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                        v58 = "%{public}s %{public}s%sProxy original endpoint is wrong type, backtrace limit exceeded";
                        goto LABEL_175;
                      }
                      v65 = (char *)__nw_create_backtrace_string();
                      v56 = __nwlog_obj();
                      v57 = type[0];
                      v66 = os_log_type_enabled(v56, type[0]);
                      if (v65)
                      {
                        if (v66)
                        {
                          *(_DWORD *)buf = 136446978;
                          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = handle + 284;
                          *(_WORD *)&buf[22] = 2080;
                          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                          LOWORD(v114) = 2082;
                          *(_QWORD *)((char *)&v114 + 2) = v65;
                          _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s %{public}s%sProxy original endpoint is wrong type, dumping backtrace:%{public}s", buf, 0x2Au);
                        }
                        free(v65);
                        if (!v55)
                          goto LABEL_82;
LABEL_177:
                        v51 = (char *)v55;
                        goto LABEL_81;
                      }
                      if (v66)
                      {
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = handle + 284;
                        *(_WORD *)&buf[22] = 2080;
                        v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                        v58 = "%{public}s %{public}s%sProxy original endpoint is wrong type, no backtrace";
LABEL_175:
                        _os_log_impl(&dword_182FBE000, v56, v57, v58, buf, 0x20u);
                      }
LABEL_176:
                      if (!v55)
                        goto LABEL_82;
                      goto LABEL_177;
                    }
                    nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
                    if (!a2->output_handler)
                      nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)(handle + 24));
                    *(_OWORD *)(handle + 24) = *(_OWORD *)a2->flow_id;
                    if (nw_proxy_copy_http_connect_definition::onceToken != -1)
                      dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_92);
                    v59 = (id)nw_proxy_copy_http_connect_definition::proxy_definition;
                    v60 = v8;
                    v61 = v59;
                    v62 = v61;
                    if (v61)
                    {
                      *(_QWORD *)buf = 0;
                      *(_QWORD *)&buf[8] = buf;
                      *(_QWORD *)&buf[16] = 0x3032000000;
                      v113 = __Block_byref_object_copy__19149;
                      *(_QWORD *)&v114 = __Block_byref_object_dispose__19150;
                      *((_QWORD *)&v114 + 1) = 0;
                      v63 = (unsigned __int8 *)v60[21];
                      if (v63)
                      {
                        *(_QWORD *)type = MEMORY[0x1E0C809B0];
                        v106 = 3221225472;
                        v107 = __nw_parameters_copy_proxy_options_block_invoke;
                        v108 = &unk_1E14AB5F0;
                        v109 = v61;
                        v110 = buf;
                        nw_array_apply(v63, (uint64_t)type);

                        v64 = *(void **)(*(_QWORD *)&buf[8] + 40);
                      }
                      else
                      {
                        v64 = 0;
                      }
                      v67 = v64;
                      _Block_object_dispose(buf, 8);

                      goto LABEL_136;
                    }
                    __nwlog_obj();
                    v97 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = "nw_parameters_copy_proxy_options";
                    v98 = (char *)_os_log_send_and_compose_impl();

                    type[0] = OS_LOG_TYPE_ERROR;
                    v111 = 0;
                    if (__nwlog_fault(v98, type, &v111))
                    {
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        __nwlog_obj();
                        v99 = objc_claimAutoreleasedReturnValue();
                        v100 = type[0];
                        if (os_log_type_enabled(v99, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(_QWORD *)&buf[4] = "nw_parameters_copy_proxy_options";
                          _os_log_impl(&dword_182FBE000, v99, v100, "%{public}s called with null proxy_protocol", buf, 0xCu);
                        }
                      }
                      else if (v111)
                      {
                        v101 = (char *)__nw_create_backtrace_string();
                        __nwlog_obj();
                        v99 = objc_claimAutoreleasedReturnValue();
                        v102 = type[0];
                        v103 = os_log_type_enabled(v99, type[0]);
                        if (v101)
                        {
                          if (v103)
                          {
                            *(_DWORD *)buf = 136446466;
                            *(_QWORD *)&buf[4] = "nw_parameters_copy_proxy_options";
                            *(_WORD *)&buf[12] = 2082;
                            *(_QWORD *)&buf[14] = v101;
                            _os_log_impl(&dword_182FBE000, v99, v102, "%{public}s called with null proxy_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                          }

                          free(v101);
                          goto LABEL_225;
                        }
                        if (v103)
                        {
                          *(_DWORD *)buf = 136446210;
                          *(_QWORD *)&buf[4] = "nw_parameters_copy_proxy_options";
                          _os_log_impl(&dword_182FBE000, v99, v102, "%{public}s called with null proxy_protocol, no backtrace", buf, 0xCu);
                        }
                      }
                      else
                      {
                        __nwlog_obj();
                        v99 = objc_claimAutoreleasedReturnValue();
                        v104 = type[0];
                        if (os_log_type_enabled(v99, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          *(_QWORD *)&buf[4] = "nw_parameters_copy_proxy_options";
                          _os_log_impl(&dword_182FBE000, v99, v104, "%{public}s called with null proxy_protocol, backtrace limit exceeded", buf, 0xCu);
                        }
                      }

                    }
LABEL_225:
                    if (v98)
                      free(v98);
                    v67 = 0;
LABEL_136:

                    *((_QWORD *)handle + 23) = v67;
                    v68 = v60;
                    v69 = v68[23];

                    if (!v69)
                    {
LABEL_153:
                      v82 = v68;
                      v83 = *(id *)(v8[13] + 136);

                      *((_QWORD *)handle + 28) = 0;
                      v84 = handle + 224;
                      *((_QWORD *)v84 - 7) = v83;
                      *((_DWORD *)v84 + 14) = 0;
                      *((_QWORD *)v84 + 1) = v84;
                      return 1;
                    }
                    v70 = v69;
                    v71 = v70;
                    if (v70[38] == 1)
                    {
                      v72 = v70[39];

                      v73 = (v72 == 4002) << 8;
                    }
                    else
                    {

                      v73 = 0;
                    }
                    *((_WORD *)handle + 184) = *((_WORD *)handle + 184) & 0xFEFF | v73;
                    v74 = v71;
                    v75 = v74[13];

                    if (v75
                      && (username = (const char *)nw_authentication_credential_get_username(v75),
                          (password = (const char *)nw_authentication_credential_get_password(v75)) != 0))
                    {
                      if (username)
                      {
                        if (*username)
                        {
                          v78 = password;
                          if (*password)
                          {
                            v79 = (void *)*((_QWORD *)handle + 22);
                            if (v79)
                            {
                              os_release(v79);
                              *((_QWORD *)handle + 22) = 0;
                            }
                            v80 = nw_authentication_credential_create(1);
                            *((_QWORD *)handle + 22) = v80;
                            *((_DWORD *)handle + 68) = 0;
                            nw_authentication_credential_set_username(v80, username);
                            nw_authentication_credential_set_password(*((void **)handle + 22), v78);
                          }
                        }
                      }
                    }
                    else
                    {
                      v81 = nw_proxy_config_copy_endpoint(v74);
                      nw_endpoint_get_hostname(v81);
                      if (v81)
                        os_release(v81);
                      if (!v75)
                        goto LABEL_152;
                    }
                    os_release(v75);
LABEL_152:
                    os_release(v74);
                    goto LABEL_153;
                  }
                }
                else
                {
                  *((_QWORD *)handle + 17) = 0;
                }
                if ((*((_WORD *)handle + 184) & 0x80) != 0)
                  goto LABEL_159;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                v27 = (char *)_os_log_send_and_compose_impl();
                type[0] = OS_LOG_TYPE_ERROR;
                v111 = 0;
                if (!__nwlog_fault(v27, type, &v111))
                  goto LABEL_157;
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v28 = gLogObj;
                  v29 = type[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                    goto LABEL_157;
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = handle + 284;
                  *(_WORD *)&buf[22] = 2080;
                  v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  v30 = "%{public}s %{public}s%sNo remote endpoint";
                  goto LABEL_156;
                }
                if (!v111)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v28 = gLogObj;
                  v29 = type[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
                    goto LABEL_157;
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = handle + 284;
                  *(_WORD *)&buf[22] = 2080;
                  v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  v30 = "%{public}s %{public}s%sNo remote endpoint, backtrace limit exceeded";
                  goto LABEL_156;
                }
                v37 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v28 = gLogObj;
                v29 = type[0];
                v38 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
                if (!v37)
                {
                  if (!v38)
                    goto LABEL_157;
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = handle + 284;
                  *(_WORD *)&buf[22] = 2080;
                  v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                  v30 = "%{public}s %{public}s%sNo remote endpoint, no backtrace";
                  goto LABEL_156;
                }
                if (!v38)
                  goto LABEL_90;
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
                LOWORD(v114) = 2082;
                *(_QWORD *)((char *)&v114 + 2) = v37;
                v39 = "%{public}s %{public}s%sNo remote endpoint, dumping backtrace:%{public}s";
LABEL_89:
                _os_log_impl(&dword_182FBE000, v28, v29, v39, buf, 0x2Au);
                goto LABEL_90;
              }
              v19 = *((_WORD *)handle + 184) & 0x80;
            }
          }
          if (v19)
            goto LABEL_159;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
          v27 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v111 = 0;
          if (!__nwlog_fault(v27, type, &v111))
            goto LABEL_157;
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v28 = gLogObj;
            v29 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
              goto LABEL_157;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
            v30 = "%{public}s %{public}s%sUnable to get path";
            goto LABEL_156;
          }
          if (!v111)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v28 = gLogObj;
            v29 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
              goto LABEL_157;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
            v30 = "%{public}s %{public}s%sUnable to get path, backtrace limit exceeded";
            goto LABEL_156;
          }
          v37 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = gLogObj;
          v29 = type[0];
          v40 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (!v37)
          {
            if (!v40)
              goto LABEL_157;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
            v30 = "%{public}s %{public}s%sUnable to get path, no backtrace";
            goto LABEL_156;
          }
          if (!v40)
            goto LABEL_90;
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v114) = 2082;
          *(_QWORD *)((char *)&v114 + 2) = v37;
          v39 = "%{public}s %{public}s%sUnable to get path, dumping backtrace:%{public}s";
          goto LABEL_89;
        }
      }
    }
  }
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
    v31 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v111 = 0;
    if (!__nwlog_fault(v31, type, &v111))
      goto LABEL_79;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = gLogObj;
      v33 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_79;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
      v34 = "%{public}s %{public}s%sUnable to get parameters";
    }
    else if (v111)
    {
      v35 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = gLogObj;
      v33 = type[0];
      v36 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
          LOWORD(v114) = 2082;
          *(_QWORD *)((char *)&v114 + 2) = v35;
          _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s %{public}s%sUnable to get parameters, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v35);
LABEL_79:
        if (v31)
        {
          v51 = (char *)v31;
LABEL_81:
          free(v51);
          goto LABEL_82;
        }
        goto LABEL_82;
      }
      if (!v36)
        goto LABEL_79;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
      v34 = "%{public}s %{public}s%sUnable to get parameters, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = gLogObj;
      v33 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_79;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_add_input_handler";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v113 = (uint64_t (*)(uint64_t, uint64_t))" ";
      v34 = "%{public}s %{public}s%sUnable to get parameters, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v32, v33, v34, buf, 0x20u);
    goto LABEL_79;
  }
LABEL_82:
  nw_http_connect_destroy((uint64_t)handle);
  return 0;
}

void sub_1836C60DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_http_connect_remove_input_handler(nw_protocol *a1, nw_protocol *a2, int a3)
{
  _QWORD *handle;
  uint64_t v8;
  uint64_t v9;
  char v10;
  NSObject *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  const char *v18;
  _BOOL4 v19;
  NSObject *v20;
  char v21;
  os_log_type_t type;
  _BYTE buf[24];
  void *v24;
  char *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v12, &type, &v21))
      goto LABEL_47;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
        v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_46;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v17 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v17)
          goto LABEL_47;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
        v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_46;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_34:
        _os_log_impl(&dword_182FBE000, v13, v14, v18, buf, 0x16u);
      }
LABEL_35:
      free(backtrace_string);
      goto LABEL_47;
    }
    v13 = __nwlog_obj();
    v14 = type;
    if (!os_log_type_enabled(v13, type))
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
    v15 = "%{public}s called with null protocol";
LABEL_46:
    _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
LABEL_47:
    if (v12)
      free(v12);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v12, &type, &v21))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
      v15 = "%{public}s called with null http_connect";
      goto LABEL_46;
    }
    if (!v21)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
      v15 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v19 = os_log_type_enabled(v13, type);
    if (backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v18 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_34;
      }
      goto LABEL_35;
    }
    if (!v19)
      goto LABEL_47;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_remove_input_handler";
    v15 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_46;
  }
  if (a2->output_handler == a1)
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  if (a1->default_input_handler != a2)
    return 0;
  if (gLogDatapath)
  {
    v20 = __nwlog_obj();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_35427;
  v24 = &__block_descriptor_tmp_15_35428;
  v25 = (char *)(handle + 28);
  v26 = 0;
  v8 = handle[28];
  do
  {
    if (!v8)
      break;
    v9 = *(_QWORD *)(v8 + 32);
    v10 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
    v8 = v9;
  }
  while ((v10 & 1) != 0);
  nw_protocol_remove_input_handler((uint64_t)a1->output_handler, (uint64_t)a1);
  nw_protocol_set_input_handler((uint64_t)a1, 0);
  if (a3)
  {
    a1->handle = 0;
    nw_http_connect_destroy((uint64_t)handle);
  }
  return 1;
}

void nw_protocol_http_connect_input_available(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*input_available)(void);
  int v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  nw_protocol *output_handler;
  int v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  _QWORD *v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  _BOOL4 v31;
  _BYTE *v32;
  __int16 v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  _BOOL4 v38;
  _BOOL4 v39;
  NSObject *v40;
  os_log_type_t v41;
  uint32_t v42;
  NSObject *v43;
  const char *v44;
  __int16 v45;
  char *v46;
  _BOOL4 v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  unsigned int v52;
  int v53;
  __CFHTTPMessage *v54;
  __int16 v55;
  CFIndex ResponseStatusCode;
  CFStringRef v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(uint64_t, _QWORD);
  uint64_t v67;
  uint64_t v68;
  void (*v69)(uint64_t, char *);
  _BOOL4 v70;
  __int16 v71;
  uint64_t v72;
  NSObject *v73;
  void *v74;
  void *v75;
  void (**v76)(_QWORD, _QWORD, _QWORD);
  const __CFString *v77;
  const __CFString *v78;
  CFIndex Length;
  CFIndex v80;
  int v81;
  CFIndex v82;
  NSObject *v83;
  uint64_t v84;
  CFDictionaryRef v85;
  NSObject *v86;
  NSObject *v87;
  os_log_type_t v88;
  uint32_t v89;
  NSObject *v90;
  NSObject *v91;
  os_log_type_t v92;
  _BOOL4 v93;
  char *backtrace_string;
  _BOOL4 v95;
  _BOOL4 v96;
  NSObject *v97;
  NSObject *v98;
  NSObject *v99;
  NSObject *v100;
  NWConcrete_nw_authentication_protection_space *v101;
  _BOOL8 v102;
  NWConcrete_nw_authentication_challenge *v103;
  NSObject *v104;
  void *v105;
  uint64_t v106;
  NSObject *v107;
  NSObject *v108;
  NSObject *v109;
  NSObject *v110;
  NSObject *v111;
  NSObject *v112;
  uint64_t v113;
  const char *v114;
  const char *v115;
  char *v116;
  NSObject *v117;
  os_log_type_t v118;
  uint64_t v119;
  const char *v120;
  const char *v121;
  const char *v122;
  _BOOL4 v123;
  char *v124;
  _BOOL4 v125;
  uint64_t v126;
  const char *v127;
  const char *v128;
  uint64_t v129;
  const char *v130;
  const char *v131;
  uint64_t v132;
  const char *v133;
  const char *v134;
  uint64_t v135;
  const char *v136;
  const char *v137;
  char *v138;
  NSObject *v139;
  os_log_type_t v140;
  uint64_t v141;
  const char *v142;
  const char *v143;
  const char *v144;
  char *v145;
  _BOOL4 v146;
  uint64_t v147;
  const char *v148;
  const char *v149;
  uint64_t v150;
  const char *v151;
  const char *v152;
  uint64_t v153;
  const char *v154;
  const char *v155;
  nw_protocol *v156;
  nw_protocol *v157;
  char *v158;
  char *v159;
  uint64_t v160;
  uint64_t *v161;
  os_log_type_t type[8];
  uint64_t v163;
  BOOL (*v164)(uint64_t, uint64_t);
  void *v165;
  char *v166;
  char v167;
  _BYTE buf[24];
  const char *v169;
  __int128 v170;
  _BYTE v171[24];
  const char *v172;
  uint64_t v173;
  CFRange v174;
  CFRange v175;
  CFRange v176;

  v173 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v90 = __nwlog_obj();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      _os_log_impl(&dword_182FBE000, v90, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (!__nwlog_fault(v8, type, v171))
      goto LABEL_224;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v91 = __nwlog_obj();
      v92 = type[0];
      if (!os_log_type_enabled(v91, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      v11 = "%{public}s called with null protocol";
    }
    else if (v171[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v91 = __nwlog_obj();
      v92 = type[0];
      v95 = os_log_type_enabled(v91, type[0]);
      if (backtrace_string)
      {
        if (v95)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v91, v92, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_224;
      }
      if (!v95)
        goto LABEL_224;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v91 = __nwlog_obj();
      v92 = type[0];
      if (!os_log_type_enabled(v91, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_272;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (!__nwlog_fault(v8, type, v171))
      goto LABEL_224;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v91 = __nwlog_obj();
      v92 = type[0];
      if (!os_log_type_enabled(v91, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      v11 = "%{public}s called with null http_connect";
      goto LABEL_272;
    }
    if (!v171[0])
    {
      v91 = __nwlog_obj();
      v92 = type[0];
      if (!os_log_type_enabled(v91, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      v11 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_272;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v91 = __nwlog_obj();
    v92 = type[0];
    v96 = os_log_type_enabled(v91, type[0]);
    if (!v28)
    {
      if (!v96)
        goto LABEL_224;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      v11 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_272;
    }
    if (!v96)
      goto LABEL_100;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v28;
    v30 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_250:
    v40 = v91;
    v41 = v92;
    v42 = 22;
    goto LABEL_99;
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0)
      return;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (!__nwlog_fault(v8, type, v171))
      goto LABEL_224;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v171[0])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_224;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v11 = "%{public}s %{public}s%sNo input handler, backtrace limit exceeded";
        goto LABEL_222;
      }
      v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type[0];
      v29 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!v28)
      {
        if (!v29)
          goto LABEL_224;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v11 = "%{public}s %{public}s%sNo input handler, no backtrace";
        goto LABEL_222;
      }
      if (!v29)
        goto LABEL_100;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      LOWORD(v170) = 2082;
      *(_QWORD *)((char *)&v170 + 2) = v28;
      v30 = "%{public}s %{public}s%sNo input handler, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
      goto LABEL_224;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v11 = "%{public}s %{public}s%sNo input handler";
LABEL_222:
    v87 = v9;
    v88 = v10;
    v89 = 32;
LABEL_223:
    _os_log_impl(&dword_182FBE000, v87, v88, v11, buf, v89);
    goto LABEL_224;
  }
  callbacks = default_input_handler->callbacks;
  if (!callbacks || (input_available = (void (*)(void))callbacks->input_available) == 0)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0)
      return;
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (!__nwlog_fault(v8, type, v171))
      goto LABEL_224;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type[0];
      if (!os_log_type_enabled(v9, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      v11 = "%{public}s %{public}s%sinput_handler callback invalid: input_available";
      goto LABEL_222;
    }
    if (v171[0])
    {
      v28 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type[0];
      v93 = os_log_type_enabled(v9, type[0]);
      if (v28)
      {
        if (v93)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          LOWORD(v170) = 2082;
          *(_QWORD *)((char *)&v170 + 2) = v28;
          v30 = "%{public}s %{public}s%sinput_handler callback invalid: input_available, dumping backtrace:%{public}s";
          goto LABEL_98;
        }
        goto LABEL_100;
      }
      if (!v93)
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      v11 = "%{public}s %{public}s%sinput_handler callback invalid: input_available, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = type[0];
      if (!os_log_type_enabled(v9, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      v11 = "%{public}s %{public}s%sinput_handler callback invalid: input_available, backtrace limit exceeded";
    }
    goto LABEL_222;
  }
  v7 = *((_DWORD *)handle + 70);
  if (v7 == 3)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0)
      return;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (!__nwlog_fault(v8, type, v171))
      goto LABEL_224;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v171[0])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_224;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v11 = "%{public}s %{public}s%sState is failed, backtrace limit exceeded";
        goto LABEL_222;
      }
      v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type[0];
      v31 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!v28)
      {
        if (!v31)
          goto LABEL_224;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v11 = "%{public}s %{public}s%sState is failed, no backtrace";
        goto LABEL_222;
      }
      if (!v31)
        goto LABEL_100;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      LOWORD(v170) = 2082;
      *(_QWORD *)((char *)&v170 + 2) = v28;
      v30 = "%{public}s %{public}s%sState is failed, dumping backtrace:%{public}s";
      goto LABEL_98;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type[0];
    if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
      goto LABEL_224;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v11 = "%{public}s %{public}s%sState is failed";
    goto LABEL_222;
  }
  if (v7 == 2)
  {
    input_available();
    return;
  }
  output_handler = a1->output_handler;
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      v97 = __nwlog_obj();
      if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        _os_log_impl(&dword_182FBE000, v97, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sNot yet connected, reading input for http connect", buf, 0x20u);
      }
    }
  }
  if (!output_handler)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0)
      return;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (!__nwlog_fault(v8, type, v171))
      goto LABEL_224;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      v11 = "%{public}s %{public}s%sNo output handler";
      goto LABEL_222;
    }
    if (!v171[0])
    {
      v9 = __nwlog_obj();
      v10 = type[0];
      if (!os_log_type_enabled(v9, type[0]))
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      v11 = "%{public}s %{public}s%sNo output handler, backtrace limit exceeded";
      goto LABEL_222;
    }
    v28 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    v10 = type[0];
    v38 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!v28)
    {
      if (!v38)
        goto LABEL_224;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 284;
      *(_WORD *)&buf[22] = 2080;
      v169 = " ";
      v11 = "%{public}s %{public}s%sNo output handler, no backtrace";
      goto LABEL_222;
    }
    if (!v38)
      goto LABEL_100;
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    LOWORD(v170) = 2082;
    *(_QWORD *)((char *)&v170 + 2) = v28;
    v30 = "%{public}s %{public}s%sNo output handler, dumping backtrace:%{public}s";
LABEL_98:
    v40 = v9;
    v41 = v10;
    v42 = 42;
LABEL_99:
    _os_log_impl(&dword_182FBE000, v40, v41, v30, buf, v42);
    goto LABEL_100;
  }
  v160 = 0;
  v161 = &v160;
  v159 = handle;
  if (((unsigned int (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, uint64_t *))output_handler->callbacks->get_input_frames)(output_handler, a1, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, &v160))
  {
    v13 = 0;
    v14 = 0;
    v158 = handle + 284;
    v156 = output_handler;
    v157 = a1;
    while (1)
    {
      v15 = v160;
      if (v160)
        break;
LABEL_25:
      if (!((unsigned int (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, uint64_t *))v156->callbacks->get_input_frames)(v156, v157, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, &v160))goto LABEL_64;
    }
    while (1)
    {
      v18 = (_QWORD *)(v15 + 32);
      v17 = *(_QWORD *)(v15 + 32);
      if (v17 || *(_QWORD *)(v15 + 40))
      {
        if (!*(_QWORD *)(v15 + 112))
          goto LABEL_41;
      }
      else
      {
        v17 = 0;
        if (!*(_QWORD *)(v15 + 112))
          goto LABEL_41;
      }
      if ((*(_WORD *)(v15 + 204) & 0x100) != 0
        && g_channel_check_validity
        && !g_channel_check_validity(v15, *(_QWORD *)(v15 + 88)))
      {
LABEL_41:
        v24 = 0;
        v22 = 0;
        goto LABEL_42;
      }
      v19 = *(_DWORD *)(v15 + 52);
      if (v19)
      {
        v20 = *(unsigned int *)(v15 + 56);
        v21 = v20 + *(_DWORD *)(v15 + 60);
        v22 = *(_QWORD *)(v15 + 112) + v20;
        v23 = *((_WORD *)handle + 184);
        v24 = v19 - v21;
        if (v19 != v21)
        {
          v23 |= 4u;
          *((_WORD *)handle + 184) = v23;
        }
        goto LABEL_43;
      }
      v24 = 0;
      v22 = *(_QWORD *)(v15 + 112) + *(unsigned int *)(v15 + 56);
LABEL_42:
      v23 = *((_WORD *)handle + 184);
LABEL_43:
      if ((v23 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v158;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          LOWORD(v170) = 1024;
          *(_DWORD *)((char *)&v170 + 2) = v24;
          WORD3(v170) = 2048;
          *((_QWORD *)&v170 + 1) = v22;
          _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sRead frame has %u bytes (%p)", buf, 0x30u);
        }
      }
      v26 = *(_QWORD *)(v15 + 32);
      v27 = *(_QWORD **)(v15 + 40);
      if (v26)
      {
        *(_QWORD *)(v26 + 40) = v27;
        v27 = *(_QWORD **)(v15 + 40);
      }
      else
      {
        v161 = *(uint64_t **)(v15 + 40);
      }
      handle = v159;
      v13 += v24;
      *v27 = v26;
      *v18 = 0;
      *(_QWORD *)(v15 + 40) = 0;
      v16 = (_QWORD *)*((_QWORD *)v159 + 29);
      *(_QWORD *)(v15 + 40) = v16;
      *v16 = v15;
      *((_QWORD *)v159 + 29) = v18;
      ++v14;
      v15 = v17;
      if (!v17)
        goto LABEL_25;
    }
  }
  v14 = 0;
  v13 = 0;
LABEL_64:
  v32 = &unk_1ECD84000;
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      v98 = __nwlog_obj();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sGot 0 input frames, done reading", buf, 0x20u);
      }
    }
  }
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      v99 = __nwlog_obj();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_input_available";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        LOWORD(v170) = 1024;
        *(_DWORD *)((char *)&v170 + 2) = v14;
        WORD3(v170) = 1024;
        DWORD2(v170) = v13;
        _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sRead %u frames (%u bytes)", buf, 0x2Cu);
      }
    }
  }
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      v100 = __nwlog_obj();
      if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
  }
  if (*((_DWORD *)handle + 70) == 2)
  {
    if ((*((_WORD *)handle + 184) & 0x80) != 0)
      return;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v8 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (__nwlog_fault(v8, type, v171))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = gLogObj;
        v10 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_224;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v11 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected";
        goto LABEL_222;
      }
      if (!v171[0])
      {
        v9 = __nwlog_obj();
        v10 = type[0];
        if (!os_log_type_enabled(v9, type[0]))
          goto LABEL_224;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v11 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected, backtrace limit exceeded";
        goto LABEL_222;
      }
      v28 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = gLogObj;
      v10 = type[0];
      v39 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!v28)
      {
        if (!v39)
          goto LABEL_224;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v11 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected, no backtrace";
        goto LABEL_222;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        LOWORD(v170) = 2082;
        *(_QWORD *)((char *)&v170 + 2) = v28;
        v30 = "%{public}s %{public}s%sSkipping inbound data process, since we're already connected, dumping backtrace:%{public}s";
        goto LABEL_98;
      }
LABEL_100:
      free(v28);
      if (!v8)
        return;
LABEL_225:
      free(v8);
      return;
    }
    goto LABEL_224;
  }
  if (*((_QWORD *)handle + 28))
  {
    v33 = *((_WORD *)handle + 184);
    if (*((_QWORD *)handle + 25))
      goto LABEL_130;
    if ((v33 & 0x80) == 0)
    {
      if (gLogDatapath)
      {
        v108 = __nwlog_obj();
        if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          _os_log_impl(&dword_182FBE000, v108, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
    }
    if (!*((_QWORD *)handle + 25))
    {
      *((_QWORD *)handle + 25) = CFHTTPMessageCreateEmpty((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      *((_DWORD *)handle + 66) = 0;
      *((_QWORD *)handle + 32) = 0;
      v45 = *((_WORD *)handle + 184);
      LOBYTE(v33) = v45 & 0xFD;
      *((_WORD *)handle + 184) = v45 & 0xFFFD;
      goto LABEL_130;
    }
    v33 = *((_WORD *)handle + 184);
    if ((v33 & 0x80) != 0)
    {
LABEL_130:
      v48 = MEMORY[0x1E0C809B0];
      *(_QWORD *)type = MEMORY[0x1E0C809B0];
      v163 = 0x40000000;
      v164 = ___ZL36nw_http_connect_process_inbound_dataP24nw_protocol_http_connect_block_invoke;
      v165 = &__block_descriptor_tmp_17_35798;
      v166 = handle;
      v49 = *((_QWORD *)handle + 28);
      do
      {
        if (!v49)
          break;
        v50 = *(_QWORD *)(v49 + 32);
        v51 = ((uint64_t (*)(os_log_type_t *))v164)(type);
        v49 = v50;
      }
      while ((v51 & 1) != 0);
      v52 = *((unsigned __int16 *)handle + 184);
      if ((v33 & 2) != 0)
      {
        if ((v52 & 0x80) == 0)
        {
          if (v32[1345])
          {
            v43 = __nwlog_obj();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              v44 = "%{public}s %{public}s%sResponse message was already complete, ignoring extra data...";
              goto LABEL_144;
            }
          }
        }
        return;
      }
      v53 = (v52 >> 7) & 1;
      if (!v32[1345])
        LOBYTE(v53) = 1;
      if ((v52 & 2) == 0)
      {
        if ((v53 & 1) == 0)
        {
          v43 = __nwlog_obj();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v169 = " ";
            v44 = "%{public}s %{public}s%sResponse message is not complete, waiting for more data...";
            goto LABEL_144;
          }
        }
        return;
      }
      if ((v53 & 1) == 0)
      {
        v109 = __nwlog_obj();
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          _os_log_impl(&dword_182FBE000, v109, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sResponse message is complete", buf, 0x20u);
        }
      }
      if ((*((_WORD *)handle + 184) & 0x80) == 0)
      {
        if (v32[1345])
        {
          v110 = __nwlog_obj();
          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v169 = " ";
            _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
          }
        }
      }
      v54 = (__CFHTTPMessage *)*((_QWORD *)handle + 25);
      if (v54)
      {
        v55 = *((_WORD *)handle + 184);
        if ((v55 & 2) == 0)
        {
          if ((v55 & 0x80) != 0)
            return;
          __nwlog_obj();
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          v8 = (char *)_os_log_send_and_compose_impl();
          v171[0] = 16;
          v167 = 0;
          if (__nwlog_fault(v8, v171, &v167))
          {
            if (v171[0] == 17)
            {
              v9 = __nwlog_obj();
              v10 = v171[0];
              if (!os_log_type_enabled(v9, (os_log_type_t)v171[0]))
                goto LABEL_224;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              v11 = "%{public}s %{public}s%sCannot process response that is not yet complete";
              goto LABEL_222;
            }
            if (!v167)
            {
              v9 = __nwlog_obj();
              v10 = v171[0];
              if (!os_log_type_enabled(v9, (os_log_type_t)v171[0]))
                goto LABEL_224;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              v11 = "%{public}s %{public}s%sCannot process response that is not yet complete, backtrace limit exceeded";
              goto LABEL_222;
            }
            v28 = (char *)__nw_create_backtrace_string();
            v9 = __nwlog_obj();
            v10 = v171[0];
            v70 = os_log_type_enabled(v9, (os_log_type_t)v171[0]);
            if (!v28)
            {
              if (!v70)
                goto LABEL_224;
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              v11 = "%{public}s %{public}s%sCannot process response that is not yet complete, no backtrace";
              goto LABEL_222;
            }
            if (v70)
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              LOWORD(v170) = 2082;
              *(_QWORD *)((char *)&v170 + 2) = v28;
              v30 = "%{public}s %{public}s%sCannot process response that is not yet complete, dumping backtrace:%{public}s";
              goto LABEL_98;
            }
            goto LABEL_100;
          }
LABEL_224:
          if (!v8)
            return;
          goto LABEL_225;
        }
        ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(v54);
        v57 = CFHTTPMessageCopyResponseStatusLine(*((CFHTTPMessageRef *)handle + 25));
        if ((*((_WORD *)handle + 184) & 0x80) == 0)
        {
          if (v32[1345])
          {
            v111 = __nwlog_obj();
            if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              LOWORD(v170) = 2112;
              *(_QWORD *)((char *)&v170 + 2) = v57;
              _os_log_impl(&dword_182FBE000, v111, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sResponse Message: %@", buf, 0x2Au);
            }
          }
        }
        if ((*((_WORD *)handle + 184) & 0x80) == 0)
        {
          if (v32[1345])
          {
            v112 = __nwlog_obj();
            if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              LOWORD(v170) = 2048;
              *(_QWORD *)((char *)&v170 + 2) = ResponseStatusCode;
              _os_log_impl(&dword_182FBE000, v112, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sStatus Code: %ld", buf, 0x2Au);
            }
          }
        }
        if (!*((_QWORD *)handle + 1))
        {
          v58 = mach_continuous_time();
          if (v58 <= 1)
            v59 = 1;
          else
            v59 = v58;
          *((_QWORD *)handle + 1) = v59;
        }
        if (ResponseStatusCode == 407)
        {
          v71 = *((_WORD *)handle + 184);
          *((_WORD *)handle + 184) = v71 & 0xFFF7;
          v72 = *((_QWORD *)handle + 21);
          if ((!v72 || *(_DWORD *)(v72 + 124) != 4) && (v71 & 0x80) == 0)
          {
            v73 = __nwlog_obj();
            if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              _os_log_impl(&dword_182FBE000, v73, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect proxy authentication required", buf, 0x20u);
            }
          }
          if (!*((_QWORD *)handle + 22) || *((_DWORD *)handle + 68))
          {
            v74 = (void *)*((_QWORD *)handle + 23);
            if (v74)
            {
              v75 = nw_proxy_options_copy_authentication_challenge_handler(v74);
              if (v75)
              {
                v76 = (void (**)(_QWORD, _QWORD, _QWORD))v75;
                v77 = CFHTTPMessageCopyHeaderFieldValue(*((CFHTTPMessageRef *)handle + 25), CFSTR("Proxy-Authenticate"));
                if (v77)
                {
                  v78 = v77;
                  Length = CFStringGetLength(v77);
                  if (Length < CFStringGetLength(CFSTR("NTLM"))
                    || (v174.length = CFStringGetLength(CFSTR("NTLM")),
                        v174.location = 0,
                        CFStringCompareWithOptions(v78, CFSTR("NTLM"), v174, 1uLL)))
                  {
                    v80 = CFStringGetLength(v78);
                    if (v80 < CFStringGetLength(CFSTR("Basic"))
                      || (v175.length = CFStringGetLength(CFSTR("Basic")),
                          v81 = 1,
                          v175.location = 0,
                          CFStringCompareWithOptions(v78, CFSTR("Basic"), v175, 1uLL)))
                    {
                      v82 = CFStringGetLength(v78);
                      if (v82 < CFStringGetLength(CFSTR("Digest"))
                        || (v176.length = CFStringGetLength(CFSTR("Digest")),
                            v176.location = 0,
                            CFStringCompareWithOptions(v78, CFSTR("Digest"), v176, 1uLL)))
                      {
                        v81 = 0;
                      }
                      else
                      {
                        v81 = 2;
                      }
                    }
                  }
                  else
                  {
                    v81 = 5;
                  }
                  v101 = nw_authentication_protection_space_create(v81);
                  CFRelease(v78);
                  if (v101)
                  {
                    nw_authentication_protection_space_set_is_proxy(v101, 1);
                    v102 = nw_endpoint_create_with_cfurl(*((const __CFURL **)handle + 27));
                    nw_authentication_protection_space_set_endpoint(v101, (void *)v102);
                    nw_authentication_protection_space_set_proxy_origin_is_cleartext(v101, 0);
                    v103 = objc_alloc_init(NWConcrete_nw_authentication_challenge);
                    nw_authentication_challenge_set_protection_space(v103, v101);
                    nw_authentication_challenge_set_http_message(v103, *((const void **)handle + 25));
                    nw_authentication_challenge_set_attempt_count(v103, *((_DWORD *)handle + 67));
                    os_release(v101);
                    ++*((_DWORD *)handle + 67);
                    nw_http_connect_start_async((uint64_t)handle);
                    if ((*((_WORD *)handle + 184) & 0x80) == 0)
                    {
                      v104 = __nwlog_obj();
                      if (os_log_type_enabled(v104, OS_LOG_TYPE_INFO))
                      {
                        *(_DWORD *)v171 = 136446722;
                        *(_QWORD *)&v171[4] = "nw_http_connect_send_auth_challenge";
                        *(_WORD *)&v171[12] = 2082;
                        *(_QWORD *)&v171[14] = handle + 284;
                        *(_WORD *)&v171[22] = 2080;
                        v172 = " ";
                        _os_log_impl(&dword_182FBE000, v104, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect calling out to challenge handler", v171, 0x20u);
                      }
                    }
                    *(_QWORD *)v171 = 0;
                    *(_QWORD *)&v171[8] = v171;
                    *(_QWORD *)&v171[16] = 0x2000000000;
                    v172 = 0;
                    v105 = (void *)*((_QWORD *)handle + 21);
                    if (v105)
                      v105 = os_retain(v105);
                    v172 = (const char *)v105;
                    *(_QWORD *)buf = v48;
                    *(_QWORD *)&buf[8] = 0x40000000;
                    *(_QWORD *)&buf[16] = ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke;
                    v169 = (const char *)&unk_1E14A09F0;
                    *(_QWORD *)&v170 = v171;
                    *((_QWORD *)&v170 + 1) = handle;
                    ((void (**)(_QWORD, NWConcrete_nw_authentication_challenge *, _BYTE *))v76)[2](v76, v103, buf);
                    _Block_release(v76);
                    if (v103)
                      os_release(v103);
                    _Block_object_dispose(v171, 8);
                    if (v102)
                      os_release((void *)v102);
                    goto LABEL_290;
                  }
                }
                v106 = *((_QWORD *)handle + 21);
                if ((!v106 || *(_DWORD *)(v106 + 124) != 4) && (*((_WORD *)handle + 184) & 0x80) == 0)
                {
                  v107 = __nwlog_obj();
                  if (os_log_type_enabled(v107, OS_LOG_TYPE_INFO))
                  {
                    *(_DWORD *)v171 = 136446722;
                    *(_QWORD *)&v171[4] = "nw_http_connect_send_auth_challenge";
                    *(_WORD *)&v171[12] = 2082;
                    *(_QWORD *)&v171[14] = handle + 284;
                    *(_WORD *)&v171[22] = 2080;
                    v172 = " ";
                    _os_log_impl(&dword_182FBE000, v107, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sCould not create challenge for HTTP Connect Proxy authentication", v171, 0x20u);
                  }
                }
              }
            }
          }
          nw_http_connect_send_auth_request((uint64_t)handle);
LABEL_290:
          if (v57)
            CFRelease(v57);
          return;
        }
        if (ResponseStatusCode != 200)
        {
          if ((*((_WORD *)handle + 184) & 0x80) == 0)
          {
            v83 = __nwlog_obj();
            if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = handle + 284;
              *(_WORD *)&buf[22] = 2080;
              v169 = " ";
              LOWORD(v170) = 2114;
              *(_QWORD *)((char *)&v170 + 2) = v57;
              _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%shttp connect Proxy received status: %{public}@", buf, 0x2Au);
            }
          }
          _CFHTTPAuthenticationApplyProxyAuthorizationToRequest();
          v84 = *((_QWORD *)handle + 21);
          if (!v84 || *(_DWORD *)(v84 + 124) != 4)
          {
            v85 = CFHTTPMessageCopyAllHeaderFields(*((CFHTTPMessageRef *)handle + 25));
            if ((*((_WORD *)handle + 184) & 0x80) == 0)
            {
              v86 = __nwlog_obj();
              if (os_log_type_enabled(v86, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = handle + 284;
                *(_WORD *)&buf[22] = 2080;
                v169 = " ";
                LOWORD(v170) = 2114;
                *(_QWORD *)((char *)&v170 + 2) = v85;
                _os_log_impl(&dword_182FBE000, v86, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sHeaders:\n%{public}@", buf, 0x2Au);
              }
            }
            if (v85)
              CFRelease(v85);
          }
          nw_http_connect_fail((uint64_t)handle, 57);
          goto LABEL_290;
        }
        v60 = *((_QWORD *)handle + 21);
        if ((!v60 || *(_DWORD *)(v60 + 124) != 4) && (*((_WORD *)handle + 184) & 0x80) == 0)
        {
          v61 = __nwlog_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v169 = " ";
            _os_log_impl(&dword_182FBE000, v61, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect proxy connected", buf, 0x20u);
          }
        }
        v62 = mach_continuous_time();
        if (v62 <= 1)
          v63 = 1;
        else
          v63 = v62;
        *((_QWORD *)handle + 2) = v63;
        *((_DWORD *)handle + 70) = 2;
        _CFHTTPAuthenticationApplyProxyAuthorizationToRequest();
        v64 = *((_QWORD *)handle + 9);
        if (v64)
        {
          v65 = *(_QWORD *)(v64 + 24);
          if (v65)
          {
            v66 = *(void (**)(uint64_t, _QWORD))(v65 + 40);
            if (v66)
            {
              v66(v64, *((_QWORD *)handle + 7));
              v67 = *((_QWORD *)handle + 9);
              if (!v67)
                goto LABEL_346;
LABEL_178:
              v68 = *(_QWORD *)(v67 + 24);
              if (v68)
              {
                v69 = *(void (**)(uint64_t, char *))(v68 + 40);
                if (v69)
                {
                  v69(v67, handle + 24);
                  goto LABEL_290;
                }
              }
LABEL_346:
              __nwlog_obj();
              v135 = *((_QWORD *)handle + 9);
              v136 = "invalid";
              if (v135)
              {
                v137 = *(const char **)(v135 + 16);
                if (v137)
                  v136 = v137;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v136;
              v138 = (char *)_os_log_send_and_compose_impl();
              v171[0] = 16;
              v167 = 0;
              if (!__nwlog_fault(v138, v171, &v167))
                goto LABEL_375;
              if (v171[0] == 17)
              {
                v139 = __nwlog_obj();
                v140 = v171[0];
                if (!os_log_type_enabled(v139, (os_log_type_t)v171[0]))
                  goto LABEL_375;
                v141 = *((_QWORD *)v159 + 9);
                v142 = "invalid";
                if (v141)
                {
                  v143 = *(const char **)(v141 + 16);
                  if (v143)
                    v142 = v143;
                }
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v142;
                v144 = "%{public}s protocol %{public}s has invalid connected callback";
              }
              else if (v167)
              {
                v145 = (char *)__nw_create_backtrace_string();
                v139 = __nwlog_obj();
                v140 = v171[0];
                v146 = os_log_type_enabled(v139, (os_log_type_t)v171[0]);
                if (v145)
                {
                  if (v146)
                  {
                    v147 = *((_QWORD *)v159 + 9);
                    v148 = "invalid";
                    if (v147)
                    {
                      v149 = *(const char **)(v147 + 16);
                      if (v149)
                        v148 = v149;
                    }
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v148;
                    *(_WORD *)&buf[22] = 2082;
                    v169 = v145;
                    _os_log_impl(&dword_182FBE000, v139, v140, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }
                  free(v145);
                  goto LABEL_375;
                }
                if (!v146)
                {
LABEL_375:
                  if (v138)
                    free(v138);
                  goto LABEL_290;
                }
                v153 = *((_QWORD *)v159 + 9);
                v154 = "invalid";
                if (v153)
                {
                  v155 = *(const char **)(v153 + 16);
                  if (v155)
                    v154 = v155;
                }
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v154;
                v144 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
              }
              else
              {
                v139 = __nwlog_obj();
                v140 = v171[0];
                if (!os_log_type_enabled(v139, (os_log_type_t)v171[0]))
                  goto LABEL_375;
                v150 = *((_QWORD *)v159 + 9);
                v151 = "invalid";
                if (v150)
                {
                  v152 = *(const char **)(v150 + 16);
                  if (v152)
                    v151 = v152;
                }
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v151;
                v144 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
              }
              _os_log_impl(&dword_182FBE000, v139, v140, v144, buf, 0x16u);
              goto LABEL_375;
            }
          }
        }
        __nwlog_obj();
        v113 = *((_QWORD *)handle + 9);
        v114 = "invalid";
        if (v113)
        {
          v115 = *(const char **)(v113 + 16);
          if (v115)
            v114 = v115;
        }
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v114;
        v116 = (char *)_os_log_send_and_compose_impl();
        v171[0] = 16;
        v167 = 0;
        if (__nwlog_fault(v116, v171, &v167))
        {
          if (v171[0] == 17)
          {
            v117 = __nwlog_obj();
            v118 = v171[0];
            if (!os_log_type_enabled(v117, (os_log_type_t)v171[0]))
              goto LABEL_343;
            v119 = *((_QWORD *)v159 + 9);
            v120 = "invalid";
            if (v119)
            {
              v121 = *(const char **)(v119 + 16);
              if (v121)
                v120 = v121;
            }
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v120;
            v122 = "%{public}s protocol %{public}s has invalid connected callback";
LABEL_342:
            _os_log_impl(&dword_182FBE000, v117, v118, v122, buf, 0x16u);
            goto LABEL_343;
          }
          if (!v167)
          {
            v117 = __nwlog_obj();
            v118 = v171[0];
            if (!os_log_type_enabled(v117, (os_log_type_t)v171[0]))
              goto LABEL_343;
            v129 = *((_QWORD *)v159 + 9);
            v130 = "invalid";
            if (v129)
            {
              v131 = *(const char **)(v129 + 16);
              if (v131)
                v130 = v131;
            }
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v130;
            v122 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
            goto LABEL_342;
          }
          v124 = (char *)__nw_create_backtrace_string();
          v117 = __nwlog_obj();
          v118 = v171[0];
          v125 = os_log_type_enabled(v117, (os_log_type_t)v171[0]);
          if (!v124)
          {
            if (!v125)
              goto LABEL_343;
            v132 = *((_QWORD *)v159 + 9);
            v133 = "invalid";
            if (v132)
            {
              v134 = *(const char **)(v132 + 16);
              if (v134)
                v133 = v134;
            }
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v133;
            v122 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
            goto LABEL_342;
          }
          if (v125)
          {
            v126 = *((_QWORD *)v159 + 9);
            v127 = "invalid";
            if (v126)
            {
              v128 = *(const char **)(v126 + 16);
              if (v128)
                v127 = v128;
            }
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v127;
            *(_WORD *)&buf[22] = 2082;
            v169 = v124;
            _os_log_impl(&dword_182FBE000, v117, v118, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v124);
        }
LABEL_343:
        if (v116)
          free(v116);
        handle = v159;
        v67 = *((_QWORD *)v159 + 9);
        if (!v67)
          goto LABEL_346;
        goto LABEL_178;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
      v8 = (char *)_os_log_send_and_compose_impl();
      v171[0] = 16;
      v167 = 0;
      if (!__nwlog_fault(v8, v171, &v167))
        goto LABEL_224;
      if (v171[0] == 17)
      {
        v91 = __nwlog_obj();
        v92 = v171[0];
        if (!os_log_type_enabled(v91, (os_log_type_t)v171[0]))
          goto LABEL_224;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
        v11 = "%{public}s called with null http_connect->response_message";
        goto LABEL_272;
      }
      if (v167)
      {
        v28 = (char *)__nw_create_backtrace_string();
        v91 = __nwlog_obj();
        v92 = v171[0];
        v123 = os_log_type_enabled(v91, (os_log_type_t)v171[0]);
        if (v28)
        {
          if (!v123)
            goto LABEL_100;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v28;
          v30 = "%{public}s called with null http_connect->response_message, dumping backtrace:%{public}s";
          goto LABEL_250;
        }
        if (!v123)
          goto LABEL_224;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
        v11 = "%{public}s called with null http_connect->response_message, no backtrace";
      }
      else
      {
        v91 = __nwlog_obj();
        v92 = v171[0];
        if (!os_log_type_enabled(v91, (os_log_type_t)v171[0]))
          goto LABEL_224;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_response";
        v11 = "%{public}s called with null http_connect->response_message, backtrace limit exceeded";
      }
LABEL_272:
      v87 = v91;
      v88 = v92;
      v89 = 12;
      goto LABEL_223;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_http_connect_prepare_response_message";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = handle + 284;
    *(_WORD *)&buf[22] = 2080;
    v169 = " ";
    v34 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v171[0] = 0;
    if (__nwlog_fault(v34, type, v171))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        v36 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          v37 = "%{public}s %{public}s%sAlready have response message, cannot create new one";
LABEL_126:
          _os_log_impl(&dword_182FBE000, v35, v36, v37, buf, 0x20u);
        }
      }
      else if (v171[0])
      {
        v46 = (char *)__nw_create_backtrace_string();
        v35 = __nwlog_obj();
        v36 = type[0];
        v47 = os_log_type_enabled(v35, type[0]);
        if (v46)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_http_connect_prepare_response_message";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 284;
            *(_WORD *)&buf[22] = 2080;
            v169 = " ";
            LOWORD(v170) = 2082;
            *(_QWORD *)((char *)&v170 + 2) = v46;
            _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s %{public}s%sAlready have response message, cannot create new one, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v46);
          v32 = (_BYTE *)&unk_1ECD84000;
          goto LABEL_127;
        }
        v32 = &unk_1ECD84000;
        if (v47)
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          v37 = "%{public}s %{public}s%sAlready have response message, cannot create new one, no backtrace";
          goto LABEL_126;
        }
      }
      else
      {
        v35 = __nwlog_obj();
        v36 = type[0];
        if (os_log_type_enabled(v35, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_prepare_response_message";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 284;
          *(_WORD *)&buf[22] = 2080;
          v169 = " ";
          v37 = "%{public}s %{public}s%sAlready have response message, cannot create new one, backtrace limit exceeded";
          goto LABEL_126;
        }
      }
    }
LABEL_127:
    if (v34)
      free(v34);
    v33 = *((_WORD *)handle + 184);
    goto LABEL_130;
  }
  if ((*((_WORD *)handle + 184) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      v43 = __nwlog_obj();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_process_inbound_data";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 284;
        *(_WORD *)&buf[22] = 2080;
        v169 = " ";
        v44 = "%{public}s %{public}s%sNo read frames, nothing to process";
LABEL_144:
        _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, v44, buf, 0x20u);
      }
    }
  }
}

void nw_protocol_http_connect_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  _WORD *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*input_finished)(void);
  nw_protocol *v8;
  const char *v9;
  nw_protocol_identifier *identifier;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  nw_protocol *v14;
  const char *v15;
  nw_protocol_identifier *v16;
  const char *v17;
  nw_protocol_callbacks *v18;
  nw_protocol *v19;
  nw_protocol_callbacks *v20;
  nw_protocol *v21;
  const char *v22;
  nw_protocol_identifier *v23;
  const char *v24;
  NSObject *v25;
  os_log_type_t v26;
  nw_protocol *v27;
  const char *v28;
  nw_protocol_identifier *v29;
  const char *v30;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  nw_protocol *v36;
  const char *v37;
  nw_protocol_identifier *v38;
  nw_protocol *v39;
  nw_protocol_identifier *v40;
  char *backtrace_string;
  _BOOL4 v42;
  char *v43;
  _BOOL4 v44;
  const char *v45;
  _BOOL4 v46;
  char *v47;
  _BOOL4 v48;
  nw_protocol *v49;
  const char *v50;
  nw_protocol_identifier *v51;
  char *v52;
  _BOOL4 v53;
  nw_protocol *v54;
  const char *v55;
  nw_protocol_identifier *v56;
  nw_protocol *v57;
  const char *v58;
  nw_protocol_identifier *v59;
  char *v60;
  _BOOL4 v61;
  nw_protocol *v62;
  const char *v63;
  nw_protocol_identifier *v64;
  char *v65;
  nw_protocol *v66;
  const char *v67;
  nw_protocol_identifier *v68;
  nw_protocol *v69;
  nw_protocol_identifier *v70;
  nw_protocol *v71;
  nw_protocol_identifier *v72;
  nw_protocol *v73;
  const char *v74;
  nw_protocol_identifier *v75;
  nw_protocol *v76;
  const char *v77;
  nw_protocol_identifier *v78;
  char v79;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v82;
  __int16 v83;
  void *v84;
  __int16 v85;
  char *v86;
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v31 = __nwlog_obj();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v82 = "nw_protocol_http_connect_input_finished";
      _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "nw_protocol_http_connect_input_finished";
    v32 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    if (!__nwlog_fault(v32, &type, &v79))
      goto LABEL_120;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_120;
      *(_DWORD *)buf = 136446210;
      v82 = "nw_protocol_http_connect_input_finished";
      v35 = "%{public}s called with null protocol";
    }
    else if (v79)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v42 = os_log_type_enabled(v33, type);
      if (backtrace_string)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          v82 = "nw_protocol_http_connect_input_finished";
          v83 = 2082;
          v84 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_120:
        if (!v32)
          return;
        goto LABEL_121;
      }
      if (!v42)
        goto LABEL_120;
      *(_DWORD *)buf = 136446210;
      v82 = "nw_protocol_http_connect_input_finished";
      v35 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_120;
      *(_DWORD *)buf = 136446210;
      v82 = "nw_protocol_http_connect_input_finished";
      v35 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_119;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "nw_protocol_http_connect_input_finished";
    v32 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    if (!__nwlog_fault(v32, &type, &v79))
      goto LABEL_120;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v79)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_120;
        *(_DWORD *)buf = 136446210;
        v82 = "nw_protocol_http_connect_input_finished";
        v35 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_119;
      }
      v43 = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v44 = os_log_type_enabled(v33, type);
      if (!v43)
      {
        if (!v44)
          goto LABEL_120;
        *(_DWORD *)buf = 136446210;
        v82 = "nw_protocol_http_connect_input_finished";
        v35 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_119;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = v43;
        v45 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_182FBE000, v33, v34, v45, buf, 0x16u);
      }
LABEL_75:
      free(v43);
      if (!v32)
        return;
LABEL_121:
      v65 = (char *)v32;
LABEL_140:
      free(v65);
      return;
    }
    v33 = __nwlog_obj();
    v34 = type;
    if (!os_log_type_enabled(v33, type))
      goto LABEL_120;
    *(_DWORD *)buf = 136446210;
    v82 = "nw_protocol_http_connect_input_finished";
    v35 = "%{public}s called with null http_connect";
LABEL_119:
    _os_log_impl(&dword_182FBE000, v33, v34, v35, buf, 0xCu);
    goto LABEL_120;
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v82 = "nw_protocol_http_connect_input_finished";
    v32 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    if (!__nwlog_fault(v32, &type, &v79))
      goto LABEL_120;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_120;
      *(_DWORD *)buf = 136446210;
      v82 = "nw_protocol_http_connect_input_finished";
      v35 = "%{public}s called with null protocol->default_input_handler";
      goto LABEL_119;
    }
    if (!v79)
    {
      v33 = __nwlog_obj();
      v34 = type;
      if (!os_log_type_enabled(v33, type))
        goto LABEL_120;
      *(_DWORD *)buf = 136446210;
      v82 = "nw_protocol_http_connect_input_finished";
      v35 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
      goto LABEL_119;
    }
    v43 = (char *)__nw_create_backtrace_string();
    v33 = __nwlog_obj();
    v34 = type;
    v46 = os_log_type_enabled(v33, type);
    if (!v43)
    {
      if (!v46)
        goto LABEL_120;
      *(_DWORD *)buf = 136446210;
      v82 = "nw_protocol_http_connect_input_finished";
      v35 = "%{public}s called with null protocol->default_input_handler, no backtrace";
      goto LABEL_119;
    }
    if (v46)
    {
      *(_DWORD *)buf = 136446466;
      v82 = "nw_protocol_http_connect_input_finished";
      v83 = 2082;
      v84 = v43;
      v45 = "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s";
      goto LABEL_74;
    }
    goto LABEL_75;
  }
  if (*((_DWORD *)handle + 70) == 1)
  {
    if (a1->output_handler != a2)
    {
      callbacks = default_input_handler->callbacks;
      if (!callbacks || (input_finished = (void (*)(void))callbacks->input_finished) == 0)
      {
        __nwlog_obj();
        v8 = a1->default_input_handler;
        v9 = "invalid";
        if (v8)
        {
          identifier = v8->identifier;
          if (identifier)
            v9 = (const char *)identifier;
        }
        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v9;
        v11 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v79 = 0;
        if (!__nwlog_fault(v11, &type, &v79))
          goto LABEL_138;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v12 = __nwlog_obj();
          v13 = type;
          if (!os_log_type_enabled(v12, type))
            goto LABEL_138;
          v14 = a1->default_input_handler;
          v15 = "invalid";
          if (v14)
          {
            v16 = v14->identifier;
            if (v16)
              v15 = (const char *)v16;
          }
LABEL_18:
          *(_DWORD *)buf = 136446466;
          v82 = "nw_protocol_http_connect_input_finished";
          v83 = 2082;
          v84 = (void *)v15;
          v17 = "%{public}s protocol %{public}s has invalid input_finished callback";
LABEL_137:
          _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
          goto LABEL_138;
        }
        if (v79)
        {
          v52 = (char *)__nw_create_backtrace_string();
          v12 = __nwlog_obj();
          v13 = type;
          v53 = os_log_type_enabled(v12, type);
          if (v52)
          {
            if (v53)
            {
              v54 = a1->default_input_handler;
              v55 = "invalid";
              if (v54)
              {
                v56 = v54->identifier;
                if (v56)
                  v55 = (const char *)v56;
              }
              *(_DWORD *)buf = 136446722;
              v82 = "nw_protocol_http_connect_input_finished";
              v83 = 2082;
              v84 = (void *)v55;
              v85 = 2082;
              v86 = v52;
              _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v52);
            if (v11)
              goto LABEL_139;
            return;
          }
          if (v53)
          {
            v71 = a1->default_input_handler;
            v67 = "invalid";
            if (v71)
            {
              v72 = v71->identifier;
              if (v72)
                v67 = (const char *)v72;
            }
LABEL_136:
            *(_DWORD *)buf = 136446466;
            v82 = "nw_protocol_http_connect_input_finished";
            v83 = 2082;
            v84 = (void *)v67;
            v17 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
            goto LABEL_137;
          }
          goto LABEL_138;
        }
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
          goto LABEL_138;
        v69 = a1->default_input_handler;
        v58 = "invalid";
        if (v69)
        {
          v70 = v69->identifier;
          if (v70)
            v58 = (const char *)v70;
        }
LABEL_104:
        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v58;
        v17 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
        goto LABEL_137;
      }
LABEL_21:
      input_finished();
      return;
    }
    handle[184] = handle[184] & 0xFFC7 | 0x20;
    if ((nw_http_connect_restart_after_disconnect((uint64_t)handle) & 1) != 0)
      return;
    v19 = a1->default_input_handler;
    if (v19)
    {
      v20 = v19->callbacks;
      if (v20)
      {
        input_finished = (void (*)(void))v20->disconnected;
        if (input_finished)
          goto LABEL_21;
      }
    }
    __nwlog_obj();
    v21 = a1->default_input_handler;
    v22 = "invalid";
    if (v21)
    {
      v23 = v21->identifier;
      if (v23)
        v22 = (const char *)v23;
    }
    *(_DWORD *)buf = 136446466;
    v82 = "nw_protocol_http_connect_input_finished";
    v83 = 2082;
    v84 = (void *)v22;
    type = OS_LOG_TYPE_ERROR;
    v79 = 0;
    v24 = (const char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v24, &type, &v79))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
          goto LABEL_152;
        v27 = a1->default_input_handler;
        v28 = "invalid";
        if (v27)
        {
          v29 = v27->identifier;
          if (v29)
            v28 = (const char *)v29;
        }
        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v28;
        v30 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_151:
        _os_log_impl(&dword_182FBE000, v25, v26, v30, buf, 0x16u);
        goto LABEL_152;
      }
      if (!v79)
      {
        v25 = __nwlog_obj();
        v26 = type;
        if (!os_log_type_enabled(v25, type))
          goto LABEL_152;
        v73 = a1->default_input_handler;
        v74 = "invalid";
        if (v73)
        {
          v75 = v73->identifier;
          if (v75)
            v74 = (const char *)v75;
        }
        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v74;
        v30 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_151;
      }
      v60 = (char *)__nw_create_backtrace_string();
      v25 = __nwlog_obj();
      v26 = type;
      v61 = os_log_type_enabled(v25, type);
      if (!v60)
      {
        if (!v61)
          goto LABEL_152;
        v76 = a1->default_input_handler;
        v77 = "invalid";
        if (v76)
        {
          v78 = v76->identifier;
          if (v78)
            v77 = (const char *)v78;
        }
        *(_DWORD *)buf = 136446466;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v77;
        v30 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
        goto LABEL_151;
      }
      if (v61)
      {
        v62 = a1->default_input_handler;
        v63 = "invalid";
        if (v62)
        {
          v64 = v62->identifier;
          if (v64)
            v63 = (const char *)v64;
        }
        *(_DWORD *)buf = 136446722;
        v82 = "nw_protocol_http_connect_input_finished";
        v83 = 2082;
        v84 = (void *)v63;
        v85 = 2082;
        v86 = v60;
        _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v60);
    }
LABEL_152:
    if (v24)
    {
      v65 = (char *)v24;
      goto LABEL_140;
    }
    return;
  }
  v18 = default_input_handler->callbacks;
  if (v18)
  {
    input_finished = (void (*)(void))v18->input_finished;
    if (input_finished)
      goto LABEL_21;
  }
  __nwlog_obj();
  v36 = a1->default_input_handler;
  v37 = "invalid";
  if (v36)
  {
    v38 = v36->identifier;
    if (v38)
      v37 = (const char *)v38;
  }
  *(_DWORD *)buf = 136446466;
  v82 = "nw_protocol_http_connect_input_finished";
  v83 = 2082;
  v84 = (void *)v37;
  v11 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v79 = 0;
  if (!__nwlog_fault(v11, &type, &v79))
    goto LABEL_138;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_138;
    v39 = a1->default_input_handler;
    v15 = "invalid";
    if (v39)
    {
      v40 = v39->identifier;
      if (v40)
        v15 = (const char *)v40;
    }
    goto LABEL_18;
  }
  if (!v79)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_138;
    v57 = a1->default_input_handler;
    v58 = "invalid";
    if (v57)
    {
      v59 = v57->identifier;
      if (v59)
        v58 = (const char *)v59;
    }
    goto LABEL_104;
  }
  v47 = (char *)__nw_create_backtrace_string();
  v12 = __nwlog_obj();
  v13 = type;
  v48 = os_log_type_enabled(v12, type);
  if (!v47)
  {
    if (!v48)
      goto LABEL_138;
    v66 = a1->default_input_handler;
    v67 = "invalid";
    if (v66)
    {
      v68 = v66->identifier;
      if (v68)
        v67 = (const char *)v68;
    }
    goto LABEL_136;
  }
  if (v48)
  {
    v49 = a1->default_input_handler;
    v50 = "invalid";
    if (v49)
    {
      v51 = v49->identifier;
      if (v51)
        v50 = (const char *)v51;
    }
    *(_DWORD *)buf = 136446722;
    v82 = "nw_protocol_http_connect_input_finished";
    v83 = 2082;
    v84 = (void *)v50;
    v85 = 2082;
    v86 = v47;
    _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
  }
  free(v47);
LABEL_138:
  if (v11)
  {
LABEL_139:
    v65 = (char *)v11;
    goto LABEL_140;
  }
}

uint64_t nw_protocol_http_connect_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _WORD *handle;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  nw_frame **tqh_last;
  nw_frame **v15;
  uint64_t v16;
  _QWORD *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  nw_frame **v25;
  char *v26;
  _BOOL4 v27;
  NSObject *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  char *backtrace_string;
  _BOOL4 v34;
  const char *v35;
  _BOOL4 v36;
  NSObject *log;
  char v39;
  os_log_type_t type;
  _BYTE buf[22];
  __int16 v42;
  const char *v43;
  __int16 v44;
  _BYTE v45[10];
  __int16 v46;
  int v47;
  __int16 v48;
  unsigned int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v28 = __nwlog_obj();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
      _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v29, &type, &v39))
      goto LABEL_79;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v39)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (!os_log_type_enabled(v30, type))
          goto LABEL_79;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        v32 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_78;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v34 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v34)
          goto LABEL_79;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        v32 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_78;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v35 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_66:
        _os_log_impl(&dword_182FBE000, v30, v31, v35, buf, 0x16u);
      }
LABEL_67:
      free(backtrace_string);
      goto LABEL_79;
    }
    v30 = __nwlog_obj();
    v31 = type;
    if (!os_log_type_enabled(v30, type))
      goto LABEL_79;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
    v32 = "%{public}s called with null protocol";
LABEL_78:
    _os_log_impl(&dword_182FBE000, v30, v31, v32, buf, 0xCu);
LABEL_79:
    if (v29)
      free(v29);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v29, &type, &v39))
      goto LABEL_79;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
      v32 = "%{public}s called with null http_connect";
      goto LABEL_78;
    }
    if (!v39)
    {
      v30 = __nwlog_obj();
      v31 = type;
      if (!os_log_type_enabled(v30, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
      v32 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v30 = __nwlog_obj();
    v31 = type;
    v36 = os_log_type_enabled(v30, type);
    if (backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v35 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_66;
      }
      goto LABEL_67;
    }
    if (!v36)
      goto LABEL_79;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
    v32 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_78;
  }
  if (*((_DWORD *)handle + 70) != 2)
  {
    if ((handle[184] & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 142;
        v42 = 2080;
        v43 = " ";
        _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sNot yet connected, returning 0 input frames", buf, 0x20u);
        return 0;
      }
    }
    return 0;
  }
  v11 = *((_QWORD *)handle + 28);
  if (!v11)
    goto LABEL_34;
  v12 = 0;
  v13 = 0;
  while (v11 && nw_frame_unclaimed_length((_DWORD *)v11) + v13 <= a4 && v12 <= a5)
  {
    v16 = *(_QWORD *)(v11 + 32);
    v17 = *(_QWORD **)(v11 + 40);
    v15 = (nw_frame **)(v11 + 32);
    if (v16)
    {
      *(_QWORD *)(v16 + 40) = v17;
      v17 = *(_QWORD **)(v11 + 40);
    }
    else
    {
      *((_QWORD *)handle + 29) = v17;
    }
    *v17 = v16;
    *v15 = 0;
    *(_QWORD *)(v11 + 40) = 0;
    tqh_last = a6->tqh_last;
    *(_QWORD *)(v11 + 40) = tqh_last;
    *tqh_last = (nw_frame *)v11;
    a6->tqh_last = v15;
    v13 += nw_frame_unclaimed_length((_DWORD *)v11);
    v12 = (v12 + 1);
    v11 = *((_QWORD *)handle + 28);
  }
  if ((handle[184] & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      log = __nwlog_obj();
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 142;
        v42 = 2080;
        v43 = " ";
        v44 = 1024;
        *(_DWORD *)v45 = v12;
        *(_WORD *)&v45[4] = 1024;
        *(_DWORD *)&v45[6] = v13;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sAdding %u frames (%u bytes) from read_frames", buf, 0x2Cu);
      }
    }
  }
  if (v11)
  {
    if ((handle[184] & 0x80) == 0)
    {
      if (gLogDatapath)
      {
        v19 = __nwlog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136447746;
          *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = handle + 142;
          v42 = 2080;
          v43 = " ";
          v44 = 1024;
          *(_DWORD *)v45 = a4;
          *(_WORD *)&v45[4] = 1024;
          *(_DWORD *)&v45[6] = a5;
          v46 = 1024;
          v47 = v12;
          v48 = 1024;
          v49 = v13;
          _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sHit maximum (%u bytes, %u frames), returning %u frames (%u bytes)", buf, 0x38u);
        }
      }
    }
    return v12;
  }
  if (v13 > a4)
  {
    if ((handle[184] & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 142;
        v42 = 2080;
        v43 = " ";
        v44 = 1024;
        *(_DWORD *)v45 = v13;
        *(_WORD *)&v45[4] = 1024;
        *(_DWORD *)&v45[6] = a4;
        _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sAbout to read from below when above maximum bytes (%u bytes > %u bytes)", buf, 0x2Cu);
      }
    }
    if ((handle[184] & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = handle + 142;
      v42 = 2080;
      v43 = " ";
      v21 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v39 = 0;
      if (!__nwlog_fault(v21, &type, &v39))
        goto LABEL_46;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_46;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 142;
        v42 = 2080;
        v43 = " ";
        v24 = "%{public}s %{public}s%sAbout to read from below when above maximum bytes";
      }
      else if (v39)
      {
        v26 = (char *)__nw_create_backtrace_string();
        v22 = __nwlog_obj();
        v23 = type;
        v27 = os_log_type_enabled(v22, type);
        if (v26)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = handle + 142;
            v42 = 2080;
            v43 = " ";
            v44 = 2082;
            *(_QWORD *)v45 = v26;
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s %{public}s%sAbout to read from below when above maximum bytes, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v26);
          goto LABEL_46;
        }
        if (!v27)
        {
LABEL_46:
          if (v21)
            free(v21);
          return v12;
        }
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 142;
        v42 = 2080;
        v43 = " ";
        v24 = "%{public}s %{public}s%sAbout to read from below when above maximum bytes, no backtrace";
      }
      else
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (!os_log_type_enabled(v22, type))
          goto LABEL_46;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_protocol_http_connect_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = handle + 142;
        v42 = 2080;
        v43 = " ";
        v24 = "%{public}s %{public}s%sAbout to read from below when above maximum bytes, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0x20u);
      goto LABEL_46;
    }
  }
  else
  {
LABEL_34:
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v12 = (*(uint64_t (**)(void))(*(_QWORD *)(*((_QWORD *)handle + 7) + 24) + 80))();
    if (*(_QWORD *)buf)
    {
      *a6->tqh_last = *(nw_frame **)buf;
      v25 = *(nw_frame ***)&buf[8];
      *(_QWORD *)(*(_QWORD *)buf + 40) = a6->tqh_last;
      a6->tqh_last = v25;
    }
  }
  return v12;
}

uint64_t nw_protocol_http_connect_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  uint64_t result;
  uint64_t v9;
  uint64_t (*v10)(void);
  NSObject *v11;
  NSObject *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  const char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http_connect_get_output_frames";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http_connect_get_output_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_43;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v21)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_43;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_http_connect_get_output_frames";
        v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v18 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (!v18)
          goto LABEL_43;
        *(_DWORD *)buf = 136446210;
        v24 = "nw_protocol_http_connect_get_output_frames";
        v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_42;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_http_connect_get_output_frames";
        v25 = 2082;
        v26 = backtrace_string;
        v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      }
LABEL_33:
      free(backtrace_string);
      goto LABEL_43;
    }
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http_connect_get_output_frames";
    v16 = "%{public}s called with null protocol";
LABEL_42:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
LABEL_43:
    if (v13)
      free(v13);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http_connect_get_output_frames";
    v13 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v13, &type, &v21))
      goto LABEL_43;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http_connect_get_output_frames";
      v16 = "%{public}s called with null http_connect";
      goto LABEL_42;
    }
    if (!v21)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_43;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_protocol_http_connect_get_output_frames";
      v16 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v20 = os_log_type_enabled(v14, type);
    if (backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_protocol_http_connect_get_output_frames";
        v25 = 2082;
        v26 = backtrace_string;
        v19 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v20)
      goto LABEL_43;
    *(_DWORD *)buf = 136446210;
    v24 = "nw_protocol_http_connect_get_output_frames";
    v16 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_42;
  }
  if (*((_DWORD *)handle + 70) == 2)
  {
    result = handle[7];
    if (!result)
      return result;
    v9 = *(_QWORD *)(result + 24);
    if (v9)
    {
      v10 = *(uint64_t (**)(void))(v9 + 88);
      if (v10)
        return v10();
    }
  }
  else if ((handle[46] & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)buf = 136446722;
    v24 = "nw_protocol_http_connect_get_output_frames";
    v25 = 2082;
    v26 = (char *)handle + 284;
    v27 = 2080;
    v28 = " ";
    _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sNot yet connected, returning 0 output frames", buf, 0x20u);
  }
  return 0;
}

uint64_t nw_protocol_http_connect_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  _WORD *handle;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(void);
  char *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *backtrace_string;
  _BOOL4 v14;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint32_t v18;
  NSObject *v19;
  os_log_type_t v20;
  uint32_t v21;
  char *v22;
  NSObject *v23;
  NSObject *v24;
  os_log_type_t v25;
  char *v26;
  _BOOL4 v27;
  _BOOL4 v28;
  _BOOL4 v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  char *v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_http_connect_finalize_output_frames";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30))
      goto LABEL_27;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v12 = "%{public}s called with null protocol";
      goto LABEL_71;
    }
    if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v28 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (!v28)
          goto LABEL_19;
        *(_DWORD *)buf = 136446466;
        v33 = "nw_protocol_http_connect_finalize_output_frames";
        v34 = 2082;
        v35 = backtrace_string;
        v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_58;
      }
      if (!v28)
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v12 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_71:
    v19 = v24;
    v20 = v25;
    v21 = 12;
    goto LABEL_26;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_protocol_http_connect_finalize_output_frames";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30))
      goto LABEL_27;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v12 = "%{public}s called with null http_connect";
      goto LABEL_71;
    }
    if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v29 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (!v29)
          goto LABEL_19;
        *(_DWORD *)buf = 136446466;
        v33 = "nw_protocol_http_connect_finalize_output_frames";
        v34 = 2082;
        v35 = backtrace_string;
        v15 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_58:
        v16 = v24;
        v17 = v25;
        v18 = 22;
        goto LABEL_18;
      }
      if (!v29)
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v12 = "%{public}s called with null http_connect, no backtrace";
    }
    else
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (!os_log_type_enabled(v24, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446210;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v12 = "%{public}s called with null http_connect, backtrace limit exceeded";
    }
    goto LABEL_71;
  }
  if (*((_DWORD *)handle + 70) != 2)
  {
    if ((handle[184] & 0x80) != 0)
      return 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (char *)(handle + 142);
    *(_DWORD *)buf = 136446722;
    v33 = "nw_protocol_http_connect_finalize_output_frames";
    v34 = 2082;
    v35 = (char *)(handle + 142);
    v36 = 2080;
    v37 = " ";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30))
      goto LABEL_27;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446722;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v34 = 2082;
      v35 = v8;
      v36 = 2080;
      v37 = " ";
      v12 = "%{public}s %{public}s%sCannot finalize output frames when not connected";
      goto LABEL_25;
    }
    if (!v30)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = gLogObj;
      v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_27;
      *(_DWORD *)buf = 136446722;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v34 = 2082;
      v35 = v8;
      v36 = 2080;
      v37 = " ";
      v12 = "%{public}s %{public}s%sCannot finalize output frames when not connected, backtrace limit exceeded";
      goto LABEL_25;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = gLogObj;
    v11 = type;
    v14 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v14)
        goto LABEL_27;
      *(_DWORD *)buf = 136446722;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v34 = 2082;
      v35 = v8;
      v36 = 2080;
      v37 = " ";
      v12 = "%{public}s %{public}s%sCannot finalize output frames when not connected, no backtrace";
      goto LABEL_25;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446978;
      v33 = "nw_protocol_http_connect_finalize_output_frames";
      v34 = 2082;
      v35 = v8;
      v36 = 2080;
      v37 = " ";
      v38 = 2082;
      v39 = backtrace_string;
      v15 = "%{public}s %{public}s%sCannot finalize output frames when not connected, dumping backtrace:%{public}s";
      v16 = v10;
      v17 = v11;
      v18 = 42;
LABEL_18:
      _os_log_impl(&dword_182FBE000, v16, v17, v15, buf, v18);
    }
LABEL_19:
    free(backtrace_string);
    if (!v9)
      return 0;
    goto LABEL_28;
  }
  v4 = *((_QWORD *)handle + 7);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 + 24);
    if (v5)
    {
      v6 = *(uint64_t (**)(void))(v5 + 96);
      if (v6)
        return v6();
    }
  }
  if ((handle[184] & 0x80) != 0)
    return 0;
  __nwlog_obj();
  v22 = (char *)(handle + 142);
  *(_DWORD *)buf = 136446722;
  v33 = "nw_protocol_http_connect_finalize_output_frames";
  v34 = 2082;
  v35 = (char *)(handle + 142);
  v36 = 2080;
  v37 = " ";
  v9 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v30 = 0;
  if (__nwlog_fault(v9, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        v33 = "nw_protocol_http_connect_finalize_output_frames";
        v34 = 2082;
        v35 = v22;
        v36 = 2080;
        v37 = " ";
        v12 = "%{public}s %{public}s%sOutput handler has invalid finalize_output_frames callback";
LABEL_25:
        v19 = v10;
        v20 = v11;
        v21 = 32;
LABEL_26:
        _os_log_impl(&dword_182FBE000, v19, v20, v12, buf, v21);
      }
    }
    else if (v30)
    {
      v26 = (char *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v27 = os_log_type_enabled(v10, type);
      if (v26)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446978;
          v33 = "nw_protocol_http_connect_finalize_output_frames";
          v34 = 2082;
          v35 = v22;
          v36 = 2080;
          v37 = " ";
          v38 = 2082;
          v39 = v26;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s %{public}s%sOutput handler has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v26);
      }
      else if (v27)
      {
        *(_DWORD *)buf = 136446722;
        v33 = "nw_protocol_http_connect_finalize_output_frames";
        v34 = 2082;
        v35 = v22;
        v36 = 2080;
        v37 = " ";
        v12 = "%{public}s %{public}s%sOutput handler has invalid finalize_output_frames callback, no backtrace";
        goto LABEL_25;
      }
    }
    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446722;
        v33 = "nw_protocol_http_connect_finalize_output_frames";
        v34 = 2082;
        v35 = v22;
        v36 = 2080;
        v37 = " ";
        v12 = "%{public}s %{public}s%sOutput handler has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_25;
      }
    }
  }
LABEL_27:
  if (v9)
LABEL_28:
    free(v9);
  return 0;
}

void nw_protocol_http_connect_connected(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*connected)(nw_protocol *, nw_protocol *);
  nw_protocol *v8;
  __int16 v9;
  nw_protocol *path;
  NWConcrete_nw_path *v11;
  OS_nw_parameters *v12;
  _DWORD *v13;
  _DWORD *v14;
  NWConcrete_nw_path_flow_registration *v15;
  NWConcrete_nw_path_flow_registration *v16;
  uint64_t nexus_key;
  char can_support_user_packet_pool;
  char v19;
  _BOOL8 v20;
  void *v21;
  const void *v22;
  int v23;
  BOOL v24;
  uint64_t v25;
  nw_protocol *v26;
  nw_protocol_callbacks *v27;
  void (*v28)(void);
  nw_protocol_callbacks *v29;
  char *v30;
  const char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *v35;
  _BOOL4 v36;
  NSObject *v37;
  const char *v38;
  NSObject *v39;
  os_log_type_t v40;
  uint32_t v41;
  char *v42;
  NSObject *v43;
  NSObject *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  nw_protocol *v48;
  const char *v49;
  nw_protocol_identifier *identifier;
  const char *v51;
  NSObject *v52;
  os_log_type_t v53;
  nw_protocol *v54;
  const char *v55;
  nw_protocol_identifier *v56;
  const char *v57;
  NSObject *v58;
  NSObject *v59;
  os_log_type_t v60;
  char *v61;
  _BOOL4 v62;
  nw_protocol *v63;
  const char *v64;
  nw_protocol_identifier *v65;
  char *backtrace_string;
  _BOOL4 v67;
  const char *v68;
  _BOOL4 v69;
  _BOOL4 v70;
  nw_protocol *v71;
  const char *v72;
  nw_protocol_identifier *v73;
  nw_protocol *v74;
  const char *v75;
  nw_protocol_identifier *v76;
  char *v77;
  NSObject *v78;
  os_log_type_t v79;
  nw_protocol *v80;
  const char *v81;
  nw_protocol_identifier *v82;
  const char *v83;
  nw_protocol *v84;
  const char *v85;
  nw_protocol_identifier *v86;
  nw_protocol *v87;
  nw_protocol_identifier *v88;
  nw_protocol *v89;
  const char *v90;
  nw_protocol_identifier *v91;
  char *v92;
  _BOOL4 v93;
  nw_protocol *v94;
  const char *v95;
  nw_protocol_identifier *v96;
  char *v97;
  _BOOL4 v98;
  nw_protocol *v99;
  const char *v100;
  nw_protocol_identifier *v101;
  nw_protocol *v102;
  const char *v103;
  nw_protocol_identifier *v104;
  nw_protocol *v105;
  nw_protocol_identifier *v106;
  nw_protocol *v107;
  const char *v108;
  nw_protocol_identifier *v109;
  nw_protocol *v110;
  nw_protocol_identifier *v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  unsigned int v115;
  uint8_t buf[4];
  const char *v117;
  __int16 v118;
  char *v119;
  __int16 v120;
  const char *v121;
  __int16 v122;
  char *v123;
  __int128 uu;
  uint64_t v125;

  v125 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v58 = __nwlog_obj();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v117 = "nw_protocol_http_connect_connected";
    v31 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (!__nwlog_fault(v31, &uu, &v112))
      goto LABEL_60;
    if (uu == 17)
    {
      v59 = __nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null protocol";
      goto LABEL_177;
    }
    if (!(_BYTE)v112)
    {
      v59 = __nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_177;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = __nwlog_obj();
    v60 = uu;
    v67 = os_log_type_enabled(v59, (os_log_type_t)uu);
    if (!backtrace_string)
    {
      if (!v67)
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_177;
    }
    if (v67)
    {
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      v118 = 2082;
      v119 = backtrace_string;
      v68 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_129:
      _os_log_impl(&dword_182FBE000, v59, v60, v68, buf, 0x16u);
    }
LABEL_130:
    free(backtrace_string);
    if (!v31)
      return;
LABEL_61:
    v42 = (char *)v31;
LABEL_62:
    free(v42);
    return;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v117 = "nw_protocol_http_connect_connected";
    v31 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (!__nwlog_fault(v31, &uu, &v112))
      goto LABEL_60;
    if (uu == 17)
    {
      v59 = __nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null http_connect";
      goto LABEL_177;
    }
    if (!(_BYTE)v112)
    {
      v59 = __nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_177;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = __nwlog_obj();
    v60 = uu;
    v69 = os_log_type_enabled(v59, (os_log_type_t)uu);
    if (!backtrace_string)
    {
      if (!v69)
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_177;
    }
    if (v69)
    {
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      v118 = 2082;
      v119 = backtrace_string;
      v68 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
      goto LABEL_129;
    }
    goto LABEL_130;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v117 = "nw_protocol_http_connect_connected";
    v31 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (!__nwlog_fault(v31, &uu, &v112))
      goto LABEL_60;
    if (uu == 17)
    {
      v59 = __nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null other_protocol";
      goto LABEL_177;
    }
    if (!(_BYTE)v112)
    {
      v59 = __nwlog_obj();
      v60 = uu;
      if (!os_log_type_enabled(v59, (os_log_type_t)uu))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v117 = "nw_protocol_http_connect_connected";
      v34 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_177;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v59 = __nwlog_obj();
    v60 = uu;
    v70 = os_log_type_enabled(v59, (os_log_type_t)uu);
    if (backtrace_string)
    {
      if (!v70)
        goto LABEL_130;
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      v118 = 2082;
      v119 = backtrace_string;
      v68 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_129;
    }
    if (!v70)
      goto LABEL_60;
    *(_DWORD *)buf = 136446210;
    v117 = "nw_protocol_http_connect_connected";
    v34 = "%{public}s called with null other_protocol, no backtrace";
LABEL_177:
    v39 = v59;
    v40 = v60;
    v41 = 12;
LABEL_59:
    _os_log_impl(&dword_182FBE000, v39, v40, v34, buf, v41);
LABEL_60:
    if (!v31)
      return;
    goto LABEL_61;
  }
  if (a1->output_handler != a2)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        connected = (void (*)(nw_protocol *, nw_protocol *))callbacks->connected;
        if (connected)
        {
          v8 = a2;
LABEL_10:
          connected(default_input_handler, v8);
          return;
        }
      }
    }
    __nwlog_obj();
    v48 = a1->default_input_handler;
    v49 = "invalid";
    if (v48)
    {
      identifier = v48->identifier;
      if (identifier)
        v49 = (const char *)identifier;
    }
    *(_DWORD *)buf = 136446466;
    v117 = "nw_protocol_http_connect_connected";
    v118 = 2082;
    v119 = (char *)v49;
    v51 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    LOBYTE(v112) = 0;
    if (__nwlog_fault(v51, &uu, &v112))
    {
      if (uu == 17)
      {
        v52 = __nwlog_obj();
        v53 = uu;
        if (!os_log_type_enabled(v52, (os_log_type_t)uu))
          goto LABEL_163;
        v54 = a1->default_input_handler;
        v55 = "invalid";
        if (v54)
        {
          v56 = v54->identifier;
          if (v56)
            v55 = (const char *)v56;
        }
LABEL_94:
        *(_DWORD *)buf = 136446466;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = (char *)v55;
        v57 = "%{public}s protocol %{public}s has invalid connected callback";
LABEL_162:
        _os_log_impl(&dword_182FBE000, v52, v53, v57, buf, 0x16u);
        goto LABEL_163;
      }
      if ((_BYTE)v112)
      {
        v61 = (char *)__nw_create_backtrace_string();
        v52 = __nwlog_obj();
        v53 = uu;
        v62 = os_log_type_enabled(v52, (os_log_type_t)uu);
        if (v61)
        {
          if (v62)
          {
            v63 = a1->default_input_handler;
            v64 = "invalid";
            if (v63)
            {
              v65 = v63->identifier;
              if (v65)
                v64 = (const char *)v65;
            }
            *(_DWORD *)buf = 136446722;
            v117 = "nw_protocol_http_connect_connected";
            v118 = 2082;
            v119 = (char *)v64;
            v120 = 2082;
            v121 = v61;
            _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v61);
          goto LABEL_163;
        }
        if (!v62)
          goto LABEL_163;
        v89 = a1->default_input_handler;
        v90 = "invalid";
        if (v89)
        {
          v91 = v89->identifier;
          if (v91)
            v90 = (const char *)v91;
        }
LABEL_161:
        *(_DWORD *)buf = 136446466;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = (char *)v90;
        v57 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
        goto LABEL_162;
      }
      v52 = __nwlog_obj();
      v53 = uu;
      if (!os_log_type_enabled(v52, (os_log_type_t)uu))
        goto LABEL_163;
      v71 = a1->default_input_handler;
      v72 = "invalid";
      if (v71)
      {
        v73 = v71->identifier;
        if (v73)
          v72 = (const char *)v73;
      }
LABEL_136:
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      v118 = 2082;
      v119 = (char *)v72;
      v57 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
      goto LABEL_162;
    }
    goto LABEL_163;
  }
  v9 = *((_WORD *)handle + 184);
  *((_WORD *)handle + 184) = v9 | 0x10;
  switch(*((_DWORD *)handle + 70))
  {
    case 0:
      if ((v9 & 1) == 0)
        goto LABEL_79;
      path = nw_protocol_http_connect_get_path((nw_protocol *)(handle + 24));
      if (path)
      {
        v11 = path;
        v12 = v11->parameters;

        if (v12)
        {
          v13 = nw_parameters_copy_context(v12);
          if (v13)
          {
            v14 = v13;
            v15 = (NWConcrete_nw_path_flow_registration *)nw_path_copy_flow_registration(v13, (uint64_t)(handle + 24));
            if (!v15)
            {
              if ((*((_WORD *)handle + 184) & 0x80) == 0)
              {
                v43 = __nwlog_obj();
                if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  v117 = "nw_http_connect_keep_path_flow_registration_open";
                  v118 = 2082;
                  v119 = handle + 284;
                  v120 = 2080;
                  v121 = " ";
                  _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sUnable to copy flow registration", buf, 0x20u);
                }
              }
              goto LABEL_78;
            }
            v16 = v15;
            uu = 0uLL;
            v115 = 0;
            if (nw_path_flow_registration_get_nexus_instance(v11, v15, &uu, &v115))
            {
              v114 = 0;
              nexus_key = nw_path_flow_registration_get_nexus_key(v11, v16, &v114);
              v113 = 16;
              can_support_user_packet_pool = nw_path_flow_registration_can_support_user_packet_pool(v11, v16);
              if (nw_path_flow_registration_should_use_event_ring(v11, v16))
                v19 = 2;
              else
                v19 = 0;
              BYTE4(v113) = v19 | can_support_user_packet_pool;
              v112 = nexus_key;
              v20 = nw_channel_create_with_attributes(v14, (unsigned __int8 *)&uu, v115, (uint64_t)&v112);
              if (v20)
              {
                v21 = (void *)v20;
                nw_channel_set_keep_path_flow_registration_open(v20, v16);
                os_release(v21);
LABEL_77:
                os_release(v16);
LABEL_78:
                os_release(v14);
                os_release(v12);
                goto LABEL_79;
              }
              if ((*((_WORD *)handle + 184) & 0x80) != 0)
                goto LABEL_77;
              v44 = __nwlog_obj();
              if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                goto LABEL_77;
              *(_DWORD *)buf = 136446722;
              v117 = "nw_http_connect_keep_path_flow_registration_open";
              v118 = 2082;
              v119 = handle + 284;
              v120 = 2080;
              v121 = " ";
              v45 = "%{public}s %{public}s%sUnable to get channel";
            }
            else
            {
              if ((*((_WORD *)handle + 184) & 0x80) != 0)
                goto LABEL_77;
              v44 = __nwlog_obj();
              if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                goto LABEL_77;
              *(_DWORD *)buf = 136446722;
              v117 = "nw_http_connect_keep_path_flow_registration_open";
              v118 = 2082;
              v119 = handle + 284;
              v120 = 2080;
              v121 = " ";
              v45 = "%{public}s %{public}s%sUnable to get nexus instance";
            }
            _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, v45, buf, 0x20u);
            goto LABEL_77;
          }
          os_release(v12);
          if ((*((_WORD *)handle + 184) & 0x80) == 0)
          {
            v37 = __nwlog_obj();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              v117 = "nw_http_connect_keep_path_flow_registration_open";
              v118 = 2082;
              v119 = handle + 284;
              v120 = 2080;
              v121 = " ";
              v38 = "%{public}s %{public}s%sUnable to get context";
              goto LABEL_66;
            }
          }
LABEL_79:
          v46 = mach_continuous_time();
          if (v46 <= 1)
            v47 = 1;
          else
            v47 = v46;
          *(_QWORD *)handle = v47;
          *((_DWORD *)handle + 70) = 1;
          v25 = (uint64_t)handle;
          v22 = 0;
          goto LABEL_83;
        }
        if ((*((_WORD *)handle + 184) & 0x80) != 0)
          goto LABEL_79;
        v37 = __nwlog_obj();
        if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          goto LABEL_79;
        *(_DWORD *)buf = 136446722;
        v117 = "nw_http_connect_keep_path_flow_registration_open";
        v118 = 2082;
        v119 = handle + 284;
        v120 = 2080;
        v121 = " ";
        v38 = "%{public}s %{public}s%sUnable to get parameters";
      }
      else
      {
        if ((*((_WORD *)handle + 184) & 0x80) != 0)
          goto LABEL_79;
        v37 = __nwlog_obj();
        if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          goto LABEL_79;
        *(_DWORD *)buf = 136446722;
        v117 = "nw_http_connect_keep_path_flow_registration_open";
        v118 = 2082;
        v119 = handle + 284;
        v120 = 2080;
        v121 = " ";
        v38 = "%{public}s %{public}s%sUnable to get path";
      }
LABEL_66:
      _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_ERROR, v38, buf, 0x20u);
      goto LABEL_79;
    case 1:
      v22 = (const void *)*((_QWORD *)handle + 26);
      v23 = v9 & 8;
      if (v22)
        v24 = v23 == 0;
      else
        v24 = 0;
      if (v24)
      {
        v25 = (uint64_t)handle;
LABEL_83:
        if ((nw_http_connect_send_request(v25, v22) & 1) == 0)
          nw_http_connect_fail((uint64_t)handle, 22);
      }
      return;
    case 2:
      v26 = a1->default_input_handler;
      if (v26)
      {
        v27 = v26->callbacks;
        if (v27)
        {
          v28 = (void (*)(void))v27->connected;
          if (v28)
          {
            v28();
            goto LABEL_34;
          }
        }
      }
      __nwlog_obj();
      v74 = a1->default_input_handler;
      v75 = "invalid";
      if (v74)
      {
        v76 = v74->identifier;
        if (v76)
          v75 = (const char *)v76;
      }
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      v118 = 2082;
      v119 = (char *)v75;
      v77 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(uu) = 16;
      LOBYTE(v112) = 0;
      if (!__nwlog_fault(v77, &uu, &v112))
        goto LABEL_211;
      if (uu == 17)
      {
        v78 = __nwlog_obj();
        v79 = uu;
        if (!os_log_type_enabled(v78, (os_log_type_t)uu))
          goto LABEL_211;
        v80 = a1->default_input_handler;
        v81 = "invalid";
        if (v80)
        {
          v82 = v80->identifier;
          if (v82)
            v81 = (const char *)v82;
        }
        *(_DWORD *)buf = 136446466;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = (char *)v81;
        v83 = "%{public}s protocol %{public}s has invalid connected callback";
LABEL_210:
        _os_log_impl(&dword_182FBE000, v78, v79, v83, buf, 0x16u);
        goto LABEL_211;
      }
      if (!(_BYTE)v112)
      {
        v78 = __nwlog_obj();
        v79 = uu;
        if (!os_log_type_enabled(v78, (os_log_type_t)uu))
          goto LABEL_211;
        v102 = a1->default_input_handler;
        v103 = "invalid";
        if (v102)
        {
          v104 = v102->identifier;
          if (v104)
            v103 = (const char *)v104;
        }
        *(_DWORD *)buf = 136446466;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = (char *)v103;
        v83 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_210;
      }
      v92 = (char *)__nw_create_backtrace_string();
      v78 = __nwlog_obj();
      v79 = uu;
      v93 = os_log_type_enabled(v78, (os_log_type_t)uu);
      if (!v92)
      {
        if (!v93)
          goto LABEL_211;
        v107 = a1->default_input_handler;
        v108 = "invalid";
        if (v107)
        {
          v109 = v107->identifier;
          if (v109)
            v108 = (const char *)v109;
        }
        *(_DWORD *)buf = 136446466;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = (char *)v108;
        v83 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
        goto LABEL_210;
      }
      if (v93)
      {
        v94 = a1->default_input_handler;
        v95 = "invalid";
        if (v94)
        {
          v96 = v94->identifier;
          if (v96)
            v95 = (const char *)v96;
        }
        *(_DWORD *)buf = 136446722;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = (char *)v95;
        v120 = 2082;
        v121 = v92;
        _os_log_impl(&dword_182FBE000, v78, v79, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v92);
LABEL_211:
      if (v77)
        free(v77);
LABEL_34:
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        v29 = default_input_handler->callbacks;
        if (v29)
        {
          connected = (void (*)(nw_protocol *, nw_protocol *))v29->connected;
          if (connected)
          {
            v8 = a1;
            goto LABEL_10;
          }
        }
      }
      __nwlog_obj();
      v84 = a1->default_input_handler;
      v85 = "invalid";
      if (v84)
      {
        v86 = v84->identifier;
        if (v86)
          v85 = (const char *)v86;
      }
      *(_DWORD *)buf = 136446466;
      v117 = "nw_protocol_http_connect_connected";
      v118 = 2082;
      v119 = (char *)v85;
      v51 = (const char *)_os_log_send_and_compose_impl();
      LOBYTE(uu) = 16;
      LOBYTE(v112) = 0;
      if (__nwlog_fault(v51, &uu, &v112))
      {
        if (uu == 17)
        {
          v52 = __nwlog_obj();
          v53 = uu;
          if (!os_log_type_enabled(v52, (os_log_type_t)uu))
            goto LABEL_163;
          v87 = a1->default_input_handler;
          v55 = "invalid";
          if (v87)
          {
            v88 = v87->identifier;
            if (v88)
              v55 = (const char *)v88;
          }
          goto LABEL_94;
        }
        if (!(_BYTE)v112)
        {
          v52 = __nwlog_obj();
          v53 = uu;
          if (!os_log_type_enabled(v52, (os_log_type_t)uu))
            goto LABEL_163;
          v105 = a1->default_input_handler;
          v72 = "invalid";
          if (v105)
          {
            v106 = v105->identifier;
            if (v106)
              v72 = (const char *)v106;
          }
          goto LABEL_136;
        }
        v97 = (char *)__nw_create_backtrace_string();
        v52 = __nwlog_obj();
        v53 = uu;
        v98 = os_log_type_enabled(v52, (os_log_type_t)uu);
        if (v97)
        {
          if (v98)
          {
            v99 = a1->default_input_handler;
            v100 = "invalid";
            if (v99)
            {
              v101 = v99->identifier;
              if (v101)
                v100 = (const char *)v101;
            }
            *(_DWORD *)buf = 136446722;
            v117 = "nw_protocol_http_connect_connected";
            v118 = 2082;
            v119 = (char *)v100;
            v120 = 2082;
            v121 = v97;
            _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v97);
          if (v51)
            goto LABEL_164;
          return;
        }
        if (v98)
        {
          v110 = a1->default_input_handler;
          v90 = "invalid";
          if (v110)
          {
            v111 = v110->identifier;
            if (v111)
              v90 = (const char *)v111;
          }
          goto LABEL_161;
        }
      }
LABEL_163:
      if (v51)
      {
LABEL_164:
        v42 = (char *)v51;
        goto LABEL_62;
      }
      return;
    case 3:
      if ((v9 & 0x80) != 0)
        return;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = handle + 284;
      *(_DWORD *)buf = 136446722;
      v117 = "nw_protocol_http_connect_connected";
      v118 = 2082;
      v119 = handle + 284;
      v120 = 2080;
      v121 = " ";
      v31 = (const char *)_os_log_send_and_compose_impl();
      LOBYTE(uu) = 16;
      LOBYTE(v112) = 0;
      if (!__nwlog_fault(v31, &uu, &v112))
        goto LABEL_60;
      if (uu == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = gLogObj;
        v33 = uu;
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu))
          goto LABEL_60;
        *(_DWORD *)buf = 136446722;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = v30;
        v120 = 2080;
        v121 = " ";
        v34 = "%{public}s %{public}s%shttp connect state is failed";
LABEL_58:
        v39 = v32;
        v40 = v33;
        v41 = 32;
        goto LABEL_59;
      }
      if (!(_BYTE)v112)
      {
        v32 = __nwlog_obj();
        v33 = uu;
        if (!os_log_type_enabled(v32, (os_log_type_t)uu))
          goto LABEL_60;
        *(_DWORD *)buf = 136446722;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = v30;
        v120 = 2080;
        v121 = " ";
        v34 = "%{public}s %{public}s%shttp connect state is failed, backtrace limit exceeded";
        goto LABEL_58;
      }
      v35 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = gLogObj;
      v33 = uu;
      v36 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)uu);
      if (!v35)
      {
        if (!v36)
          goto LABEL_60;
        *(_DWORD *)buf = 136446722;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = v30;
        v120 = 2080;
        v121 = " ";
        v34 = "%{public}s %{public}s%shttp connect state is failed, no backtrace";
        goto LABEL_58;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446978;
        v117 = "nw_protocol_http_connect_connected";
        v118 = 2082;
        v119 = v30;
        v120 = 2080;
        v121 = " ";
        v122 = 2082;
        v123 = v35;
        _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s %{public}s%shttp connect state is failed, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v35);
      break;
    default:
      return;
  }
  goto LABEL_60;
}

void nw_protocol_http_connect_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  _WORD *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*disconnected)(void);
  nw_protocol *v8;
  const char *v9;
  nw_protocol_identifier *identifier;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  nw_protocol *v14;
  const char *v15;
  nw_protocol_identifier *v16;
  const char *v17;
  nw_protocol *v18;
  nw_protocol_callbacks *v19;
  nw_protocol *v20;
  nw_protocol_callbacks *v21;
  nw_protocol *v22;
  const char *v23;
  nw_protocol_identifier *v24;
  const char *v25;
  NSObject *v26;
  os_log_type_t v27;
  nw_protocol *v28;
  const char *v29;
  nw_protocol_identifier *v30;
  const char *v31;
  nw_protocol *v32;
  const char *v33;
  nw_protocol_identifier *v34;
  nw_protocol *v35;
  nw_protocol_identifier *v36;
  NSObject *v37;
  const char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  nw_protocol *v44;
  const char *v45;
  nw_protocol_identifier *v46;
  char *backtrace_string;
  _BOOL4 v48;
  char *v49;
  _BOOL4 v50;
  const char *v51;
  _BOOL4 v52;
  char *v53;
  _BOOL4 v54;
  nw_protocol *v55;
  const char *v56;
  nw_protocol_identifier *v57;
  nw_protocol *v58;
  const char *v59;
  nw_protocol_identifier *v60;
  nw_protocol *v61;
  const char *v62;
  nw_protocol_identifier *v63;
  nw_protocol *v64;
  nw_protocol_identifier *v65;
  char *v66;
  _BOOL4 v67;
  nw_protocol *v68;
  const char *v69;
  nw_protocol_identifier *v70;
  char *v71;
  nw_protocol *v72;
  nw_protocol_identifier *v73;
  nw_protocol *v74;
  const char *v75;
  nw_protocol_identifier *v76;
  nw_protocol *v77;
  const char *v78;
  nw_protocol_identifier *v79;
  char v80;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v83;
  __int16 v84;
  void *v85;
  __int16 v86;
  char *v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    v37 = __nwlog_obj();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v83 = "nw_protocol_http_connect_disconnected";
    v38 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (!__nwlog_fault(v38, &type, &v80))
      goto LABEL_132;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      v41 = "%{public}s called with null protocol";
    }
    else if (v80)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v39 = __nwlog_obj();
      v40 = type;
      v48 = os_log_type_enabled(v39, type);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          v83 = "nw_protocol_http_connect_disconnected";
          v84 = 2082;
          v85 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_132:
        if (!v38)
          return;
        goto LABEL_133;
      }
      if (!v48)
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      v41 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      v41 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_131;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v83 = "nw_protocol_http_connect_disconnected";
    v38 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (!__nwlog_fault(v38, &type, &v80))
      goto LABEL_132;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v80)
      {
        v39 = __nwlog_obj();
        v40 = type;
        if (!os_log_type_enabled(v39, type))
          goto LABEL_132;
        *(_DWORD *)buf = 136446210;
        v83 = "nw_protocol_http_connect_disconnected";
        v41 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_131;
      }
      v49 = (char *)__nw_create_backtrace_string();
      v39 = __nwlog_obj();
      v40 = type;
      v50 = os_log_type_enabled(v39, type);
      if (!v49)
      {
        if (!v50)
          goto LABEL_132;
        *(_DWORD *)buf = 136446210;
        v83 = "nw_protocol_http_connect_disconnected";
        v41 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_131;
      }
      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = v49;
        v51 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_84:
        _os_log_impl(&dword_182FBE000, v39, v40, v51, buf, 0x16u);
      }
LABEL_85:
      free(v49);
      if (!v38)
        return;
LABEL_133:
      v71 = (char *)v38;
LABEL_142:
      free(v71);
      return;
    }
    v39 = __nwlog_obj();
    v40 = type;
    if (!os_log_type_enabled(v39, type))
      goto LABEL_132;
    *(_DWORD *)buf = 136446210;
    v83 = "nw_protocol_http_connect_disconnected";
    v41 = "%{public}s called with null http_connect";
LABEL_131:
    _os_log_impl(&dword_182FBE000, v39, v40, v41, buf, 0xCu);
    goto LABEL_132;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v83 = "nw_protocol_http_connect_disconnected";
    v38 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v80 = 0;
    if (!__nwlog_fault(v38, &type, &v80))
      goto LABEL_132;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      v41 = "%{public}s called with null other_protocol";
      goto LABEL_131;
    }
    if (!v80)
    {
      v39 = __nwlog_obj();
      v40 = type;
      if (!os_log_type_enabled(v39, type))
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      v41 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_131;
    }
    v49 = (char *)__nw_create_backtrace_string();
    v39 = __nwlog_obj();
    v40 = type;
    v52 = os_log_type_enabled(v39, type);
    if (!v49)
    {
      if (!v52)
        goto LABEL_132;
      *(_DWORD *)buf = 136446210;
      v83 = "nw_protocol_http_connect_disconnected";
      v41 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_131;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      v83 = "nw_protocol_http_connect_disconnected";
      v84 = 2082;
      v85 = v49;
      v51 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_84;
    }
    goto LABEL_85;
  }
  if (*((_DWORD *)handle + 70) == 1)
  {
    if (a1->output_handler != a2)
    {
      default_input_handler = a1->default_input_handler;
      if (!default_input_handler
        || (callbacks = default_input_handler->callbacks) == 0
        || (disconnected = (void (*)(void))callbacks->disconnected) == 0)
      {
        __nwlog_obj();
        v8 = a1->default_input_handler;
        v9 = "invalid";
        if (v8)
        {
          identifier = v8->identifier;
          if (identifier)
            v9 = (const char *)identifier;
        }
        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v9;
        v11 = (const char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v80 = 0;
        if (!__nwlog_fault(v11, &type, &v80))
          goto LABEL_140;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v12 = __nwlog_obj();
          v13 = type;
          if (!os_log_type_enabled(v12, type))
            goto LABEL_140;
          v14 = a1->default_input_handler;
          v15 = "invalid";
          if (v14)
          {
            v16 = v14->identifier;
            if (v16)
              v15 = (const char *)v16;
          }
LABEL_19:
          *(_DWORD *)buf = 136446466;
          v83 = "nw_protocol_http_connect_disconnected";
          v84 = 2082;
          v85 = (void *)v15;
          v17 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_139:
          _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
          goto LABEL_140;
        }
        if (v80)
        {
          v53 = (char *)__nw_create_backtrace_string();
          v12 = __nwlog_obj();
          v13 = type;
          v54 = os_log_type_enabled(v12, type);
          if (v53)
          {
            if (v54)
            {
              v55 = a1->default_input_handler;
              v56 = "invalid";
              if (v55)
              {
                v57 = v55->identifier;
                if (v57)
                  v56 = (const char *)v57;
              }
              *(_DWORD *)buf = 136446722;
              v83 = "nw_protocol_http_connect_disconnected";
              v84 = 2082;
              v85 = (void *)v56;
              v86 = 2082;
              v87 = v53;
              _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v53);
            if (v11)
              goto LABEL_141;
            return;
          }
          if (v54)
          {
            v72 = a1->default_input_handler;
            v62 = "invalid";
            if (v72)
            {
              v73 = v72->identifier;
              if (v73)
                v62 = (const char *)v73;
            }
LABEL_138:
            *(_DWORD *)buf = 136446466;
            v83 = "nw_protocol_http_connect_disconnected";
            v84 = 2082;
            v85 = (void *)v62;
            v17 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
            goto LABEL_139;
          }
          goto LABEL_140;
        }
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
          goto LABEL_140;
        v64 = a1->default_input_handler;
        v59 = "invalid";
        if (v64)
        {
          v65 = v64->identifier;
          if (v65)
            v59 = (const char *)v65;
        }
LABEL_100:
        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v59;
        v17 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_139;
      }
LABEL_23:
      disconnected();
      return;
    }
    handle[184] = handle[184] & 0xFFC7 | 0x20;
    if ((nw_http_connect_restart_after_disconnect((uint64_t)handle) & 1) != 0)
      return;
    v20 = a1->default_input_handler;
    if (v20)
    {
      v21 = v20->callbacks;
      if (v21)
      {
        disconnected = (void (*)(void))v21->disconnected;
        if (disconnected)
          goto LABEL_23;
      }
    }
    __nwlog_obj();
    v22 = a1->default_input_handler;
    v23 = "invalid";
    if (v22)
    {
      v24 = v22->identifier;
      if (v24)
        v23 = (const char *)v24;
    }
    *(_DWORD *)buf = 136446466;
    v83 = "nw_protocol_http_connect_disconnected";
    v84 = 2082;
    v85 = (void *)v23;
    type = OS_LOG_TYPE_ERROR;
    v80 = 0;
    v25 = (const char *)_os_log_send_and_compose_impl();
    if (__nwlog_fault(v25, &type, &v80))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_154;
        v28 = a1->default_input_handler;
        v29 = "invalid";
        if (v28)
        {
          v30 = v28->identifier;
          if (v30)
            v29 = (const char *)v30;
        }
        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v29;
        v31 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_153:
        _os_log_impl(&dword_182FBE000, v26, v27, v31, buf, 0x16u);
        goto LABEL_154;
      }
      if (!v80)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_154;
        v74 = a1->default_input_handler;
        v75 = "invalid";
        if (v74)
        {
          v76 = v74->identifier;
          if (v76)
            v75 = (const char *)v76;
        }
        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v75;
        v31 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_153;
      }
      v66 = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v67 = os_log_type_enabled(v26, type);
      if (!v66)
      {
        if (!v67)
          goto LABEL_154;
        v77 = a1->default_input_handler;
        v78 = "invalid";
        if (v77)
        {
          v79 = v77->identifier;
          if (v79)
            v78 = (const char *)v79;
        }
        *(_DWORD *)buf = 136446466;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v78;
        v31 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
        goto LABEL_153;
      }
      if (v67)
      {
        v68 = a1->default_input_handler;
        v69 = "invalid";
        if (v68)
        {
          v70 = v68->identifier;
          if (v70)
            v69 = (const char *)v70;
        }
        *(_DWORD *)buf = 136446722;
        v83 = "nw_protocol_http_connect_disconnected";
        v84 = 2082;
        v85 = (void *)v69;
        v86 = 2082;
        v87 = v66;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v66);
    }
LABEL_154:
    if (v25)
    {
      v71 = (char *)v25;
      goto LABEL_142;
    }
    return;
  }
  v18 = a1->default_input_handler;
  if (v18)
  {
    v19 = v18->callbacks;
    if (v19)
    {
      disconnected = (void (*)(void))v19->disconnected;
      if (disconnected)
        goto LABEL_23;
    }
  }
  __nwlog_obj();
  v32 = a1->default_input_handler;
  v33 = "invalid";
  if (v32)
  {
    v34 = v32->identifier;
    if (v34)
      v33 = (const char *)v34;
  }
  *(_DWORD *)buf = 136446466;
  v83 = "nw_protocol_http_connect_disconnected";
  v84 = 2082;
  v85 = (void *)v33;
  v11 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v80 = 0;
  if (!__nwlog_fault(v11, &type, &v80))
    goto LABEL_140;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_140;
    v35 = a1->default_input_handler;
    v15 = "invalid";
    if (v35)
    {
      v36 = v35->identifier;
      if (v36)
        v15 = (const char *)v36;
    }
    goto LABEL_19;
  }
  if (!v80)
  {
    v12 = __nwlog_obj();
    v13 = type;
    if (!os_log_type_enabled(v12, type))
      goto LABEL_140;
    v58 = a1->default_input_handler;
    v59 = "invalid";
    if (v58)
    {
      v60 = v58->identifier;
      if (v60)
        v59 = (const char *)v60;
    }
    goto LABEL_100;
  }
  v42 = (char *)__nw_create_backtrace_string();
  v12 = __nwlog_obj();
  v13 = type;
  v43 = os_log_type_enabled(v12, type);
  if (!v42)
  {
    if (!v43)
      goto LABEL_140;
    v61 = a1->default_input_handler;
    v62 = "invalid";
    if (v61)
    {
      v63 = v61->identifier;
      if (v63)
        v62 = (const char *)v63;
    }
    goto LABEL_138;
  }
  if (v43)
  {
    v44 = a1->default_input_handler;
    v45 = "invalid";
    if (v44)
    {
      v46 = v44->identifier;
      if (v46)
        v45 = (const char *)v46;
    }
    *(_DWORD *)buf = 136446722;
    v83 = "nw_protocol_http_connect_disconnected";
    v84 = 2082;
    v85 = (void *)v45;
    v86 = 2082;
    v87 = v42;
    _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
  }
  free(v42);
LABEL_140:
  if (v11)
  {
LABEL_141:
    v71 = (char *)v11;
    goto LABEL_142;
  }
}

void nw_protocol_http_connect_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  _WORD *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*error)(void);
  nw_protocol *v8;
  const char *v9;
  nw_protocol_identifier *identifier;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  nw_protocol *v14;
  const char *v15;
  nw_protocol_identifier *v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  _BOOL4 v21;
  nw_protocol *v22;
  const char *v23;
  nw_protocol_identifier *v24;
  char *backtrace_string;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  _BOOL4 v29;
  NSObject *v30;
  nw_protocol *v31;
  const char *v32;
  nw_protocol_identifier *v33;
  nw_protocol *v34;
  const char *v35;
  nw_protocol_identifier *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint32_t v39;
  char v40;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  char *v45;
  __int16 v46;
  const char *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http_connect_error";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v11, &type, &v40))
      goto LABEL_86;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http_connect_error";
      v17 = "%{public}s called with null protocol";
LABEL_84:
      v37 = v18;
      v38 = v19;
      v39 = 12;
      goto LABEL_85;
    }
    if (!v40)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http_connect_error";
      v17 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_84;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v26 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v26)
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http_connect_error";
      v17 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_84;
    }
    if (!v26)
      goto LABEL_57;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_http_connect_error";
    v44 = 2082;
    v45 = backtrace_string;
    v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_56:
    _os_log_impl(&dword_182FBE000, v18, v19, v27, buf, 0x16u);
    goto LABEL_57;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http_connect_error";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v11, &type, &v40))
      goto LABEL_86;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http_connect_error";
      v17 = "%{public}s called with null http_connect";
      goto LABEL_84;
    }
    if (!v40)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http_connect_error";
      v17 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_84;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v28 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_86;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http_connect_error";
      v17 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_84;
    }
    if (!v28)
      goto LABEL_57;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_http_connect_error";
    v44 = 2082;
    v45 = backtrace_string;
    v27 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
    goto LABEL_56;
  }
  if (a2)
  {
    if (!a3)
    {
      if ((handle[184] & 0x80) == 0)
      {
        if (gLogDatapath)
        {
          v30 = __nwlog_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v43 = "nw_protocol_http_connect_error";
            v44 = 2082;
            v45 = (char *)(handle + 142);
            v46 = 2080;
            v47 = " ";
            _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%ssuppressing error 0", buf, 0x20u);
          }
        }
      }
      return;
    }
    if (*((_DWORD *)handle + 70) == 1 && a1->output_handler == a2)
      return;
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        error = (void (*)(void))callbacks->error;
        if (error)
        {
          error();
          return;
        }
      }
    }
    __nwlog_obj();
    v8 = a1->default_input_handler;
    v9 = "invalid";
    if (v8)
    {
      identifier = v8->identifier;
      if (identifier)
        v9 = (const char *)identifier;
    }
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_http_connect_error";
    v44 = 2082;
    v45 = (char *)v9;
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v11, &type, &v40))
      goto LABEL_86;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_86;
      v14 = a1->default_input_handler;
      v15 = "invalid";
      if (v14)
      {
        v16 = v14->identifier;
        if (v16)
          v15 = (const char *)v16;
      }
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http_connect_error";
      v44 = 2082;
      v45 = (char *)v15;
      v17 = "%{public}s protocol %{public}s has invalid error callback";
    }
    else if (v40)
    {
      v20 = (char *)__nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v21 = os_log_type_enabled(v12, type);
      if (v20)
      {
        if (v21)
        {
          v22 = a1->default_input_handler;
          v23 = "invalid";
          if (v22)
          {
            v24 = v22->identifier;
            if (v24)
              v23 = (const char *)v24;
          }
          *(_DWORD *)buf = 136446722;
          v43 = "nw_protocol_http_connect_error";
          v44 = 2082;
          v45 = (char *)v23;
          v46 = 2082;
          v47 = v20;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v20);
LABEL_86:
        if (v11)
          goto LABEL_87;
        return;
      }
      if (!v21)
        goto LABEL_86;
      v34 = a1->default_input_handler;
      v35 = "invalid";
      if (v34)
      {
        v36 = v34->identifier;
        if (v36)
          v35 = (const char *)v36;
      }
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http_connect_error";
      v44 = 2082;
      v45 = (char *)v35;
      v17 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
    }
    else
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_86;
      v31 = a1->default_input_handler;
      v32 = "invalid";
      if (v31)
      {
        v33 = v31->identifier;
        if (v33)
          v32 = (const char *)v33;
      }
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http_connect_error";
      v44 = 2082;
      v45 = (char *)v32;
      v17 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
    }
    v37 = v12;
    v38 = v13;
    v39 = 22;
LABEL_85:
    _os_log_impl(&dword_182FBE000, v37, v38, v17, buf, v39);
    goto LABEL_86;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v43 = "nw_protocol_http_connect_error";
  v11 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (!__nwlog_fault(v11, &type, &v40))
    goto LABEL_86;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v18 = __nwlog_obj();
    v19 = type;
    if (!os_log_type_enabled(v18, type))
      goto LABEL_86;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http_connect_error";
    v17 = "%{public}s called with null other_protocol";
    goto LABEL_84;
  }
  if (!v40)
  {
    v18 = __nwlog_obj();
    v19 = type;
    if (!os_log_type_enabled(v18, type))
      goto LABEL_86;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http_connect_error";
    v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
    goto LABEL_84;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  v18 = __nwlog_obj();
  v19 = type;
  v29 = os_log_type_enabled(v18, type);
  if (!backtrace_string)
  {
    if (!v29)
      goto LABEL_86;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http_connect_error";
    v17 = "%{public}s called with null other_protocol, no backtrace";
    goto LABEL_84;
  }
  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_http_connect_error";
    v44 = 2082;
    v45 = backtrace_string;
    v27 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_56;
  }
LABEL_57:
  free(backtrace_string);
  if (v11)
LABEL_87:
    free(v11);
}

uint64_t nw_protocol_http_connect_copy_info(uint64_t a1, int a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t v6;
  id v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  NWConcrete_nw_protocol_establishment_report *v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(void);
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *backtrace_string;
  _BOOL4 v22;
  const char *v23;
  _BOOL4 v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http_connect_copy_info";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v17, &type, &v25))
      goto LABEL_56;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (!os_log_type_enabled(v18, type))
          goto LABEL_56;
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_connect_copy_info";
        v20 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_55;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v22 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (!v22)
          goto LABEL_56;
        *(_DWORD *)buf = 136446210;
        v28 = "nw_protocol_http_connect_copy_info";
        v20 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_55;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        v28 = "nw_protocol_http_connect_copy_info";
        v29 = 2082;
        v30 = backtrace_string;
        v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_45:
        _os_log_impl(&dword_182FBE000, v18, v19, v23, buf, 0x16u);
      }
LABEL_46:
      free(backtrace_string);
      goto LABEL_56;
    }
    v18 = __nwlog_obj();
    v19 = type;
    if (!os_log_type_enabled(v18, type))
      goto LABEL_56;
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http_connect_copy_info";
    v20 = "%{public}s called with null protocol";
LABEL_55:
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
LABEL_56:
    if (v17)
      free(v17);
    return 0;
  }
  v2 = *(uint64_t **)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http_connect_copy_info";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v17, &type, &v25))
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http_connect_copy_info";
      v20 = "%{public}s called with null http_connect";
      goto LABEL_55;
    }
    if (!v25)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v28 = "nw_protocol_http_connect_copy_info";
      v20 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v24 = os_log_type_enabled(v18, type);
    if (backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v28 = "nw_protocol_http_connect_copy_info";
        v29 = 2082;
        v30 = backtrace_string;
        v23 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    if (!v24)
      goto LABEL_56;
    *(_DWORD *)buf = 136446210;
    v28 = "nw_protocol_http_connect_copy_info";
    v20 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_55;
  }
  if (a2 == 254 && *v2 && v2[1] && v2[2])
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (!v3 || (v4 = *(_QWORD *)(v3 + 24)) == 0 || (v5 = *(uint64_t (**)(void))(v4 + 224)) == 0 || (v6 = v5()) == 0)
      v6 = nw_array_create();
    if (nw_proxy_copy_http_connect_definition::onceToken != -1)
      dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_92);
    v7 = (id)nw_proxy_copy_http_connect_definition::proxy_definition;
    v8 = nw_delta_nanos(*v2, v2[1]);
    if (v8 <= 0xF423FFFFFFFFFLL)
      v9 = (v8 / 0xF4240);
    else
      v9 = 0xFFFFFFFFLL;
    v10 = nw_delta_nanos(*v2, v2[2]);
    if (v10 <= 0xF423FFFFFFFFFLL)
      v11 = (v10 / 0xF4240);
    else
      v11 = 0xFFFFFFFFLL;
    v12 = nw_protocol_establishment_report_create(v7, v9, v11);
    if (v7)
      os_release(v7);
    nw_array_append(v6, v12);
    if (v12)
      os_release(v12);
    return v6;
  }
  v14 = *(_QWORD *)(a1 + 32);
  if (!v14)
    return 0;
  v15 = *(_QWORD *)(v14 + 24);
  if (!v15)
    return 0;
  v16 = *(uint64_t (**)(void))(v15 + 224);
  if (!v16)
    return 0;
  return v16();
}

nw_protocol *nw_protocol_http_connect_get_parameters(nw_protocol *a1)
{
  void *handle;
  nw_protocol *result;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_parameters)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_http_connect_get_parameters";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_parameters";
      v9 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v14)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http_connect_get_parameters";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_http_connect_get_parameters";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v6)
          return 0;
        goto LABEL_38;
      }
      if (!v11)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_parameters";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_37;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_http_connect_get_parameters";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_parameters";
      v9 = "%{public}s called with null http_connect";
      goto LABEL_36;
    }
    if (!v14)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_parameters";
      v9 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_36;
    }
    v12 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v13)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_parameters";
      v9 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_36;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_http_connect_get_parameters";
      v18 = 2082;
      v19 = v12;
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v12);
LABEL_37:
    if (!v6)
      return 0;
LABEL_38:
    free(v6);
    return 0;
  }
  result = (nw_protocol *)*((_QWORD *)handle + 14);
  if (!result)
  {
    result = a1->default_input_handler;
    if (result)
    {
      callbacks = result->callbacks;
      if (callbacks)
      {
        get_parameters = (uint64_t (*)(void))callbacks->get_parameters;
        if (get_parameters)
          return (nw_protocol *)get_parameters();
      }
      return 0;
    }
  }
  return result;
}

nw_protocol *nw_protocol_http_connect_get_path(nw_protocol *a1)
{
  void *handle;
  nw_protocol *result;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_path)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_http_connect_get_path";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_path";
      v9 = "%{public}s called with null protocol";
    }
    else
    {
      if (!v14)
      {
        v7 = __nwlog_obj();
        v8 = type;
        if (!os_log_type_enabled(v7, type))
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_http_connect_get_path";
        v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v7 = __nwlog_obj();
      v8 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_http_connect_get_path";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v6)
          return 0;
        goto LABEL_38;
      }
      if (!v11)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_path";
      v9 = "%{public}s called with null protocol, no backtrace";
    }
LABEL_36:
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_37;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_protocol_http_connect_get_path";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (!__nwlog_fault(v6, &type, &v14))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_path";
      v9 = "%{public}s called with null http_connect";
      goto LABEL_36;
    }
    if (!v14)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_path";
      v9 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_36;
    }
    v12 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v13 = os_log_type_enabled(v7, type);
    if (!v12)
    {
      if (!v13)
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v17 = "nw_protocol_http_connect_get_path";
      v9 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_36;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      v17 = "nw_protocol_http_connect_get_path";
      v18 = 2082;
      v19 = v12;
      _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v12);
LABEL_37:
    if (!v6)
      return 0;
LABEL_38:
    free(v6);
    return 0;
  }
  result = (nw_protocol *)*((_QWORD *)handle + 13);
  if (!result)
  {
    result = a1->default_input_handler;
    if (result)
    {
      callbacks = result->callbacks;
      if (callbacks)
      {
        get_path = (uint64_t (*)(void))callbacks->get_path;
        if (get_path)
          return (nw_protocol *)get_path();
      }
      return 0;
    }
  }
  return result;
}

nw_protocol *nw_protocol_http_connect_get_local_endpoint(nw_protocol *a1)
{
  _QWORD *handle;
  nw_protocol *result;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_local_endpoint)(void);
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  const char *v11;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http_connect_get_local_endpoint";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_37;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v13)
      {
        v6 = __nwlog_obj();
        v7 = type;
        if (!os_log_type_enabled(v6, type))
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_http_connect_get_local_endpoint";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = type;
      v10 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v10)
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_http_connect_get_local_endpoint";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        v16 = "nw_protocol_http_connect_get_local_endpoint";
        v17 = 2082;
        v18 = backtrace_string;
        v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
        _os_log_impl(&dword_182FBE000, v6, v7, v11, buf, 0x16u);
      }
LABEL_27:
      free(backtrace_string);
      goto LABEL_37;
    }
    v6 = __nwlog_obj();
    v7 = type;
    if (!os_log_type_enabled(v6, type))
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http_connect_get_local_endpoint";
    v8 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
LABEL_37:
    if (v5)
      free(v5);
    return 0;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http_connect_get_local_endpoint";
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_http_connect_get_local_endpoint";
      v8 = "%{public}s called with null http_connect";
      goto LABEL_36;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      v7 = type;
      if (!os_log_type_enabled(v6, type))
        goto LABEL_37;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_protocol_http_connect_get_local_endpoint";
      v8 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = type;
    v12 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v16 = "nw_protocol_http_connect_get_local_endpoint";
        v17 = 2082;
        v18 = backtrace_string;
        v11 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
        goto LABEL_26;
      }
      goto LABEL_27;
    }
    if (!v12)
      goto LABEL_37;
    *(_DWORD *)buf = 136446210;
    v16 = "nw_protocol_http_connect_get_local_endpoint";
    v8 = "%{public}s called with null http_connect, no backtrace";
    goto LABEL_36;
  }
  if (handle[13])
    return (nw_protocol *)handle[15];
  result = a1->default_input_handler;
  if (result)
  {
    callbacks = result->callbacks;
    if (callbacks)
    {
      get_local_endpoint = (uint64_t (*)(void))callbacks->get_local_endpoint;
      if (get_local_endpoint)
        return (nw_protocol *)get_local_endpoint();
    }
    return 0;
  }
  return result;
}

uint64_t nw_protocol_http_connect_get_remote_endpoint(nw_protocol *a1)
{
  _QWORD *handle;
  uint64_t result;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      result = handle[19];
      if (!result)
        return handle[17];
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_http_connect_get_remote_endpoint";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http_connect_get_remote_endpoint";
        v6 = "%{public}s called with null http_connect";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http_connect_get_remote_endpoint";
        v6 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http_connect_get_remote_endpoint";
        v6 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_http_connect_get_remote_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
      goto LABEL_22;
    }
    goto LABEL_23;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_http_connect_get_remote_endpoint";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_33;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http_connect_get_remote_endpoint";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http_connect_get_remote_endpoint";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_http_connect_get_remote_endpoint";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_22:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_23:
    free(backtrace_string);
    goto LABEL_33;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_http_connect_get_remote_endpoint";
    v6 = "%{public}s called with null protocol";
LABEL_32:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_33:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_http_connect_restart_after_disconnect(uint64_t a1)
{
  __int16 v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  void *v6;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  char *backtrace_string;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  _BOOL4 v16;
  _QWORD v17[5];
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  const char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http_connect_restart_after_disconnect";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18))
      goto LABEL_53;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http_connect_restart_after_disconnect";
      v11 = "%{public}s called with null http_connect";
LABEL_52:
      _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
      goto LABEL_53;
    }
    if (!v18)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_http_connect_restart_after_disconnect";
        v11 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_http_connect_restart_after_disconnect";
        v11 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v13)
      goto LABEL_39;
    *(_DWORD *)buf = 136446466;
    v21 = "nw_http_connect_restart_after_disconnect";
    v22 = 2082;
    v23 = backtrace_string;
    v14 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_38:
    _os_log_impl(&dword_182FBE000, v9, v10, v14, buf, 0x16u);
    goto LABEL_39;
  }
  if (!*(_QWORD *)(a1 + 168))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http_connect_restart_after_disconnect";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (!__nwlog_fault(v8, &type, &v18))
      goto LABEL_53;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v21 = "nw_http_connect_restart_after_disconnect";
      v11 = "%{public}s called with null http_connect->context";
      goto LABEL_52;
    }
    if (!v18)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_http_connect_restart_after_disconnect";
        v11 = "%{public}s called with null http_connect->context, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_http_connect_restart_after_disconnect";
        v11 = "%{public}s called with null http_connect->context, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v15)
      goto LABEL_39;
    *(_DWORD *)buf = 136446466;
    v21 = "nw_http_connect_restart_after_disconnect";
    v22 = 2082;
    v23 = backtrace_string;
    v14 = "%{public}s called with null http_connect->context, dumping backtrace:%{public}s";
    goto LABEL_38;
  }
  v2 = *(_WORD *)(a1 + 368);
  if ((v2 & 0x20) != 0)
  {
    if (*(_DWORD *)(a1 + 276))
    {
      if ((v2 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        v4 = 1;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446722;
          v21 = "nw_http_connect_restart_after_disconnect";
          v22 = 2082;
          v23 = (char *)(a1 + 284);
          v24 = 2080;
          v25 = " ";
          _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sNot restarting after disconnect because async operation is active", buf, 0x20u);
        }
        return v4;
      }
    }
    else
    {
      if ((v2 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446722;
          v21 = "nw_http_connect_restart_after_disconnect";
          v22 = 2082;
          v23 = (char *)(a1 + 284);
          v24 = 2080;
          v25 = " ";
          _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sWaiting to restart after disconnect", buf, 0x20u);
        }
      }
      nw_http_connect_start_async(a1);
      v6 = *(void **)(a1 + 168);
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 0x40000000;
      v17[2] = ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke;
      v17[3] = &__block_descriptor_tmp_48;
      v17[4] = a1;
      nw_queue_context_async(v6, v17);
    }
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_http_connect_restart_after_disconnect";
  v8 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (!__nwlog_fault(v8, &type, &v18))
    goto LABEL_53;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v18)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_http_connect_restart_after_disconnect";
        v11 = "%{public}s called with null http_connect->was_disconnected, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v16 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_http_connect_restart_after_disconnect";
        v11 = "%{public}s called with null http_connect->was_disconnected, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v21 = "nw_http_connect_restart_after_disconnect";
      v22 = 2082;
      v23 = backtrace_string;
      v14 = "%{public}s called with null http_connect->was_disconnected, dumping backtrace:%{public}s";
      goto LABEL_38;
    }
LABEL_39:
    free(backtrace_string);
    goto LABEL_53;
  }
  v9 = __nwlog_obj();
  v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)buf = 136446210;
    v21 = "nw_http_connect_restart_after_disconnect";
    v11 = "%{public}s called with null http_connect->was_disconnected";
    goto LABEL_52;
  }
LABEL_53:
  if (v8)
    free(v8);
  return 0;
}

void nw_http_connect_start_async(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  uint64_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(unsigned int *)(a1 + 276) + 1;
    v3 = v2 << 31 >> 31;
    *(_DWORD *)(a1 + 276) = v2;
    if (v3 == v2 && (v3 & 0x8000000000000000) == 0)
      return;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = *(unsigned int *)(a1 + 276);
    *(_DWORD *)buf = 136446978;
    v24 = "nw_http_connect_start_async";
    v25 = 2082;
    v26 = "http_connect->in_async";
    v27 = 2048;
    v28 = 1;
    v29 = 2048;
    v30 = v4;
    v5 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v5, &type, &v21))
      goto LABEL_18;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v8 = *(unsigned int *)(a1 + 276);
        *(_DWORD *)buf = 136446978;
        v24 = "nw_http_connect_start_async";
        v25 = 2082;
        v26 = "http_connect->in_async";
        v27 = 2048;
        v28 = 1;
        v29 = 2048;
        v30 = v8;
        v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v9, buf, 0x2Au);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v11)
        {
          v12 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136447234;
          v24 = "nw_http_connect_start_async";
          v25 = 2082;
          v26 = "http_connect->in_async";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v12;
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v11)
      {
        v14 = *(unsigned int *)(a1 + 276);
        *(_DWORD *)buf = 136446978;
        v24 = "nw_http_connect_start_async";
        v25 = 2082;
        v26 = "http_connect->in_async";
        v27 = 2048;
        v28 = 1;
        v29 = 2048;
        v30 = v14;
        v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v13 = *(unsigned int *)(a1 + 276);
        *(_DWORD *)buf = 136446978;
        v24 = "nw_http_connect_start_async";
        v25 = 2082;
        v26 = "http_connect->in_async";
        v27 = 2048;
        v28 = 1;
        v29 = 2048;
        v30 = v13;
        v9 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
    if (v5)
      free(v5);
    *(_DWORD *)(a1 + 276) = -1;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_http_connect_start_async";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_http_connect_start_async";
      v18 = "%{public}s called with null http_connect";
      goto LABEL_35;
    }
    if (!v21)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_36;
      *(_DWORD *)buf = 136446210;
      v24 = "nw_http_connect_start_async";
      v18 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_35;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v20 = os_log_type_enabled(v16, type);
    if (v19)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v24 = "nw_http_connect_start_async";
        v25 = 2082;
        v26 = v19;
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v19);
      goto LABEL_36;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_http_connect_start_async";
      v18 = "%{public}s called with null http_connect, no backtrace";
LABEL_35:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
    }
  }
LABEL_36:
  if (v15)
    free(v15);
}

void ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  const char *v6;
  BOOL v7;
  uint64_t v8;
  __int16 v9;
  NSObject *v10;
  uint64_t v11;
  const char *v12;
  BOOL v13;
  const char *v14;
  NSObject *v15;
  _BOOL4 v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  _BOOL4 v22;
  const char *v23;
  const char *v24;
  const char *v25;
  NSObject *v26;
  os_log_type_t v27;
  uint32_t v28;
  NSObject *v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  BOOL v33;
  int v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  void (*v43)(_QWORD, uint64_t);
  uint64_t v44;
  uint64_t v45;
  void (*v46)(void);
  os_log_type_t *v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  BOOL v53;
  NSObject *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t (*v58)(_QWORD);
  NSObject *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(uint64_t, uint64_t, uint64_t);
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  NSObject *v68;
  _BOOL4 v69;
  const char *v70;
  const char *v71;
  NSObject *v72;
  _BOOL4 v73;
  const char *v74;
  const char *v75;
  const char *v76;
  NSObject *v77;
  os_log_type_t v78;
  uint32_t v79;
  NSObject *v80;
  _BOOL4 v81;
  const char *v82;
  const char *v83;
  NSObject *v84;
  _BOOL4 v85;
  const char *v86;
  const char *v87;
  NSObject *v88;
  _BOOL4 v89;
  const char *v90;
  const char *v91;
  uint64_t v92;
  const char *v93;
  const char *v94;
  char *v95;
  NSObject *v96;
  os_log_type_t v97;
  uint64_t v98;
  const char *v99;
  const char *v100;
  const char *v101;
  NSObject *v102;
  _BOOL4 v103;
  const char *v104;
  uint64_t v105;
  const char *v106;
  NSObject *v107;
  char *backtrace_string;
  _BOOL4 v109;
  uint64_t v110;
  const char *v111;
  const char *v112;
  uint64_t v113;
  const char *v114;
  const char *v115;
  uint64_t v116;
  const char *v117;
  const char *v118;
  char v119;
  _QWORD v120[2];
  void (*v121)(uint64_t);
  void *v122;
  os_log_type_t *v123;
  uint64_t v124;
  os_log_type_t type[8];
  os_log_type_t *v126;
  uint64_t v127;
  id v128;
  _BYTE buf[24];
  void *v130;
  __int128 v131;
  uint64_t v132;

  v132 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2 || (*(_WORD *)(v2 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    v2 = *(_QWORD *)(a1 + 32);
    if (v4)
    {
      v5 = "";
      v6 = (const char *)(v2 + 284);
      if (!v2)
        v6 = "";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
      if (v2)
        v5 = " ";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v6;
      *(_WORD *)&buf[22] = 2080;
      v130 = (void *)v5;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sFinished waiting to restart after disconnect", buf, 0x20u);
      v2 = *(_QWORD *)(a1 + 32);
    }
  }
  v7 = nw_http_connect_end_async(v2);
  v8 = *(_QWORD *)(a1 + 32);
  if (v7)
  {
    v9 = *(_WORD *)(v8 + 368);
    if ((v9 & 0x20) == 0)
    {
      if ((v9 & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v11 = *(_QWORD *)(a1 + 32);
          v12 = "";
          v13 = v11 == 0;
          if (v11)
            v14 = (const char *)(v11 + 284);
          else
            v14 = "";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (!v13)
            v12 = " ";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v14;
          *(_WORD *)&buf[22] = 2080;
          v130 = (void *)v12;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sNot restarting because not disconnected", buf, 0x20u);
        }
      }
      return;
    }
    *(_WORD *)(v8 + 368) = v9 & 0xFFDF;
    v19 = *(_QWORD *)(a1 + 32);
    v20 = *(_WORD *)(v19 + 368);
    if (*(_DWORD *)(v19 + 280) == 1)
    {
      if ((v20 & 4) == 0)
      {
        if ((v20 & 0x80) != 0)
          goto LABEL_39;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = gLogObj;
        v22 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
        v19 = *(_QWORD *)(a1 + 32);
        if (!v22)
          goto LABEL_39;
        v23 = "";
        v24 = (const char *)(v19 + 284);
        if (!v19)
          v24 = "";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        if (v19)
          v23 = " ";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v24;
        *(_WORD *)&buf[22] = 2080;
        v130 = (void *)v23;
        v25 = "%{public}s %{public}s%sNot restarting because no response bytes were received";
        v26 = v21;
        v27 = OS_LOG_TYPE_INFO;
        v28 = 32;
LABEL_38:
        _os_log_impl(&dword_182FBE000, v26, v27, v25, buf, v28);
        v19 = *(_QWORD *)(a1 + 32);
LABEL_39:
        nw_http_connect_fail(v19, 22);
        return;
      }
      v35 = (uint64_t *)(v19 + 224);
      if (gLogDatapath)
      {
        v107 = __nwlog_obj();
        if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_182FBE000, v107, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }
      v36 = MEMORY[0x1E0C809B0];
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_35427;
      v130 = &__block_descriptor_tmp_15_35428;
      *(_QWORD *)&v131 = v35;
      BYTE8(v131) = 0;
      v37 = *v35;
      do
      {
        if (!v37)
          break;
        v38 = *(_QWORD *)(v37 + 32);
        v39 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v37 = v38;
      }
      while ((v39 & 1) != 0);
      *(_WORD *)(*(_QWORD *)(a1 + 32) + 368) &= ~4u;
      *(_WORD *)(*(_QWORD *)(a1 + 32) + 368) &= ~2u;
      v19 = *(_QWORD *)(a1 + 32);
      v40 = *(_WORD *)(v19 + 368);
      if ((v40 & 1) == 0)
      {
        v41 = *(_QWORD *)(v19 + 56);
        if (!v41
          || (v42 = *(_QWORD *)(v41 + 24)) == 0
          || (v43 = *(void (**)(_QWORD, uint64_t))(v42 + 256)) == 0)
        {
          if ((v40 & 0x80) != 0)
            goto LABEL_39;
          v102 = __nwlog_obj();
          v103 = os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
          v19 = *(_QWORD *)(a1 + 32);
          if (!v103)
            goto LABEL_39;
          v104 = (const char *)(v19 + 284);
          v105 = *(_QWORD *)(v19 + 56);
          if (!v19)
            v104 = "";
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v104;
          if (v19)
            v106 = " ";
          else
            v106 = "";
          *(_WORD *)&buf[22] = 2080;
          v130 = (void *)v106;
          LOWORD(v131) = 2048;
          *(_QWORD *)((char *)&v131 + 2) = v105;
          v25 = "%{public}s %{public}s%sNot restarting after disconnect because unable to call reset on output_handler %p";
          v26 = v102;
          v27 = OS_LOG_TYPE_ERROR;
          v28 = 42;
          goto LABEL_38;
        }
        v43(*(_QWORD *)(v19 + 56), v19 + 24);
LABEL_56:
        v44 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
        if (v44)
        {
          v45 = *(_QWORD *)(v44 + 24);
          if (v45)
          {
            v46 = *(void (**)(void))(v45 + 24);
            if (v46)
            {
              v46();
              return;
            }
          }
        }
        __nwlog_obj();
        v92 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
        v93 = "invalid";
        if (v92)
        {
          v94 = *(const char **)(v92 + 16);
          if (v94)
            v93 = v94;
        }
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v93;
        v95 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v119 = 0;
        if (!__nwlog_fault(v95, type, &v119))
          goto LABEL_168;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v96 = __nwlog_obj();
          v97 = type[0];
          if (!os_log_type_enabled(v96, type[0]))
            goto LABEL_168;
          v98 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
          v99 = "invalid";
          if (v98)
          {
            v100 = *(const char **)(v98 + 16);
            if (v100)
              v99 = v100;
          }
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v99;
          v101 = "%{public}s protocol %{public}s has invalid connect callback";
        }
        else if (v119)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          v96 = __nwlog_obj();
          v97 = type[0];
          v109 = os_log_type_enabled(v96, type[0]);
          if (backtrace_string)
          {
            if (v109)
            {
              v110 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
              v111 = "invalid";
              if (v110)
              {
                v112 = *(const char **)(v110 + 16);
                if (v112)
                  v111 = v112;
              }
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v111;
              *(_WORD *)&buf[22] = 2082;
              v130 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v96, v97, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_168;
          }
          if (!v109)
          {
LABEL_168:
            if (v95)
              free(v95);
            return;
          }
          v116 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
          v117 = "invalid";
          if (v116)
          {
            v118 = *(const char **)(v116 + 16);
            if (v118)
              v117 = v118;
          }
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v117;
          v101 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
        }
        else
        {
          v96 = __nwlog_obj();
          v97 = type[0];
          if (!os_log_type_enabled(v96, type[0]))
            goto LABEL_168;
          v113 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
          v114 = "invalid";
          if (v113)
          {
            v115 = *(const char **)(v113 + 16);
            if (v115)
              v114 = v115;
          }
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v114;
          v101 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
        }
        _os_log_impl(&dword_182FBE000, v96, v97, v101, buf, 0x16u);
        goto LABEL_168;
      }
      *(_QWORD *)type = 0;
      v126 = type;
      v127 = 0x2000000000;
      v128 = 0;
      v128 = nw_path_copy_flow_registration(*(void **)(v19 + 168), v19 + 24);
      v47 = v126;
      if (!*((_QWORD *)v126 + 3))
      {
        v67 = *(_QWORD *)(a1 + 32);
        if (!v67 || (*(_WORD *)(v67 + 368) & 0x80) == 0)
        {
          v68 = __nwlog_obj();
          v69 = os_log_type_enabled(v68, OS_LOG_TYPE_INFO);
          v67 = *(_QWORD *)(a1 + 32);
          if (v69)
          {
            v70 = "";
            v71 = (const char *)(v67 + 284);
            if (!v67)
              v71 = "";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
            if (v67)
              v70 = " ";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v71;
            *(_WORD *)&buf[22] = 2080;
            v130 = (void *)v70;
            _os_log_impl(&dword_182FBE000, v68, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sNot restarting after disconnect because unable to get flow registration", buf, 0x20u);
            v67 = *(_QWORD *)(a1 + 32);
          }
        }
        nw_http_connect_fail(v67, 22);
        goto LABEL_127;
      }
      v120[0] = v36;
      v120[1] = 0x40000000;
      v121 = ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke_46;
      v122 = &unk_1E14A0A68;
      v48 = *(_QWORD *)(a1 + 32);
      v123 = type;
      v124 = v48;
      v49 = *(void **)(v48 + 96);
      if (v49)
      {
        os_release(v49);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96) = 0;
        v47 = v126;
        v48 = *(_QWORD *)(a1 + 32);
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96) = nw_path_flow_registration_create_new_flow(*((void **)v47 + 3), 1, 1, 0, 0, (_OWORD *)(v48 + 240), 0, 0);
      v50 = *(_QWORD *)(a1 + 32);
      if (*(_QWORD *)(v50 + 96))
      {
        nw_http_connect_start_async(v50);
        v51 = *(_QWORD *)(a1 + 32);
        v52 = *(void **)(v51 + 104);
        if (v52)
        {
          os_release(v52);
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 104) = 0;
          v51 = *(_QWORD *)(a1 + 32);
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 104) = nw_path_flow_registration_force_update(*(void **)(v51 + 96));
        v53 = nw_http_connect_end_async(*(_QWORD *)(a1 + 32));
        v50 = *(_QWORD *)(a1 + 32);
        if (!v53)
        {
          if (!v50 || (*(_WORD *)(v50 + 368) & 0x80) == 0)
          {
            v80 = __nwlog_obj();
            v81 = os_log_type_enabled(v80, OS_LOG_TYPE_INFO);
            v50 = *(_QWORD *)(a1 + 32);
            if (v81)
            {
              v82 = "";
              v83 = (const char *)(v50 + 284);
              if (!v50)
                v83 = "";
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
              if (v50)
                v82 = " ";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v83;
              *(_WORD *)&buf[22] = 2080;
              v130 = (void *)v82;
              _os_log_impl(&dword_182FBE000, v80, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sNot restarting after disconnect because getting new path changed state to destroy", buf, 0x20u);
              v50 = *(_QWORD *)(a1 + 32);
            }
          }
          nw_http_connect_destroy(v50);
          goto LABEL_126;
        }
        v54 = *(NSObject **)(v50 + 104);
        if (v54)
        {
          v55 = *(void **)(v50 + 120);
          if (v55)
          {
            os_release(v55);
            *(_QWORD *)(*(_QWORD *)(a1 + 32) + 120) = 0;
            v54 = *(NSObject **)(*(_QWORD *)(a1 + 32) + 104);
          }
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 120) = nw_path_copy_effective_local_endpoint(v54);
          v50 = *(_QWORD *)(a1 + 32);
          v56 = *(_QWORD *)(v50 + 72);
          if (!v56)
            goto LABEL_115;
          v57 = *(_QWORD *)(v56 + 24);
          if (!v57)
            goto LABEL_115;
          v58 = *(uint64_t (**)(_QWORD))(v57 + 112);
          if (!v58)
            goto LABEL_115;
          v59 = v58(*(_QWORD *)(v50 + 72));
          v50 = *(_QWORD *)(a1 + 32);
          if (v59)
          {
            v60 = *(void **)(v50 + 112);
            if (v60)
            {
              os_release(v60);
              *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) = 0;
            }
            *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) = nw_parameters_copy(v59);
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = 0;
            nw_path_flow_registration_get_id(*(void **)(*(_QWORD *)(a1 + 32) + 96), buf);
            *(_OWORD *)(*(_QWORD *)(a1 + 32) + 24) = *(_OWORD *)buf;
            v61 = *(_QWORD *)(a1 + 32);
            v62 = *(_QWORD *)(v61 + 56);
            nw_protocol_set_output_handler(v61 + 24, 0);
            if (nw_http_connect_reattach_channel_protocol(*(_QWORD *)(a1 + 32)))
            {
              if (v62)
              {
                v63 = *(_QWORD *)(v62 + 24);
                if (v63)
                {
                  v64 = *(void (**)(uint64_t, uint64_t, uint64_t))(v63 + 8);
                  if (v64)
                  {
                    v65 = *(_QWORD *)(a1 + 32);
                    v66 = *(_QWORD *)(v65 + 56);
                    v64(v62, v65 + 24, 1);
                    nw_protocol_set_output_handler(*(_QWORD *)(a1 + 32) + 24, v66);
                  }
                }
              }
              v121((uint64_t)v120);
              _Block_object_dispose(type, 8);
              goto LABEL_56;
            }
            nw_protocol_set_output_handler(*(_QWORD *)(a1 + 32) + 24, v62);
            goto LABEL_124;
          }
          if (v50)
          {
LABEL_115:
            if ((*(_WORD *)(v50 + 368) & 0x80) != 0)
              goto LABEL_125;
          }
          v88 = __nwlog_obj();
          v89 = os_log_type_enabled(v88, OS_LOG_TYPE_INFO);
          v50 = *(_QWORD *)(a1 + 32);
          if (!v89)
          {
LABEL_125:
            nw_http_connect_fail(v50, 22);
LABEL_126:
            v121((uint64_t)v120);
LABEL_127:
            _Block_object_dispose(type, 8);
            return;
          }
          v90 = "";
          v91 = (const char *)(v50 + 284);
          if (!v50)
            v91 = "";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (v50)
            v90 = " ";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v91;
          *(_WORD *)&buf[22] = 2080;
          v130 = (void *)v90;
          v76 = "%{public}s %{public}s%sNot restarting after disconnect because unable to get parameters";
          v77 = v88;
          v78 = OS_LOG_TYPE_INFO;
        }
        else
        {
          if ((*(_WORD *)(v50 + 368) & 0x80) != 0)
            goto LABEL_125;
          v84 = __nwlog_obj();
          v85 = os_log_type_enabled(v84, OS_LOG_TYPE_ERROR);
          v50 = *(_QWORD *)(a1 + 32);
          if (!v85)
            goto LABEL_125;
          v86 = "";
          v87 = (const char *)(v50 + 284);
          if (!v50)
            v87 = "";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (v50)
            v86 = " ";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v87;
          *(_WORD *)&buf[22] = 2080;
          v130 = (void *)v86;
          v76 = "%{public}s %{public}s%sNot restarting after disconnect because unable to get new path";
          v77 = v84;
          v78 = OS_LOG_TYPE_ERROR;
        }
        v79 = 32;
      }
      else
      {
        if ((*(_WORD *)(v50 + 368) & 0x80) != 0)
          goto LABEL_125;
        v72 = __nwlog_obj();
        v73 = os_log_type_enabled(v72, OS_LOG_TYPE_INFO);
        v50 = *(_QWORD *)(a1 + 32);
        if (!v73)
          goto LABEL_125;
        v74 = (const char *)(v50 + 284);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        if (!v50)
          v74 = "";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v74;
        *(_WORD *)&buf[22] = 2080;
        v75 = " ";
        if (!v50)
          v75 = "";
        v130 = (void *)v75;
        LOWORD(v131) = 1040;
        *(_DWORD *)((char *)&v131 + 2) = 16;
        WORD3(v131) = 2096;
        *((_QWORD *)&v131 + 1) = v50 + 240;
        v76 = "%{public}s %{public}s%sNot restarting after disconnect because unable to create new flow with nexus agent %{uuid_t}.16P";
        v77 = v72;
        v78 = OS_LOG_TYPE_INFO;
        v79 = 48;
      }
      _os_log_impl(&dword_182FBE000, v77, v78, v76, buf, v79);
LABEL_124:
      v50 = *(_QWORD *)(a1 + 32);
      goto LABEL_125;
    }
    if ((v20 & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v29 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v30 = *(_QWORD *)(a1 + 32);
        v31 = (const char *)(v30 + 284);
        v32 = "";
        v33 = v30 == 0;
        v34 = *(_DWORD *)(v30 + 280);
        if (v33)
          v31 = "";
        *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(_DWORD *)buf = 136446978;
        if (!v33)
          v32 = " ";
        *(_QWORD *)&buf[14] = v31;
        *(_WORD *)&buf[22] = 2080;
        v130 = (void *)v32;
        LOWORD(v131) = 1024;
        *(_DWORD *)((char *)&v131 + 2) = v34;
        _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sNot restarting because state %d is not negotiating", buf, 0x26u);
      }
    }
  }
  else
  {
    if (!v8 || (*(_WORD *)(v8 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      v16 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      v8 = *(_QWORD *)(a1 + 32);
      if (v16)
      {
        v17 = "";
        v18 = (const char *)(v8 + 284);
        if (!v8)
          v18 = "";
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_restart_after_disconnect_block_invoke";
        if (v8)
          v17 = " ";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v18;
        *(_WORD *)&buf[22] = 2080;
        v130 = (void *)v17;
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sNot restarting after disconnect because http connect state was changed to destroy", buf, 0x20u);
        v8 = *(_QWORD *)(a1 + 32);
      }
    }
    nw_http_connect_destroy(v8);
  }
}

BOOL nw_http_connect_end_async(uint64_t a1)
{
  int v2;
  uint64_t v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  _BOOL4 v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 276);
    *(_DWORD *)(a1 + 276) = v2 - 1;
    if (v2)
      return (*(_WORD *)(a1 + 368) & 0x40) == 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = *(unsigned int *)(a1 + 276);
    *(_DWORD *)buf = 136446978;
    v24 = "nw_http_connect_end_async";
    v25 = 2082;
    v26 = "http_connect->in_async";
    v27 = 2048;
    v28 = 1;
    v29 = 2048;
    v30 = v3;
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (__nwlog_fault(v4, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v7 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136446978;
          v24 = "nw_http_connect_end_async";
          v25 = 2082;
          v26 = "http_connect->in_async";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v7;
          v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_16:
          _os_log_impl(&dword_182FBE000, v5, v6, v8, buf, 0x2Au);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        v10 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v10)
          {
            v11 = *(unsigned int *)(a1 + 276);
            *(_DWORD *)buf = 136447234;
            v24 = "nw_http_connect_end_async";
            v25 = 2082;
            v26 = "http_connect->in_async";
            v27 = 2048;
            v28 = 1;
            v29 = 2048;
            v30 = v11;
            v31 = 2082;
            v32 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(backtrace_string);
          goto LABEL_17;
        }
        if (v10)
        {
          v13 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136446978;
          v24 = "nw_http_connect_end_async";
          v25 = 2082;
          v26 = "http_connect->in_async";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v13;
          v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_16;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = gLogObj;
        v6 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          v12 = *(unsigned int *)(a1 + 276);
          *(_DWORD *)buf = 136446978;
          v24 = "nw_http_connect_end_async";
          v25 = 2082;
          v26 = "http_connect->in_async";
          v27 = 2048;
          v28 = 1;
          v29 = 2048;
          v30 = v12;
          v8 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_16;
        }
      }
    }
LABEL_17:
    if (v4)
      free(v4);
    *(_DWORD *)(a1 + 276) = 0;
    return (*(_WORD *)(a1 + 368) & 0x40) == 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_http_connect_end_async";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v15, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_http_connect_end_async";
        v18 = "%{public}s called with null http_connect";
LABEL_35:
        _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      }
    }
    else if (v21)
    {
      v19 = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v20 = os_log_type_enabled(v16, type);
      if (v19)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_http_connect_end_async";
          v25 = 2082;
          v26 = v19;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v19);
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_http_connect_end_async";
        v18 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_35;
      }
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_http_connect_end_async";
        v18 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
  }
LABEL_36:
  if (v15)
    free(v15);
  return 0;
}

void nw_http_connect_destroy(uint64_t a1)
{
  __int16 v2;
  NSObject *v3;
  const char *v4;
  const char *v5;
  NSObject *v6;
  const char *v7;
  const char *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  NSObject *v28;
  const char *v29;
  const char *v30;
  int v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a1 && (v2 = *(_WORD *)(a1 + 368), (v2 & 0x80) != 0))
  {
    if (*(_DWORD *)(a1 + 276))
    {
LABEL_12:
      *(_WORD *)(a1 + 368) |= 0x40u;
      return;
    }
  }
  else
  {
    if (gLogDatapath)
    {
      v28 = __nwlog_obj();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      {
        v29 = (const char *)(a1 + 284);
        if (!a1)
          v29 = "";
        v31 = 136446978;
        v32 = "nw_http_connect_destroy";
        v33 = 2082;
        v34 = v29;
        v30 = " ";
        if (!a1)
          v30 = "";
        v35 = 2080;
        v36 = v30;
        v37 = 2048;
        v38 = a1;
        _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%stearing down %p", (uint8_t *)&v31, 0x2Au);
      }
    }
    if (nw_http_connect_in_async(a1))
    {
      if (!a1 || (*(_WORD *)(a1 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          v4 = "";
          v32 = "nw_http_connect_destroy";
          v5 = " ";
          v31 = 136446722;
          if (a1)
            v4 = (const char *)(a1 + 284);
          else
            v5 = "";
          v33 = 2082;
          v34 = v4;
          v35 = 2080;
          v36 = v5;
          _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect in async, setting state to destroy", (uint8_t *)&v31, 0x20u);
        }
      }
      goto LABEL_12;
    }
    v2 = *(_WORD *)(a1 + 368);
  }
  if ((v2 & 0x40) != 0)
  {
    *(_WORD *)(a1 + 368) = v2 & 0xFFBF;
    if (!a1 || (v2 & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v6 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v7 = "";
        v32 = "nw_http_connect_destroy";
        v8 = " ";
        v31 = 136446722;
        if (a1)
          v7 = (const char *)(a1 + 284);
        else
          v8 = "";
        v33 = 2082;
        v34 = v7;
        v35 = 2080;
        v36 = v8;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect destroying after deferral", (uint8_t *)&v31, 0x20u);
      }
    }
  }
  _CFHTTPAuthenticationApplyProxyAuthorizationToRequest();
  v9 = *(void **)(a1 + 96);
  if (v9)
  {
    nw_path_flow_registration_close(v9);
    v10 = *(void **)(a1 + 96);
    if (v10)
    {
      os_release(v10);
      *(_QWORD *)(a1 + 96) = 0;
    }
  }
  v11 = *(void **)(a1 + 88);
  if (v11)
  {
    nw_path_flow_registration_close(v11);
    v12 = *(void **)(a1 + 88);
    if (v12)
    {
      os_release(v12);
      *(_QWORD *)(a1 + 88) = 0;
    }
  }
  v13 = *(void **)(a1 + 128);
  if (v13)
  {
    os_release(v13);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v14 = *(void **)(a1 + 104);
  if (v14)
  {
    os_release(v14);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v15 = *(void **)(a1 + 112);
  if (v15)
  {
    os_release(v15);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v16 = *(void **)(a1 + 120);
  if (v16)
  {
    os_release(v16);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v17 = *(void **)(a1 + 136);
  if (v17)
  {
    os_release(v17);
    *(_QWORD *)(a1 + 136) = 0;
  }
  v18 = *(void **)(a1 + 144);
  if (v18)
  {
    os_release(v18);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v19 = *(void **)(a1 + 152);
  if (v19)
  {
    os_release(v19);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v20 = *(void **)(a1 + 160);
  if (v20)
  {
    os_release(v20);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v21 = *(void **)(a1 + 168);
  if (v21)
  {
    os_release(v21);
    *(_QWORD *)(a1 + 168) = 0;
  }
  v22 = *(void **)(a1 + 176);
  if (v22)
  {
    os_release(v22);
    *(_QWORD *)(a1 + 176) = 0;
  }
  v23 = *(void **)(a1 + 184);
  if (v23)
  {
    os_release(v23);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v24 = *(const void **)(a1 + 192);
  if (v24)
  {
    CFRelease(v24);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v25 = *(const void **)(a1 + 208);
  if (v25)
  {
    CFRelease(v25);
    *(_QWORD *)(a1 + 208) = 0;
  }
  v26 = *(const void **)(a1 + 200);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v27 = *(const void **)(a1 + 216);
  if (v27)
    CFRelease(v27);
  free((void *)a1);
}

void nw_http_connect_fail(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  void (*v5)(void);
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, uint64_t);
  uint64_t v12;
  const char *v13;
  const char *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  const char *v25;
  NSObject *v26;
  os_log_type_t v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  const char *v41;
  char *v42;
  _BOOL4 v43;
  uint64_t v44;
  const char *v45;
  const char *v46;
  char *v47;
  _BOOL4 v48;
  uint64_t v49;
  const char *v50;
  const char *v51;
  const char *v52;
  NSObject *v53;
  os_log_type_t v54;
  const char *v55;
  char *backtrace_string;
  _BOOL4 v57;
  uint64_t v58;
  const char *v59;
  const char *v60;
  uint64_t v61;
  const char *v62;
  const char *v63;
  uint64_t v64;
  const char *v65;
  const char *v66;
  char *v67;
  _BOOL4 v68;
  uint64_t v69;
  const char *v70;
  const char *v71;
  uint64_t v72;
  const char *v73;
  const char *v74;
  char *v75;
  uint64_t v76;
  const char *v77;
  const char *v78;
  uint64_t v79;
  const char *v80;
  const char *v81;
  char v82;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v85;
  __int16 v86;
  void *v87;
  __int16 v88;
  char *v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_DWORD *)(a1 + 280) = 3;
    if (!a2)
      goto LABEL_7;
    v3 = *(_QWORD *)(a1 + 72);
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 24);
      if (v4)
      {
        v5 = *(void (**)(void))(v4 + 56);
        if (v5)
        {
          v5();
          goto LABEL_7;
        }
      }
    }
    __nwlog_obj();
    v32 = *(_QWORD *)(a1 + 72);
    v33 = "invalid";
    if (v32)
    {
      v34 = *(const char **)(v32 + 16);
      if (v34)
        v33 = v34;
    }
    *(_DWORD *)buf = 136446466;
    v85 = "nw_http_connect_fail";
    v86 = 2082;
    v87 = (void *)v33;
    v35 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (__nwlog_fault(v35, &type, &v82))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v36 = __nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type))
          goto LABEL_116;
        v38 = *(_QWORD *)(a1 + 72);
        v39 = "invalid";
        if (v38)
        {
          v40 = *(const char **)(v38 + 16);
          if (v40)
            v39 = v40;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v39;
        v41 = "%{public}s protocol %{public}s has invalid error callback";
        goto LABEL_115;
      }
      if (!v82)
      {
        v36 = __nwlog_obj();
        v37 = type;
        if (!os_log_type_enabled(v36, type))
          goto LABEL_116;
        v76 = *(_QWORD *)(a1 + 72);
        v77 = "invalid";
        if (v76)
        {
          v78 = *(const char **)(v76 + 16);
          if (v78)
            v77 = v78;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v77;
        v41 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_115;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v36 = __nwlog_obj();
      v37 = type;
      v57 = os_log_type_enabled(v36, type);
      if (backtrace_string)
      {
        if (v57)
        {
          v58 = *(_QWORD *)(a1 + 72);
          v59 = "invalid";
          if (v58)
          {
            v60 = *(const char **)(v58 + 16);
            if (v60)
              v59 = v60;
          }
          *(_DWORD *)buf = 136446722;
          v85 = "nw_http_connect_fail";
          v86 = 2082;
          v87 = (void *)v59;
          v88 = 2082;
          v89 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_116;
      }
      if (v57)
      {
        v79 = *(_QWORD *)(a1 + 72);
        v80 = "invalid";
        if (v79)
        {
          v81 = *(const char **)(v79 + 16);
          if (v81)
            v80 = v81;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v80;
        v41 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
LABEL_115:
        _os_log_impl(&dword_182FBE000, v36, v37, v41, buf, 0x16u);
      }
    }
LABEL_116:
    if (v35)
      free(v35);
LABEL_7:
    v6 = *(_QWORD *)(a1 + 72);
    if (v6)
    {
      v7 = *(_QWORD *)(v6 + 24);
      if (v7)
      {
        v8 = *(void (**)(uint64_t, uint64_t))(v7 + 48);
        if (v8)
        {
          v8(v6, a1 + 24);
          goto LABEL_11;
        }
      }
    }
    __nwlog_obj();
    v12 = *(_QWORD *)(a1 + 72);
    v13 = "invalid";
    if (v12)
    {
      v14 = *(const char **)(v12 + 16);
      if (v14)
        v13 = v14;
    }
    *(_DWORD *)buf = 136446466;
    v85 = "nw_http_connect_fail";
    v86 = 2082;
    v87 = (void *)v13;
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (__nwlog_fault(v15, &type, &v82))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        v17 = type;
        if (!os_log_type_enabled(v16, type))
          goto LABEL_95;
        v18 = *(_QWORD *)(a1 + 72);
        v19 = "invalid";
        if (v18)
        {
          v20 = *(const char **)(v18 + 16);
          if (v20)
            v19 = v20;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v19;
        v21 = "%{public}s protocol %{public}s has invalid disconnected callback";
        goto LABEL_94;
      }
      if (!v82)
      {
        v16 = __nwlog_obj();
        v17 = type;
        if (!os_log_type_enabled(v16, type))
          goto LABEL_95;
        v61 = *(_QWORD *)(a1 + 72);
        v62 = "invalid";
        if (v61)
        {
          v63 = *(const char **)(v61 + 16);
          if (v63)
            v62 = v63;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v62;
        v21 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_94;
      }
      v42 = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v43 = os_log_type_enabled(v16, type);
      if (v42)
      {
        if (v43)
        {
          v44 = *(_QWORD *)(a1 + 72);
          v45 = "invalid";
          if (v44)
          {
            v46 = *(const char **)(v44 + 16);
            if (v46)
              v45 = v46;
          }
          *(_DWORD *)buf = 136446722;
          v85 = "nw_http_connect_fail";
          v86 = 2082;
          v87 = (void *)v45;
          v88 = 2082;
          v89 = v42;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v42);
        goto LABEL_95;
      }
      if (v43)
      {
        v69 = *(_QWORD *)(a1 + 72);
        v70 = "invalid";
        if (v69)
        {
          v71 = *(const char **)(v69 + 16);
          if (v71)
            v70 = v71;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v70;
        v21 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
LABEL_94:
        _os_log_impl(&dword_182FBE000, v16, v17, v21, buf, 0x16u);
      }
    }
LABEL_95:
    if (v15)
      free(v15);
LABEL_11:
    v9 = *(_QWORD *)(a1 + 56);
    if (v9)
    {
      v10 = *(_QWORD *)(v9 + 24);
      if (v10)
      {
        v11 = *(void (**)(uint64_t, uint64_t))(v10 + 32);
        if (v11)
        {
          v11(v9, a1 + 24);
          return;
        }
      }
    }
    __nwlog_obj();
    v22 = *(_QWORD *)(a1 + 56);
    v23 = "invalid";
    if (v22)
    {
      v24 = *(const char **)(v22 + 16);
      if (v24)
        v23 = v24;
    }
    *(_DWORD *)buf = 136446466;
    v85 = "nw_http_connect_fail";
    v86 = 2082;
    v87 = (void *)v23;
    v25 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v82 = 0;
    if (__nwlog_fault(v25, &type, &v82))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_103;
        v28 = *(_QWORD *)(a1 + 56);
        v29 = "invalid";
        if (v28)
        {
          v30 = *(const char **)(v28 + 16);
          if (v30)
            v29 = v30;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v29;
        v31 = "%{public}s protocol %{public}s has invalid disconnect callback";
LABEL_102:
        _os_log_impl(&dword_182FBE000, v26, v27, v31, buf, 0x16u);
        goto LABEL_103;
      }
      if (!v82)
      {
        v26 = __nwlog_obj();
        v27 = type;
        if (!os_log_type_enabled(v26, type))
          goto LABEL_103;
        v64 = *(_QWORD *)(a1 + 56);
        v65 = "invalid";
        if (v64)
        {
          v66 = *(const char **)(v64 + 16);
          if (v66)
            v65 = v66;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v65;
        v31 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        goto LABEL_102;
      }
      v47 = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v48 = os_log_type_enabled(v26, type);
      if (!v47)
      {
        if (!v48)
          goto LABEL_103;
        v72 = *(_QWORD *)(a1 + 56);
        v73 = "invalid";
        if (v72)
        {
          v74 = *(const char **)(v72 + 16);
          if (v74)
            v73 = v74;
        }
        *(_DWORD *)buf = 136446466;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v73;
        v31 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
        goto LABEL_102;
      }
      if (v48)
      {
        v49 = *(_QWORD *)(a1 + 56);
        v50 = "invalid";
        if (v49)
        {
          v51 = *(const char **)(v49 + 16);
          if (v51)
            v50 = v51;
        }
        *(_DWORD *)buf = 136446722;
        v85 = "nw_http_connect_fail";
        v86 = 2082;
        v87 = (void *)v50;
        v88 = 2082;
        v89 = v47;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v47);
    }
LABEL_103:
    if (v25)
    {
      v75 = (char *)v25;
LABEL_125:
      free(v75);
      return;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v85 = "nw_http_connect_fail";
  v52 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v82 = 0;
  if (__nwlog_fault(v52, &type, &v82))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v53 = __nwlog_obj();
      v54 = type;
      if (!os_log_type_enabled(v53, type))
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      v85 = "nw_http_connect_fail";
      v55 = "%{public}s called with null http_connect";
LABEL_122:
      _os_log_impl(&dword_182FBE000, v53, v54, v55, buf, 0xCu);
      goto LABEL_123;
    }
    if (!v82)
    {
      v53 = __nwlog_obj();
      v54 = type;
      if (!os_log_type_enabled(v53, type))
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      v85 = "nw_http_connect_fail";
      v55 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_122;
    }
    v67 = (char *)__nw_create_backtrace_string();
    v53 = __nwlog_obj();
    v54 = type;
    v68 = os_log_type_enabled(v53, type);
    if (!v67)
    {
      if (!v68)
        goto LABEL_123;
      *(_DWORD *)buf = 136446210;
      v85 = "nw_http_connect_fail";
      v55 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_122;
    }
    if (v68)
    {
      *(_DWORD *)buf = 136446466;
      v85 = "nw_http_connect_fail";
      v86 = 2082;
      v87 = v67;
      _os_log_impl(&dword_182FBE000, v53, v54, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v67);
  }
LABEL_123:
  if (v52)
  {
    v75 = (char *)v52;
    goto LABEL_125;
  }
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_35427(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

void ___ZL40nw_http_connect_restart_after_disconnectP24nw_protocol_http_connect_block_invoke_46(uint64_t a1)
{
  void *v1;
  unsigned __int8 *v3;
  uint64_t v4;
  int v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  uint64_t v12;
  BOOL v13;
  const char *v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  NSObject *v18;
  _BOOL4 v19;
  BOOL v20;
  const char *v21;
  const char *v22;
  char v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  void *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  __int128 *v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v1)
  {
    v34 = 0uLL;
    v3 = v1;
    if (!uuid_is_null(v3 + 32))
      v34 = *((_OWORD *)v3 + 2);

    v4 = *(_QWORD *)(a1 + 40);
    v5 = (*(unsigned __int16 *)(v4 + 368) >> 7) & 1;
    if (!gLogDatapath)
      LOBYTE(v5) = 1;
    if (*(_QWORD *)(v4 + 88))
    {
      if ((v5 & 1) == 0)
      {
        v11 = __nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          v12 = *(_QWORD *)(a1 + 40);
          v13 = v12 == 0;
          *(_DWORD *)buf = 136447234;
          v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
          if (v12)
            v14 = (const char *)(v12 + 284);
          else
            v14 = "";
          v26 = 2082;
          v27 = (void *)v14;
          if (v13)
            v15 = "";
          else
            v15 = " ";
          v28 = 2080;
          v29 = v15;
          v30 = 1040;
          v31 = 16;
          v32 = 2096;
          v33 = &v34;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sCleaning up flow registration %{uuid_t}.16P", buf, 0x30u);
        }
      }
      nw_path_flow_registration_close(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      v6 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v6)
      {
        os_release(v6);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      }
    }
    else
    {
      if ((v5 & 1) == 0)
      {
        v18 = __nwlog_obj();
        v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
        v4 = *(_QWORD *)(a1 + 40);
        if (v19)
        {
          *(_DWORD *)buf = 136447234;
          v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
          v20 = v4 == 0;
          if (v4)
            v21 = (const char *)(v4 + 284);
          else
            v21 = "";
          v26 = 2082;
          v27 = (void *)v21;
          v28 = 2080;
          v22 = " ";
          if (v20)
            v22 = "";
          v29 = v22;
          v30 = 1040;
          v31 = 16;
          v32 = 2096;
          v33 = &v34;
          _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDeferring cleanup of flow registration %{uuid_t}.16P", buf, 0x30u);
          v4 = *(_QWORD *)(a1 + 40);
        }
      }
      *(_QWORD *)(v4 + 88) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
  v7 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v34) = 16;
  v23 = 0;
  if (__nwlog_fault(v7, &v34, &v23))
  {
    if (v34 == 17)
    {
      v8 = __nwlog_obj();
      v9 = v34;
      if (!os_log_type_enabled(v8, (os_log_type_t)v34))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
      v10 = "%{public}s called with null flow_registration";
      goto LABEL_41;
    }
    if (!v23)
    {
      v8 = __nwlog_obj();
      v9 = v34;
      if (!os_log_type_enabled(v8, (os_log_type_t)v34))
        goto LABEL_42;
      *(_DWORD *)buf = 136446210;
      v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
      v10 = "%{public}s called with null flow_registration, backtrace limit exceeded";
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = v34;
    v17 = os_log_type_enabled(v8, (os_log_type_t)v34);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
        v26 = 2082;
        v27 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_42;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_http_connect_restart_after_disconnect_block_invoke";
      v10 = "%{public}s called with null flow_registration, no backtrace";
LABEL_41:
      _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    }
  }
LABEL_42:
  if (v7)
    free(v7);
}

void sub_1836D2690(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_http_connect_reattach_channel_protocol(uint64_t a1)
{
  int protocol_level;
  NSObject *v3;
  int v4;
  void *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t nexus_key;
  char can_support_user_packet_pool;
  char v12;
  NSObject *v13;
  id v14;
  void *v15;
  _DWORD *v16;
  uint64_t v17;
  __int16 v18;
  NSObject *v19;
  int v20;
  void *v21;
  uint64_t stats_region;
  uint64_t v23;
  NSObject *v25;
  NSObject *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  __int128 *v32;
  void *v33;
  __int128 *upper_transport_protocol_identifier;
  void *v35;
  uint64_t v36;
  uint64_t protocol_handler;
  NSObject *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  char *backtrace_string;
  _BOOL4 v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  _BYTE buf[22];
  __int16 v49;
  const char *v50;
  _BYTE v51[24];
  const char *v52;
  __int128 *p_uu;
  uint64_t v54;
  uint64_t *v55;
  __int128 uu;
  uint64_t v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)v51 = 136446210;
    *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
    v39 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(uu) = 16;
    buf[0] = 0;
    if (!__nwlog_fault(v39, &uu, buf))
      goto LABEL_92;
    if (uu == 17)
    {
      v40 = __nwlog_obj();
      v41 = uu;
      if (!os_log_type_enabled(v40, (os_log_type_t)uu))
        goto LABEL_92;
      *(_DWORD *)v51 = 136446210;
      *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
      v42 = "%{public}s called with null http_connect";
    }
    else if (buf[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v40 = __nwlog_obj();
      v41 = uu;
      v44 = os_log_type_enabled(v40, (os_log_type_t)uu);
      if (backtrace_string)
      {
        if (v44)
        {
          *(_DWORD *)v51 = 136446466;
          *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
          *(_WORD *)&v51[12] = 2082;
          *(_QWORD *)&v51[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s called with null http_connect, dumping backtrace:%{public}s", v51, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_92;
      }
      if (!v44)
      {
LABEL_92:
        if (v39)
          free(v39);
        return 0;
      }
      *(_DWORD *)v51 = 136446210;
      *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
      v42 = "%{public}s called with null http_connect, no backtrace";
    }
    else
    {
      v40 = __nwlog_obj();
      v41 = uu;
      if (!os_log_type_enabled(v40, (os_log_type_t)uu))
        goto LABEL_92;
      *(_DWORD *)v51 = 136446210;
      *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
      v42 = "%{public}s called with null http_connect, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v40, v41, v42, v51, 0xCu);
    goto LABEL_92;
  }
  protocol_level = nw_path_flow_registration_get_protocol_level(*(void **)(a1 + 104), *(void **)(a1 + 96));
  v47 = 0;
  *(_QWORD *)&uu = 0;
  *((_QWORD *)&uu + 1) = &uu;
  v57 = 0x2000000000;
  v58 = 1;
  if (protocol_level > 4)
    goto LABEL_3;
  v4 = protocol_level;
  v5 = *(void **)(a1 + 112);
  v6 = MEMORY[0x1E0C809B0];
  *(_QWORD *)v51 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v51[8] = 0x40000000;
  *(_QWORD *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
  v52 = (const char *)&unk_1E14A0AB0;
  v54 = a1;
  v55 = &v47;
  p_uu = &uu;
  nw_parameters_internal_iterate_protocol_stack(v5, 4, 0, v51);
  if (!*(_BYTE *)(*((_QWORD *)&uu + 1) + 24))
    goto LABEL_42;
  if (!v47)
    goto LABEL_3;
  _Block_object_dispose(&uu, 8);
  *(_QWORD *)&uu = 0;
  *((_QWORD *)&uu + 1) = &uu;
  v57 = 0x2000000000;
  v58 = 1;
  if (v4 <= 3)
  {
    v7 = *(void **)(a1 + 112);
    *(_QWORD *)v51 = v6;
    *(_QWORD *)&v51[8] = 0x40000000;
    *(_QWORD *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
    v52 = (const char *)&unk_1E14A0AB0;
    v54 = a1;
    v55 = &v47;
    p_uu = &uu;
    nw_parameters_internal_iterate_protocol_stack(v7, 3, 0, v51);
    if (!*(_BYTE *)(*((_QWORD *)&uu + 1) + 24))
      goto LABEL_42;
  }
  if (!v47)
    goto LABEL_3;
  _Block_object_dispose(&uu, 8);
  *(_QWORD *)&uu = 0;
  *((_QWORD *)&uu + 1) = &uu;
  v57 = 0x2000000000;
  v58 = 1;
  if (v4 <= 2)
  {
    v8 = *(void **)(a1 + 112);
    *(_QWORD *)v51 = v6;
    *(_QWORD *)&v51[8] = 0x40000000;
    *(_QWORD *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
    v52 = (const char *)&unk_1E14A0AB0;
    v54 = a1;
    v55 = &v47;
    p_uu = &uu;
    nw_parameters_internal_iterate_protocol_stack(v8, 2, 0, v51);
    if (!*(_BYTE *)(*((_QWORD *)&uu + 1) + 24))
      goto LABEL_42;
  }
  if (!v47)
    goto LABEL_3;
  _Block_object_dispose(&uu, 8);
  *(_QWORD *)&uu = 0;
  *((_QWORD *)&uu + 1) = &uu;
  v57 = 0x2000000000;
  v58 = 1;
  if (v4 <= 1)
  {
    v9 = *(void **)(a1 + 112);
    *(_QWORD *)v51 = v6;
    *(_QWORD *)&v51[8] = 0x40000000;
    *(_QWORD *)&v51[16] = ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke;
    v52 = (const char *)&unk_1E14A0AB0;
    v54 = a1;
    v55 = &v47;
    p_uu = &uu;
    nw_parameters_internal_iterate_protocol_stack(v9, 1, 0, v51);
    if (!*(_BYTE *)(*((_QWORD *)&uu + 1) + 24))
    {
LABEL_42:
      _Block_object_dispose(&uu, 8);
      return 0;
    }
  }
  if (!v47)
  {
LABEL_3:
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_reattach_protocols";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        v49 = 2080;
        v50 = " ";
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sFailed to locate http_connect in protocol stack", buf, 0x20u);
      }
    }
    *(_BYTE *)(*((_QWORD *)&uu + 1) + 24) = 0;
    goto LABEL_42;
  }
  _Block_object_dispose(&uu, 8);
  uu = 0uLL;
  v46 = 0;
  if (!nw_path_flow_registration_get_nexus_instance(*(NWConcrete_nw_path **)(a1 + 104), *(NWConcrete_nw_path_flow_registration **)(a1 + 96), &uu, &v46))
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      v25 = __nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v51 = 136446722;
        *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
        *(_WORD *)&v51[12] = 2082;
        *(_QWORD *)&v51[14] = a1 + 284;
        *(_WORD *)&v51[22] = 2080;
        v52 = " ";
        _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNot restarting after disconnect because nexus is not ready", v51, 0x20u);
      }
    }
    return 0;
  }
  v45 = 0;
  nexus_key = nw_path_flow_registration_get_nexus_key(*(NWConcrete_nw_path **)(a1 + 104), *(NWConcrete_nw_path_flow_registration **)(a1 + 96), &v45);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  can_support_user_packet_pool = nw_path_flow_registration_can_support_user_packet_pool(*(void **)(a1 + 104), *(void **)(a1 + 96));
  buf[12] = buf[12] & 0xFE | can_support_user_packet_pool;
  if (nw_path_flow_registration_should_use_event_ring(*(void **)(a1 + 104), *(void **)(a1 + 96)))
    v12 = 2;
  else
    v12 = 0;
  buf[12] = buf[12] & 0xFD | v12;
  *(_QWORD *)buf = nexus_key;
  *(_DWORD *)&buf[8] = 16;
  v13 = nw_path_copy_endpoint(*(void **)(a1 + 104));
  v14 = nw_path_copy_parameters(*(void **)(a1 + 104));
  v15 = *(void **)(a1 + 128);
  if (v15)
  {
    os_release(v15);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v16 = nw_parameters_copy_context(v14);
  v17 = nw_channel_create_with_attributes(v16, (unsigned __int8 *)&uu, v46, (uint64_t)buf);
  *(_QWORD *)(a1 + 128) = v17;
  if (v16)
  {
    os_release(v16);
    v17 = *(_QWORD *)(a1 + 128);
  }
  v18 = *(_WORD *)(a1 + 368);
  if (!v17)
  {
    if ((v18 & 0x80) == 0)
    {
      v26 = __nwlog_obj();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v51 = 136446722;
        *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
        *(_WORD *)&v51[12] = 2082;
        *(_QWORD *)&v51[14] = a1 + 284;
        *(_WORD *)&v51[22] = 2080;
        v52 = " ";
        _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNot restarting after disconnect because failed to open channel", v51, 0x20u);
      }
    }
    if (v13)
      os_release(v13);
    v23 = 0;
    if (v14)
      goto LABEL_77;
    return v23;
  }
  if ((v18 & 0x80) == 0)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v51 = 136446978;
      *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
      *(_WORD *)&v51[12] = 2082;
      *(_QWORD *)&v51[14] = a1 + 284;
      *(_WORD *)&v51[22] = 2080;
      v52 = " ";
      LOWORD(p_uu) = 1024;
      *(_DWORD *)((char *)&p_uu + 2) = v4;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sopened channel at level %u", v51, 0x26u);
    }
  }
  nw_channel_set_close_automatically(*(_QWORD *)(a1 + 128), 1);
  nw_channel_set_defer_input_available(*(_QWORD *)(a1 + 128), 1);
  nw_channel_set_protocol_level(*(_QWORD *)(a1 + 128), v4);
  if (v4 == 2)
  {
    if (nw_protocol_ip_identifier::onceToken != -1)
      dispatch_once(&nw_protocol_ip_identifier::onceToken, &__block_literal_global_85105);
    if (nw_parameters_has_protocol_in_stack(v14, &nw_protocol_ip_identifier::identifier)
      && v13
      && nw_endpoint_get_type(v13) == nw_endpoint_type_address)
    {
      if (nw_endpoint_get_address_family(v13) == 2)
        v20 = 1;
      else
        v20 = 2;
      v21 = *(void **)(a1 + 96);
      if (nw_protocol_ip_identifier::onceToken != -1)
        dispatch_once(&nw_protocol_ip_identifier::onceToken, &__block_literal_global_85105);
      stats_region = nw_channel_get_stats_region(*(_QWORD *)(a1 + 128), v20);
      nw_path_flow_registration_set_stats_region(v21, 2, (__int128 *)&nw_protocol_ip_identifier::identifier, stats_region);
    }
  }
  else if ((v4 & 0xFFFFFFFE) != 2)
  {
    goto LABEL_67;
  }
  v27 = (_QWORD *)nw_protocol_tcp_identifier();
  if (!nw_parameters_has_protocol_in_stack(v14, v27))
  {
    if (nw_protocol_udp_identifier::onceToken != -1)
      dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
    if (nw_parameters_has_protocol_in_stack(v14, &nw_protocol_udp_identifier::identifier))
    {
      v33 = *(void **)(a1 + 96);
      if (nw_protocol_udp_identifier::onceToken == -1)
        goto LABEL_65;
    }
    else
    {
      if (nw_parameters_get_upper_transport_protocol(v14) != 253)
        goto LABEL_67;
      upper_transport_protocol_identifier = (__int128 *)nw_parameters_get_upper_transport_protocol_identifier(v14);
      v35 = *(void **)(a1 + 96);
      v36 = nw_channel_get_stats_region(*(_QWORD *)(a1 + 128), 5);
      nw_path_flow_registration_set_stats_region(v35, 3, upper_transport_protocol_identifier, v36);
      v33 = *(void **)(a1 + 96);
      if (nw_protocol_udp_identifier::onceToken == -1)
        goto LABEL_65;
    }
    dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
LABEL_65:
    v30 = nw_channel_get_stats_region(*(_QWORD *)(a1 + 128), 4);
    v32 = (__int128 *)&nw_protocol_udp_identifier::identifier;
    v31 = v33;
    goto LABEL_66;
  }
  v28 = *(void **)(a1 + 96);
  v29 = nw_protocol_tcp_identifier();
  v30 = nw_channel_get_stats_region(*(_QWORD *)(a1 + 128), 3);
  v31 = v28;
  v32 = (__int128 *)v29;
LABEL_66:
  nw_path_flow_registration_set_stats_region(v31, 3, v32, v30);
LABEL_67:
  protocol_handler = nw_channel_get_protocol_handler(*(_QWORD *)(a1 + 128));
  if ((**(unsigned int (***)(void))(protocol_handler + 24))())
  {
    if (nw_channel_set_path_flow_registration(*(_QWORD *)(a1 + 128), *(void **)(a1 + 104), *(void **)(a1 + 96)))
    {
      nw_channel_set_keep_path_flow_registration_open(*(_QWORD *)(a1 + 128), *(void **)(a1 + 96));
      v23 = 1;
      goto LABEL_74;
    }
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      v38 = __nwlog_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v51 = 136446722;
        *(_QWORD *)&v51[4] = "nw_http_connect_reattach_channel_protocol";
        *(_WORD *)&v51[12] = 2082;
        *(_QWORD *)&v51[14] = a1 + 284;
        *(_WORD *)&v51[22] = 2080;
        v52 = " ";
        _os_log_impl(&dword_182FBE000, v38, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sNot restarting after disconnect because unable to set path flow registration", v51, 0x20u);
      }
    }
  }
  v23 = 0;
LABEL_74:
  if (v13)
    os_release(v13);
  if (v14)
LABEL_77:
    os_release(v14);
  return v23;
}

uint64_t ___ZL34nw_http_connect_reattach_protocolsP24nw_protocol_http_connect19nw_protocol_level_tS1_PP11nw_protocol_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  BOOL v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t internal;
  uint64_t v17;
  _QWORD *v18;
  uint64_t (**v19)(uint64_t, uint64_t);
  uint64_t (*v20)(uint64_t, uint64_t);
  char v21;
  char v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  BOOL v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  NSObject *v30;
  _BOOL4 v31;
  BOOL v32;
  const char *v33;
  const char *v34;
  uint64_t result;
  NSObject *v36;
  const char *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  BOOL v41;
  const char *v42;
  const char *v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  const char *v47;
  char *backtrace_string;
  _BOOL4 v49;
  char *v50;
  _BOOL4 v51;
  const char *v52;
  _BOOL4 v53;
  char v54;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v57;
  __int16 v58;
  void *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  id v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v7 = *(_QWORD *)(a1 + 40);
  if (!v7 || (*(_WORD *)(v7 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      v9 = *(_QWORD *)(a1 + 40);
      v10 = v9 == 0;
      if (v9)
        v11 = (const char *)(v9 + 284);
      else
        v11 = "";
      *(_DWORD *)buf = 136446978;
      v57 = "nw_http_connect_reattach_protocols_block_invoke";
      v58 = 2082;
      v59 = (void *)v11;
      if (v10)
        v12 = "";
      else
        v12 = " ";
      v60 = 2080;
      v61 = v12;
      v62 = 2114;
      v63 = a3;
      _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sEnumerating protocol: %{public}@", buf, 0x2Au);
    }
  }
  v13 = **(_QWORD **)(a1 + 48);
  if (!v13)
  {
    if (nw_proxy_copy_http_connect_definition::onceToken != -1)
      dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_92);
    if (nw_protocol_definition_is_equal_unsafe((uint64_t)a3, (uint64_t)(id)nw_proxy_copy_http_connect_definition::proxy_definition))
    {
      v29 = *(_QWORD *)(a1 + 40);
      if (!v29 || (*(_WORD *)(v29 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v30 = gLogObj;
        v31 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG);
        v29 = *(_QWORD *)(a1 + 40);
        if (v31)
        {
          v32 = v29 == 0;
          if (v29)
            v33 = (const char *)(v29 + 284);
          else
            v33 = "";
          *(_DWORD *)buf = 136446978;
          v57 = "nw_http_connect_reattach_protocols_block_invoke";
          v58 = 2082;
          v59 = (void *)v33;
          v34 = " ";
          if (v32)
            v34 = "";
          v60 = 2080;
          v61 = v34;
          v62 = 2114;
          v63 = a3;
          _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sRebuilding stack under protocol: %{public}@", buf, 0x2Au);
          v29 = *(_QWORD *)(a1 + 40);
        }
      }
      **(_QWORD **)(a1 + 48) = v29 + 24;
    }
    return 1;
  }
  v14 = *(_QWORD *)(a1 + 40);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_http_connect_reattach_protocol";
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v44, &type, &v54))
      goto LABEL_107;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v45 = __nwlog_obj();
      v46 = type;
      if (!os_log_type_enabled(v45, type))
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_http_connect_reattach_protocol";
      v47 = "%{public}s called with null http_connect";
    }
    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = type;
      v49 = os_log_type_enabled(v45, type);
      if (backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          v57 = "nw_http_connect_reattach_protocol";
          v58 = 2082;
          v59 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_107:
        if (!v44)
          goto LABEL_52;
LABEL_108:
        free(v44);
        goto LABEL_52;
      }
      if (!v49)
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_http_connect_reattach_protocol";
      v47 = "%{public}s called with null http_connect, no backtrace";
    }
    else
    {
      v45 = __nwlog_obj();
      v46 = type;
      if (!os_log_type_enabled(v45, type))
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_http_connect_reattach_protocol";
      v47 = "%{public}s called with null http_connect, backtrace limit exceeded";
    }
    goto LABEL_106;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_http_connect_reattach_protocol";
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v44, &type, &v54))
      goto LABEL_107;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v54)
      {
        v45 = __nwlog_obj();
        v46 = type;
        if (!os_log_type_enabled(v45, type))
          goto LABEL_107;
        *(_DWORD *)buf = 136446210;
        v57 = "nw_http_connect_reattach_protocol";
        v47 = "%{public}s called with null definition, backtrace limit exceeded";
        goto LABEL_106;
      }
      v50 = (char *)__nw_create_backtrace_string();
      v45 = __nwlog_obj();
      v46 = type;
      v51 = os_log_type_enabled(v45, type);
      if (!v50)
      {
        if (!v51)
          goto LABEL_107;
        *(_DWORD *)buf = 136446210;
        v57 = "nw_http_connect_reattach_protocol";
        v47 = "%{public}s called with null definition, no backtrace";
        goto LABEL_106;
      }
      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        v57 = "nw_http_connect_reattach_protocol";
        v58 = 2082;
        v59 = v50;
        v52 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_91:
        _os_log_impl(&dword_182FBE000, v45, v46, v52, buf, 0x16u);
      }
LABEL_92:
      free(v50);
      if (!v44)
        goto LABEL_52;
      goto LABEL_108;
    }
    v45 = __nwlog_obj();
    v46 = type;
    if (!os_log_type_enabled(v45, type))
      goto LABEL_107;
    *(_DWORD *)buf = 136446210;
    v57 = "nw_http_connect_reattach_protocol";
    v47 = "%{public}s called with null definition";
LABEL_106:
    _os_log_impl(&dword_182FBE000, v45, v46, v47, buf, 0xCu);
    goto LABEL_107;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_http_connect_reattach_protocol";
    v44 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (!__nwlog_fault(v44, &type, &v54))
      goto LABEL_107;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v45 = __nwlog_obj();
      v46 = type;
      if (!os_log_type_enabled(v45, type))
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_http_connect_reattach_protocol";
      v47 = "%{public}s called with null protocol_parameters";
      goto LABEL_106;
    }
    if (!v54)
    {
      v45 = __nwlog_obj();
      v46 = type;
      if (!os_log_type_enabled(v45, type))
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_http_connect_reattach_protocol";
      v47 = "%{public}s called with null protocol_parameters, backtrace limit exceeded";
      goto LABEL_106;
    }
    v50 = (char *)__nw_create_backtrace_string();
    v45 = __nwlog_obj();
    v46 = type;
    v53 = os_log_type_enabled(v45, type);
    if (!v50)
    {
      if (!v53)
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      v57 = "nw_http_connect_reattach_protocol";
      v47 = "%{public}s called with null protocol_parameters, no backtrace";
      goto LABEL_106;
    }
    if (v53)
    {
      *(_DWORD *)buf = 136446466;
      v57 = "nw_http_connect_reattach_protocol";
      v58 = 2082;
      v59 = v50;
      v52 = "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s";
      goto LABEL_91;
    }
    goto LABEL_92;
  }
  v15 = a3;

  internal = nw_protocol_create_internal((uint64_t)v15 + 8, *(void **)(v14 + 120), *(const char **)(v14 + 112), 1);
  if (internal)
  {
    v17 = internal;
    v18 = a4;
    v18[2] = v17;

    v19 = *(uint64_t (***)(uint64_t, uint64_t))(v17 + 24);
    if (v19 && (v20 = *v19) != 0)
    {
      v21 = v20(v17, v13);
      v22 = v21;
      if (*(_QWORD *)(v14 + 56))
      {
        if ((v21 & 1) != 0)
          goto LABEL_20;
      }
      else
      {
        nw_protocol_set_output_handler(v14 + 24, v17);
        if ((v22 & 1) != 0)
        {
LABEL_20:
          **(_QWORD **)(a1 + 48) = v17;
          v23 = *(_QWORD *)(a1 + 40);
          if (!v23 || (*(_WORD *)(v23 + 368) & 0x80) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              v25 = *(_QWORD *)(a1 + 40);
              v26 = v25 == 0;
              if (v25)
                v27 = (const char *)(v25 + 284);
              else
                v27 = "";
              *(_DWORD *)buf = 136446978;
              v57 = "nw_http_connect_reattach_protocols_block_invoke";
              v58 = 2082;
              v59 = (void *)v27;
              if (v26)
                v28 = "";
              else
                v28 = " ";
              v60 = 2080;
              v61 = v28;
              v62 = 2114;
              v63 = v15;
              _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sAttached protocol: %{public}@", buf, 0x2Au);
            }
          }
          return 1;
        }
      }
      if ((*(_WORD *)(v14 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v36 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          v57 = "nw_http_connect_reattach_protocol";
          v58 = 2082;
          v59 = (void *)(v14 + 284);
          v60 = 2080;
          v61 = " ";
          v62 = 2114;
          v63 = v15;
          v37 = "%{public}s %{public}s%sCould not add input handler for %{public}@";
          goto LABEL_51;
        }
      }
    }
    else if ((*(_WORD *)(v14 + 368) & 0x80) == 0)
    {
      v36 = __nwlog_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v57 = "nw_http_connect_reattach_protocol";
        v58 = 2082;
        v59 = (void *)(v14 + 284);
        v60 = 2080;
        v61 = " ";
        v62 = 2114;
        v63 = v15;
        v37 = "%{public}s %{public}s%sCannot call add input handler for %{public}@ because it is not valid";
        goto LABEL_51;
      }
    }
  }
  else if ((*(_WORD *)(v14 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v36 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446978;
      v57 = "nw_http_connect_reattach_protocol";
      v58 = 2082;
      v59 = (void *)(v14 + 284);
      v60 = 2080;
      v61 = " ";
      v62 = 2114;
      v63 = v15;
      v37 = "%{public}s %{public}s%sPath could not create protocol for %{public}@";
LABEL_51:
      _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_ERROR, v37, buf, 0x2Au);
    }
  }
LABEL_52:
  v38 = *(_QWORD *)(a1 + 40);
  if (!v38 || (*(_WORD *)(v38 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v39 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v40 = *(_QWORD *)(a1 + 40);
      v41 = v40 == 0;
      if (v40)
        v42 = (const char *)(v40 + 284);
      else
        v42 = "";
      *(_DWORD *)buf = 136446978;
      v57 = "nw_http_connect_reattach_protocols_block_invoke";
      v58 = 2082;
      v59 = (void *)v42;
      if (v41)
        v43 = "";
      else
        v43 = " ";
      v60 = 2080;
      v61 = v43;
      v62 = 2114;
      v63 = a3;
      _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sFailed to attach protocol %{public}@", buf, 0x2Au);
    }
  }
  result = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

BOOL nw_http_connect_in_async(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_DWORD *)(a1 + 276) != 0;
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_http_connect_in_async";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_http_connect_in_async";
        v5 = "%{public}s called with null http_connect";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_http_connect_in_async";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_http_connect_in_async";
        v5 = "%{public}s called with null http_connect, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_http_connect_in_async";
        v5 = "%{public}s called with null http_connect, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

uint64_t nw_http_connect_send_request(uint64_t a1, CFTypeRef cf)
{
  __CFHTTPMessage *Request;
  NSObject *v5;
  CFDataRef v6;
  const __CFData *v7;
  const void *v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t *v25;
  nw_endpoint_type_t v26;
  nw_endpoint_type_t v27;
  const char *hostname;
  char *v29;
  uint64_t v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  const char *v38;
  char *v39;
  char *v40;
  const __CFAllocator *v41;
  const char *v42;
  const char *v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFURL *v46;
  const __CFURL *v47;
  uint64_t v48;
  const char *v49;
  NSObject *v50;
  uint32_t v51;
  char *v52;
  _BOOL4 v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  const char *v57;
  uint64_t v58;
  char *v59;
  _BOOL4 v60;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  const char *v64;
  char *v65;
  _BOOL4 v66;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  const char *v70;
  char *v71;
  _BOOL4 v72;
  char *v73;
  _BOOL4 v74;
  NSObject *v75;
  uint64_t v76;
  const __CFString *v77;
  const __CFString *v78;
  void *v79;
  id v80;
  const char *v81;
  const __CFString *v82;
  const __CFString *v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  NSObject *v87;
  int v88;
  uint64_t v89;
  NSObject *v90;
  char *v91;
  _BOOL4 v92;
  char *v93;
  NSObject *v94;
  os_log_type_t v95;
  const char *v96;
  char *v97;
  NSObject *v98;
  os_log_type_t v99;
  const char *v100;
  const void *v101;
  NSObject *v102;
  char *v103;
  _BOOL4 v104;
  char *v105;
  NSObject *v106;
  _BOOL4 v107;
  NSObject *v108;
  const void *v109;
  const void *v110;
  const void *v111;
  void *v112;
  id *v113;
  void *v114;
  id *v115;
  id v116;
  id v117;
  NSObject *v118;
  int v119;
  const char *v120;
  const char *v121;
  unsigned int port;
  const __CFString *v123;
  NSObject *v124;
  char *v125;
  char *v126;
  const char *v127;
  unsigned int v128;
  char *v129;
  NSObject *v130;
  os_log_type_t v131;
  const char *v132;
  NSObject *v133;
  const char *v134;
  const char *v135;
  char *backtrace_string;
  _BOOL4 v137;
  NSObject *v138;
  os_log_type_t v139;
  const char *v140;
  NSObject *v141;
  os_log_type_t v142;
  const char *v143;
  NSObject *v144;
  char *v145;
  _BOOL4 v146;
  char *v147;
  _BOOL4 v148;
  char *v149;
  _BOOL4 v150;
  NSObject *log;
  __CFHTTPMessage *v153;
  __CFHTTPMessage *v154;
  __CFHTTPMessage *v155;
  os_log_type_t type[8];
  uint64_t v157;
  uint64_t v158;
  void *v159;
  os_log_type_t *v160;
  os_log_type_t v161[8];
  os_log_type_t *v162;
  uint64_t v163;
  int v164;
  char v165;
  uint64_t v166;
  uint64_t *v167;
  uint64_t v168;
  uint64_t *v169;
  _BYTE buf[24];
  const char *v171;
  __int128 v172;
  uint64_t v173;

  v173 = *MEMORY[0x1E0C80C00];
  if (!a1 || (*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      v133 = __nwlog_obj();
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
      {
        v134 = " ";
        v135 = (const char *)(a1 + 284);
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        *(_DWORD *)buf = 136446722;
        if (!a1)
        {
          v134 = "";
          v135 = "";
        }
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v135;
        *(_WORD *)&buf[22] = 2080;
        v171 = v134;
        _os_log_impl(&dword_182FBE000, v133, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
    if (!a1)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
      v129 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v161[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v129, type, v161))
        goto LABEL_324;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v130 = __nwlog_obj();
        v131 = type[0];
        if (!os_log_type_enabled(v130, type[0]))
          goto LABEL_324;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        v132 = "%{public}s called with null http_connect";
      }
      else if (v161[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v130 = __nwlog_obj();
        v131 = type[0];
        v137 = os_log_type_enabled(v130, type[0]);
        if (backtrace_string)
        {
          if (v137)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v130, v131, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_324;
        }
        if (!v137)
        {
LABEL_324:
          if (v129)
            free(v129);
          return 0;
        }
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        v132 = "%{public}s called with null http_connect, no backtrace";
      }
      else
      {
        v130 = __nwlog_obj();
        v131 = type[0];
        if (!os_log_type_enabled(v130, type[0]))
          goto LABEL_324;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        v132 = "%{public}s called with null http_connect, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v130, v131, v132, buf, 0xCu);
      goto LABEL_324;
    }
  }
  if (cf)
  {
    Request = (__CFHTTPMessage *)CFRetain(cf);
    goto LABEL_7;
  }
  if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    if (gLogDatapath)
    {
      v144 = __nwlog_obj();
      if (os_log_type_enabled(v144, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        _os_log_impl(&dword_182FBE000, v144, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
      }
    }
  }
  v26 = nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 144));
  if (v26 == nw_endpoint_type_address)
  {
    v29 = nw_endpoint_copy_address_string(*(nw_endpoint_t *)(a1 + 144));
    hostname = 0;
  }
  else
  {
    v27 = v26;
    if (v26 != nw_endpoint_type_host)
    {
      if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v48 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 284;
          *(_WORD *)&buf[22] = 2080;
          v171 = " ";
          LOWORD(v172) = 1024;
          *(_DWORD *)((char *)&v172 + 2) = v27;
          v49 = "%{public}s %{public}s%sUnsupported endpoint type: %d";
          v50 = v48;
          v51 = 38;
LABEL_85:
          _os_log_impl(&dword_182FBE000, v50, OS_LOG_TYPE_ERROR, v49, buf, v51);
        }
      }
LABEL_86:
      nw_http_connect_fail(a1, 22);
      if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
        return 0;
LABEL_213:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v102 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        _os_log_impl(&dword_182FBE000, v102, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sFailed to create request message", buf, 0x20u);
        return 0;
      }
      return 0;
    }
    hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 144));
    v29 = 0;
  }
  v39 = nw_endpoint_copy_port_string(*(nw_endpoint_t *)(a1 + 144));
  if (!v39)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v58 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v49 = "%{public}s %{public}s%sCannot connect without port";
        v50 = v58;
        v51 = 32;
        goto LABEL_85;
      }
    }
    goto LABEL_86;
  }
  v40 = v39;
  v41 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v42 = "";
  if (v29)
    v42 = v29;
  if (hostname)
    v43 = hostname;
  else
    v43 = v42;
  v44 = CFStringCreateWithFormat(v41, 0, CFSTR("%s:%s"), v43, v39);
  if (!v44)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
      goto LABEL_186;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    v171 = " ";
    v61 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v61, type, v161))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v62 = gLogObj;
        v63 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_184;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v64 = "%{public}s %{public}s%sCFStringCreateWithFormat failed";
        goto LABEL_183;
      }
      if (v161[0] == OS_LOG_TYPE_DEFAULT)
      {
        v62 = __nwlog_obj();
        v63 = type[0];
        if (!os_log_type_enabled(v62, type[0]))
          goto LABEL_184;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v64 = "%{public}s %{public}s%sCFStringCreateWithFormat failed, backtrace limit exceeded";
        goto LABEL_183;
      }
      v71 = (char *)__nw_create_backtrace_string();
      v62 = __nwlog_obj();
      v63 = type[0];
      v72 = os_log_type_enabled(v62, type[0]);
      if (v71)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 284;
          *(_WORD *)&buf[22] = 2080;
          v171 = " ";
          LOWORD(v172) = 2082;
          *(_QWORD *)((char *)&v172 + 2) = v71;
          _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s %{public}s%sCFStringCreateWithFormat failed, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v71);
        goto LABEL_184;
      }
      if (v72)
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v64 = "%{public}s %{public}s%sCFStringCreateWithFormat failed, no backtrace";
LABEL_183:
        _os_log_impl(&dword_182FBE000, v62, v63, v64, buf, 0x20u);
      }
    }
LABEL_184:
    if (v61)
      free(v61);
LABEL_186:
    if (!v29)
    {
LABEL_212:
      free(v40);
      if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
        return 0;
      goto LABEL_213;
    }
LABEL_211:
    free(v29);
    goto LABEL_212;
  }
  v45 = v44;
  v46 = CFURLCreateWithString(v41, v44, 0);
  if (!v46)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
      goto LABEL_209;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    v171 = " ";
    v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v67, type, v161))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v68 = __nwlog_obj();
        v69 = type[0];
        if (!os_log_type_enabled(v68, type[0]))
          goto LABEL_207;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v70 = "%{public}s %{public}s%sCFURLCreateWithString failed";
LABEL_206:
        _os_log_impl(&dword_182FBE000, v68, v69, v70, buf, 0x20u);
        goto LABEL_207;
      }
      if (v161[0] == OS_LOG_TYPE_DEFAULT)
      {
        v68 = __nwlog_obj();
        v69 = type[0];
        if (!os_log_type_enabled(v68, type[0]))
          goto LABEL_207;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v70 = "%{public}s %{public}s%sCFURLCreateWithString failed, backtrace limit exceeded";
        goto LABEL_206;
      }
      v73 = (char *)__nw_create_backtrace_string();
      v68 = __nwlog_obj();
      v69 = type[0];
      v74 = os_log_type_enabled(v68, type[0]);
      if (!v73)
      {
        if (!v74)
          goto LABEL_207;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v70 = "%{public}s %{public}s%sCFURLCreateWithString failed, no backtrace";
        goto LABEL_206;
      }
      if (v74)
      {
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        LOWORD(v172) = 2082;
        *(_QWORD *)((char *)&v172 + 2) = v73;
        _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s %{public}s%sCFURLCreateWithString failed, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v73);
    }
LABEL_207:
    if (v67)
LABEL_208:
      free(v67);
LABEL_209:
    v101 = v45;
    goto LABEL_210;
  }
  v47 = v46;
  Request = CFHTTPMessageCreateRequest(v41, CFSTR("CONNECT"), v46, CFSTR("HTTP/1.1"));
  CFRelease(v47);
  if (!Request)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
      goto LABEL_209;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    v171 = " ";
    v67 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v67, type, v161))
      goto LABEL_207;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
        goto LABEL_207;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      v70 = "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed";
    }
    else if (v161[0])
    {
      v91 = (char *)__nw_create_backtrace_string();
      v68 = __nwlog_obj();
      v69 = type[0];
      v92 = os_log_type_enabled(v68, type[0]);
      if (v91)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 284;
          *(_WORD *)&buf[22] = 2080;
          v171 = " ";
          LOWORD(v172) = 2082;
          *(_QWORD *)((char *)&v172 + 2) = v91;
          _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v91);
        if (!v67)
          goto LABEL_209;
        goto LABEL_208;
      }
      if (!v92)
        goto LABEL_207;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      v70 = "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed, no backtrace";
    }
    else
    {
      v68 = __nwlog_obj();
      v69 = type[0];
      if (!os_log_type_enabled(v68, type[0]))
        goto LABEL_207;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      v70 = "%{public}s %{public}s%sCFHTTPMessageCreateRequest failed, backtrace limit exceeded";
    }
    goto LABEL_206;
  }
  if (strcmp(v40, "443"))
  {
    CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Host"), v45);
    goto LABEL_149;
  }
  v77 = CFStringCreateWithCString(v41, v43, 0x600u);
  if (!v77)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
    {
LABEL_273:
      CFRelease(v45);
      v101 = Request;
      goto LABEL_210;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    v171 = " ";
    v93 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v93, type, v161))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v94 = __nwlog_obj();
        v95 = type[0];
        if (!os_log_type_enabled(v94, type[0]))
          goto LABEL_271;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v96 = "%{public}s %{public}s%sCFStringCreateWithCString failed";
        goto LABEL_270;
      }
      if (v161[0] == OS_LOG_TYPE_DEFAULT)
      {
        v94 = __nwlog_obj();
        v95 = type[0];
        if (!os_log_type_enabled(v94, type[0]))
          goto LABEL_271;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v96 = "%{public}s %{public}s%sCFStringCreateWithCString failed, backtrace limit exceeded";
        goto LABEL_270;
      }
      v155 = Request;
      v103 = (char *)__nw_create_backtrace_string();
      v94 = __nwlog_obj();
      v95 = type[0];
      v104 = os_log_type_enabled(v94, type[0]);
      if (v103)
      {
        if (v104)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 284;
          *(_WORD *)&buf[22] = 2080;
          v171 = " ";
          LOWORD(v172) = 2082;
          *(_QWORD *)((char *)&v172 + 2) = v103;
          _os_log_impl(&dword_182FBE000, v94, v95, "%{public}s %{public}s%sCFStringCreateWithCString failed, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v103);
        Request = v155;
        goto LABEL_271;
      }
      Request = v155;
      if (v104)
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v96 = "%{public}s %{public}s%sCFStringCreateWithCString failed, no backtrace";
LABEL_270:
        _os_log_impl(&dword_182FBE000, v94, v95, v96, buf, 0x20u);
      }
    }
LABEL_271:
    if (v93)
      free(v93);
    goto LABEL_273;
  }
  v78 = v77;
  CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Host"), v77);
  CFRelease(v78);
LABEL_149:
  CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Connection"), CFSTR("keep-alive"));
  CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Proxy-Connection"), CFSTR("keep-alive"));
  v79 = *(void **)(a1 + 184);
  if (v79)
  {
    v80 = v79;
    *(_QWORD *)type = 0;
    v157 = (uint64_t)type;
    v158 = 0x2020000000;
    v159 = 0;
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __nw_proxy_options_get_http_proxy_authorization_header_block_invoke;
    v171 = (const char *)&unk_1E14A9D68;
    *(_QWORD *)&v172 = type;
    nw_protocol_options_access_handle(v80, buf);
    v81 = *(const char **)(v157 + 24);
    _Block_object_dispose(type, 8);

    if (v81)
    {
      v82 = CFStringCreateWithCString(v41, v81, 0x8000100u);
      if (v82)
      {
        v83 = v82;
        CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Proxy-Authorization"), v82);
        CFRelease(v83);
        goto LABEL_234;
      }
      if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
      {
        v154 = Request;
        __nwlog_obj();
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v97 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        v161[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v97, type, v161))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v98 = __nwlog_obj();
            v99 = type[0];
            if (os_log_type_enabled(v98, type[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 284;
              *(_WORD *)&buf[22] = 2080;
              v171 = " ";
              v100 = "%{public}s %{public}s%sCFStringCreateWithCString failed";
LABEL_229:
              v108 = v98;
LABEL_230:
              _os_log_impl(&dword_182FBE000, v108, v99, v100, buf, 0x20u);
            }
          }
          else if (v161[0])
          {
            v105 = (char *)__nw_create_backtrace_string();
            v106 = __nwlog_obj();
            v99 = type[0];
            log = v106;
            v107 = os_log_type_enabled(v106, type[0]);
            if (v105)
            {
              if (v107)
              {
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = a1 + 284;
                *(_WORD *)&buf[22] = 2080;
                v171 = " ";
                LOWORD(v172) = 2082;
                *(_QWORD *)((char *)&v172 + 2) = v105;
                _os_log_impl(&dword_182FBE000, log, v99, "%{public}s %{public}s%sCFStringCreateWithCString failed, dumping backtrace:%{public}s", buf, 0x2Au);
              }
              free(v105);
              goto LABEL_231;
            }
            if (v107)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 284;
              *(_WORD *)&buf[22] = 2080;
              v171 = " ";
              v100 = "%{public}s %{public}s%sCFStringCreateWithCString failed, no backtrace";
              v108 = log;
              goto LABEL_230;
            }
          }
          else
          {
            v98 = __nwlog_obj();
            v99 = type[0];
            if (os_log_type_enabled(v98, type[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = a1 + 284;
              *(_WORD *)&buf[22] = 2080;
              v171 = " ";
              v100 = "%{public}s %{public}s%sCFStringCreateWithCString failed, backtrace limit exceeded";
              goto LABEL_229;
            }
          }
        }
LABEL_231:
        if (v97)
          free(v97);
        Request = v154;
      }
    }
  }
LABEL_234:
  CFRelease(v45);
  v109 = *(const void **)(a1 + 216);
  if (v109)
  {
    CFRelease(v109);
    *(_QWORD *)(a1 + 216) = 0;
  }
  v110 = *(const void **)(a1 + 192);
  if (v110)
  {
    CFRelease(v110);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v111 = *(const void **)(a1 + 208);
  if (v111)
  {
    CFRelease(v111);
    *(_QWORD *)(a1 + 208) = 0;
  }
  v112 = *(void **)(a1 + 160);
  if (!v112 || (v113 = (id *)os_retain(v112)) == 0)
  {
    v114 = *(void **)(a1 + 152);
    if (v114)
    {
      v115 = (id *)os_retain(v114);
      if (v115)
      {
        v113 = v115;
        v116 = nw_endpoint_copy_parent_endpoint(v115);
        if (v116)
        {
          v117 = v116;
          do
          {
            os_release(v113);
            v113 = (id *)v117;
            v117 = v113[14];

          }
          while (v117);
        }
        goto LABEL_247;
      }
    }
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      v124 = __nwlog_obj();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_create_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        _os_log_impl(&dword_182FBE000, v124, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sunable to derive the correct proxy url", buf, 0x20u);
      }
    }
    v101 = Request;
LABEL_210:
    CFRelease(v101);
    if (!v29)
      goto LABEL_212;
    goto LABEL_211;
  }
LABEL_247:
  v118 = v113;
  v119 = -[NSObject type](v118, "type");

  if (v119 == 2)
  {
    if ((*(_WORD *)(a1 + 368) & 0x100) != 0)
      v120 = "https";
    else
      v120 = "http";
    v121 = nw_endpoint_get_hostname(v118);
    port = nw_endpoint_get_port(v118);
    v123 = CFStringCreateWithFormat(v41, 0, CFSTR("%s://%s:%d/"), v120, v121, port);
    goto LABEL_262;
  }
  if (nw_endpoint_get_type(v118) == nw_endpoint_type_address)
  {
    v125 = nw_endpoint_copy_address_string(v118);
    if (v125)
    {
      v126 = v125;
      if ((*(_WORD *)(a1 + 368) & 0x100) != 0)
        v127 = "https";
      else
        v127 = "http";
      v128 = nw_endpoint_get_port(v118);
      v123 = CFStringCreateWithFormat(v41, 0, CFSTR("%s://%s:%d/"), v127, v126, v128);
      free(v126);
LABEL_262:
      os_release(v118);
      if (v123)
      {
        *(_QWORD *)(a1 + 216) = CFURLCreateWithString(v41, v123, 0);
        CFRelease(v123);
      }
      goto LABEL_265;
    }
  }
  os_release(v118);
LABEL_265:
  *(_QWORD *)(a1 + 192) = CFRetain(Request);
  if (v29)
    free(v29);
  free(v40);
LABEL_7:
  if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      LOWORD(v172) = 2048;
      *(_QWORD *)((char *)&v172 + 2) = Request;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sSending http_message %p", buf, 0x2Au);
    }
  }
  v6 = CFHTTPMessageCopySerializedMessage(Request);
  if (!v6)
  {
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
    {
LABEL_120:
      if (Request)
        CFRelease(Request);
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = a1 + 284;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    v171 = " ";
    v31 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v161[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v31, type, v161))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = gLogObj;
        v33 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_118;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v30;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v34 = "%{public}s %{public}s%sCFHTTPMessageCopySerializedMessage failed";
        goto LABEL_117;
      }
      if (v161[0] == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = gLogObj;
        v33 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_118;
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v30;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v34 = "%{public}s %{public}s%sCFHTTPMessageCopySerializedMessage failed, backtrace limit exceeded";
        goto LABEL_117;
      }
      v52 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = gLogObj;
      v33 = type[0];
      v53 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v52)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v30;
          *(_WORD *)&buf[22] = 2080;
          v171 = " ";
          LOWORD(v172) = 2082;
          *(_QWORD *)((char *)&v172 + 2) = v52;
          _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s %{public}s%sCFHTTPMessageCopySerializedMessage failed, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v52);
        goto LABEL_118;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v30;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        v34 = "%{public}s %{public}s%sCFHTTPMessageCopySerializedMessage failed, no backtrace";
LABEL_117:
        _os_log_impl(&dword_182FBE000, v32, v33, v34, buf, 0x20u);
      }
    }
LABEL_118:
    if (v31)
      free(v31);
    goto LABEL_120;
  }
  v7 = v6;
  v8 = *(const void **)(a1 + 200);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 200) = 0;
  }
  BytePtr = CFDataGetBytePtr(v7);
  Length = CFDataGetLength(v7);
  if (!BytePtr)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
    v35 = (char *)_os_log_send_and_compose_impl();
    v161[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v168) = 0;
    if (!__nwlog_fault(v35, v161, &v168))
      goto LABEL_339;
    if (v161[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = v161[0];
      if (!os_log_type_enabled(v138, v161[0]))
        goto LABEL_339;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v140 = "%{public}s called with null buffer";
      goto LABEL_338;
    }
    if (!(_BYTE)v168)
    {
      v138 = __nwlog_obj();
      v139 = v161[0];
      if (!os_log_type_enabled(v138, v161[0]))
        goto LABEL_339;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v140 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_338;
    }
    v145 = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = v161[0];
    v146 = os_log_type_enabled(v138, v161[0]);
    if (!v145)
    {
      if (!v146)
        goto LABEL_339;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v140 = "%{public}s called with null buffer, no backtrace";
      goto LABEL_338;
    }
    if (v146)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v145;
      _os_log_impl(&dword_182FBE000, v138, v139, "%{public}s called with null buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v145);
LABEL_339:
    if (!v35)
      goto LABEL_141;
    goto LABEL_140;
  }
  v11 = Length;
  if (!(_DWORD)Length)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
    v35 = (char *)_os_log_send_and_compose_impl();
    v161[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v168) = 0;
    if (!__nwlog_fault(v35, v161, &v168))
      goto LABEL_339;
    if (v161[0] == OS_LOG_TYPE_FAULT)
    {
      v138 = __nwlog_obj();
      v139 = v161[0];
      if (!os_log_type_enabled(v138, v161[0]))
        goto LABEL_339;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v140 = "%{public}s called with null length";
      goto LABEL_338;
    }
    if (!(_BYTE)v168)
    {
      v138 = __nwlog_obj();
      v139 = v161[0];
      if (!os_log_type_enabled(v138, v161[0]))
        goto LABEL_339;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v140 = "%{public}s called with null length, backtrace limit exceeded";
      goto LABEL_338;
    }
    v147 = (char *)__nw_create_backtrace_string();
    v138 = __nwlog_obj();
    v139 = v161[0];
    v148 = os_log_type_enabled(v138, v161[0]);
    if (v147)
    {
      if (v148)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v147;
        _os_log_impl(&dword_182FBE000, v138, v139, "%{public}s called with null length, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v147);
      if (v35)
        goto LABEL_140;
      goto LABEL_141;
    }
    if (v148)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v140 = "%{public}s called with null length, no backtrace";
LABEL_338:
      _os_log_impl(&dword_182FBE000, v138, v139, v140, buf, 0xCu);
      goto LABEL_339;
    }
    goto LABEL_339;
  }
  v168 = 0;
  v169 = &v168;
  v166 = 0;
  v167 = &v166;
  v12 = *(_QWORD *)(a1 + 56);
  if (!v12)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
    v35 = (char *)_os_log_send_and_compose_impl();
    v161[0] = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (!__nwlog_fault(v35, v161, &v165))
      goto LABEL_344;
    if (v161[0] == OS_LOG_TYPE_FAULT)
    {
      v141 = __nwlog_obj();
      v142 = v161[0];
      if (!os_log_type_enabled(v141, v161[0]))
        goto LABEL_344;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v143 = "%{public}s called with null output_handler";
    }
    else if (v165)
    {
      v149 = (char *)__nw_create_backtrace_string();
      v141 = __nwlog_obj();
      v142 = v161[0];
      v150 = os_log_type_enabled(v141, v161[0]);
      if (v149)
      {
        if (v150)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v149;
          _os_log_impl(&dword_182FBE000, v141, v142, "%{public}s called with null output_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v149);
LABEL_344:
        if (!v35)
          goto LABEL_141;
        goto LABEL_140;
      }
      if (!v150)
        goto LABEL_344;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v143 = "%{public}s called with null output_handler, no backtrace";
    }
    else
    {
      v141 = __nwlog_obj();
      v142 = v161[0];
      if (!os_log_type_enabled(v141, v161[0]))
        goto LABEL_344;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      v143 = "%{public}s called with null output_handler, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v141, v142, v143, buf, 0xCu);
    goto LABEL_344;
  }
  v13 = (*(uint64_t (**)(_QWORD, uint64_t, CFIndex, CFIndex, uint64_t, uint64_t *))(*(_QWORD *)(v12 + 24) + 88))(*(_QWORD *)(a1 + 56), a1 + 24, Length, Length, 0xFFFFFFFFLL, &v168);
  v14 = v13;
  v15 = v168;
  if (!v168 || !v13)
  {
    if (!v13 || (*(_WORD *)(a1 + 368) & 0x80) != 0)
      goto LABEL_141;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    v171 = " ";
    LOWORD(v172) = 1024;
    *(_DWORD *)((char *)&v172 + 2) = v14;
    v35 = (char *)_os_log_send_and_compose_impl();
    v161[0] = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (!__nwlog_fault(v35, v161, &v165))
      goto LABEL_139;
    if (v161[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = gLogObj;
      v37 = v161[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v161[0]))
        goto LABEL_139;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      LOWORD(v172) = 1024;
      *(_DWORD *)((char *)&v172 + 2) = v14;
      v38 = "%{public}s %{public}s%sOutput handler reported %u frames to write, but array is empty";
    }
    else if (v165)
    {
      v59 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = gLogObj;
      v37 = v161[0];
      v60 = os_log_type_enabled((os_log_t)gLogObj, v161[0]);
      if (v59)
      {
        if (v60)
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = a1 + 284;
          *(_WORD *)&buf[22] = 2080;
          v171 = " ";
          LOWORD(v172) = 1024;
          *(_DWORD *)((char *)&v172 + 2) = v14;
          WORD3(v172) = 2082;
          *((_QWORD *)&v172 + 1) = v59;
          _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s %{public}s%sOutput handler reported %u frames to write, but array is empty, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v59);
LABEL_139:
        if (v35)
LABEL_140:
          free(v35);
LABEL_141:
        if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v75 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 284;
            *(_WORD *)&buf[22] = 2080;
            v171 = " ";
            _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sFailed to send http connect request", buf, 0x20u);
          }
        }
        v76 = 0;
        if (!Request)
          goto LABEL_146;
LABEL_145:
        CFRelease(Request);
        goto LABEL_146;
      }
      if (!v60)
        goto LABEL_139;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      LOWORD(v172) = 1024;
      *(_DWORD *)((char *)&v172 + 2) = v14;
      v38 = "%{public}s %{public}s%sOutput handler reported %u frames to write, but array is empty, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = gLogObj;
      v37 = v161[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, v161[0]))
        goto LABEL_139;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      LOWORD(v172) = 1024;
      *(_DWORD *)((char *)&v172 + 2) = v14;
      v38 = "%{public}s %{public}s%sOutput handler reported %u frames to write, but array is empty, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v36, v37, v38, buf, 0x26u);
    goto LABEL_139;
  }
  v153 = Request;
  while (1)
  {
    v16 = *(_QWORD *)(v15 + 32);
    if (v16 || *(_QWORD *)(v15 + 40))
    {
      v17 = *(_QWORD *)(v15 + 112);
      if (!v17)
        goto LABEL_29;
    }
    else
    {
      v16 = 0;
      v17 = *(_QWORD *)(v15 + 112);
      if (!v17)
        goto LABEL_29;
    }
    if ((*(_WORD *)(v15 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v15, *(_QWORD *)(v15 + 88)))
    {
      LODWORD(v17) = 0;
LABEL_29:
      v19 = 0;
      goto LABEL_30;
    }
    LODWORD(v17) = *(_DWORD *)(v15 + 52);
    v18 = *(unsigned int *)(v15 + 56);
    if ((_DWORD)v17)
      LODWORD(v17) = v17 - (v18 + *(_DWORD *)(v15 + 60));
    v19 = (void *)(*(_QWORD *)(v15 + 112) + v18);
LABEL_30:
    v20 = v17 >= v11 ? v11 : v17;
    memcpy(v19, BytePtr, v20);
    if (!nw_frame_claim(v15, v21, v20, 0))
      break;
    nw_frame_collapse(v15);
    nw_frame_unclaim(v15, v22, v20, 0);
    v23 = *(_QWORD *)(v15 + 32);
    v24 = *(_QWORD **)(v15 + 40);
    if (v23)
    {
      *(_QWORD *)(v23 + 40) = v24;
      v24 = *(_QWORD **)(v15 + 40);
    }
    else
    {
      v169 = *(uint64_t **)(v15 + 40);
    }
    *v24 = v23;
    v25 = v167;
    *(_QWORD *)(v15 + 32) = 0;
    *(_QWORD *)(v15 + 40) = v25;
    *v25 = v15;
    v167 = (uint64_t *)(v15 + 32);
    if (v16)
    {
      BytePtr += v20;
      v15 = v16;
      v11 -= v20;
      if (v11)
        continue;
    }
    goto LABEL_158;
  }
  if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = a1 + 284;
    *(_WORD *)&buf[22] = 2080;
    v171 = " ";
    LOWORD(v172) = 1024;
    *(_DWORD *)((char *)&v172 + 2) = v20;
    v54 = (char *)_os_log_send_and_compose_impl();
    v161[0] = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (!__nwlog_fault(v54, v161, &v165))
      goto LABEL_156;
    if (v161[0] != OS_LOG_TYPE_FAULT)
    {
      if (v165)
      {
        v65 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v55 = gLogObj;
        v56 = v161[0];
        v66 = os_log_type_enabled((os_log_t)gLogObj, v161[0]);
        if (v65)
        {
          if (v66)
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a1 + 284;
            *(_WORD *)&buf[22] = 2080;
            v171 = " ";
            LOWORD(v172) = 1024;
            *(_DWORD *)((char *)&v172 + 2) = v20;
            WORD3(v172) = 2082;
            *((_QWORD *)&v172 + 1) = v65;
            _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s %{public}s%sClaiming frame with %u bytes failed, dumping backtrace:%{public}s", buf, 0x30u);
          }
          free(v65);
          goto LABEL_156;
        }
        if (!v66)
          goto LABEL_156;
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        LOWORD(v172) = 1024;
        *(_DWORD *)((char *)&v172 + 2) = v20;
        v57 = "%{public}s %{public}s%sClaiming frame with %u bytes failed, no backtrace";
      }
      else
      {
        v55 = __nwlog_obj();
        v56 = v161[0];
        if (!os_log_type_enabled(v55, v161[0]))
          goto LABEL_156;
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        LOWORD(v172) = 1024;
        *(_DWORD *)((char *)&v172 + 2) = v20;
        v57 = "%{public}s %{public}s%sClaiming frame with %u bytes failed, backtrace limit exceeded";
      }
LABEL_155:
      _os_log_impl(&dword_182FBE000, v55, v56, v57, buf, 0x26u);
      goto LABEL_156;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v55 = gLogObj;
    v56 = v161[0];
    if (os_log_type_enabled((os_log_t)gLogObj, v161[0]))
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      LOWORD(v172) = 1024;
      *(_DWORD *)((char *)&v172 + 2) = v20;
      v57 = "%{public}s %{public}s%sClaiming frame with %u bytes failed";
      goto LABEL_155;
    }
LABEL_156:
    if (v54)
      free(v54);
  }
LABEL_158:
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)(v12 + 24) + 96))(v12, &v166);
  v84 = v168;
  Request = v153;
  if (v168)
  {
    *(_QWORD *)v161 = 0;
    v162 = v161;
    v164 = 0;
    v163 = 0x2000000000;
    *(_QWORD *)type = MEMORY[0x1E0C809B0];
    v157 = 0x40000000;
    v158 = (uint64_t)___ZL26nw_http_connect_send_bytesP24nw_protocol_http_connectPKhj_block_invoke;
    v159 = &unk_1E14A0AD8;
    v160 = v161;
    do
    {
      if (!v84)
        break;
      v85 = *(_QWORD *)(v84 + 32);
      v86 = ((uint64_t (*)(os_log_type_t *))v158)(type);
      v84 = v85;
    }
    while ((v86 & 1) != 0);
    if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v87 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v88 = *((_DWORD *)v162 + 6);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_http_connect_send_bytes";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = a1 + 284;
        *(_WORD *)&buf[22] = 2080;
        v171 = " ";
        LOWORD(v172) = 1024;
        *(_DWORD *)((char *)&v172 + 2) = v88;
        _os_log_impl(&dword_182FBE000, v87, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sFailed to use %u frames, marking as failed", buf, 0x26u);
      }
    }
    _Block_object_dispose(v161, 8);
  }
  v89 = *(_QWORD *)(a1 + 168);
  if ((!v89 || *(_DWORD *)(v89 + 124) != 4) && (*(_WORD *)(a1 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v90 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_request";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = a1 + 284;
      *(_WORD *)&buf[22] = 2080;
      v171 = " ";
      _os_log_impl(&dword_182FBE000, v90, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sSent http connect request to proxy", buf, 0x20u);
    }
  }
  *(_WORD *)(a1 + 368) |= 8u;
  v76 = 1;
  if (v153)
    goto LABEL_145;
LABEL_146:
  CFRelease(v7);
  return v76;
}

void sub_1836D6658(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL26nw_http_connect_send_bytesP24nw_protocol_http_connectPKhj_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_frame_finalize(a2);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return 1;
}

BOOL ___ZL36nw_http_connect_process_inbound_dataP24nw_protocol_http_connect_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  const UInt8 *v7;
  uint64_t v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  unsigned int v13;
  int v14;
  __int16 v15;
  int v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  NSObject *v21;
  int v22;
  const __CFData *v23;
  const __CFData *v24;
  int v25;
  int v26;
  BOOL v27;
  int v28;
  __int16 v29;
  CFIndex ResponseStatusCode;
  uint64_t v31;
  CFIndex v32;
  uint64_t v33;
  int v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  uint64_t v38;
  NSObject *v39;
  os_log_type_t v40;
  uint64_t v41;
  int has_internal_diagnostics;
  uint64_t v43;
  NSObject *v44;
  _BOOL4 v45;
  uint64_t v46;
  int v47;
  BOOL v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  const char *v54;
  BOOL v55;
  int v56;
  const char *v57;
  NSObject *v58;
  uint32_t v59;
  NSObject *v60;
  os_log_type_t v61;
  uint32_t v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  BOOL v66;
  uint64_t v67;
  const char *v68;
  const char *v69;
  NSObject *v70;
  os_log_type_t v71;
  uint64_t v72;
  const char *v73;
  BOOL v74;
  uint64_t v75;
  const char *v76;
  const char *v77;
  char *v78;
  _BOOL4 v79;
  uint64_t v80;
  const char *v81;
  const char *v82;
  uint64_t v83;
  uint64_t v84;
  const char *v85;
  BOOL v86;
  uint64_t v87;
  const char *v88;
  uint64_t v89;
  const char *v90;
  BOOL v91;
  uint64_t v92;
  const char *v93;
  char *v94;
  char *v96;
  _BOOL4 v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  const char *v101;
  const char *v102;
  BOOL v103;
  int v104;
  uint64_t v105;
  _QWORD *v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  NSObject *v114;
  _BOOL4 v115;
  uint64_t v116;
  BOOL v117;
  const char *v118;
  const char *v119;
  NSObject *v120;
  uint64_t v121;
  BOOL v122;
  const char *v123;
  const char *v124;
  uint64_t v125;
  uint64_t v126;
  BOOL v127;
  const char *v128;
  const char *v129;
  char *v130;
  NSObject *v131;
  os_log_type_t v132;
  uint64_t v133;
  BOOL v134;
  const char *v135;
  const char *v136;
  const char *v137;
  char *v138;
  _BOOL4 v139;
  uint64_t v140;
  BOOL v141;
  const char *v142;
  const char *v143;
  uint64_t v144;
  BOOL v145;
  const char *v146;
  const char *v147;
  uint64_t v148;
  BOOL v149;
  const char *v150;
  const char *v151;
  uint64_t v152;
  uint64_t v153;
  const char *v154;
  NSObject *v155;
  os_log_type_t v156;
  const char *v157;
  NSObject *v158;
  _BOOL4 v159;
  const char *v160;
  const char *v161;
  char *backtrace_string;
  _BOOL4 v163;
  _BOOL4 v164;
  char v165;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v168;
  __int16 v169;
  void *v170;
  __int16 v171;
  const char *v172;
  __int16 v173;
  _BYTE v174[18];
  uint64_t v175;
  CFRange v176;
  CFRange v177;

  v175 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v168 = "nw_http_connect_process_inbound_data_block_invoke";
    v154 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (__nwlog_fault(v154, &type, &v165))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v155 = __nwlog_obj();
        v156 = type;
        if (os_log_type_enabled(v155, type))
        {
          *(_DWORD *)buf = 136446210;
          v168 = "nw_http_connect_process_inbound_data_block_invoke";
          v157 = "%{public}s called with null frame";
LABEL_269:
          _os_log_impl(&dword_182FBE000, v155, v156, v157, buf, 0xCu);
        }
      }
      else if (v165)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v155 = __nwlog_obj();
        v156 = type;
        v163 = os_log_type_enabled(v155, type);
        if (backtrace_string)
        {
          if (v163)
          {
            *(_DWORD *)buf = 136446466;
            v168 = "nw_http_connect_process_inbound_data_block_invoke";
            v169 = 2082;
            v170 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v155, v156, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_270;
        }
        if (v163)
        {
          *(_DWORD *)buf = 136446210;
          v168 = "nw_http_connect_process_inbound_data_block_invoke";
          v157 = "%{public}s called with null frame, no backtrace";
          goto LABEL_269;
        }
      }
      else
      {
        v155 = __nwlog_obj();
        v156 = type;
        if (os_log_type_enabled(v155, type))
        {
          *(_DWORD *)buf = 136446210;
          v168 = "nw_http_connect_process_inbound_data_block_invoke";
          v157 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_269;
        }
      }
    }
LABEL_270:
    if (!v154)
      return 0;
    v94 = (char *)v154;
    goto LABEL_138;
  }
  if (!*(_QWORD *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(_QWORD *)(a2 + 88)))
  {
    v6 = 0;
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 32);
    if (v8)
      goto LABEL_16;
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 52);
    v4 = *(unsigned int *)(a2 + 56);
    if (v5)
      v6 = v5 - (v4 + *(_DWORD *)(a2 + 60));
    else
      v6 = 0;
    v7 = (const UInt8 *)(*(_QWORD *)(a2 + 112) + v4);
    v8 = *(_QWORD *)(a1 + 32);
    if (v8)
    {
LABEL_16:
      if ((*(_WORD *)(v8 + 368) & 0x80) != 0 || !gLogDatapath)
        goto LABEL_18;
      goto LABEL_244;
    }
  }
  if (!gLogDatapath)
    goto LABEL_10;
LABEL_244:
  v158 = __nwlog_obj();
  v159 = os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG);
  v8 = *(_QWORD *)(a1 + 32);
  if (v159)
  {
    v160 = "";
    *(_DWORD *)buf = 136447234;
    v168 = "nw_http_connect_process_inbound_data_block_invoke";
    v161 = (const char *)(v8 + 284);
    if (!v8)
      v161 = "";
    v169 = 2082;
    v170 = (void *)v161;
    v171 = 2080;
    if (v8)
      v160 = " ";
    v172 = v160;
    v173 = 2048;
    *(_QWORD *)v174 = a2;
    *(_WORD *)&v174[8] = 1024;
    *(_DWORD *)&v174[10] = v6;
    _os_log_impl(&dword_182FBE000, v158, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sProcessing frame (%p, %u bytes)", buf, 0x30u);
    v8 = *(_QWORD *)(a1 + 32);
  }
  if (!v8)
  {
LABEL_10:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v168 = "nw_http_connect_append_bytes";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (!__nwlog_fault(v9, &type, &v165))
      goto LABEL_95;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      v12 = "%{public}s called with null http_connect";
      goto LABEL_93;
    }
    if (!v165)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      v12 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_93;
    }
    v35 = (char *)__nw_create_backtrace_string();
    v10 = __nwlog_obj();
    v11 = type;
    v36 = os_log_type_enabled(v10, type);
    if (!v35)
    {
      if (!v36)
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      v12 = "%{public}s called with null http_connect, no backtrace";
      goto LABEL_93;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v168 = "nw_http_connect_append_bytes";
      v169 = 2082;
      v170 = v35;
      v37 = "%{public}s called with null http_connect, dumping backtrace:%{public}s";
LABEL_62:
      _os_log_impl(&dword_182FBE000, v10, v11, v37, buf, 0x16u);
    }
LABEL_63:
    free(v35);
    if (!v9)
      goto LABEL_97;
    goto LABEL_96;
  }
LABEL_18:
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v168 = "nw_http_connect_append_bytes";
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (!__nwlog_fault(v9, &type, &v165))
      goto LABEL_95;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      v12 = "%{public}s called with null new_bytes";
      goto LABEL_93;
    }
    if (v165)
    {
      v35 = (char *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v164 = os_log_type_enabled(v10, type);
      if (v35)
      {
        if (v164)
        {
          *(_DWORD *)buf = 136446466;
          v168 = "nw_http_connect_append_bytes";
          v169 = 2082;
          v170 = v35;
          v37 = "%{public}s called with null new_bytes, dumping backtrace:%{public}s";
          goto LABEL_62;
        }
        goto LABEL_63;
      }
      if (!v164)
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      v12 = "%{public}s called with null new_bytes, no backtrace";
    }
    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_95;
      *(_DWORD *)buf = 136446210;
      v168 = "nw_http_connect_append_bytes";
      v12 = "%{public}s called with null new_bytes, backtrace limit exceeded";
    }
LABEL_93:
    v60 = v10;
    v61 = v11;
    v62 = 12;
LABEL_94:
    _os_log_impl(&dword_182FBE000, v60, v61, v12, buf, v62);
    goto LABEL_95;
  }
  if (CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(v8 + 200)))
  {
    v13 = *(_DWORD *)(v8 + 260) + v6;
    *(_DWORD *)(v8 + 260) = v13;
    v14 = *(_DWORD *)(v8 + 256);
    v15 = *(_WORD *)(v8 + 368);
    v27 = __OFSUB__(v13, v14);
    v16 = v13 - v14;
    if (v16 < 0 != v27)
    {
      *(_WORD *)(v8 + 368) = v15 & 0xFFFD;
      *(_DWORD *)(v8 + 264) = 0;
    }
    else
    {
      *(_WORD *)(v8 + 368) = v15 | 2;
      *(_DWORD *)(v8 + 264) = v16;
    }
    goto LABEL_54;
  }
  if (!CFHTTPMessageAppendBytes(*(CFHTTPMessageRef *)(v8 + 200), v7, v6))
  {
    if ((*(_WORD *)(v8 + 368) & 0x80) != 0)
      goto LABEL_97;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = *(_QWORD *)(v8 + 200);
    *(_DWORD *)buf = 136446978;
    v168 = "nw_http_connect_append_bytes";
    v169 = 2082;
    v170 = (void *)(v8 + 284);
    v171 = 2080;
    v172 = " ";
    v173 = 2048;
    *(_QWORD *)v174 = v38;
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (__nwlog_fault(v9, &type, &v165))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v39 = gLogObj;
        v40 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_95;
        v41 = *(_QWORD *)(v8 + 200);
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_append_bytes";
        v169 = 2082;
        v170 = (void *)(v8 + 284);
        v171 = 2080;
        v172 = " ";
        v173 = 2048;
        *(_QWORD *)v174 = v41;
        v12 = "%{public}s %{public}s%sFailed to apply bytes to response message %p";
        goto LABEL_239;
      }
      if (v165)
      {
        v96 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v39 = gLogObj;
        v40 = type;
        v97 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v96)
        {
          if (v97)
          {
            v98 = *(_QWORD *)(v8 + 200);
            *(_DWORD *)buf = 136447234;
            v168 = "nw_http_connect_append_bytes";
            v169 = 2082;
            v170 = (void *)(v8 + 284);
            v171 = 2080;
            v172 = " ";
            v173 = 2048;
            *(_QWORD *)v174 = v98;
            *(_WORD *)&v174[8] = 2082;
            *(_QWORD *)&v174[10] = v96;
            _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s %{public}s%sFailed to apply bytes to response message %p, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v96);
          goto LABEL_95;
        }
        if (!v97)
          goto LABEL_95;
        v153 = *(_QWORD *)(v8 + 200);
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_append_bytes";
        v169 = 2082;
        v170 = (void *)(v8 + 284);
        v171 = 2080;
        v172 = " ";
        v173 = 2048;
        *(_QWORD *)v174 = v153;
        v12 = "%{public}s %{public}s%sFailed to apply bytes to response message %p, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v39 = gLogObj;
        v40 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_95;
        v152 = *(_QWORD *)(v8 + 200);
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_append_bytes";
        v169 = 2082;
        v170 = (void *)(v8 + 284);
        v171 = 2080;
        v172 = " ";
        v173 = 2048;
        *(_QWORD *)v174 = v152;
        v12 = "%{public}s %{public}s%sFailed to apply bytes to response message %p, backtrace limit exceeded";
      }
LABEL_239:
      v60 = v39;
      v61 = v40;
      v62 = 42;
      goto LABEL_94;
    }
LABEL_95:
    if (v9)
LABEL_96:
      free(v9);
LABEL_97:
    v63 = *(_QWORD *)(a1 + 32);
    if (v63 && (*(_WORD *)(v63 + 368) & 0x80) != 0)
      return 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v64 = *(_QWORD *)(a1 + 32);
    v65 = (const char *)(v64 + 284);
    v66 = v64 == 0;
    v67 = *(_QWORD *)(v64 + 200);
    *(_DWORD *)buf = 136446978;
    if (v66)
      v65 = "";
    v168 = "nw_http_connect_process_inbound_data_block_invoke";
    if (v66)
      v68 = "";
    else
      v68 = " ";
    v169 = 2082;
    v170 = (void *)v65;
    v171 = 2080;
    v172 = v68;
    v173 = 2048;
    *(_QWORD *)v174 = v67;
    v69 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (!__nwlog_fault(v69, &type, &v165))
      goto LABEL_136;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = gLogObj;
      v71 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v72 = *(_QWORD *)(a1 + 32);
        v73 = (const char *)(v72 + 284);
        v74 = v72 == 0;
        if (!v72)
          v73 = "";
        v75 = *(_QWORD *)(v72 + 200);
        if (v74)
          v76 = "";
        else
          v76 = " ";
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_process_inbound_data_block_invoke";
        v169 = 2082;
        v170 = (void *)v73;
        v171 = 2080;
        v172 = v76;
        v173 = 2048;
        *(_QWORD *)v174 = v75;
        v77 = "%{public}s %{public}s%sFailed to apply bytes to response message %p";
LABEL_135:
        _os_log_impl(&dword_182FBE000, v70, v71, v77, buf, 0x2Au);
      }
    }
    else if (v165)
    {
      v78 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = gLogObj;
      v71 = type;
      v79 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v78)
      {
        if (v79)
        {
          v80 = *(_QWORD *)(a1 + 32);
          v81 = (const char *)(v80 + 284);
          if (v80)
          {
            v82 = " ";
          }
          else
          {
            v81 = "";
            v82 = "";
          }
          v83 = *(_QWORD *)(v80 + 200);
          *(_DWORD *)buf = 136447234;
          v168 = "nw_http_connect_process_inbound_data_block_invoke";
          v169 = 2082;
          v170 = (void *)v81;
          v171 = 2080;
          v172 = v82;
          v173 = 2048;
          *(_QWORD *)v174 = v83;
          *(_WORD *)&v174[8] = 2082;
          *(_QWORD *)&v174[10] = v78;
          _os_log_impl(&dword_182FBE000, v70, v71, "%{public}s %{public}s%sFailed to apply bytes to response message %p, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v78);
        goto LABEL_136;
      }
      if (v79)
      {
        v89 = *(_QWORD *)(a1 + 32);
        v90 = (const char *)(v89 + 284);
        v91 = v89 == 0;
        if (!v89)
          v90 = "";
        v92 = *(_QWORD *)(v89 + 200);
        if (v91)
          v93 = "";
        else
          v93 = " ";
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_process_inbound_data_block_invoke";
        v169 = 2082;
        v170 = (void *)v90;
        v171 = 2080;
        v172 = v93;
        v173 = 2048;
        *(_QWORD *)v174 = v92;
        v77 = "%{public}s %{public}s%sFailed to apply bytes to response message %p, no backtrace";
        goto LABEL_135;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v70 = gLogObj;
      v71 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        v84 = *(_QWORD *)(a1 + 32);
        v85 = (const char *)(v84 + 284);
        v86 = v84 == 0;
        if (!v84)
          v85 = "";
        v87 = *(_QWORD *)(v84 + 200);
        if (v86)
          v88 = "";
        else
          v88 = " ";
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_process_inbound_data_block_invoke";
        v169 = 2082;
        v170 = (void *)v85;
        v171 = 2080;
        v172 = v88;
        v173 = 2048;
        *(_QWORD *)v174 = v87;
        v77 = "%{public}s %{public}s%sFailed to apply bytes to response message %p, backtrace limit exceeded";
        goto LABEL_135;
      }
    }
LABEL_136:
    if (!v69)
      return 0;
    v94 = (char *)v69;
LABEL_138:
    free(v94);
    return 0;
  }
  if (CFHTTPMessageIsHeaderComplete(*(CFHTTPMessageRef *)(v8 + 200)))
  {
    v17 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(v8 + 200), CFSTR("Content-Length"));
    v18 = v17;
    if (v17)
      *(_DWORD *)(v8 + 256) = CFStringGetIntValue(v17);
    v19 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(v8 + 200), CFSTR("Connection"));
    if (v19)
    {
      v176.length = CFStringGetLength(CFSTR("Close"));
      v176.location = 0;
      if (CFStringCompareWithOptions(v19, CFSTR("Close"), v176, 1uLL) == kCFCompareEqualTo)
        *(_WORD *)(v8 + 368) |= 0x20u;
    }
    v20 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(v8 + 200), CFSTR("Proxy-Connection"));
    if (v20)
    {
      v177.length = CFStringGetLength(CFSTR("Close"));
      v177.location = 0;
      if (CFStringCompareWithOptions(v20, CFSTR("Close"), v177, 1uLL) == kCFCompareEqualTo)
        *(_WORD *)(v8 + 368) |= 0x20u;
    }
    if (CFHTTPMessageGetResponseStatusCode(*(CFHTTPMessageRef *)(v8 + 200)) == 200)
    {
      if (*(_DWORD *)(v8 + 256))
      {
        if ((*(_WORD *)(v8 + 368) & 0x80) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v22 = *(_DWORD *)(v8 + 256);
            *(_DWORD *)buf = 136446978;
            v168 = "nw_http_connect_append_bytes";
            v169 = 2082;
            v170 = (void *)(v8 + 284);
            v171 = 2080;
            v172 = " ";
            v173 = 1024;
            *(_DWORD *)v174 = v22;
            _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sProxy server sent back 200 OK and specified a Content-Length (%d)", buf, 0x26u);
          }
        }
      }
      *(_DWORD *)(v8 + 256) = 0;
    }
    v23 = CFHTTPMessageCopyBody(*(CFHTTPMessageRef *)(v8 + 200));
    v24 = v23;
    if (v23)
      LODWORD(v23) = CFDataGetLength(v23);
    v25 = *(_DWORD *)(v8 + 260) + (_DWORD)v23;
    v26 = *(_DWORD *)(v8 + 256);
    v27 = __OFSUB__(v25, v26);
    v28 = v25 - v26;
    v29 = v28 < 0 == v27;
    *(_DWORD *)(v8 + 260) = v25;
    if (v28 < 0 != v27)
      v28 = 0;
    *(_WORD *)(v8 + 368) = *(_WORD *)(v8 + 368) & 0xFFFD | (2 * v29);
    *(_DWORD *)(v8 + 264) = v28;
    if (v24)
      CFRelease(v24);
    if (v20)
      CFRelease(v20);
    if (v19)
      CFRelease(v19);
    if (v18)
      CFRelease(v18);
  }
LABEL_54:
  ResponseStatusCode = CFHTTPMessageGetResponseStatusCode(*(CFHTTPMessageRef *)(*(_QWORD *)(a1 + 32) + 200));
  v32 = ResponseStatusCode;
  v33 = *(_QWORD *)(a1 + 32);
  if ((*(_WORD *)(v33 + 368) & 2) == 0)
    goto LABEL_154;
  v34 = *(_DWORD *)(v33 + 264);
  if (!v34)
    goto LABEL_154;
  if (ResponseStatusCode != 200)
  {
    has_internal_diagnostics = os_variant_has_internal_diagnostics();
    v43 = *(_QWORD *)(a1 + 32);
    if (!has_internal_diagnostics)
    {
      if (v43 && (*(_WORD *)(v43 + 368) & 0x80) != 0)
        goto LABEL_154;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v99 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_154;
      v100 = *(_QWORD *)(a1 + 32);
      v101 = (const char *)(v100 + 284);
      v102 = "";
      v103 = v100 == 0;
      v104 = *(_DWORD *)(v100 + 264);
      if (v103)
        v101 = "";
      v168 = "nw_http_connect_process_inbound_data_block_invoke";
      v169 = 2082;
      *(_DWORD *)buf = 136446978;
      if (!v103)
        v102 = " ";
      v170 = (void *)v101;
      v171 = 2080;
      v172 = v102;
      v173 = 1024;
      *(_DWORD *)v174 = v104;
      v57 = "%{public}s %{public}s%s%d bytes of unexpected response data from server";
      v58 = v99;
      v59 = 38;
      goto LABEL_153;
    }
    if (!v43 || (*(_WORD *)(v43 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v44 = gLogObj;
      v45 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      v46 = *(_QWORD *)(a1 + 32);
      if (v45)
      {
        v47 = *(_DWORD *)(v46 + 264);
        v48 = v46 == 0;
        if (v46)
          v49 = (const char *)(v46 + 284);
        else
          v49 = "";
        *(_DWORD *)buf = 136446978;
        v168 = "nw_http_connect_process_inbound_data_block_invoke";
        v169 = 2082;
        v170 = (void *)v49;
        if (v48)
          v50 = "";
        else
          v50 = " ";
        v171 = 2080;
        v172 = v50;
        v173 = 1024;
        *(_DWORD *)v174 = v47;
        _os_log_impl(&dword_182FBE000, v44, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%d bytes of unexpected data from server:", buf, 0x26u);
        v46 = *(_QWORD *)(a1 + 32);
      }
      if (!v46 || (*(_WORD *)(v46 + 368) & 0x80) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v51 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v52 = *(_QWORD *)(a1 + 32);
          v53 = (const char *)(v52 + 284);
          v54 = "";
          v55 = v52 == 0;
          v56 = *(_DWORD *)(v52 + 264);
          v168 = "nw_http_connect_process_inbound_data_block_invoke";
          if (v55)
            v53 = "";
          v169 = 2082;
          *(_DWORD *)buf = 136447234;
          if (!v55)
            v54 = " ";
          v170 = (void *)v53;
          v171 = 2080;
          v172 = v54;
          v173 = 1040;
          *(_DWORD *)v174 = v56;
          *(_WORD *)&v174[4] = 2096;
          *(_QWORD *)&v174[6] = &v7[v6 - v56];
          v57 = "%{public}s %{public}s%s%{network:data}.*P";
          v58 = v51;
          v59 = 48;
LABEL_153:
          _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_ERROR, v57, buf, v59);
        }
      }
    }
LABEL_154:
    v105 = *(_QWORD *)(a2 + 32);
    v106 = *(_QWORD **)(a2 + 40);
    if (v105)
    {
      *(_QWORD *)(v105 + 40) = v106;
      v106 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 232) = v106;
    }
    *v106 = v105;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
    v107 = *(_QWORD *)(a1 + 32);
    if ((*(_WORD *)(v107 + 368) & 2) == 0)
      return (*(_WORD *)(*(_QWORD *)(a1 + 32) + 368) & 2) == 0;
    if (v32 == 200)
      return (*(_WORD *)(*(_QWORD *)(a1 + 32) + 368) & 2) == 0;
    v108 = *(_QWORD *)(v107 + 224);
    if (!v108)
      return (*(_WORD *)(*(_QWORD *)(a1 + 32) + 368) & 2) == 0;
    if (os_variant_has_internal_diagnostics()
      && *(_QWORD *)(v108 + 112)
      && ((*(_WORD *)(v108 + 204) & 0x100) == 0
       || !g_channel_check_validity
       || g_channel_check_validity(v108, *(_QWORD *)(v108 + 88))))
    {
      v109 = *(_DWORD *)(v108 + 52);
      if (v109)
      {
        v110 = *(_QWORD *)(v108 + 112);
        if (v110)
        {
          v111 = *(unsigned int *)(v108 + 56);
          v112 = v109 - (v111 + *(_DWORD *)(v108 + 60));
          if (v112)
          {
            v113 = *(_QWORD *)(a1 + 32);
            if (!v113 || (*(_WORD *)(v113 + 368) & 0x80) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v114 = gLogObj;
              v115 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
              v116 = *(_QWORD *)(a1 + 32);
              if (v115)
              {
                v117 = v116 == 0;
                if (v116)
                  v118 = (const char *)(v116 + 284);
                else
                  v118 = "";
                *(_DWORD *)buf = 136446722;
                v168 = "nw_http_connect_process_inbound_data_block_invoke";
                v119 = " ";
                if (v117)
                  v119 = "";
                v169 = 2082;
                v170 = (void *)v118;
                v171 = 2080;
                v172 = v119;
                _os_log_impl(&dword_182FBE000, v114, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sUnexpected data from server:", buf, 0x20u);
                v116 = *(_QWORD *)(a1 + 32);
              }
              if (!v116 || (*(_WORD *)(v116 + 368) & 0x80) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v120 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  v121 = *(_QWORD *)(a1 + 32);
                  v168 = "nw_http_connect_process_inbound_data_block_invoke";
                  *(_DWORD *)buf = 136447234;
                  v122 = v121 == 0;
                  if (v121)
                    v123 = (const char *)(v121 + 284);
                  else
                    v123 = "";
                  v169 = 2082;
                  v170 = (void *)v123;
                  v124 = " ";
                  v171 = 2080;
                  if (v122)
                    v124 = "";
                  v172 = v124;
                  v173 = 1040;
                  *(_DWORD *)v174 = v112;
                  *(_WORD *)&v174[4] = 2096;
                  *(_QWORD *)&v174[6] = v110 + v111;
                  _os_log_impl(&dword_182FBE000, v120, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%{network:data}.*P", buf, 0x30u);
                }
              }
            }
          }
        }
      }
    }
    v125 = *(_QWORD *)(a1 + 32);
    if (v125)
    {
      if ((*(_WORD *)(v125 + 368) & 0x80) != 0)
        return (*(_WORD *)(*(_QWORD *)(a1 + 32) + 368) & 2) == 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v126 = *(_QWORD *)(a1 + 32);
    v127 = v126 == 0;
    if (v126)
      v128 = (const char *)(v126 + 284);
    else
      v128 = "";
    *(_DWORD *)buf = 136446722;
    v168 = "nw_http_connect_process_inbound_data_block_invoke";
    if (v127)
      v129 = "";
    else
      v129 = " ";
    v169 = 2082;
    v170 = (void *)v128;
    v171 = 2080;
    v172 = v129;
    v130 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (!__nwlog_fault(v130, &type, &v165))
      goto LABEL_232;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v131 = gLogObj;
      v132 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_232;
      v133 = *(_QWORD *)(a1 + 32);
      v134 = v133 == 0;
      if (v133)
        v135 = (const char *)(v133 + 284);
      else
        v135 = "";
      *(_DWORD *)buf = 136446722;
      if (v134)
        v136 = "";
      else
        v136 = " ";
      v168 = "nw_http_connect_process_inbound_data_block_invoke";
      v169 = 2082;
      v170 = (void *)v135;
      v171 = 2080;
      v172 = v136;
      v137 = "%{public}s %{public}s%sFrames remaining after response header is complete";
    }
    else if (v165)
    {
      v138 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v131 = gLogObj;
      v132 = type;
      v139 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v138)
      {
        if (v139)
        {
          v140 = *(_QWORD *)(a1 + 32);
          v141 = v140 == 0;
          if (v140)
            v142 = (const char *)(v140 + 284);
          else
            v142 = "";
          if (v141)
            v143 = "";
          else
            v143 = " ";
          *(_DWORD *)buf = 136446978;
          v168 = "nw_http_connect_process_inbound_data_block_invoke";
          v169 = 2082;
          v170 = (void *)v142;
          v171 = 2080;
          v172 = v143;
          v173 = 2082;
          *(_QWORD *)v174 = v138;
          _os_log_impl(&dword_182FBE000, v131, v132, "%{public}s %{public}s%sFrames remaining after response header is complete, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v138);
        goto LABEL_232;
      }
      if (!v139)
      {
LABEL_232:
        if (v130)
          free(v130);
        return (*(_WORD *)(*(_QWORD *)(a1 + 32) + 368) & 2) == 0;
      }
      v148 = *(_QWORD *)(a1 + 32);
      v149 = v148 == 0;
      if (v148)
        v150 = (const char *)(v148 + 284);
      else
        v150 = "";
      *(_DWORD *)buf = 136446722;
      if (v149)
        v151 = "";
      else
        v151 = " ";
      v168 = "nw_http_connect_process_inbound_data_block_invoke";
      v169 = 2082;
      v170 = (void *)v150;
      v171 = 2080;
      v172 = v151;
      v137 = "%{public}s %{public}s%sFrames remaining after response header is complete, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v131 = gLogObj;
      v132 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_232;
      v144 = *(_QWORD *)(a1 + 32);
      v145 = v144 == 0;
      if (v144)
        v146 = (const char *)(v144 + 284);
      else
        v146 = "";
      *(_DWORD *)buf = 136446722;
      if (v145)
        v147 = "";
      else
        v147 = " ";
      v168 = "nw_http_connect_process_inbound_data_block_invoke";
      v169 = 2082;
      v170 = (void *)v146;
      v171 = 2080;
      v172 = v147;
      v137 = "%{public}s %{public}s%sFrames remaining after response header is complete, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v131, v132, v137, buf, 0x20u);
    goto LABEL_232;
  }
  nw_frame_claim(a2, v31, v6 - v34, 0);
  return (*(_WORD *)(*(_QWORD *)(a1 + 32) + 368) & 2) == 0;
}

void ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke(uint64_t a1, char *object, int a3)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  BOOL v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  _QWORD v15[6];
  char v16;
  _BYTE buf[24];
  const char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 40);
  if (!v6 || (*(_WORD *)(v6 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v8 = *(_QWORD *)(a1 + 40);
      v9 = v8 == 0;
      if (v8)
        v10 = (const char *)(v8 + 284);
      else
        v10 = "";
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_auth_challenge_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v10;
      if (v9)
        v11 = "";
      else
        v11 = " ";
      *(_WORD *)&buf[22] = 2080;
      v18 = v11;
      v19 = 1024;
      v20 = a3;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect returned from challenge handler, cancel is %d", buf, 0x26u);
    }
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2000000000;
  v18 = object;
  if (object)
    os_retain(object);
  v12 = *(_QWORD *)(a1 + 40);
  v13 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[2] = ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke_33;
  v15[3] = &unk_1E14A09C8;
  v15[1] = 0x40000000;
  v15[4] = buf;
  v15[5] = v12;
  v16 = a3;
  nw_queue_context_async_if_needed(v13, v15);
  v14 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v14)
  {
    os_release(v14);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  _Block_object_dispose(buf, 8);
}

void nw_http_connect_send_auth_request(uint64_t a1)
{
  void *v2;
  __CFDictionary *Mutable;
  const void *v4;
  NSObject *v5;
  const __CFAllocator *v6;
  const char *username;
  CFStringRef v8;
  CFStringRef v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *v14;
  _BOOL4 v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *v20;
  _BOOL4 v21;
  const char *password;
  CFStringRef v23;
  CFStringRef v24;
  char *backtrace_string;
  _BOOL4 v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  char *v31;
  _BOOL4 v32;
  char v33;
  os_log_type_t v34[8];
  os_log_type_t *v35;
  uint64_t v36;
  void *v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  char *v42;
  __int16 v43;
  const char *v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)v34 = 0;
    v35 = v34;
    v36 = 0x2000000000;
    v37 = 0;
    v2 = *(void **)(a1 + 168);
    if (v2)
      v2 = os_retain(v2);
    v37 = v2;
    if (!*(_QWORD *)(a1 + 176) || *(_DWORD *)(a1 + 272))
    {
      Mutable = 0;
      v4 = *(const void **)(a1 + 208);
      if (!v4)
        goto LABEL_8;
      goto LABEL_7;
    }
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      username = (const char *)nw_authentication_credential_get_username(*(void **)(a1 + 176));
      if (!username)
      {
        nw_authentication_credential_get_password(*(void **)(a1 + 176));
        goto LABEL_71;
      }
      v8 = CFStringCreateWithCString(v6, username, 0x8000100u);
      if (v8)
      {
        v9 = v8;
        CFDictionarySetValue(Mutable, CFSTR("kCFHTTPAuthenticationUsername"), v8);
        CFRelease(v9);
        goto LABEL_51;
      }
      if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
      {
LABEL_51:
        password = (const char *)nw_authentication_credential_get_password(*(void **)(a1 + 176));
        v23 = CFStringCreateWithCString(v6, password, 0x8000100u);
        if (v23)
        {
          v24 = v23;
          CFDictionarySetValue(Mutable, CFSTR("kCFHTTPAuthenticationPassword"), v23);
          CFRelease(v24);
          goto LABEL_71;
        }
        if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446722;
          v40 = "nw_http_connect_send_auth_request";
          v41 = 2082;
          v42 = (char *)(a1 + 284);
          v43 = 2080;
          v44 = " ";
          v10 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v33 = 0;
          if (!__nwlog_fault(v10, &type, &v33))
            goto LABEL_69;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v11 = __nwlog_obj();
            v12 = type;
            if (!os_log_type_enabled(v11, type))
              goto LABEL_69;
            *(_DWORD *)buf = 136446722;
            v40 = "nw_http_connect_send_auth_request";
            v41 = 2082;
            v42 = (char *)(a1 + 284);
            v43 = 2080;
            v44 = " ";
            v13 = "%{public}s %{public}s%sCFStringCreateWithCString failed";
            goto LABEL_68;
          }
          if (!v33)
          {
            v11 = __nwlog_obj();
            v12 = type;
            if (!os_log_type_enabled(v11, type))
              goto LABEL_69;
            *(_DWORD *)buf = 136446722;
            v40 = "nw_http_connect_send_auth_request";
            v41 = 2082;
            v42 = (char *)(a1 + 284);
            v43 = 2080;
            v44 = " ";
            v13 = "%{public}s %{public}s%sCFStringCreateWithCString failed, backtrace limit exceeded";
            goto LABEL_68;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          v11 = __nwlog_obj();
          v12 = type;
          v26 = os_log_type_enabled(v11, type);
          if (!backtrace_string)
          {
            if (!v26)
              goto LABEL_69;
            *(_DWORD *)buf = 136446722;
            v40 = "nw_http_connect_send_auth_request";
            v41 = 2082;
            v42 = (char *)(a1 + 284);
            v43 = 2080;
            v44 = " ";
            v13 = "%{public}s %{public}s%sCFStringCreateWithCString failed, no backtrace";
            goto LABEL_68;
          }
          if (v26)
          {
            *(_DWORD *)buf = 136446978;
            v40 = "nw_http_connect_send_auth_request";
            v41 = 2082;
            v42 = (char *)(a1 + 284);
            v43 = 2080;
            v44 = " ";
            v45 = 2082;
            v46 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s %{public}s%sCFStringCreateWithCString failed, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
          if (v10)
LABEL_70:
            free(v10);
        }
LABEL_71:
        ++*(_DWORD *)(a1 + 272);
        v4 = *(const void **)(a1 + 208);
        if (!v4)
        {
LABEL_8:
          if ((*(_WORD *)(a1 + 368) & 0x80) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v5 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446722;
              v40 = "nw_http_connect_send_auth_request";
              v41 = 2082;
              v42 = (char *)(a1 + 284);
              v43 = 2080;
              v44 = " ";
              _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect calling out for proxy authorization", buf, 0x20u);
            }
          }
          nw_http_connect_start_async(a1);
          _CFHTTPAuthenticationApplyProxyAuthorizationToRequest();
          if (Mutable)
            CFRelease(Mutable);
          _Block_object_dispose(v34, 8);
          return;
        }
LABEL_7:
        CFRelease(v4);
        *(_QWORD *)(a1 + 208) = 0;
        goto LABEL_8;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446722;
      v40 = "nw_http_connect_send_auth_request";
      v41 = 2082;
      v42 = (char *)(a1 + 284);
      v43 = 2080;
      v44 = " ";
      v16 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v33 = 0;
      if (__nwlog_fault(v16, &type, &v33))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v17 = __nwlog_obj();
          v18 = type;
          if (!os_log_type_enabled(v17, type))
            goto LABEL_49;
          *(_DWORD *)buf = 136446722;
          v40 = "nw_http_connect_send_auth_request";
          v41 = 2082;
          v42 = (char *)(a1 + 284);
          v43 = 2080;
          v44 = " ";
          v19 = "%{public}s %{public}s%sCFStringCreateWithCString failed";
          goto LABEL_48;
        }
        if (!v33)
        {
          v17 = __nwlog_obj();
          v18 = type;
          if (!os_log_type_enabled(v17, type))
            goto LABEL_49;
          *(_DWORD *)buf = 136446722;
          v40 = "nw_http_connect_send_auth_request";
          v41 = 2082;
          v42 = (char *)(a1 + 284);
          v43 = 2080;
          v44 = " ";
          v19 = "%{public}s %{public}s%sCFStringCreateWithCString failed, backtrace limit exceeded";
          goto LABEL_48;
        }
        v20 = (char *)__nw_create_backtrace_string();
        v17 = __nwlog_obj();
        v18 = type;
        v21 = os_log_type_enabled(v17, type);
        if (v20)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446978;
            v40 = "nw_http_connect_send_auth_request";
            v41 = 2082;
            v42 = (char *)(a1 + 284);
            v43 = 2080;
            v44 = " ";
            v45 = 2082;
            v46 = v20;
            _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s %{public}s%sCFStringCreateWithCString failed, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v20);
          goto LABEL_49;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446722;
          v40 = "nw_http_connect_send_auth_request";
          v41 = 2082;
          v42 = (char *)(a1 + 284);
          v43 = 2080;
          v44 = " ";
          v19 = "%{public}s %{public}s%sCFStringCreateWithCString failed, no backtrace";
LABEL_48:
          _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0x20u);
        }
      }
LABEL_49:
      if (v16)
        free(v16);
      goto LABEL_51;
    }
    if ((*(_WORD *)(a1 + 368) & 0x80) != 0)
      goto LABEL_71;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v40 = "nw_http_connect_send_auth_request";
    v41 = 2082;
    v42 = (char *)(a1 + 284);
    v43 = 2080;
    v44 = " ";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v10, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v11 = gLogObj;
        v12 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_69;
        *(_DWORD *)buf = 136446722;
        v40 = "nw_http_connect_send_auth_request";
        v41 = 2082;
        v42 = (char *)(a1 + 284);
        v43 = 2080;
        v44 = " ";
        v13 = "%{public}s %{public}s%sCFDictionaryCreateMutable failed";
LABEL_68:
        _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0x20u);
        goto LABEL_69;
      }
      if (!v33)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_69;
        *(_DWORD *)buf = 136446722;
        v40 = "nw_http_connect_send_auth_request";
        v41 = 2082;
        v42 = (char *)(a1 + 284);
        v43 = 2080;
        v44 = " ";
        v13 = "%{public}s %{public}s%sCFDictionaryCreateMutable failed, backtrace limit exceeded";
        goto LABEL_68;
      }
      v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = gLogObj;
      v12 = type;
      v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v14)
      {
        if (!v15)
          goto LABEL_69;
        *(_DWORD *)buf = 136446722;
        v40 = "nw_http_connect_send_auth_request";
        v41 = 2082;
        v42 = (char *)(a1 + 284);
        v43 = 2080;
        v44 = " ";
        v13 = "%{public}s %{public}s%sCFDictionaryCreateMutable failed, no backtrace";
        goto LABEL_68;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446978;
        v40 = "nw_http_connect_send_auth_request";
        v41 = 2082;
        v42 = (char *)(a1 + 284);
        v43 = 2080;
        v44 = " ";
        v45 = 2082;
        v46 = v14;
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s %{public}s%sCFDictionaryCreateMutable failed, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v14);
    }
LABEL_69:
    if (!v10)
      goto LABEL_71;
    goto LABEL_70;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v40 = "nw_http_connect_send_auth_request";
  v27 = (char *)_os_log_send_and_compose_impl();
  v34[0] = OS_LOG_TYPE_ERROR;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v27, v34, &type))
  {
    if (v34[0] == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = v34[0];
      if (!os_log_type_enabled(v28, v34[0]))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_http_connect_send_auth_request";
      v30 = "%{public}s called with null http_connect";
      goto LABEL_86;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      v28 = __nwlog_obj();
      v29 = v34[0];
      if (!os_log_type_enabled(v28, v34[0]))
        goto LABEL_87;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_http_connect_send_auth_request";
      v30 = "%{public}s called with null http_connect, backtrace limit exceeded";
      goto LABEL_86;
    }
    v31 = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = v34[0];
    v32 = os_log_type_enabled(v28, v34[0]);
    if (v31)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        v40 = "nw_http_connect_send_auth_request";
        v41 = 2082;
        v42 = v31;
        _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null http_connect, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v31);
      goto LABEL_87;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_http_connect_send_auth_request";
      v30 = "%{public}s called with null http_connect, no backtrace";
LABEL_86:
      _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0xCu);
    }
  }
LABEL_87:
  if (v27)
    free(v27);
}

void ___ZL33nw_http_connect_send_auth_requestP24nw_protocol_http_connect_block_invoke(uint64_t a1, const char *cf, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  const char *v11;
  BOOL v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  _QWORD v17[8];
  _BYTE buf[24];
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 40);
  if (!v8 || (*(_WORD *)(v8 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v10 = *(_QWORD *)(a1 + 40);
      v11 = "";
      v12 = v10 == 0;
      if (v10)
        v13 = (const char *)(v10 + 284);
      else
        v13 = "";
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_http_connect_send_auth_request_block_invoke";
      if (!v12)
        v11 = " ";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v13;
      *(_WORD *)&buf[22] = 2080;
      v19 = v11;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect returned from proxy authorization", buf, 0x20u);
    }
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2000000000;
  v19 = cf;
  if (cf)
    CFRetain(cf);
  v14 = *(_QWORD *)(a1 + 40);
  v15 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v17[0] = MEMORY[0x1E0C809B0];
  v17[2] = ___ZL33nw_http_connect_send_auth_requestP24nw_protocol_http_connect_block_invoke_42;
  v17[3] = &unk_1E14A0A18;
  v17[1] = 0x40000000;
  v17[4] = buf;
  v17[5] = v14;
  v17[6] = a3;
  v17[7] = a4;
  nw_queue_context_async_if_needed(v15, v17);
  v16 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v16)
  {
    os_release(v16);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  _Block_object_dispose(buf, 8);
}

void ___ZL33nw_http_connect_send_auth_requestP24nw_protocol_http_connect_block_invoke_42(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  BOOL v6;
  const char *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL4 v12;
  const char *v13;
  const char *v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  _BOOL4 v18;
  const char *v19;
  const char *v20;
  const void *v21;
  __int16 v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  const char *v27;
  const char *v28;
  BOOL v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(void);
  uint64_t v34;
  const char *v35;
  const char *v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  const char *v43;
  char *backtrace_string;
  _BOOL4 v45;
  uint64_t v46;
  const char *v47;
  const char *v48;
  uint64_t v49;
  const char *v50;
  const char *v51;
  uint64_t v52;
  const char *v53;
  const char *v54;
  char v55;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  void *v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  int v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2 || (*(_WORD *)(v2 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    v2 = *(_QWORD *)(a1 + 40);
    if (v4)
    {
      v5 = "";
      v6 = v2 == 0;
      if (v2)
        v7 = (const char *)(v2 + 284);
      else
        v7 = "";
      *(_DWORD *)buf = 136446722;
      v58 = "nw_http_connect_send_auth_request_block_invoke";
      if (!v6)
        v5 = " ";
      v59 = 2082;
      v60 = v7;
      v61 = 2080;
      v62 = (void *)v5;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect returned from proxy authorization async", buf, 0x20u);
      v2 = *(_QWORD *)(a1 + 40);
    }
  }
  *(_QWORD *)(v2 + 208) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v8 = nw_http_connect_end_async(*(_QWORD *)(a1 + 40));
  v9 = *(_QWORD *)(a1 + 40);
  if (!v8)
  {
    if (!v9 || (*(_WORD *)(v9 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
      v9 = *(_QWORD *)(a1 + 40);
      if (v18)
      {
        v19 = "";
        v20 = (const char *)(v9 + 284);
        if (!v9)
          v20 = "";
        *(_DWORD *)buf = 136446722;
        v58 = "nw_http_connect_send_auth_request_block_invoke";
        if (v9)
          v19 = " ";
        v59 = 2082;
        v60 = v20;
        v61 = 2080;
        v62 = (void *)v19;
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sStopping proxy authorization because state has changed to destroyed while getting signed request", buf, 0x20u);
        v9 = *(_QWORD *)(a1 + 40);
      }
    }
    nw_http_connect_destroy(v9);
    return;
  }
  v10 = *(_QWORD *)(v9 + 168);
  if ((!v10 || *(_DWORD *)(v10 + 124) != 4) && (*(_WORD *)(v9 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = gLogObj;
    v12 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    v9 = *(_QWORD *)(a1 + 40);
    if (v12)
    {
      v13 = (const char *)(v9 + 284);
      v14 = "";
      if (!v9)
        v13 = "";
      v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v9)
        v14 = " ";
      v16 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136447234;
      v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      v60 = v13;
      v61 = 2080;
      v62 = (void *)v14;
      v63 = 2048;
      v64 = v15;
      v65 = 1024;
      v66 = v16;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect proxy authentication received request %p error %d", buf, 0x30u);
      v9 = *(_QWORD *)(a1 + 40);
    }
  }
  if (*(_DWORD *)(a1 + 56))
  {
    if (!v9)
      goto LABEL_38;
    goto LABEL_37;
  }
  v21 = *(const void **)(v9 + 208);
  if (!v21)
  {
LABEL_37:
    if ((*(_WORD *)(v9 + 368) & 0x80) != 0)
    {
LABEL_44:
      if (*(_QWORD *)(a1 + 48) == 1)
        v24 = *(_DWORD *)(a1 + 56);
      else
        v24 = 80;
      v23 = *(_QWORD *)(a1 + 40);
      goto LABEL_48;
    }
LABEL_38:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v25 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      v26 = *(_QWORD *)(a1 + 40);
      v27 = (const char *)(v26 + 284);
      v28 = "";
      v29 = v26 == 0;
      v30 = *(_DWORD *)(a1 + 56);
      if (v29)
        v27 = "";
      v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      *(_DWORD *)buf = 136446978;
      if (!v29)
        v28 = " ";
      v60 = v27;
      v61 = 2080;
      v62 = (void *)v28;
      v63 = 1024;
      LODWORD(v64) = v30;
      _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sProxy authentication failed with error %d, cancelling connection", buf, 0x26u);
    }
    goto LABEL_44;
  }
  v22 = *(_WORD *)(v9 + 368);
  if ((v22 & 0x20) != 0)
  {
    if ((nw_http_connect_restart_after_disconnect(v9) & 1) != 0)
      return;
    v31 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72);
    if (v31)
    {
      v32 = *(_QWORD *)(v31 + 24);
      if (v32)
      {
        v33 = *(void (**)(void))(v32 + 48);
        if (v33)
        {
          v33();
          return;
        }
      }
    }
    __nwlog_obj();
    v34 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72);
    v35 = "invalid";
    if (v34)
    {
      v36 = *(const char **)(v34 + 16);
      if (v36)
        v35 = v36;
    }
    *(_DWORD *)buf = 136446466;
    v58 = "nw_http_connect_send_auth_request_block_invoke";
    v59 = 2082;
    v60 = v35;
    v37 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v37, &type, &v55))
      goto LABEL_84;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type))
        goto LABEL_84;
      v40 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72);
      v41 = "invalid";
      if (v40)
      {
        v42 = *(const char **)(v40 + 16);
        if (v42)
          v41 = v42;
      }
      *(_DWORD *)buf = 136446466;
      v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      v60 = v41;
      v43 = "%{public}s protocol %{public}s has invalid disconnected callback";
    }
    else if (v55)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = __nwlog_obj();
      v39 = type;
      v45 = os_log_type_enabled(v38, type);
      if (backtrace_string)
      {
        if (v45)
        {
          v46 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72);
          v47 = "invalid";
          if (v46)
          {
            v48 = *(const char **)(v46 + 16);
            if (v48)
              v47 = v48;
          }
          *(_DWORD *)buf = 136446722;
          v58 = "nw_http_connect_send_auth_request_block_invoke";
          v59 = 2082;
          v60 = v47;
          v61 = 2082;
          v62 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_84;
      }
      if (!v45)
      {
LABEL_84:
        if (v37)
          free(v37);
        return;
      }
      v52 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72);
      v53 = "invalid";
      if (v52)
      {
        v54 = *(const char **)(v52 + 16);
        if (v54)
          v53 = v54;
      }
      *(_DWORD *)buf = 136446466;
      v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      v60 = v53;
      v43 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
    }
    else
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (!os_log_type_enabled(v38, type))
        goto LABEL_84;
      v49 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 72);
      v50 = "invalid";
      if (v49)
      {
        v51 = *(const char **)(v49 + 16);
        if (v51)
          v50 = v51;
      }
      *(_DWORD *)buf = 136446466;
      v58 = "nw_http_connect_send_auth_request_block_invoke";
      v59 = 2082;
      v60 = v50;
      v43 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v38, v39, v43, buf, 0x16u);
    goto LABEL_84;
  }
  if ((v22 & 0x18) == 0x10 && (nw_http_connect_send_request(v9, v21) & 1) == 0)
  {
    v23 = *(_QWORD *)(a1 + 40);
    v24 = 22;
LABEL_48:
    nw_http_connect_fail(v23, v24);
  }
}

void ___ZL35nw_http_connect_send_auth_challengeP24nw_protocol_http_connect_block_invoke_33(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  BOOL v11;
  const char *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  if (!v2 || (*(_WORD *)(v2 + 368) & 0x80) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    v4 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO);
    v2 = *(_QWORD *)(a1 + 40);
    if (v4)
    {
      v5 = "";
      v6 = (const char *)(v2 + 284);
      if (!v2)
        v6 = "";
      v18 = 136446722;
      v19 = "nw_http_connect_send_auth_challenge_block_invoke";
      if (v2)
        v5 = " ";
      v20 = 2082;
      v21 = v6;
      v22 = 2080;
      v23 = v5;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%shttp connect returned from challenge handler async", (uint8_t *)&v18, 0x20u);
      v2 = *(_QWORD *)(a1 + 40);
    }
  }
  if (nw_http_connect_end_async(v2))
  {
    if (*(_BYTE *)(a1 + 48))
    {
      nw_http_connect_fail(*(_QWORD *)(a1 + 40), 80);
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 40);
      v15 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v15)
      {
        v16 = *(void **)(v14 + 176);
        if (!v16
          || (os_release(v16),
              *(_QWORD *)(*(_QWORD *)(a1 + 40) + 176) = 0,
              (v15 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)) != 0))
        {
          v15 = os_retain(v15);
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 40) + 176) = v15;
        v14 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)(v14 + 272) = 0;
      }
      nw_http_connect_send_auth_request(v14);
    }
    v17 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v17)
    {
      os_release(v17);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 40);
    if (!v7 || (*(_WORD *)(v7 + 368) & 0x80) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v9 = *(_QWORD *)(a1 + 40);
        v10 = "";
        v11 = v9 == 0;
        if (v9)
          v12 = (const char *)(v9 + 284);
        else
          v12 = "";
        v18 = 136446722;
        v19 = "nw_http_connect_send_auth_challenge_block_invoke";
        if (!v11)
          v10 = " ";
        v20 = 2082;
        v21 = v12;
        v22 = 2080;
        v23 = v10;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sStopping proxy authorization because state has changed to destroyed while getting authentication credentials", (uint8_t *)&v18, 0x20u);
      }
    }
    v13 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v13)
    {
      os_release(v13);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    nw_http_connect_destroy(*(_QWORD *)(a1 + 40));
  }
}

uint64_t NWPBParametersReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  unint64_t v5;
  int *v6;
  unint64_t v7;
  int *v8;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  _BYTE *v14;
  char v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  int v55;
  BOOL v56;
  _BYTE *v57;
  NWPBEndpoint *v58;
  void *v59;
  id v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  int v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  int v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  int v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  int v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  int v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  int v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  int v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  char v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  int v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  int v116;
  uint64_t v117;
  unint64_t v118;
  unint64_t v119;
  int v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  int v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  int v128;
  uint64_t v129;
  unint64_t v130;
  unint64_t v131;
  int v132;
  uint64_t v133;
  unint64_t v134;
  unint64_t v135;
  int v136;
  uint64_t v137;
  unint64_t v138;
  unint64_t v139;
  int v140;
  uint64_t v141;
  unint64_t v142;
  unint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  char v148;
  uint64_t v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  int v153;
  uint64_t v154;
  unint64_t v155;
  unint64_t v156;
  int v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  int v161;
  uint64_t v162;
  unint64_t v163;
  unint64_t v164;
  int v165;
  uint64_t v166;
  unint64_t v167;
  unint64_t v168;
  int v169;
  uint64_t v170;
  unint64_t v171;
  unint64_t v172;
  int v173;
  uint64_t v174;
  unint64_t v175;
  unint64_t v176;
  int v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  int v181;
  uint64_t v182;
  unint64_t v183;
  unint64_t v184;
  uint64_t v185;
  uint64_t v186;
  unint64_t v187;
  unint64_t v188;
  char v189;
  uint64_t v190;
  uint64_t v191;
  unint64_t v192;
  unint64_t v193;
  int v194;
  uint64_t v195;
  unint64_t v196;
  unint64_t v197;
  int v198;
  uint64_t v199;
  unint64_t v200;
  unint64_t v201;
  int v202;
  uint64_t v203;
  unint64_t v204;
  unint64_t v205;
  int v206;
  uint64_t v207;
  unint64_t v208;
  unint64_t v209;
  int v210;
  uint64_t v211;
  unint64_t v212;
  unint64_t v213;
  int v214;
  uint64_t v215;
  unint64_t v216;
  unint64_t v217;
  int v218;
  uint64_t v219;
  unint64_t v220;
  unint64_t v221;
  int v222;
  uint64_t v223;
  unint64_t v224;
  unint64_t v225;
  uint64_t v226;
  uint64_t v227;
  unint64_t v228;
  unint64_t v229;
  char v230;
  unsigned int v231;
  uint64_t v232;
  unint64_t v233;
  int v234;
  uint64_t v235;
  unint64_t v236;
  int v237;
  uint64_t v238;
  unint64_t v239;
  int v240;
  uint64_t v241;
  unint64_t v242;
  unint64_t v243;
  int v244;
  uint64_t v245;
  unint64_t v246;
  unint64_t v247;
  int v248;
  uint64_t v249;
  unint64_t v250;
  unint64_t v251;
  int v252;
  uint64_t v253;
  unint64_t v254;
  unint64_t v255;
  int v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  int v260;
  uint64_t v261;
  unint64_t v262;
  unint64_t v263;
  int v264;
  id v265;
  void *v266;
  void *v267;
  id v268;
  void *v269;
  uint64_t v270;
  unint64_t v271;
  unint64_t v272;
  char v273;
  uint64_t v274;
  uint64_t v275;
  unint64_t v276;
  unint64_t v277;
  int v278;
  uint64_t v279;
  unint64_t v280;
  unint64_t v281;
  int v282;
  uint64_t v283;
  unint64_t v284;
  unint64_t v285;
  int v286;
  uint64_t v287;
  unint64_t v288;
  unint64_t v289;
  int v290;
  uint64_t v291;
  unint64_t v292;
  unint64_t v293;
  int v294;
  uint64_t v295;
  unint64_t v296;
  unint64_t v297;
  int v298;
  uint64_t v299;
  unint64_t v300;
  unint64_t v301;
  int v302;
  uint64_t v303;
  unint64_t v304;
  unint64_t v305;
  int v306;
  uint64_t v307;
  unint64_t v308;
  unint64_t v309;
  uint64_t v310;
  uint64_t v311;
  unint64_t v312;
  unint64_t v313;
  char v314;
  unsigned int v315;
  uint64_t v316;
  unint64_t v317;
  int v318;
  uint64_t v319;
  unint64_t v320;
  int v321;
  uint64_t v322;
  unint64_t v323;
  int v324;
  uint64_t v325;
  unint64_t v326;
  unint64_t v327;
  int v328;
  uint64_t v329;
  unint64_t v330;
  unint64_t v331;
  int v332;
  uint64_t v333;
  unint64_t v334;
  unint64_t v335;
  int v336;
  uint64_t v337;
  unint64_t v338;
  unint64_t v339;
  int v340;
  uint64_t v341;
  unint64_t v342;
  unint64_t v343;
  int v344;
  uint64_t v345;
  unint64_t v346;
  unint64_t v347;
  int v348;
  uint64_t v349;
  unint64_t v350;
  unint64_t v351;
  char v352;
  uint64_t v353;
  uint64_t v354;
  unint64_t v355;
  unint64_t v356;
  int v357;
  uint64_t v358;
  unint64_t v359;
  unint64_t v360;
  int v361;
  uint64_t v362;
  unint64_t v363;
  unint64_t v364;
  int v365;
  uint64_t v366;
  unint64_t v367;
  unint64_t v368;
  int v369;
  uint64_t v370;
  unint64_t v371;
  unint64_t v372;
  int v373;
  uint64_t v374;
  unint64_t v375;
  unint64_t v376;
  int v377;
  uint64_t v378;
  unint64_t v379;
  unint64_t v380;
  int v381;
  uint64_t v382;
  unint64_t v383;
  unint64_t v384;
  int v385;
  uint64_t v386;
  unint64_t v387;
  unint64_t v388;
  uint64_t v389;
  uint64_t v390;
  unint64_t v391;
  unint64_t v392;
  char v393;
  unsigned int v394;
  uint64_t v395;
  unint64_t v396;
  int v397;
  uint64_t v398;
  unint64_t v399;
  int v400;
  uint64_t v401;
  unint64_t v402;
  int v403;
  uint64_t v404;
  unint64_t v405;
  unint64_t v406;
  int v407;
  uint64_t v408;
  unint64_t v409;
  unint64_t v410;
  int v411;
  uint64_t v412;
  unint64_t v413;
  unint64_t v414;
  int v415;
  uint64_t v416;
  unint64_t v417;
  unint64_t v418;
  int v419;
  uint64_t v420;
  unint64_t v421;
  unint64_t v422;
  int v423;
  uint64_t v424;
  unint64_t v425;
  unint64_t v426;
  int v427;
  uint64_t v428;
  unint64_t v429;
  unint64_t v430;
  char v431;
  uint64_t v432;
  uint64_t v433;
  unint64_t v434;
  unint64_t v435;
  int v436;
  uint64_t v437;
  unint64_t v438;
  unint64_t v439;
  int v440;
  uint64_t v441;
  unint64_t v442;
  unint64_t v443;
  int v444;
  uint64_t v445;
  unint64_t v446;
  unint64_t v447;
  int v448;
  uint64_t v449;
  unint64_t v450;
  unint64_t v451;
  int v452;
  uint64_t v453;
  unint64_t v454;
  unint64_t v455;
  int v456;
  uint64_t v457;
  unint64_t v458;
  unint64_t v459;
  int v460;
  uint64_t v461;
  unint64_t v462;
  unint64_t v463;
  int v464;
  uint64_t v465;
  unint64_t v466;
  unint64_t v467;
  uint64_t v468;
  uint64_t v469;
  unint64_t v470;
  unint64_t v471;
  char v472;
  unsigned int v473;
  uint64_t v474;
  unint64_t v475;
  int v476;
  uint64_t v477;
  unint64_t v478;
  int v479;
  uint64_t v480;
  unint64_t v481;
  int v482;
  uint64_t v483;
  unint64_t v484;
  unint64_t v485;
  int v486;
  uint64_t v487;
  unint64_t v488;
  unint64_t v489;
  int v490;
  uint64_t v491;
  unint64_t v492;
  unint64_t v493;
  int v494;
  uint64_t v495;
  unint64_t v496;
  unint64_t v497;
  int v498;
  uint64_t v499;
  unint64_t v500;
  unint64_t v501;
  int v502;
  uint64_t v503;
  unint64_t v504;
  unint64_t v505;
  int v506;
  uint64_t v507;
  unint64_t v508;
  unint64_t v509;
  char v510;
  unsigned int v511;
  uint64_t v512;
  unint64_t v513;
  int v514;
  uint64_t v515;
  unint64_t v516;
  int v517;
  uint64_t v518;
  unint64_t v519;
  int v520;
  uint64_t v521;
  unint64_t v522;
  unint64_t v523;
  int v524;
  uint64_t v525;
  unint64_t v526;
  unint64_t v527;
  int v528;
  uint64_t v529;
  unint64_t v530;
  unint64_t v531;
  int v532;
  uint64_t v533;
  unint64_t v534;
  unint64_t v535;
  int v536;
  uint64_t v537;
  unint64_t v538;
  unint64_t v539;
  int v540;
  uint64_t v541;
  unint64_t v542;
  unint64_t v543;
  int v544;
  uint64_t v545;
  unint64_t v546;
  unint64_t v547;
  char v548;
  unsigned int v549;
  uint64_t v550;
  unint64_t v551;
  int v552;
  uint64_t v553;
  unint64_t v554;
  int v555;
  uint64_t v556;
  unint64_t v557;
  int v558;
  uint64_t v559;
  unint64_t v560;
  unint64_t v561;
  int v562;
  uint64_t v563;
  unint64_t v564;
  unint64_t v565;
  int v566;
  uint64_t v567;
  unint64_t v568;
  unint64_t v569;
  int v570;
  uint64_t v571;
  unint64_t v572;
  unint64_t v573;
  int v574;
  uint64_t v575;
  unint64_t v576;
  unint64_t v577;
  int v578;
  uint64_t v579;
  unint64_t v580;
  unint64_t v581;
  int v582;
  uint64_t v583;
  unint64_t v584;
  unint64_t v585;
  char v586;
  uint64_t v587;
  uint64_t v588;
  unint64_t v589;
  unint64_t v590;
  int v591;
  uint64_t v592;
  unint64_t v593;
  unint64_t v594;
  int v595;
  uint64_t v596;
  unint64_t v597;
  unint64_t v598;
  int v599;
  uint64_t v600;
  unint64_t v601;
  unint64_t v602;
  int v603;
  uint64_t v604;
  unint64_t v605;
  unint64_t v606;
  int v607;
  uint64_t v608;
  unint64_t v609;
  unint64_t v610;
  int v611;
  uint64_t v612;
  unint64_t v613;
  unint64_t v614;
  int v615;
  uint64_t v616;
  unint64_t v617;
  unint64_t v618;
  int v619;
  uint64_t v620;
  unint64_t v621;
  unint64_t v622;
  uint64_t v623;
  uint64_t result;
  uint64_t v625;
  unint64_t v626;
  unint64_t v627;
  _BYTE *v628;
  char v629;
  uint64_t v630;
  unint64_t v631;
  int v632;
  uint64_t v633;
  unint64_t v634;
  int v635;
  uint64_t v636;
  unint64_t v637;
  int v638;
  uint64_t v639;
  unint64_t v640;
  unint64_t v641;
  int v642;
  uint64_t v643;
  unint64_t v644;
  unint64_t v645;
  int v646;
  uint64_t v647;
  unint64_t v648;
  unint64_t v649;
  int v650;
  uint64_t v651;
  unint64_t v652;
  unint64_t v653;
  int v654;
  uint64_t v655;
  unint64_t v656;
  unint64_t v657;
  int v658;
  uint64_t v659;
  unint64_t v660;
  uint64_t v661;
  unint64_t v662;
  unint64_t v663;
  char v664;
  uint64_t v665;
  uint64_t v666;
  unint64_t v667;
  unint64_t v668;
  int v669;
  uint64_t v670;
  unint64_t v671;
  unint64_t v672;
  int v673;
  uint64_t v674;
  unint64_t v675;
  unint64_t v676;
  int v677;
  uint64_t v678;
  unint64_t v679;
  unint64_t v680;
  int v681;
  uint64_t v682;
  unint64_t v683;
  unint64_t v684;
  int v685;
  uint64_t v686;
  unint64_t v687;
  unint64_t v688;
  int v689;
  uint64_t v690;
  unint64_t v691;
  unint64_t v692;
  int v693;
  uint64_t v694;
  unint64_t v695;
  unint64_t v696;
  int v697;
  uint64_t v698;
  unint64_t v699;
  unint64_t v700;
  uint64_t v701;
  uint64_t v702;
  unint64_t v703;
  unint64_t i;
  _BYTE *v705;
  char v706;
  uint64_t v707;
  unint64_t v708;
  int v709;
  uint64_t v710;
  unint64_t v711;
  int v712;
  uint64_t v713;
  unint64_t v714;
  int v715;
  uint64_t v716;
  unint64_t v717;
  unint64_t v718;
  int v719;
  uint64_t v720;
  unint64_t v721;
  unint64_t v722;
  int v723;
  uint64_t v724;
  unint64_t v725;
  unint64_t v726;
  int v727;
  uint64_t v728;
  unint64_t v729;
  unint64_t v730;
  int v731;
  uint64_t v732;
  unint64_t v733;
  unint64_t v734;
  int v735;
  uint64_t v736;
  unint64_t v737;
  id v738;
  void *v739;
  uint64_t v740;
  unint64_t v741;
  char v742;
  uint64_t v743;
  unint64_t v744;
  int v745;
  uint64_t v746;
  unint64_t v747;
  int v748;
  uint64_t v749;
  unint64_t v750;
  int v751;
  uint64_t v752;
  unint64_t v753;
  unint64_t v754;
  int v755;
  uint64_t v756;
  unint64_t v757;
  unint64_t v758;
  int v759;
  uint64_t v760;
  unint64_t v761;
  unint64_t v762;
  int v763;
  uint64_t v764;
  unint64_t v765;
  unint64_t v766;
  int v767;
  uint64_t v768;
  unint64_t v769;
  unint64_t v770;
  int v771;
  uint64_t v772;
  unint64_t v773;
  uint64_t v774;
  uint64_t v775;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int)*MEMORY[0x1E0D82BF0];
  v5 = *(_QWORD *)(a2 + v4);
  v6 = (int *)MEMORY[0x1E0D82BD8];
  v7 = *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]);
  v8 = (int *)MEMORY[0x1E0D82BC8];
  if (v5 >= v7)
    return *(_BYTE *)(a2 + *v8) == 0;
  v10 = (int *)MEMORY[0x1E0D82BB8];
  while (1)
  {
    v14 = (_BYTE *)(a2 + *v8);
    if (*v14)
      return *(_BYTE *)(a2 + *v8) == 0;
    if (v5 >= v7)
      break;
    v15 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v5);
    *(_QWORD *)(a2 + (int)v4) = v5 + 1;
    v16 = v15 & 0x7F;
    if ((v15 & 0x80) == 0)
      goto LABEL_40;
    v17 = *v3;
    v18 = *(_QWORD *)(a2 + v17);
    if (v18 == -1 || v18 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v19 = v18 + 1;
    v20 = *(char *)(*(_QWORD *)(a2 + *v10) + v18);
    *(_QWORD *)(a2 + v17) = v19;
    v16 |= (unint64_t)(v20 & 0x7F) << 7;
    if ((v20 & 0x80000000) == 0)
      goto LABEL_40;
    v21 = *v3;
    v22 = *(_QWORD *)(a2 + v21);
    if (v22 == -1 || v22 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v23 = v22 + 1;
    v24 = *(char *)(*(_QWORD *)(a2 + *v10) + v22);
    *(_QWORD *)(a2 + v21) = v23;
    v16 |= (unint64_t)(v24 & 0x7F) << 14;
    if ((v24 & 0x80000000) == 0)
      goto LABEL_40;
    v25 = *v3;
    v26 = *(_QWORD *)(a2 + v25);
    if (v26 == -1 || v26 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v27 = v26 + 1;
    v28 = *(char *)(*(_QWORD *)(a2 + *v10) + v26);
    *(_QWORD *)(a2 + v25) = v27;
    v16 |= (unint64_t)(v28 & 0x7F) << 21;
    if ((v28 & 0x80000000) == 0)
      goto LABEL_40;
    v29 = *v3;
    v30 = *(_QWORD *)(a2 + v29);
    if (v30 == -1 || v30 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v31 = v30 + 1;
    v32 = *(char *)(*(_QWORD *)(a2 + *v10) + v30);
    *(_QWORD *)(a2 + v29) = v31;
    v16 |= (unint64_t)(v32 & 0x7F) << 28;
    if ((v32 & 0x80000000) == 0)
      goto LABEL_40;
    v33 = *v3;
    v34 = *(_QWORD *)(a2 + v33);
    if (v34 == -1 || v34 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v35 = v34 + 1;
    v36 = *(char *)(*(_QWORD *)(a2 + *v10) + v34);
    *(_QWORD *)(a2 + v33) = v35;
    if ((v36 & 0x80000000) == 0)
      goto LABEL_40;
    v37 = *v3;
    v38 = *(_QWORD *)(a2 + v37);
    if (v38 == -1 || v38 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v39 = v38 + 1;
    v40 = *(char *)(*(_QWORD *)(a2 + *v10) + v38);
    *(_QWORD *)(a2 + v37) = v39;
    if ((v40 & 0x80000000) == 0)
      goto LABEL_40;
    v41 = *v3;
    v42 = *(_QWORD *)(a2 + v41);
    if (v42 == -1 || v42 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v43 = v42 + 1;
    v44 = *(char *)(*(_QWORD *)(a2 + *v10) + v42);
    *(_QWORD *)(a2 + v41) = v43;
    if ((v44 & 0x80000000) == 0)
      goto LABEL_40;
    v45 = *v3;
    v46 = *(_QWORD *)(a2 + v45);
    if (v46 == -1 || v46 >= *(_QWORD *)(a2 + *v6))
      goto LABEL_38;
    v47 = v46 + 1;
    v48 = *(char *)(*(_QWORD *)(a2 + *v10) + v46);
    *(_QWORD *)(a2 + v45) = v47;
    if ((v48 & 0x80000000) == 0)
      goto LABEL_40;
    v49 = *v3;
    v50 = *(_QWORD *)(a2 + v49);
    if (v50 == -1 || v50 >= *(_QWORD *)(a2 + *v6))
    {
LABEL_38:
      v14 = (_BYTE *)(a2 + *v8);
      goto LABEL_39;
    }
    v51 = v50 + 1;
    v52 = *(char *)(*(_QWORD *)(a2 + *v10) + v50);
    *(_QWORD *)(a2 + v49) = v51;
    if (v52 < 0)
    {
      v16 = 0;
      v53 = *v8;
      v54 = *(unsigned __int8 *)(a2 + v53);
      goto LABEL_42;
    }
LABEL_40:
    v53 = *v8;
    v54 = *(unsigned __int8 *)(a2 + v53);
    if (*(_BYTE *)(a2 + v53))
      v16 = 0;
LABEL_42:
    v55 = v16 & 7;
    if (v54)
      v56 = 1;
    else
      v56 = v55 == 4;
    if (v56)
      return *(_BYTE *)(a2 + *v8) == 0;
    v57 = (_BYTE *)(a2 + v53);
    switch((v16 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = 56;
        goto LABEL_4;
      case 2u:
        PBReaderReadString();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = 72;
        goto LABEL_4;
      case 3u:
        PBReaderReadString();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = 80;
        goto LABEL_4;
      case 4u:
        PBReaderReadString();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = 144;
        goto LABEL_4;
      case 5u:
        PBReaderReadString();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = 176;
        goto LABEL_4;
      case 6u:
        *(_WORD *)(a1 + 196) |= 4u;
        v390 = *v3;
        v391 = *(_QWORD *)(a2 + v390);
        if (v391 == -1 || v391 >= *(_QWORD *)(a2 + *v6))
        {
          v394 = 0;
LABEL_662:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_663;
        }
        v392 = v391 + 1;
        v393 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v391);
        *(_QWORD *)(a2 + v390) = v392;
        v394 = v393 & 0x7F;
        if ((v393 & 0x80) == 0)
          goto LABEL_663;
        v395 = *v3;
        v396 = *(_QWORD *)(a2 + v395);
        if (v396 == -1 || v396 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v397 = *(char *)(*(_QWORD *)(a2 + *v10) + v396);
        *(_QWORD *)(a2 + v395) = v396 + 1;
        v394 = v394 & 0xFFFFC07F | ((v397 & 0x7F) << 7);
        if ((v397 & 0x80000000) == 0)
          goto LABEL_663;
        v398 = *v3;
        v399 = *(_QWORD *)(a2 + v398);
        if (v399 == -1 || v399 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v400 = *(char *)(*(_QWORD *)(a2 + *v10) + v399);
        *(_QWORD *)(a2 + v398) = v399 + 1;
        v394 = v394 & 0xFFE03FFF | ((v400 & 0x7F) << 14);
        if ((v400 & 0x80000000) == 0)
          goto LABEL_663;
        v401 = *v3;
        v402 = *(_QWORD *)(a2 + v401);
        if (v402 == -1 || v402 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v403 = *(char *)(*(_QWORD *)(a2 + *v10) + v402);
        *(_QWORD *)(a2 + v401) = v402 + 1;
        v394 = v394 & 0xF01FFFFF | ((v403 & 0x7F) << 21);
        if ((v403 & 0x80000000) == 0)
          goto LABEL_663;
        v404 = *v3;
        v405 = *(_QWORD *)(a2 + v404);
        if (v405 == -1 || v405 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v406 = v405 + 1;
        v407 = *(char *)(*(_QWORD *)(a2 + *v10) + v405);
        *(_QWORD *)(a2 + v404) = v406;
        v394 |= v407 << 28;
        if ((v407 & 0x80000000) == 0)
          goto LABEL_663;
        v408 = *v3;
        v409 = *(_QWORD *)(a2 + v408);
        if (v409 == -1 || v409 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v410 = v409 + 1;
        v411 = *(char *)(*(_QWORD *)(a2 + *v10) + v409);
        *(_QWORD *)(a2 + v408) = v410;
        if ((v411 & 0x80000000) == 0)
          goto LABEL_663;
        v412 = *v3;
        v413 = *(_QWORD *)(a2 + v412);
        if (v413 == -1 || v413 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v414 = v413 + 1;
        v415 = *(char *)(*(_QWORD *)(a2 + *v10) + v413);
        *(_QWORD *)(a2 + v412) = v414;
        if ((v415 & 0x80000000) == 0)
          goto LABEL_663;
        v416 = *v3;
        v417 = *(_QWORD *)(a2 + v416);
        if (v417 == -1 || v417 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v418 = v417 + 1;
        v419 = *(char *)(*(_QWORD *)(a2 + *v10) + v417);
        *(_QWORD *)(a2 + v416) = v418;
        if ((v419 & 0x80000000) == 0)
          goto LABEL_663;
        v420 = *v3;
        v421 = *(_QWORD *)(a2 + v420);
        if (v421 == -1 || v421 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v422 = v421 + 1;
        v423 = *(char *)(*(_QWORD *)(a2 + *v10) + v421);
        *(_QWORD *)(a2 + v420) = v422;
        if ((v423 & 0x80000000) == 0)
          goto LABEL_663;
        v424 = *v3;
        v425 = *(_QWORD *)(a2 + v424);
        if (v425 == -1 || v425 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_662;
        v426 = v425 + 1;
        v427 = *(char *)(*(_QWORD *)(a2 + *v10) + v425);
        *(_QWORD *)(a2 + v424) = v426;
        if (v427 < 0)
        {
          v394 = 0;
          goto LABEL_665;
        }
LABEL_663:
        if (*(_BYTE *)(a2 + *v8))
          v394 = 0;
LABEL_665:
        *(_DWORD *)(a1 + 88) = v394;
        goto LABEL_5;
      case 7u:
        *(_WORD *)(a1 + 196) |= 1u;
        v469 = *v3;
        v470 = *(_QWORD *)(a2 + v469);
        if (v470 == -1 || v470 >= *(_QWORD *)(a2 + *v6))
        {
          v473 = 0;
LABEL_672:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_673;
        }
        v471 = v470 + 1;
        v472 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v470);
        *(_QWORD *)(a2 + v469) = v471;
        v473 = v472 & 0x7F;
        if ((v472 & 0x80) == 0)
          goto LABEL_673;
        v474 = *v3;
        v475 = *(_QWORD *)(a2 + v474);
        if (v475 == -1 || v475 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v476 = *(char *)(*(_QWORD *)(a2 + *v10) + v475);
        *(_QWORD *)(a2 + v474) = v475 + 1;
        v473 = v473 & 0xFFFFC07F | ((v476 & 0x7F) << 7);
        if ((v476 & 0x80000000) == 0)
          goto LABEL_673;
        v477 = *v3;
        v478 = *(_QWORD *)(a2 + v477);
        if (v478 == -1 || v478 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v479 = *(char *)(*(_QWORD *)(a2 + *v10) + v478);
        *(_QWORD *)(a2 + v477) = v478 + 1;
        v473 = v473 & 0xFFE03FFF | ((v479 & 0x7F) << 14);
        if ((v479 & 0x80000000) == 0)
          goto LABEL_673;
        v480 = *v3;
        v481 = *(_QWORD *)(a2 + v480);
        if (v481 == -1 || v481 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v482 = *(char *)(*(_QWORD *)(a2 + *v10) + v481);
        *(_QWORD *)(a2 + v480) = v481 + 1;
        v473 = v473 & 0xF01FFFFF | ((v482 & 0x7F) << 21);
        if ((v482 & 0x80000000) == 0)
          goto LABEL_673;
        v483 = *v3;
        v484 = *(_QWORD *)(a2 + v483);
        if (v484 == -1 || v484 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v485 = v484 + 1;
        v486 = *(char *)(*(_QWORD *)(a2 + *v10) + v484);
        *(_QWORD *)(a2 + v483) = v485;
        v473 |= v486 << 28;
        if ((v486 & 0x80000000) == 0)
          goto LABEL_673;
        v487 = *v3;
        v488 = *(_QWORD *)(a2 + v487);
        if (v488 == -1 || v488 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v489 = v488 + 1;
        v490 = *(char *)(*(_QWORD *)(a2 + *v10) + v488);
        *(_QWORD *)(a2 + v487) = v489;
        if ((v490 & 0x80000000) == 0)
          goto LABEL_673;
        v491 = *v3;
        v492 = *(_QWORD *)(a2 + v491);
        if (v492 == -1 || v492 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v493 = v492 + 1;
        v494 = *(char *)(*(_QWORD *)(a2 + *v10) + v492);
        *(_QWORD *)(a2 + v491) = v493;
        if ((v494 & 0x80000000) == 0)
          goto LABEL_673;
        v495 = *v3;
        v496 = *(_QWORD *)(a2 + v495);
        if (v496 == -1 || v496 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v497 = v496 + 1;
        v498 = *(char *)(*(_QWORD *)(a2 + *v10) + v496);
        *(_QWORD *)(a2 + v495) = v497;
        if ((v498 & 0x80000000) == 0)
          goto LABEL_673;
        v499 = *v3;
        v500 = *(_QWORD *)(a2 + v499);
        if (v500 == -1 || v500 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v501 = v500 + 1;
        v502 = *(char *)(*(_QWORD *)(a2 + *v10) + v500);
        *(_QWORD *)(a2 + v499) = v501;
        if ((v502 & 0x80000000) == 0)
          goto LABEL_673;
        v503 = *v3;
        v504 = *(_QWORD *)(a2 + v503);
        if (v504 == -1 || v504 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_672;
        v505 = v504 + 1;
        v506 = *(char *)(*(_QWORD *)(a2 + *v10) + v504);
        *(_QWORD *)(a2 + v503) = v505;
        if (v506 < 0)
        {
          v473 = 0;
          goto LABEL_675;
        }
LABEL_673:
        if (*(_BYTE *)(a2 + *v8))
          v473 = 0;
LABEL_675:
        *(_DWORD *)(a1 + 64) = v473;
        goto LABEL_5;
      case 8u:
        *(_WORD *)(a1 + 196) |= 0x20u;
        v311 = *v3;
        v312 = *(_QWORD *)(a2 + v311);
        if (v312 == -1 || v312 >= *(_QWORD *)(a2 + *v6))
        {
          v315 = 0;
LABEL_652:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_653;
        }
        v313 = v312 + 1;
        v314 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v312);
        *(_QWORD *)(a2 + v311) = v313;
        v315 = v314 & 0x7F;
        if ((v314 & 0x80) == 0)
          goto LABEL_653;
        v316 = *v3;
        v317 = *(_QWORD *)(a2 + v316);
        if (v317 == -1 || v317 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v318 = *(char *)(*(_QWORD *)(a2 + *v10) + v317);
        *(_QWORD *)(a2 + v316) = v317 + 1;
        v315 = v315 & 0xFFFFC07F | ((v318 & 0x7F) << 7);
        if ((v318 & 0x80000000) == 0)
          goto LABEL_653;
        v319 = *v3;
        v320 = *(_QWORD *)(a2 + v319);
        if (v320 == -1 || v320 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v321 = *(char *)(*(_QWORD *)(a2 + *v10) + v320);
        *(_QWORD *)(a2 + v319) = v320 + 1;
        v315 = v315 & 0xFFE03FFF | ((v321 & 0x7F) << 14);
        if ((v321 & 0x80000000) == 0)
          goto LABEL_653;
        v322 = *v3;
        v323 = *(_QWORD *)(a2 + v322);
        if (v323 == -1 || v323 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v324 = *(char *)(*(_QWORD *)(a2 + *v10) + v323);
        *(_QWORD *)(a2 + v322) = v323 + 1;
        v315 = v315 & 0xF01FFFFF | ((v324 & 0x7F) << 21);
        if ((v324 & 0x80000000) == 0)
          goto LABEL_653;
        v325 = *v3;
        v326 = *(_QWORD *)(a2 + v325);
        if (v326 == -1 || v326 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v327 = v326 + 1;
        v328 = *(char *)(*(_QWORD *)(a2 + *v10) + v326);
        *(_QWORD *)(a2 + v325) = v327;
        v315 |= v328 << 28;
        if ((v328 & 0x80000000) == 0)
          goto LABEL_653;
        v329 = *v3;
        v330 = *(_QWORD *)(a2 + v329);
        if (v330 == -1 || v330 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v331 = v330 + 1;
        v332 = *(char *)(*(_QWORD *)(a2 + *v10) + v330);
        *(_QWORD *)(a2 + v329) = v331;
        if ((v332 & 0x80000000) == 0)
          goto LABEL_653;
        v333 = *v3;
        v334 = *(_QWORD *)(a2 + v333);
        if (v334 == -1 || v334 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v335 = v334 + 1;
        v336 = *(char *)(*(_QWORD *)(a2 + *v10) + v334);
        *(_QWORD *)(a2 + v333) = v335;
        if ((v336 & 0x80000000) == 0)
          goto LABEL_653;
        v337 = *v3;
        v338 = *(_QWORD *)(a2 + v337);
        if (v338 == -1 || v338 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v339 = v338 + 1;
        v340 = *(char *)(*(_QWORD *)(a2 + *v10) + v338);
        *(_QWORD *)(a2 + v337) = v339;
        if ((v340 & 0x80000000) == 0)
          goto LABEL_653;
        v341 = *v3;
        v342 = *(_QWORD *)(a2 + v341);
        if (v342 == -1 || v342 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v343 = v342 + 1;
        v344 = *(char *)(*(_QWORD *)(a2 + *v10) + v342);
        *(_QWORD *)(a2 + v341) = v343;
        if ((v344 & 0x80000000) == 0)
          goto LABEL_653;
        v345 = *v3;
        v346 = *(_QWORD *)(a2 + v345);
        if (v346 == -1 || v346 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_652;
        v347 = v346 + 1;
        v348 = *(char *)(*(_QWORD *)(a2 + *v10) + v346);
        *(_QWORD *)(a2 + v345) = v347;
        if (v348 < 0)
        {
          v315 = 0;
          goto LABEL_655;
        }
LABEL_653:
        if (*(_BYTE *)(a2 + *v8))
          v315 = 0;
LABEL_655:
        *(_DWORD *)(a1 + 172) = v315;
        goto LABEL_5;
      case 9u:
        *(_WORD *)(a1 + 196) |= 2u;
        v545 = *v3;
        v546 = *(_QWORD *)(a2 + v545);
        if (v546 == -1 || v546 >= *(_QWORD *)(a2 + *v6))
        {
          v549 = 0;
LABEL_687:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_688;
        }
        v547 = v546 + 1;
        v548 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v546);
        *(_QWORD *)(a2 + v545) = v547;
        v549 = v548 & 0x7F;
        if ((v548 & 0x80) == 0)
          goto LABEL_688;
        v550 = *v3;
        v551 = *(_QWORD *)(a2 + v550);
        if (v551 == -1 || v551 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v552 = *(char *)(*(_QWORD *)(a2 + *v10) + v551);
        *(_QWORD *)(a2 + v550) = v551 + 1;
        v549 = v549 & 0xFFFFC07F | ((v552 & 0x7F) << 7);
        if ((v552 & 0x80000000) == 0)
          goto LABEL_688;
        v553 = *v3;
        v554 = *(_QWORD *)(a2 + v553);
        if (v554 == -1 || v554 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v555 = *(char *)(*(_QWORD *)(a2 + *v10) + v554);
        *(_QWORD *)(a2 + v553) = v554 + 1;
        v549 = v549 & 0xFFE03FFF | ((v555 & 0x7F) << 14);
        if ((v555 & 0x80000000) == 0)
          goto LABEL_688;
        v556 = *v3;
        v557 = *(_QWORD *)(a2 + v556);
        if (v557 == -1 || v557 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v558 = *(char *)(*(_QWORD *)(a2 + *v10) + v557);
        *(_QWORD *)(a2 + v556) = v557 + 1;
        v549 = v549 & 0xF01FFFFF | ((v558 & 0x7F) << 21);
        if ((v558 & 0x80000000) == 0)
          goto LABEL_688;
        v559 = *v3;
        v560 = *(_QWORD *)(a2 + v559);
        if (v560 == -1 || v560 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v561 = v560 + 1;
        v562 = *(char *)(*(_QWORD *)(a2 + *v10) + v560);
        *(_QWORD *)(a2 + v559) = v561;
        v549 |= v562 << 28;
        if ((v562 & 0x80000000) == 0)
          goto LABEL_688;
        v563 = *v3;
        v564 = *(_QWORD *)(a2 + v563);
        if (v564 == -1 || v564 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v565 = v564 + 1;
        v566 = *(char *)(*(_QWORD *)(a2 + *v10) + v564);
        *(_QWORD *)(a2 + v563) = v565;
        if ((v566 & 0x80000000) == 0)
          goto LABEL_688;
        v567 = *v3;
        v568 = *(_QWORD *)(a2 + v567);
        if (v568 == -1 || v568 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v569 = v568 + 1;
        v570 = *(char *)(*(_QWORD *)(a2 + *v10) + v568);
        *(_QWORD *)(a2 + v567) = v569;
        if ((v570 & 0x80000000) == 0)
          goto LABEL_688;
        v571 = *v3;
        v572 = *(_QWORD *)(a2 + v571);
        if (v572 == -1 || v572 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v573 = v572 + 1;
        v574 = *(char *)(*(_QWORD *)(a2 + *v10) + v572);
        *(_QWORD *)(a2 + v571) = v573;
        if ((v574 & 0x80000000) == 0)
          goto LABEL_688;
        v575 = *v3;
        v576 = *(_QWORD *)(a2 + v575);
        if (v576 == -1 || v576 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v577 = v576 + 1;
        v578 = *(char *)(*(_QWORD *)(a2 + *v10) + v576);
        *(_QWORD *)(a2 + v575) = v577;
        if ((v578 & 0x80000000) == 0)
          goto LABEL_688;
        v579 = *v3;
        v580 = *(_QWORD *)(a2 + v579);
        if (v580 == -1 || v580 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_687;
        v581 = v580 + 1;
        v582 = *(char *)(*(_QWORD *)(a2 + *v10) + v580);
        *(_QWORD *)(a2 + v579) = v581;
        if (v582 < 0)
        {
          v549 = 0;
          goto LABEL_690;
        }
LABEL_688:
        if (*(_BYTE *)(a2 + *v8))
          v549 = 0;
LABEL_690:
        *(_DWORD *)(a1 + 68) = v549;
        goto LABEL_5;
      case 0xAu:
        *(_WORD *)(a1 + 196) |= 0x10u;
        v227 = *v3;
        v228 = *(_QWORD *)(a2 + v227);
        if (v228 == -1 || v228 >= *(_QWORD *)(a2 + *v6))
        {
          v231 = 0;
LABEL_642:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_643;
        }
        v229 = v228 + 1;
        v230 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v228);
        *(_QWORD *)(a2 + v227) = v229;
        v231 = v230 & 0x7F;
        if ((v230 & 0x80) == 0)
          goto LABEL_643;
        v232 = *v3;
        v233 = *(_QWORD *)(a2 + v232);
        if (v233 == -1 || v233 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v234 = *(char *)(*(_QWORD *)(a2 + *v10) + v233);
        *(_QWORD *)(a2 + v232) = v233 + 1;
        v231 = v231 & 0xFFFFC07F | ((v234 & 0x7F) << 7);
        if ((v234 & 0x80000000) == 0)
          goto LABEL_643;
        v235 = *v3;
        v236 = *(_QWORD *)(a2 + v235);
        if (v236 == -1 || v236 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v237 = *(char *)(*(_QWORD *)(a2 + *v10) + v236);
        *(_QWORD *)(a2 + v235) = v236 + 1;
        v231 = v231 & 0xFFE03FFF | ((v237 & 0x7F) << 14);
        if ((v237 & 0x80000000) == 0)
          goto LABEL_643;
        v238 = *v3;
        v239 = *(_QWORD *)(a2 + v238);
        if (v239 == -1 || v239 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v240 = *(char *)(*(_QWORD *)(a2 + *v10) + v239);
        *(_QWORD *)(a2 + v238) = v239 + 1;
        v231 = v231 & 0xF01FFFFF | ((v240 & 0x7F) << 21);
        if ((v240 & 0x80000000) == 0)
          goto LABEL_643;
        v241 = *v3;
        v242 = *(_QWORD *)(a2 + v241);
        if (v242 == -1 || v242 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v243 = v242 + 1;
        v244 = *(char *)(*(_QWORD *)(a2 + *v10) + v242);
        *(_QWORD *)(a2 + v241) = v243;
        v231 |= v244 << 28;
        if ((v244 & 0x80000000) == 0)
          goto LABEL_643;
        v245 = *v3;
        v246 = *(_QWORD *)(a2 + v245);
        if (v246 == -1 || v246 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v247 = v246 + 1;
        v248 = *(char *)(*(_QWORD *)(a2 + *v10) + v246);
        *(_QWORD *)(a2 + v245) = v247;
        if ((v248 & 0x80000000) == 0)
          goto LABEL_643;
        v249 = *v3;
        v250 = *(_QWORD *)(a2 + v249);
        if (v250 == -1 || v250 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v251 = v250 + 1;
        v252 = *(char *)(*(_QWORD *)(a2 + *v10) + v250);
        *(_QWORD *)(a2 + v249) = v251;
        if ((v252 & 0x80000000) == 0)
          goto LABEL_643;
        v253 = *v3;
        v254 = *(_QWORD *)(a2 + v253);
        if (v254 == -1 || v254 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v255 = v254 + 1;
        v256 = *(char *)(*(_QWORD *)(a2 + *v10) + v254);
        *(_QWORD *)(a2 + v253) = v255;
        if ((v256 & 0x80000000) == 0)
          goto LABEL_643;
        v257 = *v3;
        v258 = *(_QWORD *)(a2 + v257);
        if (v258 == -1 || v258 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v259 = v258 + 1;
        v260 = *(char *)(*(_QWORD *)(a2 + *v10) + v258);
        *(_QWORD *)(a2 + v257) = v259;
        if ((v260 & 0x80000000) == 0)
          goto LABEL_643;
        v261 = *v3;
        v262 = *(_QWORD *)(a2 + v261);
        if (v262 == -1 || v262 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_642;
        v263 = v262 + 1;
        v264 = *(char *)(*(_QWORD *)(a2 + *v10) + v262);
        *(_QWORD *)(a2 + v261) = v263;
        if (v264 < 0)
        {
          v231 = 0;
          goto LABEL_645;
        }
LABEL_643:
        if (*(_BYTE *)(a2 + *v8))
          v231 = 0;
LABEL_645:
        *(_DWORD *)(a1 + 168) = v231;
        goto LABEL_5;
      case 0xBu:
        *(_WORD *)(a1 + 196) |= 0x400u;
        v583 = *v3;
        v584 = *(_QWORD *)(a2 + v583);
        if (v584 == -1 || v584 >= *(_QWORD *)(a2 + *v6))
        {
          v587 = 0;
LABEL_682:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_683;
        }
        v585 = v584 + 1;
        v586 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v584);
        *(_QWORD *)(a2 + v583) = v585;
        v587 = v586 & 0x7F;
        if ((v586 & 0x80) == 0)
          goto LABEL_683;
        v588 = *v3;
        v589 = *(_QWORD *)(a2 + v588);
        if (v589 == -1 || v589 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v590 = v589 + 1;
        v591 = *(char *)(*(_QWORD *)(a2 + *v10) + v589);
        *(_QWORD *)(a2 + v588) = v590;
        v587 |= (unint64_t)(v591 & 0x7F) << 7;
        if ((v591 & 0x80000000) == 0)
          goto LABEL_683;
        v592 = *v3;
        v593 = *(_QWORD *)(a2 + v592);
        if (v593 == -1 || v593 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v594 = v593 + 1;
        v595 = *(char *)(*(_QWORD *)(a2 + *v10) + v593);
        *(_QWORD *)(a2 + v592) = v594;
        v587 |= (unint64_t)(v595 & 0x7F) << 14;
        if ((v595 & 0x80000000) == 0)
          goto LABEL_683;
        v596 = *v3;
        v597 = *(_QWORD *)(a2 + v596);
        if (v597 == -1 || v597 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v598 = v597 + 1;
        v599 = *(char *)(*(_QWORD *)(a2 + *v10) + v597);
        *(_QWORD *)(a2 + v596) = v598;
        v587 |= (unint64_t)(v599 & 0x7F) << 21;
        if ((v599 & 0x80000000) == 0)
          goto LABEL_683;
        v600 = *v3;
        v601 = *(_QWORD *)(a2 + v600);
        if (v601 == -1 || v601 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v602 = v601 + 1;
        v603 = *(char *)(*(_QWORD *)(a2 + *v10) + v601);
        *(_QWORD *)(a2 + v600) = v602;
        v587 |= (unint64_t)(v603 & 0x7F) << 28;
        if ((v603 & 0x80000000) == 0)
          goto LABEL_683;
        v604 = *v3;
        v605 = *(_QWORD *)(a2 + v604);
        if (v605 == -1 || v605 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v606 = v605 + 1;
        v607 = *(char *)(*(_QWORD *)(a2 + *v10) + v605);
        *(_QWORD *)(a2 + v604) = v606;
        v587 |= (unint64_t)(v607 & 0x7F) << 35;
        if ((v607 & 0x80000000) == 0)
          goto LABEL_683;
        v608 = *v3;
        v609 = *(_QWORD *)(a2 + v608);
        if (v609 == -1 || v609 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v610 = v609 + 1;
        v611 = *(char *)(*(_QWORD *)(a2 + *v10) + v609);
        *(_QWORD *)(a2 + v608) = v610;
        v587 |= (unint64_t)(v611 & 0x7F) << 42;
        if ((v611 & 0x80000000) == 0)
          goto LABEL_683;
        v612 = *v3;
        v613 = *(_QWORD *)(a2 + v612);
        if (v613 == -1 || v613 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v614 = v613 + 1;
        v615 = *(char *)(*(_QWORD *)(a2 + *v10) + v613);
        *(_QWORD *)(a2 + v612) = v614;
        v587 |= (unint64_t)(v615 & 0x7F) << 49;
        if ((v615 & 0x80000000) == 0)
          goto LABEL_683;
        v616 = *v3;
        v617 = *(_QWORD *)(a2 + v616);
        if (v617 == -1 || v617 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v618 = v617 + 1;
        v619 = *(char *)(*(_QWORD *)(a2 + *v10) + v617);
        *(_QWORD *)(a2 + v616) = v618;
        v587 |= (unint64_t)(v619 & 0x7F) << 56;
        if ((v619 & 0x80000000) == 0)
          goto LABEL_683;
        v620 = *v3;
        v621 = *(_QWORD *)(a2 + v620);
        if (v621 == -1 || v621 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_682;
        v622 = v621 + 1;
        v623 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v621);
        *(_QWORD *)(a2 + v620) = v622;
        if ((v623 & 0x80) != 0)
        {
          v587 = 0;
          goto LABEL_685;
        }
        v587 |= v623 << 63;
LABEL_683:
        if (*(_BYTE *)(a2 + *v8))
          v587 = 0;
LABEL_685:
        *(_BYTE *)(a1 + 188) = v587 != 0;
        goto LABEL_5;
      case 0xCu:
        *(_WORD *)(a1 + 196) |= 0x40u;
        v145 = *v3;
        v146 = *(_QWORD *)(a2 + v145);
        if (v146 == -1 || v146 >= *(_QWORD *)(a2 + *v6))
        {
          v149 = 0;
LABEL_632:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_633;
        }
        v147 = v146 + 1;
        v148 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v146);
        *(_QWORD *)(a2 + v145) = v147;
        v149 = v148 & 0x7F;
        if ((v148 & 0x80) == 0)
          goto LABEL_633;
        v150 = *v3;
        v151 = *(_QWORD *)(a2 + v150);
        if (v151 == -1 || v151 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v152 = v151 + 1;
        v153 = *(char *)(*(_QWORD *)(a2 + *v10) + v151);
        *(_QWORD *)(a2 + v150) = v152;
        v149 |= (unint64_t)(v153 & 0x7F) << 7;
        if ((v153 & 0x80000000) == 0)
          goto LABEL_633;
        v154 = *v3;
        v155 = *(_QWORD *)(a2 + v154);
        if (v155 == -1 || v155 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v156 = v155 + 1;
        v157 = *(char *)(*(_QWORD *)(a2 + *v10) + v155);
        *(_QWORD *)(a2 + v154) = v156;
        v149 |= (unint64_t)(v157 & 0x7F) << 14;
        if ((v157 & 0x80000000) == 0)
          goto LABEL_633;
        v158 = *v3;
        v159 = *(_QWORD *)(a2 + v158);
        if (v159 == -1 || v159 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v160 = v159 + 1;
        v161 = *(char *)(*(_QWORD *)(a2 + *v10) + v159);
        *(_QWORD *)(a2 + v158) = v160;
        v149 |= (unint64_t)(v161 & 0x7F) << 21;
        if ((v161 & 0x80000000) == 0)
          goto LABEL_633;
        v162 = *v3;
        v163 = *(_QWORD *)(a2 + v162);
        if (v163 == -1 || v163 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v164 = v163 + 1;
        v165 = *(char *)(*(_QWORD *)(a2 + *v10) + v163);
        *(_QWORD *)(a2 + v162) = v164;
        v149 |= (unint64_t)(v165 & 0x7F) << 28;
        if ((v165 & 0x80000000) == 0)
          goto LABEL_633;
        v166 = *v3;
        v167 = *(_QWORD *)(a2 + v166);
        if (v167 == -1 || v167 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v168 = v167 + 1;
        v169 = *(char *)(*(_QWORD *)(a2 + *v10) + v167);
        *(_QWORD *)(a2 + v166) = v168;
        v149 |= (unint64_t)(v169 & 0x7F) << 35;
        if ((v169 & 0x80000000) == 0)
          goto LABEL_633;
        v170 = *v3;
        v171 = *(_QWORD *)(a2 + v170);
        if (v171 == -1 || v171 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v172 = v171 + 1;
        v173 = *(char *)(*(_QWORD *)(a2 + *v10) + v171);
        *(_QWORD *)(a2 + v170) = v172;
        v149 |= (unint64_t)(v173 & 0x7F) << 42;
        if ((v173 & 0x80000000) == 0)
          goto LABEL_633;
        v174 = *v3;
        v175 = *(_QWORD *)(a2 + v174);
        if (v175 == -1 || v175 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v176 = v175 + 1;
        v177 = *(char *)(*(_QWORD *)(a2 + *v10) + v175);
        *(_QWORD *)(a2 + v174) = v176;
        v149 |= (unint64_t)(v177 & 0x7F) << 49;
        if ((v177 & 0x80000000) == 0)
          goto LABEL_633;
        v178 = *v3;
        v179 = *(_QWORD *)(a2 + v178);
        if (v179 == -1 || v179 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v180 = v179 + 1;
        v181 = *(char *)(*(_QWORD *)(a2 + *v10) + v179);
        *(_QWORD *)(a2 + v178) = v180;
        v149 |= (unint64_t)(v181 & 0x7F) << 56;
        if ((v181 & 0x80000000) == 0)
          goto LABEL_633;
        v182 = *v3;
        v183 = *(_QWORD *)(a2 + v182);
        if (v183 == -1 || v183 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_632;
        v184 = v183 + 1;
        v185 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v183);
        *(_QWORD *)(a2 + v182) = v184;
        if ((v185 & 0x80) != 0)
        {
          v149 = 0;
          goto LABEL_635;
        }
        v149 |= v185 << 63;
LABEL_633:
        if (*(_BYTE *)(a2 + *v8))
          v149 = 0;
LABEL_635:
        *(_BYTE *)(a1 + 184) = v149 != 0;
        goto LABEL_5;
      case 0xDu:
        *(_WORD *)(a1 + 196) |= 0x800u;
        v186 = *v3;
        v187 = *(_QWORD *)(a2 + v186);
        if (v187 == -1 || v187 >= *(_QWORD *)(a2 + *v6))
        {
          v190 = 0;
LABEL_637:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_638;
        }
        v188 = v187 + 1;
        v189 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v187);
        *(_QWORD *)(a2 + v186) = v188;
        v190 = v189 & 0x7F;
        if ((v189 & 0x80) == 0)
          goto LABEL_638;
        v191 = *v3;
        v192 = *(_QWORD *)(a2 + v191);
        if (v192 == -1 || v192 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v193 = v192 + 1;
        v194 = *(char *)(*(_QWORD *)(a2 + *v10) + v192);
        *(_QWORD *)(a2 + v191) = v193;
        v190 |= (unint64_t)(v194 & 0x7F) << 7;
        if ((v194 & 0x80000000) == 0)
          goto LABEL_638;
        v195 = *v3;
        v196 = *(_QWORD *)(a2 + v195);
        if (v196 == -1 || v196 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v197 = v196 + 1;
        v198 = *(char *)(*(_QWORD *)(a2 + *v10) + v196);
        *(_QWORD *)(a2 + v195) = v197;
        v190 |= (unint64_t)(v198 & 0x7F) << 14;
        if ((v198 & 0x80000000) == 0)
          goto LABEL_638;
        v199 = *v3;
        v200 = *(_QWORD *)(a2 + v199);
        if (v200 == -1 || v200 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v201 = v200 + 1;
        v202 = *(char *)(*(_QWORD *)(a2 + *v10) + v200);
        *(_QWORD *)(a2 + v199) = v201;
        v190 |= (unint64_t)(v202 & 0x7F) << 21;
        if ((v202 & 0x80000000) == 0)
          goto LABEL_638;
        v203 = *v3;
        v204 = *(_QWORD *)(a2 + v203);
        if (v204 == -1 || v204 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v205 = v204 + 1;
        v206 = *(char *)(*(_QWORD *)(a2 + *v10) + v204);
        *(_QWORD *)(a2 + v203) = v205;
        v190 |= (unint64_t)(v206 & 0x7F) << 28;
        if ((v206 & 0x80000000) == 0)
          goto LABEL_638;
        v207 = *v3;
        v208 = *(_QWORD *)(a2 + v207);
        if (v208 == -1 || v208 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v209 = v208 + 1;
        v210 = *(char *)(*(_QWORD *)(a2 + *v10) + v208);
        *(_QWORD *)(a2 + v207) = v209;
        v190 |= (unint64_t)(v210 & 0x7F) << 35;
        if ((v210 & 0x80000000) == 0)
          goto LABEL_638;
        v211 = *v3;
        v212 = *(_QWORD *)(a2 + v211);
        if (v212 == -1 || v212 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v213 = v212 + 1;
        v214 = *(char *)(*(_QWORD *)(a2 + *v10) + v212);
        *(_QWORD *)(a2 + v211) = v213;
        v190 |= (unint64_t)(v214 & 0x7F) << 42;
        if ((v214 & 0x80000000) == 0)
          goto LABEL_638;
        v215 = *v3;
        v216 = *(_QWORD *)(a2 + v215);
        if (v216 == -1 || v216 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v217 = v216 + 1;
        v218 = *(char *)(*(_QWORD *)(a2 + *v10) + v216);
        *(_QWORD *)(a2 + v215) = v217;
        v190 |= (unint64_t)(v218 & 0x7F) << 49;
        if ((v218 & 0x80000000) == 0)
          goto LABEL_638;
        v219 = *v3;
        v220 = *(_QWORD *)(a2 + v219);
        if (v220 == -1 || v220 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v221 = v220 + 1;
        v222 = *(char *)(*(_QWORD *)(a2 + *v10) + v220);
        *(_QWORD *)(a2 + v219) = v221;
        v190 |= (unint64_t)(v222 & 0x7F) << 56;
        if ((v222 & 0x80000000) == 0)
          goto LABEL_638;
        v223 = *v3;
        v224 = *(_QWORD *)(a2 + v223);
        if (v224 == -1 || v224 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_637;
        v225 = v224 + 1;
        v226 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v224);
        *(_QWORD *)(a2 + v223) = v225;
        if ((v226 & 0x80) != 0)
        {
          v190 = 0;
          goto LABEL_640;
        }
        v190 |= v226 << 63;
LABEL_638:
        if (*(_BYTE *)(a2 + *v8))
          v190 = 0;
LABEL_640:
        *(_BYTE *)(a1 + 189) = v190 != 0;
        goto LABEL_5;
      case 0xEu:
        *(_WORD *)(a1 + 196) |= 0x100u;
        v428 = *v3;
        v429 = *(_QWORD *)(a2 + v428);
        if (v429 == -1 || v429 >= *(_QWORD *)(a2 + *v6))
        {
          v432 = 0;
LABEL_667:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_668;
        }
        v430 = v429 + 1;
        v431 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v429);
        *(_QWORD *)(a2 + v428) = v430;
        v432 = v431 & 0x7F;
        if ((v431 & 0x80) == 0)
          goto LABEL_668;
        v433 = *v3;
        v434 = *(_QWORD *)(a2 + v433);
        if (v434 == -1 || v434 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v435 = v434 + 1;
        v436 = *(char *)(*(_QWORD *)(a2 + *v10) + v434);
        *(_QWORD *)(a2 + v433) = v435;
        v432 |= (unint64_t)(v436 & 0x7F) << 7;
        if ((v436 & 0x80000000) == 0)
          goto LABEL_668;
        v437 = *v3;
        v438 = *(_QWORD *)(a2 + v437);
        if (v438 == -1 || v438 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v439 = v438 + 1;
        v440 = *(char *)(*(_QWORD *)(a2 + *v10) + v438);
        *(_QWORD *)(a2 + v437) = v439;
        v432 |= (unint64_t)(v440 & 0x7F) << 14;
        if ((v440 & 0x80000000) == 0)
          goto LABEL_668;
        v441 = *v3;
        v442 = *(_QWORD *)(a2 + v441);
        if (v442 == -1 || v442 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v443 = v442 + 1;
        v444 = *(char *)(*(_QWORD *)(a2 + *v10) + v442);
        *(_QWORD *)(a2 + v441) = v443;
        v432 |= (unint64_t)(v444 & 0x7F) << 21;
        if ((v444 & 0x80000000) == 0)
          goto LABEL_668;
        v445 = *v3;
        v446 = *(_QWORD *)(a2 + v445);
        if (v446 == -1 || v446 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v447 = v446 + 1;
        v448 = *(char *)(*(_QWORD *)(a2 + *v10) + v446);
        *(_QWORD *)(a2 + v445) = v447;
        v432 |= (unint64_t)(v448 & 0x7F) << 28;
        if ((v448 & 0x80000000) == 0)
          goto LABEL_668;
        v449 = *v3;
        v450 = *(_QWORD *)(a2 + v449);
        if (v450 == -1 || v450 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v451 = v450 + 1;
        v452 = *(char *)(*(_QWORD *)(a2 + *v10) + v450);
        *(_QWORD *)(a2 + v449) = v451;
        v432 |= (unint64_t)(v452 & 0x7F) << 35;
        if ((v452 & 0x80000000) == 0)
          goto LABEL_668;
        v453 = *v3;
        v454 = *(_QWORD *)(a2 + v453);
        if (v454 == -1 || v454 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v455 = v454 + 1;
        v456 = *(char *)(*(_QWORD *)(a2 + *v10) + v454);
        *(_QWORD *)(a2 + v453) = v455;
        v432 |= (unint64_t)(v456 & 0x7F) << 42;
        if ((v456 & 0x80000000) == 0)
          goto LABEL_668;
        v457 = *v3;
        v458 = *(_QWORD *)(a2 + v457);
        if (v458 == -1 || v458 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v459 = v458 + 1;
        v460 = *(char *)(*(_QWORD *)(a2 + *v10) + v458);
        *(_QWORD *)(a2 + v457) = v459;
        v432 |= (unint64_t)(v460 & 0x7F) << 49;
        if ((v460 & 0x80000000) == 0)
          goto LABEL_668;
        v461 = *v3;
        v462 = *(_QWORD *)(a2 + v461);
        if (v462 == -1 || v462 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v463 = v462 + 1;
        v464 = *(char *)(*(_QWORD *)(a2 + *v10) + v462);
        *(_QWORD *)(a2 + v461) = v463;
        v432 |= (unint64_t)(v464 & 0x7F) << 56;
        if ((v464 & 0x80000000) == 0)
          goto LABEL_668;
        v465 = *v3;
        v466 = *(_QWORD *)(a2 + v465);
        if (v466 == -1 || v466 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_667;
        v467 = v466 + 1;
        v468 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v466);
        *(_QWORD *)(a2 + v465) = v467;
        if ((v468 & 0x80) != 0)
        {
          v432 = 0;
          goto LABEL_670;
        }
        v432 |= v468 << 63;
LABEL_668:
        if (*(_BYTE *)(a2 + *v8))
          v432 = 0;
LABEL_670:
        *(_BYTE *)(a1 + 186) = v432 != 0;
        goto LABEL_5;
      case 0xFu:
        *(_WORD *)(a1 + 196) |= 0x2000u;
        v104 = *v3;
        v105 = *(_QWORD *)(a2 + v104);
        if (v105 == -1 || v105 >= *(_QWORD *)(a2 + *v6))
        {
          v108 = 0;
LABEL_627:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_628;
        }
        v106 = v105 + 1;
        v107 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v105);
        *(_QWORD *)(a2 + v104) = v106;
        v108 = v107 & 0x7F;
        if ((v107 & 0x80) == 0)
          goto LABEL_628;
        v109 = *v3;
        v110 = *(_QWORD *)(a2 + v109);
        if (v110 == -1 || v110 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v111 = v110 + 1;
        v112 = *(char *)(*(_QWORD *)(a2 + *v10) + v110);
        *(_QWORD *)(a2 + v109) = v111;
        v108 |= (unint64_t)(v112 & 0x7F) << 7;
        if ((v112 & 0x80000000) == 0)
          goto LABEL_628;
        v113 = *v3;
        v114 = *(_QWORD *)(a2 + v113);
        if (v114 == -1 || v114 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v115 = v114 + 1;
        v116 = *(char *)(*(_QWORD *)(a2 + *v10) + v114);
        *(_QWORD *)(a2 + v113) = v115;
        v108 |= (unint64_t)(v116 & 0x7F) << 14;
        if ((v116 & 0x80000000) == 0)
          goto LABEL_628;
        v117 = *v3;
        v118 = *(_QWORD *)(a2 + v117);
        if (v118 == -1 || v118 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v119 = v118 + 1;
        v120 = *(char *)(*(_QWORD *)(a2 + *v10) + v118);
        *(_QWORD *)(a2 + v117) = v119;
        v108 |= (unint64_t)(v120 & 0x7F) << 21;
        if ((v120 & 0x80000000) == 0)
          goto LABEL_628;
        v121 = *v3;
        v122 = *(_QWORD *)(a2 + v121);
        if (v122 == -1 || v122 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v123 = v122 + 1;
        v124 = *(char *)(*(_QWORD *)(a2 + *v10) + v122);
        *(_QWORD *)(a2 + v121) = v123;
        v108 |= (unint64_t)(v124 & 0x7F) << 28;
        if ((v124 & 0x80000000) == 0)
          goto LABEL_628;
        v125 = *v3;
        v126 = *(_QWORD *)(a2 + v125);
        if (v126 == -1 || v126 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v127 = v126 + 1;
        v128 = *(char *)(*(_QWORD *)(a2 + *v10) + v126);
        *(_QWORD *)(a2 + v125) = v127;
        v108 |= (unint64_t)(v128 & 0x7F) << 35;
        if ((v128 & 0x80000000) == 0)
          goto LABEL_628;
        v129 = *v3;
        v130 = *(_QWORD *)(a2 + v129);
        if (v130 == -1 || v130 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v131 = v130 + 1;
        v132 = *(char *)(*(_QWORD *)(a2 + *v10) + v130);
        *(_QWORD *)(a2 + v129) = v131;
        v108 |= (unint64_t)(v132 & 0x7F) << 42;
        if ((v132 & 0x80000000) == 0)
          goto LABEL_628;
        v133 = *v3;
        v134 = *(_QWORD *)(a2 + v133);
        if (v134 == -1 || v134 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v135 = v134 + 1;
        v136 = *(char *)(*(_QWORD *)(a2 + *v10) + v134);
        *(_QWORD *)(a2 + v133) = v135;
        v108 |= (unint64_t)(v136 & 0x7F) << 49;
        if ((v136 & 0x80000000) == 0)
          goto LABEL_628;
        v137 = *v3;
        v138 = *(_QWORD *)(a2 + v137);
        if (v138 == -1 || v138 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v139 = v138 + 1;
        v140 = *(char *)(*(_QWORD *)(a2 + *v10) + v138);
        *(_QWORD *)(a2 + v137) = v139;
        v108 |= (unint64_t)(v140 & 0x7F) << 56;
        if ((v140 & 0x80000000) == 0)
          goto LABEL_628;
        v141 = *v3;
        v142 = *(_QWORD *)(a2 + v141);
        if (v142 == -1 || v142 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_627;
        v143 = v142 + 1;
        v144 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v142);
        *(_QWORD *)(a2 + v141) = v143;
        if ((v144 & 0x80) != 0)
        {
          v108 = 0;
          goto LABEL_630;
        }
        v108 |= v144 << 63;
LABEL_628:
        if (*(_BYTE *)(a2 + *v8))
          v108 = 0;
LABEL_630:
        *(_BYTE *)(a1 + 191) = v108 != 0;
        goto LABEL_5;
      case 0x10u:
        *(_WORD *)(a1 + 196) |= 0x4000u;
        v270 = *v3;
        v271 = *(_QWORD *)(a2 + v270);
        if (v271 == -1 || v271 >= *(_QWORD *)(a2 + *v6))
        {
          v274 = 0;
LABEL_647:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_648;
        }
        v272 = v271 + 1;
        v273 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v271);
        *(_QWORD *)(a2 + v270) = v272;
        v274 = v273 & 0x7F;
        if ((v273 & 0x80) == 0)
          goto LABEL_648;
        v275 = *v3;
        v276 = *(_QWORD *)(a2 + v275);
        if (v276 == -1 || v276 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v277 = v276 + 1;
        v278 = *(char *)(*(_QWORD *)(a2 + *v10) + v276);
        *(_QWORD *)(a2 + v275) = v277;
        v274 |= (unint64_t)(v278 & 0x7F) << 7;
        if ((v278 & 0x80000000) == 0)
          goto LABEL_648;
        v279 = *v3;
        v280 = *(_QWORD *)(a2 + v279);
        if (v280 == -1 || v280 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v281 = v280 + 1;
        v282 = *(char *)(*(_QWORD *)(a2 + *v10) + v280);
        *(_QWORD *)(a2 + v279) = v281;
        v274 |= (unint64_t)(v282 & 0x7F) << 14;
        if ((v282 & 0x80000000) == 0)
          goto LABEL_648;
        v283 = *v3;
        v284 = *(_QWORD *)(a2 + v283);
        if (v284 == -1 || v284 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v285 = v284 + 1;
        v286 = *(char *)(*(_QWORD *)(a2 + *v10) + v284);
        *(_QWORD *)(a2 + v283) = v285;
        v274 |= (unint64_t)(v286 & 0x7F) << 21;
        if ((v286 & 0x80000000) == 0)
          goto LABEL_648;
        v287 = *v3;
        v288 = *(_QWORD *)(a2 + v287);
        if (v288 == -1 || v288 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v289 = v288 + 1;
        v290 = *(char *)(*(_QWORD *)(a2 + *v10) + v288);
        *(_QWORD *)(a2 + v287) = v289;
        v274 |= (unint64_t)(v290 & 0x7F) << 28;
        if ((v290 & 0x80000000) == 0)
          goto LABEL_648;
        v291 = *v3;
        v292 = *(_QWORD *)(a2 + v291);
        if (v292 == -1 || v292 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v293 = v292 + 1;
        v294 = *(char *)(*(_QWORD *)(a2 + *v10) + v292);
        *(_QWORD *)(a2 + v291) = v293;
        v274 |= (unint64_t)(v294 & 0x7F) << 35;
        if ((v294 & 0x80000000) == 0)
          goto LABEL_648;
        v295 = *v3;
        v296 = *(_QWORD *)(a2 + v295);
        if (v296 == -1 || v296 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v297 = v296 + 1;
        v298 = *(char *)(*(_QWORD *)(a2 + *v10) + v296);
        *(_QWORD *)(a2 + v295) = v297;
        v274 |= (unint64_t)(v298 & 0x7F) << 42;
        if ((v298 & 0x80000000) == 0)
          goto LABEL_648;
        v299 = *v3;
        v300 = *(_QWORD *)(a2 + v299);
        if (v300 == -1 || v300 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v301 = v300 + 1;
        v302 = *(char *)(*(_QWORD *)(a2 + *v10) + v300);
        *(_QWORD *)(a2 + v299) = v301;
        v274 |= (unint64_t)(v302 & 0x7F) << 49;
        if ((v302 & 0x80000000) == 0)
          goto LABEL_648;
        v303 = *v3;
        v304 = *(_QWORD *)(a2 + v303);
        if (v304 == -1 || v304 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v305 = v304 + 1;
        v306 = *(char *)(*(_QWORD *)(a2 + *v10) + v304);
        *(_QWORD *)(a2 + v303) = v305;
        v274 |= (unint64_t)(v306 & 0x7F) << 56;
        if ((v306 & 0x80000000) == 0)
          goto LABEL_648;
        v307 = *v3;
        v308 = *(_QWORD *)(a2 + v307);
        if (v308 == -1 || v308 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_647;
        v309 = v308 + 1;
        v310 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v308);
        *(_QWORD *)(a2 + v307) = v309;
        if ((v310 & 0x80) != 0)
        {
          v274 = 0;
          goto LABEL_650;
        }
        v274 |= v310 << 63;
LABEL_648:
        if (*(_BYTE *)(a2 + *v8))
          v274 = 0;
LABEL_650:
        *(_BYTE *)(a1 + 192) = v274 != 0;
        goto LABEL_5;
      case 0x11u:
        *(_WORD *)(a1 + 196) |= 0x1000u;
        v63 = *v3;
        v64 = *(_QWORD *)(a2 + v63);
        if (v64 == -1 || v64 >= *(_QWORD *)(a2 + *v6))
        {
          v67 = 0;
LABEL_622:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_623;
        }
        v65 = v64 + 1;
        v66 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v64);
        *(_QWORD *)(a2 + v63) = v65;
        v67 = v66 & 0x7F;
        if ((v66 & 0x80) == 0)
          goto LABEL_623;
        v68 = *v3;
        v69 = *(_QWORD *)(a2 + v68);
        if (v69 == -1 || v69 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v70 = v69 + 1;
        v71 = *(char *)(*(_QWORD *)(a2 + *v10) + v69);
        *(_QWORD *)(a2 + v68) = v70;
        v67 |= (unint64_t)(v71 & 0x7F) << 7;
        if ((v71 & 0x80000000) == 0)
          goto LABEL_623;
        v72 = *v3;
        v73 = *(_QWORD *)(a2 + v72);
        if (v73 == -1 || v73 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v74 = v73 + 1;
        v75 = *(char *)(*(_QWORD *)(a2 + *v10) + v73);
        *(_QWORD *)(a2 + v72) = v74;
        v67 |= (unint64_t)(v75 & 0x7F) << 14;
        if ((v75 & 0x80000000) == 0)
          goto LABEL_623;
        v76 = *v3;
        v77 = *(_QWORD *)(a2 + v76);
        if (v77 == -1 || v77 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v78 = v77 + 1;
        v79 = *(char *)(*(_QWORD *)(a2 + *v10) + v77);
        *(_QWORD *)(a2 + v76) = v78;
        v67 |= (unint64_t)(v79 & 0x7F) << 21;
        if ((v79 & 0x80000000) == 0)
          goto LABEL_623;
        v80 = *v3;
        v81 = *(_QWORD *)(a2 + v80);
        if (v81 == -1 || v81 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v82 = v81 + 1;
        v83 = *(char *)(*(_QWORD *)(a2 + *v10) + v81);
        *(_QWORD *)(a2 + v80) = v82;
        v67 |= (unint64_t)(v83 & 0x7F) << 28;
        if ((v83 & 0x80000000) == 0)
          goto LABEL_623;
        v84 = *v3;
        v85 = *(_QWORD *)(a2 + v84);
        if (v85 == -1 || v85 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v86 = v85 + 1;
        v87 = *(char *)(*(_QWORD *)(a2 + *v10) + v85);
        *(_QWORD *)(a2 + v84) = v86;
        v67 |= (unint64_t)(v87 & 0x7F) << 35;
        if ((v87 & 0x80000000) == 0)
          goto LABEL_623;
        v88 = *v3;
        v89 = *(_QWORD *)(a2 + v88);
        if (v89 == -1 || v89 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v90 = v89 + 1;
        v91 = *(char *)(*(_QWORD *)(a2 + *v10) + v89);
        *(_QWORD *)(a2 + v88) = v90;
        v67 |= (unint64_t)(v91 & 0x7F) << 42;
        if ((v91 & 0x80000000) == 0)
          goto LABEL_623;
        v92 = *v3;
        v93 = *(_QWORD *)(a2 + v92);
        if (v93 == -1 || v93 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v94 = v93 + 1;
        v95 = *(char *)(*(_QWORD *)(a2 + *v10) + v93);
        *(_QWORD *)(a2 + v92) = v94;
        v67 |= (unint64_t)(v95 & 0x7F) << 49;
        if ((v95 & 0x80000000) == 0)
          goto LABEL_623;
        v96 = *v3;
        v97 = *(_QWORD *)(a2 + v96);
        if (v97 == -1 || v97 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v98 = v97 + 1;
        v99 = *(char *)(*(_QWORD *)(a2 + *v10) + v97);
        *(_QWORD *)(a2 + v96) = v98;
        v67 |= (unint64_t)(v99 & 0x7F) << 56;
        if ((v99 & 0x80000000) == 0)
          goto LABEL_623;
        v100 = *v3;
        v101 = *(_QWORD *)(a2 + v100);
        if (v101 == -1 || v101 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_622;
        v102 = v101 + 1;
        v103 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v101);
        *(_QWORD *)(a2 + v100) = v102;
        if ((v103 & 0x80) != 0)
        {
          v67 = 0;
          goto LABEL_625;
        }
        v67 |= v103 << 63;
LABEL_623:
        if (*(_BYTE *)(a2 + *v8))
          v67 = 0;
LABEL_625:
        *(_BYTE *)(a1 + 190) = v67 != 0;
        goto LABEL_5;
      case 0x12u:
        *(_WORD *)(a1 + 196) |= 0x200u;
        v349 = *v3;
        v350 = *(_QWORD *)(a2 + v349);
        if (v350 == -1 || v350 >= *(_QWORD *)(a2 + *v6))
        {
          v353 = 0;
LABEL_657:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_658;
        }
        v351 = v350 + 1;
        v352 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v350);
        *(_QWORD *)(a2 + v349) = v351;
        v353 = v352 & 0x7F;
        if ((v352 & 0x80) == 0)
          goto LABEL_658;
        v354 = *v3;
        v355 = *(_QWORD *)(a2 + v354);
        if (v355 == -1 || v355 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v356 = v355 + 1;
        v357 = *(char *)(*(_QWORD *)(a2 + *v10) + v355);
        *(_QWORD *)(a2 + v354) = v356;
        v353 |= (unint64_t)(v357 & 0x7F) << 7;
        if ((v357 & 0x80000000) == 0)
          goto LABEL_658;
        v358 = *v3;
        v359 = *(_QWORD *)(a2 + v358);
        if (v359 == -1 || v359 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v360 = v359 + 1;
        v361 = *(char *)(*(_QWORD *)(a2 + *v10) + v359);
        *(_QWORD *)(a2 + v358) = v360;
        v353 |= (unint64_t)(v361 & 0x7F) << 14;
        if ((v361 & 0x80000000) == 0)
          goto LABEL_658;
        v362 = *v3;
        v363 = *(_QWORD *)(a2 + v362);
        if (v363 == -1 || v363 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v364 = v363 + 1;
        v365 = *(char *)(*(_QWORD *)(a2 + *v10) + v363);
        *(_QWORD *)(a2 + v362) = v364;
        v353 |= (unint64_t)(v365 & 0x7F) << 21;
        if ((v365 & 0x80000000) == 0)
          goto LABEL_658;
        v366 = *v3;
        v367 = *(_QWORD *)(a2 + v366);
        if (v367 == -1 || v367 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v368 = v367 + 1;
        v369 = *(char *)(*(_QWORD *)(a2 + *v10) + v367);
        *(_QWORD *)(a2 + v366) = v368;
        v353 |= (unint64_t)(v369 & 0x7F) << 28;
        if ((v369 & 0x80000000) == 0)
          goto LABEL_658;
        v370 = *v3;
        v371 = *(_QWORD *)(a2 + v370);
        if (v371 == -1 || v371 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v372 = v371 + 1;
        v373 = *(char *)(*(_QWORD *)(a2 + *v10) + v371);
        *(_QWORD *)(a2 + v370) = v372;
        v353 |= (unint64_t)(v373 & 0x7F) << 35;
        if ((v373 & 0x80000000) == 0)
          goto LABEL_658;
        v374 = *v3;
        v375 = *(_QWORD *)(a2 + v374);
        if (v375 == -1 || v375 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v376 = v375 + 1;
        v377 = *(char *)(*(_QWORD *)(a2 + *v10) + v375);
        *(_QWORD *)(a2 + v374) = v376;
        v353 |= (unint64_t)(v377 & 0x7F) << 42;
        if ((v377 & 0x80000000) == 0)
          goto LABEL_658;
        v378 = *v3;
        v379 = *(_QWORD *)(a2 + v378);
        if (v379 == -1 || v379 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v380 = v379 + 1;
        v381 = *(char *)(*(_QWORD *)(a2 + *v10) + v379);
        *(_QWORD *)(a2 + v378) = v380;
        v353 |= (unint64_t)(v381 & 0x7F) << 49;
        if ((v381 & 0x80000000) == 0)
          goto LABEL_658;
        v382 = *v3;
        v383 = *(_QWORD *)(a2 + v382);
        if (v383 == -1 || v383 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v384 = v383 + 1;
        v385 = *(char *)(*(_QWORD *)(a2 + *v10) + v383);
        *(_QWORD *)(a2 + v382) = v384;
        v353 |= (unint64_t)(v385 & 0x7F) << 56;
        if ((v385 & 0x80000000) == 0)
          goto LABEL_658;
        v386 = *v3;
        v387 = *(_QWORD *)(a2 + v386);
        if (v387 == -1 || v387 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_657;
        v388 = v387 + 1;
        v389 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v387);
        *(_QWORD *)(a2 + v386) = v388;
        if ((v389 & 0x80) != 0)
        {
          v353 = 0;
          goto LABEL_660;
        }
        v353 |= v389 << 63;
LABEL_658:
        if (*(_BYTE *)(a2 + *v8))
          v353 = 0;
LABEL_660:
        *(_BYTE *)(a1 + 187) = v353 != 0;
        goto LABEL_5;
      case 0x13u:
        *(_WORD *)(a1 + 196) |= 8u;
        v507 = *v3;
        v508 = *(_QWORD *)(a2 + v507);
        if (v508 == -1 || v508 >= *(_QWORD *)(a2 + *v6))
        {
          v511 = 0;
LABEL_677:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_678;
        }
        v509 = v508 + 1;
        v510 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v508);
        *(_QWORD *)(a2 + v507) = v509;
        v511 = v510 & 0x7F;
        if ((v510 & 0x80) == 0)
          goto LABEL_678;
        v512 = *v3;
        v513 = *(_QWORD *)(a2 + v512);
        if (v513 == -1 || v513 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v514 = *(char *)(*(_QWORD *)(a2 + *v10) + v513);
        *(_QWORD *)(a2 + v512) = v513 + 1;
        v511 = v511 & 0xFFFFC07F | ((v514 & 0x7F) << 7);
        if ((v514 & 0x80000000) == 0)
          goto LABEL_678;
        v515 = *v3;
        v516 = *(_QWORD *)(a2 + v515);
        if (v516 == -1 || v516 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v517 = *(char *)(*(_QWORD *)(a2 + *v10) + v516);
        *(_QWORD *)(a2 + v515) = v516 + 1;
        v511 = v511 & 0xFFE03FFF | ((v517 & 0x7F) << 14);
        if ((v517 & 0x80000000) == 0)
          goto LABEL_678;
        v518 = *v3;
        v519 = *(_QWORD *)(a2 + v518);
        if (v519 == -1 || v519 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v520 = *(char *)(*(_QWORD *)(a2 + *v10) + v519);
        *(_QWORD *)(a2 + v518) = v519 + 1;
        v511 = v511 & 0xF01FFFFF | ((v520 & 0x7F) << 21);
        if ((v520 & 0x80000000) == 0)
          goto LABEL_678;
        v521 = *v3;
        v522 = *(_QWORD *)(a2 + v521);
        if (v522 == -1 || v522 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v523 = v522 + 1;
        v524 = *(char *)(*(_QWORD *)(a2 + *v10) + v522);
        *(_QWORD *)(a2 + v521) = v523;
        v511 |= v524 << 28;
        if ((v524 & 0x80000000) == 0)
          goto LABEL_678;
        v525 = *v3;
        v526 = *(_QWORD *)(a2 + v525);
        if (v526 == -1 || v526 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v527 = v526 + 1;
        v528 = *(char *)(*(_QWORD *)(a2 + *v10) + v526);
        *(_QWORD *)(a2 + v525) = v527;
        if ((v528 & 0x80000000) == 0)
          goto LABEL_678;
        v529 = *v3;
        v530 = *(_QWORD *)(a2 + v529);
        if (v530 == -1 || v530 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v531 = v530 + 1;
        v532 = *(char *)(*(_QWORD *)(a2 + *v10) + v530);
        *(_QWORD *)(a2 + v529) = v531;
        if ((v532 & 0x80000000) == 0)
          goto LABEL_678;
        v533 = *v3;
        v534 = *(_QWORD *)(a2 + v533);
        if (v534 == -1 || v534 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v535 = v534 + 1;
        v536 = *(char *)(*(_QWORD *)(a2 + *v10) + v534);
        *(_QWORD *)(a2 + v533) = v535;
        if ((v536 & 0x80000000) == 0)
          goto LABEL_678;
        v537 = *v3;
        v538 = *(_QWORD *)(a2 + v537);
        if (v538 == -1 || v538 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v539 = v538 + 1;
        v540 = *(char *)(*(_QWORD *)(a2 + *v10) + v538);
        *(_QWORD *)(a2 + v537) = v539;
        if ((v540 & 0x80000000) == 0)
          goto LABEL_678;
        v541 = *v3;
        v542 = *(_QWORD *)(a2 + v541);
        if (v542 == -1 || v542 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_677;
        v543 = v542 + 1;
        v544 = *(char *)(*(_QWORD *)(a2 + *v10) + v542);
        *(_QWORD *)(a2 + v541) = v543;
        if (v544 < 0)
        {
          v511 = 0;
          goto LABEL_680;
        }
LABEL_678:
        if (*(_BYTE *)(a2 + *v8))
          v511 = 0;
LABEL_680:
        *(_DWORD *)(a1 + 112) = v511;
        goto LABEL_5;
      case 0x14u:
        *(_WORD *)(a1 + 196) |= 0x80u;
        v661 = *v3;
        v662 = *(_QWORD *)(a2 + v661);
        if (v662 == -1 || v662 >= *(_QWORD *)(a2 + *v6))
        {
          v665 = 0;
LABEL_692:
          *(_BYTE *)(a2 + *v8) = 1;
          goto LABEL_693;
        }
        v663 = v662 + 1;
        v664 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v662);
        *(_QWORD *)(a2 + v661) = v663;
        v665 = v664 & 0x7F;
        if ((v664 & 0x80) == 0)
          goto LABEL_693;
        v666 = *v3;
        v667 = *(_QWORD *)(a2 + v666);
        if (v667 == -1 || v667 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v668 = v667 + 1;
        v669 = *(char *)(*(_QWORD *)(a2 + *v10) + v667);
        *(_QWORD *)(a2 + v666) = v668;
        v665 |= (unint64_t)(v669 & 0x7F) << 7;
        if ((v669 & 0x80000000) == 0)
          goto LABEL_693;
        v670 = *v3;
        v671 = *(_QWORD *)(a2 + v670);
        if (v671 == -1 || v671 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v672 = v671 + 1;
        v673 = *(char *)(*(_QWORD *)(a2 + *v10) + v671);
        *(_QWORD *)(a2 + v670) = v672;
        v665 |= (unint64_t)(v673 & 0x7F) << 14;
        if ((v673 & 0x80000000) == 0)
          goto LABEL_693;
        v674 = *v3;
        v675 = *(_QWORD *)(a2 + v674);
        if (v675 == -1 || v675 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v676 = v675 + 1;
        v677 = *(char *)(*(_QWORD *)(a2 + *v10) + v675);
        *(_QWORD *)(a2 + v674) = v676;
        v665 |= (unint64_t)(v677 & 0x7F) << 21;
        if ((v677 & 0x80000000) == 0)
          goto LABEL_693;
        v678 = *v3;
        v679 = *(_QWORD *)(a2 + v678);
        if (v679 == -1 || v679 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v680 = v679 + 1;
        v681 = *(char *)(*(_QWORD *)(a2 + *v10) + v679);
        *(_QWORD *)(a2 + v678) = v680;
        v665 |= (unint64_t)(v681 & 0x7F) << 28;
        if ((v681 & 0x80000000) == 0)
          goto LABEL_693;
        v682 = *v3;
        v683 = *(_QWORD *)(a2 + v682);
        if (v683 == -1 || v683 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v684 = v683 + 1;
        v685 = *(char *)(*(_QWORD *)(a2 + *v10) + v683);
        *(_QWORD *)(a2 + v682) = v684;
        v665 |= (unint64_t)(v685 & 0x7F) << 35;
        if ((v685 & 0x80000000) == 0)
          goto LABEL_693;
        v686 = *v3;
        v687 = *(_QWORD *)(a2 + v686);
        if (v687 == -1 || v687 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v688 = v687 + 1;
        v689 = *(char *)(*(_QWORD *)(a2 + *v10) + v687);
        *(_QWORD *)(a2 + v686) = v688;
        v665 |= (unint64_t)(v689 & 0x7F) << 42;
        if ((v689 & 0x80000000) == 0)
          goto LABEL_693;
        v690 = *v3;
        v691 = *(_QWORD *)(a2 + v690);
        if (v691 == -1 || v691 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v692 = v691 + 1;
        v693 = *(char *)(*(_QWORD *)(a2 + *v10) + v691);
        *(_QWORD *)(a2 + v690) = v692;
        v665 |= (unint64_t)(v693 & 0x7F) << 49;
        if ((v693 & 0x80000000) == 0)
          goto LABEL_693;
        v694 = *v3;
        v695 = *(_QWORD *)(a2 + v694);
        if (v695 == -1 || v695 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v696 = v695 + 1;
        v697 = *(char *)(*(_QWORD *)(a2 + *v10) + v695);
        *(_QWORD *)(a2 + v694) = v696;
        v665 |= (unint64_t)(v697 & 0x7F) << 56;
        if ((v697 & 0x80000000) == 0)
          goto LABEL_693;
        v698 = *v3;
        v699 = *(_QWORD *)(a2 + v698);
        if (v699 == -1 || v699 >= *(_QWORD *)(a2 + *v6))
          goto LABEL_692;
        v700 = v699 + 1;
        v701 = *(unsigned __int8 *)(*(_QWORD *)(a2 + *v10) + v699);
        *(_QWORD *)(a2 + v698) = v700;
        if ((v701 & 0x80) != 0)
        {
          v665 = 0;
          goto LABEL_695;
        }
        v665 |= v701 << 63;
LABEL_693:
        if (*(_BYTE *)(a2 + *v8))
          v665 = 0;
LABEL_695:
        *(_BYTE *)(a1 + 185) = v665 != 0;
        goto LABEL_5;
      case 0x15u:
        v58 = objc_alloc_init(NWPBEndpoint);
        objc_storeStrong((id *)(a1 + 96), v58);
        v774 = 0;
        v775 = 0;
        if (!PBReaderPlaceMark() || !NWPBEndpointReadFrom((uint64_t)v58, a2))
          goto LABEL_740;
        goto LABEL_620;
      case 0x16u:
        v58 = objc_alloc_init(NWPBInterface);
        objc_storeStrong((id *)(a1 + 160), v58);
        goto LABEL_345;
      case 0x17u:
        if (v55 != 2)
          goto LABEL_696;
        v774 = 0;
        v775 = 0;
        result = PBReaderPlaceMark();
        if (!(_DWORD)result)
          return result;
        v625 = *v3;
        v626 = *(_QWORD *)(a2 + v625);
        v627 = *(_QWORD *)(a2 + *v6);
        if (v626 >= v627)
          goto LABEL_609;
        while (2)
        {
          v628 = (_BYTE *)(a2 + *v8);
          if (*v628)
            goto LABEL_609;
          if (v626 >= v627)
            goto LABEL_538;
          v629 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v626);
          *(_QWORD *)(a2 + (int)v625) = v626 + 1;
          if ((v629 & 0x80) == 0)
            goto LABEL_539;
          v630 = *v3;
          v631 = *(_QWORD *)(a2 + v630);
          if (v631 == -1 || v631 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v632 = *(char *)(*(_QWORD *)(a2 + *v10) + v631);
          *(_QWORD *)(a2 + v630) = v631 + 1;
          if ((v632 & 0x80000000) == 0)
            goto LABEL_539;
          v633 = *v3;
          v634 = *(_QWORD *)(a2 + v633);
          if (v634 == -1 || v634 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v635 = *(char *)(*(_QWORD *)(a2 + *v10) + v634);
          *(_QWORD *)(a2 + v633) = v634 + 1;
          if ((v635 & 0x80000000) == 0)
            goto LABEL_539;
          v636 = *v3;
          v637 = *(_QWORD *)(a2 + v636);
          if (v637 == -1 || v637 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v638 = *(char *)(*(_QWORD *)(a2 + *v10) + v637);
          *(_QWORD *)(a2 + v636) = v637 + 1;
          if ((v638 & 0x80000000) == 0)
            goto LABEL_539;
          v639 = *v3;
          v640 = *(_QWORD *)(a2 + v639);
          if (v640 == -1 || v640 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v641 = v640 + 1;
          v642 = *(char *)(*(_QWORD *)(a2 + *v10) + v640);
          *(_QWORD *)(a2 + v639) = v641;
          if ((v642 & 0x80000000) == 0)
            goto LABEL_539;
          v643 = *v3;
          v644 = *(_QWORD *)(a2 + v643);
          if (v644 == -1 || v644 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v645 = v644 + 1;
          v646 = *(char *)(*(_QWORD *)(a2 + *v10) + v644);
          *(_QWORD *)(a2 + v643) = v645;
          if ((v646 & 0x80000000) == 0)
            goto LABEL_539;
          v647 = *v3;
          v648 = *(_QWORD *)(a2 + v647);
          if (v648 == -1 || v648 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v649 = v648 + 1;
          v650 = *(char *)(*(_QWORD *)(a2 + *v10) + v648);
          *(_QWORD *)(a2 + v647) = v649;
          if ((v650 & 0x80000000) == 0)
            goto LABEL_539;
          v651 = *v3;
          v652 = *(_QWORD *)(a2 + v651);
          if (v652 == -1 || v652 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v653 = v652 + 1;
          v654 = *(char *)(*(_QWORD *)(a2 + *v10) + v652);
          *(_QWORD *)(a2 + v651) = v653;
          if ((v654 & 0x80000000) == 0)
            goto LABEL_539;
          v655 = *v3;
          v656 = *(_QWORD *)(a2 + v655);
          if (v656 == -1 || v656 >= *(_QWORD *)(a2 + *v6))
            goto LABEL_537;
          v657 = v656 + 1;
          v658 = *(char *)(*(_QWORD *)(a2 + *v10) + v656);
          *(_QWORD *)(a2 + v655) = v657;
          if (v658 < 0)
          {
            v659 = *v3;
            v660 = *(_QWORD *)(a2 + v659);
            if (v660 == -1 || v660 >= *(_QWORD *)(a2 + *v6))
            {
LABEL_537:
              v628 = (_BYTE *)(a2 + *v8);
LABEL_538:
              *v628 = 1;
            }
            else
            {
              *(_QWORD *)(a2 + v659) = v660 + 1;
            }
          }
LABEL_539:
          PBRepeatedInt32Add();
          v625 = *v3;
          v626 = *(_QWORD *)(a2 + v625);
          v627 = *(_QWORD *)(a2 + *v6);
          if (v626 >= v627)
            goto LABEL_609;
          continue;
        }
      case 0x18u:
        if (v55 != 2)
        {
LABEL_696:
          v740 = *v3;
          v741 = *(_QWORD *)(a2 + v740);
          if (v741 != -1 && v741 < *(_QWORD *)(a2 + *v6))
          {
            v742 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v741);
            *(_QWORD *)(a2 + v740) = v741 + 1;
            if ((v742 & 0x80) == 0)
              goto LABEL_727;
            v743 = *v3;
            v744 = *(_QWORD *)(a2 + v743);
            if (v744 == -1 || v744 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v745 = *(char *)(*(_QWORD *)(a2 + *v10) + v744);
            *(_QWORD *)(a2 + v743) = v744 + 1;
            if ((v745 & 0x80000000) == 0)
              goto LABEL_727;
            v746 = *v3;
            v747 = *(_QWORD *)(a2 + v746);
            if (v747 == -1 || v747 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v748 = *(char *)(*(_QWORD *)(a2 + *v10) + v747);
            *(_QWORD *)(a2 + v746) = v747 + 1;
            if ((v748 & 0x80000000) == 0)
              goto LABEL_727;
            v749 = *v3;
            v750 = *(_QWORD *)(a2 + v749);
            if (v750 == -1 || v750 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v751 = *(char *)(*(_QWORD *)(a2 + *v10) + v750);
            *(_QWORD *)(a2 + v749) = v750 + 1;
            if ((v751 & 0x80000000) == 0)
              goto LABEL_727;
            v752 = *v3;
            v753 = *(_QWORD *)(a2 + v752);
            if (v753 == -1 || v753 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v754 = v753 + 1;
            v755 = *(char *)(*(_QWORD *)(a2 + *v10) + v753);
            *(_QWORD *)(a2 + v752) = v754;
            if ((v755 & 0x80000000) == 0)
              goto LABEL_727;
            v756 = *v3;
            v757 = *(_QWORD *)(a2 + v756);
            if (v757 == -1 || v757 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v758 = v757 + 1;
            v759 = *(char *)(*(_QWORD *)(a2 + *v10) + v757);
            *(_QWORD *)(a2 + v756) = v758;
            if ((v759 & 0x80000000) == 0)
              goto LABEL_727;
            v760 = *v3;
            v761 = *(_QWORD *)(a2 + v760);
            if (v761 == -1 || v761 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v762 = v761 + 1;
            v763 = *(char *)(*(_QWORD *)(a2 + *v10) + v761);
            *(_QWORD *)(a2 + v760) = v762;
            if ((v763 & 0x80000000) == 0)
              goto LABEL_727;
            v764 = *v3;
            v765 = *(_QWORD *)(a2 + v764);
            if (v765 == -1 || v765 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v766 = v765 + 1;
            v767 = *(char *)(*(_QWORD *)(a2 + *v10) + v765);
            *(_QWORD *)(a2 + v764) = v766;
            if ((v767 & 0x80000000) == 0)
              goto LABEL_727;
            v768 = *v3;
            v769 = *(_QWORD *)(a2 + v768);
            if (v769 == -1 || v769 >= *(_QWORD *)(a2 + *v6))
              goto LABEL_728;
            v770 = v769 + 1;
            v771 = *(char *)(*(_QWORD *)(a2 + *v10) + v769);
            *(_QWORD *)(a2 + v768) = v770;
            if ((v771 & 0x80000000) == 0)
            {
LABEL_727:
              PBRepeatedInt32Add();
              goto LABEL_5;
            }
            v772 = *v3;
            v773 = *(_QWORD *)(a2 + v772);
            if (v773 != -1 && v773 < *(_QWORD *)(a2 + *v6))
            {
              *(_QWORD *)(a2 + v772) = v773 + 1;
              goto LABEL_727;
            }
LABEL_728:
            v57 = (_BYTE *)(a2 + *v8);
          }
          *v57 = 1;
          goto LABEL_727;
        }
        v774 = 0;
        v775 = 0;
        result = PBReaderPlaceMark();
        if (!(_DWORD)result)
          return result;
        v702 = *v3;
        v703 = *(_QWORD *)(a2 + v702);
        for (i = *(_QWORD *)(a2 + *v6); v703 < i; i = *(_QWORD *)(a2 + *v6))
        {
          v705 = (_BYTE *)(a2 + *v8);
          if (*v705)
            break;
          if (v703 >= i)
            goto LABEL_607;
          v706 = *(_BYTE *)(*(_QWORD *)(a2 + *v10) + v703);
          *(_QWORD *)(a2 + (int)v702) = v703 + 1;
          if (v706 < 0)
          {
            v707 = *v3;
            v708 = *(_QWORD *)(a2 + v707);
            if (v708 == -1 || v708 >= *(_QWORD *)(a2 + *v6))
            {
LABEL_606:
              v705 = (_BYTE *)(a2 + *v8);
LABEL_607:
              *v705 = 1;
              goto LABEL_608;
            }
            v709 = *(char *)(*(_QWORD *)(a2 + *v10) + v708);
            *(_QWORD *)(a2 + v707) = v708 + 1;
            if (v709 < 0)
            {
              v710 = *v3;
              v711 = *(_QWORD *)(a2 + v710);
              if (v711 == -1 || v711 >= *(_QWORD *)(a2 + *v6))
                goto LABEL_606;
              v712 = *(char *)(*(_QWORD *)(a2 + *v10) + v711);
              *(_QWORD *)(a2 + v710) = v711 + 1;
              if (v712 < 0)
              {
                v713 = *v3;
                v714 = *(_QWORD *)(a2 + v713);
                if (v714 == -1 || v714 >= *(_QWORD *)(a2 + *v6))
                  goto LABEL_606;
                v715 = *(char *)(*(_QWORD *)(a2 + *v10) + v714);
                *(_QWORD *)(a2 + v713) = v714 + 1;
                if (v715 < 0)
                {
                  v716 = *v3;
                  v717 = *(_QWORD *)(a2 + v716);
                  if (v717 == -1 || v717 >= *(_QWORD *)(a2 + *v6))
                    goto LABEL_606;
                  v718 = v717 + 1;
                  v719 = *(char *)(*(_QWORD *)(a2 + *v10) + v717);
                  *(_QWORD *)(a2 + v716) = v718;
                  if (v719 < 0)
                  {
                    v720 = *v3;
                    v721 = *(_QWORD *)(a2 + v720);
                    if (v721 == -1 || v721 >= *(_QWORD *)(a2 + *v6))
                      goto LABEL_606;
                    v722 = v721 + 1;
                    v723 = *(char *)(*(_QWORD *)(a2 + *v10) + v721);
                    *(_QWORD *)(a2 + v720) = v722;
                    if (v723 < 0)
                    {
                      v724 = *v3;
                      v725 = *(_QWORD *)(a2 + v724);
                      if (v725 == -1 || v725 >= *(_QWORD *)(a2 + *v6))
                        goto LABEL_606;
                      v726 = v725 + 1;
                      v727 = *(char *)(*(_QWORD *)(a2 + *v10) + v725);
                      *(_QWORD *)(a2 + v724) = v726;
                      if (v727 < 0)
                      {
                        v728 = *v3;
                        v729 = *(_QWORD *)(a2 + v728);
                        if (v729 == -1 || v729 >= *(_QWORD *)(a2 + *v6))
                          goto LABEL_606;
                        v730 = v729 + 1;
                        v731 = *(char *)(*(_QWORD *)(a2 + *v10) + v729);
                        *(_QWORD *)(a2 + v728) = v730;
                        if (v731 < 0)
                        {
                          v732 = *v3;
                          v733 = *(_QWORD *)(a2 + v732);
                          if (v733 == -1 || v733 >= *(_QWORD *)(a2 + *v6))
                            goto LABEL_606;
                          v734 = v733 + 1;
                          v735 = *(char *)(*(_QWORD *)(a2 + *v10) + v733);
                          *(_QWORD *)(a2 + v732) = v734;
                          if (v735 < 0)
                          {
                            v736 = *v3;
                            v737 = *(_QWORD *)(a2 + v736);
                            if (v737 == -1 || v737 >= *(_QWORD *)(a2 + *v6))
                              goto LABEL_606;
                            *(_QWORD *)(a2 + v736) = v737 + 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
LABEL_608:
          PBRepeatedInt32Add();
          v702 = *v3;
          v703 = *(_QWORD *)(a2 + v702);
        }
LABEL_609:
        PBReaderRecallMark();
LABEL_5:
        v4 = *v3;
        v5 = *(_QWORD *)(a2 + v4);
        v7 = *(_QWORD *)(a2 + *v6);
        if (v5 >= v7)
          return *(_BYTE *)(a2 + *v8) == 0;
        break;
      case 0x19u:
        v58 = objc_alloc_init(NWPBInterface);
        if (a1)
        {
          v267 = *(void **)(a1 + 136);
          if (!v267)
          {
            v268 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
            v269 = *(void **)(a1 + 136);
            *(_QWORD *)(a1 + 136) = v268;

            v267 = *(void **)(a1 + 136);
          }
          objc_msgSend(v267, "addObject:", v58, v774, v775);
        }

LABEL_345:
        v774 = 0;
        v775 = 0;
        if (!PBReaderPlaceMark() || (NWPBInterfaceReadFrom((uint64_t)v58, a2) & 1) == 0)
          goto LABEL_740;
        goto LABEL_620;
      case 0x1Au:
        v58 = objc_alloc_init(NWPBAgentClass);
        if (!a1)
          goto LABEL_618;
        v59 = *(void **)(a1 + 128);
        if (v59)
          goto LABEL_617;
        v265 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v266 = *(void **)(a1 + 128);
        *(_QWORD *)(a1 + 128) = v265;

        v62 = 128;
        goto LABEL_616;
      case 0x1Bu:
        v58 = objc_alloc_init(NWPBAgentClass);
        if (!a1)
          goto LABEL_618;
        v59 = *(void **)(a1 + 152);
        if (v59)
          goto LABEL_617;
        v738 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v739 = *(void **)(a1 + 152);
        *(_QWORD *)(a1 + 152) = v738;

        v62 = 152;
        goto LABEL_616;
      case 0x1Cu:
        v58 = objc_alloc_init(NWPBAgentClass);
        if (!a1)
          goto LABEL_618;
        v59 = *(void **)(a1 + 120);
        if (v59)
          goto LABEL_617;
        v60 = objc_alloc_init(MEMORY[0x1E0C99DE8]);
        v61 = *(void **)(a1 + 120);
        *(_QWORD *)(a1 + 120) = v60;

        v62 = 120;
LABEL_616:
        v59 = *(void **)(a1 + v62);
LABEL_617:
        objc_msgSend(v59, "addObject:", v58, v774, v775);
LABEL_618:

        v774 = 0;
        v775 = 0;
        if (PBReaderPlaceMark() && NWPBAgentClassReadFrom((uint64_t)v58, a2))
        {
LABEL_620:
          PBReaderRecallMark();

          goto LABEL_5;
        }
LABEL_740:

        return 0;
      case 0x1Du:
        PBReaderReadData();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = 104;
LABEL_4:
        v13 = *(void **)(a1 + v12);
        *(_QWORD *)(a1 + v12) = v11;

        goto LABEL_5;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0)
          return 0;
        goto LABEL_5;
    }
  }
  v16 = 0;
LABEL_39:
  *v14 = 1;
  goto LABEL_40;
}

void sub_1836E0750(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

char *nw_socks5_server_create(void *a1, void *a2)
{
  id v3;
  id v4;
  char *v5;
  NSObject *v6;
  NSObject *v7;
  char *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v17;
  os_log_type_t v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  char *v24;
  _BOOL4 v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  nw_allow_use_of_dispatch_internal();
  if (v4)
  {
    v5 = (char *)-[NWConcrete_nw_socks5_server initWithParameters:clientQueue:]([NWConcrete_nw_socks5_server alloc], v3, v4);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    v7 = v6;
    if (v5)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_socks5_server_create";
        v30 = 2114;
        v31 = v5;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ created", buf, 0x16u);
      }

      v8 = v5;
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    v29 = "nw_socks5_server_create";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v9, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (!os_log_type_enabled(v10, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_socks5_server_create";
        v12 = "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed";
LABEL_21:
        v17 = v10;
        v18 = v11;
        goto LABEL_22;
      }
      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (!os_log_type_enabled(v10, type))
          goto LABEL_23;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_socks5_server_create";
        v12 = "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed, backtrace limit exceeded";
        goto LABEL_21;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v14 = type;
      v15 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (!v15)
        {
LABEL_23:

          if (!v9)
            goto LABEL_17;
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446210;
        v29 = "nw_socks5_server_create";
        v12 = "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed, no backtrace";
        v17 = v10;
        v18 = v14;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v17, v18, v12, buf, 0xCu);
        goto LABEL_23;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v29 = "nw_socks5_server_create";
        v30 = 2082;
        v31 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s [nw_socks5_server initWithParameters:clientQueue:] failed, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v9)
    {
LABEL_17:

      goto LABEL_18;
    }
LABEL_16:
    free(v9);
    goto LABEL_17;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v29 = "nw_socks5_server_create";
  v20 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v26 = 0;
  if (__nwlog_fault(v20, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_socks5_server_create";
        v23 = "%{public}s called with null queue";
LABEL_40:
        _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0xCu);
      }
    }
    else
    {
      if (v26)
      {
        v24 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        v25 = os_log_type_enabled(v21, type);
        if (v24)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v29 = "nw_socks5_server_create";
            v30 = 2082;
            v31 = v24;
            _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v24);
          goto LABEL_42;
        }
        if (!v25)
          goto LABEL_41;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_socks5_server_create";
        v23 = "%{public}s called with null queue, no backtrace";
        goto LABEL_40;
      }
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_socks5_server_create";
        v23 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_40;
      }
    }
LABEL_41:

  }
LABEL_42:
  if (v20)
    free(v20);
  v5 = 0;
LABEL_18:

  return v5;
}

id nw_socks5_server_copy_parameters(uint64_t a1)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(id *)(a1 + 40);
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_socks5_server_copy_parameters";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_socks5_server_copy_parameters";
        v6 = "%{public}s called with null server";
LABEL_16:
        _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
      }
    }
    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v4 = objc_claimAutoreleasedReturnValue();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)buf = 136446466;
            v12 = "nw_socks5_server_copy_parameters";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }
        if (!v8)
          goto LABEL_17;
        *(_DWORD *)buf = 136446210;
        v12 = "nw_socks5_server_copy_parameters";
        v6 = "%{public}s called with null server, no backtrace";
        goto LABEL_16;
      }
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_socks5_server_copy_parameters";
        v6 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
LABEL_17:

  }
LABEL_18:
  if (v3)
    free(v3);
  return 0;
}

uint64_t nw_socks5_server_get_port(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v19 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_socks5_server_get_port_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v15 = buf;
    v14 = v1;
    os_unfair_lock_lock(v2 + 6);
    __nw_socks5_server_get_port_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 6);
    v3 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_socks5_server_get_port";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_get_port";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null server", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_socks5_server_get_port";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_get_port";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null server, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_get_port";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null server, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_socks5_server_get_port_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = nw_listener_get_port(*(nw_listener_t *)(*(_QWORD *)(a1 + 32) + 72));
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void nw_socks5_server_cancel_connections(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  _QWORD v11[5];
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = __nw_socks5_server_cancel_connections_block_invoke;
    v11[3] = &unk_1E14ACFD0;
    v3 = v1;
    v11[4] = v3;
    os_unfair_lock_lock(v2 + 6);
    __nw_socks5_server_cancel_connections_block_invoke((uint64_t)v11);
    os_unfair_lock_unlock(v2 + 6);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v15 = "nw_socks5_server_cancel_connections";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_socks5_server_cancel_connections";
        v8 = "%{public}s called with null server";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            v15 = "nw_socks5_server_cancel_connections";
            v16 = 2082;
            v17 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v10)
          goto LABEL_18;
        *(_DWORD *)buf = 136446210;
        v15 = "nw_socks5_server_cancel_connections";
        v8 = "%{public}s called with null server, no backtrace";
        goto LABEL_17;
      }
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_socks5_server_cancel_connections";
        v8 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:

  }
LABEL_19:
  if (v5)
    free(v5);
LABEL_3:

}

void __nw_socks5_server_cancel_connections_block_invoke(uint64_t a1)
{
  nw_socks5_server_cancel_connections_locked(*(void **)(a1 + 32));
}

void nw_socks5_server_cancel_connections_locked(void *a1)
{
  unsigned __int8 **v1;
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  unsigned __int8 **v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v3 = 136446466;
    v4 = "nw_socks5_server_cancel_connections_locked";
    v5 = 2048;
    v6 = v1;
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %p", (uint8_t *)&v3, 0x16u);
  }

  nw_array_apply(v1[10], (uint64_t)&__block_literal_global_36287);
}

uint64_t __nw_socks5_server_cancel_connections_locked_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  _QWORD *v3;
  void *v4;
  NSObject *v5;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  _BYTE block[24];
  void *v18;
  _QWORD *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a3;
  v4 = v3;
  if (v3)
  {
    v5 = v3[5];
    *(_QWORD *)block = MEMORY[0x1E0C809B0];
    *(_QWORD *)&block[8] = 3221225472;
    *(_QWORD *)&block[16] = __nw_socks5_connection_cancel_block_invoke;
    v18 = &unk_1E14ACFD0;
    v19 = v3;
    dispatch_async(v5, block);

    goto LABEL_3;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  *(_DWORD *)block = 136446210;
  *(_QWORD *)&block[4] = "nw_socks5_connection_cancel";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_socks5_connection_cancel";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null connection", block, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)block = 136446466;
          *(_QWORD *)&block[4] = "nw_socks5_connection_cancel";
          *(_WORD *)&block[12] = 2082;
          *(_QWORD *)&block[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", block, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_socks5_connection_cancel";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection, no backtrace", block, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v9 = (id)gLogObj;
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_socks5_connection_cancel";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection, backtrace limit exceeded", block, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

  return 1;
}

void nw_socks5_server_set_error_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  os_unfair_lock_s *v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  void *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  _QWORD v18[6];
  char v19;
  os_log_type_t v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_socks5_server_set_error_handler";
    v9 = (char *)_os_log_send_and_compose_impl();

    v20 = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v9, &v20, &v19))
      goto LABEL_34;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_socks5_server_set_error_handler";
        v12 = "%{public}s called with null server";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = v20;
      v15 = os_log_type_enabled(v10, v20);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_socks5_server_set_error_handler";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v9)
          goto LABEL_4;
LABEL_35:
        free(v9);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_socks5_server_set_error_handler";
        v12 = "%{public}s called with null server, no backtrace";
        goto LABEL_32;
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_socks5_server_set_error_handler";
        v12 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_32;
      }
    }
LABEL_33:

    goto LABEL_34;
  }
  if (v4)
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = __nw_socks5_server_set_error_handler_block_invoke;
    v18[3] = &unk_1E14ACE18;
    v6 = v3;
    v18[4] = v6;
    v7 = v5;
    v18[5] = v7;
    os_unfair_lock_lock(v3 + 6);
    __nw_socks5_server_set_error_handler_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v3 + 6);

    goto LABEL_4;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_socks5_server_set_error_handler";
  v9 = (char *)_os_log_send_and_compose_impl();

  v20 = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v9, &v20, &v19))
    goto LABEL_34;
  if (v20 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_socks5_server_set_error_handler";
      v12 = "%{public}s called with null handler";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (!v19)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_socks5_server_set_error_handler";
      v12 = "%{public}s called with null handler, backtrace limit exceeded";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v11 = v20;
  v17 = os_log_type_enabled(v10, v20);
  if (!v16)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_socks5_server_set_error_handler";
      v12 = "%{public}s called with null handler, no backtrace";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_socks5_server_set_error_handler";
    v23 = 2082;
    v24 = v16;
    _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v9)
    goto LABEL_35;
LABEL_4:

}

void __nw_socks5_server_set_error_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 64);
  *(_QWORD *)(v3 + 64) = v2;

}

void nw_socks5_server_set_state_changed_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  os_unfair_lock_s *v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  void *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char *v16;
  _BOOL4 v17;
  _QWORD v18[6];
  char v19;
  os_log_type_t v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_socks5_server_set_state_changed_handler";
    v9 = (char *)_os_log_send_and_compose_impl();

    v20 = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (!__nwlog_fault(v9, &v20, &v19))
      goto LABEL_34;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_socks5_server_set_state_changed_handler";
        v12 = "%{public}s called with null server";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v10, v11, v12, buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = v20;
      v15 = os_log_type_enabled(v10, v20);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_socks5_server_set_state_changed_handler";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v9)
          goto LABEL_4;
LABEL_35:
        free(v9);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_socks5_server_set_state_changed_handler";
        v12 = "%{public}s called with null server, no backtrace";
        goto LABEL_32;
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = v20;
      if (os_log_type_enabled(v10, v20))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_socks5_server_set_state_changed_handler";
        v12 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_32;
      }
    }
LABEL_33:

    goto LABEL_34;
  }
  if (v4)
  {
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = __nw_socks5_server_set_state_changed_handler_block_invoke;
    v18[3] = &unk_1E14ACE18;
    v6 = v3;
    v18[4] = v6;
    v7 = v5;
    v18[5] = v7;
    os_unfair_lock_lock(v3 + 6);
    __nw_socks5_server_set_state_changed_handler_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v3 + 6);

    goto LABEL_4;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_socks5_server_set_state_changed_handler";
  v9 = (char *)_os_log_send_and_compose_impl();

  v20 = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (!__nwlog_fault(v9, &v20, &v19))
    goto LABEL_34;
  if (v20 == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_socks5_server_set_state_changed_handler";
      v12 = "%{public}s called with null handler";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (!v19)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v11 = v20;
    if (os_log_type_enabled(v10, v20))
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_socks5_server_set_state_changed_handler";
      v12 = "%{public}s called with null handler, backtrace limit exceeded";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  v16 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v11 = v20;
  v17 = os_log_type_enabled(v10, v20);
  if (!v16)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_socks5_server_set_state_changed_handler";
      v12 = "%{public}s called with null handler, no backtrace";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v22 = "nw_socks5_server_set_state_changed_handler";
    v23 = 2082;
    v24 = v16;
    _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v9)
    goto LABEL_35;
LABEL_4:

}

void __nw_socks5_server_set_state_changed_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;

  v2 = _Block_copy(*(const void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 56);
  *(_QWORD *)(v3 + 56) = v2;

}

void nw_socks5_server_register_udp_associate_request(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  os_unfair_lock_s *v9;
  id v10;
  id v11;
  NSObject *v12;
  id v13;
  void *v14;
  uint64_t v15;
  id v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  void *v22;
  void *v23;
  void *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  char *v31;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  char *v35;
  _BOOL4 v36;
  os_log_type_t type;
  NSObject *log;
  _QWORD v39[4];
  os_unfair_lock_s *v40;
  id v41;
  id v42;
  NSObject *v43;
  id v44;
  _QWORD block[4];
  id v46;
  char v47;
  os_log_type_t v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = v13;
  if (!v9)
  {
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_socks5_server_register_udp_associate_request";
    v18 = (char *)_os_log_send_and_compose_impl();

    v48 = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v18, &v48, &v47))
      goto LABEL_66;
    if (v48 != OS_LOG_TYPE_FAULT)
    {
      if (v47)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = v48;
        v30 = os_log_type_enabled(v19, v48);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            v50 = "nw_socks5_server_register_udp_associate_request";
            v51 = 2082;
            v52 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_66:
          if (!v18)
            goto LABEL_6;
LABEL_67:
          free(v18);
          goto LABEL_6;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v50 = "nw_socks5_server_register_udp_associate_request";
          v21 = "%{public}s called with null server, no backtrace";
          goto LABEL_64;
        }
      }
      else
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = v48;
        if (os_log_type_enabled(v19, v48))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "nw_socks5_server_register_udp_associate_request";
          v21 = "%{public}s called with null server, backtrace limit exceeded";
          goto LABEL_64;
        }
      }
      goto LABEL_65;
    }
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v20 = v48;
    if (!os_log_type_enabled(v19, v48))
      goto LABEL_65;
    *(_DWORD *)buf = 136446210;
    v50 = "nw_socks5_server_register_udp_associate_request";
    v21 = "%{public}s called with null server";
    goto LABEL_64;
  }
  if (!v13)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_socks5_server_register_udp_associate_request";
    v18 = (char *)_os_log_send_and_compose_impl();

    v48 = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v18, &v48, &v47))
      goto LABEL_66;
    if (v48 != OS_LOG_TYPE_FAULT)
    {
      if (!v47)
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = v48;
        if (os_log_type_enabled(v19, v48))
        {
          *(_DWORD *)buf = 136446210;
          v50 = "nw_socks5_server_register_udp_associate_request";
          v21 = "%{public}s called with null handler, backtrace limit exceeded";
          goto LABEL_64;
        }
        goto LABEL_65;
      }
      v31 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = v48;
      v32 = os_log_type_enabled(v19, v48);
      if (!v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v50 = "nw_socks5_server_register_udp_associate_request";
          v21 = "%{public}s called with null handler, no backtrace";
          goto LABEL_64;
        }
        goto LABEL_65;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        v50 = "nw_socks5_server_register_udp_associate_request";
        v51 = 2082;
        v52 = v31;
        v33 = "%{public}s called with null handler, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v19, v20, v33, buf, 0x16u);
      }
LABEL_37:

      free(v31);
      if (!v18)
        goto LABEL_6;
      goto LABEL_67;
    }
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v20 = v48;
    if (!os_log_type_enabled(v19, v48))
      goto LABEL_65;
    *(_DWORD *)buf = 136446210;
    v50 = "nw_socks5_server_register_udp_associate_request";
    v21 = "%{public}s called with null handler";
LABEL_64:
    _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
    goto LABEL_65;
  }
  if (!v12)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_socks5_server_register_udp_associate_request";
    v18 = (char *)_os_log_send_and_compose_impl();

    v48 = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v18, &v48, &v47))
      goto LABEL_66;
    if (v48 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = v48;
      if (os_log_type_enabled(v19, v48))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_socks5_server_register_udp_associate_request";
        v21 = "%{public}s called with null queue";
        goto LABEL_64;
      }
LABEL_65:

      goto LABEL_66;
    }
    if (!v47)
    {
      __nwlog_obj();
      v19 = objc_claimAutoreleasedReturnValue();
      v20 = v48;
      if (os_log_type_enabled(v19, v48))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_socks5_server_register_udp_associate_request";
        v21 = "%{public}s called with null queue, backtrace limit exceeded";
        goto LABEL_64;
      }
      goto LABEL_65;
    }
    v31 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v19 = objc_claimAutoreleasedReturnValue();
    v20 = v48;
    v34 = os_log_type_enabled(v19, v48);
    if (!v31)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v50 = "nw_socks5_server_register_udp_associate_request";
        v21 = "%{public}s called with null queue, no backtrace";
        goto LABEL_64;
      }
      goto LABEL_65;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v50 = "nw_socks5_server_register_udp_associate_request";
      v51 = 2082;
      v52 = v31;
      v33 = "%{public}s called with null queue, dumping backtrace:%{public}s";
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  v15 = MEMORY[0x1E0C809B0];
  if (!v10)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v50 = "nw_socks5_server_register_udp_associate_request";
    v25 = (char *)_os_log_send_and_compose_impl();

    v48 = OS_LOG_TYPE_ERROR;
    v47 = 0;
    if (!__nwlog_fault(v25, &v48, &v47))
      goto LABEL_55;
    if (v48 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v27 = v48;
      if (!os_log_type_enabled(v26, v48))
      {
LABEL_54:

LABEL_55:
        if (!v25)
        {
LABEL_57:
          block[0] = v15;
          block[1] = 3221225472;
          block[2] = __nw_socks5_server_register_udp_associate_request_block_invoke;
          block[3] = &unk_1E14AC390;
          v46 = v14;
          dispatch_async(v12, block);

          goto LABEL_5;
        }
LABEL_56:
        free(v25);
        goto LABEL_57;
      }
      *(_DWORD *)buf = 136446210;
      v50 = "nw_socks5_server_register_udp_associate_request";
      v28 = "%{public}s called with null socks5_connection";
    }
    else
    {
      if (v47)
      {
        v35 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        log = objc_claimAutoreleasedReturnValue();
        type = v48;
        v36 = os_log_type_enabled(log, v48);
        if (v35)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            v50 = "nw_socks5_server_register_udp_associate_request";
            v51 = 2082;
            v52 = v35;
            _os_log_impl(&dword_182FBE000, log, type, "%{public}s called with null socks5_connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v35);
          if (!v25)
            goto LABEL_57;
        }
        else
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446210;
            v50 = "nw_socks5_server_register_udp_associate_request";
            _os_log_impl(&dword_182FBE000, log, type, "%{public}s called with null socks5_connection, no backtrace", buf, 0xCu);
          }

          if (!v25)
            goto LABEL_57;
        }
        goto LABEL_56;
      }
      __nwlog_obj();
      v26 = objc_claimAutoreleasedReturnValue();
      v27 = v48;
      if (!os_log_type_enabled(v26, v48))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v50 = "nw_socks5_server_register_udp_associate_request";
      v28 = "%{public}s called with null socks5_connection, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
    goto LABEL_54;
  }
LABEL_5:
  v39[0] = v15;
  v39[1] = 3221225472;
  v39[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_2;
  v39[3] = &unk_1E14A3D40;
  v40 = v9;
  v41 = v11;
  v42 = v10;
  v43 = v12;
  v16 = v14;
  v44 = v16;
  os_unfair_lock_lock(v9 + 6);
  __nw_socks5_server_register_udp_associate_request_block_invoke_2((uint64_t)v39);
  os_unfair_lock_unlock(v9 + 6);

LABEL_6:
}

uint64_t __nw_socks5_server_register_udp_associate_request_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __nw_socks5_server_register_udp_associate_request_block_invoke_2(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  const char *hostname;
  const char *v6;
  int port;
  xpc_object_t v8;
  uint64_t v9;
  const char *string_ptr;
  void *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  id *v15;
  _QWORD *v16;
  id v17;
  _QWORD *v18;
  NSObject *v19;
  _QWORD *v20;
  id v21;
  _QWORD *v22;
  uint64_t v23;
  const char *v24;
  NSObject *v25;
  _QWORD v26[4];
  _QWORD *v27;
  id v28;
  id v29;
  id v30;
  id v31;
  _QWORD v32[4];
  id v33;
  _QWORD block[4];
  id v35;
  id v36;
  id v37;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88))
  {
    v2 = nw_dictionary_create();
    v3 = *(_QWORD *)(a1 + 32);
    v4 = *(void **)(v3 + 88);
    *(_QWORD *)(v3 + 88) = v2;

  }
  hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 40));
  if (nw_endpoint_get_address_family(*(void **)(a1 + 40)) == 30)
    v6 = ".";
  else
    v6 = ":";
  port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 40));
  nw_endpoint_get_description(*(void **)(a1 + 40));
  v8 = xpc_string_create_with_format("%s%s%u", hostname, v6, port);
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
  string_ptr = xpc_string_get_string_ptr(v8);
  v11 = nw_dictionary_copy_value(v9, (uint64_t)string_ptr);
  v12 = *(_QWORD **)(a1 + 32);
  if (v11)
  {
    v13 = (void *)v12[4];
    v14 = MEMORY[0x1E0C809B0];
    v26[0] = MEMORY[0x1E0C809B0];
    v26[1] = 3221225472;
    v26[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_4;
    v26[3] = &unk_1E14A0B80;
    v15 = (id *)&v27;
    v27 = v12;
    v28 = *(id *)(a1 + 48);
    v29 = v8;
    v30 = *(id *)(a1 + 56);
    v31 = *(id *)(a1 + 64);
    v16 = v11;
    v17 = v13;
    v18 = v26;
    v19 = v16[5];
    block[0] = v14;
    block[1] = 3221225472;
    block[2] = __nw_socks5_connection_validate_udp_association_block_invoke_2;
    block[3] = &unk_1E14A8D98;
    v20 = v16;
    v35 = v20;
    v21 = v17;
    v36 = v21;
    v22 = v18;
    v37 = v22;
    dispatch_async(v19, block);

  }
  else
  {
    v23 = v12[11];
    v24 = xpc_string_get_string_ptr(v8);
    nw_dictionary_set_value(v23, v24, *(void **)(a1 + 48));
    v32[0] = MEMORY[0x1E0C809B0];
    v32[1] = 3221225472;
    v32[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_3;
    v32[3] = &unk_1E14AC390;
    v15 = &v33;
    v25 = *(NSObject **)(a1 + 56);
    v33 = *(id *)(a1 + 64);
    dispatch_async(v25, v32);
  }

}

uint64_t __nw_socks5_server_register_udp_associate_request_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __nw_socks5_server_register_udp_associate_request_block_invoke_4(uint64_t a1, char a2)
{
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  id v6;
  id v7;
  id v8;
  id v9;
  os_unfair_lock_s *v10;
  _QWORD v11[9];
  char v12;

  v4 = *(os_unfair_lock_s **)(a1 + 32);
  v5 = v4 + 6;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_5;
  v11[3] = &unk_1E14A0B58;
  v10 = v4;
  v11[4] = v10;
  v6 = *(id *)(a1 + 40);
  v11[5] = v6;
  v12 = a2;
  v7 = *(id *)(a1 + 48);
  v11[6] = v7;
  v8 = *(id *)(a1 + 56);
  v11[7] = v8;
  v9 = *(id *)(a1 + 64);
  v11[8] = v9;
  os_unfair_lock_lock(v5);
  __nw_socks5_server_register_udp_associate_request_block_invoke_5((uint64_t)v11);
  os_unfair_lock_unlock(v5);

}

void __nw_socks5_server_register_udp_associate_request_block_invoke_5(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v6;
  _QWORD *v7;
  char v8;
  uint64_t v9;
  const char *string_ptr;
  NSObject *v11;
  _QWORD v12[4];
  id v13;
  char v14;

  v1 = *(_QWORD **)(a1 + 32);
  if (v1[9])
  {
    v3 = v1[10];
    v4 = *(_QWORD *)(a1 + 40);
    if (v3 && v4 != 0)
    {
      v7 = *(_QWORD **)(v3 + 16);
      v6 = *(_QWORD **)(v3 + 24);
      if (v7 != v6)
      {
        while (*v7 != v4)
        {
          if (++v7 == v6)
          {
            v7 = v6;
            break;
          }
        }
      }
      if (v7 != v6)
      {
        v8 = *(_BYTE *)(a1 + 72) ^ 1;
        if (!*(_BYTE *)(a1 + 72))
        {
          v9 = v1[11];
          string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 48));
          nw_dictionary_set_value(v9, string_ptr, *(void **)(a1 + 40));
        }
        v12[0] = MEMORY[0x1E0C809B0];
        v12[1] = 3221225472;
        v12[2] = __nw_socks5_server_register_udp_associate_request_block_invoke_6;
        v12[3] = &unk_1E14AAE50;
        v11 = *(NSObject **)(a1 + 56);
        v13 = *(id *)(a1 + 64);
        v14 = v8;
        dispatch_async(v11, v12);

      }
    }
  }
}

uint64_t __nw_socks5_server_register_udp_associate_request_block_invoke_6(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void nw_socks5_server_call_outer_connection_handler(void *a1, void *a2, void *a3)
{
  _QWORD *v5;
  id v6;
  id v7;
  uint64_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (v5)
  {
    v8 = v5[12];
    if (v8)
      (*(void (**)(uint64_t, id, id))(v8 + 16))(v8, v6, v7);
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_socks5_server_call_outer_connection_handler";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_socks5_server_call_outer_connection_handler";
        v13 = "%{public}s called with null server";
LABEL_18:
        _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
      }
    }
    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_socks5_server_call_outer_connection_handler";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (!v15)
          goto LABEL_19;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_socks5_server_call_outer_connection_handler";
        v13 = "%{public}s called with null server, no backtrace";
        goto LABEL_18;
      }
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_socks5_server_call_outer_connection_handler";
        v13 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
LABEL_19:

  }
LABEL_20:
  if (v10)
    free(v10);
LABEL_4:

}

void nw_socks5_server_start(void *a1)
{
  nw_listener_t *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  nw_listener_t *v7;
  NSObject *v8;
  nw_listener_t *v9;
  id *v10;
  nw_listener_t v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  _QWORD v18[4];
  nw_listener_t *v19;
  _QWORD handler[4];
  nw_listener_t *v21;
  char v22;
  os_log_type_t v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  void *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v3 = (id)gLogObj;
  v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_socks5_server_start";
      v26 = 2114;
      v27 = v2;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ start", buf, 0x16u);
    }

    v5 = v2[9];
    v6 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = __nw_socks5_server_start_block_invoke;
    handler[3] = &unk_1E14ACF48;
    v7 = v2;
    v21 = v7;
    nw_listener_set_state_changed_handler(v5, handler);
    v8 = v2[9];
    v18[0] = v6;
    v18[1] = 3221225472;
    v18[2] = __nw_socks5_server_start_block_invoke_10;
    v18[3] = &unk_1E14A0BA8;
    v9 = v7;
    v19 = v9;
    nw_listener_set_new_connection_handler(v8, v18);
    nw_listener_set_queue(v2[9], v9[4]);
    nw_listener_start(v2[9]);
    v11 = v9[2];
    v10 = (id *)(v9 + 2);
    if (!v11)
      objc_storeStrong(v10, a1);

    goto LABEL_7;
  }
  *(_DWORD *)buf = 136446210;
  v25 = "nw_socks5_server_start";
  v12 = (char *)_os_log_send_and_compose_impl();

  v23 = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (__nwlog_fault(v12, &v23, &v22))
  {
    if (v23 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = v23;
      if (os_log_type_enabled(v13, v23))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_socks5_server_start";
        v15 = "%{public}s called with null server";
LABEL_21:
        _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
      }
    }
    else
    {
      if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = v23;
        v17 = os_log_type_enabled(v13, v23);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v25 = "nw_socks5_server_start";
            v26 = 2082;
            v27 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (!v17)
          goto LABEL_22;
        *(_DWORD *)buf = 136446210;
        v25 = "nw_socks5_server_start";
        v15 = "%{public}s called with null server, no backtrace";
        goto LABEL_21;
      }
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = v23;
      if (os_log_type_enabled(v13, v23))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_socks5_server_start";
        v15 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_22:

  }
LABEL_23:
  if (v12)
    free(v12);
LABEL_7:

}

void __nw_socks5_server_start_block_invoke(uint64_t a1, int a2, void *a3)
{
  id v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  id v9;
  _QWORD v10[6];
  int v11;

  v5 = a3;
  v6 = *(os_unfair_lock_s **)(a1 + 32);
  v7 = v6 + 6;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = __nw_socks5_server_start_block_invoke_2;
  v10[3] = &unk_1E14ACF20;
  v8 = v6;
  v11 = a2;
  v10[4] = v8;
  v10[5] = v5;
  v9 = v5;
  os_unfair_lock_lock(v7);
  __nw_socks5_server_start_block_invoke_2((uint64_t)v10);
  os_unfair_lock_unlock(v7);

}

void __nw_socks5_server_start_block_invoke_10(uint64_t a1, void *a2)
{
  id v4;
  uint64_t v5;
  void *v6;
  _QWORD *v7;
  int v8;
  void *v9;
  char v10;
  NSObject *v11;
  id v12;
  NWConcrete_nw_socks5_connection *v13;
  NSObject *v14;
  id v15;
  id v16;
  NWConcrete_nw_socks5_connection *v17;
  unint64_t v18;
  char v19;
  char v20;
  NWConcrete_nw_socks5_connection *v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t receiver;
  char *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  nw_endpoint_t v33;
  os_unfair_lock_s *v34;
  uint64_t v35;
  os_unfair_lock_s *v36;
  NWConcrete_nw_socks5_connection *v37;
  NSObject **v38;
  _QWORD *v39;
  NSObject *v40;
  NSObject **v41;
  NSObject **v42;
  _QWORD *v43;
  NSObject **v44;
  NSObject *v45;
  NSObject **v46;
  uint64_t v47;
  nw_endpoint_t v48;
  id v49;
  char *v50;
  NSObject *v51;
  os_log_type_t v52;
  char *v53;
  os_log_type_t v54;
  _BOOL4 v55;
  os_log_type_t v56;
  void *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  void *v61;
  os_log_type_t v62;
  void *v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  _BOOL4 v71;
  char *backtrace_string;
  os_log_type_t v73;
  _BOOL4 v74;
  os_log_type_t v75;
  os_log_type_t v76;
  os_log_type_t v77;
  uint64_t v78;
  id v79;
  _QWORD v80[4];
  id v81;
  NWConcrete_nw_socks5_connection *v82;
  _QWORD v83[4];
  os_unfair_lock_s *v84;
  NWConcrete_nw_socks5_connection *v85;
  char v86;
  os_log_type_t type;
  objc_super v88;
  _BYTE buf[24];
  NWConcrete_nw_socks5_connection *v90;
  __int128 v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(void **)(v5 + 40);
  v78 = a1;
  if (v6)
  {
    v7 = v6;
    v8 = (*(unsigned __int16 *)(v7[13] + 108) >> 1) & 1;

    v5 = *(_QWORD *)(a1 + 32);
  }
  else
  {
    v8 = 0;
  }
  v9 = *(void **)(v5 + 32);
  v10 = *(_BYTE *)(v5 + 136);
  v11 = v4;
  v12 = v9;
  v79 = (id)v5;
  if (v11)
  {
    if (v12)
    {
      v13 = [NWConcrete_nw_socks5_connection alloc];
      v14 = v11;
      v15 = v12;
      v16 = v79;
      if (!v13)
        goto LABEL_16;
      v88.receiver = v13;
      v88.super_class = (Class)NWConcrete_nw_socks5_connection;
      v17 = (NWConcrete_nw_socks5_connection *)objc_msgSendSuper2(&v88, sel_init);
      v13 = v17;
      if (v17)
      {
        do
          v18 = __ldaxr(&s_last_connection_id);
        while (__stlxr(v18 + 1, &s_last_connection_id));
        v17->sc_id = v18;
        objc_storeStrong((id *)&v17->sc_in_connection, a2);
        objc_storeStrong((id *)&v13->sc_queue, v9);
        if ((v10 & 1) != 0)
          v19 = 101;
        else
          v19 = 1;
        v13->sc_state = v19;
        if (v8)
          v20 = 4;
        else
          v20 = 0;
        *((_BYTE *)v13 + 160) = *((_BYTE *)v13 + 160) & 0xFB | v20;
        objc_storeWeak((id *)&v13->sc_parent, v16);
        goto LABEL_16;
      }
      __nwlog_obj();
      v63 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
      v64 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v86 = 0;
      if ((__nwlog_fault(v64, &type, &v86) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v86)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v73 = type;
          v74 = os_log_type_enabled(v65, type);
          if (backtrace_string)
          {
            if (v74)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v65, v73, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_115;
          }
          if (v74)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
            _os_log_impl(&dword_182FBE000, v65, v73, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v77 = type;
          if (os_log_type_enabled(v65, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "-[NWConcrete_nw_socks5_connection initWithConnection:queue:parent:shoes:disableProxy:]";
            _os_log_impl(&dword_182FBE000, v65, v77, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_115:
      if (v64)
        free(v64);
      v13 = 0;
LABEL_16:

      if (v13)
      {
        v21 = v13;
LABEL_37:

        goto LABEL_38;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
      v23 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(v88.receiver) = 16;
      type = OS_LOG_TYPE_DEFAULT;
      if ((__nwlog_fault(v23, &v88, &type) & 1) != 0)
      {
        if (LOBYTE(v88.receiver) == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = (id)gLogObj;
          receiver = (os_log_type_t)v88.receiver;
          if (os_log_type_enabled(v24, (os_log_type_t)v88.receiver))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
            _os_log_impl(&dword_182FBE000, v24, receiver, "%{public}s [nw_socks5_connection initWithConnection:queue:shoes:] failed", buf, 0xCu);
          }
        }
        else if (type)
        {
          v26 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = (id)gLogObj;
          v27 = (os_log_type_t)v88.receiver;
          v28 = os_log_type_enabled(v24, (os_log_type_t)v88.receiver);
          if (v26)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v26;
              _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s [nw_socks5_connection initWithConnection:queue:shoes:] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v26);
            if (!v23)
              goto LABEL_37;
            goto LABEL_36;
          }
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
            _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s [nw_socks5_connection initWithConnection:queue:shoes:] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = (id)gLogObj;
          v29 = (os_log_type_t)v88.receiver;
          if (os_log_type_enabled(v24, (os_log_type_t)v88.receiver))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
            _os_log_impl(&dword_182FBE000, v24, v29, "%{public}s [nw_socks5_connection initWithConnection:queue:shoes:] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v23)
        goto LABEL_37;
LABEL_36:
      free(v23);
      goto LABEL_37;
    }
    __nwlog_obj();
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
    v58 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v88.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v58, &v88, &type))
    {
      if (LOBYTE(v88.receiver) == 17)
      {
        __nwlog_obj();
        v59 = objc_claimAutoreleasedReturnValue();
        v62 = (os_log_type_t)v88.receiver;
        if (os_log_type_enabled(v59, (os_log_type_t)v88.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_182FBE000, v59, v62, "%{public}s called with null queue", buf, 0xCu);
        }
LABEL_108:

        goto LABEL_109;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v59 = objc_claimAutoreleasedReturnValue();
        v76 = (os_log_type_t)v88.receiver;
        if (os_log_type_enabled(v59, (os_log_type_t)v88.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_182FBE000, v59, v76, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_108;
      }
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v70 = (os_log_type_t)v88.receiver;
      v71 = os_log_type_enabled(v59, (os_log_type_t)v88.receiver);
      if (!v67)
      {
        if (v71)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_182FBE000, v59, v70, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
        goto LABEL_108;
      }
      if (v71)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v67;
        _os_log_impl(&dword_182FBE000, v59, v70, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_88;
    }
  }
  else
  {
    __nwlog_obj();
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
    v58 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v88.receiver) = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v58, &v88, &type))
    {
      if (LOBYTE(v88.receiver) == 17)
      {
        __nwlog_obj();
        v59 = objc_claimAutoreleasedReturnValue();
        v60 = (os_log_type_t)v88.receiver;
        if (os_log_type_enabled(v59, (os_log_type_t)v88.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s called with null connection", buf, 0xCu);
        }
        goto LABEL_108;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        __nwlog_obj();
        v59 = objc_claimAutoreleasedReturnValue();
        v75 = (os_log_type_t)v88.receiver;
        if (os_log_type_enabled(v59, (os_log_type_t)v88.receiver))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_182FBE000, v59, v75, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_108;
      }
      v67 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v59 = objc_claimAutoreleasedReturnValue();
      v68 = (os_log_type_t)v88.receiver;
      v69 = os_log_type_enabled(v59, (os_log_type_t)v88.receiver);
      if (!v67)
      {
        if (v69)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
          _os_log_impl(&dword_182FBE000, v59, v68, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
        goto LABEL_108;
      }
      if (v69)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_socks5_connection_create";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v67;
        _os_log_impl(&dword_182FBE000, v59, v68, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_88:

      free(v67);
    }
  }
LABEL_109:
  if (v58)
    free(v58);
  v13 = 0;
LABEL_38:

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v30 = (id)gLogObj;
  v31 = v30;
  if (v13)
  {
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v32 = *(_QWORD *)(v78 + 32);
      v33 = nw_connection_copy_endpoint(v11);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke";
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v32;
      *(_WORD *)&buf[22] = 2112;
      v90 = v13;
      LOWORD(v91) = 2112;
      *(_QWORD *)((char *)&v91 + 2) = v33;
      _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEFAULT, "%{public}s %@ received new connection %@ from %@", buf, 0x2Au);

    }
    v34 = *(os_unfair_lock_s **)(v78 + 32);
    v35 = MEMORY[0x1E0C809B0];
    v36 = v34 + 6;
    v83[0] = MEMORY[0x1E0C809B0];
    v83[1] = 3221225472;
    v83[2] = __nw_socks5_server_start_block_invoke_11;
    v83[3] = &unk_1E14ACE68;
    v84 = v34;
    v37 = v13;
    v85 = v37;
    os_unfair_lock_lock(v36);
    __nw_socks5_server_start_block_invoke_11((uint64_t)v83);
    os_unfair_lock_unlock(v36);
    v80[0] = v35;
    v80[1] = 3221225472;
    v80[2] = __nw_socks5_server_start_block_invoke_2_12;
    v80[3] = &unk_1E14ACE68;
    v81 = *(id *)(v78 + 32);
    v82 = v37;
    v38 = v82;
    v39 = v80;
    v41 = v38 + 5;
    v40 = v38[5];
    *(_QWORD *)buf = v35;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __nw_socks5_connection_set_cancel_handler_block_invoke;
    v90 = (NWConcrete_nw_socks5_connection *)&unk_1E14ACE18;
    v42 = v38;
    *(_QWORD *)&v91 = v42;
    v43 = v39;
    *((_QWORD *)&v91 + 1) = v43;
    dispatch_async(v40, buf);

    v44 = v42;
    v45 = *v41;
    *(_QWORD *)buf = v35;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = __nw_socks5_connection_start_block_invoke;
    v90 = (NWConcrete_nw_socks5_connection *)&unk_1E14ACFD0;
    v46 = v44;
    *(_QWORD *)&v91 = v46;
    dispatch_async(v45, buf);

    goto LABEL_63;
  }
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v47 = *(_QWORD *)(v78 + 32);
    v48 = nw_connection_copy_endpoint(v11);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke";
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v47;
    *(_WORD *)&buf[22] = 2112;
    v90 = (NWConcrete_nw_socks5_connection *)v48;
    _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_ERROR, "%{public}s %@ failed to create new connection from %@", buf, 0x20u);

  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v49 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke";
  v50 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v88.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v50, &v88, &type))
    goto LABEL_61;
  if (LOBYTE(v88.receiver) == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (id)gLogObj;
    v52 = (os_log_type_t)v88.receiver;
    if (os_log_type_enabled(v51, (os_log_type_t)v88.receiver))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke";
      _os_log_impl(&dword_182FBE000, v51, v52, "%{public}s nw_socks5_connection_create failed", buf, 0xCu);
    }
LABEL_60:

LABEL_61:
    if (!v50)
      goto LABEL_63;
LABEL_62:
    free(v50);
    goto LABEL_63;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v51 = (id)gLogObj;
    v56 = (os_log_type_t)v88.receiver;
    if (os_log_type_enabled(v51, (os_log_type_t)v88.receiver))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke";
      _os_log_impl(&dword_182FBE000, v51, v56, "%{public}s nw_socks5_connection_create failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_60;
  }
  v53 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v51 = (id)gLogObj;
  v54 = (os_log_type_t)v88.receiver;
  v55 = os_log_type_enabled(v51, (os_log_type_t)v88.receiver);
  if (!v53)
  {
    if (v55)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke";
      _os_log_impl(&dword_182FBE000, v51, v54, "%{public}s nw_socks5_connection_create failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_60;
  }
  if (v55)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v53;
    _os_log_impl(&dword_182FBE000, v51, v54, "%{public}s nw_socks5_connection_create failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v53);
  if (v50)
    goto LABEL_62;
LABEL_63:

}

void sub_1836E46CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __nw_socks5_server_start_block_invoke_11(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  unint64_t v5;

  nw_array_append(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80), *(void **)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(v2 + 108);
  if (v3 != -1)
  {
    *(_DWORD *)(v2 + 108) = v3 + 1;
    v2 = *(_QWORD *)(a1 + 32);
  }
  v4 = *(_QWORD *)(v2 + 80);
  if (v4)
  {
    v5 = (uint64_t)(*(_QWORD *)(v4 + 24) - *(_QWORD *)(v4 + 16)) >> 3;
    if (v5 > *(unsigned int *)(v2 + 104))
    {
      if (v5 >= 0xFFFFFFFF)
        LODWORD(v5) = -1;
      *(_DWORD *)(v2 + 104) = v5;
    }
  }
}

void __nw_socks5_server_start_block_invoke_2_12(uint64_t a1)
{
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  id v4;
  os_unfair_lock_s *v5;
  _QWORD v6[6];

  v2 = *(os_unfair_lock_s **)(a1 + 32);
  v3 = v2 + 6;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __nw_socks5_server_start_block_invoke_3;
  v6[3] = &unk_1E14ACE68;
  v5 = v2;
  v6[4] = v5;
  v4 = *(id *)(a1 + 40);
  v6[5] = v4;
  os_unfair_lock_lock(v3);
  __nw_socks5_server_start_block_invoke_3((uint64_t)v6);
  os_unfair_lock_unlock(v3);

}

void __nw_socks5_server_start_block_invoke_3(uint64_t a1)
{
  _BOOL8 v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  int v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  const char *string_ptr;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  size_t count;
  _QWORD v19[4];
  id v20;
  _BYTE *v21;
  uint8_t v22[4];
  const char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  size_t v29;
  _BYTE buf[24];
  uint64_t (*v31)(uint64_t, uint64_t);
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = nw_array_duplicate_array_without_object(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80), *(void **)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 80);
  *(_QWORD *)(v3 + 80) = v2;

  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80);
  if (v5)
    v6 = (uint64_t)(*(_QWORD *)(v5 + 24) - *(_QWORD *)(v5 + 16)) >> 3;
  else
    v6 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 32);
    v9 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 40);
    v10 = *(_DWORD *)(v8 + 132);
    *(_DWORD *)buf = 136447234;
    *(_QWORD *)&buf[4] = "nw_socks5_server_start_block_invoke_3";
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v8;
    *(_WORD *)&buf[22] = 2112;
    v31 = v9;
    LOWORD(v32) = 2048;
    *(_QWORD *)((char *)&v32 + 2) = v6;
    WORD5(v32) = 1024;
    HIDWORD(v32) = v10;
    _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %@ cancelled connection %@, %zu remaining, busy count %u", buf, 0x30u);
  }

  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
  if (v11)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v31 = __Block_byref_object_copy__36369;
    *(_QWORD *)&v32 = __Block_byref_object_dispose__36370;
    *((_QWORD *)&v32 + 1) = 0;
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v19[2] = __nw_socks5_server_start_block_invoke_13;
    v19[3] = &unk_1E14AB4B0;
    v20 = *(id *)(a1 + 40);
    v21 = buf;
    nw_dictionary_apply(v11, (uint64_t)v19);
    v12 = *(void **)(*(_QWORD *)&buf[8] + 40);
    if (v12)
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88);
      string_ptr = xpc_string_get_string_ptr(v12);
      nw_dictionary_set_value(v13, string_ptr, 0);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = (id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v17 = *(_QWORD *)(a1 + 32);
        v16 = *(_QWORD *)(a1 + 40);
        count = nw_dictionary_get_count(*(_QWORD *)(v17 + 88));
        *(_DWORD *)v22 = 136446978;
        v23 = "nw_socks5_server_start_block_invoke_2";
        v24 = 2112;
        v25 = v17;
        v26 = 2112;
        v27 = v16;
        v28 = 2048;
        v29 = count;
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEFAULT, "%{public}s %@ removed connection %@ from udp associate %zu remaining", v22, 0x2Au);
      }

    }
    _Block_object_dispose(buf, 8);

  }
}

void sub_1836E4AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__36369(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__36370(uint64_t a1)
{

}

BOOL __nw_socks5_server_start_block_invoke_13(uint64_t a1, char *string, uint64_t a3)
{
  uint64_t v4;
  xpc_object_t v6;
  uint64_t v7;
  void *v8;

  v4 = *(_QWORD *)(a1 + 32);
  if (v4 == a3)
  {
    v6 = xpc_string_create(string);
    v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v8 = *(void **)(v7 + 40);
    *(_QWORD *)(v7 + 40) = v6;

  }
  return v4 != a3;
}

void __nw_socks5_server_start_block_invoke_2(uint64_t a1)
{
  int v2;
  void *v3;
  _QWORD *v4;
  id v5;
  const void *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  id v10;
  void *v11;
  _QWORD *v12;
  id v13;
  const void *v14;
  _QWORD *v15;
  void *v16;
  NSObject *v17;
  id v18;
  void *v19;
  id v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  NSObject *v28;
  os_log_type_t v29;
  char v30;
  os_log_type_t type;
  _BYTE block[24];
  void *v33;
  id v34;
  id v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(void **)(a1 + 40);
  v4 = *(id *)(a1 + 32);
  v5 = v3;
  v6 = (const void *)v4[7];
  if (v6)
  {
    v7 = _Block_copy(v6);
    if (v2 == 4)
    {
      v8 = (void *)v4[7];
      v4[7] = 0;

    }
    v9 = v4[6];
    *(_QWORD *)block = MEMORY[0x1E0C809B0];
    *(_QWORD *)&block[8] = 3221225472;
    *(_QWORD *)&block[16] = __nw_socks5_server_call_state_handler_locked_block_invoke;
    v33 = &unk_1E14ACFF8;
    v35 = v7;
    v36 = v2;
    v34 = v5;
    v10 = v7;
    dispatch_async(v9, block);

  }
  if (*(_DWORD *)(a1 + 48) == 3)
  {
    v11 = *(void **)(a1 + 40);
    if (v11)
    {
      v12 = *(_QWORD **)(a1 + 32);
      v13 = v11;
      v14 = (const void *)v12[8];
      if (v14)
      {
        v15 = v12;
        v16 = _Block_copy(v14);
        v17 = v15[6];
        *(_QWORD *)block = MEMORY[0x1E0C809B0];
        *(_QWORD *)&block[8] = 3221225472;
        *(_QWORD *)&block[16] = __nw_socks5_server_call_error_handler_locked_block_invoke;
        v33 = &unk_1E14ACE18;
        v35 = v16;
        v34 = v13;
        v18 = v16;
        dispatch_async(v17, block);
        v19 = (void *)v12[8];
        v12[8] = 0;

      }
      nw_socks5_server_cancel_locked(*(void **)(a1 + 32));
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (id)gLogObj;
    *(_DWORD *)block = 136446210;
    *(_QWORD *)&block[4] = "nw_socks5_server_start_block_invoke_2";
    v21 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v21, &type, &v30))
      goto LABEL_24;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = (id)gLogObj;
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_socks5_server_start_block_invoke";
        v24 = "%{public}s listener reported state of failed with NULL error";
LABEL_21:
        v28 = v22;
        v29 = v23;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v28, v29, v24, block, 0xCu);
      }
    }
    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = (id)gLogObj;
      v26 = type;
      v27 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)block = 136446466;
          *(_QWORD *)&block[4] = "nw_socks5_server_start_block_invoke";
          *(_WORD *)&block[12] = 2082;
          *(_QWORD *)&block[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v26, "%{public}s listener reported state of failed with NULL error, dumping backtrace:%{public}s", block, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v27)
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_socks5_server_start_block_invoke";
        v24 = "%{public}s listener reported state of failed with NULL error, no backtrace";
        v28 = v22;
        v29 = v26;
        goto LABEL_22;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = (id)gLogObj;
      v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)block = 136446210;
        *(_QWORD *)&block[4] = "nw_socks5_server_start_block_invoke";
        v24 = "%{public}s listener reported state of failed with NULL error, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

LABEL_24:
    if (v21)
      free(v21);
  }
}

uint64_t __nw_socks5_server_call_state_handler_locked_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 48), *(_QWORD *)(a1 + 32));
}

uint64_t __nw_socks5_server_call_error_handler_locked_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
}

void nw_socks5_server_cancel_locked(void *a1)
{
  id v1;
  NSObject *v2;
  void *v3;
  NSObject *v4;
  void *v5;
  NSObject *v6;
  void *v7;
  IOPMAssertionID v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  unint64_t v13;
  void *v14;
  int v15;
  const char *v16;
  __int16 v17;
  id v18;
  __int16 v19;
  int v20;
  __int16 v21;
  unint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v15 = 136446466;
    v16 = "nw_socks5_server_cancel_locked";
    v17 = 2048;
    v18 = v1;
    _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %p", (uint8_t *)&v15, 0x16u);
  }

  v3 = (void *)*((_QWORD *)v1 + 8);
  *((_QWORD *)v1 + 8) = 0;

  v4 = *((_QWORD *)v1 + 9);
  if (v4)
  {
    nw_listener_cancel(v4);
    v5 = (void *)*((_QWORD *)v1 + 9);
    *((_QWORD *)v1 + 9) = 0;

  }
  nw_socks5_server_cancel_connections_locked(v1);
  v6 = *((_QWORD *)v1 + 15);
  if (v6)
  {
    dispatch_source_cancel(v6);
    if ((*((_BYTE *)v1 + 136) & 2) == 0)
    {
      *((_BYTE *)v1 + 136) |= 2u;
      dispatch_resume(*((dispatch_object_t *)v1 + 15));
    }
    v7 = (void *)*((_QWORD *)v1 + 15);
    *((_QWORD *)v1 + 15) = 0;

  }
  v8 = *((_DWORD *)v1 + 32);
  if (v8)
  {
    IOPMAssertionRelease(v8);
    v9 = mach_continuous_time();
    if (v9 <= 1)
      v10 = 1;
    else
      v10 = v9;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      v12 = *((_DWORD *)v1 + 32);
      v13 = nw_delta_nanos(*((_QWORD *)v1 + 14), v10);
      v16 = "nw_socks5_server_cancel_locked";
      v17 = 2112;
      v15 = 136446978;
      v18 = v1;
      v19 = 1024;
      v20 = v12;
      v21 = 2048;
      v22 = v13 / 0x3B9ACA00;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s %@ released power assertion: %u after %llus", (uint8_t *)&v15, 0x26u);
    }

    *((_QWORD *)v1 + 14) = v10;
    *((_DWORD *)v1 + 32) = 0;
  }
  v14 = (void *)*((_QWORD *)v1 + 2);
  if (v14)
  {
    *((_QWORD *)v1 + 2) = 0;

  }
}

void nw_socks5_server_cancel(void *a1)
{
  _QWORD *v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  char *backtrace_string;
  _BOOL4 v10;
  _QWORD block[4];
  _QWORD *v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  v3 = v2;
  if (v1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v16 = "nw_socks5_server_cancel";
      v17 = 2114;
      v18 = (char *)v1;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ cancel", buf, 0x16u);
    }

    v4 = v1[4];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __nw_socks5_server_cancel_block_invoke;
    block[3] = &unk_1E14ACFD0;
    v12 = v1;
    dispatch_async(v4, block);

    goto LABEL_5;
  }
  *(_DWORD *)buf = 136446210;
  v16 = "nw_socks5_server_cancel";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_socks5_server_cancel";
        v8 = "%{public}s called with null server";
LABEL_19:
        _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v6 = objc_claimAutoreleasedReturnValue();
        v7 = type;
        v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            v16 = "nw_socks5_server_cancel";
            v17 = 2082;
            v18 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null server, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (!v10)
          goto LABEL_20;
        *(_DWORD *)buf = 136446210;
        v16 = "nw_socks5_server_cancel";
        v8 = "%{public}s called with null server, no backtrace";
        goto LABEL_19;
      }
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_socks5_server_cancel";
        v8 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
LABEL_20:

  }
LABEL_21:
  if (v5)
    free(v5);
LABEL_5:

}

void __nw_socks5_server_cancel_block_invoke(uint64_t a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  _QWORD v4[5];

  v1 = *(os_unfair_lock_s **)(a1 + 32);
  v2 = v1 + 6;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __nw_socks5_server_cancel_block_invoke_2;
  v4[3] = &unk_1E14ACFD0;
  v3 = v1;
  v4[4] = v3;
  os_unfair_lock_lock(v2);
  __nw_socks5_server_cancel_block_invoke_2((uint64_t)v4);
  os_unfair_lock_unlock(v2);

}

void __nw_socks5_server_cancel_block_invoke_2(uint64_t a1)
{
  nw_socks5_server_cancel_locked(*(void **)(a1 + 32));
}

void __nw_socks5_server_handle_busy_changed_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t *v4;
  const __CFAllocator *v5;
  CFNumberRef v6;
  CFStringRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFDictionaryRef v10;
  NSObject *v11;
  dispatch_source_t v12;
  uint64_t v13;
  void *v14;
  _QWORD *v15;
  NSObject *v16;
  dispatch_time_t v17;
  const __CFDictionary *v18;
  unsigned int v19;
  NSObject *v20;
  IOPMAssertionID v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  _BOOL4 v27;
  IOPMAssertionID v28;
  unint64_t v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  _QWORD handler[4];
  _QWORD *v34;
  IOPMAssertionID AssertionID;
  int v36;
  int valuePtr;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  uint64_t *v41;
  __int16 v42;
  IOPMAssertionID v43;
  __int16 v44;
  _BYTE v45[10];
  __int16 v46;
  int v47;
  void *values[5];
  _OWORD keys[2];
  const __CFString *v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (MEMORY[0x1E0CBB710])
  {
    v2 = *(_QWORD *)(a1 + 32);
    if (*(_DWORD *)(v2 + 132))
    {
      v3 = *(NSObject **)(v2 + 120);
      if (v3 && (*(_BYTE *)(v2 + 136) & 2) != 0)
      {
        dispatch_suspend(v3);
        *(_BYTE *)(*(_QWORD *)(a1 + 32) + 136) &= ~2u;
        v2 = *(_QWORD *)(a1 + 32);
      }
      if (!*(_DWORD *)(v2 + 128))
      {
        v4 = (uint64_t *)(id)v2;
        keys[0] = xmmword_1E14A0BE8;
        keys[1] = *(_OWORD *)off_1E14A0BF8;
        v50 = CFSTR("TimeoutAction");
        v36 = 10800;
        valuePtr = 255;
        v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
        v7 = CFStringCreateWithFormat(v5, 0, CFSTR("%@"), v4);
        v8 = CFNumberCreate(v5, kCFNumberIntType, &v36);
        v9 = v8;
        values[0] = CFSTR("PreventUserIdleSystemSleep");
        values[1] = v6;
        values[2] = (void *)v7;
        values[3] = v8;
        values[4] = CFSTR("TimeoutActionTurnOff");
        if (v6 && v7 && v8)
        {
          v10 = CFDictionaryCreate(v5, (const void **)keys, (const void **)values, 5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        }
        else
        {
          v10 = 0;
          v18 = 0;
          if (!v6)
            goto LABEL_18;
        }
        CFRelease(v6);
        v18 = v10;
LABEL_18:
        if (v7)
          CFRelease(v7);
        if (v9)
          CFRelease(v9);
        if (!v18)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v39 = "nw_socks5_server_create_power_assertion";
            v40 = 2112;
            v41 = v4;
            _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, "%{public}s %@ Failed to create power assertion properties", buf, 0x16u);
          }

          v21 = 0;
          goto LABEL_40;
        }
        AssertionID = 0;
        v19 = IOPMAssertionCreateWithProperties(v18, &AssertionID);
        CFRelease(v18);
        if (v19)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = (id)gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447490;
            v39 = "nw_socks5_server_create_power_assertion";
            v40 = 2112;
            v41 = v4;
            v42 = 1024;
            v43 = v19;
            v44 = 1024;
            *(_DWORD *)v45 = v19 >> 26;
            *(_WORD *)&v45[4] = 1024;
            *(_DWORD *)&v45[6] = (v19 >> 14) & 0xFFF;
            v46 = 1024;
            v47 = v19 & 0x3FFF;
            _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s %@ IOPMAssertionCreateWithProperties failed: %x (system: %d, subsystem: %d, code: %d)", buf, 0x2Eu);
          }

          v21 = 0;
          goto LABEL_40;
        }
        v23 = mach_continuous_time();
        if (v23 <= 1)
          v24 = 1;
        else
          v24 = v23;
        v25 = v4[14];
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v26 = (id)gLogObj;
        v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
        if (v25)
        {
          if (v27)
          {
            v28 = AssertionID;
            v29 = nw_delta_nanos(v4[14], v24);
            v39 = "nw_socks5_server_create_power_assertion";
            v40 = 2112;
            *(_DWORD *)buf = 136446978;
            v41 = v4;
            v42 = 1024;
            v43 = v28;
            v44 = 2048;
            *(_QWORD *)v45 = v29 / 0x3B9ACA00;
            v30 = "%{public}s %@ created power assertion: %u after %llus";
            v31 = v26;
            v32 = 38;
LABEL_38:
            _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
          }
        }
        else if (v27)
        {
          *(_DWORD *)buf = 136446722;
          v39 = "nw_socks5_server_create_power_assertion";
          v40 = 2112;
          v41 = v4;
          v42 = 1024;
          v43 = AssertionID;
          v30 = "%{public}s %@ created power assertion: %u";
          v31 = v26;
          v32 = 28;
          goto LABEL_38;
        }

        v4[14] = v24;
        v21 = AssertionID;
LABEL_40:

        *(_DWORD *)(*(_QWORD *)(a1 + 32) + 128) = v21;
      }
    }
    else if (*(_DWORD *)(v2 + 128))
    {
      v11 = *(NSObject **)(v2 + 120);
      if (v11)
        goto LABEL_14;
      v12 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(v2 + 32));
      v13 = *(_QWORD *)(a1 + 32);
      v14 = *(void **)(v13 + 120);
      *(_QWORD *)(v13 + 120) = v12;

      *(_BYTE *)(*(_QWORD *)(a1 + 32) + 136) &= ~2u;
      v15 = *(_QWORD **)(a1 + 32);
      v16 = v15[15];
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3221225472;
      handler[2] = __nw_socks5_server_handle_busy_changed_block_invoke_2;
      handler[3] = &unk_1E14ACFD0;
      v34 = v15;
      dispatch_source_set_event_handler(v16, handler);

      v2 = *(_QWORD *)(a1 + 32);
      v11 = *(NSObject **)(v2 + 120);
      if (v11)
      {
LABEL_14:
        if ((*(_BYTE *)(v2 + 136) & 2) == 0)
        {
          v17 = dispatch_time(0, 5000000000);
          dispatch_source_set_timer(v11, v17, 0xFFFFFFFFFFFFFFFFLL, 0x989680uLL);
          dispatch_resume(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 120));
          *(_BYTE *)(*(_QWORD *)(a1 + 32) + 136) |= 2u;
        }
      }
    }
  }
}

void __nw_socks5_server_handle_busy_changed_block_invoke_2(uint64_t a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  _QWORD v4[5];

  v1 = *(os_unfair_lock_s **)(a1 + 32);
  v2 = v1 + 6;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __nw_socks5_server_handle_busy_changed_block_invoke_3;
  v4[3] = &unk_1E14ACFD0;
  v3 = v1;
  v4[4] = v3;
  os_unfair_lock_lock(v2);
  __nw_socks5_server_handle_busy_changed_block_invoke_3((uint64_t)v4);
  os_unfair_lock_unlock(v2);

}

void __nw_socks5_server_handle_busy_changed_block_invoke_3(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  IOPMAssertionID v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  int v11;
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 120);
  if (v3 && (*(_BYTE *)(v2 + 136) & 2) != 0)
  {
    dispatch_suspend(v3);
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 136) &= ~2u;
    v2 = *(_QWORD *)(a1 + 32);
  }
  if (!*(_DWORD *)(v2 + 132))
  {
    v4 = *(_DWORD *)(v2 + 128);
    if (v4)
    {
      IOPMAssertionRelease(v4);
      v5 = mach_continuous_time();
      if (v5 <= 1)
        v6 = 1;
      else
        v6 = v5;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(_QWORD *)(a1 + 32);
        v9 = *(_DWORD *)(v8 + 128);
        v10 = nw_delta_nanos(*(_QWORD *)(v8 + 112), v6);
        v12 = "nw_socks5_server_handle_busy_changed_block_invoke_3";
        v13 = 2112;
        v11 = 136446978;
        v14 = v8;
        v15 = 1024;
        v16 = v9;
        v17 = 2048;
        v18 = v10 / 0x3B9ACA00;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %@ released power assertion: %u after %llus", (uint8_t *)&v11, 0x26u);
      }

      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) = v6;
      *(_DWORD *)(*(_QWORD *)(a1 + 32) + 128) = 0;
    }
  }
}

char *nw_shoes_server_create(void *a1, void *a2)
{
  char *v2;
  char *v3;
  NSObject *v4;
  char *v5;
  int v7;
  const char *v8;
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = nw_socks5_server_create(a1, a2);
  v3 = v2;
  if (v2)
  {
    v2[136] |= 1u;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136446466;
      v8 = "nw_shoes_server_create";
      v9 = 2114;
      v10 = v3;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ created", (uint8_t *)&v7, 0x16u);
    }

    v5 = v3;
  }

  return v3;
}

void nw_shoes_server_set_error_handler(void *a1, void *a2)
{
  id v3;
  id v4;
  _QWORD v5[4];
  id v6;

  v3 = a2;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __nw_shoes_server_set_error_handler_block_invoke;
  v5[3] = &unk_1E14A93C8;
  v6 = v3;
  v4 = v3;
  nw_socks5_server_set_error_handler(a1, v5);

}

void __nw_shoes_server_set_error_handler_block_invoke(uint64_t a1, void *a2)
{
  NSObject *v3;
  CFErrorRef v4;
  NSObject *v5;

  v3 = a2;
  v5 = v3;
  if (v3)
    v4 = nw_error_copy_cf_error(v3);
  else
    v4 = 0;
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v4)
    CFRelease(v4);

}

uint64_t nw_shoes_server_fillout_statistics(void *a1, void *a2, unint64_t a3, char a4)
{
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  os_unfair_lock_s *v9;
  uint64_t v10;
  NSObject *v11;
  size_t v12;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  void *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  _BOOL4 v23;
  char v24;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v27;
  os_unfair_lock_s *v28;
  void *v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v15, &type, &v24))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
        v18 = "%{public}s called with null server";
LABEL_39:
        _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      }
LABEL_40:

LABEL_41:
      if (v15)
        free(v15);
      goto LABEL_11;
    }
    if (!v24)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
        v18 = "%{public}s called with null server, backtrace limit exceeded";
        goto LABEL_39;
      }
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    v21 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
        v18 = "%{public}s called with null server, no backtrace";
        goto LABEL_39;
      }
      goto LABEL_40;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v22 = "%{public}s called with null server, dumping backtrace:%{public}s";
LABEL_29:
      _os_log_impl(&dword_182FBE000, v16, v17, v22, buf, 0x16u);
    }
LABEL_30:

    free(backtrace_string);
    goto LABEL_41;
  }
  if (!a2)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v15, &type, &v24))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
        v18 = "%{public}s called with null out_stats";
        goto LABEL_39;
      }
      goto LABEL_40;
    }
    if (!v24)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
        v18 = "%{public}s called with null out_stats, backtrace limit exceeded";
        goto LABEL_39;
      }
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    v23 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
        v18 = "%{public}s called with null out_stats, no backtrace";
        goto LABEL_39;
      }
      goto LABEL_40;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = backtrace_string;
      v22 = "%{public}s called with null out_stats, dumping backtrace:%{public}s";
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  if (a3 != 8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_socks5_server_fillout_statistics";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = a3;
      *(_WORD *)&buf[22] = 2048;
      v27 = 8;
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s Unsupported stats size: %zu, expected %zu", buf, 0x20u);
    }

    if (a3 >= 8)
      v12 = 8;
    else
      v12 = a3;
    bzero(a2, v12);
LABEL_11:
    v10 = 0;
    goto LABEL_12;
  }
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = __nw_socks5_server_fillout_statistics_block_invoke;
  v27 = (uint64_t)&unk_1E14AC250;
  v29 = a2;
  v9 = v7;
  v28 = v9;
  v30 = a4;
  os_unfair_lock_lock(v8 + 6);
  __nw_socks5_server_fillout_statistics_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v8 + 6);

  v10 = 1;
LABEL_12:

  return v10;
}

uint64_t __nw_socks5_server_fillout_statistics_block_invoke(uint64_t result)
{
  **(_QWORD **)(result + 40) = *(_QWORD *)(*(_QWORD *)(result + 32) + 104);
  if (*(_BYTE *)(result + 48))
    *(_QWORD *)(*(_QWORD *)(result + 32) + 104) = 0;
  return result;
}

void sub_1836E893C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31)
{
  void *v31;
  void *v32;

  _Unwind_Resume(a1);
}

void sub_1836E91E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1836EA34C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1836EAC9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_endpoint_fallback_start_fallback_child(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  NWConcrete_nw_endpoint_handler *v2;
  NWConcrete_nw_endpoint_handler *v3;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v5;
  uint64_t v6;
  NWConcrete_nw_endpoint_mode_handler *v7;
  uint64_t v8;
  void *v9;
  _DWORD *v10;
  int v11;
  NWConcrete_nw_endpoint_handler *v12;
  char v13;
  NSObject *v14;
  NWConcrete_nw_endpoint_handler *v15;
  NWConcrete_nw_endpoint_handler *v16;
  char v17;
  const char *v18;
  nw_endpoint_t v19;
  const char *v20;
  char *v21;
  unsigned int *v22;
  unsigned int *v23;
  uint64_t v24;
  const char *v25;
  NSObject *v26;
  const char *v27;
  NWConcrete_nw_endpoint_handler *v28;
  char v29;
  NWConcrete_nw_endpoint_handler *v30;
  NWConcrete_nw_endpoint_handler *v31;
  char v32;
  const char *v33;
  nw_endpoint_t v34;
  const char *logging_description;
  char *id_str;
  unsigned int *v37;
  unsigned int *v38;
  uint64_t v39;
  const char *v40;
  NWConcrete_nw_endpoint_handler *v41;
  char v42;
  NWConcrete_nw_endpoint_handler *v43;
  NWConcrete_nw_endpoint_handler *v44;
  char v45;
  const char *v46;
  nw_endpoint_t v47;
  const char *v48;
  char *v49;
  unsigned int *v50;
  unsigned int *v51;
  uint64_t v52;
  const char *v53;
  char v54;
  NSObject *v55;
  NSObject *v56;
  NSObject *v57;
  int minimize_logging;
  char logging_disabled;
  NSObject *v60;
  const char *id_string;
  const char *v62;
  const char *v63;
  const char *v64;
  const char *v65;
  id v66;
  void **v67;
  void **v68;
  int v69;
  const char *v70;
  NWConcrete_nw_endpoint_handler *v71;
  char v72;
  NSObject *v73;
  const char *v74;
  const char *v75;
  nw_endpoint_t v76;
  const char *v77;
  const char *v78;
  const char *v79;
  id v80;
  void **v81;
  void **v82;
  int v83;
  const char *v84;
  void **v85;
  void **v86;
  int v87;
  const char *v88;
  void **v89;
  id v90;
  void **v91;
  id v92;
  void **v93;
  id v94;
  void *v95;
  char *v96;
  NSObject *v97;
  os_log_type_t v98;
  char *backtrace_string;
  os_log_type_t v100;
  _BOOL4 v101;
  os_log_type_t v102;
  const char *v103;
  const char *v104;
  nw_endpoint_t v105;
  const char *v106;
  const char *v107;
  const char *v108;
  id v109;
  NSObject *v110;
  nw_endpoint_t v111;
  const char *v112;
  const char *v113;
  const char *v114;
  id v115;
  nw_endpoint_t v116;
  const char *v117;
  NSObject *log;
  const char *loga;
  NSObject *v120;
  NSObject *v121;
  NSObject *v122;
  const char *v123;
  os_log_t v124;
  NWConcrete_nw_endpoint_mode_handler *v125;
  NWConcrete_nw_endpoint_mode_handler *v126;
  NWConcrete_nw_endpoint_mode_handler *v127;
  NWConcrete_nw_endpoint_mode_handler *v128;
  NWConcrete_nw_endpoint_mode_handler *v129;
  char v130;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v133;
  __int16 v134;
  void *v135;
  __int16 v136;
  const char *v137;
  __int16 v138;
  const char *v139;
  __int16 v140;
  const char *v141;
  __int16 v142;
  const char *v143;
  __int16 v144;
  id v145;
  uint64_t v146;

  v146 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v95 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v133 = "nw_endpoint_fallback_start_fallback_child";
    v96 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v130 = 0;
    if (__nwlog_fault(v96, &type, &v130))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        v98 = type;
        if (os_log_type_enabled(v97, type))
        {
          *(_DWORD *)buf = 136446210;
          v133 = "nw_endpoint_fallback_start_fallback_child";
          _os_log_impl(&dword_182FBE000, v97, v98, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v130)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        v100 = type;
        v101 = os_log_type_enabled(v97, type);
        if (backtrace_string)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            v133 = "nw_endpoint_fallback_start_fallback_child";
            v134 = 2082;
            v135 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v97, v100, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_111;
        }
        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          v133 = "nw_endpoint_fallback_start_fallback_child";
          _os_log_impl(&dword_182FBE000, v97, v100, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v97 = objc_claimAutoreleasedReturnValue();
        v102 = type;
        if (os_log_type_enabled(v97, type))
        {
          *(_DWORD *)buf = 136446210;
          v133 = "nw_endpoint_fallback_start_fallback_child";
          _os_log_impl(&dword_182FBE000, v97, v102, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_111:
    if (v96)
      free(v96);
    goto LABEL_94;
  }
  v3 = v1;
  mode = v3->mode;

  if ((_DWORD)mode == 4)
  {
    v5 = nw_endpoint_handler_copy_fallback(v3);
    v7 = v5;
    if ((*((_BYTE *)v5 + 108) & 0x40) != 0)
    {
      v28 = v3;
      v29 = *((_BYTE *)v28 + 268);

      if ((v29 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v14 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          v121 = v14;
          v30 = v28;

          v31 = v30;
          v32 = *((_BYTE *)v28 + 268);

          if ((v32 & 1) != 0)
            v33 = "dry-run ";
          else
            v33 = "";
          v126 = v7;
          v34 = nw_endpoint_handler_copy_endpoint(v31);
          logging_description = nw_endpoint_get_logging_description(v34);
          id_str = v30->id_str;
          v37 = v31;
          v38 = v37;
          v39 = v37[30];
          if (v39 > 5)
            v40 = "unknown-state";
          else
            v40 = off_1E149FC48[v39];

          v67 = v38;
          v68 = v67;
          v69 = v3->mode;
          v70 = "path";
          switch(v69)
          {
            case 0:
              break;
            case 1:
              v70 = "resolver";
              break;
            case 2:
              v70 = nw_endpoint_flow_mode_string(v67[31]);
              break;
            case 3:
              v70 = "proxy";
              break;
            case 4:
              v70 = "fallback";
              break;
            case 5:
              v70 = "transform";
              break;
            default:
              v70 = "unknown-mode";
              break;
          }

          v89 = v68;
          os_unfair_lock_lock((os_unfair_lock_t)v89 + 28);
          v90 = v89[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v89 + 28);

          *(_DWORD *)buf = 136447746;
          v133 = "nw_endpoint_fallback_start_fallback_child";
          v134 = 2082;
          v135 = id_str;
          v136 = 2082;
          v137 = v33;
          v138 = 2082;
          v139 = logging_description;
          v140 = 2082;
          v141 = v40;
          v142 = 2082;
          v143 = v70;
          v144 = 2114;
          v145 = v90;
          v14 = v121;
          _os_log_impl(&dword_182FBE000, v121, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Already started fallback, skipping", buf, 0x48u);

          v7 = v126;
        }
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    v8 = *((_QWORD *)v5 + 9);
    if (v8)
    {
      nw_queue_cancel_source(v8, v6);
      *((_QWORD *)v7 + 9) = 0;
    }
    v9 = (void *)*((_QWORD *)v7 + 5);
    if (!v9)
    {
      v41 = v3;
      v42 = *((_BYTE *)v41 + 268);

      if ((v42 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v14 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          v122 = v14;
          v43 = v41;

          v44 = v43;
          v45 = *((_BYTE *)v41 + 268);

          if ((v45 & 1) != 0)
            v46 = "dry-run ";
          else
            v46 = "";
          v127 = v7;
          v47 = nw_endpoint_handler_copy_endpoint(v44);
          v48 = nw_endpoint_get_logging_description(v47);
          v49 = v43->id_str;
          v50 = v44;
          v51 = v50;
          v52 = v50[30];
          if (v52 > 5)
            v53 = "unknown-state";
          else
            v53 = off_1E149FC48[v52];

          v81 = v51;
          v82 = v81;
          v83 = v3->mode;
          v84 = "path";
          switch(v83)
          {
            case 0:
              break;
            case 1:
              v84 = "resolver";
              break;
            case 2:
              v84 = nw_endpoint_flow_mode_string(v81[31]);
              break;
            case 3:
              v84 = "proxy";
              break;
            case 4:
              v84 = "fallback";
              break;
            case 5:
              v84 = "transform";
              break;
            default:
              v84 = "unknown-mode";
              break;
          }

          v91 = v82;
          os_unfair_lock_lock((os_unfair_lock_t)v91 + 28);
          v92 = v91[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v91 + 28);

          *(_DWORD *)buf = 136447746;
          v133 = "nw_endpoint_fallback_start_fallback_child";
          v134 = 2082;
          v135 = v49;
          v136 = 2082;
          v137 = v46;
          v138 = 2082;
          v139 = v48;
          v140 = 2082;
          v141 = v53;
          v142 = 2082;
          v143 = v84;
          v144 = 2114;
          v145 = v92;
          v14 = v122;
          _os_log_impl(&dword_182FBE000, v122, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No fallback child found", buf, 0x48u);

          v7 = v127;
        }
        goto LABEL_92;
      }
      goto LABEL_93;
    }
    v10 = v9;
    v11 = v10[30];

    if (v11 == 5)
    {
      v12 = v3;
      v13 = *((_BYTE *)v12 + 268);

      if ((v13 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v14 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          v120 = v14;
          v15 = v12;

          v16 = v15;
          v17 = *((_BYTE *)v12 + 268);

          if ((v17 & 1) != 0)
            v18 = "dry-run ";
          else
            v18 = "";
          v125 = v7;
          v19 = nw_endpoint_handler_copy_endpoint(v16);
          v20 = nw_endpoint_get_logging_description(v19);
          v21 = v15->id_str;
          v22 = v16;
          v23 = v22;
          v24 = v22[30];
          if (v24 > 5)
            v25 = "unknown-state";
          else
            v25 = off_1E149FC48[v24];

          v85 = v23;
          v86 = v85;
          v87 = v3->mode;
          v88 = "path";
          switch(v87)
          {
            case 0:
              break;
            case 1:
              v88 = "resolver";
              break;
            case 2:
              v88 = nw_endpoint_flow_mode_string(v85[31]);
              break;
            case 3:
              v88 = "proxy";
              break;
            case 4:
              v88 = "fallback";
              break;
            case 5:
              v88 = "transform";
              break;
            default:
              v88 = "unknown-mode";
              break;
          }

          v93 = v86;
          os_unfair_lock_lock((os_unfair_lock_t)v93 + 28);
          v94 = v93[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v93 + 28);

          *(_DWORD *)buf = 136447746;
          v133 = "nw_endpoint_fallback_start_fallback_child";
          v134 = 2082;
          v135 = v21;
          v136 = 2082;
          v137 = v18;
          v138 = 2082;
          v139 = v20;
          v140 = 2082;
          v141 = v25;
          v142 = 2082;
          v143 = v88;
          v144 = 2114;
          v145 = v94;
          v14 = v120;
          _os_log_impl(&dword_182FBE000, v120, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fallback child already cancelled", buf, 0x48u);

          v7 = v125;
        }
        goto LABEL_92;
      }
LABEL_93:

      goto LABEL_94;
    }
    if (*((_DWORD *)v7 + 26))
    {
      v54 = *((_BYTE *)v7 + 108);
      if ((v54 & 0x20) != 0)
      {
        v55 = nw_endpoint_handler_copy_current_path(*((void **)v7 + 4));
        v14 = v55;
        if (v55)
        {
          v56 = v55[12].isa;
          v57 = v56;
          if (v56 && nw_interface_get_type(v56) == nw_interface_type_cellular)
          {
            minimize_logging = nw_endpoint_handler_get_minimize_logging(v3);
            logging_disabled = nw_endpoint_handler_get_logging_disabled(v3);
            if (minimize_logging)
            {
              if ((logging_disabled & 1) != 0)
                goto LABEL_53;
              v124 = v14;
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v110 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
              {
                loga = nw_endpoint_handler_get_id_string(v3);
                v117 = nw_endpoint_handler_dry_run_string(v3);
                v111 = nw_endpoint_handler_copy_endpoint(v3);
                v112 = nw_endpoint_get_logging_description(v111);
                v113 = nw_endpoint_handler_state_string(v3);
                v114 = nw_endpoint_handler_mode_string(v3);
                v115 = nw_endpoint_handler_copy_current_path(v3);
                *(_DWORD *)buf = 136447746;
                v133 = "nw_endpoint_fallback_start_fallback_child";
                v134 = 2082;
                v135 = (void *)loga;
                v136 = 2082;
                v137 = v117;
                v138 = 2082;
                v139 = v112;
                v140 = 2082;
                v141 = v113;
                v142 = 2082;
                v143 = v114;
                v144 = 2114;
                v145 = v115;
                v60 = v110;
                _os_log_impl(&dword_182FBE000, v110, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, because the primary child already uses cellular", buf, 0x48u);

                v14 = v124;
              }
              else
              {
                v60 = v110;
              }
            }
            else
            {
              if ((logging_disabled & 1) != 0)
              {
LABEL_53:
                nw_endpoint_handler_cancel(*((void **)v7 + 5), 0, 1);

LABEL_92:
                goto LABEL_93;
              }
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v60 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v60, OS_LOG_TYPE_INFO))
              {
                id_string = nw_endpoint_handler_get_id_string(v3);
                log = v60;
                v123 = nw_endpoint_handler_dry_run_string(v3);
                v62 = id_string;
                v116 = nw_endpoint_handler_copy_endpoint(v3);
                v63 = nw_endpoint_get_logging_description(v116);
                v64 = nw_endpoint_handler_state_string(v3);
                v65 = nw_endpoint_handler_mode_string(v3);
                v66 = nw_endpoint_handler_copy_current_path(v3);
                *(_DWORD *)buf = 136447746;
                v133 = "nw_endpoint_fallback_start_fallback_child";
                v134 = 2082;
                v135 = (void *)v62;
                v136 = 2082;
                v137 = v123;
                v138 = 2082;
                v139 = v63;
                v140 = 2082;
                v141 = v64;
                v142 = 2082;
                v143 = v65;
                v144 = 2114;
                v145 = v66;
                v60 = log;
                _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, because the primary child already uses cellular", buf, 0x48u);

              }
            }

            goto LABEL_53;
          }
        }
        else
        {
          v57 = 0;
        }

        v54 = *((_BYTE *)v7 + 108);
      }
      *((_BYTE *)v7 + 108) = v54 | 0x40;
      v3->event = (nw_endpoint_handler_event_s)131077;
      nw_endpoint_handler_report(v3, 0, &v3->event.domain, 0);
      nw_endpoint_handler_start(*((void **)v7 + 5));
      goto LABEL_93;
    }
    if (nw_endpoint_handler_get_minimize_logging(v3))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v3) & 1) != 0)
        goto LABEL_64;
      v129 = v7;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v73 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
      {
        v103 = nw_endpoint_handler_get_id_string(v3);
        v104 = nw_endpoint_handler_dry_run_string(v3);
        v105 = nw_endpoint_handler_copy_endpoint(v3);
        v106 = nw_endpoint_get_logging_description(v105);
        v107 = nw_endpoint_handler_state_string(v3);
        v108 = nw_endpoint_handler_mode_string(v3);
        v109 = nw_endpoint_handler_copy_current_path(v3);
        *(_DWORD *)buf = 136447746;
        v133 = "nw_endpoint_fallback_start_fallback_child";
        v134 = 2082;
        v135 = (void *)v103;
        v136 = 2082;
        v137 = v104;
        v138 = 2082;
        v139 = v106;
        v140 = 2082;
        v141 = v107;
        v142 = 2082;
        v143 = v108;
        v144 = 2114;
        v145 = v109;
        _os_log_impl(&dword_182FBE000, v73, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, disposition is set to no", buf, 0x48u);

        v7 = v129;
      }
    }
    else
    {
      v71 = v3;
      v72 = *((_BYTE *)v71 + 268);

      if ((v72 & 0x20) != 0)
      {
LABEL_64:
        nw_endpoint_handler_cancel(*((void **)v7 + 5), 0, 1);
        goto LABEL_93;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v73 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v73, OS_LOG_TYPE_INFO))
      {
        v74 = nw_endpoint_handler_get_id_string(v71);
        v75 = nw_endpoint_handler_dry_run_string(v71);
        v128 = v7;
        v76 = nw_endpoint_handler_copy_endpoint(v71);
        v77 = nw_endpoint_get_logging_description(v76);
        v78 = nw_endpoint_handler_state_string(v71);
        v79 = nw_endpoint_handler_mode_string(v71);
        v80 = nw_endpoint_handler_copy_current_path(v71);
        *(_DWORD *)buf = 136447746;
        v133 = "nw_endpoint_fallback_start_fallback_child";
        v134 = 2082;
        v135 = (void *)v74;
        v136 = 2082;
        v137 = v75;
        v138 = 2082;
        v139 = v77;
        v140 = 2082;
        v141 = v78;
        v142 = 2082;
        v143 = v79;
        v144 = 2114;
        v145 = v80;
        _os_log_impl(&dword_182FBE000, v73, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Not starting fallback child, disposition is set to no", buf, 0x48u);

        v7 = v128;
      }
    }

    goto LABEL_64;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v26 = (id)gLogObj;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5)
      v27 = "unknown-mode";
    else
      v27 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v133 = "nw_endpoint_fallback_start_fallback_child";
    v134 = 2082;
    v135 = (void *)v27;
    v136 = 2082;
    v137 = "fallback";
    _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_94:
}

void sub_1836EBC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_fallback_receive_report(void *a1, uint64_t a2, int a3, _WORD *a4, void *a5, void *a6)
{
  NSObject *v10;
  id v11;
  NWConcrete_nw_endpoint_handler *v12;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  int v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  NWConcrete_nw_endpoint_handler *v26;
  char v27;
  uint64_t v28;
  NSObject *v29;
  NWConcrete_nw_endpoint_handler *v30;
  NWConcrete_nw_endpoint_handler *v31;
  char v32;
  const char *v33;
  unsigned int *v34;
  unsigned int *v35;
  uint64_t v36;
  const char *v37;
  NWConcrete_nw_endpoint_handler *v38;
  char v39;
  NWConcrete_nw_endpoint_handler *v40;
  NWConcrete_nw_endpoint_handler *v41;
  char v42;
  const char *v43;
  unsigned int *v44;
  unsigned int *v45;
  uint64_t v46;
  const char *v47;
  void **v48;
  void **v49;
  int v50;
  const char *v51;
  void **v52;
  void **v53;
  int v54;
  const char *v55;
  void **v56;
  id v57;
  id v58;
  const char *id_string;
  const char *v60;
  nw_endpoint_t v61;
  const char *v62;
  char *id_str;
  const char *v64;
  const char *v65;
  id v66;
  void **v67;
  id v68;
  id v69;
  const char *v70;
  const char *v71;
  nw_endpoint_t v72;
  const char *v73;
  char *v74;
  const char *v75;
  const char *v76;
  id v77;
  _BYTE *v78;
  char v79;
  char v80;
  int v81;
  _DWORD *v82;
  _BOOL4 v83;
  char v84;
  int v85;
  uint64_t v86;
  NWConcrete_nw_endpoint_handler *v87;
  NWConcrete_nw_endpoint_handler *v88;
  uint64_t v89;
  int no_fullstack_fallback;
  _BOOL4 v91;
  _BOOL4 v92;
  char v93;
  NSObject *v94;
  int isa;
  uint64_t v96;
  void *v97;
  int v98;
  char v99;
  NSObject *v100;
  const char *v101;
  const char *v102;
  nw_endpoint_t v103;
  const char *v104;
  const char *v105;
  const char *v106;
  id v107;
  unint64_t v108;
  uint64_t v109;
  dispatch_time_t v110;
  void *v111;
  NWConcrete_nw_endpoint_handler *v112;
  _BOOL4 v113;
  NSObject *v114;
  const char *v115;
  const char *v116;
  nw_endpoint_t v117;
  const char *v118;
  const char *v119;
  const char *v120;
  id v121;
  void *v122;
  unint64_t v123;
  const char *v124;
  const char *v125;
  NWConcrete_nw_endpoint_handler *v126;
  char v127;
  nw_endpoint_handler_event_s *p_event;
  NWConcrete_nw_endpoint_handler *v129;
  NWConcrete_nw_path *v130;
  BOOL v131;
  char v132;
  NSObject *v133;
  const char *v134;
  const char *v135;
  nw_endpoint_t v136;
  const char *v137;
  const char *v138;
  const char *v139;
  id v140;
  NSObject *v141;
  const char *v142;
  const char *v143;
  nw_endpoint_t v144;
  const char *v145;
  const char *v146;
  const char *v147;
  id v148;
  const char *v149;
  const char *v150;
  nw_endpoint_t v151;
  const char *v152;
  const char *v153;
  const char *v154;
  id v155;
  int minimize_logging;
  char logging_disabled;
  NSObject *v158;
  const char *v159;
  const char *v160;
  nw_endpoint_t v161;
  const char *v162;
  const char *v163;
  const char *v164;
  id v165;
  NWConcrete_nw_endpoint_handler *v166;
  _BOOL4 v167;
  NSObject *v168;
  const char *v169;
  const char *v170;
  nw_endpoint_t v171;
  const char *v172;
  const char *v173;
  const char *v174;
  id v175;
  __int16 v176;
  const char *v177;
  const char *v178;
  nw_endpoint_t v179;
  const char *v180;
  const char *v181;
  const char *v182;
  id v183;
  void *v185;
  char *v186;
  NSObject *v187;
  os_log_type_t v188;
  char *backtrace_string;
  NSObject *v190;
  os_log_type_t v191;
  _BOOL4 v192;
  os_log_type_t v193;
  NSObject *v194;
  const char *v195;
  id v196;
  const char *v197;
  nw_endpoint_t v198;
  const char *v199;
  const char *v200;
  const char *v201;
  id v202;
  id v203;
  const char *v204;
  const char *v205;
  nw_endpoint_t v206;
  const char *v207;
  const char *v208;
  const char *v209;
  id v210;
  const char *v211;
  const char *v212;
  nw_endpoint_t v213;
  const char *v214;
  const char *v215;
  const char *v216;
  id v217;
  const char *v218;
  nw_endpoint_t v219;
  const char *v220;
  const char *v221;
  const char *v222;
  id v223;
  void *v224;
  unint64_t v225;
  const char *v226;
  const char *v227;
  const char *v228;
  const char *v229;
  nw_endpoint_t v230;
  const char *v231;
  const char *v232;
  const char *v233;
  id v234;
  unint64_t v235;
  const char *v236;
  const char *v237;
  nw_endpoint_t v238;
  const char *v239;
  const char *v240;
  const char *v241;
  id v242;
  const char *v243;
  const char *v244;
  const char *v245;
  const char *v246;
  const char *v247;
  const char *v248;
  const char *v249;
  const char *v250;
  const char *logging_description;
  const char *v252;
  const char *v253;
  const char *v254;
  nw_endpoint_t v255;
  nw_endpoint_t v256;
  const char *v257;
  const char *v258;
  os_log_t v259;
  os_log_t v260;
  NSObject *v261;
  const char *v262;
  const char *v263;
  const char *v264;
  NSObject *log;
  NSObject *loga;
  os_log_t logb;
  os_log_t logc;
  os_log_t logd;
  _WORD *v270;
  _WORD *v271;
  _WORD *v272;
  _WORD *v273;
  _WORD *v274;
  int v275;
  NWConcrete_nw_endpoint_handler *v276;
  NSObject *v277;
  NSObject *v278;
  NWConcrete_nw_endpoint_mode_handler *v279;
  NSObject *v280;
  id v281;
  void *v282;
  char v283;
  __int128 type;
  uint8_t buf[4];
  const char *v286;
  __int16 v287;
  void *v288;
  __int16 v289;
  const char *v290;
  __int16 v291;
  const char *v292;
  __int16 v293;
  const char *v294;
  __int16 v295;
  const char *v296;
  __int16 v297;
  id v298;
  __int16 v299;
  unint64_t v300;
  __int16 v301;
  const char *v302;
  __int16 v303;
  const char *v304;
  __int16 v305;
  const char *v306;
  __int16 v307;
  const char *v308;
  __int16 v309;
  id v310;
  uint64_t v311;

  v311 = *MEMORY[0x1E0C80C00];
  v10 = a1;
  v281 = a5;
  v11 = a6;
  v280 = v10;
  v282 = v11;
  if (!v11)
  {
    __nwlog_obj();
    v185 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v286 = "nw_endpoint_fallback_receive_report";
    v186 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(type) = 16;
    v283 = 0;
    if (__nwlog_fault(v186, &type, &v283))
    {
      if (type == 17)
      {
        __nwlog_obj();
        v187 = objc_claimAutoreleasedReturnValue();
        v188 = type;
        if (os_log_type_enabled(v187, (os_log_type_t)type))
        {
          *(_DWORD *)buf = 136446210;
          v286 = "nw_endpoint_fallback_receive_report";
          _os_log_impl(&dword_182FBE000, v187, v188, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else
      {
        if (v283)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v190 = objc_claimAutoreleasedReturnValue();
          v191 = type;
          v192 = os_log_type_enabled(v190, (os_log_type_t)type);
          if (backtrace_string)
          {
            if (v192)
            {
              *(_DWORD *)buf = 136446466;
              v286 = "nw_endpoint_fallback_receive_report";
              v287 = 2082;
              v288 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v190, v191, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v192)
            {
              *(_DWORD *)buf = 136446210;
              v286 = "nw_endpoint_fallback_receive_report";
              _os_log_impl(&dword_182FBE000, v190, v191, "%{public}s called with null handler, no backtrace", buf, 0xCu);
            }

          }
          goto LABEL_214;
        }
        __nwlog_obj();
        v187 = objc_claimAutoreleasedReturnValue();
        v193 = type;
        if (os_log_type_enabled(v187, (os_log_type_t)type))
        {
          *(_DWORD *)buf = 136446210;
          v286 = "nw_endpoint_fallback_receive_report";
          _os_log_impl(&dword_182FBE000, v187, v193, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_214:
    if (v186)
      free(v186);
    goto LABEL_28;
  }
  v12 = (NWConcrete_nw_endpoint_handler *)v11;
  mode = v12->mode;

  if ((_DWORD)mode == 4)
  {
    v276 = v12;
    nw_endpoint_handler_report(v12, v10, a4, v281);
    v14 = nw_endpoint_handler_copy_fallback(v12);
    if ((*((_BYTE *)v14 + 108) & 0x40) == 0 && (a3 & 0xFFFFFFFE) == 4)
    {
      if (v281)
      {
        v15 = v281;
        v16 = v15[2];

        if (v16 == 1)
        {
          v17 = v15;
          v18 = v17[3];

          if (v18 == 89)
            *((_BYTE *)v14 + 108) |= 1u;
        }
      }
    }
    v20 = *((_QWORD *)v14 + 4);
    v19 = *((_QWORD *)v14 + 5);
    v279 = v14;
    if (v20 == v10)
    {
      v25 = v19;
      v277 = v25;
      v275 = a3;
      if (!nw_endpoint_handler_get_minimize_logging(v12))
      {
        v26 = v12;
        v27 = *((_BYTE *)v26 + 268);

        if ((v27 & 0x20) != 0)
          goto LABEL_59;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v29 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          log = v29;
          v30 = v26;

          v31 = v30;
          v32 = *((_BYTE *)v26 + 268);

          if ((v32 & 1) != 0)
            v33 = "dry-run ";
          else
            v33 = "";
          v255 = nw_endpoint_handler_copy_endpoint(v31);
          logging_description = nw_endpoint_get_logging_description(v255);
          v34 = v31;
          v35 = v34;
          v36 = v34[30];
          if (v36 > 5)
            v37 = "unknown-state";
          else
            v37 = off_1E149FC48[v36];
          v243 = v37;

          v48 = v35;
          v49 = v48;
          v50 = v12->mode;
          v270 = a4;
          v247 = v33;
          v51 = "path";
          switch(v50)
          {
            case 0:
              break;
            case 1:
              v51 = "resolver";
              break;
            case 2:
              v51 = nw_endpoint_flow_mode_string(v48[31]);
              break;
            case 3:
              v51 = "proxy";
              break;
            case 4:
              v51 = "fallback";
              break;
            case 5:
              v51 = "transform";
              break;
            default:
              v51 = "unknown-mode";
              break;
          }

          v56 = v49;
          os_unfair_lock_lock((os_unfair_lock_t)v56 + 28);
          v57 = v56[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v56 + 28);

          v58 = v57;
          id_string = nw_endpoint_handler_get_id_string(v10);
          v60 = nw_endpoint_handler_dry_run_string(v10);
          v61 = nw_endpoint_handler_copy_endpoint(v10);
          v259 = v20;
          v62 = nw_endpoint_get_logging_description(v61);
          id_str = v30->id_str;
          v64 = nw_endpoint_handler_state_string(v10);
          v65 = nw_endpoint_handler_mode_string(v280);
          v66 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = id_str;
          v289 = 2082;
          v290 = v247;
          v291 = 2082;
          v292 = logging_description;
          v293 = 2082;
          v294 = v243;
          v295 = 2082;
          v296 = v51;
          v297 = 2114;
          v298 = v58;
          v299 = 2082;
          v300 = (unint64_t)id_string;
          v301 = 2082;
          v302 = v60;
          v303 = 2082;
          v304 = v62;
          v305 = 2082;
          v306 = v64;
          v307 = 2082;
          v308 = v65;
          v309 = 2114;
          v310 = v66;
          v29 = log;
          _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received primary child report:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

          v20 = v259;
          a4 = v270;

        }
        goto LABEL_57;
      }
      v273 = a4;
      if ((nw_endpoint_handler_get_logging_disabled(v12) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v194 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
        {
          v195 = nw_endpoint_handler_get_id_string(v12);
          v262 = nw_endpoint_handler_dry_run_string(v12);
          logc = nw_endpoint_handler_copy_endpoint(v12);
          v257 = nw_endpoint_get_logging_description(logc);
          v253 = nw_endpoint_handler_state_string(v12);
          v249 = nw_endpoint_handler_mode_string(v12);
          v196 = nw_endpoint_handler_copy_current_path(v12);
          v245 = nw_endpoint_handler_get_id_string(v280);
          v197 = nw_endpoint_handler_dry_run_string(v280);
          v198 = nw_endpoint_handler_copy_endpoint(v280);
          v199 = nw_endpoint_get_logging_description(v198);
          v200 = nw_endpoint_handler_state_string(v280);
          v201 = nw_endpoint_handler_mode_string(v280);
          v202 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = (void *)v195;
          v289 = 2082;
          v290 = v262;
          v291 = 2082;
          v292 = v257;
          v293 = 2082;
          v294 = v253;
          v295 = 2082;
          v296 = v249;
          v297 = 2114;
          v298 = v196;
          v299 = 2082;
          v300 = (unint64_t)v245;
          v301 = 2082;
          v302 = v197;
          v303 = 2082;
          v304 = v199;
          v305 = 2082;
          v306 = v200;
          v307 = 2082;
          v308 = v201;
          v309 = 2114;
          v310 = v202;
          v29 = v194;
          _os_log_impl(&dword_182FBE000, v194, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received primary child report:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

          a4 = v273;
LABEL_57:

          v10 = v280;
          v25 = v277;
          v14 = v279;
          v12 = v276;
LABEL_58:
          a3 = v275;
LABEL_59:
          v278 = v25;
          if (a3 < 2)
          {
            if (a3 != 1)
              goto LABEL_71;
            if (v20 != v10)
            {
              v78 = (char *)v14 + 109;
              v79 = *((_BYTE *)v14 + 109);
              if ((v79 & 1) == 0)
                goto LABEL_63;
              v80 = 4;
LABEL_62:
              *v78 = v79 & 0xFA | v80;
LABEL_63:
              v82 = (_DWORD *)((char *)v14 + 48);
              v81 = *((_DWORD *)v14 + 12);
              v83 = 1;
              goto LABEL_73;
            }
            v85 = *((char *)v14 + 108);
            if ((v85 & 0x80000000) == 0)
            {
LABEL_71:
              v82 = (_DWORD *)((char *)v14 + 48);
              v81 = *((_DWORD *)v14 + 12);
              v83 = v20 != v10;
              if (v20 == v10 && v81 == 1)
                goto LABEL_75;
LABEL_73:
              if (v20 != v10 && v81 == 2)
              {
LABEL_75:
                if ((a3 - 3) <= 1)
                {
                  v86 = *((_QWORD *)v14 + 10);
                  if (v86)
                  {
                    nw_queue_cancel_source(v86, v28);
                    *((_QWORD *)v279 + 10) = 0;
                    v12 = v276;
                  }
                }
                v87 = v12;
                v87->state = a3;

                nw_endpoint_handler_report(v87, 0, a4, 0);
                goto LABEL_190;
              }
              v88 = v12;
              logb = v88->parameters;

              if (networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_no_fallback_full_stack))
              {
                no_fullstack_fallback = 1;
                if (a3 != 2)
                  goto LABEL_85;
              }
              else
              {
                no_fullstack_fallback = nw_parameters_get_no_fullstack_fallback(logb);
                if (a3 != 2)
                  goto LABEL_85;
              }
              if (*a4 == 3)
              {
                v91 = a4[1] == 5;
                goto LABEL_86;
              }
LABEL_85:
              v91 = 0;
LABEL_86:
              v92 = a3 == 3;
              if (no_fullstack_fallback)
                v92 = v91;
              if (a3 != 3 && !v92)
              {
                if (a3 == 4
                  || (v20 != v280 ? (v93 = 4) : (v93 = 2), (*((_BYTE *)v279 + 109) & v93) != 0))
                {
                  if (!v25)
                    goto LABEL_170;
                  v94 = v25;
                  isa = (int)v94[15].isa;

                  if ((isa & 0xFFFFFFFE) == 4)
                    goto LABEL_170;
                  if (v20 != v280)
                  {
                    if ((*((_BYTE *)v279 + 109) & 2) == 0)
                    {
LABEL_178:
                      v176 = 4;
LABEL_188:
                      v88->event.domain = 5;
                      v88->event.event = v176;
                      nw_endpoint_handler_report(v88, 0, &v88->event.domain, 0);
                      goto LABEL_189;
                    }
LABEL_170:
                    if (nw_endpoint_handler_get_minimize_logging(v88))
                    {
                      if ((nw_endpoint_handler_get_logging_disabled(v88) & 1) != 0)
                      {
LABEL_177:
                        nw_endpoint_handler_handle_failure(v88);
                        if (v20 != v280)
                          goto LABEL_178;
LABEL_187:
                        v176 = 3;
                        goto LABEL_188;
                      }
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v168 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
                      {
                        v211 = nw_endpoint_handler_get_id_string(v88);
                        v212 = nw_endpoint_handler_dry_run_string(v88);
                        v213 = nw_endpoint_handler_copy_endpoint(v88);
                        v214 = nw_endpoint_get_logging_description(v213);
                        v215 = nw_endpoint_handler_state_string(v88);
                        v216 = nw_endpoint_handler_mode_string(v88);
                        v217 = nw_endpoint_handler_copy_current_path(v88);
                        *(_DWORD *)buf = 136447746;
                        v286 = "nw_endpoint_fallback_receive_report";
                        v287 = 2082;
                        v288 = (void *)v211;
                        v289 = 2082;
                        v290 = v212;
                        v291 = 2082;
                        v292 = v214;
                        v293 = 2082;
                        v294 = v215;
                        v295 = 2082;
                        v296 = v216;
                        v297 = 2114;
                        v298 = v217;
                        _os_log_impl(&dword_182FBE000, v168, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed", buf, 0x48u);

                      }
                    }
                    else
                    {
                      v166 = v88;
                      v167 = (*((_BYTE *)v166 + 268) & 0x20) == 0;

                      if (!v167)
                        goto LABEL_177;
                      if (__nwlog_connection_log::onceToken != -1)
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                      v168 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v168, OS_LOG_TYPE_INFO))
                      {
                        v169 = nw_endpoint_handler_get_id_string(v166);
                        v170 = nw_endpoint_handler_dry_run_string(v166);
                        v171 = nw_endpoint_handler_copy_endpoint(v166);
                        v172 = nw_endpoint_get_logging_description(v171);
                        v173 = nw_endpoint_handler_state_string(v166);
                        v174 = nw_endpoint_handler_mode_string(v166);
                        v175 = nw_endpoint_handler_copy_current_path(v166);
                        *(_DWORD *)buf = 136447746;
                        v286 = "nw_endpoint_fallback_receive_report";
                        v287 = 2082;
                        v288 = (void *)v169;
                        v289 = 2082;
                        v290 = v170;
                        v291 = 2082;
                        v292 = v172;
                        v293 = 2082;
                        v294 = v173;
                        v295 = 2082;
                        v296 = v174;
                        v297 = 2114;
                        v298 = v175;
                        _os_log_impl(&dword_182FBE000, v168, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed", buf, 0x48u);

                      }
                    }

                    goto LABEL_177;
                  }
                  if ((*((_BYTE *)v279 + 109) & 4) != 0)
                    goto LABEL_170;
                  if ((*((_BYTE *)v279 + 108) & 1) == 0 || !*((_QWORD *)v279 + 5))
                  {
                    nw_endpoint_fallback_start_fallback_child(v88);
                    goto LABEL_187;
                  }
                  minimize_logging = nw_endpoint_handler_get_minimize_logging(v88);
                  logging_disabled = nw_endpoint_handler_get_logging_disabled(v88);
                  if (minimize_logging)
                  {
                    if ((logging_disabled & 1) != 0)
                      goto LABEL_169;
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v158 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v158, OS_LOG_TYPE_DEBUG))
                    {
                      v236 = nw_endpoint_handler_get_id_string(v88);
                      v237 = nw_endpoint_handler_dry_run_string(v88);
                      v238 = nw_endpoint_handler_copy_endpoint(v88);
                      v239 = nw_endpoint_get_logging_description(v238);
                      v240 = nw_endpoint_handler_state_string(v88);
                      v241 = nw_endpoint_handler_mode_string(v88);
                      v242 = nw_endpoint_handler_copy_current_path(v88);
                      *(_DWORD *)buf = 136447746;
                      v286 = "nw_endpoint_fallback_receive_report";
                      v287 = 2082;
                      v288 = (void *)v236;
                      v289 = 2082;
                      v290 = v237;
                      v291 = 2082;
                      v292 = v239;
                      v293 = 2082;
                      v294 = v240;
                      v295 = 2082;
                      v296 = v241;
                      v297 = 2114;
                      v298 = v242;
                      _os_log_impl(&dword_182FBE000, v158, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received ECANCELED from primary child, cancelling race", buf, 0x48u);

                    }
                  }
                  else
                  {
                    if ((logging_disabled & 1) != 0)
                    {
LABEL_169:
                      nw_endpoint_handler_cancel(*((void **)v279 + 5), 0, 1);
                      goto LABEL_187;
                    }
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v158 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v158, OS_LOG_TYPE_INFO))
                    {
                      v159 = nw_endpoint_handler_get_id_string(v88);
                      v160 = nw_endpoint_handler_dry_run_string(v88);
                      v161 = nw_endpoint_handler_copy_endpoint(v88);
                      v162 = nw_endpoint_get_logging_description(v161);
                      v163 = nw_endpoint_handler_state_string(v88);
                      v164 = nw_endpoint_handler_mode_string(v88);
                      v165 = nw_endpoint_handler_copy_current_path(v88);
                      *(_DWORD *)buf = 136447746;
                      v286 = "nw_endpoint_fallback_receive_report";
                      v287 = 2082;
                      v288 = (void *)v159;
                      v289 = 2082;
                      v290 = v160;
                      v291 = 2082;
                      v292 = v162;
                      v293 = 2082;
                      v294 = v163;
                      v295 = 2082;
                      v296 = v164;
                      v297 = 2114;
                      v298 = v165;
                      _os_log_impl(&dword_182FBE000, v158, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received ECANCELED from primary child, cancelling race", buf, 0x48u);

                    }
                  }

                  goto LABEL_169;
                }
                if (v83 || !v91 || (*((_BYTE *)v279 + 108) & 0x42) != 2 || !*((_QWORD *)v279 + 9))
                  goto LABEL_189;
                v98 = nw_endpoint_handler_get_minimize_logging(v88);
                v99 = nw_endpoint_handler_get_logging_disabled(v88);
                if (v98)
                {
                  if ((v99 & 1) != 0)
                    goto LABEL_119;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v100 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
                  {
                    v228 = nw_endpoint_handler_get_id_string(v88);
                    v229 = nw_endpoint_handler_dry_run_string(v88);
                    v230 = nw_endpoint_handler_copy_endpoint(v88);
                    v231 = nw_endpoint_get_logging_description(v230);
                    v232 = nw_endpoint_handler_state_string(v88);
                    v233 = nw_endpoint_handler_mode_string(v88);
                    v234 = nw_endpoint_handler_copy_current_path(v88);
                    v235 = *((_QWORD *)v279 + 3) / 0xF4240uLL;
                    *(_DWORD *)buf = 136448002;
                    v286 = "nw_endpoint_fallback_receive_report";
                    v287 = 2082;
                    v288 = (void *)v228;
                    v289 = 2082;
                    v290 = v229;
                    v291 = 2082;
                    v292 = v231;
                    v293 = 2082;
                    v294 = v232;
                    v295 = 2082;
                    v296 = v233;
                    v297 = 2114;
                    v298 = v234;
                    v299 = 2048;
                    v300 = v235;
                    _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] pushing out fallback endpoint start by %llums", buf, 0x52u);

                  }
                }
                else
                {
                  if ((v99 & 1) != 0)
                  {
LABEL_119:
                    v109 = *((_QWORD *)v279 + 9);
                    v110 = dispatch_time(0x8000000000000000, *((_QWORD *)v279 + 3));
                    nw_queue_set_timer_values(v109, v110, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
LABEL_189:

LABEL_190:
                    v22 = 1;
                    v21 = v278;
                    goto LABEL_191;
                  }
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v100 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_INFO))
                  {
                    v101 = nw_endpoint_handler_get_id_string(v88);
                    v102 = nw_endpoint_handler_dry_run_string(v88);
                    v103 = nw_endpoint_handler_copy_endpoint(v88);
                    v104 = nw_endpoint_get_logging_description(v103);
                    v105 = nw_endpoint_handler_state_string(v88);
                    v106 = nw_endpoint_handler_mode_string(v88);
                    v107 = nw_endpoint_handler_copy_current_path(v88);
                    v108 = *((_QWORD *)v279 + 3) / 0xF4240uLL;
                    *(_DWORD *)buf = 136448002;
                    v286 = "nw_endpoint_fallback_receive_report";
                    v287 = 2082;
                    v288 = (void *)v101;
                    v289 = 2082;
                    v290 = v102;
                    v291 = 2082;
                    v292 = v104;
                    v293 = 2082;
                    v294 = v105;
                    v295 = 2082;
                    v296 = v106;
                    v297 = 2114;
                    v298 = v107;
                    v299 = 2048;
                    v300 = v108;
                    _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] pushing out fallback endpoint start by %llums", buf, 0x52u);

                  }
                }

                goto LABEL_119;
              }
              v96 = *((_QWORD *)v279 + 9);
              if (v96)
              {
                nw_queue_cancel_source(v96, v89);
                *((_QWORD *)v279 + 9) = 0;
              }
              if (!*v82)
              {
                if (v20 == v280)
                {
                  *((_DWORD *)v279 + 12) = 1;
                  v111 = (void *)*((_QWORD *)v279 + 5);
                  if (v111)
                    nw_endpoint_handler_cancel(v111, 0, 0);
                  if (a3 == 2)
                    nw_endpoint_fallback_start_post_transport_timer(v88);
                }
                else
                {
                  *((_DWORD *)v279 + 12) = 2;
                  v97 = (void *)*((_QWORD *)v279 + 4);
                  if (v97)
                    nw_endpoint_handler_cancel(v97, 0, 0);
                  if (*((_DWORD *)v279 + 26) == 2)
                    nw_endpoint_fallback_start_usage_cap_timer(v88);
                }
                if (!nw_endpoint_handler_get_minimize_logging(v88))
                {
                  v112 = v88;
                  v113 = (*((_BYTE *)v112 + 268) & 0x20) == 0;

                  if (!v113)
                    goto LABEL_134;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v114 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v114, OS_LOG_TYPE_INFO))
                  {
                    v261 = v114;
                    v272 = a4;
                    v115 = nw_endpoint_handler_get_id_string(v112);
                    v116 = nw_endpoint_handler_dry_run_string(v112);
                    v117 = nw_endpoint_handler_copy_endpoint(v112);
                    v118 = nw_endpoint_get_logging_description(v117);
                    v119 = nw_endpoint_handler_state_string(v112);
                    v120 = nw_endpoint_handler_mode_string(v112);
                    v121 = nw_endpoint_handler_copy_current_path(v112);
                    v122 = v121;
                    v123 = *((_QWORD *)v279 + 7);
                    v124 = (const char *)*((_QWORD *)v279 + 8);
                    if (v20 == v280)
                      v125 = (const char *)*((_QWORD *)v279 + 7);
                    else
                      v125 = (const char *)*((_QWORD *)v279 + 8);
                    *(_DWORD *)buf = 136448514;
                    v286 = "nw_endpoint_fallback_receive_report";
                    v287 = 2082;
                    v288 = (void *)v115;
                    v289 = 2082;
                    v290 = v116;
                    v291 = 2082;
                    v292 = v118;
                    v293 = 2082;
                    v294 = v119;
                    v295 = 2082;
                    v296 = v120;
                    v297 = 2114;
                    v298 = v121;
                    v299 = 2112;
                    v300 = v123;
                    v301 = 2112;
                    v302 = v124;
                    v303 = 2112;
                    v304 = v125;
                    _os_log_impl(&dword_182FBE000, v261, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback complete: primary child (%@), fallback child (%@), %@ connected", buf, 0x66u);

                    a4 = v272;
                    v114 = v261;
                  }
                  goto LABEL_133;
                }
                if ((nw_endpoint_handler_get_logging_disabled(v88) & 1) == 0)
                {
                  v274 = a4;
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v114 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
                  {
                    v264 = nw_endpoint_handler_get_id_string(v88);
                    v218 = nw_endpoint_handler_dry_run_string(v88);
                    v219 = nw_endpoint_handler_copy_endpoint(v88);
                    v220 = nw_endpoint_get_logging_description(v219);
                    v221 = nw_endpoint_handler_state_string(v88);
                    v222 = nw_endpoint_handler_mode_string(v88);
                    v223 = nw_endpoint_handler_copy_current_path(v88);
                    v224 = v223;
                    v225 = *((_QWORD *)v279 + 7);
                    v226 = (const char *)*((_QWORD *)v279 + 8);
                    if (v20 == v280)
                      v227 = (const char *)*((_QWORD *)v279 + 7);
                    else
                      v227 = (const char *)*((_QWORD *)v279 + 8);
                    *(_DWORD *)buf = 136448514;
                    v286 = "nw_endpoint_fallback_receive_report";
                    v287 = 2082;
                    v288 = (void *)v264;
                    v289 = 2082;
                    v290 = v218;
                    v291 = 2082;
                    v292 = v220;
                    v293 = 2082;
                    v294 = v221;
                    v295 = 2082;
                    v296 = v222;
                    v297 = 2114;
                    v298 = v223;
                    v299 = 2112;
                    v300 = v225;
                    v301 = 2112;
                    v302 = v226;
                    v303 = 2112;
                    v304 = v227;
                    _os_log_impl(&dword_182FBE000, v114, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback complete: primary child (%@), fallback child (%@), %@ connected", buf, 0x66u);

                    a4 = v274;
                  }
LABEL_133:

                }
              }
LABEL_134:
              if (a3 == 3)
              {
                v126 = v88;
                v126->state = 3;

              }
              nw_endpoint_handler_report(v88, 0, a4, 0);
              v127 = *((_BYTE *)v279 + 108);
              v88->event.domain = 5;
              p_event = &v88->event;
              if (v20 == v280)
              {
                v88->event.event = 3;
                nw_endpoint_handler_report(v88, 0, p_event, 0);
                if ((v127 & 0x10) == 0)
                  goto LABEL_189;
              }
              else
              {
                v88->event.event = 4;
                nw_endpoint_handler_report(v88, 0, p_event, 0);
                if ((v127 & 0x10) != 0)
                  goto LABEL_189;
              }
              v129 = v88;
              os_unfair_lock_lock(&v129->lock);
              v130 = v129->current_path;
              os_unfair_lock_unlock(&v129->lock);

              if (!v130)
              {
                if ((nw_endpoint_handler_get_logging_disabled(v129) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v141 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
                  {
                    v142 = nw_endpoint_handler_get_id_string(v129);
                    v143 = nw_endpoint_handler_dry_run_string(v129);
                    v144 = nw_endpoint_handler_copy_endpoint(v129);
                    v145 = nw_endpoint_get_logging_description(v144);
                    v146 = nw_endpoint_handler_state_string(v129);
                    v147 = nw_endpoint_handler_mode_string(v129);
                    v148 = nw_endpoint_handler_copy_current_path(v129);
                    *(_DWORD *)buf = 136447746;
                    v286 = "nw_endpoint_fallback_receive_report";
                    v287 = 2082;
                    v288 = (void *)v142;
                    v289 = 2082;
                    v290 = v143;
                    v291 = 2082;
                    v292 = v145;
                    v293 = 2082;
                    v294 = v146;
                    v295 = 2082;
                    v296 = v147;
                    v297 = 2114;
                    v298 = v148;
                    _os_log_impl(&dword_182FBE000, v141, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] could not get fallback path", buf, 0x48u);

                  }
                }
                goto LABEL_185;
              }
              type = 0uLL;
              if (nw_path_get_fallback_agent(v130, &type))
              {
                v131 = nw_path_agent_action(v130, (const unsigned __int8 *)&type, 131);
                v132 = nw_endpoint_handler_get_logging_disabled(v129);
                if (v131)
                {
                  if ((v132 & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1)
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                    v133 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
                    {
                      v134 = nw_endpoint_handler_get_id_string(v129);
                      v135 = nw_endpoint_handler_dry_run_string(v129);
                      v136 = nw_endpoint_handler_copy_endpoint(v129);
                      v137 = nw_endpoint_get_logging_description(v136);
                      v138 = nw_endpoint_handler_state_string(v129);
                      v139 = nw_endpoint_handler_mode_string(v129);
                      v140 = nw_endpoint_handler_copy_current_path(v129);
                      *(_DWORD *)buf = 136447746;
                      v286 = "nw_endpoint_fallback_receive_report";
                      v287 = 2082;
                      v288 = (void *)v134;
                      v289 = 2082;
                      v290 = v135;
                      v291 = 2082;
                      v292 = v137;
                      v293 = 2082;
                      v294 = v138;
                      v295 = 2082;
                      v296 = v139;
                      v297 = 2114;
                      v298 = v140;
                      _os_log_impl(&dword_182FBE000, v133, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] asserted fallback agent", buf, 0x48u);

                    }
LABEL_184:

                  }
                }
                else if ((v132 & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1)
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                  v133 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
                  {
                    v177 = nw_endpoint_handler_get_id_string(v129);
                    v178 = nw_endpoint_handler_dry_run_string(v129);
                    v179 = nw_endpoint_handler_copy_endpoint(v129);
                    v180 = nw_endpoint_get_logging_description(v179);
                    v181 = nw_endpoint_handler_state_string(v129);
                    v182 = nw_endpoint_handler_mode_string(v129);
                    v183 = nw_endpoint_handler_copy_current_path(v129);
                    *(_DWORD *)buf = 136447746;
                    v286 = "nw_endpoint_fallback_receive_report";
                    v287 = 2082;
                    v288 = (void *)v177;
                    v289 = 2082;
                    v290 = v178;
                    v291 = 2082;
                    v292 = v180;
                    v293 = 2082;
                    v294 = v181;
                    v295 = 2082;
                    v296 = v182;
                    v297 = 2114;
                    v298 = v183;
                    _os_log_impl(&dword_182FBE000, v133, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] could not assert fallback agent", buf, 0x48u);

                  }
                  goto LABEL_184;
                }
              }
              else if ((nw_endpoint_handler_get_logging_disabled(v129) & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1)
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
                v133 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
                {
                  v149 = nw_endpoint_handler_get_id_string(v129);
                  v150 = nw_endpoint_handler_dry_run_string(v129);
                  v151 = nw_endpoint_handler_copy_endpoint(v129);
                  v152 = nw_endpoint_get_logging_description(v151);
                  v153 = nw_endpoint_handler_state_string(v129);
                  v154 = nw_endpoint_handler_mode_string(v129);
                  v155 = nw_endpoint_handler_copy_current_path(v129);
                  *(_DWORD *)buf = 136447746;
                  v286 = "nw_endpoint_fallback_receive_report";
                  v287 = 2082;
                  v288 = (void *)v149;
                  v289 = 2082;
                  v290 = v150;
                  v291 = 2082;
                  v292 = v152;
                  v293 = 2082;
                  v294 = v153;
                  v295 = 2082;
                  v296 = v154;
                  v297 = 2114;
                  v298 = v155;
                  _os_log_impl(&dword_182FBE000, v133, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] could not get fallback agent", buf, 0x48u);

                }
                goto LABEL_184;
              }
LABEL_185:

              goto LABEL_189;
            }
            *((_BYTE *)v14 + 108) = v85 & 0x7F;
            v84 = *((_BYTE *)v14 + 109) | 2;
          }
          else
          {
            if (v20 != v10)
            {
              v78 = (char *)v14 + 109;
              v79 = *((_BYTE *)v14 + 109);
              v80 = 1;
              goto LABEL_62;
            }
            *((_BYTE *)v14 + 108) |= 0x80u;
            v84 = *((_BYTE *)v14 + 109) & 0xFD;
          }
          *((_BYTE *)v14 + 109) = v84;
          goto LABEL_71;
        }
LABEL_221:
        a4 = v273;
        v29 = v194;
        goto LABEL_57;
      }
    }
    else
    {
      if (v19 != v10)
      {
        v21 = 0;
        v22 = 0;
LABEL_191:

        goto LABEL_192;
      }
      v25 = v20;
      v277 = v25;
      v275 = a3;
      if (!nw_endpoint_handler_get_minimize_logging(v12))
      {
        v38 = v12;
        v39 = *((_BYTE *)v38 + 268);

        if ((v39 & 0x20) != 0)
          goto LABEL_59;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v29 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
        {
          loga = v29;
          v40 = v38;

          v41 = v40;
          v42 = *((_BYTE *)v38 + 268);

          if ((v42 & 1) != 0)
            v43 = "dry-run ";
          else
            v43 = "";
          v256 = nw_endpoint_handler_copy_endpoint(v41);
          v252 = nw_endpoint_get_logging_description(v256);
          v44 = v41;
          v45 = v44;
          v46 = v44[30];
          if (v46 > 5)
            v47 = "unknown-state";
          else
            v47 = off_1E149FC48[v46];
          v244 = v47;

          v52 = v45;
          v53 = v52;
          v54 = v12->mode;
          v271 = a4;
          v248 = v43;
          v55 = "path";
          switch(v54)
          {
            case 0:
              break;
            case 1:
              v55 = "resolver";
              break;
            case 2:
              v55 = nw_endpoint_flow_mode_string(v52[31]);
              break;
            case 3:
              v55 = "proxy";
              break;
            case 4:
              v55 = "fallback";
              break;
            case 5:
              v55 = "transform";
              break;
            default:
              v55 = "unknown-mode";
              break;
          }

          v67 = v53;
          os_unfair_lock_lock((os_unfair_lock_t)v67 + 28);
          v68 = v67[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v67 + 28);

          v69 = v68;
          v70 = nw_endpoint_handler_get_id_string(v10);
          v71 = nw_endpoint_handler_dry_run_string(v10);
          v72 = nw_endpoint_handler_copy_endpoint(v10);
          v260 = v20;
          v73 = nw_endpoint_get_logging_description(v72);
          v74 = v40->id_str;
          v75 = nw_endpoint_handler_state_string(v10);
          v76 = nw_endpoint_handler_mode_string(v280);
          v77 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = v74;
          v289 = 2082;
          v290 = v248;
          v291 = 2082;
          v292 = v252;
          v293 = 2082;
          v294 = v244;
          v295 = 2082;
          v296 = v55;
          v297 = 2114;
          v298 = v69;
          v299 = 2082;
          v300 = (unint64_t)v70;
          v301 = 2082;
          v302 = v71;
          v303 = 2082;
          v304 = v73;
          v305 = 2082;
          v306 = v75;
          v307 = 2082;
          v308 = v76;
          v309 = 2114;
          v310 = v77;
          v29 = loga;
          _os_log_impl(&dword_182FBE000, loga, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received fallback child report:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

          v20 = v260;
          a4 = v271;

        }
        goto LABEL_57;
      }
      v273 = a4;
      if ((nw_endpoint_handler_get_logging_disabled(v12) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v194 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
        {
          v263 = nw_endpoint_handler_get_id_string(v12);
          v258 = nw_endpoint_handler_dry_run_string(v12);
          logd = nw_endpoint_handler_copy_endpoint(v12);
          v254 = nw_endpoint_get_logging_description(logd);
          v250 = nw_endpoint_handler_state_string(v12);
          v246 = nw_endpoint_handler_mode_string(v12);
          v203 = nw_endpoint_handler_copy_current_path(v12);
          v204 = nw_endpoint_handler_get_id_string(v10);
          v205 = nw_endpoint_handler_dry_run_string(v10);
          v206 = nw_endpoint_handler_copy_endpoint(v10);
          v207 = nw_endpoint_get_logging_description(v206);
          v208 = nw_endpoint_handler_state_string(v10);
          v209 = nw_endpoint_handler_mode_string(v10);
          v210 = nw_endpoint_handler_copy_current_path(v280);
          *(_DWORD *)buf = 136449282;
          v286 = "nw_endpoint_fallback_receive_report";
          v287 = 2082;
          v288 = (void *)v263;
          v289 = 2082;
          v290 = v258;
          v291 = 2082;
          v292 = v254;
          v293 = 2082;
          v294 = v250;
          v295 = 2082;
          v296 = v246;
          v297 = 2114;
          v298 = v203;
          v299 = 2082;
          v300 = (unint64_t)v204;
          v301 = 2082;
          v302 = v205;
          v303 = 2082;
          v304 = v207;
          v305 = 2082;
          v306 = v208;
          v307 = 2082;
          v308 = v209;
          v309 = 2114;
          v310 = v210;
          v29 = v194;
          _os_log_impl(&dword_182FBE000, v194, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received fallback child report:[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

          a4 = v273;
          goto LABEL_57;
        }
        goto LABEL_221;
      }
    }
    v25 = v277;
    a4 = v273;
    goto LABEL_58;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v23 = (id)gLogObj;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5)
      v24 = "unknown-mode";
    else
      v24 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v286 = "nw_endpoint_fallback_receive_report";
    v287 = 2082;
    v288 = (void *)v24;
    v289 = 2082;
    v290 = "fallback";
    _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_28:
  v22 = 0;
LABEL_192:

  return v22;
}

void sub_1836EDED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,uint64_t a22,void *a23,void *a24)
{
  void *v24;
  void *v25;

  _Unwind_Resume(a1);
}

void ___ZL32nw_endpoint_fallback_start_timerP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1)
{
  nw_endpoint_fallback_start_fallback_child(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
}

void nw_endpoint_fallback_start_post_transport_timer(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  int64_t int64_with_default;
  NSObject *v6;
  const char *id_string;
  const char *v8;
  nw_endpoint_t v9;
  const char *logging_description;
  const char *v11;
  const char *v12;
  id v13;
  id v14;
  NWConcrete_nw_endpoint_handler *v15;
  uint64_t v16;
  dispatch_time_t v17;
  id v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  uint64_t *v26;
  char v27;
  os_log_type_t type;
  _QWORD v29[4];
  NWConcrete_nw_endpoint_handler *v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  void *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  id v44;
  __int16 v45;
  int64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v3 = (uint64_t *)nw_endpoint_handler_copy_fallback(v1);
  v4 = v3[10];
  if (v4)
  {
    nw_queue_cancel_source(v4, v2);
    v3[10] = 0;
  }
  int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_fallback_post_transport_timeout, 3000);
  if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v6 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(v1);
      v8 = nw_endpoint_handler_dry_run_string(v1);
      v26 = v3;
      v9 = nw_endpoint_handler_copy_endpoint(v1);
      logging_description = nw_endpoint_get_logging_description(v9);
      v11 = nw_endpoint_handler_state_string(v1);
      v12 = nw_endpoint_handler_mode_string(v1);
      v13 = nw_endpoint_handler_copy_current_path(v1);
      *(_DWORD *)buf = 136448002;
      v32 = "nw_endpoint_fallback_start_post_transport_timer";
      v33 = 2082;
      v34 = (void *)id_string;
      v35 = 2082;
      v36 = v8;
      v37 = 2082;
      v38 = logging_description;
      v39 = 2082;
      v40 = v11;
      v41 = 2082;
      v42 = v12;
      v43 = 2114;
      v44 = v13;
      v45 = 2048;
      v46 = int64_with_default;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] starting post-transport fallback timer for %llums", buf, 0x52u);

      v3 = v26;
    }

  }
  v14 = nw_endpoint_handler_copy_context(v1);
  v29[0] = MEMORY[0x1E0C809B0];
  v29[1] = 3221225472;
  v29[2] = ___ZL47nw_endpoint_fallback_start_post_transport_timerP30NWConcrete_nw_endpoint_handler_block_invoke;
  v29[3] = &unk_1E14ACFD0;
  v15 = v1;
  v30 = v15;
  v3[10] = nw_queue_context_create_source(v14, 2, 3, 0, v29, 0);

  v16 = v3[10];
  if (v16)
  {
    v17 = dispatch_time(0x8000000000000000, 1000000 * int64_with_default);
    if (*(_QWORD *)v16)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }
    else
    {
      *(_QWORD *)(v16 + 32) = v17;
      *(_QWORD *)(v16 + 40) = -1;
      if (*(_BYTE *)(v16 + 48) && *(_BYTE *)(v16 + 49))
        nw_queue_source_run_timer(v16, v17);
    }
    nw_queue_activate_source(v3[10], v17);
    goto LABEL_20;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v32 = "nw_endpoint_fallback_start_post_transport_timer";
  v19 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v19, &type, &v27))
    goto LABEL_18;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (id)gLogObj;
    v21 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      v32 = "nw_endpoint_fallback_start_post_transport_timer";
      _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s nw_queue_context_create_source(timer) failed", buf, 0xCu);
    }
LABEL_17:

LABEL_18:
    if (!v19)
      goto LABEL_20;
LABEL_19:
    free(v19);
    goto LABEL_20;
  }
  if (!v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (id)gLogObj;
    v25 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)buf = 136446210;
      v32 = "nw_endpoint_fallback_start_post_transport_timer";
      _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_17;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = (id)gLogObj;
  v23 = type;
  v24 = os_log_type_enabled(v20, type);
  if (!backtrace_string)
  {
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      v32 = "nw_endpoint_fallback_start_post_transport_timer";
      _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s nw_queue_context_create_source(timer) failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_17;
  }
  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    v32 = "nw_endpoint_fallback_start_post_transport_timer";
    v33 = 2082;
    v34 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v19)
    goto LABEL_19;
LABEL_20:

}

void sub_1836EE660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void nw_endpoint_fallback_start_usage_cap_timer(NWConcrete_nw_endpoint_handler *a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  uint64_t v2;
  NWConcrete_nw_endpoint_mode_handler *v3;
  uint64_t v4;
  int minimize_logging;
  char logging_disabled;
  NSObject *v7;
  const char *id_string;
  const char *v9;
  nw_endpoint_t v10;
  const char *logging_description;
  const char *v12;
  const char *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  NWConcrete_nw_endpoint_handler *v18;
  uint64_t v19;
  dispatch_time_t v20;
  id v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  const char *v29;
  const char *v30;
  nw_endpoint_t v31;
  const char *v32;
  const char *v33;
  const char *v34;
  id v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  os_log_type_t type;
  _QWORD v40[4];
  NWConcrete_nw_endpoint_handler *v41;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  void *v45;
  __int16 v46;
  const char *v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  id v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v3 = nw_endpoint_handler_copy_fallback(v1);
  v4 = *((_QWORD *)v3 + 11);
  if (v4)
  {
    nw_queue_cancel_source(v4, v2);
    *((_QWORD *)v3 + 11) = 0;
  }
  *((_QWORD *)v3 + 2) = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_fallback_usage_cap_interval, 3000);
  minimize_logging = nw_endpoint_handler_get_minimize_logging(v1);
  logging_disabled = nw_endpoint_handler_get_logging_disabled(v1);
  if (!minimize_logging)
  {
    if ((logging_disabled & 1) != 0)
      goto LABEL_10;
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      id_string = nw_endpoint_handler_get_id_string(v1);
      v9 = nw_endpoint_handler_dry_run_string(v1);
      v10 = nw_endpoint_handler_copy_endpoint(v1);
      logging_description = nw_endpoint_get_logging_description(v10);
      v12 = nw_endpoint_handler_state_string(v1);
      v13 = nw_endpoint_handler_mode_string(v1);
      v14 = nw_endpoint_handler_copy_current_path(v1);
      v15 = *((_QWORD *)v3 + 1);
      v16 = *((_QWORD *)v3 + 2);
      *(_DWORD *)buf = 136448258;
      v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      v44 = 2082;
      v45 = (void *)id_string;
      v46 = 2082;
      v47 = v9;
      v48 = 2082;
      v49 = logging_description;
      v50 = 2082;
      v51 = v12;
      v52 = 2082;
      v53 = v13;
      v54 = 2114;
      v55 = v14;
      v56 = 2048;
      v57 = v15;
      v58 = 2048;
      v59 = v16;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] applying data cap of %llu to fallback child, checking every %llums", buf, 0x5Cu);

    }
    goto LABEL_9;
  }
  if ((logging_disabled & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v7 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v29 = nw_endpoint_handler_get_id_string(v1);
      v30 = nw_endpoint_handler_dry_run_string(v1);
      v31 = nw_endpoint_handler_copy_endpoint(v1);
      v32 = nw_endpoint_get_logging_description(v31);
      v33 = nw_endpoint_handler_state_string(v1);
      v34 = nw_endpoint_handler_mode_string(v1);
      v35 = nw_endpoint_handler_copy_current_path(v1);
      v36 = *((_QWORD *)v3 + 1);
      v37 = *((_QWORD *)v3 + 2);
      *(_DWORD *)buf = 136448258;
      v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      v44 = 2082;
      v45 = (void *)v29;
      v46 = 2082;
      v47 = v30;
      v48 = 2082;
      v49 = v32;
      v50 = 2082;
      v51 = v33;
      v52 = 2082;
      v53 = v34;
      v54 = 2114;
      v55 = v35;
      v56 = 2048;
      v57 = v36;
      v58 = 2048;
      v59 = v37;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] applying data cap of %llu to fallback child, checking every %llums", buf, 0x5Cu);

    }
LABEL_9:

  }
LABEL_10:
  v17 = nw_endpoint_handler_copy_context(v1);
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 3221225472;
  v40[2] = ___ZL42nw_endpoint_fallback_start_usage_cap_timerP30NWConcrete_nw_endpoint_handler_block_invoke;
  v40[3] = &unk_1E14ACFD0;
  v18 = v1;
  v41 = v18;
  *((_QWORD *)v3 + 11) = nw_queue_context_create_source(v17, 2, 3, 0, v40, 0);

  v19 = *((_QWORD *)v3 + 11);
  if (v19)
  {
    v20 = dispatch_time(0x8000000000000000, 1000000 * *((_QWORD *)v3 + 2));
    if (*(_QWORD *)v19)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v19, v20, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    }
    else
    {
      *(_QWORD *)(v19 + 32) = v20;
      *(_QWORD *)(v19 + 40) = -1;
      if (*(_BYTE *)(v19 + 48) && *(_BYTE *)(v19 + 49))
        nw_queue_source_run_timer(v19, v20);
    }
    nw_queue_activate_source(*((_QWORD *)v3 + 11), v20);
    goto LABEL_36;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v21 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v43 = "nw_endpoint_fallback_start_usage_cap_timer";
  v22 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v38 = 0;
  if (!__nwlog_fault(v22, &type, &v38))
    goto LABEL_34;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (id)gLogObj;
    v24 = type;
    if (os_log_type_enabled(v23, type))
    {
      *(_DWORD *)buf = 136446210;
      v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s nw_queue_context_create_source(timer) failed", buf, 0xCu);
    }
LABEL_33:

LABEL_34:
    if (!v22)
      goto LABEL_36;
LABEL_35:
    free(v22);
    goto LABEL_36;
  }
  if (!v38)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v23 = (id)gLogObj;
    v28 = type;
    if (os_log_type_enabled(v23, type))
    {
      *(_DWORD *)buf = 136446210;
      v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      _os_log_impl(&dword_182FBE000, v23, v28, "%{public}s nw_queue_context_create_source(timer) failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_33;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v23 = (id)gLogObj;
  v26 = type;
  v27 = os_log_type_enabled(v23, type);
  if (!backtrace_string)
  {
    if (v27)
    {
      *(_DWORD *)buf = 136446210;
      v43 = "nw_endpoint_fallback_start_usage_cap_timer";
      _os_log_impl(&dword_182FBE000, v23, v26, "%{public}s nw_queue_context_create_source(timer) failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_33;
  }
  if (v27)
  {
    *(_DWORD *)buf = 136446466;
    v43 = "nw_endpoint_fallback_start_usage_cap_timer";
    v44 = 2082;
    v45 = backtrace_string;
    _os_log_impl(&dword_182FBE000, v23, v26, "%{public}s nw_queue_context_create_source(timer) failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v22)
    goto LABEL_35;
LABEL_36:

}

void sub_1836EED3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void ___ZL42nw_endpoint_fallback_start_usage_cap_timerP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1)
{
  NWConcrete_nw_endpoint_handler *v1;
  uint64_t mode;
  NWConcrete_nw_endpoint_mode_handler *v3;
  NWConcrete_nw_endpoint_handler *v6;
  _BOOL4 v7;
  uint64_t v8;
  NSObject *v9;
  NWConcrete_nw_endpoint_handler *v10;
  NWConcrete_nw_endpoint_handler *v11;
  _BOOL4 v12;
  const char *v13;
  nw_endpoint_t v14;
  const char *v15;
  unsigned int *v16;
  unsigned int *v17;
  uint64_t v18;
  const char *v19;
  NSObject *v20;
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  unint64_t v25;
  NWConcrete_nw_endpoint_handler *v26;
  _BOOL4 v27;
  NSObject *v28;
  NWConcrete_nw_endpoint_handler *v29;
  NWConcrete_nw_endpoint_handler *v30;
  _BOOL4 v31;
  const char *v32;
  nw_endpoint_t v33;
  const char *v34;
  unsigned int *v35;
  unsigned int *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  dispatch_time_t v40;
  void **v41;
  void **v42;
  const char *v43;
  void **v44;
  const char *v45;
  void **v46;
  id v47;
  uint64_t v48;
  NSObject *v49;
  nw_endpoint_t v50;
  const char *v51;
  const char *v52;
  const char *v53;
  void **v54;
  id v55;
  nw_endpoint_t v56;
  char *v57;
  id *v58;
  _BOOL8 v59;
  id *v60;
  char v61;
  id *v62;
  BOOL v63;
  uint64_t v64;
  NWConcrete_nw_endpoint_mode_handler *v65;
  id v66;
  char *v67;
  char *v68;
  _BOOL4 v69;
  const char *v70;
  nw_endpoint_t v71;
  const char *logging_description;
  unsigned int *v73;
  unsigned int *v74;
  uint64_t v75;
  const char *v76;
  void **v77;
  void **v78;
  const char *v79;
  nw_endpoint_t v80;
  id *v81;
  unsigned int *v82;
  void **v83;
  id v84;
  void *v85;
  unsigned int *v86;
  id *v87;
  char *v88;
  NSObject *v89;
  os_log_type_t v90;
  id *v91;
  id *v92;
  _BOOL4 v93;
  const char *v94;
  nw_endpoint_t v95;
  const char *v96;
  id *v97;
  id *v98;
  uint64_t v99;
  const char *v100;
  const char *v101;
  const char *v102;
  char *v103;
  NSObject *v104;
  os_log_type_t v105;
  const char *id_string;
  const char *v107;
  nw_endpoint_t v108;
  const char *v109;
  const char *v110;
  const char *v111;
  id v112;
  os_log_type_t v113;
  const char *v114;
  const char *v115;
  nw_endpoint_t v116;
  const char *v117;
  const char *v118;
  const char *v119;
  id v120;
  void **v121;
  void **v122;
  const char *v123;
  os_log_type_t v124;
  const char *v125;
  const char *v126;
  nw_endpoint_t v127;
  const char *v128;
  const char *v129;
  const char *v130;
  id v131;
  void **v132;
  id v133;
  uint64_t v134;
  void *v135;
  char *v136;
  NSObject *v137;
  os_log_type_t v138;
  char *backtrace_string;
  os_log_type_t v140;
  _BOOL4 v141;
  const char *v142;
  const char *v143;
  nw_endpoint_t v144;
  const char *v145;
  const char *v146;
  const char *v147;
  id v148;
  os_log_type_t v149;
  const char *v150;
  const char *v151;
  nw_endpoint_t v152;
  const char *v153;
  const char *v154;
  const char *v155;
  id v156;
  char *v157;
  char *v158;
  os_unfair_lock_s *lock;
  id *v160;
  const char *v161;
  const char *v162;
  const char *v163;
  const char *v164;
  const char *v165;
  id v166;
  NWConcrete_nw_endpoint_handler *v167;
  NWConcrete_nw_endpoint_handler *v168;
  NWConcrete_nw_endpoint_mode_handler *v169;
  id v170;
  char v171;
  os_log_type_t type;
  os_log_type_t v173[8];
  uint64_t v174;
  void (*v175)(uint64_t, int, uint64_t);
  void *v176;
  id *v177;
  char v178;
  uint64_t v179;
  void *v180;
  __int128 v181;
  uint8_t buf[4];
  const char *v183;
  __int16 v184;
  char *id_str;
  __int16 v186;
  const char *v187;
  __int16 v188;
  const char *v189;
  __int16 v190;
  const char *v191;
  __int16 v192;
  const char *v193;
  __int16 v194;
  id v195;
  __int16 v196;
  char *v197;
  uint64_t v198;

  v198 = *MEMORY[0x1E0C80C00];
  v170 = *(id *)(a1 + 32);
  if (!v170)
  {
    __nwlog_obj();
    v135 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v183 = "nw_endpoint_fallback_check_usage_cap";
    v136 = (char *)_os_log_send_and_compose_impl();

    v173[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v181) = 0;
    if (__nwlog_fault(v136, v173, &v181))
    {
      if (v173[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v137 = objc_claimAutoreleasedReturnValue();
        v138 = v173[0];
        if (os_log_type_enabled(v137, v173[0]))
        {
          *(_DWORD *)buf = 136446210;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          _os_log_impl(&dword_182FBE000, v137, v138, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if ((_BYTE)v181)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v137 = objc_claimAutoreleasedReturnValue();
        v140 = v173[0];
        v141 = os_log_type_enabled(v137, v173[0]);
        if (backtrace_string)
        {
          if (v141)
          {
            *(_DWORD *)buf = 136446466;
            v183 = "nw_endpoint_fallback_check_usage_cap";
            v184 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_182FBE000, v137, v140, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_155;
        }
        if (v141)
        {
          *(_DWORD *)buf = 136446210;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          _os_log_impl(&dword_182FBE000, v137, v140, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v137 = objc_claimAutoreleasedReturnValue();
        v149 = v173[0];
        if (os_log_type_enabled(v137, v173[0]))
        {
          *(_DWORD *)buf = 136446210;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          _os_log_impl(&dword_182FBE000, v137, v149, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_155:
    if (v136)
      free(v136);
    goto LABEL_128;
  }
  v1 = (NWConcrete_nw_endpoint_handler *)v170;
  mode = v1->mode;

  if ((_DWORD)mode == 4)
  {
    v3 = nw_endpoint_handler_copy_fallback(v1);
    v179 = 0;
    v180 = 0;
    v178 = 0;
    v169 = v3;
    if (nw_endpoint_handler_fillout_data_transfer_snapshot(*((void **)v3 + 5), (uint64_t *)&v180, &v179, &v178, 2)
      && v180 != 0
      && v179 != 0)
    {
      v22 = *((_QWORD *)v180 + 6);
      v23 = *((_QWORD *)v3 + 1);
      v24 = v23 >= v22;
      v25 = v23 - v22;
      if (v24 && *((_QWORD *)v180 + 9) <= v25)
      {
        v39 = *((_QWORD *)v3 + 11);
        v40 = dispatch_time(0x8000000000000000, 1000000 * *((_QWORD *)v3 + 2));
        nw_queue_set_timer_values(v39, v40, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        goto LABEL_124;
      }
      v168 = v1;
      if (nw_endpoint_handler_get_minimize_logging(v1))
      {
        if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) != 0)
        {
LABEL_63:
          v58 = v168;
          v166 = v58[4];

          v181 = 0uLL;
          nw_parameters_get_e_proc_uuid(v166, &v181);
          nw_parameters_get_pid(v166);
          nw_parameters_get_effective_bundle_id(v166);
          v59 = nw_queue_copy_current_workloop();
          *(_QWORD *)v173 = MEMORY[0x1E0C809B0];
          v174 = 3221225472;
          v175 = ___ZL36nw_endpoint_fallback_check_usage_capP30NWConcrete_nw_endpoint_handler_block_invoke;
          v176 = &unk_1E14A0C18;
          v60 = v58;
          v177 = v60;
          v61 = _symptoms_daemon_fallback_subseq_disposition();

          if ((v61 & 1) != 0)
          {
LABEL_123:

            v3 = v169;
LABEL_124:
            if (v178 && v180)
              free(v180);

            goto LABEL_128;
          }
          v62 = v60;
          v63 = (*((_BYTE *)v62 + 268) & 0x20) == 0;

          v65 = v169;
          if (!v63)
          {
LABEL_120:
            v134 = *((_QWORD *)v65 + 11);
            if (v134)
            {
              nw_queue_cancel_source(v134, v64);
              v65 = v169;
              *((_QWORD *)v169 + 11) = 0;
            }
            nw_endpoint_handler_cancel(*((void **)v65 + 5), 0, 1);
            goto LABEL_123;
          }
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v66 = (id)gconnectionLogObj;
          v67 = v62;

          v68 = v67;
          v69 = (*((_BYTE *)v62 + 268) & 1) == 0;

          if (v69)
            v70 = "";
          else
            v70 = "dry-run ";
          v71 = nw_endpoint_handler_copy_endpoint(v68);
          logging_description = nw_endpoint_get_logging_description(v71);
          v73 = v68;
          v74 = v73;
          v75 = v73[30];
          v162 = logging_description;
          if (v75 > 5)
            v76 = "unknown-state";
          else
            v76 = off_1E149FC48[v75];
          v161 = v76;

          v77 = v74;
          v78 = v77;
          v79 = "path";
          switch(v168->mode)
          {
            case 0:
              break;
            case 1:
              v79 = "resolver";
              break;
            case 2:
              v79 = nw_endpoint_flow_mode_string(v77[31]);
              break;
            case 3:
              v79 = "proxy";
              break;
            case 4:
              v79 = "fallback";
              break;
            case 5:
              v79 = "transform";
              break;
            default:
              v79 = "unknown-mode";
              break;
          }

          v80 = v71;
          v81 = v62;
          v82 = v74;
          v83 = v78;
          os_unfair_lock_lock((os_unfair_lock_t)v83 + 28);
          v84 = v83[8];
          lock = (os_unfair_lock_s *)(v83 + 14);
          os_unfair_lock_unlock((os_unfair_lock_t)v83 + 28);
          v160 = v83;

          v85 = v66;
          v86 = v82;
          v87 = v81;
          *(_DWORD *)buf = 136447746;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          v184 = 2082;
          v158 = v67 + 168;
          id_str = v67 + 168;
          v186 = 2082;
          v187 = v70;
          v188 = 2082;
          v189 = v162;
          v190 = 2082;
          v191 = v161;
          v192 = 2082;
          v193 = v79;
          v194 = 2114;
          v195 = v84;
          v164 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v171 = 0;
          v88 = (char *)v164;
          if (!__nwlog_fault(v164, &type, &v171))
          {
LABEL_118:
            v65 = v169;
            if (v88)
              free(v88);
            goto LABEL_120;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v89 = (id)gconnectionLogObj;
            v90 = type;
            if (os_log_type_enabled(v89, type))
            {
              v91 = v160;

              v92 = v91;
              v93 = (*((_BYTE *)v87 + 268) & 1) == 0;

              if (v93)
                v94 = "";
              else
                v94 = "dry-run ";
              v95 = nw_endpoint_handler_copy_endpoint(v92);
              v96 = nw_endpoint_get_logging_description(v95);
              v163 = v94;
              v97 = v92;
              v98 = v97;
              v99 = v86[30];
              v100 = v96;
              if (v99 > 5)
                v101 = "unknown-state";
              else
                v101 = off_1E149FC48[v99];

              v121 = v98;
              v122 = v121;
              v123 = "path";
              switch(v168->mode)
              {
                case 0:
                  break;
                case 1:
                  v123 = "resolver";
                  break;
                case 2:
                  v123 = nw_endpoint_flow_mode_string(v121[31]);
                  break;
                case 3:
                  v123 = "proxy";
                  break;
                case 4:
                  v123 = "fallback";
                  break;
                case 5:
                  v123 = "transform";
                  break;
                default:
                  v123 = "unknown-mode";
                  break;
              }

              v132 = v122;
              os_unfair_lock_lock(lock);
              v133 = v160[8];
              os_unfair_lock_unlock(lock);

              *(_DWORD *)buf = 136447746;
              v183 = "nw_endpoint_fallback_check_usage_cap";
              v184 = 2082;
              id_str = v158;
              v186 = 2082;
              v187 = v163;
              v188 = 2082;
              v189 = v100;
              v190 = 2082;
              v191 = v101;
              v192 = 2082;
              v193 = v123;
              v194 = 2114;
              v195 = v133;
              _os_log_impl(&dword_182FBE000, v89, v90, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fallback_subseq_disposition failed, cancelling fallback", buf, 0x48u);

            }
          }
          else if (v171)
          {
            v102 = __nw_create_backtrace_string();
            if (v102)
            {
              v103 = (char *)v102;
              if (__nwlog_connection_log::onceToken != -1)
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
              v104 = (id)gconnectionLogObj;
              v105 = type;
              if (os_log_type_enabled(v104, type))
              {
                id_string = nw_endpoint_handler_get_id_string(v160);
                v107 = nw_endpoint_handler_dry_run_string(v160);
                v108 = nw_endpoint_handler_copy_endpoint(v160);
                v109 = nw_endpoint_get_logging_description(v108);
                v110 = nw_endpoint_handler_state_string(v160);
                v111 = nw_endpoint_handler_mode_string(v160);
                v112 = nw_endpoint_handler_copy_current_path(v160);
                *(_DWORD *)buf = 136448002;
                v183 = "nw_endpoint_fallback_check_usage_cap";
                v184 = 2082;
                id_str = (char *)id_string;
                v186 = 2082;
                v187 = v107;
                v188 = 2082;
                v189 = v109;
                v190 = 2082;
                v191 = v110;
                v192 = 2082;
                v193 = v111;
                v194 = 2114;
                v195 = v112;
                v196 = 2082;
                v197 = v103;
                _os_log_impl(&dword_182FBE000, v104, v105, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fallback_subseq_disposition failed, cancelling fallback, dumping backtrace:%{public}s", buf, 0x52u);

              }
              free(v103);
              goto LABEL_117;
            }
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v89 = (id)gconnectionLogObj;
            v124 = type;
            if (os_log_type_enabled(v89, type))
            {
              v125 = nw_endpoint_handler_get_id_string(v160);
              v126 = nw_endpoint_handler_dry_run_string(v160);
              v127 = nw_endpoint_handler_copy_endpoint(v160);
              v128 = nw_endpoint_get_logging_description(v127);
              v129 = nw_endpoint_handler_state_string(v160);
              v130 = nw_endpoint_handler_mode_string(v160);
              v131 = nw_endpoint_handler_copy_current_path(v160);
              *(_DWORD *)buf = 136447746;
              v183 = "nw_endpoint_fallback_check_usage_cap";
              v184 = 2082;
              id_str = (char *)v125;
              v186 = 2082;
              v187 = v126;
              v188 = 2082;
              v189 = v128;
              v190 = 2082;
              v191 = v129;
              v192 = 2082;
              v193 = v130;
              v194 = 2114;
              v195 = v131;
              _os_log_impl(&dword_182FBE000, v89, v124, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fallback_subseq_disposition failed, cancelling fallback, no backtrace", buf, 0x48u);

            }
          }
          else
          {
            if (__nwlog_connection_log::onceToken != -1)
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
            v89 = (id)gconnectionLogObj;
            v113 = type;
            if (os_log_type_enabled(v89, type))
            {
              v114 = nw_endpoint_handler_get_id_string(v160);
              v115 = nw_endpoint_handler_dry_run_string(v160);
              v116 = nw_endpoint_handler_copy_endpoint(v160);
              v117 = nw_endpoint_get_logging_description(v116);
              v118 = nw_endpoint_handler_state_string(v160);
              v119 = nw_endpoint_handler_mode_string(v160);
              v120 = nw_endpoint_handler_copy_current_path(v160);
              *(_DWORD *)buf = 136447746;
              v183 = "nw_endpoint_fallback_check_usage_cap";
              v184 = 2082;
              id_str = (char *)v114;
              v186 = 2082;
              v187 = v115;
              v188 = 2082;
              v189 = v117;
              v190 = 2082;
              v191 = v118;
              v192 = 2082;
              v193 = v119;
              v194 = 2114;
              v195 = v120;
              _os_log_impl(&dword_182FBE000, v89, v113, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] _symptoms_daemon_fallback_subseq_disposition failed, cancelling fallback, backtrace limit exceeded", buf, 0x48u);

            }
          }

LABEL_117:
          v88 = (char *)v164;
          goto LABEL_118;
        }
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v28 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          v150 = nw_endpoint_handler_get_id_string(v1);
          v151 = nw_endpoint_handler_dry_run_string(v1);
          v152 = nw_endpoint_handler_copy_endpoint(v1);
          v153 = nw_endpoint_get_logging_description(v152);
          v154 = nw_endpoint_handler_state_string(v1);
          v155 = nw_endpoint_handler_mode_string(v1);
          v156 = nw_endpoint_handler_copy_current_path(v1);
          v157 = (char *)*((_QWORD *)v169 + 1);
          *(_DWORD *)buf = 136448002;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          v184 = 2082;
          id_str = (char *)v150;
          v186 = 2082;
          v187 = v151;
          v188 = 2082;
          v189 = v153;
          v190 = 2082;
          v191 = v154;
          v192 = 2082;
          v193 = v155;
          v194 = 2114;
          v195 = v156;
          v196 = 2048;
          v197 = v157;
          _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback reached usage cap of %llu bytes, asking for an update from symptoms", buf, 0x52u);

        }
      }
      else
      {
        v26 = v1;
        v27 = (*((_BYTE *)v26 + 268) & 0x20) == 0;

        if (!v27)
          goto LABEL_63;
        if (__nwlog_connection_log::onceToken != -1)
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
        v28 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          v29 = v26;

          v30 = v29;
          v31 = (*((_BYTE *)v26 + 268) & 1) == 0;

          if (v31)
            v32 = "";
          else
            v32 = "dry-run ";
          v33 = nw_endpoint_handler_copy_endpoint(v30);
          v34 = nw_endpoint_get_logging_description(v33);
          v35 = v30;
          v36 = v35;
          v37 = v35[30];
          if (v37 > 5)
            v38 = "unknown-state";
          else
            v38 = off_1E149FC48[v37];

          v44 = v36;
          v45 = "path";
          switch(v168->mode)
          {
            case 0:
              break;
            case 1:
              v45 = "resolver";
              break;
            case 2:
              v45 = nw_endpoint_flow_mode_string(v44[31]);
              break;
            case 3:
              v45 = "proxy";
              break;
            case 4:
              v45 = "fallback";
              break;
            case 5:
              v45 = "transform";
              break;
            default:
              v45 = "unknown-mode";
              break;
          }
          v165 = v45;

          v49 = v28;
          v50 = v33;
          v51 = v38;
          v52 = v32;
          v53 = v34;
          v54 = v44;
          os_unfair_lock_lock((os_unfair_lock_t)v54 + 28);
          v55 = v54[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v54 + 28);

          v56 = v50;
          v28 = v49;
          v57 = (char *)*((_QWORD *)v169 + 1);
          *(_DWORD *)buf = 136448002;
          v183 = "nw_endpoint_fallback_check_usage_cap";
          v184 = 2082;
          id_str = v29->id_str;
          v186 = 2082;
          v187 = v52;
          v188 = 2082;
          v189 = v53;
          v190 = 2082;
          v191 = v51;
          v192 = 2082;
          v193 = v165;
          v194 = 2114;
          v195 = v55;
          v196 = 2048;
          v197 = v57;
          _os_log_impl(&dword_182FBE000, v49, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback reached usage cap of %llu bytes, asking for an update from symptoms", buf, 0x52u);

        }
      }

      goto LABEL_63;
    }
    v167 = v1;
    if (nw_endpoint_handler_get_minimize_logging(v1))
    {
      if ((nw_endpoint_handler_get_logging_disabled(v1) & 1) != 0)
      {
LABEL_54:
        v3 = v169;
        v48 = *((_QWORD *)v169 + 11);
        if (v48)
        {
          nw_queue_cancel_source(v48, v8);
          *((_QWORD *)v169 + 11) = 0;
        }
        goto LABEL_124;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v9 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        v142 = nw_endpoint_handler_get_id_string(v1);
        v143 = nw_endpoint_handler_dry_run_string(v1);
        v144 = nw_endpoint_handler_copy_endpoint(v1);
        v145 = nw_endpoint_get_logging_description(v144);
        v146 = nw_endpoint_handler_state_string(v1);
        v147 = nw_endpoint_handler_mode_string(v1);
        v148 = nw_endpoint_handler_copy_current_path(v1);
        *(_DWORD *)buf = 136447746;
        v183 = "nw_endpoint_fallback_check_usage_cap";
        v184 = 2082;
        id_str = (char *)v142;
        v186 = 2082;
        v187 = v143;
        v188 = 2082;
        v189 = v145;
        v190 = 2082;
        v191 = v146;
        v192 = 2082;
        v193 = v147;
        v194 = 2114;
        v195 = v148;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to get byte count for fallback connection with data cap, ignoring", buf, 0x48u);

      }
    }
    else
    {
      v6 = v1;
      v7 = (*((_BYTE *)v6 + 268) & 0x20) == 0;

      if (!v7)
        goto LABEL_54;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v9 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        v10 = v6;

        v11 = v10;
        v12 = (*((_BYTE *)v6 + 268) & 1) == 0;

        if (v12)
          v13 = "";
        else
          v13 = "dry-run ";
        v14 = nw_endpoint_handler_copy_endpoint(v11);
        v15 = nw_endpoint_get_logging_description(v14);
        v16 = v11;
        v17 = v16;
        v18 = v16[30];
        if (v18 > 5)
          v19 = "unknown-state";
        else
          v19 = off_1E149FC48[v18];

        v41 = v17;
        v42 = v41;
        v43 = "path";
        switch(v167->mode)
        {
          case 0:
            break;
          case 1:
            v43 = "resolver";
            break;
          case 2:
            v43 = nw_endpoint_flow_mode_string(v41[31]);
            break;
          case 3:
            v43 = "proxy";
            break;
          case 4:
            v43 = "fallback";
            break;
          case 5:
            v43 = "transform";
            break;
          default:
            v43 = "unknown-mode";
            break;
        }

        v46 = v42;
        os_unfair_lock_lock((os_unfair_lock_t)v46 + 28);
        v47 = v46[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v46 + 28);

        *(_DWORD *)buf = 136447746;
        v183 = "nw_endpoint_fallback_check_usage_cap";
        v184 = 2082;
        id_str = v10->id_str;
        v186 = 2082;
        v187 = v13;
        v188 = 2082;
        v189 = v15;
        v190 = 2082;
        v191 = v19;
        v192 = 2082;
        v193 = v43;
        v194 = 2114;
        v195 = v47;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to get byte count for fallback connection with data cap, ignoring", buf, 0x48u);

      }
    }

    goto LABEL_54;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = (id)gLogObj;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5)
      v21 = "unknown-mode";
    else
      v21 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446722;
    v183 = "nw_endpoint_fallback_check_usage_cap";
    v184 = 2082;
    id_str = (char *)v21;
    v186 = 2082;
    v187 = "fallback";
    _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_128:
}

void sub_1836F020C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21)
{
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void ___ZL36nw_endpoint_fallback_check_usage_capP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  void *v3;
  unsigned int *v7;
  uint64_t v8;
  NWConcrete_nw_endpoint_mode_handler *v9;
  NWConcrete_nw_endpoint_mode_handler *v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  const char *id_string;
  const char *v18;
  nw_endpoint_t v19;
  const char *logging_description;
  const char *v21;
  const char *v22;
  id v23;
  uint64_t v24;
  NSObject *v25;
  const char *v26;
  int minimize_logging;
  char logging_disabled;
  NSObject *v29;
  const char *v30;
  const char *v31;
  nw_endpoint_t v32;
  const char *v33;
  const char *v34;
  const char *v35;
  id v36;
  uint64_t v37;
  dispatch_time_t v38;
  void *v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  char *backtrace_string;
  os_log_type_t v44;
  _BOOL4 v45;
  os_log_type_t v46;
  const char *v47;
  const char *v48;
  nw_endpoint_t v49;
  const char *v50;
  const char *v51;
  const char *v52;
  id v53;
  char v54;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v57;
  __int16 v58;
  void *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  id v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v3 = *(void **)(a1 + 32);
  if (!v3)
  {
    __nwlog_obj();
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
    v40 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v40, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v41 = objc_claimAutoreleasedReturnValue();
        v42 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
          _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v54)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v41 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        v45 = os_log_type_enabled(v41, type);
        if (backtrace_string)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
            v58 = 2082;
            v59 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v41, v44, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_58;
        }
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
          _os_log_impl(&dword_182FBE000, v41, v44, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v41 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        if (os_log_type_enabled(v41, type))
        {
          *(_DWORD *)buf = 136446210;
          v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
          _os_log_impl(&dword_182FBE000, v41, v46, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_58:
    if (v40)
      free(v40);
    return;
  }
  v7 = v3;
  v8 = v7[29];

  if ((_DWORD)v8 == 4)
  {
    v9 = nw_endpoint_handler_copy_fallback(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
    v10 = v9;
    v11 = *((_QWORD *)v9 + 1);
    v12 = __CFADD__(v11, a3);
    v13 = v11 + a3;
    if (v12)
      v14 = 1;
    else
      v14 = a2;
    if (v12)
      v13 = -1;
    *((_DWORD *)v9 + 26) = v14;
    *((_QWORD *)v9 + 1) = v13;
    if (a2 == 2)
    {
      v37 = *((_QWORD *)v9 + 11);
      v38 = dispatch_time(0x8000000000000000, 1000000 * *((_QWORD *)v9 + 2));
      nw_queue_set_timer_values(v37, v38, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      goto LABEL_32;
    }
    if (a2 != 1)
    {
      if (!a2)
      {
        if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1)
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
          v16 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
            v18 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
            v19 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
            logging_description = nw_endpoint_get_logging_description(v19);
            v21 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
            v22 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
            v23 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
            *(_DWORD *)buf = 136447746;
            v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
            v58 = 2082;
            v59 = (void *)id_string;
            v60 = 2082;
            v61 = v18;
            v62 = 2082;
            v63 = logging_description;
            v64 = 2082;
            v65 = v21;
            v66 = 2082;
            v67 = v22;
            v68 = 2114;
            v69 = v23;
            _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback no longer allowed for connection, cancelling", buf, 0x48u);

          }
        }
        v24 = *((_QWORD *)v10 + 11);
        if (v24)
        {
          nw_queue_cancel_source(v24, v15);
          *((_QWORD *)v10 + 11) = 0;
        }
        nw_endpoint_handler_cancel(*((void **)v10 + 5), 0, 1);
      }
      goto LABEL_32;
    }
    minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 32));
    logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
    if (minimize_logging)
    {
      if ((logging_disabled & 1) != 0)
        goto LABEL_32;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v29 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        v47 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        v48 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        v49 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        v50 = nw_endpoint_get_logging_description(v49);
        v51 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        v52 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        v53 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136447746;
        v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
        v58 = 2082;
        v59 = (void *)v47;
        v60 = 2082;
        v61 = v48;
        v62 = 2082;
        v63 = v50;
        v64 = 2082;
        v65 = v51;
        v66 = 2082;
        v67 = v52;
        v68 = 2114;
        v69 = v53;
        _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback now allowed for connection with no cap", buf, 0x48u);

      }
    }
    else
    {
      if ((logging_disabled & 1) != 0)
      {
LABEL_32:

        return;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v29 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        v30 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        v31 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        v32 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        v33 = nw_endpoint_get_logging_description(v32);
        v34 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        v35 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        v36 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136447746;
        v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
        v58 = 2082;
        v59 = (void *)v30;
        v60 = 2082;
        v61 = v31;
        v62 = 2082;
        v63 = v33;
        v64 = 2082;
        v65 = v34;
        v66 = 2082;
        v67 = v35;
        v68 = 2114;
        v69 = v36;
        _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] fallback now allowed for connection with no cap", buf, 0x48u);

      }
    }

    goto LABEL_32;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v25 = (id)gLogObj;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    if (v8 > 5)
      v26 = "unknown-mode";
    else
      v26 = off_1E149FC18[v8];
    *(_DWORD *)buf = 136446722;
    v57 = "nw_endpoint_fallback_check_usage_cap_block_invoke";
    v58 = 2082;
    v59 = (void *)v26;
    v60 = 2082;
    v61 = "fallback";
    _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

}

void sub_1836F0ADC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL47nw_endpoint_fallback_start_post_transport_timerP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1)
{
  _WORD *v1;

  v1 = *(_WORD **)(a1 + 32);
  *((_DWORD *)v1 + 20) = 327685;
  nw_endpoint_handler_report(v1, 0, v1 + 40, 0);
}

uint64_t nw_endpoint_fallback_get_timeout_nanos_for_path(void *a1)
{
  id v1;
  void *v2;
  _BYTE *v3;
  char v4;
  unint64_t v5;
  unint64_t int64_with_default;
  uint64_t v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1;
    v4 = v3[473];

    if ((v4 & 1) != 0)
    {
      int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_tcpconn_weak_fallback_delay, 200);
      v5 = networkd_settings_get_int64_with_default(nw_setting_tcpconn_fallback_delay_cap_ms, 500);
      v7 = 2 * int64_with_default;
      if (2 * int64_with_default >= v5)
        v7 = v5;
      if (int64_with_default <= 0x7FFFFFFFFFFFFFFELL)
        v5 = v7;
    }
    else
    {
      v5 = networkd_settings_get_int64_with_default(nw_setting_tcpconn_strong_fallback_delay, 100);
    }
    v8 = 1000000 * v5;
    goto LABEL_9;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_endpoint_fallback_get_timeout_nanos_for_path";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_26:
  if (v11)
    free(v11);
  v8 = 0;
LABEL_9:

  return v8;
}

void nw_endpoint_fallback_reset_expected_progress_target(void *a1, uint64_t a2)
{
  NWConcrete_nw_endpoint_handler *v3;
  NWConcrete_nw_endpoint_handler *v4;
  unsigned int mode;
  NWConcrete_nw_endpoint_mode_handler *v6;
  NWConcrete_nw_endpoint_mode_handler *v7;
  int64_t int64_with_default;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unint64_t v18;
  int64_t v19;
  int64_t v20;
  NWConcrete_nw_endpoint_handler *v21;
  char v22;
  NSObject *v23;
  NWConcrete_nw_endpoint_handler *v24;
  NWConcrete_nw_endpoint_handler *v25;
  char v26;
  const char *v27;
  nw_endpoint_t v28;
  const char *v29;
  char *id_str;
  unsigned int *v31;
  unsigned int *v32;
  uint64_t v33;
  const char *v34;
  void **v35;
  void **v36;
  unint64_t v37;
  const char *v38;
  void **v39;
  id v40;
  uint64_t v41;
  dispatch_time_t v42;
  void *v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  char *backtrace_string;
  os_log_type_t v48;
  _BOOL4 v49;
  os_log_type_t v50;
  id v51;
  const char *v52;
  void *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  char *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  const char *v60;
  os_log_type_t v61;
  const char *v62;
  const char *v63;
  unint64_t v64;
  const char *v65;
  nw_endpoint_t v66;
  const char *logging_description;
  const char *v68;
  const char *v69;
  id v70;
  const char *v71;
  NSObject *log;
  const char *id_string;
  char v74;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v77;
  __int16 v78;
  void *v79;
  __int16 v80;
  const char *v81;
  __int16 v82;
  void *v83;
  __int16 v84;
  const char *v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  id v89;
  __int16 v90;
  unint64_t v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v77 = "nw_endpoint_handler_get_mode";
    v44 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v74 = 0;
    if (__nwlog_fault(v44, &type, &v74))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v45 = objc_claimAutoreleasedReturnValue();
        v46 = type;
        if (os_log_type_enabled(v45, type))
        {
          *(_DWORD *)buf = 136446210;
          v77 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v74)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v45 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        v49 = os_log_type_enabled(v45, type);
        if (backtrace_string)
        {
          if (v49)
          {
            *(_DWORD *)buf = 136446466;
            v77 = "nw_endpoint_handler_get_mode";
            v78 = 2082;
            v79 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v45, v48, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_55;
        }
        if (v49)
        {
          *(_DWORD *)buf = 136446210;
          v77 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v45, v48, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v45 = objc_claimAutoreleasedReturnValue();
        v50 = type;
        if (os_log_type_enabled(v45, type))
        {
          *(_DWORD *)buf = 136446210;
          v77 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_182FBE000, v45, v50, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_55:
    if (v44)
      free(v44);
    mode = 0;
    goto LABEL_58;
  }
  mode = v3->mode;

  if (mode == 4)
  {
    v6 = nw_endpoint_handler_copy_fallback(v4);
    v7 = v6;
    if ((*((_BYTE *)v6 + 108) & 0x42) != 2 || !a2 || !*((_QWORD *)v6 + 9))
      goto LABEL_38;
    int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_progress_target_fallback_leeway, 2500);
    v9 = *((_QWORD *)v7 + 12);
    v10 = mach_continuous_time();
    if (v10 <= 1)
      v11 = 1;
    else
      v11 = v10;
    v12 = nw_delta_nanos(v9, v11);
    v13 = *((_QWORD *)v7 + 3);
    v14 = v13 >= v12;
    v15 = v13 - v12;
    if (!v14)
      v15 = 0;
    v16 = v15 + 1000000 * int64_with_default;
    v17 = dword_1ECD84D64;
    if (!dword_1ECD84D64)
    {
      mach_timebase_info((mach_timebase_info_t)&time_base);
      v17 = dword_1ECD84D64;
    }
    v18 = time_base;
    if (mach_continuous_time() + v16 * v17 / v18 <= a2)
      goto LABEL_38;
    v19 = networkd_settings_get_int64_with_default(nw_setting_tcpconn_strong_fallback_delay, 100);
    if (1000000 * v19 >= v12)
      v20 = 1000000 * v19 - v12;
    else
      v20 = 0;
    if ((nw_endpoint_handler_get_minimize_logging(v4) & 1) != 0)
    {
      if ((nw_endpoint_handler_get_logging_disabled(v4) & 1) != 0)
        goto LABEL_37;
      v64 = v20;
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v23 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v4);
        v65 = nw_endpoint_handler_dry_run_string(v4);
        v66 = nw_endpoint_handler_copy_endpoint(v4);
        logging_description = nw_endpoint_get_logging_description(v66);
        v68 = nw_endpoint_handler_state_string(v4);
        v69 = nw_endpoint_handler_mode_string(v4);
        v70 = nw_endpoint_handler_copy_current_path(v4);
        *(_DWORD *)buf = 136448002;
        v77 = "nw_endpoint_fallback_reset_expected_progress_target";
        v78 = 2082;
        v79 = (void *)id_string;
        v80 = 2082;
        v81 = v65;
        v82 = 2082;
        v83 = (void *)logging_description;
        v84 = 2082;
        v85 = v68;
        v86 = 2082;
        v87 = v69;
        v20 = v64;
        v88 = 2114;
        v89 = v70;
        v90 = 2048;
        v91 = v64 / 0xF4240;
        _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] target time set, resetting fallback timer to %llums", buf, 0x52u);

      }
    }
    else
    {
      v21 = v4;
      v22 = *((_BYTE *)v21 + 268);

      if ((v22 & 0x20) != 0)
      {
LABEL_37:
        v41 = *((_QWORD *)v7 + 9);
        v42 = dispatch_time(0x8000000000000000, v20);
        nw_queue_set_timer_values(v41, v42, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
LABEL_38:

        goto LABEL_92;
      }
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v23 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
      {
        v24 = v21;

        v25 = v24;
        v26 = *((_BYTE *)v21 + 268);

        if ((v26 & 1) != 0)
          v27 = "dry-run ";
        else
          v27 = "";
        v28 = nw_endpoint_handler_copy_endpoint(v25);
        v29 = nw_endpoint_get_logging_description(v28);
        id_str = v24->id_str;
        v31 = v25;
        v32 = v31;
        v33 = v31[30];
        if (v33 > 5)
          v34 = "unknown-state";
        else
          v34 = off_1E149FC48[v33];
        v71 = v34;

        v35 = v32;
        v36 = v35;
        log = v23;
        v37 = v20;
        v38 = "path";
        switch(v4->mode)
        {
          case 0:
            break;
          case 1:
            v38 = "resolver";
            break;
          case 2:
            v38 = nw_endpoint_flow_mode_string(v35[31]);
            break;
          case 3:
            v38 = "proxy";
            break;
          case 4:
            v38 = "fallback";
            break;
          case 5:
            v38 = "transform";
            break;
          default:
            v38 = "unknown-mode";
            break;
        }

        v39 = v36;
        os_unfair_lock_lock((os_unfair_lock_t)v39 + 28);
        v40 = v39[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v39 + 28);

        *(_DWORD *)buf = 136448002;
        v77 = "nw_endpoint_fallback_reset_expected_progress_target";
        v78 = 2082;
        v79 = id_str;
        v80 = 2082;
        v81 = v27;
        v82 = 2082;
        v83 = (void *)v29;
        v84 = 2082;
        v85 = v71;
        v86 = 2082;
        v87 = v38;
        v20 = v37;
        v88 = 2114;
        v89 = v40;
        v90 = 2048;
        v91 = v37 / 0xF4240;
        v23 = log;
        _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] target time set, resetting fallback timer to %llums", buf, 0x52u);

      }
    }

    goto LABEL_37;
  }
LABEL_58:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v51 = (id)gLogObj;
  if (mode > 5)
    v52 = "unknown-mode";
  else
    v52 = off_1E149FC18[mode];
  *(_DWORD *)buf = 136446722;
  v77 = "nw_endpoint_fallback_reset_expected_progress_target";
  v78 = 2082;
  v79 = (void *)v52;
  v80 = 2082;
  v81 = "fallback";
  v53 = (void *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v74 = 0;
  if (!__nwlog_fault((const char *)v53, &type, &v74))
  {
LABEL_90:
    if (!v53)
      goto LABEL_92;
LABEL_91:
    free(v53);
    goto LABEL_92;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v54 = (id)gLogObj;
    v55 = type;
    if (os_log_type_enabled(v54, type))
    {
      if (mode > 5)
        v56 = "unknown-mode";
      else
        v56 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v77 = "nw_endpoint_fallback_reset_expected_progress_target";
      v78 = 2082;
      v79 = (void *)v56;
      v80 = 2082;
      v81 = "fallback";
      _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_89:

    goto LABEL_90;
  }
  if (!v74)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v54 = (id)gLogObj;
    v61 = type;
    if (os_log_type_enabled(v54, type))
    {
      if (mode > 5)
        v62 = "unknown-mode";
      else
        v62 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v77 = "nw_endpoint_fallback_reset_expected_progress_target";
      v78 = 2082;
      v79 = (void *)v62;
      v80 = 2082;
      v81 = "fallback";
      _os_log_impl(&dword_182FBE000, v54, v61, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_89;
  }
  v57 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v54 = (id)gLogObj;
  v58 = type;
  v59 = os_log_type_enabled(v54, type);
  if (!v57)
  {
    if (v59)
    {
      if (mode > 5)
        v63 = "unknown-mode";
      else
        v63 = off_1E149FC18[mode];
      *(_DWORD *)buf = 136446722;
      v77 = "nw_endpoint_fallback_reset_expected_progress_target";
      v78 = 2082;
      v79 = (void *)v63;
      v80 = 2082;
      v81 = "fallback";
      _os_log_impl(&dword_182FBE000, v54, v58, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_89;
  }
  if (v59)
  {
    if (mode > 5)
      v60 = "unknown-mode";
    else
      v60 = off_1E149FC18[mode];
    *(_DWORD *)buf = 136446978;
    v77 = "nw_endpoint_fallback_reset_expected_progress_target";
    v78 = 2082;
    v79 = (void *)v60;
    v80 = 2082;
    v81 = "fallback";
    v82 = 2082;
    v83 = v57;
    _os_log_impl(&dword_182FBE000, v54, v58, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v57);
  if (v53)
    goto LABEL_91;
LABEL_92:

}

void sub_1836F18E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

__int128 *nw_protocol_http2_transport_identifier()
{
  if (nw_protocol_http2_transport_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_http2_transport_identifier::onceToken, &__block_literal_global_36847);
  return &g_http2_transport_protocol_identifier;
}

BOOL __nw_protocol_http2_transport_identifier_block_invoke()
{
  strcpy((char *)&g_http2_transport_protocol_identifier, "http2_transport");
  qword_1EDCE34A8 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCE34B0 = nw_protocol_default_input_flush;
  qword_1EDCE3478 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCE3480 = nw_protocol_default_waiting_for_output;
  qword_1EDCE3438 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCE3440 = nw_protocol_default_unregister_notification;
  qword_1EDCE33C8 = (uint64_t)nw_protocol_http2_transport_disconnect;
  unk_1EDCE33D0 = nw_protocol_http2_transport_connected;
  qword_1EDCE3468 = (uint64_t)nw_protocol_http2_transport_output_finished;
  unk_1EDCE3470 = nw_protocol_default_get_output_local;
  qword_1EDCE3458 = (uint64_t)nw_protocol_default_supports_external_data;
  unk_1EDCE3460 = nw_protocol_http2_transport_input_finished;
  g_http2_transport_protocol_callbacks = (uint64_t)nw_protocol_http2_transport_add_input_handler;
  unk_1EDCE33B0 = nw_protocol_http2_transport_remove_input_handler;
  qword_1EDCE33B8 = (uint64_t)nw_protocol_http2_replace_input_handler;
  unk_1EDCE33C0 = nw_protocol_http2_transport_connect;
  qword_1EDCE33E8 = (uint64_t)nw_protocol_http2_transport_input_available;
  unk_1EDCE33F0 = nw_protocol_http2_transport_output_available;
  qword_1EDCE33F8 = (uint64_t)nw_protocol_http2_transport_get_input_frames;
  unk_1EDCE3400 = nw_protocol_http2_transport_get_output_frames;
  qword_1EDCE3418 = (uint64_t)nw_protocol_http2_transport_get_parameters;
  unk_1EDCE3420 = nw_protocol_default_get_path;
  qword_1EDCE3408 = (uint64_t)nw_protocol_http2_transport_finalize_output_frames;
  unk_1EDCE3410 = nw_protocol_default_link_state;
  qword_1EDCE3488 = (uint64_t)nw_protocol_default_copy_info;
  unk_1EDCE3490 = nw_protocol_http2_transport_add_listen_handler;
  qword_1EDCE3498 = (uint64_t)nw_protocol_http2_transport_remove_listen_handler;
  unk_1EDCE34A0 = nw_protocol_default_get_message_properties;
  qword_1EDCE3428 = (uint64_t)nw_protocol_default_get_local;
  unk_1EDCE3430 = nw_protocol_http2_transport_get_remote_endpoint;
  qword_1EDCE33D8 = (uint64_t)nw_protocol_http2_transport_disconnected;
  unk_1EDCE33E0 = nw_protocol_http2_transport_error;
  qword_1EDCE3448 = (uint64_t)nw_protocol_http2_transport_notify;
  unk_1EDCE3450 = nw_protocol_default_updated_path;
  qword_1EDCE34E0 = 0x200000003;
  return nw_protocol_register_many_to_one((uint64_t)&g_http2_transport_protocol_identifier, (uint64_t)nw_protocol_http2_transport_create, (uint64_t)nw_protocol_http2_transport_accept);
}

BOOL nw_protocol_http2_transport_connect(nw_protocol *a1, nw_protocol *a2)
{
  _BYTE *handle;
  _QWORD *output_handler_context;
  uint64_t v6;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  void (*connect)(void);
  _BOOL8 result;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  char *v18;
  const char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  char *v23;
  _BOOL4 v24;
  _BOOL4 v25;
  char *v26;
  const char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  NSObject *v31;
  nw_protocol *v32;
  const char *v33;
  nw_protocol_identifier *identifier;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  nw_protocol *v38;
  const char *v39;
  nw_protocol_identifier *v40;
  const char *v41;
  char *backtrace_string;
  _BOOL4 v43;
  const char *v44;
  _BOOL4 v45;
  NSObject *v46;
  _BOOL4 v47;
  char *v48;
  _BOOL4 v49;
  nw_protocol *v50;
  const char *v51;
  nw_protocol_identifier *v52;
  nw_protocol *v53;
  const char *v54;
  nw_protocol_identifier *v55;
  NSObject *v56;
  int v57;
  nw_protocol *v58;
  const char *v59;
  nw_protocol_identifier *v60;
  char v61;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v64;
  __int16 v65;
  char *v66;
  __int16 v67;
  _BYTE v68[18];
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v64 = "nw_protocol_http2_transport_connect";
    v27 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (!__nwlog_fault(v27, &type, &v61))
      goto LABEL_116;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_116;
      *(_DWORD *)buf = 136446210;
      v64 = "nw_protocol_http2_transport_connect";
      v30 = "%{public}s called with null protocol";
LABEL_115:
      _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0xCu);
      goto LABEL_116;
    }
    if (!v61)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http2_transport_connect";
        v30 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_115;
      }
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = type;
    v43 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http2_transport_connect";
        v30 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_115;
      }
      goto LABEL_116;
    }
    if (!v43)
      goto LABEL_94;
    *(_DWORD *)buf = 136446466;
    v64 = "nw_protocol_http2_transport_connect";
    v65 = 2082;
    v66 = backtrace_string;
    v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_93:
    _os_log_impl(&dword_182FBE000, v28, v29, v44, buf, 0x16u);
    goto LABEL_94;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v64 = "nw_protocol_http2_transport_connect";
    v27 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (!__nwlog_fault(v27, &type, &v61))
      goto LABEL_116;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (!os_log_type_enabled(v28, type))
        goto LABEL_116;
      *(_DWORD *)buf = 136446210;
      v64 = "nw_protocol_http2_transport_connect";
      v30 = "%{public}s called with null http2_transport";
      goto LABEL_115;
    }
    if (!v61)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http2_transport_connect";
        v30 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_115;
      }
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = type;
    v45 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http2_transport_connect";
        v30 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_115;
      }
      goto LABEL_116;
    }
    if (!v45)
      goto LABEL_94;
    *(_DWORD *)buf = 136446466;
    v64 = "nw_protocol_http2_transport_connect";
    v65 = 2082;
    v66 = backtrace_string;
    v44 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_93;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v64 = "nw_protocol_http2_transport_connect";
    v27 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (!__nwlog_fault(v27, &type, &v61))
      goto LABEL_116;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http2_transport_connect";
        v30 = "%{public}s called with null other_protocol";
        goto LABEL_115;
      }
LABEL_116:
      if (!v27)
        return 0;
      v26 = (char *)v27;
      goto LABEL_53;
    }
    if (!v61)
    {
      v28 = __nwlog_obj();
      v29 = type;
      if (os_log_type_enabled(v28, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http2_transport_connect";
        v30 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_115;
      }
      goto LABEL_116;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = type;
    v47 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_protocol_http2_transport_connect";
        v30 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_115;
      }
      goto LABEL_116;
    }
    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      v66 = backtrace_string;
      v44 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_93;
    }
LABEL_94:
    free(backtrace_string);
    goto LABEL_116;
  }
  if (gLogDatapath)
  {
    v31 = __nwlog_obj();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      v66 = handle + 205;
      _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  if ((handle[204] & 4) != 0)
  {
    if (gLogDatapath)
    {
      v46 = __nwlog_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v64 = "nw_protocol_http2_transport_connect";
        v65 = 2082;
        v66 = handle + 205;
        _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s tunnel already closed, ignoring connect with success", buf, 0x16u);
      }
    }
    return 1;
  }
  output_handler_context = a2->output_handler_context;
  if ((handle[204] & 2) == 0)
  {
    if (!output_handler_context)
      goto LABEL_10;
    v6 = output_handler_context[4];
    if (v6)
    {
      *(_BYTE *)(v6 + 36) |= 2u;
      if (gLogDatapath)
      {
        v56 = __nwlog_obj();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
        {
          v57 = *(_DWORD *)(v6 + 32);
          *(_DWORD *)buf = 136446978;
          v64 = "nw_protocol_http2_transport_connect";
          v65 = 2082;
          v66 = handle + 205;
          v67 = 1024;
          *(_DWORD *)v68 = v57;
          *(_WORD *)&v68[4] = 2048;
          *(_QWORD *)&v68[6] = v6;
          _os_log_impl(&dword_182FBE000, v56, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s marked stream id %d (%p) as waiting for connect", buf, 0x26u);
        }
      }
LABEL_10:
      output_handler = a1->output_handler;
      if (output_handler)
      {
        callbacks = output_handler->callbacks;
        if (callbacks)
        {
          connect = (void (*)(void))callbacks->connect;
          if (connect)
          {
            connect();
            return 1;
          }
        }
      }
      __nwlog_obj();
      v32 = a1->output_handler;
      v33 = "invalid";
      if (v32)
      {
        identifier = v32->identifier;
        if (identifier)
          v33 = (const char *)identifier;
      }
      *(_DWORD *)buf = 136446466;
      v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      v66 = (char *)v33;
      v35 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (__nwlog_fault(v35, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v36 = __nwlog_obj();
          v37 = type;
          if (!os_log_type_enabled(v36, type))
            goto LABEL_131;
          v38 = a1->output_handler;
          v39 = "invalid";
          if (v38)
          {
            v40 = v38->identifier;
            if (v40)
              v39 = (const char *)v40;
          }
          *(_DWORD *)buf = 136446466;
          v64 = "nw_protocol_http2_transport_connect";
          v65 = 2082;
          v66 = (char *)v39;
          v41 = "%{public}s protocol %{public}s has invalid connect callback";
          goto LABEL_130;
        }
        if (!v61)
        {
          v36 = __nwlog_obj();
          v37 = type;
          if (!os_log_type_enabled(v36, type))
            goto LABEL_131;
          v53 = a1->output_handler;
          v54 = "invalid";
          if (v53)
          {
            v55 = v53->identifier;
            if (v55)
              v54 = (const char *)v55;
          }
          *(_DWORD *)buf = 136446466;
          v64 = "nw_protocol_http2_transport_connect";
          v65 = 2082;
          v66 = (char *)v54;
          v41 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
          goto LABEL_130;
        }
        v48 = (char *)__nw_create_backtrace_string();
        v36 = __nwlog_obj();
        v37 = type;
        v49 = os_log_type_enabled(v36, type);
        if (v48)
        {
          if (v49)
          {
            v50 = a1->output_handler;
            v51 = "invalid";
            if (v50)
            {
              v52 = v50->identifier;
              if (v52)
                v51 = (const char *)v52;
            }
            *(_DWORD *)buf = 136446722;
            v64 = "nw_protocol_http2_transport_connect";
            v65 = 2082;
            v66 = (char *)v51;
            v67 = 2082;
            *(_QWORD *)v68 = v48;
            _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v48);
          goto LABEL_131;
        }
        if (v49)
        {
          v58 = a1->output_handler;
          v59 = "invalid";
          if (v58)
          {
            v60 = v58->identifier;
            if (v60)
              v59 = (const char *)v60;
          }
          *(_DWORD *)buf = 136446466;
          v64 = "nw_protocol_http2_transport_connect";
          v65 = 2082;
          v66 = (char *)v59;
          v41 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
LABEL_130:
          _os_log_impl(&dword_182FBE000, v36, v37, v41, buf, 0x16u);
        }
      }
LABEL_131:
      if (v35)
        free(v35);
      return 1;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = handle + 205;
    *(_DWORD *)buf = 136446722;
    v64 = "nw_protocol_http2_transport_connect";
    v65 = 2082;
    v66 = handle + 205;
    v67 = 2048;
    *(_QWORD *)v68 = a2;
    v19 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v61 = 0;
    if (!__nwlog_fault(v19, &type, &v61))
      goto LABEL_51;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = gLogObj;
      v21 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
LABEL_28:
        *(_DWORD *)buf = 136446722;
        v64 = "nw_protocol_http2_transport_connect";
        v65 = 2082;
        v66 = v18;
        v67 = 2048;
        *(_QWORD *)v68 = a2;
        v22 = "%{public}s %{public}s hash node for protocol %p did not have stream as extra";
LABEL_50:
        _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0x20u);
      }
LABEL_51:
      if (!v19)
        return 0;
      v26 = (char *)v19;
LABEL_53:
      free(v26);
      return 0;
    }
    if (v61)
    {
      v23 = (char *)__nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v21 = type;
      v24 = os_log_type_enabled(v20, type);
      if (v23)
      {
        if (v24)
          goto LABEL_40;
        goto LABEL_41;
      }
      if (!v24)
        goto LABEL_51;
      goto LABEL_49;
    }
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_51;
    goto LABEL_43;
  }
  if (output_handler_context)
  {
    v11 = output_handler_context[4];
    if (!v11)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = handle + 205;
      *(_DWORD *)buf = 136446722;
      v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      v66 = handle + 205;
      v67 = 2048;
      *(_QWORD *)v68 = a2;
      v19 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (!__nwlog_fault(v19, &type, &v61))
        goto LABEL_51;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v20 = gLogObj;
        v21 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_28;
        goto LABEL_51;
      }
      if (v61)
      {
        v23 = (char *)__nw_create_backtrace_string();
        v20 = __nwlog_obj();
        v21 = type;
        v25 = os_log_type_enabled(v20, type);
        if (v23)
        {
          if (v25)
          {
LABEL_40:
            *(_DWORD *)buf = 136446978;
            v64 = "nw_protocol_http2_transport_connect";
            v65 = 2082;
            v66 = v18;
            v67 = 2048;
            *(_QWORD *)v68 = a2;
            *(_WORD *)&v68[8] = 2082;
            *(_QWORD *)&v68[10] = v23;
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s %{public}s hash node for protocol %p did not have stream as extra, dumping backtrace:%{public}s", buf, 0x2Au);
          }
LABEL_41:
          free(v23);
          goto LABEL_51;
        }
        if (!v25)
          goto LABEL_51;
LABEL_49:
        *(_DWORD *)buf = 136446722;
        v64 = "nw_protocol_http2_transport_connect";
        v65 = 2082;
        v66 = v18;
        v67 = 2048;
        *(_QWORD *)v68 = a2;
        v22 = "%{public}s %{public}s hash node for protocol %p did not have stream as extra, no backtrace";
        goto LABEL_50;
      }
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_51;
LABEL_43:
      *(_DWORD *)buf = 136446722;
      v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      v66 = v18;
      v67 = 2048;
      *(_QWORD *)v68 = a2;
      v22 = "%{public}s %{public}s hash node for protocol %p did not have stream as extra, backtrace limit exceeded";
      goto LABEL_50;
    }
    if (nw_http2_transport_stream_connect((uint64_t)handle, output_handler_context[4], (uint64_t)a2))
      return 1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v13 = *(_DWORD *)(v11 + 32);
      *(_DWORD *)buf = 136446978;
      v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      v66 = handle + 205;
      v67 = 1024;
      *(_DWORD *)v68 = v13;
      *(_WORD *)&v68[4] = 2048;
      *(_QWORD *)&v68[6] = v11;
      v14 = "%{public}s %{public}s nw_http2_transport_stream_connect failed for stream id %d (%p)";
      v15 = v12;
      v16 = 38;
LABEL_24:
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, v14, buf, v16);
      return 0;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      *(_DWORD *)buf = 136446722;
      v64 = "nw_protocol_http2_transport_connect";
      v65 = 2082;
      v66 = handle + 205;
      v67 = 2048;
      *(_QWORD *)v68 = a2;
      v14 = "%{public}s %{public}s connect called on protocol %p which is not in protocol hash table";
      v15 = v17;
      v16 = 32;
      goto LABEL_24;
    }
  }
  return result;
}

void nw_protocol_http2_transport_connected(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*connected)(void);
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  char v12;
  char *v13;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  NSObject *v23;
  char *v24;
  _BOOL4 v25;
  char *backtrace_string;
  _BOOL4 v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  _BOOL4 v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  char v35;
  os_log_type_t type;
  _BYTE buf[24];
  char *v38;
  _QWORD *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v19, &type, &v35))
      goto LABEL_98;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      v22 = "%{public}s called with null protocol";
    }
    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v21 = type;
      v27 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_98:
        if (!v19)
          return;
        goto LABEL_99;
      }
      if (!v27)
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      v22 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      v22 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_97;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v19, &type, &v35))
      goto LABEL_98;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v35)
      {
        v20 = __nwlog_obj();
        v21 = type;
        if (!os_log_type_enabled(v20, type))
          goto LABEL_98;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
        v22 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_97;
      }
      v28 = (char *)__nw_create_backtrace_string();
      v20 = __nwlog_obj();
      v21 = type;
      v29 = os_log_type_enabled(v20, type);
      if (!v28)
      {
        if (!v29)
          goto LABEL_98;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
        v22 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_97;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v28;
        v30 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_68:
        _os_log_impl(&dword_182FBE000, v20, v21, v30, buf, 0x16u);
      }
LABEL_69:
      free(v28);
      if (!v19)
        return;
LABEL_99:
      free(v19);
      return;
    }
    v20 = __nwlog_obj();
    v21 = type;
    if (!os_log_type_enabled(v20, type))
      goto LABEL_98;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
    v22 = "%{public}s called with null http2_transport";
LABEL_97:
    _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
    goto LABEL_98;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v19, &type, &v35))
      goto LABEL_98;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      v22 = "%{public}s called with null other_protocol";
      goto LABEL_97;
    }
    if (!v35)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      v22 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_97;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type;
    v31 = os_log_type_enabled(v20, type);
    if (!v28)
    {
      if (!v31)
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      v22 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_97;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v28;
      v30 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_68;
    }
    goto LABEL_69;
  }
  if (gLogDatapath)
  {
    v23 = __nwlog_obj();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)handle + 205;
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      connected = (void (*)(void))callbacks->connected;
      if (connected)
      {
        connected();
        goto LABEL_9;
      }
    }
  }
  if (nw_hash_table_count(handle[14], (uint64_t)a2))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = (char *)handle + 205;
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v15, &type, &v35))
      goto LABEL_78;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_78;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)handle + 205;
      v18 = "%{public}s %{public}s Have remaining input handlers, but no connected callback on the default input handler";
    }
    else if (v35)
    {
      v24 = (char *)__nw_create_backtrace_string();
      v16 = __nwlog_obj();
      v17 = type;
      v25 = os_log_type_enabled(v16, type);
      if (v24)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = (char *)handle + 205;
          *(_WORD *)&buf[22] = 2082;
          v38 = v24;
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s %{public}s Have remaining input handlers, but no connected callback on the default input handler, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v24);
        goto LABEL_78;
      }
      if (!v25)
      {
LABEL_78:
        if (v15)
          free(v15);
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)handle + 205;
      v18 = "%{public}s %{public}s Have remaining input handlers, but no connected callback on the default input handler, no backtrace";
    }
    else
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_78;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)handle + 205;
      v18 = "%{public}s %{public}s Have remaining input handlers, but no connected callback on the default input handler,"
            " backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0x16u);
    goto LABEL_78;
  }
LABEL_80:
  v33 = __nwlog_obj();
  if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
    _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_INFO, "%{public}s No default input handler, skipping connected callback", buf, 0xCu);
  }
LABEL_9:
  if (a1->output_handler != a2)
  {
    if (gLogDatapath)
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)handle + 205;
        v9 = "%{public}s %{public}s connected protocol is not our output_handler, ignoring";
LABEL_24:
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, v9, buf, 0x16u);
        return;
      }
    }
    return;
  }
  if (gLogDatapath)
  {
    v32 = __nwlog_obj();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_process_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)handle + 205;
      _os_log_impl(&dword_182FBE000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  if ((*((_BYTE *)handle + 204) & 0x10) != 0)
  {
    if (!handle[13])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)handle + 205;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s no listen handler on server, deferring processing of input and connected state until listen handler is present", buf, 0x16u);
      }
      *((_BYTE *)handle + 204) |= 0x40u;
      return;
    }
    if (!gLogDatapath)
      goto LABEL_20;
    v10 = __nwlog_obj();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      goto LABEL_20;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_process_connected";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = (char *)handle + 205;
    v11 = "%{public}s %{public}s listen handler present, processing input without waiting";
    goto LABEL_92;
  }
  if (gLogDatapath)
  {
    v10 = __nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_process_connected";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = (char *)handle + 205;
      v11 = "%{public}s %{public}s not server, processing input without waiting";
LABEL_92:
      _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, v11, buf, 0x16u);
    }
  }
LABEL_20:
  v12 = *((_BYTE *)handle + 204);
  *((_BYTE *)handle + 204) = v12 & 0xBF;
  if ((v12 & 6) != 0)
  {
    if (gLogDatapath)
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)handle + 205;
        v9 = "%{public}s %{public}s tunnel already connected or closed, ignoring connected event";
        goto LABEL_24;
      }
    }
  }
  else
  {
    nw_http2_transport_send_settings((uint64_t)handle);
    *((_BYTE *)handle + 204) |= 2u;
    if (gLogDatapath)
    {
      v34 = __nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http2_transport_process_connected";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = (char *)handle + 205;
        _os_log_impl(&dword_182FBE000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s http2 tunnel is now connected", buf, 0x16u);
      }
    }
    nw_protocol_http2_transport_process_input((uint64_t)handle);
    v13 = (char *)handle[14];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZL45nw_protocol_http2_transport_process_connectedP27nw_protocol_http2_transport_block_invoke;
    v38 = (char *)&__block_descriptor_tmp_20_37773;
    v39 = handle;
    nw_hash_table_apply(v13, (uint64_t)buf);
  }
}

void nw_protocol_http2_transport_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  _QWORD *output_handler_context;
  uint64_t v5;
  nw_protocol_callbacks *callbacks;
  void (*disconnected)(nw_protocol *, char *);
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  NSObject *v17;
  nw_protocol_identifier *identifier;
  const char *v19;
  NSObject *v20;
  os_log_type_t v21;
  nw_protocol_identifier *v22;
  const char *v23;
  char *backtrace_string;
  _BOOL4 v25;
  char *v26;
  _BOOL4 v27;
  const char *v28;
  _BOOL4 v29;
  char *v30;
  _BOOL4 v31;
  nw_protocol_identifier *v32;
  nw_protocol_identifier *v33;
  char *v34;
  nw_protocol_identifier *v35;
  char v36;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  nw_protocol_identifier *v41;
  __int16 v42;
  nw_protocol *v43;
  __int16 v44;
  _QWORD *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_http2_transport_disconnect";
    v13 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36))
      goto LABEL_79;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_http2_transport_disconnect";
      v16 = "%{public}s called with null protocol";
    }
    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v25 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v39 = "nw_protocol_http2_transport_disconnect";
          v40 = 2082;
          v41 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_79:
        if (!v13)
          return;
        goto LABEL_80;
      }
      if (!v25)
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_http2_transport_disconnect";
      v16 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_http2_transport_disconnect";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_78;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_http2_transport_disconnect";
    v13 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36))
      goto LABEL_79;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v36)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_79;
        *(_DWORD *)buf = 136446210;
        v39 = "nw_protocol_http2_transport_disconnect";
        v16 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_78;
      }
      v26 = (char *)__nw_create_backtrace_string();
      v14 = __nwlog_obj();
      v15 = type;
      v27 = os_log_type_enabled(v14, type);
      if (!v26)
      {
        if (!v27)
          goto LABEL_79;
        *(_DWORD *)buf = 136446210;
        v39 = "nw_protocol_http2_transport_disconnect";
        v16 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_78;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        v39 = "nw_protocol_http2_transport_disconnect";
        v40 = 2082;
        v41 = (nw_protocol_identifier *)v26;
        v28 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_51:
        _os_log_impl(&dword_182FBE000, v14, v15, v28, buf, 0x16u);
      }
LABEL_52:
      free(v26);
      if (!v13)
        return;
LABEL_80:
      v34 = (char *)v13;
LABEL_88:
      free(v34);
      return;
    }
    v14 = __nwlog_obj();
    v15 = type;
    if (!os_log_type_enabled(v14, type))
      goto LABEL_79;
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_http2_transport_disconnect";
    v16 = "%{public}s called with null http2_transport";
LABEL_78:
    _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
    goto LABEL_79;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v39 = "nw_protocol_http2_transport_disconnect";
    v13 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v36 = 0;
    if (!__nwlog_fault(v13, &type, &v36))
      goto LABEL_79;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_http2_transport_disconnect";
      v16 = "%{public}s called with null other_protocol";
      goto LABEL_78;
    }
    if (!v36)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_http2_transport_disconnect";
      v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_78;
    }
    v26 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v29 = os_log_type_enabled(v14, type);
    if (!v26)
    {
      if (!v29)
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v39 = "nw_protocol_http2_transport_disconnect";
      v16 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_78;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v39 = "nw_protocol_http2_transport_disconnect";
      v40 = 2082;
      v41 = (nw_protocol_identifier *)v26;
      v28 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_51;
    }
    goto LABEL_52;
  }
  if (gLogDatapath)
  {
    v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v39 = "nw_protocol_http2_transport_disconnect";
      v40 = 2082;
      v41 = (nw_protocol_identifier *)(handle + 205);
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446466;
    v39 = "nw_protocol_http2_transport_disconnect";
    v40 = 2082;
    v41 = (nw_protocol_identifier *)(handle + 205);
    v9 = "%{public}s %{public}s attempting to disconnect on protocol that doesn't have entry in table, ignoring";
    v10 = v8;
    v11 = 22;
LABEL_14:
    _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
    return;
  }
  v5 = output_handler_context[4];
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446978;
    v39 = "nw_protocol_http2_transport_disconnect";
    v40 = 2082;
    v41 = (nw_protocol_identifier *)(handle + 205);
    v42 = 2048;
    v43 = a2;
    v44 = 2048;
    v45 = output_handler_context;
    v9 = "%{public}s %{public}s protocol (%p) node (%p) has no stream pointer as extra";
    v10 = v12;
    v11 = 42;
    goto LABEL_14;
  }
  nw_http2_transport_stream_close((uint64_t)handle, v5);
  callbacks = a2->callbacks;
  if (callbacks)
  {
    disconnected = (void (*)(nw_protocol *, char *))callbacks->disconnected;
    if (disconnected)
    {
      disconnected(a2, handle);
      return;
    }
  }
  __nwlog_obj();
  identifier = a2->identifier;
  if (!identifier)
    identifier = (nw_protocol_identifier *)"invalid";
  *(_DWORD *)buf = 136446466;
  v39 = "nw_protocol_http2_transport_disconnect";
  v40 = 2082;
  v41 = identifier;
  v19 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v36 = 0;
  if (__nwlog_fault(v19, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_86;
      v22 = a2->identifier;
      if (!v22)
        v22 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446466;
      v39 = "nw_protocol_http2_transport_disconnect";
      v40 = 2082;
      v41 = v22;
      v23 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_85:
      _os_log_impl(&dword_182FBE000, v20, v21, v23, buf, 0x16u);
      goto LABEL_86;
    }
    if (!v36)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_86;
      v33 = a2->identifier;
      if (!v33)
        v33 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446466;
      v39 = "nw_protocol_http2_transport_disconnect";
      v40 = 2082;
      v41 = v33;
      v23 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_85;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type;
    v31 = os_log_type_enabled(v20, type);
    if (!v30)
    {
      if (!v31)
        goto LABEL_86;
      v35 = a2->identifier;
      if (!v35)
        v35 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446466;
      v39 = "nw_protocol_http2_transport_disconnect";
      v40 = 2082;
      v41 = v35;
      v23 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
      goto LABEL_85;
    }
    if (v31)
    {
      if (a2->identifier)
        v32 = a2->identifier;
      else
        v32 = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446722;
      v39 = "nw_protocol_http2_transport_disconnect";
      v40 = 2082;
      v41 = v32;
      v42 = 2082;
      v43 = (nw_protocol *)v30;
      _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v30);
  }
LABEL_86:
  if (v19)
  {
    v34 = (char *)v19;
    goto LABEL_88;
  }
}

void nw_protocol_http2_transport_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v4;
  void (*v5)(void);
  char *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *v10;
  const char *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  NSObject *v16;
  char *backtrace_string;
  _BOOL4 v18;
  char *v19;
  char *v20;
  _BOOL4 v21;
  char *v22;
  _BOOL4 v23;
  char *v24;
  char *v25;
  char v26;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        v16 = __nwlog_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_http2_transport_disconnected";
          v30 = 2082;
          v31 = (char *)handle + 205;
          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
        }
      }
      nw_protocol_remove_instance((uint64_t)a1);
      v4 = handle[13];
      if (!v4)
        goto LABEL_8;
      if (*(_QWORD *)v4)
      {
        v5 = *(void (**)(void))(*(_QWORD *)v4 + 8);
        if (v5)
        {
          v5();
LABEL_8:
          nw_http2_transport_connection_close((uint64_t)handle);
          return;
        }
      }
      __nwlog_obj();
      v6 = (char *)handle[13];
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_http2_transport_disconnected";
      v30 = 2048;
      v31 = v6;
      v7 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v26 = 0;
      if (__nwlog_fault(v7, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v8 = __nwlog_obj();
          v9 = type;
          if (!os_log_type_enabled(v8, type))
            goto LABEL_49;
          v10 = (char *)handle[13];
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_http2_transport_disconnected";
          v30 = 2048;
          v31 = v10;
          v11 = "%{public}s listen protocol (%p) has invalid disconnected callback";
          goto LABEL_48;
        }
        if (!v26)
        {
          v8 = __nwlog_obj();
          v9 = type;
          if (!os_log_type_enabled(v8, type))
            goto LABEL_49;
          v24 = (char *)handle[13];
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_http2_transport_disconnected";
          v30 = 2048;
          v31 = v24;
          v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, backtrace limit exceeded";
          goto LABEL_48;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        v8 = __nwlog_obj();
        v9 = type;
        v18 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v18)
          {
            v19 = (char *)handle[13];
            *(_DWORD *)buf = 136446722;
            v29 = "nw_protocol_http2_transport_disconnected";
            v30 = 2048;
            v31 = v19;
            v32 = 2082;
            v33 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s listen protocol (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_49;
        }
        if (v18)
        {
          v25 = (char *)handle[13];
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_http2_transport_disconnected";
          v30 = 2048;
          v31 = v25;
          v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, no backtrace";
LABEL_48:
          _os_log_impl(&dword_182FBE000, v8, v9, v11, buf, 0x16u);
        }
      }
LABEL_49:
      if (v7)
        free(v7);
      goto LABEL_8;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_http2_transport_disconnected";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v12, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_56;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_http2_transport_disconnected";
        v15 = "%{public}s called with null http2_transport";
        goto LABEL_55;
      }
      if (!v26)
      {
        v13 = __nwlog_obj();
        v14 = type;
        if (!os_log_type_enabled(v13, type))
          goto LABEL_56;
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_http2_transport_disconnected";
        v15 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_55;
      }
      v22 = (char *)__nw_create_backtrace_string();
      v13 = __nwlog_obj();
      v14 = type;
      v23 = os_log_type_enabled(v13, type);
      if (v22)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_protocol_http2_transport_disconnected";
          v30 = 2082;
          v31 = v22;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v22);
        if (v12)
          goto LABEL_57;
        return;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v29 = "nw_protocol_http2_transport_disconnected";
        v15 = "%{public}s called with null http2_transport, no backtrace";
LABEL_55:
        _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v29 = "nw_protocol_http2_transport_disconnected";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v12, &type, &v26))
      goto LABEL_56;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_transport_disconnected";
      v15 = "%{public}s called with null protocol";
      goto LABEL_55;
    }
    if (!v26)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_transport_disconnected";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_55;
    }
    v20 = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v21 = os_log_type_enabled(v13, type);
    if (!v20)
    {
      if (!v21)
        goto LABEL_56;
      *(_DWORD *)buf = 136446210;
      v29 = "nw_protocol_http2_transport_disconnected";
      v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_55;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      v29 = "nw_protocol_http2_transport_disconnected";
      v30 = 2082;
      v31 = v20;
      _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v20);
  }
LABEL_56:
  if (v12)
LABEL_57:
    free(v12);
}

void nw_protocol_http2_transport_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  _QWORD *output_handler_context;
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  char *backtrace_string;
  _BOOL4 v14;
  char *v15;
  _BOOL4 v16;
  const char *v17;
  _BOOL4 v18;
  NSObject *v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_http2_transport_output_finished";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_60;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_http2_transport_output_finished";
      v11 = "%{public}s called with null protocol";
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v14 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_protocol_http2_transport_output_finished";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_60:
        if (!v8)
          return;
        goto LABEL_61;
      }
      if (!v14)
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_http2_transport_output_finished";
      v11 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_http2_transport_output_finished";
      v11 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_59;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_http2_transport_output_finished";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_60;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        v9 = __nwlog_obj();
        v10 = type;
        if (!os_log_type_enabled(v9, type))
          goto LABEL_60;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_http2_transport_output_finished";
        v11 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_59;
      }
      v15 = (char *)__nw_create_backtrace_string();
      v9 = __nwlog_obj();
      v10 = type;
      v16 = os_log_type_enabled(v9, type);
      if (!v15)
      {
        if (!v16)
          goto LABEL_60;
        *(_DWORD *)buf = 136446210;
        v23 = "nw_protocol_http2_transport_output_finished";
        v11 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_59;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        v23 = "nw_protocol_http2_transport_output_finished";
        v24 = 2082;
        v25 = v15;
        v17 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_42:
        _os_log_impl(&dword_182FBE000, v9, v10, v17, buf, 0x16u);
      }
LABEL_43:
      free(v15);
      if (!v8)
        return;
LABEL_61:
      free(v8);
      return;
    }
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_60;
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_http2_transport_output_finished";
    v11 = "%{public}s called with null http2_transport";
LABEL_59:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
    goto LABEL_60;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_protocol_http2_transport_output_finished";
    v8 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20))
      goto LABEL_60;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_http2_transport_output_finished";
      v11 = "%{public}s called with null other_protocol";
      goto LABEL_59;
    }
    if (!v20)
    {
      v9 = __nwlog_obj();
      v10 = type;
      if (!os_log_type_enabled(v9, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_http2_transport_output_finished";
      v11 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_59;
    }
    v15 = (char *)__nw_create_backtrace_string();
    v9 = __nwlog_obj();
    v10 = type;
    v18 = os_log_type_enabled(v9, type);
    if (!v15)
    {
      if (!v18)
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v23 = "nw_protocol_http2_transport_output_finished";
      v11 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_59;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_http2_transport_output_finished";
      v24 = 2082;
      v25 = v15;
      v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  if (gLogDatapath)
  {
    v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_http2_transport_output_finished";
      v24 = 2082;
      v25 = handle + 205;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446466;
    v23 = "nw_protocol_http2_transport_output_finished";
    v24 = 2082;
    v25 = handle + 205;
    v7 = "%{public}s %{public}s couldn't get output handler context during output_finished";
LABEL_13:
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, v7, buf, 0x16u);
    return;
  }
  v5 = output_handler_context[4];
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446466;
    v23 = "nw_protocol_http2_transport_output_finished";
    v24 = 2082;
    v25 = handle + 205;
    v7 = "%{public}s %{public}s couldn't get stream during output_finished";
    goto LABEL_13;
  }
  if (gLogDatapath)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v23 = "nw_protocol_http2_transport_output_finished";
      v24 = 2082;
      v25 = handle + 205;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s sending non-deferred end stream", buf, 0x16u);
    }
  }
  nw_http2_transport_send_end_stream((uint64_t)handle, v5);
}

void nw_protocol_http2_transport_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  NSObject *v3;
  char *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v8;
  NSObject *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  _BOOL4 v13;
  const char *v14;
  _BOOL4 v15;
  _QWORD v16[5];
  char v17;
  os_log_type_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_transport_input_finished";
    v5 = (char *)_os_log_send_and_compose_impl();
    v18 = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &v18, &v17))
      goto LABEL_53;
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = v18;
      if (!os_log_type_enabled(v6, v18))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_transport_input_finished";
      v8 = "%{public}s called with null protocol";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = v18;
      v11 = os_log_type_enabled(v6, v18);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_protocol_http2_transport_input_finished";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_53:
        if (!v5)
          return;
        goto LABEL_54;
      }
      if (!v11)
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_transport_input_finished";
      v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v6 = __nwlog_obj();
      v7 = v18;
      if (!os_log_type_enabled(v6, v18))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_transport_input_finished";
      v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_52;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_transport_input_finished";
    v5 = (char *)_os_log_send_and_compose_impl();
    v18 = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &v18, &v17))
      goto LABEL_53;
    if (v18 != OS_LOG_TYPE_FAULT)
    {
      if (!v17)
      {
        v6 = __nwlog_obj();
        v7 = v18;
        if (!os_log_type_enabled(v6, v18))
          goto LABEL_53;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_http2_transport_input_finished";
        v8 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_52;
      }
      v12 = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      v7 = v18;
      v13 = os_log_type_enabled(v6, v18);
      if (!v12)
      {
        if (!v13)
          goto LABEL_53;
        *(_DWORD *)buf = 136446210;
        v20 = "nw_protocol_http2_transport_input_finished";
        v8 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_52;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_protocol_http2_transport_input_finished";
        v21 = 2082;
        v22 = v12;
        v14 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
LABEL_37:
        _os_log_impl(&dword_182FBE000, v6, v7, v14, buf, 0x16u);
      }
LABEL_38:
      free(v12);
      if (!v5)
        return;
LABEL_54:
      free(v5);
      return;
    }
    v6 = __nwlog_obj();
    v7 = v18;
    if (!os_log_type_enabled(v6, v18))
      goto LABEL_53;
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_transport_input_finished";
    v8 = "%{public}s called with null http2_transport";
LABEL_52:
    _os_log_impl(&dword_182FBE000, v6, v7, v8, buf, 0xCu);
    goto LABEL_53;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_protocol_http2_transport_input_finished";
    v5 = (char *)_os_log_send_and_compose_impl();
    v18 = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v5, &v18, &v17))
      goto LABEL_53;
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      v7 = v18;
      if (!os_log_type_enabled(v6, v18))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_transport_input_finished";
      v8 = "%{public}s called with null other_protocol";
      goto LABEL_52;
    }
    if (!v17)
    {
      v6 = __nwlog_obj();
      v7 = v18;
      if (!os_log_type_enabled(v6, v18))
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_transport_input_finished";
      v8 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_52;
    }
    v12 = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    v7 = v18;
    v15 = os_log_type_enabled(v6, v18);
    if (!v12)
    {
      if (!v15)
        goto LABEL_53;
      *(_DWORD *)buf = 136446210;
      v20 = "nw_protocol_http2_transport_input_finished";
      v8 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_52;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_http2_transport_input_finished";
      v21 = 2082;
      v22 = v12;
      v14 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  if (gLogDatapath)
  {
    v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_http2_transport_input_finished";
      v21 = 2082;
      v22 = handle + 205;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
  }
  if ((handle[204] & 0x40) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v20 = "nw_protocol_http2_transport_input_finished";
      v21 = 2082;
      v22 = handle + 205;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s still waiting for listen handler, but input finished. Processing input anyway.", buf, 0x16u);
    }
  }
  nw_protocol_http2_transport_process_input((uint64_t)handle);
  v4 = (char *)*((_QWORD *)handle + 14);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZL42nw_protocol_http2_transport_input_finishedP11nw_protocolS0__block_invoke;
  v16[3] = &__block_descriptor_tmp_29_38212;
  v16[4] = handle;
  nw_hash_table_apply(v4, (uint64_t)v16);
}

BOOL nw_protocol_http2_transport_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_remote_endpoint)(nw_protocol *);
  void *v7;
  nw_protocol_callbacks *v8;
  uint64_t (*get_parameters)(nw_protocol *);
  void *v10;
  void *v11;
  _BYTE *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  NSObject *v19;
  _BOOL8 result;
  const char *v21;
  NSObject *v22;
  id v23;
  void *v24;
  unint64_t value;
  unint64_t v26;
  uint64_t internal;
  _BOOL8 v28;
  _QWORD *v29;
  uint64_t stream_node_from_id;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint64_t v39;
  int v40;
  const char *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  const char *v46;
  NSObject *v47;
  os_log_type_t v48;
  const char *v49;
  char *v50;
  _BOOL4 v51;
  NSObject *v52;
  char *v53;
  _BOOL4 v54;
  const char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  _QWORD *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  NSObject *v63;
  const char *v64;
  uint64_t v65;
  const char *v66;
  NSObject *v67;
  uint32_t v68;
  char *v69;
  _BOOL4 v70;
  NSObject *v71;
  char *v72;
  NSObject *v73;
  int v74;
  const char *v75;
  NSObject *v76;
  uint32_t v77;
  char *v78;
  _BOOL4 v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  int v86;
  char *v87;
  NSObject *v88;
  os_log_type_t v89;
  const char *v90;
  NSObject *v91;
  NSObject *v92;
  char *backtrace_string;
  _BOOL4 v94;
  const char *v95;
  _BOOL4 v96;
  _BOOL4 v97;
  NSObject *v98;
  NSObject *v99;
  NSObject *v100;
  NSObject *v101;
  NSObject *v102;
  void *v103;
  NSObject *v104;
  uint64_t v105;
  int v106;
  NSObject *v107;
  NSObject *v108;
  uint64_t v109;
  char v110;
  os_log_type_t v111;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v114;
  __int16 v115;
  uint64_t v116;
  __int16 v117;
  _BYTE v118[28];
  __int16 v119;
  int v120;
  __int16 v121;
  char *v122;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v87 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v111 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v87, &type, &v111))
      goto LABEL_198;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      v89 = type;
      if (!os_log_type_enabled(v88, type))
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null protocol";
      goto LABEL_197;
    }
    if (v111 == OS_LOG_TYPE_DEFAULT)
    {
      v88 = __nwlog_obj();
      v89 = type;
      if (!os_log_type_enabled(v88, type))
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_197;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    v89 = type;
    v94 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (!v94)
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_197;
    }
    if (!v94)
      goto LABEL_180;
    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)backtrace_string;
    v95 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_179:
    _os_log_impl(&dword_182FBE000, v88, v89, v95, buf, 0x16u);
    goto LABEL_180;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v87 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v111 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v87, &type, &v111))
      goto LABEL_198;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      v89 = type;
      if (!os_log_type_enabled(v88, type))
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null http2_transport";
      goto LABEL_197;
    }
    if (v111 == OS_LOG_TYPE_DEFAULT)
    {
      v88 = __nwlog_obj();
      v89 = type;
      if (!os_log_type_enabled(v88, type))
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null http2_transport, backtrace limit exceeded";
      goto LABEL_197;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    v89 = type;
    v96 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (!v96)
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null http2_transport, no backtrace";
      goto LABEL_197;
    }
    if (!v96)
      goto LABEL_180;
    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)backtrace_string;
    v95 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
    goto LABEL_179;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v87 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v111 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v87, &type, &v111))
      goto LABEL_198;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      v89 = type;
      if (!os_log_type_enabled(v88, type))
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null input_protocol";
      goto LABEL_197;
    }
    if (v111 == OS_LOG_TYPE_DEFAULT)
    {
      v88 = __nwlog_obj();
      v89 = type;
      if (!os_log_type_enabled(v88, type))
        goto LABEL_198;
      *(_DWORD *)buf = 136446210;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v90 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_197;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    v89 = type;
    v97 = os_log_type_enabled(v88, type);
    if (backtrace_string)
    {
      if (v97)
      {
        *(_DWORD *)buf = 136446466;
        v114 = "nw_protocol_http2_transport_add_input_handler";
        v115 = 2082;
        v116 = (uint64_t)backtrace_string;
        v95 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_179;
      }
LABEL_180:
      free(backtrace_string);
      goto LABEL_198;
    }
    if (!v97)
      goto LABEL_198;
    *(_DWORD *)buf = 136446210;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v90 = "%{public}s called with null input_protocol, no backtrace";
LABEL_197:
    _os_log_impl(&dword_182FBE000, v88, v89, v90, buf, 0xCu);
LABEL_198:
    if (v87)
      free(v87);
    return 0;
  }
  if (gLogDatapath)
  {
    v91 = __nwlog_obj();
    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      _os_log_impl(&dword_182FBE000, v91, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
    }
    if (gLogDatapath)
    {
      v92 = __nwlog_obj();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136447234;
        v114 = "nw_protocol_http2_transport_add_input_handler";
        v115 = 2082;
        v116 = (uint64_t)(handle + 205);
        v117 = 2048;
        *(_QWORD *)v118 = a2;
        *(_WORD *)&v118[8] = 1042;
        *(_DWORD *)&v118[10] = 16;
        *(_WORD *)&v118[14] = 2098;
        *(_QWORD *)&v118[16] = a2;
        _os_log_impl(&dword_182FBE000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s incoming protocol %p has flow id %{public,uuid_t}.16P", buf, 0x30u);
      }
    }
  }
  if (!*((_QWORD *)handle + 12))
  {
    callbacks = a2->callbacks;
    if (!callbacks
      || (get_remote_endpoint = (uint64_t (*)(nw_protocol *))callbacks->get_remote_endpoint) == 0
      || (v7 = (void *)get_remote_endpoint(a2)) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      *(_DWORD *)buf = 136446466;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v21 = "%{public}s %{public}s failed to get remote endpoint from input_handler";
      goto LABEL_137;
    }
    *((_QWORD *)handle + 12) = os_retain(v7);
  }
  v8 = a2->callbacks;
  if (!v8
    || (get_parameters = (uint64_t (*)(nw_protocol *))v8->get_parameters) == 0
    || (v10 = (void *)get_parameters(a2)) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)(handle + 205);
    v21 = "%{public}s %{public}s couldn't get parameters from input_protocol";
LABEL_137:
    _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, v21, buf, 0x16u);
    return 0;
  }
  v11 = v10;
  v12 = handle + 205;
  if (!handle[205])
  {
    v13 = nw_parameters_copy_protocol_options_legacy(v10, a1);
    if (v13)
    {
      v14 = v13;
      v15 = v14;
      v16 = 0;
      *v12 = 0;
      v17 = 84;
      while (1)
      {
        v18 = v14[v16 + 48];
        v12[v16] = v18;
        if (!v18)
          break;
        --v17;
        ++v16;
        if (v17 <= 1)
        {
          v12[v16] = 0;
          break;
        }
      }

      os_release(v15);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v22 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v114 = "nw_protocol_http2_transport_add_input_handler";
        v115 = 2082;
        v116 = (uint64_t)(handle + 205);
        _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_ERROR, "%{public}s %{public}s no http2_options found, cannot get log id", buf, 0x16u);
      }
    }
  }
  v23 = nw_parameters_copy_protocol_value(v11, (uint64_t)a1, "incomingStreamId");
  if (!v23)
  {
    LODWORD(v26) = -1;
    goto LABEL_32;
  }
  v24 = v23;
  value = xpc_int64_get_value(v23);
  v26 = value;
  if (HIDWORD(value))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)(handle + 205);
    v117 = 2048;
    *(_QWORD *)v118 = v26;
    v42 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v111 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v42, &type, &v111))
      goto LABEL_92;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v43 = gLogObj;
      v44 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_92;
      *(_DWORD *)buf = 136446722;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)v12;
      v117 = 2048;
      *(_QWORD *)v118 = v26;
      v45 = "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld";
    }
    else if (v111)
    {
      v50 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v43 = gLogObj;
      v44 = type;
      v51 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v50)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446978;
          v114 = "nw_protocol_http2_transport_add_input_handler";
          v115 = 2082;
          v116 = (uint64_t)v12;
          v117 = 2048;
          *(_QWORD *)v118 = v26;
          *(_WORD *)&v118[8] = 2082;
          *(_QWORD *)&v118[10] = v50;
          _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v50);
        goto LABEL_92;
      }
      if (!v51)
      {
LABEL_92:
        if (v42)
          free(v42);
        goto LABEL_94;
      }
      *(_DWORD *)buf = 136446722;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)v12;
      v117 = 2048;
      *(_QWORD *)v118 = v26;
      v45 = "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v43 = gLogObj;
      v44 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_92;
      *(_DWORD *)buf = 136446722;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)v12;
      v117 = 2048;
      *(_QWORD *)v118 = v26;
      v45 = "%{public}s %{public}s invalid stream id supplied via protocol parameters: %lld, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v43, v44, v45, buf, 0x20u);
    goto LABEL_92;
  }
  if ((value & 0x80000000) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v52 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 1024;
      *(_DWORD *)v118 = v26;
      _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_ERROR, "%{public}s %{public}s invalid incoming stream id detected: %d", buf, 0x1Cu);
    }
LABEL_94:
    xpc_release(v24);
    return 0;
  }
  if (gLogDatapath)
  {
    v100 = __nwlog_obj();
    if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 1024;
      *(_DWORD *)v118 = v26;
      _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s found incoming stream id: %d", buf, 0x1Cu);
    }
  }
  xpc_release(v24);
LABEL_32:
  if (gLogDatapath)
  {
    v98 = __nwlog_obj();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      v114 = "nw_http2_transport_add_to_protocol_table";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 2048;
      *(_QWORD *)v118 = a2;
      *(_WORD *)&v118[8] = 1024;
      *(_DWORD *)&v118[10] = -999;
      _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called for protocol %p, stream %d", buf, 0x26u);
    }
  }
  type = OS_LOG_TYPE_DEFAULT;
  internal = *((_QWORD *)handle + 14);
  if (!internal)
  {
    internal = nw_hash_table_create_internal(0x11u, 8, (const void *(*)(const void *, unsigned int *))nw_protocol_get_key, (unsigned int (*)(const void *, unsigned int))nw_protocol_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_protocol_matches_key, 0);
    if (internal)
    {
      *(_DWORD *)(internal + 48) &= ~2u;
      *((_QWORD *)handle + 14) = internal;
      goto LABEL_36;
    }
    *((_QWORD *)handle + 14) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v114 = "nw_http2_transport_add_to_protocol_table";
    v55 = (const char *)_os_log_send_and_compose_impl();
    v111 = OS_LOG_TYPE_ERROR;
    v110 = 0;
    if (__nwlog_fault(v55, &v111, &v110))
    {
      if (v111 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v56 = gLogObj;
        v57 = v111;
        if (!os_log_type_enabled((os_log_t)gLogObj, v111))
          goto LABEL_132;
        *(_DWORD *)buf = 136446210;
        v114 = "nw_http2_transport_add_to_protocol_table";
        v58 = "%{public}s nw_protocol_hash_table_create failed";
LABEL_131:
        _os_log_impl(&dword_182FBE000, v56, v57, v58, buf, 0xCu);
        goto LABEL_132;
      }
      if (!v110)
      {
        v56 = __nwlog_obj();
        v57 = v111;
        if (!os_log_type_enabled(v56, v111))
          goto LABEL_132;
        *(_DWORD *)buf = 136446210;
        v114 = "nw_http2_transport_add_to_protocol_table";
        v58 = "%{public}s nw_protocol_hash_table_create failed, backtrace limit exceeded";
        goto LABEL_131;
      }
      v69 = (char *)__nw_create_backtrace_string();
      v56 = __nwlog_obj();
      v57 = v111;
      v70 = os_log_type_enabled(v56, v111);
      if (!v69)
      {
        if (!v70)
          goto LABEL_132;
        *(_DWORD *)buf = 136446210;
        v114 = "nw_http2_transport_add_to_protocol_table";
        v58 = "%{public}s nw_protocol_hash_table_create failed, no backtrace";
        goto LABEL_131;
      }
      if (v70)
      {
        *(_DWORD *)buf = 136446466;
        v114 = "nw_http2_transport_add_to_protocol_table";
        v115 = 2082;
        v116 = (uint64_t)v69;
        _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s nw_protocol_hash_table_create failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v69);
    }
LABEL_132:
    if (v55)
    {
      v72 = (char *)v55;
      goto LABEL_134;
    }
LABEL_135:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)v12;
    v21 = "%{public}s %{public}s could not add protocol to protocol based hash table, cannot add input handler";
    goto LABEL_137;
  }
LABEL_36:
  v28 = nw_hash_table_add_object(internal, (uint64_t)a2, (char *)&type);
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446978;
    v114 = "nw_http2_transport_add_to_protocol_table";
    v115 = 2082;
    v116 = (uint64_t)(handle + 205);
    v117 = 1042;
    *(_DWORD *)v118 = 16;
    *(_WORD *)&v118[4] = 2098;
    *(_QWORD *)&v118[6] = a2;
    v46 = (const char *)_os_log_send_and_compose_impl();
    v111 = OS_LOG_TYPE_ERROR;
    v110 = 0;
    if (!__nwlog_fault(v46, &v111, &v110))
      goto LABEL_103;
    if (v111 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v47 = gLogObj;
      v48 = v111;
      if (!os_log_type_enabled((os_log_t)gLogObj, v111))
        goto LABEL_103;
      *(_DWORD *)buf = 136446978;
      v114 = "nw_http2_transport_add_to_protocol_table";
      v115 = 2082;
      v116 = (uint64_t)v12;
      v117 = 1042;
      *(_DWORD *)v118 = 16;
      *(_WORD *)&v118[4] = 2098;
      *(_QWORD *)&v118[6] = a2;
      v49 = "%{public}s %{public}s http2_transport already has input handler registered for %{public,uuid_t}.16P";
    }
    else if (v110)
    {
      v53 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v47 = gLogObj;
      v48 = v111;
      v54 = os_log_type_enabled((os_log_t)gLogObj, v111);
      if (v53)
      {
        if (v54)
        {
          *(_DWORD *)buf = 136447234;
          v114 = "nw_http2_transport_add_to_protocol_table";
          v115 = 2082;
          v116 = (uint64_t)v12;
          v117 = 1042;
          *(_DWORD *)v118 = 16;
          *(_WORD *)&v118[4] = 2098;
          *(_QWORD *)&v118[6] = a2;
          *(_WORD *)&v118[14] = 2082;
          *(_QWORD *)&v118[16] = v53;
          _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s %{public}s http2_transport already has input handler registered for %{public,uuid_t}.16P, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v53);
LABEL_103:
        if (v46)
        {
          v72 = (char *)v46;
LABEL_134:
          free(v72);
          goto LABEL_135;
        }
        goto LABEL_135;
      }
      if (!v54)
        goto LABEL_103;
      *(_DWORD *)buf = 136446978;
      v114 = "nw_http2_transport_add_to_protocol_table";
      v115 = 2082;
      v116 = (uint64_t)v12;
      v117 = 1042;
      *(_DWORD *)v118 = 16;
      *(_WORD *)&v118[4] = 2098;
      *(_QWORD *)&v118[6] = a2;
      v49 = "%{public}s %{public}s http2_transport already has input handler registered for %{public,uuid_t}.16P, no backtrace";
    }
    else
    {
      v47 = __nwlog_obj();
      v48 = v111;
      if (!os_log_type_enabled(v47, v111))
        goto LABEL_103;
      *(_DWORD *)buf = 136446978;
      v114 = "nw_http2_transport_add_to_protocol_table";
      v115 = 2082;
      v116 = (uint64_t)v12;
      v117 = 1042;
      *(_DWORD *)v118 = 16;
      *(_WORD *)&v118[4] = 2098;
      *(_QWORD *)&v118[6] = a2;
      v49 = "%{public}s %{public}s http2_transport already has input handler registered for %{public,uuid_t}.16P, backtra"
            "ce limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v47, v48, v49, buf, 0x26u);
    goto LABEL_103;
  }
  v29 = (_QWORD *)v28;
  if (gLogDatapath)
  {
    v99 = __nwlog_obj();
    if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v114 = "nw_http2_transport_add_to_protocol_table";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 2048;
      *(_QWORD *)v118 = a2;
      _os_log_impl(&dword_182FBE000, v99, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s added protocol %p to protocol hash table", buf, 0x20u);
    }
  }
  if (!v29)
    goto LABEL_135;
  if ((_DWORD)v26 != -1)
  {
    stream_node_from_id = nw_http2_transport_get_stream_node_from_id((uint64_t)handle, v26);
    if (stream_node_from_id)
    {
      v32 = stream_node_from_id;
      v33 = *(_QWORD *)(stream_node_from_id + 16);
      if (v33)
      {
        if (*(_QWORD *)(stream_node_from_id + 32))
        {
          __nwlog_obj();
          v34 = *(_QWORD *)(v32 + 32);
          v35 = *(_DWORD *)(v33 + 32);
          *(_DWORD *)buf = 136447490;
          v114 = "nw_protocol_http2_transport_add_input_handler";
          v115 = 2082;
          v116 = (uint64_t)(handle + 205);
          v117 = 2048;
          *(_QWORD *)v118 = a2;
          *(_WORD *)&v118[8] = 2048;
          *(_QWORD *)&v118[10] = v34;
          *(_WORD *)&v118[18] = 2048;
          *(_QWORD *)&v118[20] = v33;
          v119 = 1024;
          v120 = v35;
          v36 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v111 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v36, &type, &v111))
            goto LABEL_147;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v37 = __nwlog_obj();
            v38 = type;
            if (!os_log_type_enabled(v37, type))
              goto LABEL_147;
            v39 = *(_QWORD *)(v32 + 32);
            v40 = *(_DWORD *)(v33 + 32);
            *(_DWORD *)buf = 136447490;
            v114 = "nw_protocol_http2_transport_add_input_handler";
            v115 = 2082;
            v116 = (uint64_t)(handle + 205);
            v117 = 2048;
            *(_QWORD *)v118 = a2;
            *(_WORD *)&v118[8] = 2048;
            *(_QWORD *)&v118[10] = v39;
            *(_WORD *)&v118[18] = 2048;
            *(_QWORD *)&v118[20] = v33;
            v119 = 1024;
            v120 = v40;
            v41 = "%{public}s %{public}s adding new input handler %p, already have existing protocol pointer %p for stream (%p, id %d)";
          }
          else if (v111)
          {
            v78 = (char *)__nw_create_backtrace_string();
            v37 = __nwlog_obj();
            v38 = type;
            v79 = os_log_type_enabled(v37, type);
            if (v78)
            {
              if (v79)
              {
                v80 = *(_QWORD *)(v32 + 32);
                v81 = *(_DWORD *)(v33 + 32);
                *(_DWORD *)buf = 136447746;
                v114 = "nw_protocol_http2_transport_add_input_handler";
                v115 = 2082;
                v116 = (uint64_t)(handle + 205);
                v117 = 2048;
                *(_QWORD *)v118 = a2;
                *(_WORD *)&v118[8] = 2048;
                *(_QWORD *)&v118[10] = v80;
                *(_WORD *)&v118[18] = 2048;
                *(_QWORD *)&v118[20] = v33;
                v119 = 1024;
                v120 = v81;
                v121 = 2082;
                v122 = v78;
                _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s %{public}s adding new input handler %p, already have existing protocol pointer %p for stream (%p, id %d), dumping backtrace:%{public}s", buf, 0x44u);
              }
              free(v78);
              goto LABEL_147;
            }
            if (!v79)
            {
LABEL_147:
              if (v36)
                free(v36);
              goto LABEL_149;
            }
            v85 = *(_QWORD *)(v32 + 32);
            v86 = *(_DWORD *)(v33 + 32);
            *(_DWORD *)buf = 136447490;
            v114 = "nw_protocol_http2_transport_add_input_handler";
            v115 = 2082;
            v116 = (uint64_t)(handle + 205);
            v117 = 2048;
            *(_QWORD *)v118 = a2;
            *(_WORD *)&v118[8] = 2048;
            *(_QWORD *)&v118[10] = v85;
            *(_WORD *)&v118[18] = 2048;
            *(_QWORD *)&v118[20] = v33;
            v119 = 1024;
            v120 = v86;
            v41 = "%{public}s %{public}s adding new input handler %p, already have existing protocol pointer %p for strea"
                  "m (%p, id %d), no backtrace";
          }
          else
          {
            v37 = __nwlog_obj();
            v38 = type;
            if (!os_log_type_enabled(v37, type))
              goto LABEL_147;
            v83 = *(_QWORD *)(v32 + 32);
            v84 = *(_DWORD *)(v33 + 32);
            *(_DWORD *)buf = 136447490;
            v114 = "nw_protocol_http2_transport_add_input_handler";
            v115 = 2082;
            v116 = (uint64_t)(handle + 205);
            v117 = 2048;
            *(_QWORD *)v118 = a2;
            *(_WORD *)&v118[8] = 2048;
            *(_QWORD *)&v118[10] = v83;
            *(_WORD *)&v118[18] = 2048;
            *(_QWORD *)&v118[20] = v33;
            v119 = 1024;
            v120 = v84;
            v41 = "%{public}s %{public}s adding new input handler %p, already have existing protocol pointer %p for strea"
                  "m (%p, id %d), backtrace limit exceeded";
          }
          _os_log_impl(&dword_182FBE000, v37, v38, v41, buf, 0x3Au);
          goto LABEL_147;
        }
        *(_QWORD *)(stream_node_from_id + 32) = a2;
        v29[4] = v33;
        if (gLogDatapath)
        {
          v73 = __nwlog_obj();
          if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
          {
            v74 = *(_DWORD *)(v33 + 32);
            *(_DWORD *)buf = 136447234;
            v114 = "nw_protocol_http2_transport_add_input_handler";
            v115 = 2082;
            v116 = (uint64_t)(handle + 205);
            v117 = 1024;
            *(_DWORD *)v118 = v26;
            *(_WORD *)&v118[4] = 1024;
            *(_DWORD *)&v118[6] = v74;
            *(_WORD *)&v118[10] = 2048;
            *(_QWORD *)&v118[12] = v33;
            v75 = "%{public}s %{public}s connected incoming stream id %d to existing stream %d (%p)";
            v76 = v73;
            v77 = 44;
LABEL_212:
            _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_DEBUG, v75, buf, v77);
            goto LABEL_118;
          }
        }
        goto LABEL_118;
      }
      v71 = __nwlog_obj();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v114 = "nw_protocol_http2_transport_add_input_handler";
        v115 = 2082;
        v116 = (uint64_t)(handle + 205);
        v117 = 1024;
        *(_DWORD *)v118 = v26;
        v66 = "%{public}s %{public}s stream (id %d) not found in hash node";
        v67 = v71;
        v68 = 28;
        goto LABEL_99;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v65 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v114 = "nw_protocol_http2_transport_add_input_handler";
        v115 = 2082;
        v116 = (uint64_t)(handle + 205);
        v117 = 1024;
        *(_DWORD *)v118 = v26;
        *(_WORD *)&v118[4] = 2048;
        *(_QWORD *)&v118[6] = a2;
        v66 = "%{public}s %{public}s could not find existing stream %d to connect protocol %p with";
        v67 = v65;
        v68 = 38;
LABEL_99:
        _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_ERROR, v66, buf, v68);
      }
    }
LABEL_149:
    nw_http2_transport_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
    return 0;
  }
  if (gLogDatapath)
  {
    v101 = __nwlog_obj();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s detected new stream initiated from this side of the connection, allocating new stream", buf, 0x16u);
    }
  }
  v59 = malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  v60 = (uint64_t)v59;
  if (v59)
  {
    *v59 = 0;
    v59[1] = v59;
    v59[2] = 0;
    v59[3] = v59 + 2;
    *((_BYTE *)v59 + 36) &= 0xF0u;
  }
  else
  {
    v102 = __nwlog_obj();
    os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v114 = "strict_calloc";
    v115 = 2048;
    v116 = 1;
    v117 = 2048;
    *(_QWORD *)v118 = 40;
    v103 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v103);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v103);
    nw_http2_transport_stream_init(0);
  }
  *(_DWORD *)(v60 + 32) = -1;
  v61 = v11;
  v62 = v61[12];

  *(_BYTE *)(v60 + 36) = *(_BYTE *)(v60 + 36) & 0xF7 | (v62 >> 12) & 8;
  v29[4] = v60;
  if ((*(_BYTE *)(v60 + 36) & 8) == 0)
    goto LABEL_118;
  if (a1->default_input_handler)
  {
    v63 = __nwlog_obj();
    if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
LABEL_79:
      nw_http2_transport_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      free((void *)v60);
      return 0;
    }
    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)(handle + 205);
    v64 = "%{public}s %{public}s http2_transport has default_input_handler on the first stream in a listening connection."
          " Is a connection trying to join while having server set on the parameters?";
LABEL_78:
    _os_log_impl(&dword_182FBE000, v63, OS_LOG_TYPE_ERROR, v64, buf, 0x16u);
    goto LABEL_79;
  }
  if (gLogDatapath)
  {
    v107 = __nwlog_obj();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      _os_log_impl(&dword_182FBE000, v107, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s responder's first stream detected, overriding stream id to 1", buf, 0x16u);
    }
  }
  *(_DWORD *)(v60 + 32) = 1;
  if (!nw_http2_transport_add_to_id_table((uint64_t)handle, v60, (uint64_t)a2))
  {
    v63 = __nwlog_obj();
    if (!os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      goto LABEL_79;
    *(_DWORD *)buf = 136446466;
    v114 = "nw_protocol_http2_transport_add_input_handler";
    v115 = 2082;
    v116 = (uint64_t)(handle + 205);
    v64 = "%{public}s %{public}s Failed to add new stream to the id based hash table";
    goto LABEL_78;
  }
  if (gLogDatapath)
  {
    v108 = __nwlog_obj();
    if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
    {
      v109 = v29[4];
      *(_DWORD *)buf = 136446978;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 2048;
      *(_QWORD *)v118 = v60;
      *(_WORD *)&v118[8] = 2048;
      *(_QWORD *)&v118[10] = v109;
      v75 = "%{public}s %{public}s new stream is %p, stream pointer is %p";
      v76 = v108;
      v77 = 42;
      goto LABEL_212;
    }
  }
LABEL_118:
  a2->output_handler_context = v29;
  if (a2->output_handler)
  {
    if (a1->default_input_handler)
      goto LABEL_120;
LABEL_127:
    nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
    *(_OWORD *)handle = *(_OWORD *)a2->flow_id;
    v82 = *((_QWORD *)handle + 9);
    if (!v82)
      goto LABEL_122;
    goto LABEL_121;
  }
  nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
  if (!a1->default_input_handler)
    goto LABEL_127;
LABEL_120:
  v82 = *((_QWORD *)handle + 9);
  if (v82)
  {
LABEL_121:
    nw_queue_cancel_source(v82, v31);
    *((_QWORD *)handle + 9) = 0;
  }
LABEL_122:
  if (!*((_QWORD *)handle + 11))
    *((_QWORD *)handle + 11) = os_retain(v11);
  if (gLogDatapath)
  {
    v104 = __nwlog_obj();
    if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
    {
      v106 = nw_hash_table_count(*((_QWORD *)handle + 14), v105);
      *(_DWORD *)buf = 136446978;
      v114 = "nw_protocol_http2_transport_add_input_handler";
      v115 = 2082;
      v116 = (uint64_t)(handle + 205);
      v117 = 2048;
      *(_QWORD *)v118 = a2;
      *(_WORD *)&v118[8] = 1024;
      *(_DWORD *)&v118[10] = v106;
      _os_log_impl(&dword_182FBE000, v104, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s added input handler %p, have %u input handlers", buf, 0x26u);
    }
  }
  return 1;
}

