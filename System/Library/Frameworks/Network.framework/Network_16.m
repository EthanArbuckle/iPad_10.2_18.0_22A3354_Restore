uint64_t nw_protocol_common_get_output_frames(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t);
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void (**v17)(_QWORD);
  const void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  char *backtrace_string;
  _BOOL4 v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  void (**v28)(_QWORD);
  const void *v29;
  const char *v31;
  char *v32;
  NSObject *v33;
  os_log_type_t v34;
  const char *v35;
  const char *v36;
  char *v37;
  _BOOL4 v38;
  const char *v39;
  _BOOL4 v40;
  _BOOL4 v41;
  _BOOL4 v42;
  const char *v43;
  const char *v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  void *v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  char *v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_common_get_output_frames";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v19, &type, &v45))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null protocol";
      goto LABEL_47;
    }
    if (!v45)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type;
    v40 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v40)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_47;
    }
    if (!v40)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v48 = "nw_protocol_common_get_output_frames";
    v49 = 2082;
    v50 = backtrace_string;
    v25 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_common_get_output_frames";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v19, &type, &v45))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null input_protocol";
      goto LABEL_47;
    }
    if (!v45)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type;
    v41 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v41)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_47;
    }
    if (!v41)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v48 = "nw_protocol_common_get_output_frames";
    v49 = 2082;
    v50 = backtrace_string;
    v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_common_get_output_frames";
    v19 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v19, &type, &v45))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null return_array";
      goto LABEL_47;
    }
    if (!v45)
    {
      v20 = __nwlog_obj();
      v21 = type;
      if (!os_log_type_enabled(v20, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v20 = __nwlog_obj();
    v21 = type;
    v42 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v42)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_47;
    }
    if (!v42)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v48 = "nw_protocol_common_get_output_frames";
    v49 = 2082;
    v50 = backtrace_string;
    v25 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (v7)
  {
    v8 = *(void **)(v7 + 40);
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      v9 = *(_QWORD *)(v7 + 88);
      if (v9)
        *(_QWORD *)(v7 + 88) = v9 + 1;
    }
    v10 = *(void **)(a1 + 40);
    if (v10 == &nw_protocol_ref_counted_handle)
    {
      v11 = *(_QWORD *)(a1 + 88);
      if (v11)
        *(_QWORD *)(a1 + 88) = v11 + 1;
    }
    v12 = *(_QWORD *)(v7 + 24);
    if (v12)
    {
      v13 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 88);
      if (v13)
      {
        v14 = v13(v7, a1);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v7 + 40) == &nw_protocol_ref_counted_handle)
          {
            v15 = *(_QWORD *)(v7 + 88);
            if (v15)
            {
              v16 = v15 - 1;
              *(_QWORD *)(v7 + 88) = v16;
              if (!v16)
              {
                v17 = *(void (***)(_QWORD))(v7 + 64);
                if (v17)
                {
                  *(_QWORD *)(v7 + 64) = 0;
                  v17[2](v17);
                  _Block_release(v17);
                }
                if ((*(_BYTE *)(v7 + 72) & 1) != 0)
                {
                  v18 = *(const void **)(v7 + 64);
                  if (v18)
                    _Block_release(v18);
                }
                free((void *)v7);
              }
            }
          }
          return v14;
        }
LABEL_14:
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          v26 = *(_QWORD *)(a1 + 88);
          if (v26)
          {
            v27 = v26 - 1;
            *(_QWORD *)(a1 + 88) = v27;
            if (!v27)
            {
              v28 = *(void (***)(_QWORD))(a1 + 64);
              if (v28)
              {
                *(_QWORD *)(a1 + 64) = 0;
                v28[2](v28);
                _Block_release(v28);
              }
              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                v29 = *(const void **)(a1 + 64);
                if (v29)
                  _Block_release(v29);
              }
              free((void *)a1);
            }
          }
        }
        goto LABEL_15;
      }
    }
    __nwlog_obj();
    v31 = *(const char **)(v7 + 16);
    *(_DWORD *)buf = 136446722;
    v48 = "__nw_protocol_get_output_frames";
    if (!v31)
      v31 = "invalid";
    v49 = 2082;
    v50 = (void *)v31;
    v51 = 2048;
    v52 = v7;
    v32 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v32, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_106;
        v35 = *(const char **)(v7 + 16);
        if (!v35)
          v35 = "invalid";
        *(_DWORD *)buf = 136446722;
        v48 = "__nw_protocol_get_output_frames";
        v49 = 2082;
        v50 = (void *)v35;
        v51 = 2048;
        v52 = v7;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_105:
        _os_log_impl(&dword_182FBE000, v33, v34, v36, buf, 0x20u);
        goto LABEL_106;
      }
      if (!v45)
      {
        v33 = __nwlog_obj();
        v34 = type;
        if (!os_log_type_enabled(v33, type))
          goto LABEL_106;
        v43 = *(const char **)(v7 + 16);
        if (!v43)
          v43 = "invalid";
        *(_DWORD *)buf = 136446722;
        v48 = "__nw_protocol_get_output_frames";
        v49 = 2082;
        v50 = (void *)v43;
        v51 = 2048;
        v52 = v7;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
        goto LABEL_105;
      }
      v37 = (char *)__nw_create_backtrace_string();
      v33 = __nwlog_obj();
      v34 = type;
      v38 = os_log_type_enabled(v33, type);
      if (!v37)
      {
        if (!v38)
          goto LABEL_106;
        v44 = *(const char **)(v7 + 16);
        if (!v44)
          v44 = "invalid";
        *(_DWORD *)buf = 136446722;
        v48 = "__nw_protocol_get_output_frames";
        v49 = 2082;
        v50 = (void *)v44;
        v51 = 2048;
        v52 = v7;
        v36 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
        goto LABEL_105;
      }
      if (v38)
      {
        v39 = *(const char **)(v7 + 16);
        if (!v39)
          v39 = "invalid";
        *(_DWORD *)buf = 136446978;
        v48 = "__nw_protocol_get_output_frames";
        v49 = 2082;
        v50 = (void *)v39;
        v51 = 2048;
        v52 = v7;
        v53 = 2082;
        v54 = v37;
        _os_log_impl(&dword_182FBE000, v33, v34, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v37);
    }
LABEL_106:
    if (v32)
      free(v32);
    v14 = 0;
    if (v10 != &nw_protocol_ref_counted_handle)
      goto LABEL_15;
    goto LABEL_14;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v48 = "nw_protocol_common_get_output_frames";
  v19 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if (!__nwlog_fault(v19, &type, &v45))
    goto LABEL_48;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    v21 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_common_get_output_frames";
      v22 = "%{public}s get_ouput_frames requires an output handler";
LABEL_47:
      _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0xCu);
      goto LABEL_48;
    }
    goto LABEL_48;
  }
  if (v45)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = gLogObj;
    v21 = type;
    v24 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_protocol_common_get_output_frames";
        v22 = "%{public}s get_ouput_frames requires an output handler, no backtrace";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (!v24)
    {
LABEL_34:
      free(backtrace_string);
      goto LABEL_48;
    }
    *(_DWORD *)buf = 136446466;
    v48 = "nw_protocol_common_get_output_frames";
    v49 = 2082;
    v50 = backtrace_string;
    v25 = "%{public}s get_ouput_frames requires an output handler, dumping backtrace:%{public}s";
LABEL_33:
    _os_log_impl(&dword_182FBE000, v20, v21, v25, buf, 0x16u);
    goto LABEL_34;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v20 = gLogObj;
  v21 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_common_get_output_frames";
    v22 = "%{public}s get_ouput_frames requires an output handler, backtrace limit exceeded";
    goto LABEL_47;
  }
LABEL_48:
  if (v19)
    free(v19);
  return 0;
}

uint64_t nw_protocol_common_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (**v10)(_QWORD);
  const void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  const char *v18;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  const char *v25;
  char *v26;
  _BOOL4 v27;
  const char *v28;
  _BOOL4 v29;
  _BOOL4 v30;
  const char *v31;
  const char *v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  void *v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_common_finalize_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v12, &type, &v33))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_protocol_common_finalize_output_frames";
      v15 = "%{public}s called with null protocol";
      goto LABEL_33;
    }
    if (!v33)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_protocol_common_finalize_output_frames";
      v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v29 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (!v29)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_protocol_common_finalize_output_frames";
      v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_33;
    }
    if (!v29)
      goto LABEL_28;
    *(_DWORD *)buf = 136446466;
    v36 = "nw_protocol_common_finalize_output_frames";
    v37 = 2082;
    v38 = backtrace_string;
    v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_27;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_common_finalize_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v12, &type, &v33))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_protocol_common_finalize_output_frames";
      v15 = "%{public}s called with null frames";
      goto LABEL_33;
    }
    if (!v33)
    {
      v13 = __nwlog_obj();
      v14 = type;
      if (!os_log_type_enabled(v13, type))
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_protocol_common_finalize_output_frames";
      v15 = "%{public}s called with null frames, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v13 = __nwlog_obj();
    v14 = type;
    v30 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (!v30)
        goto LABEL_34;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_protocol_common_finalize_output_frames";
      v15 = "%{public}s called with null frames, no backtrace";
      goto LABEL_33;
    }
    if (!v30)
      goto LABEL_28;
    *(_DWORD *)buf = 136446466;
    v36 = "nw_protocol_common_finalize_output_frames";
    v37 = 2082;
    v38 = backtrace_string;
    v18 = "%{public}s called with null frames, dumping backtrace:%{public}s";
    goto LABEL_27;
  }
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_protocol_common_finalize_output_frames";
    v12 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault(v12, &type, &v33))
      goto LABEL_34;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_common_finalize_output_frames";
        v15 = "%{public}s finalize_output_frames requires an output handler";
LABEL_33:
        _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_common_finalize_output_frames";
        v15 = "%{public}s finalize_output_frames requires an output handler, backtrace limit exceeded";
        goto LABEL_33;
      }
LABEL_34:
      if (v12)
        free(v12);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    v14 = type;
    v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_protocol_common_finalize_output_frames";
        v15 = "%{public}s finalize_output_frames requires an output handler, no backtrace";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    if (!v17)
    {
LABEL_28:
      free(backtrace_string);
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446466;
    v36 = "nw_protocol_common_finalize_output_frames";
    v37 = 2082;
    v38 = backtrace_string;
    v18 = "%{public}s finalize_output_frames requires an output handler, dumping backtrace:%{public}s";
LABEL_27:
    _os_log_impl(&dword_182FBE000, v13, v14, v18, buf, 0x16u);
    goto LABEL_28;
  }
  v3 = *(void **)(v2 + 40);
  if (v3 == &nw_protocol_ref_counted_handle)
  {
    v4 = *(_QWORD *)(v2 + 88);
    if (v4)
      *(_QWORD *)(v2 + 88) = v4 + 1;
  }
  v5 = *(_QWORD *)(v2 + 24);
  if (v5)
  {
    v6 = *(uint64_t (**)(uint64_t))(v5 + 96);
    if (v6)
    {
      v7 = v6(v2);
      if (v3 != &nw_protocol_ref_counted_handle)
        return v7;
      goto LABEL_10;
    }
  }
  __nwlog_obj();
  v20 = *(const char **)(v2 + 16);
  *(_DWORD *)buf = 136446722;
  v36 = "__nw_protocol_finalize_output_frames";
  if (!v20)
    v20 = "invalid";
  v37 = 2082;
  v38 = (void *)v20;
  v39 = 2048;
  v40 = v2;
  v21 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (!__nwlog_fault(v21, &type, &v33))
    goto LABEL_82;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
      goto LABEL_82;
    v24 = *(const char **)(v2 + 16);
    if (!v24)
      v24 = "invalid";
    *(_DWORD *)buf = 136446722;
    v36 = "__nw_protocol_finalize_output_frames";
    v37 = 2082;
    v38 = (void *)v24;
    v39 = 2048;
    v40 = v2;
    v25 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_81:
    _os_log_impl(&dword_182FBE000, v22, v23, v25, buf, 0x20u);
    goto LABEL_82;
  }
  if (!v33)
  {
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
      goto LABEL_82;
    v31 = *(const char **)(v2 + 16);
    if (!v31)
      v31 = "invalid";
    *(_DWORD *)buf = 136446722;
    v36 = "__nw_protocol_finalize_output_frames";
    v37 = 2082;
    v38 = (void *)v31;
    v39 = 2048;
    v40 = v2;
    v25 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
    goto LABEL_81;
  }
  v26 = (char *)__nw_create_backtrace_string();
  v22 = __nwlog_obj();
  v23 = type;
  v27 = os_log_type_enabled(v22, type);
  if (!v26)
  {
    if (!v27)
      goto LABEL_82;
    v32 = *(const char **)(v2 + 16);
    if (!v32)
      v32 = "invalid";
    *(_DWORD *)buf = 136446722;
    v36 = "__nw_protocol_finalize_output_frames";
    v37 = 2082;
    v38 = (void *)v32;
    v39 = 2048;
    v40 = v2;
    v25 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
    goto LABEL_81;
  }
  if (v27)
  {
    v28 = *(const char **)(v2 + 16);
    if (!v28)
      v28 = "invalid";
    *(_DWORD *)buf = 136446978;
    v36 = "__nw_protocol_finalize_output_frames";
    v37 = 2082;
    v38 = (void *)v28;
    v39 = 2048;
    v40 = v2;
    v41 = 2082;
    v42 = v26;
    _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v26);
LABEL_82:
  if (v21)
    free(v21);
  v7 = 0;
  if (v3 == &nw_protocol_ref_counted_handle)
  {
LABEL_10:
    if (*(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
    {
      v8 = *(_QWORD *)(v2 + 88);
      if (v8)
      {
        v9 = v8 - 1;
        *(_QWORD *)(v2 + 88) = v9;
        if (!v9)
        {
          v10 = *(void (***)(_QWORD))(v2 + 64);
          if (v10)
          {
            *(_QWORD *)(v2 + 64) = 0;
            v10[2](v10);
            _Block_release(v10);
          }
          if ((*(_BYTE *)(v2 + 72) & 1) != 0)
          {
            v11 = *(const void **)(v2 + 64);
            if (v11)
              _Block_release(v11);
          }
          free((void *)v2);
        }
      }
    }
  }
  return v7;
}

uint64_t nw_protocol_common_get_parameters(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(_QWORD);
  const void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_parameters";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_parameters";
      v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v31)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_parameters";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_parameters";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (!v28)
      goto LABEL_27;
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_parameters";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }
  v1 = *(_QWORD *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_parameters";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_parameters";
        v14 = "%{public}s get_parameters requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_parameters";
        v14 = "%{public}s get_parameters requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }
LABEL_33:
      if (v11)
        free(v11);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_parameters";
        v14 = "%{public}s get_parameters requires a default input handler, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_parameters";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s get_parameters requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }
  v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(v1 + 88);
    if (v3)
      *(_QWORD *)(v1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(v1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 112);
    if (v5)
    {
      v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_9;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  v34 = "__nw_protocol_get_parameters";
  if (!v19)
    v19 = "invalid";
  v35 = 2082;
  v36 = (void *)v19;
  v37 = 2048;
  v38 = v1;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v20, &type, &v31))
    goto LABEL_71;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v23 = *(const char **)(v1 + 16);
    if (!v23)
      v23 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_parameters";
    v35 = 2082;
    v36 = (void *)v23;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_70:
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }
  if (!v31)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v29 = *(const char **)(v1 + 16);
    if (!v29)
      v29 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_parameters";
    v35 = 2082;
    v36 = (void *)v29;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
    goto LABEL_70;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26)
      goto LABEL_71;
    v30 = *(const char **)(v1 + 16);
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_parameters";
    v35 = 2082;
    v36 = (void *)v30;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
    goto LABEL_70;
  }
  if (v26)
  {
    v27 = *(const char **)(v1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446978;
    v34 = "__nw_protocol_get_parameters";
    v35 = 2082;
    v36 = (void *)v27;
    v37 = 2048;
    v38 = v1;
    v39 = 2082;
    v40 = v25;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v25);
LABEL_71:
  if (v20)
    free(v20);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v1 + 88);
      if (v7)
      {
        v8 = v7 - 1;
        *(_QWORD *)(v1 + 88) = v8;
        if (!v8)
        {
          v9 = *(void (***)(_QWORD))(v1 + 64);
          if (v9)
          {
            *(_QWORD *)(v1 + 64) = 0;
            v9[2](v9);
            _Block_release(v9);
          }
          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            v10 = *(const void **)(v1 + 64);
            if (v10)
              _Block_release(v10);
          }
          free((void *)v1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_common_get_path(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(_QWORD);
  const void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_path";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_path";
      v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v31)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_path";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_path";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (!v28)
      goto LABEL_27;
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_path";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }
  v1 = *(_QWORD *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_path";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_path";
        v14 = "%{public}s get_path requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_path";
        v14 = "%{public}s get_path requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }
LABEL_33:
      if (v11)
        free(v11);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_path";
        v14 = "%{public}s get_path requires a default input handler, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_path";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s get_path requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }
  v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(v1 + 88);
    if (v3)
      *(_QWORD *)(v1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(v1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 120);
    if (v5)
    {
      v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_9;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  v34 = "__nw_protocol_get_path";
  if (!v19)
    v19 = "invalid";
  v35 = 2082;
  v36 = (void *)v19;
  v37 = 2048;
  v38 = v1;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v20, &type, &v31))
    goto LABEL_71;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v23 = *(const char **)(v1 + 16);
    if (!v23)
      v23 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_path";
    v35 = 2082;
    v36 = (void *)v23;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_path callback";
LABEL_70:
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }
  if (!v31)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v29 = *(const char **)(v1 + 16);
    if (!v29)
      v29 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_path";
    v35 = 2082;
    v36 = (void *)v29;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, backtrace limit exceeded";
    goto LABEL_70;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26)
      goto LABEL_71;
    v30 = *(const char **)(v1 + 16);
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_path";
    v35 = 2082;
    v36 = (void *)v30;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, no backtrace";
    goto LABEL_70;
  }
  if (v26)
  {
    v27 = *(const char **)(v1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446978;
    v34 = "__nw_protocol_get_path";
    v35 = 2082;
    v36 = (void *)v27;
    v37 = 2048;
    v38 = v1;
    v39 = 2082;
    v40 = v25;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid get_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v25);
LABEL_71:
  if (v20)
    free(v20);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v1 + 88);
      if (v7)
      {
        v8 = v7 - 1;
        *(_QWORD *)(v1 + 88) = v8;
        if (!v8)
        {
          v9 = *(void (***)(_QWORD))(v1 + 64);
          if (v9)
          {
            *(_QWORD *)(v1 + 64) = 0;
            v9[2](v9);
            _Block_release(v9);
          }
          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            v10 = *(const void **)(v1 + 64);
            if (v10)
              _Block_release(v10);
          }
          free((void *)v1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_common_get_remote_endpoint(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(_QWORD);
  const void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_remote_endpoint";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_remote_endpoint";
      v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v31)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_remote_endpoint";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_remote_endpoint";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (!v28)
      goto LABEL_27;
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_remote_endpoint";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }
  v1 = *(_QWORD *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_remote_endpoint";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_remote_endpoint";
        v14 = "%{public}s get_remote_endpoint requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_remote_endpoint";
        v14 = "%{public}s get_remote_endpoint requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }
LABEL_33:
      if (v11)
        free(v11);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_remote_endpoint";
        v14 = "%{public}s get_remote_endpoint requires a default input handler, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_remote_endpoint";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s get_remote_endpoint requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }
  v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(v1 + 88);
    if (v3)
      *(_QWORD *)(v1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(v1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 136);
    if (v5)
    {
      v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_9;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  v34 = "__nw_protocol_get_remote_endpoint";
  if (!v19)
    v19 = "invalid";
  v35 = 2082;
  v36 = (void *)v19;
  v37 = 2048;
  v38 = v1;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v20, &type, &v31))
    goto LABEL_71;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v23 = *(const char **)(v1 + 16);
    if (!v23)
      v23 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_remote_endpoint";
    v35 = 2082;
    v36 = (void *)v23;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback";
LABEL_70:
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }
  if (!v31)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v29 = *(const char **)(v1 + 16);
    if (!v29)
      v29 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_remote_endpoint";
    v35 = 2082;
    v36 = (void *)v29;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, backtrace limit exceeded";
    goto LABEL_70;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26)
      goto LABEL_71;
    v30 = *(const char **)(v1 + 16);
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_remote_endpoint";
    v35 = 2082;
    v36 = (void *)v30;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, no backtrace";
    goto LABEL_70;
  }
  if (v26)
  {
    v27 = *(const char **)(v1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446978;
    v34 = "__nw_protocol_get_remote_endpoint";
    v35 = 2082;
    v36 = (void *)v27;
    v37 = 2048;
    v38 = v1;
    v39 = 2082;
    v40 = v25;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid get_remote_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v25);
LABEL_71:
  if (v20)
    free(v20);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v1 + 88);
      if (v7)
      {
        v8 = v7 - 1;
        *(_QWORD *)(v1 + 88) = v8;
        if (!v8)
        {
          v9 = *(void (***)(_QWORD))(v1 + 64);
          if (v9)
          {
            *(_QWORD *)(v1 + 64) = 0;
            v9[2](v9);
            _Block_release(v9);
          }
          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            v10 = *(const void **)(v1 + 64);
            if (v10)
              _Block_release(v10);
          }
          free((void *)v1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_common_get_local_endpoint(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(_QWORD);
  const void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_local_endpoint";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_local_endpoint";
      v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v31)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_local_endpoint";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_local_endpoint";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (!v28)
      goto LABEL_27;
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_local_endpoint";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }
  v1 = *(_QWORD *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_local_endpoint";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_local_endpoint";
        v14 = "%{public}s get_local_endpoint requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_local_endpoint";
        v14 = "%{public}s get_local_endpoint requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }
LABEL_33:
      if (v11)
        free(v11);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_local_endpoint";
        v14 = "%{public}s get_local_endpoint requires a default input handler, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_local_endpoint";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s get_local_endpoint requires a default input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }
  v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(v1 + 88);
    if (v3)
      *(_QWORD *)(v1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(v1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 128);
    if (v5)
    {
      v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_9;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  v34 = "__nw_protocol_get_local_endpoint";
  if (!v19)
    v19 = "invalid";
  v35 = 2082;
  v36 = (void *)v19;
  v37 = 2048;
  v38 = v1;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v20, &type, &v31))
    goto LABEL_71;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v23 = *(const char **)(v1 + 16);
    if (!v23)
      v23 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_local_endpoint";
    v35 = 2082;
    v36 = (void *)v23;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback";
LABEL_70:
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }
  if (!v31)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v29 = *(const char **)(v1 + 16);
    if (!v29)
      v29 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_local_endpoint";
    v35 = 2082;
    v36 = (void *)v29;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, backtrace limit exceeded";
    goto LABEL_70;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26)
      goto LABEL_71;
    v30 = *(const char **)(v1 + 16);
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_local_endpoint";
    v35 = 2082;
    v36 = (void *)v30;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, no backtrace";
    goto LABEL_70;
  }
  if (v26)
  {
    v27 = *(const char **)(v1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446978;
    v34 = "__nw_protocol_get_local_endpoint";
    v35 = 2082;
    v36 = (void *)v27;
    v37 = 2048;
    v38 = v1;
    v39 = 2082;
    v40 = v25;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid get_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v25);
LABEL_71:
  if (v20)
    free(v20);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v1 + 88);
      if (v7)
      {
        v8 = v7 - 1;
        *(_QWORD *)(v1 + 88) = v8;
        if (!v8)
        {
          v9 = *(void (***)(_QWORD))(v1 + 64);
          if (v9)
          {
            *(_QWORD *)(v1 + 64) = 0;
            v9[2](v9);
            _Block_release(v9);
          }
          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            v10 = *(const void **)(v1 + 64);
            if (v10)
              _Block_release(v10);
          }
          free((void *)v1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_common_get_output_local_endpoint(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(_QWORD);
  const void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_output_local_endpoint";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_output_local_endpoint";
      v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v31)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_output_local_endpoint";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_output_local_endpoint";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (!v28)
      goto LABEL_27;
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_output_local_endpoint";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }
  v1 = *(_QWORD *)(a1 + 32);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_output_local_endpoint";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_output_local_endpoint";
        v14 = "%{public}s get_output_local_endpoint requires an output handler";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_output_local_endpoint";
        v14 = "%{public}s get_output_local_endpoint requires an output handler, backtrace limit exceeded";
        goto LABEL_32;
      }
LABEL_33:
      if (v11)
        free(v11);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_output_local_endpoint";
        v14 = "%{public}s get_output_local_endpoint requires an output handler, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_output_local_endpoint";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s get_output_local_endpoint requires an output handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }
  v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(v1 + 88);
    if (v3)
      *(_QWORD *)(v1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(v1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 200);
    if (v5)
    {
      v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_9;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  v34 = "__nw_protocol_get_output_local_endpoint";
  if (!v19)
    v19 = "invalid";
  v35 = 2082;
  v36 = (void *)v19;
  v37 = 2048;
  v38 = v1;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v20, &type, &v31))
    goto LABEL_71;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v23 = *(const char **)(v1 + 16);
    if (!v23)
      v23 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_output_local_endpoint";
    v35 = 2082;
    v36 = (void *)v23;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback";
LABEL_70:
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }
  if (!v31)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v29 = *(const char **)(v1 + 16);
    if (!v29)
      v29 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_output_local_endpoint";
    v35 = 2082;
    v36 = (void *)v29;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, backtrace limit exceeded";
    goto LABEL_70;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26)
      goto LABEL_71;
    v30 = *(const char **)(v1 + 16);
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_output_local_endpoint";
    v35 = 2082;
    v36 = (void *)v30;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, no backtrace";
    goto LABEL_70;
  }
  if (v26)
  {
    v27 = *(const char **)(v1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446978;
    v34 = "__nw_protocol_get_output_local_endpoint";
    v35 = 2082;
    v36 = (void *)v27;
    v37 = 2048;
    v38 = v1;
    v39 = 2082;
    v40 = v25;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid get_output_local_endpoint callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v25);
LABEL_71:
  if (v20)
    free(v20);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v1 + 88);
      if (v7)
      {
        v8 = v7 - 1;
        *(_QWORD *)(v1 + 88) = v8;
        if (!v8)
        {
          v9 = *(void (***)(_QWORD))(v1 + 64);
          if (v9)
          {
            *(_QWORD *)(v1 + 64) = 0;
            v9[2](v9);
            _Block_release(v9);
          }
          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            v10 = *(const void **)(v1 + 64);
            if (v10)
              _Block_release(v10);
          }
          free((void *)v1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_common_get_output_interface(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(_QWORD);
  const void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_output_interface";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_output_interface";
      v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v31)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_output_interface";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_get_output_interface";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (!v28)
      goto LABEL_27;
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_output_interface";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }
  v1 = *(_QWORD *)(a1 + 32);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_get_output_interface";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_output_interface";
        v14 = "%{public}s get_output_interface requires an output handler";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_output_interface";
        v14 = "%{public}s get_output_interface requires an output handler, backtrace limit exceeded";
        goto LABEL_32;
      }
LABEL_33:
      if (v11)
        free(v11);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_get_output_interface";
        v14 = "%{public}s get_output_interface requires an output handler, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_get_output_interface";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s get_output_interface requires an output handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }
  v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(v1 + 88);
    if (v3)
      *(_QWORD *)(v1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(v1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 208);
    if (v5)
    {
      v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_9;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  v34 = "__nw_protocol_get_output_interface";
  if (!v19)
    v19 = "invalid";
  v35 = 2082;
  v36 = (void *)v19;
  v37 = 2048;
  v38 = v1;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v20, &type, &v31))
    goto LABEL_71;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v23 = *(const char **)(v1 + 16);
    if (!v23)
      v23 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_output_interface";
    v35 = 2082;
    v36 = (void *)v23;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback";
LABEL_70:
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }
  if (!v31)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v29 = *(const char **)(v1 + 16);
    if (!v29)
      v29 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_output_interface";
    v35 = 2082;
    v36 = (void *)v29;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, backtrace limit exceeded";
    goto LABEL_70;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26)
      goto LABEL_71;
    v30 = *(const char **)(v1 + 16);
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_get_output_interface";
    v35 = 2082;
    v36 = (void *)v30;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, no backtrace";
    goto LABEL_70;
  }
  if (v26)
  {
    v27 = *(const char **)(v1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446978;
    v34 = "__nw_protocol_get_output_interface";
    v35 = 2082;
    v36 = (void *)v27;
    v37 = 2048;
    v38 = v1;
    v39 = 2082;
    v40 = v25;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid get_output_interface callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v25);
LABEL_71:
  if (v20)
    free(v20);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v1 + 88);
      if (v7)
      {
        v8 = v7 - 1;
        *(_QWORD *)(v1 + 88) = v8;
        if (!v8)
        {
          v9 = *(void (***)(_QWORD))(v1 + 64);
          if (v9)
          {
            *(_QWORD *)(v1 + 64) = 0;
            v9[2](v9);
            _Block_release(v9);
          }
          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            v10 = *(const void **)(v1 + 64);
            if (v10)
              _Block_release(v10);
          }
          free((void *)v1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_common_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (**v13)(_QWORD);
  const void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  void (**v24)(_QWORD);
  const void *v25;
  const char *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  const char *v35;
  _BOOL4 v36;
  _BOOL4 v37;
  const char *v38;
  const char *v39;
  char v40;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  void *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  char *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_connect";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v15, &type, &v40))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_connect";
      v18 = "%{public}s called with null protocol";
      goto LABEL_46;
    }
    if (!v40)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_connect";
      v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v36 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v36)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_connect";
      v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_46;
    }
    if (!v36)
      goto LABEL_33;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_connect";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_connect";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v15, &type, &v40))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_connect";
      v18 = "%{public}s called with null other_protocol";
      goto LABEL_46;
    }
    if (!v40)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_connect";
      v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v37 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v37)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_connect";
      v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_46;
    }
    if (!v37)
      goto LABEL_33;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_connect";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      v5 = *(_QWORD *)(v3 + 88);
      if (v5)
        *(_QWORD *)(v3 + 88) = v5 + 1;
    }
    v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(a1 + 88);
      if (v7)
        *(_QWORD *)(a1 + 88) = v7 + 1;
    }
    v8 = *(_QWORD *)(v3 + 24);
    if (v8)
    {
      v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 24);
      if (v9)
      {
        v10 = v9(v3, a1);
        if (v6 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
          {
            v11 = *(_QWORD *)(v3 + 88);
            if (v11)
            {
              v12 = v11 - 1;
              *(_QWORD *)(v3 + 88) = v12;
              if (!v12)
              {
                v13 = *(void (***)(_QWORD))(v3 + 64);
                if (v13)
                {
                  *(_QWORD *)(v3 + 64) = 0;
                  v13[2](v13);
                  _Block_release(v13);
                }
                if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                {
                  v14 = *(const void **)(v3 + 64);
                  if (v14)
                    _Block_release(v14);
                }
                free((void *)v3);
              }
            }
          }
          return v10;
        }
LABEL_13:
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          v22 = *(_QWORD *)(a1 + 88);
          if (v22)
          {
            v23 = v22 - 1;
            *(_QWORD *)(a1 + 88) = v23;
            if (!v23)
            {
              v24 = *(void (***)(_QWORD))(a1 + 64);
              if (v24)
              {
                *(_QWORD *)(a1 + 64) = 0;
                v24[2](v24);
                _Block_release(v24);
              }
              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                v25 = *(const void **)(a1 + 64);
                if (v25)
                  _Block_release(v25);
              }
              free((void *)a1);
            }
          }
        }
        goto LABEL_14;
      }
    }
    __nwlog_obj();
    v27 = *(const char **)(v3 + 16);
    *(_DWORD *)buf = 136446722;
    v43 = "__nw_protocol_connect";
    if (!v27)
      v27 = "invalid";
    v44 = 2082;
    v45 = (void *)v27;
    v46 = 2048;
    v47 = v3;
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v28, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (!os_log_type_enabled(v29, type))
          goto LABEL_95;
        v31 = *(const char **)(v3 + 16);
        if (!v31)
          v31 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_connect";
        v44 = 2082;
        v45 = (void *)v31;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid connect callback";
LABEL_94:
        _os_log_impl(&dword_182FBE000, v29, v30, v32, buf, 0x20u);
        goto LABEL_95;
      }
      if (!v40)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (!os_log_type_enabled(v29, type))
          goto LABEL_95;
        v38 = *(const char **)(v3 + 16);
        if (!v38)
          v38 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_connect";
        v44 = 2082;
        v45 = (void *)v38;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded";
        goto LABEL_94;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v29 = __nwlog_obj();
      v30 = type;
      v34 = os_log_type_enabled(v29, type);
      if (!v33)
      {
        if (!v34)
          goto LABEL_95;
        v39 = *(const char **)(v3 + 16);
        if (!v39)
          v39 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_connect";
        v44 = 2082;
        v45 = (void *)v39;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace";
        goto LABEL_94;
      }
      if (v34)
      {
        v35 = *(const char **)(v3 + 16);
        if (!v35)
          v35 = "invalid";
        *(_DWORD *)buf = 136446978;
        v43 = "__nw_protocol_connect";
        v44 = 2082;
        v45 = (void *)v35;
        v46 = 2048;
        v47 = v3;
        v48 = 2082;
        v49 = v33;
        _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v33);
    }
LABEL_95:
    if (v28)
      free(v28);
    v10 = 0;
    if (v6 != &nw_protocol_ref_counted_handle)
      goto LABEL_14;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v43 = "nw_protocol_common_connect";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (!__nwlog_fault(v15, &type, &v40))
    goto LABEL_47;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v17 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_connect";
      v18 = "%{public}s connect requires an output handler";
LABEL_46:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      goto LABEL_47;
    }
    goto LABEL_47;
  }
  if (v40)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v17 = type;
    v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_common_connect";
        v18 = "%{public}s connect requires an output handler, no backtrace";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    if (!v20)
    {
LABEL_33:
      free(backtrace_string);
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_connect";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s connect requires an output handler, dumping backtrace:%{public}s";
LABEL_32:
    _os_log_impl(&dword_182FBE000, v16, v17, v21, buf, 0x16u);
    goto LABEL_33;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  v17 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_connect";
    v18 = "%{public}s connect requires an output handler, backtrace limit exceeded";
    goto LABEL_46;
  }
LABEL_47:
  if (v15)
    free(v15);
  return 0;
}

uint64_t nw_protocol_common_reset(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (**v13)(_QWORD);
  const void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  void (**v24)(_QWORD);
  const void *v25;
  const char *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  const char *v35;
  _BOOL4 v36;
  _BOOL4 v37;
  const char *v38;
  const char *v39;
  char v40;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  void *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  char *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_reset";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v15, &type, &v40))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_reset";
      v18 = "%{public}s called with null protocol";
      goto LABEL_46;
    }
    if (!v40)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_reset";
      v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v36 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v36)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_reset";
      v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_46;
    }
    if (!v36)
      goto LABEL_33;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_reset";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_reset";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v15, &type, &v40))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_reset";
      v18 = "%{public}s called with null other_protocol";
      goto LABEL_46;
    }
    if (!v40)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_reset";
      v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v37 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v37)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_reset";
      v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_46;
    }
    if (!v37)
      goto LABEL_33;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_reset";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      v5 = *(_QWORD *)(v3 + 88);
      if (v5)
        *(_QWORD *)(v3 + 88) = v5 + 1;
    }
    v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(a1 + 88);
      if (v7)
        *(_QWORD *)(a1 + 88) = v7 + 1;
    }
    v8 = *(_QWORD *)(v3 + 24);
    if (v8)
    {
      v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 256);
      if (v9)
      {
        v10 = v9(v3, a1);
        if (v6 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
          {
            v11 = *(_QWORD *)(v3 + 88);
            if (v11)
            {
              v12 = v11 - 1;
              *(_QWORD *)(v3 + 88) = v12;
              if (!v12)
              {
                v13 = *(void (***)(_QWORD))(v3 + 64);
                if (v13)
                {
                  *(_QWORD *)(v3 + 64) = 0;
                  v13[2](v13);
                  _Block_release(v13);
                }
                if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                {
                  v14 = *(const void **)(v3 + 64);
                  if (v14)
                    _Block_release(v14);
                }
                free((void *)v3);
              }
            }
          }
          return v10;
        }
LABEL_13:
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          v22 = *(_QWORD *)(a1 + 88);
          if (v22)
          {
            v23 = v22 - 1;
            *(_QWORD *)(a1 + 88) = v23;
            if (!v23)
            {
              v24 = *(void (***)(_QWORD))(a1 + 64);
              if (v24)
              {
                *(_QWORD *)(a1 + 64) = 0;
                v24[2](v24);
                _Block_release(v24);
              }
              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                v25 = *(const void **)(a1 + 64);
                if (v25)
                  _Block_release(v25);
              }
              free((void *)a1);
            }
          }
        }
        goto LABEL_14;
      }
    }
    __nwlog_obj();
    v27 = *(const char **)(v3 + 16);
    *(_DWORD *)buf = 136446722;
    v43 = "__nw_protocol_reset";
    if (!v27)
      v27 = "invalid";
    v44 = 2082;
    v45 = (void *)v27;
    v46 = 2048;
    v47 = v3;
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v28, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (!os_log_type_enabled(v29, type))
          goto LABEL_95;
        v31 = *(const char **)(v3 + 16);
        if (!v31)
          v31 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_reset";
        v44 = 2082;
        v45 = (void *)v31;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid reset callback";
LABEL_94:
        _os_log_impl(&dword_182FBE000, v29, v30, v32, buf, 0x20u);
        goto LABEL_95;
      }
      if (!v40)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (!os_log_type_enabled(v29, type))
          goto LABEL_95;
        v38 = *(const char **)(v3 + 16);
        if (!v38)
          v38 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_reset";
        v44 = 2082;
        v45 = (void *)v38;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid reset callback, backtrace limit exceeded";
        goto LABEL_94;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v29 = __nwlog_obj();
      v30 = type;
      v34 = os_log_type_enabled(v29, type);
      if (!v33)
      {
        if (!v34)
          goto LABEL_95;
        v39 = *(const char **)(v3 + 16);
        if (!v39)
          v39 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_reset";
        v44 = 2082;
        v45 = (void *)v39;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid reset callback, no backtrace";
        goto LABEL_94;
      }
      if (v34)
      {
        v35 = *(const char **)(v3 + 16);
        if (!v35)
          v35 = "invalid";
        *(_DWORD *)buf = 136446978;
        v43 = "__nw_protocol_reset";
        v44 = 2082;
        v45 = (void *)v35;
        v46 = 2048;
        v47 = v3;
        v48 = 2082;
        v49 = v33;
        _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s protocol %{public}s (%p) has invalid reset callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v33);
    }
LABEL_95:
    if (v28)
      free(v28);
    v10 = 0;
    if (v6 != &nw_protocol_ref_counted_handle)
      goto LABEL_14;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v43 = "nw_protocol_common_reset";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (!__nwlog_fault(v15, &type, &v40))
    goto LABEL_47;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v17 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_reset";
      v18 = "%{public}s reset requires an output handler";
LABEL_46:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      goto LABEL_47;
    }
    goto LABEL_47;
  }
  if (v40)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v17 = type;
    v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_common_reset";
        v18 = "%{public}s reset requires an output handler, no backtrace";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    if (!v20)
    {
LABEL_33:
      free(backtrace_string);
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_reset";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s reset requires an output handler, dumping backtrace:%{public}s";
LABEL_32:
    _os_log_impl(&dword_182FBE000, v16, v17, v21, buf, 0x16u);
    goto LABEL_33;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  v17 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_reset";
    v18 = "%{public}s reset requires an output handler, backtrace limit exceeded";
    goto LABEL_46;
  }
LABEL_47:
  if (v15)
    free(v15);
  return 0;
}

void nw_protocol_common_connected(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t);
  uint64_t v18;
  uint64_t v19;
  void (**v20)(_QWORD);
  const void *v21;
  char *v22;
  const char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  char *v27;
  _BOOL4 v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  void (**v32)(_QWORD);
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  void (**v36)(_QWORD);
  const void *v37;
  uint64_t v38;
  uint64_t v39;
  void (**v40)(_QWORD);
  const void *v41;
  const char *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  const char *v46;
  const char *v47;
  char *v48;
  _BOOL4 v49;
  const char *v50;
  char *backtrace_string;
  _BOOL4 v52;
  _BOOL4 v53;
  const char *v54;
  char *v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  const char *v59;
  const char *v60;
  char *v61;
  _BOOL4 v62;
  const char *v63;
  const char *v64;
  _BOOL4 v65;
  const char *v66;
  const char *v67;
  char v68;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v71;
  __int16 v72;
  void *v73;
  __int16 v74;
  uint64_t v75;
  __int16 v76;
  char *v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_protocol_common_connected";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v23, &type, &v68))
      goto LABEL_72;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v68)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v24 = __nwlog_obj();
        v25 = type;
        v52 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v52)
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_protocol_common_connected";
            v72 = 2082;
            v73 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v52)
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_protocol_common_connected";
          v26 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_71;
        }
      }
      else
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_protocol_common_connected";
          v26 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_71;
        }
      }
      goto LABEL_72;
    }
    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    v71 = "nw_protocol_common_connected";
    v26 = "%{public}s called with null protocol";
    goto LABEL_71;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_protocol_common_connected";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v23, &type, &v68))
      goto LABEL_72;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v68)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_protocol_common_connected";
          v26 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_71;
        }
        goto LABEL_72;
      }
      v27 = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v53 = os_log_type_enabled(v24, type);
      if (!v27)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_protocol_common_connected";
          v26 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_71;
        }
        goto LABEL_72;
      }
      if (!v53)
        goto LABEL_49;
      *(_DWORD *)buf = 136446466;
      v71 = "nw_protocol_common_connected";
      v72 = 2082;
      v73 = v27;
      v29 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_48:
      _os_log_impl(&dword_182FBE000, v24, v25, v29, buf, 0x16u);
      goto LABEL_49;
    }
    v24 = __nwlog_obj();
    v25 = type;
    if (!os_log_type_enabled(v24, type))
      goto LABEL_72;
    *(_DWORD *)buf = 136446210;
    v71 = "nw_protocol_common_connected";
    v26 = "%{public}s called with null other_protocol";
LABEL_71:
    _os_log_impl(&dword_182FBE000, v24, v25, v26, buf, 0xCu);
    goto LABEL_72;
  }
  v4 = *(_QWORD *)(a1 + 48);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_protocol_common_connected";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v23, &type, &v68))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = gLogObj;
      v25 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_protocol_common_connected";
      v26 = "%{public}s connected requires a default input handler";
      goto LABEL_71;
    }
    if (!v68)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = gLogObj;
      v25 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_protocol_common_connected";
      v26 = "%{public}s connected requires a default input handler, backtrace limit exceeded";
      goto LABEL_71;
    }
    v27 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = gLogObj;
    v25 = type;
    v28 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v27)
    {
      if (!v28)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_protocol_common_connected";
      v26 = "%{public}s connected requires a default input handler, no backtrace";
      goto LABEL_71;
    }
    if (!v28)
      goto LABEL_49;
    *(_DWORD *)buf = 136446466;
    v71 = "nw_protocol_common_connected";
    v72 = 2082;
    v73 = v27;
    v29 = "%{public}s connected requires a default input handler, dumping backtrace:%{public}s";
    goto LABEL_48;
  }
  v5 = *(void **)(v4 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    v6 = *(_QWORD *)(v4 + 88);
    if (v6)
      *(_QWORD *)(v4 + 88) = v6 + 1;
  }
  v7 = *(void **)(a2 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    v8 = *(_QWORD *)(a2 + 88);
    if (v8)
      *(_QWORD *)(a2 + 88) = v8 + 1;
  }
  v9 = *(_QWORD *)(v4 + 24);
  if (v9)
  {
    v10 = *(void (**)(uint64_t, uint64_t))(v9 + 40);
    if (v10)
    {
      v10(v4, a2);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v42 = *(const char **)(v4 + 16);
  *(_DWORD *)buf = 136446722;
  v71 = "__nw_protocol_connected";
  if (!v42)
    v42 = "invalid";
  v72 = 2082;
  v73 = (void *)v42;
  v74 = 2048;
  v75 = v4;
  v43 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v68 = 0;
  if (__nwlog_fault(v43, &type, &v68))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v44 = __nwlog_obj();
      v45 = type;
      if (!os_log_type_enabled(v44, type))
        goto LABEL_148;
      v46 = *(const char **)(v4 + 16);
      if (!v46)
        v46 = "invalid";
      *(_DWORD *)buf = 136446722;
      v71 = "__nw_protocol_connected";
      v72 = 2082;
      v73 = (void *)v46;
      v74 = 2048;
      v75 = v4;
      v47 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_147;
    }
    if (!v68)
    {
      v44 = __nwlog_obj();
      v45 = type;
      if (!os_log_type_enabled(v44, type))
        goto LABEL_148;
      v60 = *(const char **)(v4 + 16);
      if (!v60)
        v60 = "invalid";
      *(_DWORD *)buf = 136446722;
      v71 = "__nw_protocol_connected";
      v72 = 2082;
      v73 = (void *)v60;
      v74 = 2048;
      v75 = v4;
      v47 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_147;
    }
    v48 = (char *)__nw_create_backtrace_string();
    v44 = __nwlog_obj();
    v45 = type;
    v49 = os_log_type_enabled(v44, type);
    if (v48)
    {
      if (v49)
      {
        v50 = *(const char **)(v4 + 16);
        if (!v50)
          v50 = "invalid";
        *(_DWORD *)buf = 136446978;
        v71 = "__nw_protocol_connected";
        v72 = 2082;
        v73 = (void *)v50;
        v74 = 2048;
        v75 = v4;
        v76 = 2082;
        v77 = v48;
        _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v48);
      goto LABEL_148;
    }
    if (v49)
    {
      v64 = *(const char **)(v4 + 16);
      if (!v64)
        v64 = "invalid";
      *(_DWORD *)buf = 136446722;
      v71 = "__nw_protocol_connected";
      v72 = 2082;
      v73 = (void *)v64;
      v74 = 2048;
      v75 = v4;
      v47 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_147:
      _os_log_impl(&dword_182FBE000, v44, v45, v47, buf, 0x20u);
    }
  }
LABEL_148:
  if (v43)
    free(v43);
LABEL_13:
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v30 = *(_QWORD *)(a2 + 88);
    if (v30)
    {
      v31 = v30 - 1;
      *(_QWORD *)(a2 + 88) = v31;
      if (!v31)
      {
        v32 = *(void (***)(_QWORD))(a2 + 64);
        if (v32)
        {
          *(_QWORD *)(a2 + 64) = 0;
          v32[2](v32);
          _Block_release(v32);
        }
        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v33 = *(const void **)(a2 + 64);
          if (v33)
            _Block_release(v33);
        }
        free((void *)a2);
      }
    }
  }
  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    v34 = *(_QWORD *)(v4 + 88);
    if (v34)
    {
      v35 = v34 - 1;
      *(_QWORD *)(v4 + 88) = v35;
      if (!v35)
      {
        v36 = *(void (***)(_QWORD))(v4 + 64);
        if (v36)
        {
          *(_QWORD *)(v4 + 64) = 0;
          v36[2](v36);
          _Block_release(v36);
        }
        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          v37 = *(const void **)(v4 + 64);
          if (v37)
            _Block_release(v37);
        }
        free((void *)v4);
      }
    }
  }
  if (*(_QWORD *)(a1 + 32) != a2)
    return;
  v11 = *(_QWORD *)(a1 + 48);
  if (!v11)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "__nw_protocol_connected";
    v23 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v68 = 0;
    if (!__nwlog_fault(v23, &type, &v68))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "__nw_protocol_connected";
        v26 = "%{public}s called with null protocol";
        goto LABEL_71;
      }
LABEL_72:
      if (!v23)
        return;
      goto LABEL_73;
    }
    if (!v68)
    {
      v24 = __nwlog_obj();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v71 = "__nw_protocol_connected";
        v26 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_71;
      }
      goto LABEL_72;
    }
    v27 = (char *)__nw_create_backtrace_string();
    v24 = __nwlog_obj();
    v25 = type;
    v65 = os_log_type_enabled(v24, type);
    if (!v27)
    {
      if (v65)
      {
        *(_DWORD *)buf = 136446210;
        v71 = "__nw_protocol_connected";
        v26 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_71;
      }
      goto LABEL_72;
    }
    if (v65)
    {
      *(_DWORD *)buf = 136446466;
      v71 = "__nw_protocol_connected";
      v72 = 2082;
      v73 = v27;
      v29 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_48;
    }
LABEL_49:
    free(v27);
    if (!v23)
      return;
LABEL_73:
    v22 = (char *)v23;
LABEL_74:
    free(v22);
    return;
  }
  v12 = *(void **)(v11 + 40);
  if (v12 == &nw_protocol_ref_counted_handle)
  {
    v13 = *(_QWORD *)(v11 + 88);
    if (v13)
      *(_QWORD *)(v11 + 88) = v13 + 1;
  }
  v14 = *(void **)(a1 + 40);
  if (v14 == &nw_protocol_ref_counted_handle)
  {
    v15 = *(_QWORD *)(a1 + 88);
    if (v15)
      *(_QWORD *)(a1 + 88) = v15 + 1;
  }
  v16 = *(_QWORD *)(v11 + 24);
  if (v16)
  {
    v17 = *(void (**)(uint64_t, uint64_t))(v16 + 40);
    if (v17)
    {
      v17(v11, a1);
      goto LABEL_28;
    }
  }
  __nwlog_obj();
  v54 = *(const char **)(v11 + 16);
  *(_DWORD *)buf = 136446722;
  v71 = "__nw_protocol_connected";
  if (!v54)
    v54 = "invalid";
  v72 = 2082;
  v73 = (void *)v54;
  v74 = 2048;
  v75 = v11;
  v55 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v68 = 0;
  if (__nwlog_fault(v55, &type, &v68))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_167;
      v58 = *(const char **)(v11 + 16);
      if (!v58)
        v58 = "invalid";
      *(_DWORD *)buf = 136446722;
      v71 = "__nw_protocol_connected";
      v72 = 2082;
      v73 = (void *)v58;
      v74 = 2048;
      v75 = v11;
      v59 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_166;
    }
    if (!v68)
    {
      v56 = __nwlog_obj();
      v57 = type;
      if (!os_log_type_enabled(v56, type))
        goto LABEL_167;
      v66 = *(const char **)(v11 + 16);
      if (!v66)
        v66 = "invalid";
      *(_DWORD *)buf = 136446722;
      v71 = "__nw_protocol_connected";
      v72 = 2082;
      v73 = (void *)v66;
      v74 = 2048;
      v75 = v11;
      v59 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_166;
    }
    v61 = (char *)__nw_create_backtrace_string();
    v56 = __nwlog_obj();
    v57 = type;
    v62 = os_log_type_enabled(v56, type);
    if (v61)
    {
      if (v62)
      {
        v63 = *(const char **)(v11 + 16);
        if (!v63)
          v63 = "invalid";
        *(_DWORD *)buf = 136446978;
        v71 = "__nw_protocol_connected";
        v72 = 2082;
        v73 = (void *)v63;
        v74 = 2048;
        v75 = v11;
        v76 = 2082;
        v77 = v61;
        _os_log_impl(&dword_182FBE000, v56, v57, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v61);
      goto LABEL_167;
    }
    if (v62)
    {
      v67 = *(const char **)(v11 + 16);
      if (!v67)
        v67 = "invalid";
      *(_DWORD *)buf = 136446722;
      v71 = "__nw_protocol_connected";
      v72 = 2082;
      v73 = (void *)v67;
      v74 = 2048;
      v75 = v11;
      v59 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_166:
      _os_log_impl(&dword_182FBE000, v56, v57, v59, buf, 0x20u);
    }
  }
LABEL_167:
  if (v55)
    free(v55);
LABEL_28:
  if (v14 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    v38 = *(_QWORD *)(a1 + 88);
    if (v38)
    {
      v39 = v38 - 1;
      *(_QWORD *)(a1 + 88) = v39;
      if (!v39)
      {
        v40 = *(void (***)(_QWORD))(a1 + 64);
        if (v40)
        {
          *(_QWORD *)(a1 + 64) = 0;
          v40[2](v40);
          _Block_release(v40);
        }
        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          v41 = *(const void **)(a1 + 64);
          if (v41)
            _Block_release(v41);
        }
        free((void *)a1);
      }
    }
  }
  if (v12 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v11 + 40) == &nw_protocol_ref_counted_handle)
  {
    v18 = *(_QWORD *)(v11 + 88);
    if (v18)
    {
      v19 = v18 - 1;
      *(_QWORD *)(v11 + 88) = v19;
      if (!v19)
      {
        v20 = *(void (***)(_QWORD))(v11 + 64);
        if (v20)
        {
          *(_QWORD *)(v11 + 64) = 0;
          v20[2](v20);
          _Block_release(v20);
        }
        if ((*(_BYTE *)(v11 + 72) & 1) != 0)
        {
          v21 = *(const void **)(v11 + 64);
          if (v21)
            _Block_release(v21);
        }
        v22 = (char *)v11;
        goto LABEL_74;
      }
    }
  }
}

void nw_protocol_common_disconnect(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_disconnect";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnect";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_disconnect";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnect";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnect";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_disconnect";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnect";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_disconnect";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnect";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnect";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_disconnect";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_disconnect";
      v16 = "%{public}s disconnect requires an output handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_disconnect";
      v16 = "%{public}s disconnect requires an output handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_disconnect";
      v16 = "%{public}s disconnect requires an output handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_disconnect";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s disconnect requires an output handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a1 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a1 + 88);
    if (v7)
      *(_QWORD *)(a1 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 32);
    if (v9)
    {
      v9(v3, a1);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_disconnect";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_disconnect";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_disconnect";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_disconnect";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_disconnect";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a1 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a1 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a1 + 64);
        if (v22)
        {
          *(_QWORD *)(a1 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a1 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a1);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_disconnected";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnected";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_disconnected";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnected";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnected";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_disconnected";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnected";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_disconnected";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnected";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_disconnected";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_disconnected";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_disconnected";
      v16 = "%{public}s disconnected requires a default input handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_disconnected";
      v16 = "%{public}s disconnected requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_disconnected";
      v16 = "%{public}s disconnected requires a default input handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_disconnected";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s disconnected requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a1 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a1 + 88);
    if (v7)
      *(_QWORD *)(a1 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 48);
    if (v9)
    {
      v9(v3, a1);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_disconnected";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_disconnected";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_disconnected";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_disconnected";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_disconnected";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a1 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a1 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a1 + 64);
        if (v22)
        {
          *(_QWORD *)(a1 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a1 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a1);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_input_available(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_available";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_input_available";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_available";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_available";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_available";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_input_available";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_available";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_available";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_available";
      v16 = "%{public}s input_available requires a default input handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_available";
      v16 = "%{public}s input_available requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_available";
      v16 = "%{public}s input_available requires a default input handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_input_available";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s input_available requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a1 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a1 + 88);
    if (v7)
      *(_QWORD *)(a1 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 64);
    if (v9)
    {
      v9(v3, a1);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_input_available";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_available";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_available";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_input_available";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_available";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a1 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a1 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a1 + 64);
        if (v22)
        {
          *(_QWORD *)(a1 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a1 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a1);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_output_available(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_output_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_available";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_output_available";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_available";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_available";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_output_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_available";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_output_available";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_available";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_available";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_output_available";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_output_available";
      v16 = "%{public}s output_available requires a default input handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_output_available";
      v16 = "%{public}s output_available requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_output_available";
      v16 = "%{public}s output_available requires a default input handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_output_available";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s output_available requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a2 + 88);
    if (v7)
      *(_QWORD *)(a2 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 72);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_output_available";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_output_available";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_output_available";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_output_available";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_output_available";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a2 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a2 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a2 + 64);
        if (v22)
        {
          *(_QWORD *)(a2 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a2 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a2);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_input_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_finished";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_input_finished";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_finished";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_finished";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_finished";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_input_finished";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_finished";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_finished";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_finished";
      v16 = "%{public}s input_finished requires a default input handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_finished";
      v16 = "%{public}s input_finished requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_finished";
      v16 = "%{public}s input_finished requires a default input handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_input_finished";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s input_finished requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a2 + 88);
    if (v7)
      *(_QWORD *)(a2 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 184);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_input_finished";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_finished";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_finished";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_input_finished";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_finished";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a2 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a2 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a2 + 64);
        if (v22)
        {
          *(_QWORD *)(a2 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a2 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a2);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_output_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_finished";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_output_finished";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_finished";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_finished";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_finished";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_output_finished";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_finished";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_output_finished";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_output_finished";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_output_finished";
      v16 = "%{public}s output_finished requires an output handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_output_finished";
      v16 = "%{public}s output_finished requires an output handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_output_finished";
      v16 = "%{public}s output_finished requires an output handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_output_finished";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s output_finished requires an output handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a2 + 88);
    if (v7)
      *(_QWORD *)(a2 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 192);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_output_finished";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_output_finished";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_output_finished";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_output_finished";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_output_finished";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a2 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a2 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a2 + 64);
        if (v22)
        {
          *(_QWORD *)(a2 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a2 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a2);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_input_flush(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_flush";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_flush";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_input_flush";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_flush";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_flush";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_flush";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_flush";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_input_flush";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_flush";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_input_flush";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_input_flush";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_flush";
      v16 = "%{public}s input_flush requires a default input handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_flush";
      v16 = "%{public}s input_flush requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_input_flush";
      v16 = "%{public}s input_flush requires a default input handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_input_flush";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s input_flush requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a2 + 88);
    if (v7)
      *(_QWORD *)(a2 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 264);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_input_flush";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_flush";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_flush";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_input_flush";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid input_flush callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_input_flush";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid input_flush callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a2 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a2 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a2 + 64);
        if (v22)
        {
          *(_QWORD *)(a2 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a2 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a2);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_error(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  void (**v12)(_QWORD);
  const void *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  char *backtrace_string;
  _BOOL4 v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  void (**v22)(_QWORD);
  const void *v23;
  const char *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  const char *v29;
  char *v30;
  _BOOL4 v31;
  const char *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  void *v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  char *v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_error";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_error";
          v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0xCu);
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_error";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
LABEL_33:
          free(backtrace_string);
          if (!v3)
            return;
          goto LABEL_49;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_error";
          v16 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_error";
          v16 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
LABEL_48:
    if (!v3)
      return;
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_error";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_error";
          v16 = "%{public}s called with null other_protocol";
          goto LABEL_47;
        }
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v34 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v40 = "nw_protocol_common_error";
            v41 = 2082;
            v42 = backtrace_string;
            v19 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_error";
          v16 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_47;
        }
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v40 = "nw_protocol_common_error";
          v16 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_47;
        }
      }
    }
    goto LABEL_48;
  }
  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_common_error";
    v3 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v37))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_error";
      v16 = "%{public}s error requires a default input handler";
      goto LABEL_47;
    }
    if (!v37)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = gLogObj;
      v15 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_error";
      v16 = "%{public}s error requires a default input handler, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = gLogObj;
    v15 = type;
    v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v18)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_common_error";
      v16 = "%{public}s error requires a default input handler, no backtrace";
      goto LABEL_47;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_common_error";
      v41 = 2082;
      v42 = backtrace_string;
      v19 = "%{public}s error requires a default input handler, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_182FBE000, v14, v15, v19, buf, 0x16u);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  v4 = *(void **)(v3 + 40);
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    v5 = *(_QWORD *)(v3 + 88);
    if (v5)
      *(_QWORD *)(v3 + 88) = v5 + 1;
  }
  v6 = *(void **)(a2 + 40);
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    v7 = *(_QWORD *)(a2 + 88);
    if (v7)
      *(_QWORD *)(a2 + 88) = v7 + 1;
  }
  v8 = *(_QWORD *)(v3 + 24);
  if (v8)
  {
    v9 = *(void (**)(uint64_t, uint64_t))(v8 + 56);
    if (v9)
    {
      v9(v3, a2);
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  v24 = *(const char **)(v3 + 16);
  *(_DWORD *)buf = 136446722;
  v40 = "__nw_protocol_error";
  if (!v24)
    v24 = "invalid";
  v41 = 2082;
  v42 = (void *)v24;
  v43 = 2048;
  v44 = v3;
  v25 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v37 = 0;
  if (__nwlog_fault(v25, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v28 = *(const char **)(v3 + 16);
      if (!v28)
        v28 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_error";
      v41 = 2082;
      v42 = (void *)v28;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid error callback";
      goto LABEL_94;
    }
    if (!v37)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_95;
      v35 = *(const char **)(v3 + 16);
      if (!v35)
        v35 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_error";
      v41 = 2082;
      v42 = (void *)v35;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v26 = __nwlog_obj();
    v27 = type;
    v31 = os_log_type_enabled(v26, type);
    if (v30)
    {
      if (v31)
      {
        v32 = *(const char **)(v3 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446978;
        v40 = "__nw_protocol_error";
        v41 = 2082;
        v42 = (void *)v32;
        v43 = 2048;
        v44 = v3;
        v45 = 2082;
        v46 = v30;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_95;
    }
    if (v31)
    {
      v36 = *(const char **)(v3 + 16);
      if (!v36)
        v36 = "invalid";
      *(_DWORD *)buf = 136446722;
      v40 = "__nw_protocol_error";
      v41 = 2082;
      v42 = (void *)v36;
      v43 = 2048;
      v44 = v3;
      v29 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v26, v27, v29, buf, 0x20u);
    }
  }
LABEL_95:
  if (v25)
    free(v25);
LABEL_13:
  if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v20 = *(_QWORD *)(a2 + 88);
    if (v20)
    {
      v21 = v20 - 1;
      *(_QWORD *)(a2 + 88) = v21;
      if (!v21)
      {
        v22 = *(void (***)(_QWORD))(a2 + 64);
        if (v22)
        {
          *(_QWORD *)(a2 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v23 = *(const void **)(a2 + 64);
          if (v23)
            _Block_release(v23);
        }
        free((void *)a2);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
  {
    v10 = *(_QWORD *)(v3 + 88);
    if (v10)
    {
      v11 = v10 - 1;
      *(_QWORD *)(v3 + 88) = v11;
      if (!v11)
      {
        v12 = *(void (***)(_QWORD))(v3 + 64);
        if (v12)
        {
          *(_QWORD *)(v3 + 64) = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if ((*(_BYTE *)(v3 + 72) & 1) != 0)
        {
          v13 = *(const void **)(v3 + 64);
          if (v13)
            _Block_release(v13);
        }
LABEL_49:
        free((void *)v3);
      }
    }
  }
}

void nw_protocol_common_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  void (**v13)(_QWORD);
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  void (**v17)(_QWORD);
  const void *v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  NSObject *v25;
  os_log_type_t v26;
  const char *v27;
  char *v28;
  _BOOL4 v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  NSObject *v36;
  const char *v37;
  const char *v38;
  char v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  void *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  char *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_get_message_properties";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v39))
      goto LABEL_104;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null protocol";
      goto LABEL_103;
    }
    if (!v39)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_103;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v32 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (!v32)
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_103;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_common_get_message_properties";
      v43 = 2082;
      v44 = backtrace_string;
      v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_75:
      _os_log_impl(&dword_182FBE000, v25, v26, v33, buf, 0x16u);
    }
LABEL_76:
    free(backtrace_string);
    if (!v4)
      return;
LABEL_25:
    free((void *)v4);
    return;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_get_message_properties";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v39))
      goto LABEL_104;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null other_protocol";
      goto LABEL_103;
    }
    if (!v39)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_103;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v34 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (!v34)
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_103;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_common_get_message_properties";
      v43 = 2082;
      v44 = backtrace_string;
      v33 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_75;
    }
    goto LABEL_76;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_get_message_properties";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v39))
      goto LABEL_104;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null message_properties";
      goto LABEL_103;
    }
    if (!v39)
    {
      v25 = __nwlog_obj();
      v26 = type;
      if (!os_log_type_enabled(v25, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_get_message_properties";
      v27 = "%{public}s called with null message_properties, backtrace limit exceeded";
      goto LABEL_103;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v25 = __nwlog_obj();
    v26 = type;
    v35 = os_log_type_enabled(v25, type);
    if (backtrace_string)
    {
      if (!v35)
        goto LABEL_76;
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_common_get_message_properties";
      v43 = 2082;
      v44 = backtrace_string;
      v33 = "%{public}s called with null message_properties, dumping backtrace:%{public}s";
      goto LABEL_75;
    }
    if (!v35)
      goto LABEL_104;
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_get_message_properties";
    v27 = "%{public}s called with null message_properties, no backtrace";
LABEL_103:
    _os_log_impl(&dword_182FBE000, v25, v26, v27, buf, 0xCu);
LABEL_104:
    if (!v4)
      return;
    goto LABEL_25;
  }
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
  {
    if (gLogDatapath)
    {
      v36 = __nwlog_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v42 = "nw_protocol_common_get_message_properties";
        _os_log_impl(&dword_182FBE000, v36, OS_LOG_TYPE_DEBUG, "%{public}s get_message_properties requires an output handler", buf, 0xCu);
      }
    }
    return;
  }
  v5 = *(void **)(v4 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    v6 = *(_QWORD *)(v4 + 88);
    if (v6)
      *(_QWORD *)(v4 + 88) = v6 + 1;
  }
  v7 = *(void **)(a1 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    v8 = *(_QWORD *)(a1 + 88);
    if (v8)
      *(_QWORD *)(a1 + 88) = v8 + 1;
  }
  v9 = *(_QWORD *)(v4 + 24);
  if (v9)
  {
    v10 = *(void (**)(uint64_t, uint64_t))(v9 + 248);
    if (v10)
    {
      v10(v4, a1);
      goto LABEL_14;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v4 + 16);
  *(_DWORD *)buf = 136446722;
  v42 = "__nw_protocol_get_message_properties";
  if (!v19)
    v19 = "invalid";
  v43 = 2082;
  v44 = (void *)v19;
  v45 = 2048;
  v46 = v4;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v20, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
        goto LABEL_95;
      v23 = *(const char **)(v4 + 16);
      if (!v23)
        v23 = "invalid";
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_get_message_properties";
      v43 = 2082;
      v44 = (void *)v23;
      v45 = 2048;
      v46 = v4;
      v24 = "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback";
      goto LABEL_94;
    }
    if (!v39)
    {
      v21 = __nwlog_obj();
      v22 = type;
      if (!os_log_type_enabled(v21, type))
        goto LABEL_95;
      v37 = *(const char **)(v4 + 16);
      if (!v37)
        v37 = "invalid";
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_get_message_properties";
      v43 = 2082;
      v44 = (void *)v37;
      v45 = 2048;
      v46 = v4;
      v24 = "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, backtrace limit exceeded";
      goto LABEL_94;
    }
    v28 = (char *)__nw_create_backtrace_string();
    v21 = __nwlog_obj();
    v22 = type;
    v29 = os_log_type_enabled(v21, type);
    if (v28)
    {
      if (v29)
      {
        v30 = *(const char **)(v4 + 16);
        if (!v30)
          v30 = "invalid";
        *(_DWORD *)buf = 136446978;
        v42 = "__nw_protocol_get_message_properties";
        v43 = 2082;
        v44 = (void *)v30;
        v45 = 2048;
        v46 = v4;
        v47 = 2082;
        v48 = v28;
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v28);
      goto LABEL_95;
    }
    if (v29)
    {
      v38 = *(const char **)(v4 + 16);
      if (!v38)
        v38 = "invalid";
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_get_message_properties";
      v43 = 2082;
      v44 = (void *)v38;
      v45 = 2048;
      v46 = v4;
      v24 = "%{public}s protocol %{public}s (%p) has invalid get_message_properties callback, no backtrace";
LABEL_94:
      _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    }
  }
LABEL_95:
  if (v20)
    free(v20);
LABEL_14:
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    v15 = *(_QWORD *)(a1 + 88);
    if (v15)
    {
      v16 = v15 - 1;
      *(_QWORD *)(a1 + 88) = v16;
      if (!v16)
      {
        v17 = *(void (***)(_QWORD))(a1 + 64);
        if (v17)
        {
          *(_QWORD *)(a1 + 64) = 0;
          v17[2](v17);
          _Block_release(v17);
        }
        if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        {
          v18 = *(const void **)(a1 + 64);
          if (v18)
            _Block_release(v18);
        }
        free((void *)a1);
      }
    }
  }
  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    v11 = *(_QWORD *)(v4 + 88);
    if (v11)
    {
      v12 = v11 - 1;
      *(_QWORD *)(v4 + 88) = v12;
      if (!v12)
      {
        v13 = *(void (***)(_QWORD))(v4 + 64);
        if (v13)
        {
          *(_QWORD *)(v4 + 64) = 0;
          v13[2](v13);
          _Block_release(v13);
        }
        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          v14 = *(const void **)(v4 + 64);
          if (v14)
            _Block_release(v14);
        }
        goto LABEL_25;
      }
    }
  }
}

uint64_t nw_protocol_common_copy_info(uint64_t a1, int a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void (**v10)(_QWORD);
  const void *v11;
  const char *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  _BOOL4 v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v32;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  void *v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  char *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_common_copy_info";
    v18 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v18, &type, &v32))
      goto LABEL_74;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        v19 = __nwlog_obj();
        v20 = type;
        if (!os_log_type_enabled(v19, type))
          goto LABEL_74;
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_common_copy_info";
        v21 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_73;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v19 = __nwlog_obj();
      v20 = type;
      v26 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (!v26)
          goto LABEL_74;
        *(_DWORD *)buf = 136446210;
        v35 = "nw_protocol_common_copy_info";
        v21 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_73;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_protocol_common_copy_info";
        v36 = 2082;
        v37 = backtrace_string;
        v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_50:
        _os_log_impl(&dword_182FBE000, v19, v20, v27, buf, 0x16u);
      }
LABEL_51:
      free(backtrace_string);
      goto LABEL_74;
    }
    v19 = __nwlog_obj();
    v20 = type;
    if (!os_log_type_enabled(v19, type))
      goto LABEL_74;
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_common_copy_info";
    v21 = "%{public}s called with null protocol";
LABEL_73:
    _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
LABEL_74:
    if (v18)
      free(v18);
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_common_copy_info";
    v18 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (!__nwlog_fault(v18, &type, &v32))
      goto LABEL_74;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_common_copy_info";
      v21 = "%{public}s called with null type";
      goto LABEL_73;
    }
    if (!v32)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v35 = "nw_protocol_common_copy_info";
      v21 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v28 = os_log_type_enabled(v19, type);
    if (backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_protocol_common_copy_info";
        v36 = 2082;
        v37 = backtrace_string;
        v27 = "%{public}s called with null type, dumping backtrace:%{public}s";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (!v28)
      goto LABEL_74;
    *(_DWORD *)buf = 136446210;
    v35 = "nw_protocol_common_copy_info";
    v21 = "%{public}s called with null type, no backtrace";
    goto LABEL_73;
  }
  v2 = *(_QWORD *)(a1 + 32);
  if (!v2)
    return 0;
  v3 = *(void **)(v2 + 40);
  if (v3 == &nw_protocol_ref_counted_handle)
  {
    v4 = *(_QWORD *)(v2 + 88);
    if (v4)
      *(_QWORD *)(v2 + 88) = v4 + 1;
  }
  v5 = *(_QWORD *)(v2 + 24);
  if (v5)
  {
    v6 = *(uint64_t (**)(uint64_t))(v5 + 224);
    if (v6)
    {
      v7 = v6(v2);
      if (v3 != &nw_protocol_ref_counted_handle)
        return v7;
      goto LABEL_10;
    }
  }
  __nwlog_obj();
  v12 = *(const char **)(v2 + 16);
  *(_DWORD *)buf = 136446722;
  v35 = "__nw_protocol_copy_info";
  if (!v12)
    v12 = "invalid";
  v36 = 2082;
  v37 = (void *)v12;
  v38 = 2048;
  v39 = v2;
  v13 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v32 = 0;
  if (__nwlog_fault(v13, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_65;
      v16 = *(const char **)(v2 + 16);
      if (!v16)
        v16 = "invalid";
      *(_DWORD *)buf = 136446722;
      v35 = "__nw_protocol_copy_info";
      v36 = 2082;
      v37 = (void *)v16;
      v38 = 2048;
      v39 = v2;
      v17 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback";
LABEL_64:
      _os_log_impl(&dword_182FBE000, v14, v15, v17, buf, 0x20u);
      goto LABEL_65;
    }
    if (!v32)
    {
      v14 = __nwlog_obj();
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_65;
      v29 = *(const char **)(v2 + 16);
      if (!v29)
        v29 = "invalid";
      *(_DWORD *)buf = 136446722;
      v35 = "__nw_protocol_copy_info";
      v36 = 2082;
      v37 = (void *)v29;
      v38 = 2048;
      v39 = v2;
      v17 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback, backtrace limit exceeded";
      goto LABEL_64;
    }
    v22 = (char *)__nw_create_backtrace_string();
    v14 = __nwlog_obj();
    v15 = type;
    v23 = os_log_type_enabled(v14, type);
    if (!v22)
    {
      if (!v23)
        goto LABEL_65;
      v30 = *(const char **)(v2 + 16);
      if (!v30)
        v30 = "invalid";
      *(_DWORD *)buf = 136446722;
      v35 = "__nw_protocol_copy_info";
      v36 = 2082;
      v37 = (void *)v30;
      v38 = 2048;
      v39 = v2;
      v17 = "%{public}s protocol %{public}s (%p) has invalid copy_info callback, no backtrace";
      goto LABEL_64;
    }
    if (v23)
    {
      v24 = *(const char **)(v2 + 16);
      if (!v24)
        v24 = "invalid";
      *(_DWORD *)buf = 136446978;
      v35 = "__nw_protocol_copy_info";
      v36 = 2082;
      v37 = (void *)v24;
      v38 = 2048;
      v39 = v2;
      v40 = 2082;
      v41 = v22;
      _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s protocol %{public}s (%p) has invalid copy_info callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v22);
  }
LABEL_65:
  if (v13)
    free(v13);
  v7 = 0;
  if (v3 == &nw_protocol_ref_counted_handle)
  {
LABEL_10:
    if (*(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
    {
      v8 = *(_QWORD *)(v2 + 88);
      if (v8)
      {
        v9 = v8 - 1;
        *(_QWORD *)(v2 + 88) = v9;
        if (!v9)
        {
          v10 = *(void (***)(_QWORD))(v2 + 64);
          if (v10)
          {
            *(_QWORD *)(v2 + 64) = 0;
            v10[2](v10);
            _Block_release(v10);
          }
          if ((*(_BYTE *)(v2 + 72) & 1) != 0)
          {
            v11 = *(const void **)(v2 + 64);
            if (v11)
              _Block_release(v11);
          }
          free((void *)v2);
        }
      }
    }
  }
  return v7;
}

uint64_t nw_protocol_common_supports_external_data(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (**v9)(_QWORD);
  const void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *backtrace_string;
  _BOOL4 v16;
  const char *v17;
  const char *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  const char *v29;
  const char *v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  void *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  char *v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_supports_external_data";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_supports_external_data";
      v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v31)
    {
      v12 = __nwlog_obj();
      v13 = type;
      if (!os_log_type_enabled(v12, type))
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_supports_external_data";
      v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v12 = __nwlog_obj();
    v13 = type;
    v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_33;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_protocol_common_supports_external_data";
      v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (!v28)
      goto LABEL_27;
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_supports_external_data";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }
  v1 = *(_QWORD *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_protocol_common_supports_external_data";
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v11, &type, &v31))
      goto LABEL_33;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_supports_external_data";
        v14 = "%{public}s supports_external_data requires an input handler";
LABEL_32:
        _os_log_impl(&dword_182FBE000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }
      goto LABEL_33;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = gLogObj;
      v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_supports_external_data";
        v14 = "%{public}s supports_external_data requires an input handler, backtrace limit exceeded";
        goto LABEL_32;
      }
LABEL_33:
      if (v11)
        free(v11);
      return 0;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    v13 = type;
    v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_protocol_common_supports_external_data";
        v14 = "%{public}s supports_external_data requires an input handler, no backtrace";
        goto LABEL_32;
      }
      goto LABEL_33;
    }
    if (!v16)
    {
LABEL_27:
      free(backtrace_string);
      goto LABEL_33;
    }
    *(_DWORD *)buf = 136446466;
    v34 = "nw_protocol_common_supports_external_data";
    v35 = 2082;
    v36 = backtrace_string;
    v17 = "%{public}s supports_external_data requires an input handler, dumping backtrace:%{public}s";
LABEL_26:
    _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
    goto LABEL_27;
  }
  v2 = *(void **)(v1 + 40);
  if (v2 == &nw_protocol_ref_counted_handle)
  {
    v3 = *(_QWORD *)(v1 + 88);
    if (v3)
      *(_QWORD *)(v1 + 88) = v3 + 1;
  }
  v4 = *(_QWORD *)(v1 + 24);
  if (v4)
  {
    v5 = *(uint64_t (**)(uint64_t))(v4 + 176);
    if (v5)
    {
      v6 = v5(v1);
      if (v2 != &nw_protocol_ref_counted_handle)
        return v6;
      goto LABEL_9;
    }
  }
  __nwlog_obj();
  v19 = *(const char **)(v1 + 16);
  *(_DWORD *)buf = 136446722;
  v34 = "__nw_protocol_supports_external_data";
  if (!v19)
    v19 = "invalid";
  v35 = 2082;
  v36 = (void *)v19;
  v37 = 2048;
  v38 = v1;
  v20 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (!__nwlog_fault(v20, &type, &v31))
    goto LABEL_71;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v23 = *(const char **)(v1 + 16);
    if (!v23)
      v23 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_supports_external_data";
    v35 = 2082;
    v36 = (void *)v23;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid supports_external_data callback";
LABEL_70:
    _os_log_impl(&dword_182FBE000, v21, v22, v24, buf, 0x20u);
    goto LABEL_71;
  }
  if (!v31)
  {
    v21 = __nwlog_obj();
    v22 = type;
    if (!os_log_type_enabled(v21, type))
      goto LABEL_71;
    v29 = *(const char **)(v1 + 16);
    if (!v29)
      v29 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_supports_external_data";
    v35 = 2082;
    v36 = (void *)v29;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid supports_external_data callback, backtrace limit exceeded";
    goto LABEL_70;
  }
  v25 = (char *)__nw_create_backtrace_string();
  v21 = __nwlog_obj();
  v22 = type;
  v26 = os_log_type_enabled(v21, type);
  if (!v25)
  {
    if (!v26)
      goto LABEL_71;
    v30 = *(const char **)(v1 + 16);
    if (!v30)
      v30 = "invalid";
    *(_DWORD *)buf = 136446722;
    v34 = "__nw_protocol_supports_external_data";
    v35 = 2082;
    v36 = (void *)v30;
    v37 = 2048;
    v38 = v1;
    v24 = "%{public}s protocol %{public}s (%p) has invalid supports_external_data callback, no backtrace";
    goto LABEL_70;
  }
  if (v26)
  {
    v27 = *(const char **)(v1 + 16);
    if (!v27)
      v27 = "invalid";
    *(_DWORD *)buf = 136446978;
    v34 = "__nw_protocol_supports_external_data";
    v35 = 2082;
    v36 = (void *)v27;
    v37 = 2048;
    v38 = v1;
    v39 = 2082;
    v40 = v25;
    _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid supports_external_data callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v25);
LABEL_71:
  if (v20)
    free(v20);
  v6 = 0;
  if (v2 == &nw_protocol_ref_counted_handle)
  {
LABEL_9:
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(v1 + 88);
      if (v7)
      {
        v8 = v7 - 1;
        *(_QWORD *)(v1 + 88) = v8;
        if (!v8)
        {
          v9 = *(void (***)(_QWORD))(v1 + 64);
          if (v9)
          {
            *(_QWORD *)(v1 + 64) = 0;
            v9[2](v9);
            _Block_release(v9);
          }
          if ((*(_BYTE *)(v1 + 72) & 1) != 0)
          {
            v10 = *(const void **)(v1 + 64);
            if (v10)
              _Block_release(v10);
          }
          free((void *)v1);
        }
      }
    }
  }
  return v6;
}

uint64_t nw_protocol_common_waiting_for_output(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (**v13)(_QWORD);
  const void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  char *backtrace_string;
  _BOOL4 v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  void (**v24)(_QWORD);
  const void *v25;
  const char *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  const char *v32;
  char *v33;
  _BOOL4 v34;
  const char *v35;
  _BOOL4 v36;
  _BOOL4 v37;
  const char *v38;
  const char *v39;
  char v40;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  void *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  char *v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_waiting_for_output";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v15, &type, &v40))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_waiting_for_output";
      v18 = "%{public}s called with null protocol";
      goto LABEL_46;
    }
    if (!v40)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_waiting_for_output";
      v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v36 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v36)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_waiting_for_output";
      v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_46;
    }
    if (!v36)
      goto LABEL_33;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_waiting_for_output";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_waiting_for_output";
    v15 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (!__nwlog_fault(v15, &type, &v40))
      goto LABEL_47;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_waiting_for_output";
      v18 = "%{public}s called with null other_protocol";
      goto LABEL_46;
    }
    if (!v40)
    {
      v16 = __nwlog_obj();
      v17 = type;
      if (!os_log_type_enabled(v16, type))
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_waiting_for_output";
      v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v16 = __nwlog_obj();
    v17 = type;
    v37 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v37)
        goto LABEL_47;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_waiting_for_output";
      v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_46;
    }
    if (!v37)
      goto LABEL_33;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_waiting_for_output";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }
  v3 = *(_QWORD *)(a1 + 32);
  if (v3)
  {
    v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      v5 = *(_QWORD *)(v3 + 88);
      if (v5)
        *(_QWORD *)(v3 + 88) = v5 + 1;
    }
    v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      v7 = *(_QWORD *)(a1 + 88);
      if (v7)
        *(_QWORD *)(a1 + 88) = v7 + 1;
    }
    v8 = *(_QWORD *)(v3 + 24);
    if (v8)
    {
      v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 216);
      if (v9)
      {
        v10 = v9(v3, a1);
        if (v6 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
          {
            v11 = *(_QWORD *)(v3 + 88);
            if (v11)
            {
              v12 = v11 - 1;
              *(_QWORD *)(v3 + 88) = v12;
              if (!v12)
              {
                v13 = *(void (***)(_QWORD))(v3 + 64);
                if (v13)
                {
                  *(_QWORD *)(v3 + 64) = 0;
                  v13[2](v13);
                  _Block_release(v13);
                }
                if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                {
                  v14 = *(const void **)(v3 + 64);
                  if (v14)
                    _Block_release(v14);
                }
                free((void *)v3);
              }
            }
          }
          return v10;
        }
LABEL_13:
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          v22 = *(_QWORD *)(a1 + 88);
          if (v22)
          {
            v23 = v22 - 1;
            *(_QWORD *)(a1 + 88) = v23;
            if (!v23)
            {
              v24 = *(void (***)(_QWORD))(a1 + 64);
              if (v24)
              {
                *(_QWORD *)(a1 + 64) = 0;
                v24[2](v24);
                _Block_release(v24);
              }
              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
              {
                v25 = *(const void **)(a1 + 64);
                if (v25)
                  _Block_release(v25);
              }
              free((void *)a1);
            }
          }
        }
        goto LABEL_14;
      }
    }
    __nwlog_obj();
    v27 = *(const char **)(v3 + 16);
    *(_DWORD *)buf = 136446722;
    v43 = "__nw_protocol_waiting_for_output";
    if (!v27)
      v27 = "invalid";
    v44 = 2082;
    v45 = (void *)v27;
    v46 = 2048;
    v47 = v3;
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v40 = 0;
    if (__nwlog_fault(v28, &type, &v40))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (!os_log_type_enabled(v29, type))
          goto LABEL_95;
        v31 = *(const char **)(v3 + 16);
        if (!v31)
          v31 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_waiting_for_output";
        v44 = 2082;
        v45 = (void *)v31;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback";
LABEL_94:
        _os_log_impl(&dword_182FBE000, v29, v30, v32, buf, 0x20u);
        goto LABEL_95;
      }
      if (!v40)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (!os_log_type_enabled(v29, type))
          goto LABEL_95;
        v38 = *(const char **)(v3 + 16);
        if (!v38)
          v38 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_waiting_for_output";
        v44 = 2082;
        v45 = (void *)v38;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback, backtrace limit exceeded";
        goto LABEL_94;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v29 = __nwlog_obj();
      v30 = type;
      v34 = os_log_type_enabled(v29, type);
      if (!v33)
      {
        if (!v34)
          goto LABEL_95;
        v39 = *(const char **)(v3 + 16);
        if (!v39)
          v39 = "invalid";
        *(_DWORD *)buf = 136446722;
        v43 = "__nw_protocol_waiting_for_output";
        v44 = 2082;
        v45 = (void *)v39;
        v46 = 2048;
        v47 = v3;
        v32 = "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback, no backtrace";
        goto LABEL_94;
      }
      if (v34)
      {
        v35 = *(const char **)(v3 + 16);
        if (!v35)
          v35 = "invalid";
        *(_DWORD *)buf = 136446978;
        v43 = "__nw_protocol_waiting_for_output";
        v44 = 2082;
        v45 = (void *)v35;
        v46 = 2048;
        v47 = v3;
        v48 = 2082;
        v49 = v33;
        _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s protocol %{public}s (%p) has invalid waiting_for_output callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v33);
    }
LABEL_95:
    if (v28)
      free(v28);
    v10 = 0;
    if (v6 != &nw_protocol_ref_counted_handle)
      goto LABEL_14;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v43 = "nw_protocol_common_waiting_for_output";
  v15 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v40 = 0;
  if (!__nwlog_fault(v15, &type, &v40))
    goto LABEL_47;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v17 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_common_waiting_for_output";
      v18 = "%{public}s waiting_for_output requires an output handler";
LABEL_46:
      _os_log_impl(&dword_182FBE000, v16, v17, v18, buf, 0xCu);
      goto LABEL_47;
    }
    goto LABEL_47;
  }
  if (v40)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    v17 = type;
    v20 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_common_waiting_for_output";
        v18 = "%{public}s waiting_for_output requires an output handler, no backtrace";
        goto LABEL_46;
      }
      goto LABEL_47;
    }
    if (!v20)
    {
LABEL_33:
      free(backtrace_string);
      goto LABEL_47;
    }
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_common_waiting_for_output";
    v44 = 2082;
    v45 = backtrace_string;
    v21 = "%{public}s waiting_for_output requires an output handler, dumping backtrace:%{public}s";
LABEL_32:
    _os_log_impl(&dword_182FBE000, v16, v17, v21, buf, 0x16u);
    goto LABEL_33;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v16 = gLogObj;
  v17 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_common_waiting_for_output";
    v18 = "%{public}s waiting_for_output requires an output handler, backtrace limit exceeded";
    goto LABEL_46;
  }
LABEL_47:
  if (v15)
    free(v15);
  return 0;
}

uint64_t nw_protocol_common_register_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (**v14)(_QWORD);
  const void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void (**v25)(_QWORD);
  const void *v26;
  const char *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  const char *v33;
  char *v34;
  _BOOL4 v35;
  const char *v36;
  _BOOL4 v37;
  _BOOL4 v38;
  _BOOL4 v39;
  const char *v40;
  const char *v41;
  char v42;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  void *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  char *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_register_notification";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v16, &type, &v42))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null protocol";
      goto LABEL_47;
    }
    if (!v42)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v37 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v37)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_47;
    }
    if (!v37)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_register_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_register_notification";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v16, &type, &v42))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null other_protocol";
      goto LABEL_47;
    }
    if (!v42)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v38 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v38)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_47;
    }
    if (!v38)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_register_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_register_notification";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v16, &type, &v42))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null type";
      goto LABEL_47;
    }
    if (!v42)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v39 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v39)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s called with null type, no backtrace";
      goto LABEL_47;
    }
    if (!v39)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_register_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s called with null type, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v5 = *(void **)(v4 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      v6 = *(_QWORD *)(v4 + 88);
      if (v6)
        *(_QWORD *)(v4 + 88) = v6 + 1;
    }
    v7 = *(void **)(a2 + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      v8 = *(_QWORD *)(a2 + 88);
      if (v8)
        *(_QWORD *)(a2 + 88) = v8 + 1;
    }
    v9 = *(_QWORD *)(v4 + 24);
    if (v9)
    {
      v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 144);
      if (v10)
      {
        v11 = v10(v4, a2);
        if (v7 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
          {
            v12 = *(_QWORD *)(v4 + 88);
            if (v12)
            {
              v13 = v12 - 1;
              *(_QWORD *)(v4 + 88) = v13;
              if (!v13)
              {
                v14 = *(void (***)(_QWORD))(v4 + 64);
                if (v14)
                {
                  *(_QWORD *)(v4 + 64) = 0;
                  v14[2](v14);
                  _Block_release(v14);
                }
                if ((*(_BYTE *)(v4 + 72) & 1) != 0)
                {
                  v15 = *(const void **)(v4 + 64);
                  if (v15)
                    _Block_release(v15);
                }
                free((void *)v4);
              }
            }
          }
          return v11;
        }
LABEL_14:
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          v23 = *(_QWORD *)(a2 + 88);
          if (v23)
          {
            v24 = v23 - 1;
            *(_QWORD *)(a2 + 88) = v24;
            if (!v24)
            {
              v25 = *(void (***)(_QWORD))(a2 + 64);
              if (v25)
              {
                *(_QWORD *)(a2 + 64) = 0;
                v25[2](v25);
                _Block_release(v25);
              }
              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                v26 = *(const void **)(a2 + 64);
                if (v26)
                  _Block_release(v26);
              }
              free((void *)a2);
            }
          }
        }
        goto LABEL_15;
      }
    }
    __nwlog_obj();
    v28 = *(const char **)(v4 + 16);
    *(_DWORD *)buf = 136446722;
    v45 = "__nw_protocol_register_notification";
    if (!v28)
      v28 = "invalid";
    v46 = 2082;
    v47 = (void *)v28;
    v48 = 2048;
    v49 = v4;
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v29, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (!os_log_type_enabled(v30, type))
          goto LABEL_106;
        v32 = *(const char **)(v4 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_register_notification";
        v46 = 2082;
        v47 = (void *)v32;
        v48 = 2048;
        v49 = v4;
        v33 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback";
LABEL_105:
        _os_log_impl(&dword_182FBE000, v30, v31, v33, buf, 0x20u);
        goto LABEL_106;
      }
      if (!v42)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (!os_log_type_enabled(v30, type))
          goto LABEL_106;
        v40 = *(const char **)(v4 + 16);
        if (!v40)
          v40 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_register_notification";
        v46 = 2082;
        v47 = (void *)v40;
        v48 = 2048;
        v49 = v4;
        v33 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback, backtrace limit exceeded";
        goto LABEL_105;
      }
      v34 = (char *)__nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v35 = os_log_type_enabled(v30, type);
      if (!v34)
      {
        if (!v35)
          goto LABEL_106;
        v41 = *(const char **)(v4 + 16);
        if (!v41)
          v41 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_register_notification";
        v46 = 2082;
        v47 = (void *)v41;
        v48 = 2048;
        v49 = v4;
        v33 = "%{public}s protocol %{public}s (%p) has invalid register_notification callback, no backtrace";
        goto LABEL_105;
      }
      if (v35)
      {
        v36 = *(const char **)(v4 + 16);
        if (!v36)
          v36 = "invalid";
        *(_DWORD *)buf = 136446978;
        v45 = "__nw_protocol_register_notification";
        v46 = 2082;
        v47 = (void *)v36;
        v48 = 2048;
        v49 = v4;
        v50 = 2082;
        v51 = v34;
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s protocol %{public}s (%p) has invalid register_notification callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v34);
    }
LABEL_106:
    if (v29)
      free(v29);
    v11 = 0;
    if (v7 != &nw_protocol_ref_counted_handle)
      goto LABEL_15;
    goto LABEL_14;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v45 = "nw_protocol_common_register_notification";
  v16 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (!__nwlog_fault(v16, &type, &v42))
    goto LABEL_48;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_register_notification";
      v19 = "%{public}s register_notification requires an output handler";
LABEL_47:
      _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
      goto LABEL_48;
    }
    goto LABEL_48;
  }
  if (v42)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = type;
    v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_protocol_common_register_notification";
        v19 = "%{public}s register_notification requires an output handler, no backtrace";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (!v21)
    {
LABEL_34:
      free(backtrace_string);
      goto LABEL_48;
    }
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_register_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s register_notification requires an output handler, dumping backtrace:%{public}s";
LABEL_33:
    _os_log_impl(&dword_182FBE000, v17, v18, v22, buf, 0x16u);
    goto LABEL_34;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = gLogObj;
  v18 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_register_notification";
    v19 = "%{public}s register_notification requires an output handler, backtrace limit exceeded";
    goto LABEL_47;
  }
LABEL_48:
  if (v16)
    free(v16);
  return 0;
}

uint64_t nw_protocol_common_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (**v14)(_QWORD);
  const void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  void (**v25)(_QWORD);
  const void *v26;
  const char *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  const char *v32;
  const char *v33;
  char *v34;
  _BOOL4 v35;
  const char *v36;
  _BOOL4 v37;
  _BOOL4 v38;
  _BOOL4 v39;
  const char *v40;
  const char *v41;
  char v42;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  void *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  char *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_unregister_notification";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v16, &type, &v42))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null protocol";
      goto LABEL_47;
    }
    if (!v42)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v37 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v37)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_47;
    }
    if (!v37)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_unregister_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_unregister_notification";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v16, &type, &v42))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null other_protocol";
      goto LABEL_47;
    }
    if (!v42)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v38 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v38)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_47;
    }
    if (!v38)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_unregister_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_unregister_notification";
    v16 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v16, &type, &v42))
      goto LABEL_48;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null type";
      goto LABEL_47;
    }
    if (!v42)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v39 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v39)
        goto LABEL_48;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s called with null type, no backtrace";
      goto LABEL_47;
    }
    if (!v39)
      goto LABEL_34;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_unregister_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s called with null type, dumping backtrace:%{public}s";
    goto LABEL_33;
  }
  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v5 = *(void **)(v4 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      v6 = *(_QWORD *)(v4 + 88);
      if (v6)
        *(_QWORD *)(v4 + 88) = v6 + 1;
    }
    v7 = *(void **)(a2 + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      v8 = *(_QWORD *)(a2 + 88);
      if (v8)
        *(_QWORD *)(a2 + 88) = v8 + 1;
    }
    v9 = *(_QWORD *)(v4 + 24);
    if (v9)
    {
      v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 152);
      if (v10)
      {
        v11 = v10(v4, a2);
        if (v7 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
          {
            v12 = *(_QWORD *)(v4 + 88);
            if (v12)
            {
              v13 = v12 - 1;
              *(_QWORD *)(v4 + 88) = v13;
              if (!v13)
              {
                v14 = *(void (***)(_QWORD))(v4 + 64);
                if (v14)
                {
                  *(_QWORD *)(v4 + 64) = 0;
                  v14[2](v14);
                  _Block_release(v14);
                }
                if ((*(_BYTE *)(v4 + 72) & 1) != 0)
                {
                  v15 = *(const void **)(v4 + 64);
                  if (v15)
                    _Block_release(v15);
                }
                free((void *)v4);
              }
            }
          }
          return v11;
        }
LABEL_14:
        if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
        {
          v23 = *(_QWORD *)(a2 + 88);
          if (v23)
          {
            v24 = v23 - 1;
            *(_QWORD *)(a2 + 88) = v24;
            if (!v24)
            {
              v25 = *(void (***)(_QWORD))(a2 + 64);
              if (v25)
              {
                *(_QWORD *)(a2 + 64) = 0;
                v25[2](v25);
                _Block_release(v25);
              }
              if ((*(_BYTE *)(a2 + 72) & 1) != 0)
              {
                v26 = *(const void **)(a2 + 64);
                if (v26)
                  _Block_release(v26);
              }
              free((void *)a2);
            }
          }
        }
        goto LABEL_15;
      }
    }
    __nwlog_obj();
    v28 = *(const char **)(v4 + 16);
    *(_DWORD *)buf = 136446722;
    v45 = "__nw_protocol_unregister_notification";
    if (!v28)
      v28 = "invalid";
    v46 = 2082;
    v47 = (void *)v28;
    v48 = 2048;
    v49 = v4;
    v29 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v29, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (!os_log_type_enabled(v30, type))
          goto LABEL_106;
        v32 = *(const char **)(v4 + 16);
        if (!v32)
          v32 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_unregister_notification";
        v46 = 2082;
        v47 = (void *)v32;
        v48 = 2048;
        v49 = v4;
        v33 = "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback";
LABEL_105:
        _os_log_impl(&dword_182FBE000, v30, v31, v33, buf, 0x20u);
        goto LABEL_106;
      }
      if (!v42)
      {
        v30 = __nwlog_obj();
        v31 = type;
        if (!os_log_type_enabled(v30, type))
          goto LABEL_106;
        v40 = *(const char **)(v4 + 16);
        if (!v40)
          v40 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_unregister_notification";
        v46 = 2082;
        v47 = (void *)v40;
        v48 = 2048;
        v49 = v4;
        v33 = "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback, backtrace limit exceeded";
        goto LABEL_105;
      }
      v34 = (char *)__nw_create_backtrace_string();
      v30 = __nwlog_obj();
      v31 = type;
      v35 = os_log_type_enabled(v30, type);
      if (!v34)
      {
        if (!v35)
          goto LABEL_106;
        v41 = *(const char **)(v4 + 16);
        if (!v41)
          v41 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_unregister_notification";
        v46 = 2082;
        v47 = (void *)v41;
        v48 = 2048;
        v49 = v4;
        v33 = "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback, no backtrace";
        goto LABEL_105;
      }
      if (v35)
      {
        v36 = *(const char **)(v4 + 16);
        if (!v36)
          v36 = "invalid";
        *(_DWORD *)buf = 136446978;
        v45 = "__nw_protocol_unregister_notification";
        v46 = 2082;
        v47 = (void *)v36;
        v48 = 2048;
        v49 = v4;
        v50 = 2082;
        v51 = v34;
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s protocol %{public}s (%p) has invalid unregister_notification callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v34);
    }
LABEL_106:
    if (v29)
      free(v29);
    v11 = 0;
    if (v7 != &nw_protocol_ref_counted_handle)
      goto LABEL_15;
    goto LABEL_14;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v45 = "nw_protocol_common_unregister_notification";
  v16 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (!__nwlog_fault(v16, &type, &v42))
    goto LABEL_48;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_unregister_notification";
      v19 = "%{public}s unregister_notification requires an output handler";
LABEL_47:
      _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0xCu);
      goto LABEL_48;
    }
    goto LABEL_48;
  }
  if (v42)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = gLogObj;
    v18 = type;
    v21 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_protocol_common_unregister_notification";
        v19 = "%{public}s unregister_notification requires an output handler, no backtrace";
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (!v21)
    {
LABEL_34:
      free(backtrace_string);
      goto LABEL_48;
    }
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_unregister_notification";
    v46 = 2082;
    v47 = backtrace_string;
    v22 = "%{public}s unregister_notification requires an output handler, dumping backtrace:%{public}s";
LABEL_33:
    _os_log_impl(&dword_182FBE000, v17, v18, v22, buf, 0x16u);
    goto LABEL_34;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v17 = gLogObj;
  v18 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_unregister_notification";
    v19 = "%{public}s unregister_notification requires an output handler, backtrace limit exceeded";
    goto LABEL_47;
  }
LABEL_48:
  if (v16)
    free(v16);
  return 0;
}

uint64_t nw_protocol_common_updated_path(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (**v14)(_QWORD);
  const void *v15;
  NSObject *v16;
  uint64_t v18;
  uint64_t v19;
  void (**v20)(_QWORD);
  const void *v21;
  const char *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  const char *v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  char *v32;
  _BOOL4 v33;
  const char *v34;
  char *backtrace_string;
  _BOOL4 v36;
  const char *v37;
  _BOOL4 v38;
  _BOOL4 v39;
  const char *v40;
  const char *v41;
  char v42;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  void *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  char *v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_updated_path";
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v28, &type, &v42))
      goto LABEL_104;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null protocol";
      goto LABEL_103;
    }
    if (!v42)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_103;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v29 = __nwlog_obj();
    v30 = type;
    v36 = os_log_type_enabled(v29, type);
    if (!backtrace_string)
    {
      if (!v36)
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_103;
    }
    if (!v36)
      goto LABEL_77;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_updated_path";
    v46 = 2082;
    v47 = backtrace_string;
    v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_76:
    _os_log_impl(&dword_182FBE000, v29, v30, v37, buf, 0x16u);
    goto LABEL_77;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_updated_path";
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v28, &type, &v42))
      goto LABEL_104;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null other_protocol";
      goto LABEL_103;
    }
    if (!v42)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_103;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v29 = __nwlog_obj();
    v30 = type;
    v38 = os_log_type_enabled(v29, type);
    if (!backtrace_string)
    {
      if (!v38)
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_103;
    }
    if (!v38)
      goto LABEL_77;
    *(_DWORD *)buf = 136446466;
    v45 = "nw_protocol_common_updated_path";
    v46 = 2082;
    v47 = backtrace_string;
    v37 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_76;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_updated_path";
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (!__nwlog_fault(v28, &type, &v42))
      goto LABEL_104;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null path";
      goto LABEL_103;
    }
    if (!v42)
    {
      v29 = __nwlog_obj();
      v30 = type;
      if (!os_log_type_enabled(v29, type))
        goto LABEL_104;
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      v31 = "%{public}s called with null path, backtrace limit exceeded";
      goto LABEL_103;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v29 = __nwlog_obj();
    v30 = type;
    v39 = os_log_type_enabled(v29, type);
    if (backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446466;
        v45 = "nw_protocol_common_updated_path";
        v46 = 2082;
        v47 = backtrace_string;
        v37 = "%{public}s called with null path, dumping backtrace:%{public}s";
        goto LABEL_76;
      }
LABEL_77:
      free(backtrace_string);
      goto LABEL_104;
    }
    if (!v39)
      goto LABEL_104;
    *(_DWORD *)buf = 136446210;
    v45 = "nw_protocol_common_updated_path";
    v31 = "%{public}s called with null path, no backtrace";
LABEL_103:
    _os_log_impl(&dword_182FBE000, v29, v30, v31, buf, 0xCu);
LABEL_104:
    if (v28)
      free(v28);
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v16 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v45 = "nw_protocol_common_updated_path";
      _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_INFO, "%{public}s updated_path requires an output handler", buf, 0xCu);
    }
    return 0;
  }
  v5 = *(void **)(v4 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    v6 = *(_QWORD *)(v4 + 88);
    if (v6)
      *(_QWORD *)(v4 + 88) = v6 + 1;
  }
  v7 = *(void **)(a2 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    v8 = *(_QWORD *)(a2 + 88);
    if (v8)
      *(_QWORD *)(a2 + 88) = v8 + 1;
  }
  v9 = *(_QWORD *)(v4 + 24);
  if (!v9 || (v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 168)) == 0)
  {
    __nwlog_obj();
    v22 = *(const char **)(v4 + 16);
    *(_DWORD *)buf = 136446722;
    v45 = "__nw_protocol_updated_path";
    if (!v22)
      v22 = "invalid";
    v46 = 2082;
    v47 = (void *)v22;
    v48 = 2048;
    v49 = v4;
    v23 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v23, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (!os_log_type_enabled(v24, type))
          goto LABEL_93;
        v26 = *(const char **)(v4 + 16);
        if (!v26)
          v26 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_updated_path";
        v46 = 2082;
        v47 = (void *)v26;
        v48 = 2048;
        v49 = v4;
        v27 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback";
LABEL_92:
        _os_log_impl(&dword_182FBE000, v24, v25, v27, buf, 0x20u);
        goto LABEL_93;
      }
      if (!v42)
      {
        v24 = __nwlog_obj();
        v25 = type;
        if (!os_log_type_enabled(v24, type))
          goto LABEL_93;
        v40 = *(const char **)(v4 + 16);
        if (!v40)
          v40 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_updated_path";
        v46 = 2082;
        v47 = (void *)v40;
        v48 = 2048;
        v49 = v4;
        v27 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded";
        goto LABEL_92;
      }
      v32 = (char *)__nw_create_backtrace_string();
      v24 = __nwlog_obj();
      v25 = type;
      v33 = os_log_type_enabled(v24, type);
      if (!v32)
      {
        if (!v33)
          goto LABEL_93;
        v41 = *(const char **)(v4 + 16);
        if (!v41)
          v41 = "invalid";
        *(_DWORD *)buf = 136446722;
        v45 = "__nw_protocol_updated_path";
        v46 = 2082;
        v47 = (void *)v41;
        v48 = 2048;
        v49 = v4;
        v27 = "%{public}s protocol %{public}s (%p) has invalid updated_path callback, no backtrace";
        goto LABEL_92;
      }
      if (v33)
      {
        v34 = *(const char **)(v4 + 16);
        if (!v34)
          v34 = "invalid";
        *(_DWORD *)buf = 136446978;
        v45 = "__nw_protocol_updated_path";
        v46 = 2082;
        v47 = (void *)v34;
        v48 = 2048;
        v49 = v4;
        v50 = 2082;
        v51 = v32;
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v32);
    }
LABEL_93:
    if (v23)
      free(v23);
    v11 = 0;
    if (v7 != &nw_protocol_ref_counted_handle)
      goto LABEL_15;
    goto LABEL_14;
  }
  v11 = v10(v4, a2);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
LABEL_14:
    if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
    {
      v18 = *(_QWORD *)(a2 + 88);
      if (v18)
      {
        v19 = v18 - 1;
        *(_QWORD *)(a2 + 88) = v19;
        if (!v19)
        {
          v20 = *(void (***)(_QWORD))(a2 + 64);
          if (v20)
          {
            *(_QWORD *)(a2 + 64) = 0;
            v20[2](v20);
            _Block_release(v20);
          }
          if ((*(_BYTE *)(a2 + 72) & 1) != 0)
          {
            v21 = *(const void **)(a2 + 64);
            if (v21)
              _Block_release(v21);
          }
          free((void *)a2);
        }
      }
    }
  }
LABEL_15:
  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    v12 = *(_QWORD *)(v4 + 88);
    if (v12)
    {
      v13 = v12 - 1;
      *(_QWORD *)(v4 + 88) = v13;
      if (!v13)
      {
        v14 = *(void (***)(_QWORD))(v4 + 64);
        if (v14)
        {
          *(_QWORD *)(v4 + 64) = 0;
          v14[2](v14);
          _Block_release(v14);
        }
        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          v15 = *(const void **)(v4 + 64);
          if (v15)
            _Block_release(v15);
        }
        free((void *)v4);
      }
    }
  }
  return v11;
}

void nw_protocol_common_link_state(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;
  void (**v13)(_QWORD);
  const void *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  char *backtrace_string;
  _BOOL4 v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  void (**v23)(_QWORD);
  const void *v24;
  const char *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  const char *v30;
  char *v31;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  const char *v37;
  const char *v38;
  char v39;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  void *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  char *v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_link_state";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v39))
      goto LABEL_49;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v15 = __nwlog_obj();
        v16 = type;
        v34 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_protocol_common_link_state";
            v43 = 2082;
            v44 = backtrace_string;
            v20 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_33;
          }
LABEL_34:
          free(backtrace_string);
          if (!v4)
            return;
          goto LABEL_50;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_common_link_state";
          v17 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_48;
        }
      }
      else
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_common_link_state";
          v17 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
      goto LABEL_49;
    }
    v15 = __nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type))
      goto LABEL_49;
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_link_state";
    v17 = "%{public}s called with null protocol";
LABEL_48:
    _os_log_impl(&dword_182FBE000, v15, v16, v17, buf, 0xCu);
    goto LABEL_49;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_link_state";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v39))
      goto LABEL_49;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v15 = __nwlog_obj();
        v16 = type;
        v35 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_protocol_common_link_state";
            v43 = 2082;
            v44 = backtrace_string;
            v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
            goto LABEL_33;
          }
          goto LABEL_34;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_common_link_state";
          v17 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_48;
        }
      }
      else
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_common_link_state";
          v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
      goto LABEL_49;
    }
    v15 = __nwlog_obj();
    v16 = type;
    if (!os_log_type_enabled(v15, type))
      goto LABEL_49;
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_link_state";
    v17 = "%{public}s called with null other_protocol";
    goto LABEL_48;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_link_state";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (__nwlog_fault((const char *)v4, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_common_link_state";
          v17 = "%{public}s called with null link_info";
          goto LABEL_48;
        }
      }
      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v15 = __nwlog_obj();
        v16 = type;
        v36 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            v42 = "nw_protocol_common_link_state";
            v43 = 2082;
            v44 = backtrace_string;
            v20 = "%{public}s called with null link_info, dumping backtrace:%{public}s";
            goto LABEL_33;
          }
          goto LABEL_34;
        }
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_common_link_state";
          v17 = "%{public}s called with null link_info, no backtrace";
          goto LABEL_48;
        }
      }
      else
      {
        v15 = __nwlog_obj();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "nw_protocol_common_link_state";
          v17 = "%{public}s called with null link_info, backtrace limit exceeded";
          goto LABEL_48;
        }
      }
    }
LABEL_49:
    if (!v4)
      return;
    goto LABEL_50;
  }
  v4 = *(_QWORD *)(a1 + 48);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v42 = "nw_protocol_common_link_state";
    v4 = _os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v39))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      v16 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_link_state";
      v17 = "%{public}s link_state requires a default input handler";
      goto LABEL_48;
    }
    if (!v39)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v15 = gLogObj;
      v16 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_link_state";
      v17 = "%{public}s link_state requires a default input handler, backtrace limit exceeded";
      goto LABEL_48;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v15 = gLogObj;
    v16 = type;
    v19 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (!v19)
        goto LABEL_49;
      *(_DWORD *)buf = 136446210;
      v42 = "nw_protocol_common_link_state";
      v17 = "%{public}s link_state requires a default input handler, no backtrace";
      goto LABEL_48;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v42 = "nw_protocol_common_link_state";
      v43 = 2082;
      v44 = backtrace_string;
      v20 = "%{public}s link_state requires a default input handler, dumping backtrace:%{public}s";
LABEL_33:
      _os_log_impl(&dword_182FBE000, v15, v16, v20, buf, 0x16u);
      goto LABEL_34;
    }
    goto LABEL_34;
  }
  v5 = *(void **)(v4 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    v6 = *(_QWORD *)(v4 + 88);
    if (v6)
      *(_QWORD *)(v4 + 88) = v6 + 1;
  }
  v7 = *(void **)(a2 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    v8 = *(_QWORD *)(a2 + 88);
    if (v8)
      *(_QWORD *)(a2 + 88) = v8 + 1;
  }
  v9 = *(_QWORD *)(v4 + 24);
  if (v9)
  {
    v10 = *(void (**)(uint64_t, uint64_t))(v9 + 104);
    if (v10)
    {
      v10(v4, a2);
      goto LABEL_14;
    }
  }
  __nwlog_obj();
  v25 = *(const char **)(v4 + 16);
  *(_DWORD *)buf = 136446722;
  v42 = "__nw_protocol_link_state";
  if (!v25)
    v25 = "invalid";
  v43 = 2082;
  v44 = (void *)v25;
  v45 = 2048;
  v46 = v4;
  v26 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v39 = 0;
  if (__nwlog_fault(v26, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_106;
      v29 = *(const char **)(v4 + 16);
      if (!v29)
        v29 = "invalid";
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_link_state";
      v43 = 2082;
      v44 = (void *)v29;
      v45 = 2048;
      v46 = v4;
      v30 = "%{public}s protocol %{public}s (%p) has invalid link_state callback";
      goto LABEL_105;
    }
    if (!v39)
    {
      v27 = __nwlog_obj();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_106;
      v37 = *(const char **)(v4 + 16);
      if (!v37)
        v37 = "invalid";
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_link_state";
      v43 = 2082;
      v44 = (void *)v37;
      v45 = 2048;
      v46 = v4;
      v30 = "%{public}s protocol %{public}s (%p) has invalid link_state callback, backtrace limit exceeded";
      goto LABEL_105;
    }
    v31 = (char *)__nw_create_backtrace_string();
    v27 = __nwlog_obj();
    v28 = type;
    v32 = os_log_type_enabled(v27, type);
    if (v31)
    {
      if (v32)
      {
        v33 = *(const char **)(v4 + 16);
        if (!v33)
          v33 = "invalid";
        *(_DWORD *)buf = 136446978;
        v42 = "__nw_protocol_link_state";
        v43 = 2082;
        v44 = (void *)v33;
        v45 = 2048;
        v46 = v4;
        v47 = 2082;
        v48 = v31;
        _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s protocol %{public}s (%p) has invalid link_state callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v31);
      goto LABEL_106;
    }
    if (v32)
    {
      v38 = *(const char **)(v4 + 16);
      if (!v38)
        v38 = "invalid";
      *(_DWORD *)buf = 136446722;
      v42 = "__nw_protocol_link_state";
      v43 = 2082;
      v44 = (void *)v38;
      v45 = 2048;
      v46 = v4;
      v30 = "%{public}s protocol %{public}s (%p) has invalid link_state callback, no backtrace";
LABEL_105:
      _os_log_impl(&dword_182FBE000, v27, v28, v30, buf, 0x20u);
    }
  }
LABEL_106:
  if (v26)
    free(v26);
LABEL_14:
  if (v7 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
  {
    v21 = *(_QWORD *)(a2 + 88);
    if (v21)
    {
      v22 = v21 - 1;
      *(_QWORD *)(a2 + 88) = v22;
      if (!v22)
      {
        v23 = *(void (***)(_QWORD))(a2 + 64);
        if (v23)
        {
          *(_QWORD *)(a2 + 64) = 0;
          v23[2](v23);
          _Block_release(v23);
        }
        if ((*(_BYTE *)(a2 + 72) & 1) != 0)
        {
          v24 = *(const void **)(a2 + 64);
          if (v24)
            _Block_release(v24);
        }
        free((void *)a2);
      }
    }
  }
  if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
  {
    v11 = *(_QWORD *)(v4 + 88);
    if (v11)
    {
      v12 = v11 - 1;
      *(_QWORD *)(v4 + 88) = v12;
      if (!v12)
      {
        v13 = *(void (***)(_QWORD))(v4 + 64);
        if (v13)
        {
          *(_QWORD *)(v4 + 64) = 0;
          v13[2](v13);
          _Block_release(v13);
        }
        if ((*(_BYTE *)(v4 + 72) & 1) != 0)
        {
          v14 = *(const void **)(v4 + 64);
          if (v14)
            _Block_release(v14);
        }
LABEL_50:
        free((void *)v4);
      }
    }
  }
}

uint64_t (**nw_protocol_set_common_callbacks(uint64_t (**result)(uint64_t a1, uint64_t a2)))(uint64_t a1, uint64_t a2)
{
  *result = nw_protocol_common_add_input_handler;
  result[1] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_remove_input_handler;
  result[10] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_input_frames;
  result[11] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_output_frames;
  result[14] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_parameters;
  result[15] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_path;
  result[16] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_local_endpoint;
  result[17] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_remote_endpoint;
  result[2] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_replace_input_handler;
  result[3] = nw_protocol_common_connect;
  result[4] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_disconnect;
  result[5] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_connected;
  result[8] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_input_available;
  result[9] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_output_available;
  result[24] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_output_finished;
  result[25] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_output_local_endpoint;
  result[33] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_input_flush;
  result[6] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_disconnected;
  result[7] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_error;
  result[31] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_message_properties;
  result[32] = nw_protocol_common_reset;
  result[28] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_copy_info;
  result[22] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_supports_external_data;
  result[23] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_input_finished;
  result[26] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_output_interface;
  result[27] = nw_protocol_common_waiting_for_output;
  result[18] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_register_notification;
  result[19] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_unregister_notification;
  result[20] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_notify;
  result[21] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_updated_path;
  result[12] = nw_protocol_common_finalize_output_frames;
  result[13] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_link_state;
  return result;
}

void sub_1838CA2BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, objc_super a13)
{
  a13.super_class = (Class)NWConcrete_nw_nat64_prefixes_resolver;
  -[_Unwind_Exception dealloc](&a13, sel_dealloc);
  _Unwind_Resume(a1);
}

BOOL nw_nat64_can_v4_address_be_synthesized(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  _BOOL4 v4;
  BOOL v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = bswap32(*a1);
    v2 = v1 & 0xFF000000;
    v4 = *a1 != -1 && v1 >> 28 != 14;
    if (v1 >> 8 == 12605539 || (v1 & 0xFFFF0000) == -1442971648 || (v1 & 0xFFFFFFF8) == -1073741824)
      v4 = 0;
    if (v2)
      v7 = v2 == 2130706432;
    else
      v7 = 1;
    return !v7 && v4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_nat64_can_v4_address_be_synthesized";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_can_v4_address_be_synthesized";
        v13 = "%{public}s called with null ipv4_addr";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
      }
    }
    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_nat64_can_v4_address_be_synthesized";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }
        if (!v15)
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_can_v4_address_be_synthesized";
        v13 = "%{public}s called with null ipv4_addr, no backtrace";
        goto LABEL_36;
      }
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_can_v4_address_be_synthesized";
        v13 = "%{public}s called with null ipv4_addr, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
LABEL_37:

  }
LABEL_38:
  if (v10)
    free(v10);
  return 0;
}

uint64_t nw_nat64_synthesize_v6(_QWORD *__src, __int16 *a2, char *__dst)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v6;
  BOOL v7;
  uint64_t result;
  __int16 v11;
  __int16 v12;
  void *v13;
  int v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  int v18;
  const char *v19;
  char *v20;
  _BOOL4 v21;
  int v22;
  int v23;
  int v24;
  void *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  void *v30;
  void *v31;
  char *backtrace_string;
  _BOOL4 v33;
  const char *v34;
  _BOOL4 v35;
  _BOOL4 v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  _WORD v42[17];

  *(_QWORD *)&v42[13] = *MEMORY[0x1E0C80C00];
  if (!__src)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_nat64_synthesize_v6";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v26, &type, &v37))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_nat64_synthesize_v6";
      v29 = "%{public}s called with null prefix";
LABEL_88:
      _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0xCu);
      goto LABEL_89;
    }
    if (!v37)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null prefix, backtrace limit exceeded";
        goto LABEL_88;
      }
      goto LABEL_89;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    v28 = type;
    v33 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null prefix, no backtrace";
        goto LABEL_88;
      }
      goto LABEL_89;
    }
    if (!v33)
      goto LABEL_75;
    *(_DWORD *)buf = 136446466;
    v40 = "nw_nat64_synthesize_v6";
    v41 = 2082;
    *(_QWORD *)v42 = backtrace_string;
    v34 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
LABEL_74:
    _os_log_impl(&dword_182FBE000, v27, v28, v34, buf, 0x16u);
    goto LABEL_75;
  }
  if (!a2)
  {
    __nwlog_obj();
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_nat64_synthesize_v6";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v26, &type, &v37))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (!os_log_type_enabled(v27, type))
        goto LABEL_89;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_nat64_synthesize_v6";
      v29 = "%{public}s called with null ipv4_addr";
      goto LABEL_88;
    }
    if (!v37)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null ipv4_addr, backtrace limit exceeded";
        goto LABEL_88;
      }
      goto LABEL_89;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    v28 = type;
    v35 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null ipv4_addr, no backtrace";
        goto LABEL_88;
      }
      goto LABEL_89;
    }
    if (!v35)
      goto LABEL_75;
    *(_DWORD *)buf = 136446466;
    v40 = "nw_nat64_synthesize_v6";
    v41 = 2082;
    *(_QWORD *)v42 = backtrace_string;
    v34 = "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s";
    goto LABEL_74;
  }
  if (!__dst)
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_nat64_synthesize_v6";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v26, &type, &v37))
      goto LABEL_90;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null out_ipv6_addr";
        goto LABEL_88;
      }
LABEL_89:

LABEL_90:
      if (v26)
        free(v26);
      return 0;
    }
    if (!v37)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null out_ipv6_addr, backtrace limit exceeded";
        goto LABEL_88;
      }
      goto LABEL_89;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    v28 = type;
    v36 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_nat64_synthesize_v6";
        v29 = "%{public}s called with null out_ipv6_addr, no backtrace";
        goto LABEL_88;
      }
      goto LABEL_89;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_nat64_synthesize_v6";
      v41 = 2082;
      *(_QWORD *)v42 = backtrace_string;
      v34 = "%{public}s called with null out_ipv6_addr, dumping backtrace:%{public}s";
      goto LABEL_74;
    }
LABEL_75:

    free(backtrace_string);
    goto LABEL_90;
  }
  v3 = bswap32(*(_DWORD *)a2);
  v4 = v3 & 0xFF000000;
  if ((v3 & 0xFF000000) == 0 || v4 == 2130706432)
    return 0;
  v6 = v3 & 0xFFFF0000;
  v7 = v3 >> 8 == 12605539 || v6 == -1442971648;
  if (v7 || (v3 & 0xFFFFFFF8) == -1073741824)
    return 0;
  result = 0;
  if (*(_DWORD *)a2 != -1 && (v3 & 0xF0000000) != 0xE0000000)
  {
    if (*__src ^ 0x9BFF64000000000CLL | __src[1]
      || (result = 0, v3 >> 22 != 401) && v6 != -1062731776 && v4 != 167772160 && (v3 & 0xFFF00000) != 0xAC100000)
    {
      *(_QWORD *)__dst = 0;
      *((_QWORD *)__dst + 1) = 0;
      switch(*(_DWORD *)__src)
      {
        case 4:
          *((_DWORD *)__dst + 1) = *(_DWORD *)a2;
          goto LABEL_36;
        case 5:
          v11 = *a2;
          __dst[7] = *((_BYTE *)a2 + 2);
          *(_WORD *)(__dst + 5) = v11;
          __dst[9] = *((_BYTE *)a2 + 3);
          goto LABEL_36;
        case 6:
          *((_WORD *)__dst + 3) = *a2;
          *(_WORD *)(__dst + 9) = a2[1];
          goto LABEL_36;
        case 7:
          __dst[7] = *(_BYTE *)a2;
          v12 = *(__int16 *)((char *)a2 + 1);
          __dst[11] = *((_BYTE *)a2 + 3);
          *(_WORD *)(__dst + 9) = v12;
          goto LABEL_36;
        case 8:
          *(_DWORD *)(__dst + 9) = *(_DWORD *)a2;
          goto LABEL_36;
        case 0xC:
          *((_DWORD *)__dst + 3) = *(_DWORD *)a2;
LABEL_36:
          memcpy(__dst, (char *)__src + 4, *(unsigned int *)__src);
          return 1;
        default:
          __nwlog_obj();
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          v14 = *(_DWORD *)__src;
          *(_DWORD *)buf = 136446466;
          v40 = "nw_nat64_synthesize_v6";
          v41 = 1024;
          *(_DWORD *)v42 = v14;
          v15 = (char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v37 = 0;
          if (!__nwlog_fault(v15, &type, &v37))
            goto LABEL_48;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v16 = objc_claimAutoreleasedReturnValue();
            v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              v18 = *(_DWORD *)__src;
              *(_DWORD *)buf = 136446466;
              v40 = "nw_nat64_synthesize_v6";
              v41 = 1024;
              *(_DWORD *)v42 = v18;
              v19 = "%{public}s invalid prefix length %d";
LABEL_46:
              _os_log_impl(&dword_182FBE000, v16, v17, v19, buf, 0x12u);
              goto LABEL_47;
            }
            goto LABEL_47;
          }
          if (!v37)
          {
            __nwlog_obj();
            v16 = objc_claimAutoreleasedReturnValue();
            v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              v23 = *(_DWORD *)__src;
              *(_DWORD *)buf = 136446466;
              v40 = "nw_nat64_synthesize_v6";
              v41 = 1024;
              *(_DWORD *)v42 = v23;
              v19 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
              goto LABEL_46;
            }
LABEL_47:

            goto LABEL_48;
          }
          v20 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v16 = objc_claimAutoreleasedReturnValue();
          v17 = type;
          v21 = os_log_type_enabled(v16, type);
          if (!v20)
          {
            if (v21)
            {
              v24 = *(_DWORD *)__src;
              *(_DWORD *)buf = 136446466;
              v40 = "nw_nat64_synthesize_v6";
              v41 = 1024;
              *(_DWORD *)v42 = v24;
              v19 = "%{public}s invalid prefix length %d, no backtrace";
              goto LABEL_46;
            }
            goto LABEL_47;
          }
          if (v21)
          {
            v22 = *(_DWORD *)__src;
            *(_DWORD *)buf = 136446722;
            v40 = "nw_nat64_synthesize_v6";
            v41 = 1024;
            *(_DWORD *)v42 = v22;
            v42[2] = 2082;
            *(_QWORD *)&v42[3] = v20;
            _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s invalid prefix length %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v20);
LABEL_48:
          if (v15)
            free(v15);
          break;
      }
      return 0;
    }
  }
  return result;
}

uint64_t nw_nat64_extract_v4(unsigned int *a1, char *__s1, uint64_t a3)
{
  size_t v6;
  NSObject *v7;
  int v8;
  int v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  const char *v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  __int16 v18;
  __int16 v20;
  id v21;
  unsigned int v22;
  NSObject *v23;
  os_log_type_t v24;
  unsigned int v25;
  const char *v26;
  uint8_t *v27;
  NSObject *v28;
  os_log_type_t v29;
  uint32_t v30;
  char *v31;
  _BOOL4 v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  void *v36;
  os_log_type_t v37;
  void *v38;
  void *v39;
  char *backtrace_string;
  _BOOL4 v41;
  const char *v42;
  _BOOL4 v43;
  _BOOL4 v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  _BYTE v50[18];
  os_log_type_t v51[16];
  _WORD v52[15];
  uint8_t v53[32];
  __int128 v54;
  __int16 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v53 = 136446210;
    *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
    v11 = (char *)_os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v11, v51, buf))
      goto LABEL_37;
    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null prefix";
      goto LABEL_93;
    }
    if (buf[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      v41 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v41)
          goto LABEL_79;
        *(_DWORD *)v53 = 136446466;
        *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 2082;
        *(_QWORD *)&v53[14] = backtrace_string;
        v42 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
        goto LABEL_78;
      }
      if (!v41)
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null prefix, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null prefix, backtrace limit exceeded";
    }
LABEL_93:
    v27 = v53;
    v28 = v12;
    v29 = v37;
    v30 = 12;
    goto LABEL_35;
  }
  if (!__s1)
  {
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v53 = 136446210;
    *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
    v11 = (char *)_os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v11, v51, buf))
      goto LABEL_37;
    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null ipv6_addr";
      goto LABEL_93;
    }
    if (buf[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      v43 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v43)
          goto LABEL_79;
        *(_DWORD *)v53 = 136446466;
        *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 2082;
        *(_QWORD *)&v53[14] = backtrace_string;
        v42 = "%{public}s called with null ipv6_addr, dumping backtrace:%{public}s";
        goto LABEL_78;
      }
      if (!v43)
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null ipv6_addr, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null ipv6_addr, backtrace limit exceeded";
    }
    goto LABEL_93;
  }
  if (!a3)
  {
    __nwlog_obj();
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v53 = 136446210;
    *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
    v11 = (char *)_os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (!__nwlog_fault(v11, v51, buf))
      goto LABEL_37;
    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null out_ipv4_addr";
      goto LABEL_93;
    }
    if (buf[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      v44 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v44)
          goto LABEL_79;
        *(_DWORD *)v53 = 136446466;
        *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 2082;
        *(_QWORD *)&v53[14] = backtrace_string;
        v42 = "%{public}s called with null out_ipv4_addr, dumping backtrace:%{public}s";
LABEL_78:
        _os_log_impl(&dword_182FBE000, v12, v37, v42, v53, 0x16u);
LABEL_79:

        free(backtrace_string);
        if (!v11)
          return 0;
        goto LABEL_38;
      }
      if (!v44)
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null out_ipv4_addr, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0]))
        goto LABEL_36;
      *(_DWORD *)v53 = 136446210;
      *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
      v14 = "%{public}s called with null out_ipv4_addr, backtrace limit exceeded";
    }
    goto LABEL_93;
  }
  v6 = *a1;
  if (!memcmp(__s1, a1 + 1, v6))
  {
    switch((int)v6)
    {
      case 4:
        v8 = *((_DWORD *)__s1 + 1);
        goto LABEL_30;
      case 5:
        v18 = *(_WORD *)(__s1 + 5);
        *(_BYTE *)(a3 + 2) = __s1[7];
        *(_WORD *)a3 = v18;
        *(_BYTE *)(a3 + 3) = __s1[9];
        return 1;
      case 6:
        *(_WORD *)a3 = *((_WORD *)__s1 + 3);
        *(_WORD *)(a3 + 2) = *(_WORD *)(__s1 + 9);
        return 1;
      case 7:
        *(_BYTE *)a3 = __s1[7];
        v20 = *(_WORD *)(__s1 + 9);
        *(_BYTE *)(a3 + 3) = __s1[11];
        *(_WORD *)(a3 + 1) = v20;
        return 1;
      case 8:
        v8 = *(_DWORD *)(__s1 + 9);
        goto LABEL_30;
      case 12:
        v8 = *((_DWORD *)__s1 + 3);
LABEL_30:
        *(_DWORD *)a3 = v8;
        return 1;
      default:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (id)gLogObj;
        v22 = *a1;
        *(_DWORD *)v53 = 136446466;
        *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 1024;
        *(_DWORD *)&v53[14] = v22;
        v11 = (char *)_os_log_send_and_compose_impl();

        v51[0] = OS_LOG_TYPE_ERROR;
        buf[0] = 0;
        if (!__nwlog_fault(v11, v51, buf))
          goto LABEL_37;
        if (v51[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v23 = (id)gLogObj;
          v24 = v51[0];
          if (os_log_type_enabled(v23, v51[0]))
          {
            v25 = *a1;
            *(_DWORD *)v53 = 136446466;
            *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
            *(_WORD *)&v53[12] = 1024;
            *(_DWORD *)&v53[14] = v25;
            v26 = "%{public}s invalid prefix length %d";
LABEL_52:
            _os_log_impl(&dword_182FBE000, v23, v24, v26, v53, 0x12u);
          }
        }
        else if (buf[0])
        {
          v31 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v23 = objc_claimAutoreleasedReturnValue();
          v24 = v51[0];
          v32 = os_log_type_enabled(v23, v51[0]);
          if (v31)
          {
            if (v32)
            {
              v33 = *a1;
              *(_DWORD *)v53 = 136446722;
              *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
              *(_WORD *)&v53[12] = 1024;
              *(_DWORD *)&v53[14] = v33;
              *(_WORD *)&v53[18] = 2082;
              *(_QWORD *)&v53[20] = v31;
              _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s invalid prefix length %d, dumping backtrace:%{public}s", v53, 0x1Cu);
            }

            free(v31);
            goto LABEL_37;
          }
          if (v32)
          {
            v35 = *a1;
            *(_DWORD *)v53 = 136446466;
            *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
            *(_WORD *)&v53[12] = 1024;
            *(_DWORD *)&v53[14] = v35;
            v26 = "%{public}s invalid prefix length %d, no backtrace";
            goto LABEL_52;
          }
        }
        else
        {
          __nwlog_obj();
          v23 = objc_claimAutoreleasedReturnValue();
          v24 = v51[0];
          if (os_log_type_enabled(v23, v51[0]))
          {
            v34 = *a1;
            *(_DWORD *)v53 = 136446466;
            *(_QWORD *)&v53[4] = "nw_nat64_extract_v4";
            *(_WORD *)&v53[12] = 1024;
            *(_DWORD *)&v53[14] = v34;
            v26 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
            goto LABEL_52;
          }
        }

        goto LABEL_37;
    }
  }
  v55 = 0;
  v54 = 0u;
  memset(v53, 0, sizeof(v53));
  nw_nat64_write_prefix_to_string(a1, (char *)v53, 0x32u);
  *(_OWORD *)v51 = 0u;
  memset(v52, 0, sizeof(v52));
  if (inet_ntop(30, __s1, (char *)v51, 0x2Eu))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446723;
      v48 = "nw_nat64_extract_v4";
      v49 = 2085;
      *(_QWORD *)v50 = v53;
      *(_WORD *)&v50[8] = 2085;
      *(_QWORD *)&v50[10] = v51;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s prefix %{sensitive}s does not match address %{sensitive}s", buf, 0x20u);
    }

    return 0;
  }
  v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v10 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v48 = "nw_nat64_extract_v4";
  v49 = 1024;
  *(_DWORD *)v50 = v9;
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if (__nwlog_fault(v11, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446466;
        v48 = "nw_nat64_extract_v4";
        v49 = 1024;
        *(_DWORD *)v50 = v9;
        v14 = "%{public}s inet_ntop failed %{darwin.errno}d";
LABEL_33:
        v27 = buf;
        v28 = v12;
        v29 = v13;
LABEL_34:
        v30 = 18;
LABEL_35:
        _os_log_impl(&dword_182FBE000, v28, v29, v14, v27, v30);
      }
    }
    else
    {
      if (v45)
      {
        v15 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        v16 = type;
        v17 = os_log_type_enabled(v12, type);
        if (v15)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446722;
            v48 = "nw_nat64_extract_v4";
            v49 = 1024;
            *(_DWORD *)v50 = v9;
            *(_WORD *)&v50[4] = 2082;
            *(_QWORD *)&v50[6] = v15;
            _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s inet_ntop failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v15);
          if (!v11)
            return 0;
          goto LABEL_38;
        }
        if (!v17)
          goto LABEL_36;
        *(_DWORD *)buf = 136446466;
        v48 = "nw_nat64_extract_v4";
        v49 = 1024;
        *(_DWORD *)v50 = v9;
        v14 = "%{public}s inet_ntop failed %{darwin.errno}d, no backtrace";
        v27 = buf;
        v28 = v12;
        v29 = v16;
        goto LABEL_34;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446466;
        v48 = "nw_nat64_extract_v4";
        v49 = 1024;
        *(_DWORD *)v50 = v9;
        v14 = "%{public}s inet_ntop failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_33;
      }
    }
LABEL_36:

  }
LABEL_37:
  if (v11)
LABEL_38:
    free(v11);
  return 0;
}

uint64_t nw_nat64_write_prefix_to_string(unsigned int *a1, char *a2, socklen_t a3)
{
  id v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  size_t v11;
  size_t v13;
  size_t v14;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  int v19;
  id v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  id v24;
  int v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  int v29;
  const char *v30;
  NSObject *v31;
  os_log_type_t v32;
  char *v33;
  char *v34;
  os_log_type_t v35;
  _BOOL4 v36;
  id v37;
  int v38;
  const char *v39;
  NSObject *v41;
  os_log_type_t v42;
  int v43;
  const char *v44;
  char *v45;
  _BOOL4 v46;
  int v47;
  char *v48;
  os_log_type_t v49;
  _BOOL4 v50;
  int v51;
  NSObject *v52;
  os_log_type_t v53;
  uint32_t v54;
  int v55;
  int v56;
  int v57;
  NSObject *v58;
  os_log_type_t v59;
  int v60;
  void *v61;
  os_log_type_t v62;
  void *v63;
  char *backtrace_string;
  _BOOL4 v65;
  _BOOL4 v66;
  char v67;
  os_log_type_t v68;
  uint8_t buf[4];
  const char *v70;
  __int16 v71;
  _BYTE v72[20];
  __int16 v73;
  char *v74;
  __int16 v75;
  char *v76;
  os_log_type_t type[16];
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v70 = "nw_nat64_write_prefix_to_string";
    v39 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v68 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v39, type, &v68))
      goto LABEL_84;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      if (!os_log_type_enabled(v21, type[0]))
        goto LABEL_68;
      *(_DWORD *)buf = 136446210;
      v70 = "nw_nat64_write_prefix_to_string";
      v23 = "%{public}s called with null prefix";
    }
    else if (v68)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      v65 = os_log_type_enabled(v21, type[0]);
      if (backtrace_string)
      {
        if (v65)
        {
          *(_DWORD *)buf = 136446466;
          v70 = "nw_nat64_write_prefix_to_string";
          v71 = 2082;
          *(_QWORD *)v72 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v62, "%{public}s called with null prefix, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_84;
      }
      if (!v65)
        goto LABEL_68;
      *(_DWORD *)buf = 136446210;
      v70 = "nw_nat64_write_prefix_to_string";
      v23 = "%{public}s called with null prefix, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      if (!os_log_type_enabled(v21, type[0]))
        goto LABEL_68;
      *(_DWORD *)buf = 136446210;
      v70 = "nw_nat64_write_prefix_to_string";
      v23 = "%{public}s called with null prefix, backtrace limit exceeded";
    }
LABEL_116:
    v52 = v21;
    v53 = v62;
    v54 = 12;
    goto LABEL_67;
  }
  if (!a2)
  {
    __nwlog_obj();
    v63 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v70 = "nw_nat64_write_prefix_to_string";
    v39 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v68 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v39, type, &v68))
      goto LABEL_84;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      if (!os_log_type_enabled(v21, type[0]))
        goto LABEL_68;
      *(_DWORD *)buf = 136446210;
      v70 = "nw_nat64_write_prefix_to_string";
      v23 = "%{public}s called with null dst";
    }
    else if (v68)
    {
      v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      v66 = os_log_type_enabled(v21, type[0]);
      if (v48)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          v70 = "nw_nat64_write_prefix_to_string";
          v71 = 2082;
          *(_QWORD *)v72 = v48;
          _os_log_impl(&dword_182FBE000, v21, v62, "%{public}s called with null dst, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_61;
      }
      if (!v66)
        goto LABEL_68;
      *(_DWORD *)buf = 136446210;
      v70 = "nw_nat64_write_prefix_to_string";
      v23 = "%{public}s called with null dst, no backtrace";
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v62 = type[0];
      if (!os_log_type_enabled(v21, type[0]))
        goto LABEL_68;
      *(_DWORD *)buf = 136446210;
      v70 = "nw_nat64_write_prefix_to_string";
      v23 = "%{public}s called with null dst, backtrace limit exceeded";
    }
    goto LABEL_116;
  }
  if (a3 > 0x31)
  {
    v11 = *a1;
    if ((v11 - 4) >= 5 && (_DWORD)v11 != 12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = (id)gLogObj;
      v38 = *a1;
      *(_DWORD *)buf = 136446466;
      v70 = "nw_nat64_write_prefix_to_string";
      v71 = 1024;
      *(_DWORD *)v72 = v38;
      v39 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v68 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v39, type, &v68))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v41 = (id)gLogObj;
          v42 = type[0];
          if (os_log_type_enabled(v41, type[0]))
          {
            v43 = *a1;
            *(_DWORD *)buf = 136446466;
            v70 = "nw_nat64_write_prefix_to_string";
            v71 = 1024;
            *(_DWORD *)v72 = v43;
            v44 = "%{public}s invalid prefix length %d";
LABEL_81:
            v58 = v41;
            v59 = v42;
LABEL_82:
            _os_log_impl(&dword_182FBE000, v58, v59, v44, buf, 0x12u);
            goto LABEL_83;
          }
          goto LABEL_83;
        }
        if (v68 == OS_LOG_TYPE_DEFAULT)
        {
          __nwlog_obj();
          v41 = objc_claimAutoreleasedReturnValue();
          v42 = type[0];
          if (os_log_type_enabled(v41, type[0]))
          {
            v57 = *a1;
            *(_DWORD *)buf = 136446466;
            v70 = "nw_nat64_write_prefix_to_string";
            v71 = 1024;
            *(_DWORD *)v72 = v57;
            v44 = "%{public}s invalid prefix length %d, backtrace limit exceeded";
            goto LABEL_81;
          }
LABEL_83:

          goto LABEL_84;
        }
        v48 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v41 = (id)gLogObj;
        v49 = type[0];
        v50 = os_log_type_enabled(v41, type[0]);
        if (!v48)
        {
          if (!v50)
            goto LABEL_83;
          v60 = *a1;
          *(_DWORD *)buf = 136446466;
          v70 = "nw_nat64_write_prefix_to_string";
          v71 = 1024;
          *(_DWORD *)v72 = v60;
          v44 = "%{public}s invalid prefix length %d, no backtrace";
          v58 = v41;
          v59 = v49;
          goto LABEL_82;
        }
        if (v50)
        {
          v51 = *a1;
          *(_DWORD *)buf = 136446722;
          v70 = "nw_nat64_write_prefix_to_string";
          v71 = 1024;
          *(_DWORD *)v72 = v51;
          *(_WORD *)&v72[4] = 2082;
          *(_QWORD *)&v72[6] = v48;
          _os_log_impl(&dword_182FBE000, v41, v49, "%{public}s invalid prefix length %d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

LABEL_61:
        free(v48);
        if (!v39)
          return 0;
        goto LABEL_85;
      }
LABEL_84:
      if (!v39)
        return 0;
LABEL_85:
      v33 = (char *)v39;
      goto LABEL_86;
    }
    if (v11 <= 0xF)
      v13 = 16 - v11;
    else
      v13 = 0;
    bzero(&type[v11], v13);
    memcpy(type, a1 + 1, v11);
    if (inet_ntop(30, type, a2, a3))
    {
      v14 = strlen(a2);
      if (snprintf(&a2[v14], a3 - v14, "/%d", 8 * *a1) > 2)
        return 1;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (id)gLogObj;
      v25 = *a1;
      *(_DWORD *)buf = 136447234;
      v70 = "nw_nat64_write_prefix_to_string";
      v71 = 1024;
      *(_DWORD *)v72 = v25;
      *(_WORD *)&v72[4] = 1024;
      *(_DWORD *)&v72[6] = a3;
      *(_WORD *)&v72[10] = 2048;
      *(_QWORD *)&v72[12] = v14;
      v73 = 2082;
      v74 = a2;
      v26 = (const char *)_os_log_send_and_compose_impl();

      v68 = OS_LOG_TYPE_ERROR;
      v67 = 0;
      if (__nwlog_fault(v26, &v68, &v67))
      {
        if (v68 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = (id)gLogObj;
          v28 = v68;
          if (os_log_type_enabled(v27, v68))
          {
            v29 = *a1;
            *(_DWORD *)buf = 136447234;
            v70 = "nw_nat64_write_prefix_to_string";
            v71 = 1024;
            *(_DWORD *)v72 = v29;
            *(_WORD *)&v72[4] = 1024;
            *(_DWORD *)&v72[6] = a3;
            *(_WORD *)&v72[10] = 2048;
            *(_QWORD *)&v72[12] = v14;
            v73 = 2082;
            v74 = a2;
            v30 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=\"%{public}s\"";
LABEL_75:
            _os_log_impl(&dword_182FBE000, v27, v28, v30, buf, 0x2Cu);
            goto LABEL_76;
          }
          goto LABEL_76;
        }
        if (!v67)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = (id)gLogObj;
          v28 = v68;
          if (os_log_type_enabled(v27, v68))
          {
            v55 = *a1;
            *(_DWORD *)buf = 136447234;
            v70 = "nw_nat64_write_prefix_to_string";
            v71 = 1024;
            *(_DWORD *)v72 = v55;
            *(_WORD *)&v72[4] = 1024;
            *(_DWORD *)&v72[6] = a3;
            *(_WORD *)&v72[10] = 2048;
            *(_QWORD *)&v72[12] = v14;
            v73 = 2082;
            v74 = a2;
            v30 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=\"%{public}s\", backt"
                  "race limit exceeded";
            goto LABEL_75;
          }
LABEL_76:

          goto LABEL_77;
        }
        v45 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v27 = (id)gLogObj;
        v28 = v68;
        v46 = os_log_type_enabled(v27, v68);
        if (!v45)
        {
          if (v46)
          {
            v56 = *a1;
            *(_DWORD *)buf = 136447234;
            v70 = "nw_nat64_write_prefix_to_string";
            v71 = 1024;
            *(_DWORD *)v72 = v56;
            *(_WORD *)&v72[4] = 1024;
            *(_DWORD *)&v72[6] = a3;
            *(_WORD *)&v72[10] = 2048;
            *(_QWORD *)&v72[12] = v14;
            v73 = 2082;
            v74 = a2;
            v30 = "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=\"%{public}s\", no backtrace";
            goto LABEL_75;
          }
          goto LABEL_76;
        }
        if (v46)
        {
          v47 = *a1;
          *(_DWORD *)buf = 136447490;
          v70 = "nw_nat64_write_prefix_to_string";
          v71 = 1024;
          *(_DWORD *)v72 = v47;
          *(_WORD *)&v72[4] = 1024;
          *(_DWORD *)&v72[6] = a3;
          *(_WORD *)&v72[10] = 2048;
          *(_QWORD *)&v72[12] = v14;
          v73 = 2082;
          v74 = a2;
          v75 = 2082;
          v76 = v45;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s snprintf failed: prefix->length=%d, dst_length=%u strlen_dst=%zu, dst=\"%{public}s\", dumping backtrace:%{public}s", buf, 0x36u);
        }

        free(v45);
      }
LABEL_77:
      if (v26)
      {
        v33 = (char *)v26;
        goto LABEL_86;
      }
      return 0;
    }
    v19 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    v70 = "nw_nat64_write_prefix_to_string";
    v71 = 1024;
    *(_DWORD *)v72 = v19;
    v39 = (const char *)_os_log_send_and_compose_impl();

    v68 = OS_LOG_TYPE_ERROR;
    v67 = 0;
    if (!__nwlog_fault(v39, &v68, &v67))
      goto LABEL_84;
    if (v68 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = (id)gLogObj;
      v22 = v68;
      if (os_log_type_enabled(v21, v68))
      {
        *(_DWORD *)buf = 136446466;
        v70 = "nw_nat64_write_prefix_to_string";
        v71 = 1024;
        *(_DWORD *)v72 = v19;
        v23 = "%{public}s inet_ntop failed %{darwin.errno}d";
LABEL_65:
        v52 = v21;
        v53 = v22;
LABEL_66:
        v54 = 18;
LABEL_67:
        _os_log_impl(&dword_182FBE000, v52, v53, v23, buf, v54);
      }
    }
    else if (v67)
    {
      v34 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = (id)gLogObj;
      v35 = v68;
      v36 = os_log_type_enabled(v21, v68);
      if (v34)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446722;
          v70 = "nw_nat64_write_prefix_to_string";
          v71 = 1024;
          *(_DWORD *)v72 = v19;
          *(_WORD *)&v72[4] = 2082;
          *(_QWORD *)&v72[6] = v34;
          _os_log_impl(&dword_182FBE000, v21, v35, "%{public}s inet_ntop failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v34);
        goto LABEL_84;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v70 = "nw_nat64_write_prefix_to_string";
        v71 = 1024;
        *(_DWORD *)v72 = v19;
        v23 = "%{public}s inet_ntop failed %{darwin.errno}d, no backtrace";
        v52 = v21;
        v53 = v35;
        goto LABEL_66;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = (id)gLogObj;
      v22 = v68;
      if (os_log_type_enabled(v21, v68))
      {
        *(_DWORD *)buf = 136446466;
        v70 = "nw_nat64_write_prefix_to_string";
        v71 = 1024;
        *(_DWORD *)v72 = v19;
        v23 = "%{public}s inet_ntop failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_65;
      }
    }
LABEL_68:

    goto LABEL_84;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  v70 = "nw_nat64_write_prefix_to_string";
  v71 = 1024;
  *(_DWORD *)v72 = a3;
  *(_WORD *)&v72[4] = 1024;
  *(_DWORD *)&v72[6] = 50;
  v6 = (const char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v68 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v6, type, &v68))
    goto LABEL_24;
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = type[0];
    if (!os_log_type_enabled(v7, type[0]))
      goto LABEL_38;
    *(_DWORD *)buf = 136446722;
    v70 = "nw_nat64_write_prefix_to_string";
    v71 = 1024;
    *(_DWORD *)v72 = a3;
    *(_WORD *)&v72[4] = 1024;
    *(_DWORD *)&v72[6] = 50;
    v9 = "%{public}s dst_length=%u must be >= %d";
LABEL_36:
    v31 = v7;
    v32 = v8;
LABEL_37:
    _os_log_impl(&dword_182FBE000, v31, v32, v9, buf, 0x18u);
    goto LABEL_38;
  }
  if (v68 == OS_LOG_TYPE_DEFAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    v8 = type[0];
    if (!os_log_type_enabled(v7, type[0]))
      goto LABEL_38;
    *(_DWORD *)buf = 136446722;
    v70 = "nw_nat64_write_prefix_to_string";
    v71 = 1024;
    *(_DWORD *)v72 = a3;
    *(_WORD *)&v72[4] = 1024;
    *(_DWORD *)&v72[6] = 50;
    v9 = "%{public}s dst_length=%u must be >= %d, backtrace limit exceeded";
    goto LABEL_36;
  }
  v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v7 = (id)gLogObj;
  v17 = type[0];
  v18 = os_log_type_enabled(v7, type[0]);
  if (v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446978;
      v70 = "nw_nat64_write_prefix_to_string";
      v71 = 1024;
      *(_DWORD *)v72 = a3;
      *(_WORD *)&v72[4] = 1024;
      *(_DWORD *)&v72[6] = 50;
      *(_WORD *)&v72[10] = 2082;
      *(_QWORD *)&v72[12] = v16;
      _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s dst_length=%u must be >= %d, dumping backtrace:%{public}s", buf, 0x22u);
    }

    free(v16);
LABEL_24:
    if (!v6)
      return 0;
    goto LABEL_39;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446722;
    v70 = "nw_nat64_write_prefix_to_string";
    v71 = 1024;
    *(_DWORD *)v72 = a3;
    *(_WORD *)&v72[4] = 1024;
    *(_DWORD *)&v72[6] = 50;
    v9 = "%{public}s dst_length=%u must be >= %d, no backtrace";
    v31 = v7;
    v32 = v17;
    goto LABEL_37;
  }
LABEL_38:

  if (v6)
  {
LABEL_39:
    v33 = (char *)v6;
LABEL_86:
    free(v33);
  }
  return 0;
}

uint64_t nw_nat64_copy_prefixes_from_ipv4only_records(uint64_t a1, int a2, _QWORD *a3)
{
  uint64_t v5;
  char *v6;
  _OWORD *v7;
  uint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  const char *v11;
  NSObject *v12;
  int v13;
  const char *v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  void *v21;
  size_t v22;
  _OWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  size_t v30;
  _OWORD *v31;
  _OWORD *v32;
  uint64_t v33;
  _DWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t result;
  void *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  const char *v42;
  void *v43;
  void *v44;
  NSObject *v45;
  void *v46;
  NSObject *v47;
  void *v48;
  NSObject *v49;
  void *v50;
  NSObject *v51;
  void *v52;
  char *backtrace_string;
  _BOOL4 v54;
  const char *v55;
  _BOOL4 v56;
  NSObject *v57;
  void *v58;
  NSObject *v59;
  void *v60;
  _BOOL4 v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  _DWORD *__s2a;
  char *v67;
  unsigned int v68;
  unsigned int v69;
  int v70;
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  int v78;
  _BYTE v79[22];
  __int16 v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v39 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v70) = 0;
    if (!__nwlog_fault(v39, buf, &v70))
      goto LABEL_124;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v40 = objc_claimAutoreleasedReturnValue();
      v41 = buf[0];
      if (!os_log_type_enabled(v40, (os_log_type_t)buf[0]))
        goto LABEL_123;
      *(_DWORD *)v79 = 136446210;
      *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      v42 = "%{public}s called with null ipv6_addrs";
LABEL_122:
      _os_log_impl(&dword_182FBE000, v40, v41, v42, v79, 0xCu);
      goto LABEL_123;
    }
    if (!(_BYTE)v70)
    {
      __nwlog_obj();
      v40 = objc_claimAutoreleasedReturnValue();
      v41 = buf[0];
      if (os_log_type_enabled(v40, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null ipv6_addrs, backtrace limit exceeded";
        goto LABEL_122;
      }
      goto LABEL_123;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v40 = objc_claimAutoreleasedReturnValue();
    v41 = buf[0];
    v54 = os_log_type_enabled(v40, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v54)
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null ipv6_addrs, no backtrace";
        goto LABEL_122;
      }
      goto LABEL_123;
    }
    if (!v54)
      goto LABEL_109;
    *(_DWORD *)v79 = 136446466;
    *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *(_WORD *)&v79[12] = 2082;
    *(_QWORD *)&v79[14] = backtrace_string;
    v55 = "%{public}s called with null ipv6_addrs, dumping backtrace:%{public}s";
LABEL_108:
    _os_log_impl(&dword_182FBE000, v40, v41, v55, v79, 0x16u);
LABEL_109:

    free(backtrace_string);
    goto LABEL_124;
  }
  if (!a2)
  {
    __nwlog_obj();
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v39 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v70) = 0;
    if (!__nwlog_fault(v39, buf, &v70))
      goto LABEL_124;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v40 = objc_claimAutoreleasedReturnValue();
      v41 = buf[0];
      if (!os_log_type_enabled(v40, (os_log_type_t)buf[0]))
        goto LABEL_123;
      *(_DWORD *)v79 = 136446210;
      *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      v42 = "%{public}s called with null num_ipv6_addrs";
      goto LABEL_122;
    }
    if (!(_BYTE)v70)
    {
      __nwlog_obj();
      v40 = objc_claimAutoreleasedReturnValue();
      v41 = buf[0];
      if (os_log_type_enabled(v40, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null num_ipv6_addrs, backtrace limit exceeded";
        goto LABEL_122;
      }
      goto LABEL_123;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v40 = objc_claimAutoreleasedReturnValue();
    v41 = buf[0];
    v56 = os_log_type_enabled(v40, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v56)
      {
        *(_DWORD *)v79 = 136446210;
        *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        v42 = "%{public}s called with null num_ipv6_addrs, no backtrace";
        goto LABEL_122;
      }
      goto LABEL_123;
    }
    if (!v56)
      goto LABEL_109;
    *(_DWORD *)v79 = 136446466;
    *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *(_WORD *)&v79[12] = 2082;
    *(_QWORD *)&v79[14] = backtrace_string;
    v55 = "%{public}s called with null num_ipv6_addrs, dumping backtrace:%{public}s";
    goto LABEL_108;
  }
  if (!a3)
  {
    __nwlog_obj();
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    v39 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v70) = 0;
    if (__nwlog_fault(v39, buf, &v70))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v41 = buf[0];
        if (os_log_type_enabled(v40, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v79 = 136446210;
          *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          v42 = "%{public}s called with null out_prefixes";
          goto LABEL_122;
        }
LABEL_123:

        goto LABEL_124;
      }
      if (!(_BYTE)v70)
      {
        __nwlog_obj();
        v40 = objc_claimAutoreleasedReturnValue();
        v41 = buf[0];
        if (os_log_type_enabled(v40, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)v79 = 136446210;
          *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          v42 = "%{public}s called with null out_prefixes, backtrace limit exceeded";
          goto LABEL_122;
        }
        goto LABEL_123;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v40 = objc_claimAutoreleasedReturnValue();
      v41 = buf[0];
      v61 = os_log_type_enabled(v40, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v61)
        {
          *(_DWORD *)v79 = 136446210;
          *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          v42 = "%{public}s called with null out_prefixes, no backtrace";
          goto LABEL_122;
        }
        goto LABEL_123;
      }
      if (!v61)
        goto LABEL_109;
      *(_DWORD *)v79 = 136446466;
      *(_QWORD *)&v79[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      *(_WORD *)&v79[12] = 2082;
      *(_QWORD *)&v79[14] = backtrace_string;
      v55 = "%{public}s called with null out_prefixes, dumping backtrace:%{public}s";
      goto LABEL_108;
    }
LABEL_124:
    if (v39)
      free(v39);
    return 0xFFFFFFFFLL;
  }
  v5 = (2 * a2);
  if (!(_DWORD)v5)
  {
    __nwlog_obj();
    v45 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "strict_calloc";
    v46 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v46);
    if ((_DWORD)result)
      goto LABEL_127;
    free(v46);
  }
  v6 = (char *)malloc_type_calloc((2 * a2), 0x10uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
    if ((_DWORD)v5)
      goto LABEL_7;
    goto LABEL_88;
  }
  __nwlog_obj();
  v47 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
  *(_DWORD *)v79 = 136446722;
  *(_QWORD *)&v79[4] = "strict_calloc";
  *(_WORD *)&v79[12] = 2048;
  *(_QWORD *)&v79[14] = v5;
  v80 = 2048;
  v81 = 16;
  v48 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v48);
  if ((_DWORD)result)
    goto LABEL_127;
  free(v48);
  if (!(_DWORD)v5)
  {
LABEL_88:
    __nwlog_obj();
    v49 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "strict_calloc";
    v50 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v50);
    if ((_DWORD)result)
      goto LABEL_127;
    free(v50);
  }
LABEL_7:
  v7 = malloc_type_calloc((2 * a2), 0x10uLL, 0xEAFB8F1AuLL);
  if (!v7)
  {
    __nwlog_obj();
    v51 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v79 = 136446722;
    *(_QWORD *)&v79[4] = "strict_calloc";
    *(_WORD *)&v79[12] = 2048;
    *(_QWORD *)&v79[14] = v5;
    v80 = 2048;
    v81 = 16;
    v52 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v52);
    if (!(_DWORD)result)
    {
      free(v52);
      goto LABEL_8;
    }
LABEL_127:
    __break(1u);
    return result;
  }
LABEL_8:
  v67 = v6;
  v62 = a3;
  v8 = 0;
  v68 = 0;
  v9 = 0;
  do
  {
    v10 = (_BYTE *)(a1 + 16 * v8);
    if (!v10[8])
    {
      v15 = 0;
      while (1)
      {
        v16 = nw_nat64_copy_prefixes_from_ipv4only_records::prefix_lengths[v15];
        *(_DWORD *)&v79[12] = 0;
        *(_QWORD *)&v79[4] = 0;
        *(_DWORD *)v79 = v16;
        if (v15 == 5)
          v17 = 0;
        else
          v17 = 12 - v16;
        bzero(&v79[v16 + 4], v17);
        memcpy(&v79[4], v10, v16);
        v70 = 0;
        if (!nw_nat64_extract_v4((unsigned int *)v79, v10, (uint64_t)&v70))
          goto LABEL_18;
        if (v70 == -1426063168)
        {
          if (v68 >= v5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v18 = (id)gLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v72 = "nw_nat64_copy_prefixes_from_ipv4only_records";
              v19 = v18;
              v20 = "%{public}s too many valid prefixes for WKA2";
LABEL_32:
              _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0xCu);
            }
LABEL_33:

            goto LABEL_18;
          }
          v7[v68++] = *(_OWORD *)v79;
        }
        else if (v70 == -1442840384)
        {
          if (v9 >= v5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v18 = (id)gLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v72 = "nw_nat64_copy_prefixes_from_ipv4only_records";
              v19 = v18;
              v20 = "%{public}s too many valid prefixes for WKA1";
              goto LABEL_32;
            }
            goto LABEL_33;
          }
          *(_OWORD *)&v6[16 * v9++] = *(_OWORD *)v79;
        }
LABEL_18:
        if (++v15 == 6)
          goto LABEL_10;
      }
    }
    v11 = inet_ntop(30, (const void *)(a1 + 16 * v8), v79, 0x2Eu);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = v10[8];
      v14 = v79;
      if (!v11)
        v14 = "?";
      *(_DWORD *)buf = 136446979;
      v72 = "nw_nat64_copy_prefixes_from_ipv4only_records";
      v73 = 1024;
      v74 = v8;
      v75 = 2085;
      v76 = v14;
      v77 = 1024;
      v78 = v13;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s v6res[%u] %{sensitive}s has non zero bits 64-71: 0x%x", buf, 0x22u);
    }

LABEL_10:
    ++v8;
  }
  while (v8 != a2);
  if (!(v9 | v68))
  {
    if (v6)
      free(v6);
    if (v7)
    {
      v21 = v7;
      goto LABEL_69;
    }
    return 0;
  }
  if (v9 <= v68)
    v22 = v68;
  else
    v22 = v9;
  if (!(_DWORD)v22)
  {
    __nwlog_obj();
    v57 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
    *(_DWORD *)v79 = 136446210;
    *(_QWORD *)&v79[4] = "strict_calloc";
    v58 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v58);
    if (!(_DWORD)result)
    {
      free(v58);
      goto LABEL_43;
    }
    goto LABEL_127;
  }
LABEL_43:
  v23 = malloc_type_calloc(v22, 0x10uLL, 0xEAFB8F1AuLL);
  if (v23)
    goto LABEL_44;
  __nwlog_obj();
  v59 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
  *(_DWORD *)v79 = 136446722;
  *(_QWORD *)&v79[4] = "strict_calloc";
  *(_WORD *)&v79[12] = 2048;
  *(_QWORD *)&v79[14] = v22;
  v80 = 2048;
  v81 = 16;
  v60 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v60);
  if ((_DWORD)result)
    goto LABEL_127;
  free(v60);
LABEL_44:
  v24 = 0;
  if (v9 && v68)
  {
    v25 = 0;
    v24 = 0;
    __s2a = (_DWORD *)v23 + 1;
    v63 = v9;
    v26 = v68;
    do
    {
      v27 = 0;
      v64 = v25;
      v28 = &v67[16 * v25];
      v29 = v24;
      do
      {
        v30 = *(unsigned int *)v28;
        if ((_DWORD)v30 == LODWORD(v7[v27]) && !memcmp(v28 + 4, (char *)&v7[v27] + 4, *(unsigned int *)v28))
        {
          if ((_DWORD)v29)
          {
            v31 = v7;
            v32 = v23;
            v69 = v29;
            v33 = v29;
            v34 = __s2a;
            v35 = v33;
            while ((_DWORD)v30 != *(v34 - 1) || memcmp(v28 + 4, v34, v30))
            {
              v34 += 4;
              if (!--v35)
              {
                v23 = v32;
                v7 = v31;
                LODWORD(v29) = v69;
                goto LABEL_50;
              }
            }
            v23 = v32;
            v7 = v31;
            v29 = v69;
          }
          else
          {
            v33 = 0;
LABEL_50:
            v23[v33] = *(_OWORD *)v28;
            v29 = (v29 + 1);
          }
        }
        ++v27;
      }
      while (v27 != v26);
      v24 = v29;
      v25 = v64 + 1;
    }
    while (v64 + 1 != v63);
  }
  if (v67)
    free(v67);
  v36 = v24;
  if (v7)
    free(v7);
  if ((_DWORD)v24)
  {
    *v62 = v23;
  }
  else
  {
    if (v23)
    {
      v21 = v23;
LABEL_69:
      free(v21);
    }
    return 0;
  }
  return v36;
}

uint64_t nw_nat64_copy_prefixes(unsigned int *a1, _QWORD *a2)
{
  _BOOL8 v4;
  NSObject *v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  unsigned int v13;
  char *backtrace_string;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0)
    return 0;
  if ((sNWDispatchAllowedNow & 1) != 0)
    goto LABEL_9;
  if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
    || (getpid(), sandbox_check() == 1))
  {
    sNWDispatchAllowedNow = 1;
    goto LABEL_9;
  }
  if (sNWDispatchAllowedNow != 1)
    return 0;
LABEL_9:
  if (a2)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        if (a1)
          v13 = *a1;
        else
          v13 = 0;
        *(_DWORD *)buf = 136446466;
        v19 = "nw_nat64_copy_prefixes";
        v20 = 1024;
        LODWORD(v21) = v13;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Start nw_nat64_copy_prefixes(%u)", buf, 0x12u);
      }

    }
    *a2 = 0;
    v4 = nw_nat64_copy_prefixes_internal(a1, a2, 0, 0, 0, 0);
    if (gLogDatapath)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v19 = "nw_nat64_copy_prefixes";
        v20 = 1024;
        LODWORD(v21) = v4;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s nw_nat64_copy_prefixes returning %d", buf, 0x12u);
      }

    }
    return v4;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_nat64_copy_prefixes";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_copy_prefixes";
        v11 = "%{public}s called with null out_prefixes";
LABEL_36:
        _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
      }
    }
    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_nat64_copy_prefixes";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null out_prefixes, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }
        if (!v15)
          goto LABEL_37;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_copy_prefixes";
        v11 = "%{public}s called with null out_prefixes, no backtrace";
        goto LABEL_36;
      }
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_copy_prefixes";
        v11 = "%{public}s called with null out_prefixes, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
LABEL_37:

  }
LABEL_38:
  if (v8)
    free(v8);
  return 0xFFFFFFFFLL;
}

BOOL nw_nat64_copy_prefixes_internal(unsigned int *a1, _QWORD *a2, void *a3, DNSServiceRef *a4, _DWORD *a5, void *a6)
{
  NSObject *v11;
  id v12;
  int interface_state_internal;
  int v14;
  uint64_t v15;
  unsigned int *v16;
  void *v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  void *v25;
  uint32_t v26;
  NSObject *v27;
  id v28;
  void *v29;
  void **v30;
  DNSServiceErrorType v31;
  NSObject *v32;
  NSObject *v33;
  const char *v34;
  const char *v35;
  id v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  char *v40;
  os_log_type_t v41;
  _BOOL4 v42;
  id v43;
  NSObject *v44;
  os_log_type_t v45;
  void **v46;
  void *v47;
  void *v48;
  DNSServiceFlags v49;
  DNSServiceRef *p_service;
  DNSServiceErrorType AddrInfo;
  NSObject *v52;
  const char *string_for_dns_service_error;
  void *v54;
  uint64_t v55;
  const char *v56;
  void *v57;
  char *backtrace_string;
  os_log_type_t v59;
  _BOOL4 v60;
  os_log_type_t v61;
  NSObject *v62;
  os_log_type_t v63;
  DNSServiceErrorType v64;
  NSObject *v65;
  NSObject *v66;
  DNSServiceRef v67;
  const char *v68;
  char *v69;
  int v70;
  NSObject *v71;
  os_log_type_t v72;
  DNSServiceRef v73;
  const char *v74;
  _BOOL8 result;
  char *v76;
  NSObject *v77;
  os_log_type_t v78;
  _BOOL4 v79;
  DNSServiceRef v80;
  const char *v81;
  int v82;
  os_log_type_t v83;
  DNSServiceRef v84;
  const char *v85;
  DNSServiceRef v86;
  const char *v87;
  NSObject *v88;
  void *v89;
  NSObject *v90;
  void *v91;
  NSObject *v92;
  void *v93;
  dispatch_queue_t queue;
  DNSServiceRef *aBlock;
  NSObject *v96;
  _QWORD block[4];
  id v98;
  DNSServiceRef *v99;
  int v100;
  id v101;
  unsigned int v102;
  DNSServiceRef sdRef;
  uint64_t p_sdRef;
  uint64_t v105;
  void *v106;
  id v107;
  char v108;
  os_log_type_t type;
  DNSServiceRef service;
  uint8_t buf[4];
  const char *v112;
  __int16 v113;
  _BYTE v114[30];
  _BYTE v115[6];
  char *v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  v11 = a3;
  v12 = a6;
  v102 = 0;
  if (a1)
    v102 = *a1;
  v101 = 0;
  interface_state_internal = nw_nat64_get_interface_state_internal(&v102, &v101);
  v14 = interface_state_internal;
  if (a1)
    *a1 = v102;
  v15 = 0;
  switch(interface_state_internal)
  {
    case 1:
      if (!v101)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v43 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v112 = "nw_nat64_copy_prefixes_internal";
        v37 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(sdRef) = 16;
        LOBYTE(service) = 0;
        if (!__nwlog_fault(v37, &sdRef, &service))
          goto LABEL_108;
        if (sdRef == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v44 = (id)gLogObj;
          v45 = sdRef;
          if (os_log_type_enabled(v44, (os_log_type_t)sdRef))
          {
            *(_DWORD *)buf = 136446210;
            v112 = "nw_nat64_copy_prefixes_internal";
            _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s Received invalid path", buf, 0xCu);
          }
        }
        else if ((_BYTE)service)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v44 = objc_claimAutoreleasedReturnValue();
          v59 = sdRef;
          v60 = os_log_type_enabled(v44, (os_log_type_t)sdRef);
          if (backtrace_string)
          {
            if (v60)
            {
              *(_DWORD *)buf = 136446466;
              v112 = "nw_nat64_copy_prefixes_internal";
              v113 = 2082;
              *(_QWORD *)v114 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v44, v59, "%{public}s Received invalid path, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (v37)
LABEL_109:
              free(v37);
LABEL_110:
            v15 = 0xFFFFFFFFLL;
            goto LABEL_111;
          }
          if (v60)
          {
            *(_DWORD *)buf = 136446210;
            v112 = "nw_nat64_copy_prefixes_internal";
            _os_log_impl(&dword_182FBE000, v44, v59, "%{public}s Received invalid path, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v44 = objc_claimAutoreleasedReturnValue();
          v63 = sdRef;
          if (os_log_type_enabled(v44, (os_log_type_t)sdRef))
          {
            *(_DWORD *)buf = 136446210;
            v112 = "nw_nat64_copy_prefixes_internal";
            _os_log_impl(&dword_182FBE000, v44, v63, "%{public}s Received invalid path, backtrace limit exceeded", buf, 0xCu);
          }
        }

        goto LABEL_108;
      }
      v16 = (unsigned int *)v101;

      sdRef = 0;
      p_sdRef = (uint64_t)&sdRef;
      v105 = 0x2020000000;
      v106 = 0;
      v17 = malloc_type_calloc(4uLL, 0x10uLL, 0xEAFB8F1AuLL);
      if (v17)
        goto LABEL_8;
      __nwlog_obj();
      v90 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v90, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v112 = "strict_calloc";
      v113 = 2048;
      *(_QWORD *)v114 = 4;
      *(_WORD *)&v114[8] = 2048;
      *(_QWORD *)&v114[10] = 16;
      v91 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v91);
      if (result)
        goto LABEL_134;
      free(v91);
LABEL_8:
      v106 = v17;
      v18 = v16[102];
      if ((_DWORD)v18)
      {
        **(_DWORD **)(p_sdRef + 24) = v18;
        memcpy((void *)(*(_QWORD *)(p_sdRef + 24) + 4), v16 + 98, v18);
        v15 = 1;
        v19 = v16[107];
        if (!(_DWORD)v19)
        {
LABEL_11:
          v21 = v16[112];
          if ((_DWORD)v21)
          {
            v22 = 16 * v15;
            *(_DWORD *)(*(_QWORD *)(p_sdRef + 24) + v22) = v21;
            memcpy((void *)(*(_QWORD *)(p_sdRef + 24) + v22 + 4), v16 + 98, v21);
            v15 = (v15 + 1);
          }
          v23 = v16[117];
          if ((_DWORD)v23)
          {
            v24 = 16 * v15;
            *(_DWORD *)(*(_QWORD *)(p_sdRef + 24) + v24) = v23;
            memcpy((void *)(*(_QWORD *)(p_sdRef + 24) + v24 + 4), v16 + 98, v23);
            v15 = (v15 + 1);
          }
          if (a2)
          {
            v25 = *(void **)(p_sdRef + 24);
            if ((_DWORD)v15)
            {
              *a2 = v25;
            }
            else if (v25)
            {
              free(v25);
              v15 = 0;
              *(_QWORD *)(p_sdRef + 24) = 0;
            }
            else
            {
              v15 = 0;
            }
          }
          else
          {
            block[0] = MEMORY[0x1E0C809B0];
            block[1] = 3221225472;
            block[2] = ___ZL31nw_nat64_copy_prefixes_internalPjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS1_E_block_invoke;
            block[3] = &unk_1E14A4C00;
            v100 = v15;
            v98 = v12;
            v99 = &sdRef;
            dispatch_async(v11, block);

            v15 = 0x80000000;
          }
          _Block_object_dispose(&sdRef, 8);
LABEL_111:

          return v15;
        }
      }
      else
      {
        v15 = 0;
        v19 = v16[107];
        if (!(_DWORD)v19)
          goto LABEL_11;
      }
      v20 = 16 * v15;
      *(_DWORD *)(*(_QWORD *)(p_sdRef + 24) + v20) = v19;
      memcpy((void *)(*(_QWORD *)(p_sdRef + 24) + v20 + 4), v16 + 98, v19);
      v15 = (v15 + 1);
      goto LABEL_11;
    case 2:
      v26 = v102;
      v27 = v11;
      v28 = v12;
      v29 = v28;
      v96 = v27;
      if (!a2)
      {
        sdRef = (DNSServiceRef)MEMORY[0x1E0C809B0];
        p_sdRef = 3221225472;
        v105 = (uint64_t)___ZL43nw_nat64_copy_prefixes_by_querying_ipv4onlyjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS0_E_block_invoke;
        v106 = &unk_1E14A4C28;
        v107 = v28;
        queue = v27;
        aBlock = &sdRef;
        v46 = (void **)malloc_type_calloc(0x18uLL, 1uLL, 0xEAFB8F1AuLL);
        if (!v46)
        {
          __nwlog_obj();
          v92 = objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          v112 = "strict_calloc";
          v113 = 2048;
          *(_QWORD *)v114 = 24;
          *(_WORD *)&v114[8] = 2048;
          *(_QWORD *)&v114[10] = 1;
          v93 = (void *)_os_log_send_and_compose_impl();

          result = __nwlog_abort((uint64_t)v93);
          if (result)
            goto LABEL_134;
          free(v93);
        }
        v47 = _Block_copy(aBlock);
        v48 = v46[1];
        v46[1] = v47;

        v49 = 1073844224;
        service = 0;
        if (a4)
          p_service = a4;
        else
          p_service = &service;
        if (a5)
          v49 = *a5 | 0x40019000;
        AddrInfo = DNSServiceGetAddrInfo(p_service, v49, v26, 2u, "ipv4only.arpa", (DNSServiceGetAddrInfoReply)nw_nat64_getaddrinfo_callback_async, v46);
        if (AddrInfo)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v52 = (id)gLogObj;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            string_for_dns_service_error = nwlog_get_string_for_dns_service_error(AddrInfo);
            *(_DWORD *)buf = 136447490;
            v112 = "nw_nat64_query_ipv4only_records_async";
            v113 = 1024;
            *(_DWORD *)v114 = v49;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v26;
            *(_WORD *)&v114[10] = 2082;
            *(_QWORD *)&v114[12] = "ipv4only.arpa";
            *(_WORD *)&v114[20] = 2082;
            *(_QWORD *)&v114[22] = string_for_dns_service_error;
            *(_WORD *)v115 = 1024;
            *(_DWORD *)&v115[2] = AddrInfo;
            _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_ERROR, "%{public}s starting DNS query with flags %#x on ifindex %u for %{public}s failed with error=%{public}s(%d)", buf, 0x32u);
          }

LABEL_49:
          if (service)
            DNSServiceRefDeallocate(service);
          v54 = v46[1];
          v46[1] = 0;

          if (*v46)
            free(*v46);
          free(v46);
          v15 = 0xFFFFFFFFLL;
          goto LABEL_89;
        }
        if (a4)
        {
          __nwlog_obj();
          v62 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v112 = "nw_nat64_query_ipv4only_records_async";
            v113 = 1024;
            *(_DWORD *)v114 = v26;
            *(_WORD *)&v114[4] = 2082;
            *(_QWORD *)&v114[6] = "ipv4only.arpa";
            _os_log_impl(&dword_182FBE000, v62, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query with custom sdRef on ifindex %u for %{public}s successfully", buf, 0x1Cu);
          }

LABEL_88:
          v15 = 0x80000000;
LABEL_89:

          goto LABEL_90;
        }
        v64 = DNSServiceSetDispatchQueue(service, queue);
        __nwlog_obj();
        v65 = objc_claimAutoreleasedReturnValue();
        v66 = v65;
        if (!v64)
        {
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v112 = "nw_nat64_query_ipv4only_records_async";
            v113 = 1024;
            *(_DWORD *)v114 = v26;
            *(_WORD *)&v114[4] = 2082;
            *(_QWORD *)&v114[6] = "ipv4only.arpa";
            _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query on ifindex %u for %{public}s successfully", buf, 0x1Cu);
          }

          goto LABEL_88;
        }
        v67 = service;
        v68 = nwlog_get_string_for_dns_service_error(v64);
        *(_DWORD *)buf = 136447234;
        v112 = "nw_nat64_query_ipv4only_records_async";
        v113 = 2048;
        *(_QWORD *)v114 = v67;
        *(_WORD *)&v114[8] = 2048;
        *(_QWORD *)&v114[10] = queue;
        *(_WORD *)&v114[18] = 2082;
        *(_QWORD *)&v114[20] = v68;
        *(_WORD *)&v114[28] = 1024;
        *(_DWORD *)v115 = v64;
        v69 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v108 = 0;
        if (__nwlog_fault(v69, &type, &v108))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v70 = v64;
            __nwlog_obj();
            v71 = objc_claimAutoreleasedReturnValue();
            v72 = type;
            if (os_log_type_enabled(v71, type))
            {
              v73 = service;
              v74 = nwlog_get_string_for_dns_service_error(v70);
              *(_DWORD *)buf = 136447234;
              v112 = "nw_nat64_query_ipv4only_records_async";
              v113 = 2048;
              *(_QWORD *)v114 = v73;
              *(_WORD *)&v114[8] = 2048;
              *(_QWORD *)&v114[10] = queue;
              *(_WORD *)&v114[18] = 2082;
              *(_QWORD *)&v114[20] = v74;
              *(_WORD *)&v114[28] = 1024;
              *(_DWORD *)v115 = v70;
              _os_log_impl(&dword_182FBE000, v71, v72, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed", buf, 0x30u);
            }
          }
          else
          {
            if (v108)
            {
              v76 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v77 = objc_claimAutoreleasedReturnValue();
              v78 = type;
              v79 = os_log_type_enabled(v77, type);
              if (v76)
              {
                if (v79)
                {
                  v80 = service;
                  v81 = nwlog_get_string_for_dns_service_error(v64);
                  *(_DWORD *)buf = 136447490;
                  v112 = "nw_nat64_query_ipv4only_records_async";
                  v113 = 2048;
                  *(_QWORD *)v114 = v80;
                  *(_WORD *)&v114[8] = 2048;
                  *(_QWORD *)&v114[10] = queue;
                  *(_WORD *)&v114[18] = 2082;
                  *(_QWORD *)&v114[20] = v81;
                  *(_WORD *)&v114[28] = 1024;
                  *(_DWORD *)v115 = v64;
                  *(_WORD *)&v115[4] = 2082;
                  v116 = v76;
                  _os_log_impl(&dword_182FBE000, v77, v78, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, dumping backtrace:%{public}s", buf, 0x3Au);
                }

                free(v76);
              }
              else
              {
                if (v79)
                {
                  v86 = service;
                  v87 = nwlog_get_string_for_dns_service_error(v64);
                  *(_DWORD *)buf = 136447234;
                  v112 = "nw_nat64_query_ipv4only_records_async";
                  v113 = 2048;
                  *(_QWORD *)v114 = v86;
                  *(_WORD *)&v114[8] = 2048;
                  *(_QWORD *)&v114[10] = queue;
                  *(_WORD *)&v114[18] = 2082;
                  *(_QWORD *)&v114[20] = v87;
                  *(_WORD *)&v114[28] = 1024;
                  *(_DWORD *)v115 = v64;
                  _os_log_impl(&dword_182FBE000, v77, v78, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, no backtrace", buf, 0x30u);
                }

              }
              goto LABEL_126;
            }
            v82 = v64;
            __nwlog_obj();
            v71 = objc_claimAutoreleasedReturnValue();
            v83 = type;
            if (os_log_type_enabled(v71, type))
            {
              v84 = service;
              v85 = nwlog_get_string_for_dns_service_error(v82);
              *(_DWORD *)buf = 136447234;
              v112 = "nw_nat64_query_ipv4only_records_async";
              v113 = 2048;
              *(_QWORD *)v114 = v84;
              *(_WORD *)&v114[8] = 2048;
              *(_QWORD *)&v114[10] = queue;
              *(_WORD *)&v114[18] = 2082;
              *(_QWORD *)&v114[20] = v85;
              *(_WORD *)&v114[28] = 1024;
              *(_DWORD *)v115 = v82;
              _os_log_impl(&dword_182FBE000, v71, v83, "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, backtrace limit exceeded", buf, 0x30u);
            }
          }

        }
LABEL_126:
        if (v69)
          free(v69);
        goto LABEL_49;
      }
      v30 = (void **)malloc_type_calloc(0x10uLL, 1uLL, 0xEAFB8F1AuLL);
      if (v30)
        goto LABEL_20;
      __nwlog_obj();
      v88 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v88, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      v112 = "strict_calloc";
      v113 = 2048;
      *(_QWORD *)v114 = 16;
      *(_WORD *)&v114[8] = 2048;
      *(_QWORD *)&v114[10] = 1;
      v89 = (void *)_os_log_send_and_compose_impl();

      result = __nwlog_abort((uint64_t)v89);
      if (!result)
      {
        free(v89);
LABEL_20:
        sdRef = 0;
        v31 = DNSServiceGetAddrInfo(&sdRef, 0x40019000u, v26, 2u, "ipv4only.arpa", (DNSServiceGetAddrInfoReply)nw_nat64_getaddrinfo_callback_sync, v30);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v32 = (id)gLogObj;
        v33 = v32;
        if (v31)
        {
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            goto LABEL_67;
          v34 = nwlog_get_string_for_dns_service_error(v31);
          *(_DWORD *)buf = 136447234;
          v112 = "nw_nat64_copy_ipv4only_records";
          v113 = 1024;
          *(_DWORD *)v114 = v26;
          *(_WORD *)&v114[4] = 2082;
          *(_QWORD *)&v114[6] = "ipv4only.arpa";
          *(_WORD *)&v114[14] = 2082;
          *(_QWORD *)&v114[16] = v34;
          *(_WORD *)&v114[24] = 1024;
          *(_DWORD *)&v114[26] = v31;
          v35 = "%{public}s starting DNS query on ifindex %u for %{public}s failed with error=%{public}s(%d)";
        }
        else
        {
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v112 = "nw_nat64_copy_ipv4only_records";
            v113 = 1024;
            *(_DWORD *)v114 = v26;
            *(_WORD *)&v114[4] = 2082;
            *(_QWORD *)&v114[6] = "ipv4only.arpa";
            _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query on ifindex %u for %{public}s successfully", buf, 0x1Cu);
          }

          do
          {
            if (*((_BYTE *)v30 + 12))
              goto LABEL_68;
          }
          while (!DNSServiceProcessResult(sdRef));
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            goto LABEL_67;
          v55 = DNSServiceErrorCodeToString();
          *(_DWORD *)buf = 136447234;
          v112 = "nw_nat64_copy_ipv4only_records";
          v56 = "NoError";
          if (v55)
            v56 = (const char *)v55;
          v113 = 1024;
          *(_DWORD *)v114 = v26;
          *(_WORD *)&v114[4] = 2082;
          *(_QWORD *)&v114[6] = "ipv4only.arpa";
          *(_WORD *)&v114[14] = 2082;
          *(_QWORD *)&v114[16] = v56;
          *(_WORD *)&v114[24] = 1024;
          *(_DWORD *)&v114[26] = 0;
          v35 = "%{public}s DNSServiceProcessResult on ifindex %u for %{public}s failed with error=%{public}s(%d)";
        }
        _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_ERROR, v35, buf, 0x2Cu);
LABEL_67:

LABEL_68:
        v15 = *((unsigned int *)v30 + 2);
        v57 = *v30;
        free(v30);
        if (sdRef)
          DNSServiceRefDeallocate(sdRef);
        if ((int)v15 >= 1)
        {
          v15 = nw_nat64_copy_prefixes_from_ipv4only_records((uint64_t)v57, v15, a2);
          if (v57)
            free(v57);
        }
LABEL_90:

        goto LABEL_111;
      }
LABEL_134:
      __break(1u);
      return result;
    case 3:
      goto LABEL_111;
    case 4:
      goto LABEL_110;
    default:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v36 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v112 = "nw_nat64_copy_prefixes_internal";
      v113 = 1024;
      *(_DWORD *)v114 = v14;
      v37 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(sdRef) = 16;
      LOBYTE(service) = 0;
      if (!__nwlog_fault(v37, &sdRef, &service))
        goto LABEL_108;
      if (sdRef == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        v39 = sdRef;
        if (os_log_type_enabled(v38, (os_log_type_t)sdRef))
        {
          *(_DWORD *)buf = 136446466;
          v112 = "nw_nat64_copy_prefixes_internal";
          v113 = 1024;
          *(_DWORD *)v114 = v14;
          _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s Received unknown state %d", buf, 0x12u);
        }
      }
      else if ((_BYTE)service)
      {
        v40 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        v41 = sdRef;
        v42 = os_log_type_enabled(v38, (os_log_type_t)sdRef);
        if (v40)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446722;
            v112 = "nw_nat64_copy_prefixes_internal";
            v113 = 1024;
            *(_DWORD *)v114 = v14;
            *(_WORD *)&v114[4] = 2082;
            *(_QWORD *)&v114[6] = v40;
            _os_log_impl(&dword_182FBE000, v38, v41, "%{public}s Received unknown state %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v40);
          if (v37)
            goto LABEL_109;
          goto LABEL_110;
        }
        if (v42)
        {
          *(_DWORD *)buf = 136446466;
          v112 = "nw_nat64_copy_prefixes_internal";
          v113 = 1024;
          *(_DWORD *)v114 = v14;
          _os_log_impl(&dword_182FBE000, v38, v41, "%{public}s Received unknown state %d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v38 = (id)gLogObj;
        v61 = sdRef;
        if (os_log_type_enabled(v38, (os_log_type_t)sdRef))
        {
          *(_DWORD *)buf = 136446466;
          v112 = "nw_nat64_copy_prefixes_internal";
          v113 = 1024;
          *(_DWORD *)v114 = v14;
          _os_log_impl(&dword_182FBE000, v38, v61, "%{public}s Received unknown state %d, backtrace limit exceeded", buf, 0x12u);
        }
      }

LABEL_108:
      if (!v37)
        goto LABEL_110;
      goto LABEL_109;
  }
}

void sub_1838CEEE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  void *v30;
  void *v31;
  void *v32;

  _Unwind_Resume(a1);
}

uint64_t nw_nat64_get_interface_state_internal(unsigned int *a1, id *a2)
{
  unsigned int v4;
  id v5;
  uint64_t v6;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NWConcrete_nw_interface *v12;
  NSObject *p_super;
  NSObject *v14;
  NSObject *v15;
  NWConcrete_nw_path_evaluator *v16;
  void *v17;
  id v18;
  NWConcrete_nw_path *v19;
  unsigned int routed_interface_index;
  NSObject *v21;
  id v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  char is_eligible_for_CrazyIvan46;
  _BOOL8 v27;
  NWConcrete_nw_path *v28;
  id v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *backtrace_string;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  NSObject *v37;
  const char *v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  id v42;
  NSObject *v43;
  os_log_type_t v44;
  char *v45;
  os_log_type_t v46;
  _BOOL4 v47;
  char *v48;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  os_log_type_t v52;
  os_log_type_t v53;
  os_log_type_t v54;
  os_log_type_t v55;
  os_log_type_t v56;
  NSObject *v57;
  char v59;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v62;
  __int16 v63;
  _WORD v64[17];

  *(_QWORD *)&v64[13] = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (a2)
  {
    v5 = *a2;
    *a2 = 0;

  }
  if (!v4)
  {
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, 0);
    if (evaluator_for_endpoint)
      goto LABEL_17;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v62 = "nw_nat64_get_interface_state_internal";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v59 = 0;
    if (__nwlog_fault(v9, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s nw_path_create_default_evaluator failed", buf, 0xCu);
        }
      }
      else if (v59)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v34 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v35 = (id)gLogObj;
          v36 = type;
          if (os_log_type_enabled(v35, type))
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_nat64_get_interface_state_internal";
            v63 = 2082;
            *(_QWORD *)v64 = v34;
            _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s nw_path_create_default_evaluator failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v34);
          if (!v9)
            return 4;
          goto LABEL_84;
        }
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v53 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_182FBE000, v10, v53, "%{public}s nw_path_create_default_evaluator failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v51 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_182FBE000, v10, v51, "%{public}s nw_path_create_default_evaluator failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
      return 4;
LABEL_84:
    free(v9);
    return 4;
  }
  if (v4 != -1)
  {
    v12 = nw_interface_create_with_index(v4);
    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = (id)gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v62 = "nw_nat64_get_interface_state_internal";
        v63 = 1024;
        *(_DWORD *)v64 = v4;
        _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s nw_interface_create_with_index failed for index %u", buf, 0x12u);
      }

      return 4;
    }
    p_super = &v12->super;
    v14 = nw_parameters_create();
    v15 = v14;
    if (v14)
    {
      nw_parameters_require_interface(v14, p_super);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, v15);
      if (evaluator_for_endpoint)
      {

LABEL_17:
        v16 = evaluator_for_endpoint;
        os_unfair_lock_lock((os_unfair_lock_t)evaluator_for_endpoint + 24);
        v17 = (void *)*((_QWORD *)v16 + 6);
        v18 = v17;
        os_unfair_lock_unlock((os_unfair_lock_t)evaluator_for_endpoint + 24);

        if (v18)
        {
          v19 = (NWConcrete_nw_path *)v18;
          if (nw_path_network_is_satisfied_update_reason(v19, 0))
            routed_interface_index = v19->policy_result.routed_interface_index;
          else
            routed_interface_index = 0;

          is_eligible_for_CrazyIvan46 = nw_path_is_eligible_for_CrazyIvan46(v19);
          if (gLogDatapath)
          {
            v27 = nw_path_copy_description(v19);
            *a1 = routed_interface_index;
            if (routed_interface_index)
            {
LABEL_31:
              if ((is_eligible_for_CrazyIvan46 & 1) != 0)
              {
                v28 = v19;
                if ((*((_BYTE *)v28 + 474) & 1) != 0)
                  v6 = 1;
                else
                  v6 = 2;

                if (!a2)
                {
LABEL_114:
                  if (v27)
                    free((void *)v27);
                  goto LABEL_116;
                }
LABEL_113:
                objc_storeStrong(a2, v17);
                goto LABEL_114;
              }
              if (gLogDatapath)
              {
                __nwlog_obj();
                v37 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 136446466;
                  v62 = "nw_nat64_get_interface_state_internal";
                  v63 = 2082;
                  *(_QWORD *)v64 = v27;
                  _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s bailing because path not eligible: %{public}s", buf, 0x16u);
                }
LABEL_51:

                goto LABEL_112;
              }
              goto LABEL_112;
            }
          }
          else
          {
            v27 = 0;
            *a1 = routed_interface_index;
            if (routed_interface_index)
              goto LABEL_31;
          }
          if (gLogDatapath)
          {
            __nwlog_obj();
            v37 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              v62 = "nw_nat64_get_interface_state_internal";
              v63 = 2082;
              *(_QWORD *)v64 = v27;
              _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s bailing because path not satisfied: %{public}s", buf, 0x16u);
            }
            goto LABEL_51;
          }
LABEL_112:
          v6 = 3;
          if (!a2)
            goto LABEL_114;
          goto LABEL_113;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v62 = "nw_nat64_get_interface_state_internal";
        v23 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v59 = 0;
        if (__nwlog_fault(v23, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s nw_path_evaluator_copy_path failed", buf, 0xCu);
            }
          }
          else if (v59)
          {
            v38 = __nw_create_backtrace_string();
            if (v38)
            {
              v39 = (char *)v38;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v40 = (id)gLogObj;
              v41 = type;
              if (os_log_type_enabled(v40, type))
              {
                *(_DWORD *)buf = 136446466;
                v62 = "nw_nat64_get_interface_state_internal";
                v63 = 2082;
                *(_QWORD *)v64 = v39;
                _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s nw_path_evaluator_copy_path failed, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v39);
              if (!v23)
                goto LABEL_93;
              goto LABEL_92;
            }
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            v55 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_182FBE000, v24, v55, "%{public}s nw_path_evaluator_copy_path failed, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v24 = (id)gLogObj;
            v52 = type;
            if (os_log_type_enabled(v24, type))
            {
              *(_DWORD *)buf = 136446210;
              v62 = "nw_nat64_get_interface_state_internal";
              _os_log_impl(&dword_182FBE000, v24, v52, "%{public}s nw_path_evaluator_copy_path failed, backtrace limit exceeded", buf, 0xCu);
            }
          }

        }
        if (!v23)
        {
LABEL_93:
          v6 = 4;
LABEL_116:

          return v6;
        }
LABEL_92:
        free(v23);
        goto LABEL_93;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v42 = (id)gLogObj;
      *(_DWORD *)buf = 136446466;
      v62 = "nw_nat64_get_interface_state_internal";
      v63 = 1024;
      *(_DWORD *)v64 = v4;
      v30 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v59 = 0;
      if (__nwlog_fault(v30, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v43 = (id)gLogObj;
          v44 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_nat64_get_interface_state_internal";
            v63 = 1024;
            *(_DWORD *)v64 = v4;
            _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed", buf, 0x12u);
          }
LABEL_102:

          goto LABEL_103;
        }
        if (!v59)
        {
          __nwlog_obj();
          v43 = objc_claimAutoreleasedReturnValue();
          v56 = type;
          if (os_log_type_enabled(v43, type))
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_nat64_get_interface_state_internal";
            v63 = 1024;
            *(_DWORD *)v64 = v4;
            _os_log_impl(&dword_182FBE000, v43, v56, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, backtrace limit exceeded", buf, 0x12u);
          }
          goto LABEL_102;
        }
        v48 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v49 = type;
        v50 = os_log_type_enabled(v43, type);
        if (!v48)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            v62 = "nw_nat64_get_interface_state_internal";
            v63 = 1024;
            *(_DWORD *)v64 = v4;
            _os_log_impl(&dword_182FBE000, v43, v49, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, no backtrace", buf, 0x12u);
          }
          goto LABEL_102;
        }
        if (v50)
        {
          *(_DWORD *)buf = 136446722;
          v62 = "nw_nat64_get_interface_state_internal";
          v63 = 1024;
          *(_DWORD *)v64 = v4;
          v64[2] = 2082;
          *(_QWORD *)&v64[3] = v48;
          _os_log_impl(&dword_182FBE000, v43, v49, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v48);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v29 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v62 = "nw_nat64_get_interface_state_internal";
      v30 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v59 = 0;
      if (__nwlog_fault(v30, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v31 = (id)gLogObj;
          v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)buf = 136446210;
            v62 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s nw_parameters_create failed", buf, 0xCu);
          }
        }
        else if (v59)
        {
          v45 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v31 = objc_claimAutoreleasedReturnValue();
          v46 = type;
          v47 = os_log_type_enabled(v31, type);
          if (v45)
          {
            if (v47)
            {
              *(_DWORD *)buf = 136446466;
              v62 = "nw_nat64_get_interface_state_internal";
              v63 = 2082;
              *(_QWORD *)v64 = v45;
              _os_log_impl(&dword_182FBE000, v31, v46, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v45);
            if (!v30)
              goto LABEL_105;
            goto LABEL_104;
          }
          if (v47)
          {
            *(_DWORD *)buf = 136446210;
            v62 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_182FBE000, v31, v46, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v31 = objc_claimAutoreleasedReturnValue();
          v54 = type;
          if (os_log_type_enabled(v31, type))
          {
            *(_DWORD *)buf = 136446210;
            v62 = "nw_nat64_get_interface_state_internal";
            _os_log_impl(&dword_182FBE000, v31, v54, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
    }
LABEL_103:
    if (!v30)
    {
LABEL_105:

      return 4;
    }
LABEL_104:
    free(v30);
    goto LABEL_105;
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    v57 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      v62 = "nw_nat64_get_interface_state_internal";
      _os_log_impl(&dword_182FBE000, v57, OS_LOG_TYPE_DEBUG, "%{public}s bailing because local only", buf, 0xCu);
    }

  }
  return 3;
}

void sub_1838CFCB4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL31nw_nat64_copy_prefixes_internalPjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS1_E_block_invoke(uint64_t a1)
{
  void *v2;

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v2 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void nw_nat64_getaddrinfo_callback_sync(_DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, int *a8)
{
  NSObject *v15;
  int v16;
  nw_endpoint_t address;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  sockaddr *v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  _BYTE v30[10];
  __int16 v31;
  const char *string_for_dns_service_error;
  __int16 v33;
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *description;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v15 = (id)gLogObj;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {

  }
  else
  {
    v16 = gLogFDOverride;

    if (v16 == -1)
      goto LABEL_7;
  }
  address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136448002;
    v28 = "nw_nat64_getaddrinfo_callback_sync";
    v29 = 1024;
    *(_DWORD *)v30 = a2;
    *(_WORD *)&v30[4] = 1024;
    *(_DWORD *)&v30[6] = a3;
    v31 = 2082;
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a4);
    v33 = 1024;
    v34 = a4;
    v35 = 2082;
    v36 = a5;
    v37 = 2082;
    description = nw_endpoint_get_description(address);
    v39 = 1024;
    v40 = a7;
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%d", buf, 0x42u);
  }

LABEL_7:
  if (a4 || (a2 & 2) == 0 || !a6 || a6->sa_family != 30)
    goto LABEL_8;
  v19 = a8[2];
  v20 = v19 + 1;
  a8[2] = v19 + 1;
  if ((_DWORD)v19 == -1)
  {
    __nwlog_obj();
    v23 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v28 = "_strict_reallocf";
    v24 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v24))
      goto LABEL_21;
    free(v24);
  }
  v21 = 28 * v20;
  v22 = (sockaddr *)reallocf(*(void **)a8, 28 * v20);
  if (!v22)
  {
    __nwlog_obj();
    v25 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v28 = "_strict_reallocf";
    v29 = 2048;
    *(_QWORD *)v30 = v21;
    v26 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v26))
    {
      free(v26);
      goto LABEL_16;
    }
LABEL_21:
    __break(1u);
    return;
  }
LABEL_16:
  *(_QWORD *)a8 = v22;
  v22[a8[2] - 1] = *(sockaddr *)&a6->sa_data[6];
LABEL_8:
  if ((a2 & 1) == 0)
    *((_BYTE *)a8 + 12) = 1;
}

void sub_1838D00A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL43nw_nat64_copy_prefixes_by_querying_ipv4onlyjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS0_E_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  void *v4;

  if (a2 <= 0)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  else
  {
    v4 = 0;
    nw_nat64_copy_prefixes_from_ipv4only_records(a3, a2, &v4);
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    if (v4)
      free(v4);
  }
}

void nw_nat64_getaddrinfo_callback_async(_DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, int *a8)
{
  NSObject *v15;
  int v16;
  nw_endpoint_t address;
  NSObject *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  sockaddr *v24;
  NSObject *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  _BYTE v33[10];
  __int16 v34;
  const char *string_for_dns_service_error;
  __int16 v36;
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  const char *description;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v15 = (id)gLogObj;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {

  }
  else
  {
    v16 = gLogFDOverride;

    if (v16 == -1)
      goto LABEL_7;
  }
  address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136448002;
    v31 = "nw_nat64_getaddrinfo_callback_async";
    v32 = 1024;
    *(_DWORD *)v33 = a2;
    *(_WORD *)&v33[4] = 1024;
    *(_DWORD *)&v33[6] = a3;
    v34 = 2082;
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a4);
    v36 = 1024;
    v37 = a4;
    v38 = 2082;
    v39 = a5;
    v40 = 2082;
    description = nw_endpoint_get_description(address);
    v42 = 1024;
    v43 = a7;
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%d", buf, 0x42u);
  }

LABEL_7:
  if (!a4 && (a2 & 2) != 0 && a6 && a6->sa_family == 30)
  {
    v21 = a8[4];
    v22 = v21 + 1;
    a8[4] = v21 + 1;
    if ((_DWORD)v21 == -1)
    {
      __nwlog_obj();
      v25 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      v31 = "_strict_reallocf";
      v26 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v26))
        goto LABEL_25;
      free(v26);
    }
    v23 = 28 * v22;
    v24 = (sockaddr *)reallocf(*(void **)a8, v23);
    if (v24)
    {
LABEL_20:
      *(_QWORD *)a8 = v24;
      v24[a8[4] - 1] = *(sockaddr *)&a6->sa_data[6];
      goto LABEL_8;
    }
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v31 = "_strict_reallocf";
    v32 = 2048;
    *(_QWORD *)v33 = v23;
    v28 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v28))
    {
      free(v28);
      goto LABEL_20;
    }
LABEL_25:
    __break(1u);
    return;
  }
LABEL_8:
  if ((a2 & 1) == 0)
  {
    if (a1)
      DNSServiceRefDeallocate(a1);
    (*(void (**)(_QWORD, _QWORD))(*((_QWORD *)a8 + 1) + 16))(*((_QWORD *)a8 + 1), a8[4]);
    v19 = (void *)*((_QWORD *)a8 + 1);
    *((_QWORD *)a8 + 1) = 0;

    v20 = (void *)*((_QWORD *)a8 + 1);
    *((_QWORD *)a8 + 1) = 0;

    if (*(_QWORD *)a8)
      free(*(void **)a8);
    free(a8);
  }
}

void sub_1838D04C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_nat64_synthesize(unsigned int *a1, __int16 *a2, void **a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  int v13;
  NSObject *v14;
  const char *v15;
  uint32_t v16;
  int v17;
  uint64_t result;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  const char *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  char *backtrace_string;
  _BOOL4 v28;
  const char *v29;
  _BOOL4 v30;
  _QWORD __dst[2];
  void *v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  _BYTE v36[10];
  _BYTE v37[10];
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0)
    return 0;
  if ((sNWDispatchAllowedNow & 1) == 0)
  {
    if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
      || (getpid(), sandbox_check() == 1))
    {
      sNWDispatchAllowedNow = 1;
    }
    else if (sNWDispatchAllowedNow != 1)
    {
      return 0;
    }
  }
  if (!a2)
  {
    __nwlog_obj();
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_nat64_synthesize";
    v20 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst[0]) = 16;
    LOBYTE(v32) = 0;
    if (__nwlog_fault(v20, __dst, &v32))
    {
      if (LOBYTE(__dst[0]) == 17)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = __dst[0];
        if (os_log_type_enabled(v21, __dst[0]))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v23 = "%{public}s called with null ipv4";
LABEL_59:
          _os_log_impl(&dword_182FBE000, v21, v22, v23, buf, 0xCu);
        }
LABEL_60:

        goto LABEL_61;
      }
      if (!(_BYTE)v32)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = __dst[0];
        if (os_log_type_enabled(v21, __dst[0]))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v23 = "%{public}s called with null ipv4, backtrace limit exceeded";
          goto LABEL_59;
        }
        goto LABEL_60;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = __dst[0];
      v28 = os_log_type_enabled(v21, __dst[0]);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v23 = "%{public}s called with null ipv4, no backtrace";
          goto LABEL_59;
        }
        goto LABEL_60;
      }
      if (!v28)
        goto LABEL_50;
      *(_DWORD *)buf = 136446466;
      v34 = "nw_nat64_synthesize";
      v35 = 2082;
      *(_QWORD *)v36 = backtrace_string;
      v29 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_49;
    }
LABEL_61:
    if (v20)
      free(v20);
    return 0xFFFFFFFFLL;
  }
  if (!a3)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_nat64_synthesize";
    v20 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst[0]) = 16;
    LOBYTE(v32) = 0;
    if (__nwlog_fault(v20, __dst, &v32))
    {
      if (LOBYTE(__dst[0]) == 17)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = __dst[0];
        if (os_log_type_enabled(v21, __dst[0]))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v23 = "%{public}s called with null out_ipv6_addrs";
          goto LABEL_59;
        }
        goto LABEL_60;
      }
      if (!(_BYTE)v32)
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v22 = __dst[0];
        if (os_log_type_enabled(v21, __dst[0]))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v23 = "%{public}s called with null out_ipv6_addrs, backtrace limit exceeded";
          goto LABEL_59;
        }
        goto LABEL_60;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = __dst[0];
      v30 = os_log_type_enabled(v21, __dst[0]);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_nat64_synthesize";
          v23 = "%{public}s called with null out_ipv6_addrs, no backtrace";
          goto LABEL_59;
        }
        goto LABEL_60;
      }
      if (!v30)
        goto LABEL_50;
      *(_DWORD *)buf = 136446466;
      v34 = "nw_nat64_synthesize";
      v35 = 2082;
      *(_QWORD *)v36 = backtrace_string;
      v29 = "%{public}s called with null out_ipv6_addrs, dumping backtrace:%{public}s";
LABEL_49:
      _os_log_impl(&dword_182FBE000, v21, v22, v29, buf, 0x16u);
LABEL_50:

      free(backtrace_string);
      goto LABEL_61;
    }
    goto LABEL_61;
  }
  v32 = 0;
  v6 = nw_nat64_copy_prefixes(a1, &v32);
  v7 = v6;
  if ((int)v6 < 1)
    return v7;
  v8 = v6;
  v9 = malloc_type_calloc(v6, 0x10uLL, 0xEAFB8F1AuLL);
  if (!v9)
  {
    __nwlog_obj();
    v25 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v34 = "strict_calloc";
    v35 = 2048;
    *(_QWORD *)v36 = v8;
    *(_WORD *)&v36[8] = 2048;
    *(_QWORD *)v37 = 16;
    v26 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v26);
    if ((_DWORD)result)
    {
      __break(1u);
      return result;
    }
    free(v26);
  }
  v10 = 0;
  v7 = 0;
  *a3 = v9;
  do
  {
    if (nw_nat64_synthesize_v6((char *)v32 + v10, a2, (char *)*a3 + 16 * (int)v7))
    {
      v7 = (v7 + 1);
      goto LABEL_15;
    }
    if (*(_DWORD *)((char *)v32 + v10) > 0xCu)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v17 = *(_DWORD *)a2;
        *(_DWORD *)buf = 136446466;
        v34 = "nw_nat64_synthesize";
        v35 = 1024;
        *(_DWORD *)v36 = v17;
        v14 = v11;
        v15 = "%{public}s nw_nat64_synthesize_v6 for %{network:in_addr}d";
        v16 = 18;
        goto LABEL_22;
      }
    }
    else
    {
      __dst[0] = 0;
      __dst[1] = 0;
      memcpy(__dst, (char *)v32 + v10 + 4, *(unsigned int *)((char *)v32 + v10));
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v11 = (id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v12 = *(_DWORD *)a2;
        v13 = 8 * *(_DWORD *)((char *)v32 + v10);
        *(_DWORD *)buf = 136447234;
        v34 = "nw_nat64_synthesize";
        v35 = 1024;
        *(_DWORD *)v36 = v12;
        *(_WORD *)&v36[4] = 1040;
        *(_DWORD *)&v36[6] = 16;
        *(_WORD *)v37 = 2096;
        *(_QWORD *)&v37[2] = __dst;
        v38 = 1024;
        v39 = v13;
        v14 = v11;
        v15 = "%{public}s nw_nat64_synthesize_v6 for %{network:in_addr}d from %{network:in6_addr}.16P/%d";
        v16 = 40;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, v15, buf, v16);
      }
    }

LABEL_15:
    v10 += 16;
    --v8;
  }
  while (v8);
  if (v32)
  {
    free(v32);
    v32 = 0;
  }
  if (!(_DWORD)v7)
  {
    if (*a3)
    {
      free(*a3);
      v7 = 0;
      *a3 = 0;
      return v7;
    }
    return 0;
  }
  return v7;
}

uint64_t nw_nat64_copy_prefixes_async(unsigned int *a1, void *a2, void *a3)
{
  NSObject *v5;
  id v6;
  _BOOL4 v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  NSObject *v16;
  unsigned int v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  _QWORD block[4];
  id v26;
  _BOOL4 v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  nw_allow_use_of_dispatch_internal();
  if (v5)
  {
    if (v6)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          if (a1)
            v17 = *a1;
          else
            v17 = 0;
          *(_DWORD *)buf = 136446466;
          v31 = "nw_nat64_copy_prefixes_async";
          v32 = 1024;
          LODWORD(v33) = v17;
          _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s Start nw_nat64_copy_prefixes_async(%u)", buf, 0x12u);
        }

      }
      v7 = nw_nat64_copy_prefixes_internal(a1, 0, v5, 0, 0, v6);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __nw_nat64_copy_prefixes_async_block_invoke;
      block[3] = &unk_1E14AC408;
      v27 = v7;
      v26 = v6;
      dispatch_async(v5, block);

      v8 = 1;
      goto LABEL_5;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_nat64_copy_prefixes_async";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null block", buf, 0xCu);
        }
LABEL_43:

        goto LABEL_44;
      }
      if (!v28)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_182FBE000, v12, v24, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null block, no backtrace", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_nat64_copy_prefixes_async";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_28;
    }
  }
  else
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_nat64_copy_prefixes_async";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null queue", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (!v28)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_182FBE000, v12, v23, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        v31 = "nw_nat64_copy_prefixes_async";
        v32 = 2082;
        v33 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_28:

      free(backtrace_string);
    }
  }
LABEL_44:
  if (v11)
    free(v11);
  v8 = 0;
LABEL_5:

  return v8;
}

void sub_1838D11BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_nat64_copy_prefixes_async_block_invoke(uint64_t a1)
{
  NSObject *v3;
  int v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    __nwlog_obj();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v4 = *(_DWORD *)(a1 + 40);
      v5 = 136446466;
      v6 = "nw_nat64_copy_prefixes_async_block_invoke";
      v7 = 1024;
      v8 = v4;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s nw_nat64_copy_prefixes_async returning %d", (uint8_t *)&v5, 0x12u);
    }

  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t nw_nat64_copy_prefixes_async_override_dns(unsigned int *a1, void *a2, DNSServiceRef *a3, _DWORD *a4, void *a5)
{
  NSObject *v9;
  id v10;
  _BOOL4 v11;
  uint64_t v12;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  NSObject *v20;
  unsigned int v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  os_log_type_t v28;
  _QWORD block[4];
  id v30;
  _BOOL4 v31;
  char v32;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v9 = a2;
  v10 = a5;
  nw_allow_use_of_dispatch_internal();
  if (v9)
  {
    if (v10)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          if (a1)
            v21 = *a1;
          else
            v21 = 0;
          *(_DWORD *)buf = 136446466;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          v36 = 1024;
          LODWORD(v37) = v21;
          _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Start nw_nat64_copy_prefixes_async_override_dns(%u)", buf, 0x12u);
        }

      }
      v11 = nw_nat64_copy_prefixes_internal(a1, 0, v9, a3, a4, v10);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = __nw_nat64_copy_prefixes_async_override_dns_block_invoke;
      block[3] = &unk_1E14AC408;
      v30 = v10;
      v31 = v11;
      dispatch_async(v9, block);

      v12 = 1;
      goto LABEL_5;
    }
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_nat64_copy_prefixes_async_override_dns";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v15, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null block", buf, 0xCu);
        }
LABEL_43:

        goto LABEL_44;
      }
      if (!v32)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_182FBE000, v16, v28, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      v26 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s called with null block, no backtrace", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_nat64_copy_prefixes_async_override_dns";
        v36 = 2082;
        v37 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v16, v25, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_28;
    }
  }
  else
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "nw_nat64_copy_prefixes_async_override_dns";
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v32 = 0;
    if (__nwlog_fault(v15, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null queue", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (!v32)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      v24 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v35 = "nw_nat64_copy_prefixes_async_override_dns";
        v36 = 2082;
        v37 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v16, v23, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_28:

      free(backtrace_string);
    }
  }
LABEL_44:
  if (v15)
    free(v15);
  v12 = 0;
LABEL_5:

  return v12;
}

void sub_1838D1868(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_nat64_copy_prefixes_async_override_dns_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 40), 0);
}

uint64_t nw_nat64_does_interface_index_support_nat64(unsigned int a1)
{
  unsigned int v2;

  v2 = a1;
  return (3u >> ((nw_nat64_get_interface_state_internal(&v2, 0) - 1) & 0xF)) & 1;
}

NWConcrete_nw_nat64_prefixes_resolver *nw_nat64_prefixes_resolver_create(void *a1)
{
  id v2;
  NWConcrete_nw_nat64_prefixes_resolver *v3;
  id v4;
  id *v5;
  id *v6;
  id v7;
  nw_parameters_t v8;
  id v9;
  id v10;
  id v11;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  nw_interface_t v16;
  nw_interface_t v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  void *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  char v31;
  os_log_type_t type;
  objc_super v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v2 = a1;
  v3 = [NWConcrete_nw_nat64_prefixes_resolver alloc];
  v4 = v2;
  if (!v3)
    goto LABEL_31;
  v33.receiver = v3;
  v33.super_class = (Class)NWConcrete_nw_nat64_prefixes_resolver;
  v5 = (id *)objc_msgSendSuper2(&v33, sel_init);
  v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
    v24 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if ((__nwlog_fault(v24, &type, &v31) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
            v36 = 2082;
            v37 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_182FBE000, v25, v28, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_182FBE000, v25, v30, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_48:
    if (v24)
      free(v24);
    goto LABEL_30;
  }
  *((_DWORD *)v5 + 3) = 0;
  objc_storeStrong(v5 + 2, a1);
  v6[6] = 0;
  *((_DWORD *)v6 + 26) = 0;
  v7 = v6[12];
  v6[11] = 0;
  v6[12] = 0;

  if (v4)
    v8 = (nw_parameters_t)v4;
  else
    v8 = nw_parameters_create();
  v9 = v6[2];
  v6[2] = v8;

  v10 = nw_parameters_copy_context(v6[2]);
  v11 = v6[3];
  v6[3] = v10;

  if (nw_context_is_inline(v6[3]))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v13, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts", buf, 0xCu);
        }
      }
      else if (v31)
      {
        v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v19 = type;
        v20 = os_log_type_enabled(v14, type);
        if (v18)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
            v36 = 2082;
            v37 = v18;
            _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v18);
          if (!v13)
            goto LABEL_29;
          goto LABEL_28;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s Cannot use nw_nat64_prefixes_resolver on inline contexts, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v13)
    {
LABEL_29:

LABEL_30:
      v3 = 0;
      goto LABEL_31;
    }
LABEL_28:
    free(v13);
    goto LABEL_29;
  }
  v16 = nw_parameters_copy_required_interface((nw_parameters_t)v6[2]);
  v17 = v16;
  if (v16)
    *((_DWORD *)v6 + 3) = v16[1].isa;
  v3 = v6;

LABEL_31:
  return v3;
}

void sub_1838D1EB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_set_queue(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 2);
    objc_storeStrong((id *)v3 + 10, a2);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_nat64_prefixes_resolver_set_queue";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_nat64_prefixes_resolver_set_queue";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_nat64_prefixes_resolver_set_update_handler(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_nat64_prefixes_resolver_set_update_handler";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v12, &type, &v25))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_nat64_prefixes_resolver_set_update_handler";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v12)
          goto LABEL_6;
LABEL_41:
        free(v12);
        goto LABEL_6;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (v7)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v5 + 2);
    v9 = _Block_copy(v8);
    v10 = (void *)*((_QWORD *)v5 + 8);
    *((_QWORD *)v5 + 8) = v9;

    if (v6)
      objc_storeStrong((id *)v5 + 10, a2);
    os_unfair_lock_unlock((os_unfair_lock_t)v5 + 2);
    goto LABEL_6;
  }
  __nwlog_obj();
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_nat64_prefixes_resolver_set_update_handler";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (!__nwlog_fault(v12, &type, &v25))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_nat64_prefixes_resolver_set_update_handler";
      _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null update_handler", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v25)
  {
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v24 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_nat64_prefixes_resolver_set_update_handler";
      _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null update_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v20 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v13 = objc_claimAutoreleasedReturnValue();
  v21 = type;
  v22 = os_log_type_enabled(v13, type);
  if (!v20)
  {
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      v28 = "nw_nat64_prefixes_resolver_set_update_handler";
      _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v22)
  {
    *(_DWORD *)buf = 136446466;
    v28 = "nw_nat64_prefixes_resolver_set_update_handler";
    v29 = 2082;
    v30 = v20;
    _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null update_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v20);
  if (v12)
    goto LABEL_41;
LABEL_6:

}

void nw_nat64_prefixes_resolver_set_cancel_handler(void *a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    os_unfair_lock_lock(v3 + 2);
    v5 = _Block_copy(v4);
    v6 = *(void **)&v3[18]._os_unfair_lock_opaque;
    *(_QWORD *)&v3[18]._os_unfair_lock_opaque = v5;

    os_unfair_lock_unlock(v3 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

}

void nw_nat64_prefixes_resolver_start(void *a1)
{
  id v1;
  NSObject *v2;
  NSObject *v3;
  unsigned int required_interface_index;
  unsigned int v5;
  NWConcrete_nw_interface *v6;
  id v7;
  const char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *v11;
  os_log_type_t v12;
  _BOOL4 v13;
  NWConcrete_nw_path_evaluator *evaluator_for_endpoint;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  os_unfair_lock_s *v20;
  NSObject *v21;
  os_log_type_t v22;
  void *v23;
  const char *v24;
  NSObject *v25;
  os_log_type_t v26;
  char *v27;
  char *backtrace_string;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  char *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  os_log_type_t v39;
  _QWORD v40[4];
  id v41;
  char v42;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v45;
  __int16 v46;
  _WORD v47[17];

  *(_QWORD *)&v47[13] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  nw_allow_use_of_dispatch_internal();
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v1 + 2);
    if (!*((_QWORD *)v1 + 8))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = (id)gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s The nat64 prefixes resolver's handler is not set. You must set this resolver's handler using nw_nat64_prefixes_resolver_set_update_handler() in order to successfully start it.", buf, 0xCu);
      }
      goto LABEL_13;
    }
    if (!*((_QWORD *)v1 + 10))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = (id)gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s The nat64 prefixes resolver's client_queue is not set. You must set this resolver's client_queue using nw_nat64_prefixes_resolver_set_update_handler() in order to successfully start it.", buf, 0xCu);
      }
      goto LABEL_13;
    }
    if (*((_QWORD *)v1 + 6))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = (id)gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s The nat64 prefixes resolver has already been started.", buf, 0xCu);
      }
LABEL_13:

      goto LABEL_52;
    }
    v3 = nw_parameters_create();
    if (v3)
    {
      required_interface_index = nw_parameters_get_required_interface_index(*((void **)v1 + 2));
      v5 = required_interface_index;
      if (required_interface_index)
      {
        v6 = nw_interface_create_with_index(required_interface_index);
        if (!v6)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v21 = (id)gLogObj;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v45 = "nw_nat64_prefixes_resolver_start";
            v46 = 1024;
            *(_DWORD *)v47 = v5;
            _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s nw_interface_create_with_index failed for index %u", buf, 0x12u);
          }

          goto LABEL_51;
        }
        nw_parameters_require_interface(v3, &v6->super);

      }
      if (nw_parameters_get_required_address_family(*((void **)v1 + 2)))
      {
        nw_nat64_prefixes_resolver_start_dns_query_locked((NWConcrete_nw_nat64_prefixes_resolver *)v1);
LABEL_33:
        os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
LABEL_51:

        goto LABEL_52;
      }
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, v3);
      v15 = (void *)*((_QWORD *)v1 + 12);
      *((_QWORD *)v1 + 12) = evaluator_for_endpoint;

      v16 = (void *)*((_QWORD *)v1 + 12);
      if (v16)
      {
        nw_path_evaluator_set_logging(v16);
        v17 = (void *)*((_QWORD *)v1 + 12);
        v18 = (void *)*((_QWORD *)v1 + 10);
        v40[0] = MEMORY[0x1E0C809B0];
        v40[1] = 3221225472;
        v40[2] = __nw_nat64_prefixes_resolver_start_block_invoke;
        v40[3] = &unk_1E14AC2C8;
        v19 = v1;
        v41 = v19;
        nw_path_evaluator_set_update_handler(v17, v18, v40);
        v20 = nw_path_evaluator_copy_path(*((os_unfair_lock_s **)v1 + 12));
        nw_nat64_prefixes_resolver_path_update_callback_locked(v19, v20);

        goto LABEL_33;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
      __nwlog_obj();
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v45 = "nw_nat64_prefixes_resolver_start";
      v46 = 1024;
      *(_DWORD *)v47 = v5;
      v24 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v42 = 0;
      if (!__nwlog_fault(v24, &type, &v42))
        goto LABEL_64;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 1024;
          *(_DWORD *)v47 = v5;
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed", buf, 0x12u);
        }
      }
      else if (v42)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        v30 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446722;
            v45 = "nw_nat64_prefixes_resolver_start";
            v46 = 1024;
            *(_DWORD *)v47 = v5;
            v47[2] = 2082;
            *(_QWORD *)&v47[3] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v25, v29, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_64;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 1024;
          *(_DWORD *)v47 = v5;
          _os_log_impl(&dword_182FBE000, v25, v29, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 1024;
          *(_DWORD *)v47 = v5;
          _os_log_impl(&dword_182FBE000, v25, v31, "%{public}s nw_path_create_evaluator_for_endpoint, ifindex=%u failed, backtrace limit exceeded", buf, 0x12u);
        }
      }

LABEL_64:
      if (!v24)
        goto LABEL_51;
      v27 = (char *)v24;
      goto LABEL_50;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v45 = "nw_nat64_prefixes_resolver_start";
    v8 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v8, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_nat64_prefixes_resolver_start";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s nw_parameters_create failed", buf, 0xCu);
        }
      }
      else if (v42)
      {
        v11 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v9, type);
        if (v11)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v45 = "nw_nat64_prefixes_resolver_start";
            v46 = 2082;
            *(_QWORD *)v47 = v11;
            _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v11);
          if (!v8)
            goto LABEL_51;
LABEL_49:
          v27 = (char *)v8;
LABEL_50:
          free(v27);
          goto LABEL_51;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_nat64_prefixes_resolver_start";
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v45 = "nw_nat64_prefixes_resolver_start";
          _os_log_impl(&dword_182FBE000, v9, v22, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v8)
      goto LABEL_51;
    goto LABEL_49;
  }
  __nwlog_obj();
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v45 = "nw_nat64_prefixes_resolver_start";
  v33 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v42 = 0;
  if (__nwlog_fault(v33, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v42)
    {
      v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      v38 = os_log_type_enabled(v34, type);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          v45 = "nw_nat64_prefixes_resolver_start";
          v46 = 2082;
          *(_QWORD *)v47 = v36;
          _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v36);
        goto LABEL_82;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_182FBE000, v34, v37, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)buf = 136446210;
        v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_82:
  if (v33)
    free(v33);
LABEL_52:

}

void sub_1838D3384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void __nw_nat64_prefixes_resolver_start_block_invoke(uint64_t a1, void *a2)
{
  os_unfair_lock_s *v3;
  id v4;

  v3 = (os_unfair_lock_s *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = a2;
  os_unfair_lock_lock(v3);
  nw_nat64_prefixes_resolver_path_update_callback_locked(*(void **)(a1 + 32), v4);

  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
}

void sub_1838D3430(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_path_update_callback_locked(void *a1, void *a2)
{
  NWConcrete_nw_nat64_prefixes_resolver *v3;
  id v4;
  void *v5;
  _BYTE *v6;
  char v7;
  char *v8;
  int v9;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v14, &type, &v27))
      goto LABEL_49;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v14)
          goto LABEL_11;
LABEL_50:
        free(v14);
        goto LABEL_11;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_182FBE000, v15, v25, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_48:

    goto LABEL_49;
  }
  if (v4)
  {
    v6 = v4;
    v7 = v6[473];

    if ((v7 & 0x40) == 0 && (v8 = v6, v9 = (char)v6[473], v8, v9 < 0))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        v31 = 2114;
        v32 = v8;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s enabling NAT64 prefix detection for path=%{public}@", buf, 0x16u);
      }

      if (!*((_QWORD *)v3 + 6))
        nw_nat64_prefixes_resolver_start_dns_query_locked(v3);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        v31 = 2114;
        v32 = v6;
        _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s disabling NAT64 prefix detection for path=%{public}@", buf, 0x16u);
      }

      if (*((_QWORD *)v3 + 6))
        nw_nat64_prefixes_resolver_cancel_dns_query_locked(v3);
      *((_DWORD *)v3 + 26) = 0;
      v11 = (void *)*((_QWORD *)v3 + 11);
      if (v11)
      {
        free(v11);
        *((_QWORD *)v3 + 11) = 0;
      }
    }
    goto LABEL_11;
  }
  __nwlog_obj();
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
  v14 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v14, &type, &v27))
    goto LABEL_49;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null path", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (!v27)
  {
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    v26 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_182FBE000, v15, v26, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_48;
  }
  v22 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v15 = objc_claimAutoreleasedReturnValue();
  v23 = type;
  v24 = os_log_type_enabled(v15, type);
  if (!v22)
  {
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
      _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null path, no backtrace", buf, 0xCu);
    }
    goto LABEL_48;
  }
  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
    v31 = 2082;
    v32 = v22;
    _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v22);
  if (v14)
    goto LABEL_50;
LABEL_11:

}

void sub_1838D3A48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_start_dns_query_locked(NWConcrete_nw_nat64_prefixes_resolver *a1)
{
  NWConcrete_nw_nat64_prefixes_resolver *v1;
  void *v2;
  NWConcrete_nw_nat64_prefixes_resolver *v3;
  _QWORD v4[4];
  NWConcrete_nw_nat64_prefixes_resolver *v5;

  v1 = a1;
  v2 = (void *)*((_QWORD *)v1 + 3);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke;
  v4[3] = &unk_1E14ACFD0;
  v3 = v1;
  v5 = v3;
  nw_queue_context_async(v2, v4);

}

void sub_1838D3ADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke(uint64_t a1)
{
  uint64_t v2;
  DNSServiceRef *v3;
  uint32_t required_interface_index;
  DNSServiceErrorType AddrInfo;
  DNSServiceErrorType v6;
  uint64_t v7;
  DNSServiceRef *v8;
  uint32_t v9;
  DNSServiceErrorType v10;
  uint64_t v11;
  _DNSServiceRef_t *v12;
  _BOOL8 v13;
  NSObject *v14;
  _QWORD *v15;
  _DNSServiceRef_t *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD block[4];
  _QWORD *v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  const char *string_for_dns_service_error;
  __int16 v32;
  DNSServiceErrorType v33;
  _QWORD v34[4];
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  v35 = xmmword_183C6E180;
  v36 = unk_183C6E190;
  strcpy((char *)v34, "DNSServiceGetAddrInfo");
  HIWORD(v34[2]) = 0;
  v34[3] = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) = 0;
  v2 = *(_QWORD *)(a1 + 32);
  v3 = (DNSServiceRef *)(v2 + 48);
  required_interface_index = nw_parameters_get_required_interface_index(*(void **)(v2 + 16));
  AddrInfo = DNSServiceGetAddrInfo(v3, 0x9000u, required_interface_index, 2u, "ipv4only.arpa", (DNSServiceGetAddrInfoReply)nw_nat64_prefixes_resolver_dns_callback, *(void **)(a1 + 32));
  if (AddrInfo == -65569)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) = 0;
    v7 = *(_QWORD *)(a1 + 32);
    v8 = (DNSServiceRef *)(v7 + 48);
    v9 = nw_parameters_get_required_interface_index(*(void **)(v7 + 16));
    v10 = DNSServiceGetAddrInfo(v8, 0x9000u, v9, 2u, "ipv4only.arpa", (DNSServiceGetAddrInfoReply)nw_nat64_prefixes_resolver_dns_callback, *(void **)(a1 + 32));
    v6 = v10;
    if (v10 == -65569)
      goto LABEL_8;
    if (v10)
      goto LABEL_3;
  }
  else
  {
    v6 = AddrInfo;
    if (AddrInfo)
    {
LABEL_3:
      if (!v6)
        goto LABEL_15;
      goto LABEL_8;
    }
  }
  strcpy((char *)v34, "DNSServiceSetDispatchQueue");
  v11 = *(_QWORD *)(a1 + 32);
  v12 = *(_DNSServiceRef_t **)(v11 + 48);
  v13 = nw_context_copy_workloop(*(void **)(v11 + 24));
  v6 = DNSServiceSetDispatchQueue(v12, (dispatch_queue_t)v13);

  if (!v6)
  {
LABEL_15:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_nat64_prefixes_resolver_start_dns_query_locked_block_invoke";
      v26 = 2082;
      v27 = "ipv4only.arpa";
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s started DNS query for %{public}s successfully", buf, 0x16u);
    }

    v20 = *(_QWORD **)(a1 + 32);
    v21 = v20;
    v18 = (void *)v20[4];
    v20[4] = v21;
    goto LABEL_18;
  }
LABEL_8:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v14 = (id)gLogObj;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136447234;
    v25 = "nw_nat64_prefixes_resolver_start_dns_query_locked_block_invoke";
    v26 = 2080;
    v27 = (const char *)v34;
    v28 = 2082;
    v29 = "ipv4only.arpa";
    v30 = 2082;
    string_for_dns_service_error = nwlog_get_string_for_dns_service_error(v6);
    v32 = 1024;
    v33 = v6;
    _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s %s for %{public}s failed with error=%{public}s(%d)", buf, 0x30u);
  }

  v15 = *(_QWORD **)(a1 + 32);
  v16 = (_DNSServiceRef_t *)v15[6];
  if (v16)
  {
    DNSServiceRefDeallocate(v16);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) = 0;
    v15 = *(_QWORD **)(a1 + 32);
  }
  v17 = v15[10];
  if (v17)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke_89;
    block[3] = &unk_1E14ACFD0;
    v23 = v15;
    dispatch_async(v17, block);

    v15 = *(_QWORD **)(a1 + 32);
  }
  v18 = (void *)v15[4];
  v15[4] = 0;
LABEL_18:

  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
}

void sub_1838D3E30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_dns_callback(_DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, void *a8)
{
  NSObject *v15;
  int v16;
  nw_endpoint_t address;
  NSObject *v18;
  int *v19;
  int v20;
  int v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  sockaddr *v26;
  NSObject *v27;
  void *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  NSObject *v36;
  void *v37;
  NSObject *v38;
  void *v39;
  _QWORD block[4];
  int *v41;
  _BYTE *v42;
  int v43;
  char v44;
  os_log_type_t type;
  _BYTE buf[24];
  _BYTE v47[10];
  __int16 v48;
  int v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  const char *description;
  __int16 v54;
  int v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v15 = (id)gLogObj;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {

  }
  else
  {
    v16 = gLogFDOverride;

    if (v16 == -1)
      goto LABEL_7;
  }
  address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v18 = (id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136448002;
    *(_QWORD *)&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    *(_WORD *)v47 = 2082;
    *(_QWORD *)&v47[2] = nwlog_get_string_for_dns_service_error(a4);
    v48 = 1024;
    v49 = a4;
    v50 = 2082;
    v51 = a5;
    v52 = 2082;
    description = nw_endpoint_get_description(address);
    v54 = 1024;
    v55 = a7;
    _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%d", buf, 0x42u);
  }

LABEL_7:
  if (a8)
  {
    v19 = a8;
    os_unfair_lock_lock((os_unfair_lock_t)v19 + 2);
    if (!*((_QWORD *)v19 + 8))
    {
LABEL_22:
      os_unfair_lock_unlock((os_unfair_lock_t)v19 + 2);

      return;
    }
    if (a4 || (a2 & 2) == 0 || !a6 || a6->sa_family != 30)
    {
LABEL_10:
      if ((a2 & 1) == 0)
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        *(_QWORD *)v47 = 0;
        v20 = v19[26];
        if (v20 < 1)
        {
          v21 = 0;
        }
        else
        {
          v21 = nw_nat64_copy_prefixes_from_ipv4only_records(*((_QWORD *)v19 + 11), v20, v47);
          v19[26] = 0;
          v22 = (void *)*((_QWORD *)v19 + 11);
          if (v22)
          {
            free(v22);
            *((_QWORD *)v19 + 11) = 0;
          }
        }
        v27 = *((_QWORD *)v19 + 10);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___ZL39nw_nat64_prefixes_resolver_dns_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke;
        block[3] = &unk_1E14AB500;
        v43 = v21;
        v41 = v19;
        v42 = buf;
        dispatch_async(v27, block);

        _Block_object_dispose(buf, 8);
      }
      goto LABEL_22;
    }
    v23 = v19[26];
    v24 = v23 + 1;
    v19[26] = v23 + 1;
    if ((_DWORD)v23 == -1)
    {
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "_strict_reallocf";
      v37 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v37))
        goto LABEL_46;
      free(v37);
    }
    v25 = 28 * v24;
    v26 = (sockaddr *)reallocf(*((void **)v19 + 11), 28 * v24);
    if (v26)
    {
LABEL_19:
      *((_QWORD *)v19 + 11) = v26;
      v26[v19[26] - 1] = *(sockaddr *)&a6->sa_data[6];
      goto LABEL_10;
    }
    __nwlog_obj();
    v38 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "_strict_reallocf";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v25;
    v39 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v39))
    {
      free(v39);
      goto LABEL_19;
    }
LABEL_46:
    __break(1u);
    return;
  }
  __nwlog_obj();
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
  v29 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v44 = 0;
  if (__nwlog_fault(v29, &type, &v44))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      v34 = os_log_type_enabled(v30, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v30, v33, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_40;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
        _os_log_impl(&dword_182FBE000, v30, v33, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v35 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
        _os_log_impl(&dword_182FBE000, v30, v35, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_40:
  if (v29)
    free(v29);
}

void sub_1838D4464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke_89(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  id v4;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(const void **)(v2 + 64);
  if (v3)
  {
    v4 = _Block_copy(v3);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
    (*((void (**)(id, _QWORD, _QWORD))v4 + 2))(v4, 0, 0);

  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
  }
}

void sub_1838D4518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZL39nw_nat64_prefixes_resolver_dns_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  void (**v4)(void *, uint64_t, _QWORD);
  uint64_t v5;
  void *v6;
  _QWORD v7[3];

  v7[2] = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(const void **)(v2 + 64);
  if (v3)
  {
    v4 = (void (**)(void *, uint64_t, _QWORD))_Block_copy(v3);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
    v5 = *(unsigned int *)(a1 + 48);
    if ((_DWORD)v5)
    {
      v4[2](v4, v5, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    }
    else
    {
      v7[0] = 0;
      v7[1] = 0;
      ((void (**)(void *, uint64_t, _QWORD *))v4)[2](v4, v5, v7);
    }

  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
  }
  v6 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_1838D4610(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_cancel_dns_query_locked(NWConcrete_nw_nat64_prefixes_resolver *a1)
{
  NWConcrete_nw_nat64_prefixes_resolver *v1;
  NWConcrete_nw_nat64_prefixes_resolver *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  NWConcrete_nw_nat64_prefixes_resolver *v14;
  uint64_t v15;
  char v16;
  os_log_type_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  v3 = *((_QWORD *)v1 + 6);
  if (!v3)
    goto LABEL_4;
  if (*((_QWORD *)v1 + 4))
  {
    *((_QWORD *)v1 + 6) = 0;
    v4 = (void *)*((_QWORD *)v1 + 3);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = ___ZL50nw_nat64_prefixes_resolver_cancel_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke;
    v13[3] = &unk_1E14AA348;
    v15 = v3;
    v14 = v1;
    nw_queue_context_async_if_needed(v4, v13);

    goto LABEL_4;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
  v6 = (char *)_os_log_send_and_compose_impl();

  v17 = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null resolver->internally_retained_object", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = v17;
      v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null resolver->internally_retained_object, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null resolver->internally_retained_object, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null resolver->internally_retained_object, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v6)
    free(v6);
LABEL_4:

}

void sub_1838D491C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

void ___ZL50nw_nat64_prefixes_resolver_cancel_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;

  DNSServiceRefDeallocate(*(DNSServiceRef *)(a1 + 40));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void **)(v2 + 32);
  *(_QWORD *)(v2 + 32) = 0;

}

void nw_nat64_prefixes_resolver_cancel(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  const void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    nw_nat64_prefixes_resolver_cancel_dns_query_locked((NWConcrete_nw_nat64_prefixes_resolver *)v2);
    v3 = *(void **)&v2[16]._os_unfair_lock_opaque;
    *(_QWORD *)&v2[16]._os_unfair_lock_opaque = 0;

    v4 = *(void **)&v2[24]._os_unfair_lock_opaque;
    if (v4)
    {
      nw_path_evaluator_cancel(v4);
      v5 = *(void **)&v2[24]._os_unfair_lock_opaque;
      *(_QWORD *)&v2[24]._os_unfair_lock_opaque = 0;

    }
    v6 = *(void **)&v2[22]._os_unfair_lock_opaque;
    if (v6)
    {
      free(v6);
      *(_QWORD *)&v2[22]._os_unfair_lock_opaque = 0;
    }
    v2[26]._os_unfair_lock_opaque = 0;
    v7 = *(const void **)&v2[18]._os_unfair_lock_opaque;
    if (v7)
    {
      v8 = _Block_copy(v7);
      v9 = *(void **)&v2[18]._os_unfair_lock_opaque;
      *(_QWORD *)&v2[18]._os_unfair_lock_opaque = 0;

      dispatch_async(*(dispatch_queue_t *)&v2[20]._os_unfair_lock_opaque, v8);
    }
    v10 = *(void **)&v2[20]._os_unfair_lock_opaque;
    *(_QWORD *)&v2[20]._os_unfair_lock_opaque = 0;

    os_unfair_lock_unlock(v2 + 2);
    goto LABEL_9;
  }
  __nwlog_obj();
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_nat64_prefixes_resolver_cancel";
  v12 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_nat64_prefixes_resolver_cancel";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_182FBE000, v13, v18, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_26:
  if (v12)
    free(v12);
LABEL_9:

}

void sub_1838D4C80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_nat64_prefixes_resolver_copy_interface(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  NWConcrete_nw_interface *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    v3 = nw_interface_create_with_index(v2[3]._os_unfair_lock_opaque);
    os_unfair_lock_unlock(v2 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_nat64_prefixes_resolver_copy_interface";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_nat64_prefixes_resolver_copy_interface";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_nat64_prefixes_resolver_copy_interface";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void sub_1838D4F3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t llhttp_finish(uint64_t a1)
{
  uint64_t result;
  int v2;
  uint64_t v3;
  uint64_t (*v4)(void);

  if (*(_DWORD *)(a1 + 24))
    return 0;
  v2 = *(unsigned __int8 *)(a1 + 81);
  if (!*(_BYTE *)(a1 + 81))
    return 0;
  if (v2 == 2)
  {
    *(_QWORD *)(a1 + 32) = "Invalid EOF state";
    return 14;
  }
  if (v2 != 1)
    abort();
  v3 = *(_QWORD *)(a1 + 88);
  if (!v3)
    return 0;
  v4 = *(uint64_t (**)(void))(v3 + 88);
  if (!v4)
    return 0;
  result = v4();
  if (!(_DWORD)result)
    return 0;
  return result;
}

uint64_t llhttp__on_url(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 8);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_url";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_status(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 16);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_status";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_method(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 24);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_method";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_version(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 32);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_version";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_header_field(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 40);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_header_field";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_header_value(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 48);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_header_value";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_body(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 80);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_body";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_chunk_extension_name(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 56);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
    return 24;
  }
  return result;
}

uint64_t llhttp__on_chunk_extension_value(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1)
    return 0;
  v2 = *(uint64_t (**)(void))(v1 + 64);
  if (!v2)
    return 0;
  result = v2();
  if ((_DWORD)result == -1)
  {
    *(_QWORD *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
    return 24;
  }
  return result;
}

uint64_t copyassocids(int a1, _BOOL8 *a2, _DWORD *a3)
{
  uint64_t result;
  _BOOL8 v7;
  uint64_t v8;
  _BOOL8 v9;

  if (a2 && a3)
  {
    *a2 = 0;
    *a3 = 0;
    v8 = 0;
    v9 = 0;
    if (!ioctl(a1, 0xC0107396uLL, &v8))
    {
      result = v8;
      if (!(_DWORD)v8)
        return result;
      v7 = nw_calloc_type<unsigned int>(v8);
      v9 = v7;
      result = ioctl(a1, 0xC0107396uLL, &v8);
      if (!(_DWORD)result)
      {
        *a2 = v7;
        *a3 = v8;
        return result;
      }
      if (v7)
        free((void *)v7);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  }
  return 0xFFFFFFFFLL;
}

BOOL nw_calloc_type<unsigned int>(size_t a1)
{
  void *v1;
  _BOOL8 result;
  NSObject *v3;
  void *v4;

  v1 = malloc_type_calloc(a1, 4uLL, 0xEAFB8F1AuLL);
  if (v1)
    return (BOOL)v1;
  v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  v4 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }
  __break(1u);
  return result;
}

void freeassocids(void *a1)
{
  if (a1)
    free(a1);
}

uint64_t copyconnids(int a1, int a2, _BOOL8 *a3, unsigned int *a4)
{
  uint64_t result;
  _BOOL8 v8;
  int v9;
  unsigned int v10;
  _BOOL8 v11;

  if (a3 && a4)
  {
    *a3 = 0;
    *a4 = 0;
    v9 = a2;
    v10 = 0;
    v11 = 0;
    if (!ioctl(a1, 0xC0107397uLL, &v9))
    {
      result = v10;
      if (!v10)
        return result;
      v8 = nw_calloc_type<unsigned int>(v10);
      v11 = v8;
      result = ioctl(a1, 0xC0107397uLL, &v9);
      if (!(_DWORD)result)
      {
        *a3 = v8;
        *a4 = v10;
        return result;
      }
      if (v8)
        free((void *)v8);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  }
  return 0xFFFFFFFFLL;
}

void freeconnids(void *a1)
{
  if (a1)
    free(a1);
}

void freeconninfo(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  if (a1)
  {
    v2 = (void *)a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0;
    }
    v3 = (void *)a1[2];
    if (v3)
    {
      free(v3);
      a1[2] = 0;
    }
    v4 = (void *)a1[4];
    if (v4)
      free(v4);
    free(a1);
  }
}

uint64_t copymptcpinfo(int a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v4;
  uint64_t result;
  uint64_t v6;
  _WORD *v7;
  unsigned int v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  int v12;
  int v13;
  NSObject *v14;
  int v15;
  char *v16;
  uint64_t v17;
  os_log_type_t v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  int v27;
  char *v28;
  uint64_t v29;
  os_log_type_t v30;
  NSObject *v31;
  os_log_type_t v32;
  const char *v33;
  uint64_t v34;
  os_log_type_t v35;
  int v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  int v41;
  _QWORD *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  os_log_type_t v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  void *v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  const char *v56;
  _QWORD *v57;
  NSObject *v58;
  void *v59;
  char *backtrace_string;
  _BOOL4 v61;
  NSObject *v62;
  void *v63;
  _QWORD *v64;
  unsigned int v65;
  unint64_t StatusReg;
  char v67;
  os_log_type_t type;
  void *v69;
  os_log_type_t v70[8];
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  _BYTE v74[10];
  __int128 v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v72 = "copymptcpinfo";
    v53 = (char *)_os_log_send_and_compose_impl();
    v70[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v69) = 0;
    if (!__nwlog_fault(v53, v70, &v69))
      goto LABEL_98;
    if (v70[0] == OS_LOG_TYPE_FAULT)
    {
      v54 = __nwlog_obj();
      v55 = v70[0];
      if (!os_log_type_enabled(v54, v70[0]))
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      v72 = "copymptcpinfo";
      v56 = "%{public}s called with null mpinfo";
    }
    else if ((_BYTE)v69)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v54 = __nwlog_obj();
      v55 = v70[0];
      v61 = os_log_type_enabled(v54, v70[0]);
      if (backtrace_string)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136446466;
          v72 = "copymptcpinfo";
          v73 = 2082;
          *(_QWORD *)v74 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s called with null mpinfo, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_98;
      }
      if (!v61)
      {
LABEL_98:
        if (v53)
          free(v53);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)buf = 136446210;
      v72 = "copymptcpinfo";
      v56 = "%{public}s called with null mpinfo, no backtrace";
    }
    else
    {
      v54 = __nwlog_obj();
      v55 = v70[0];
      if (!os_log_type_enabled(v54, v70[0]))
        goto LABEL_98;
      *(_DWORD *)buf = 136446210;
      v72 = "copymptcpinfo";
      v56 = "%{public}s called with null mpinfo, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v54, v55, v56, buf, 0xCu);
    goto LABEL_98;
  }
  v2 = a2;
  *(_QWORD *)v70 = 0;
  v4 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (!v4)
  {
    v57 = v2;
    v58 = __nwlog_obj();
    os_log_type_enabled(v58, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v72 = "strict_calloc";
    v73 = 2048;
    *(_QWORD *)v74 = 1;
    *(_WORD *)&v74[8] = 2048;
    *(_QWORD *)&v75 = 24;
    v59 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v59);
    if ((_DWORD)result)
    {
LABEL_101:
      __break(1u);
      return result;
    }
    free(v59);
    v2 = v57;
  }
  if (copyconninfo(a1, -1, v70))
    goto LABEL_4;
  v6 = *(_QWORD *)v70;
  if (*(_DWORD *)(*(_QWORD *)v70 + 28) == 2)
  {
    *v4 = *(_QWORD *)v70;
    v7 = *(_WORD **)(v6 + 32);
    if (v7[20])
      v8 = (v7[56] != 0) + 1;
    else
      v8 = v7[56] != 0;
    if (v7[92])
      ++v8;
    if (v7[128])
      v9 = v8 + 1;
    else
      v9 = v8;
    if (!(_DWORD)v9)
    {
LABEL_4:
      result = 0;
      *v2 = v4;
      return result;
    }
    v64 = v2;
    v10 = malloc_type_calloc(v9, 8uLL, 0xEAFB8F1AuLL);
    if (v10)
    {
LABEL_16:
      v65 = 0;
      v4[1] = v10;
      v11 = 20;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      while (1)
      {
        v12 = (unsigned __int16)v7[v11];
        if (v7[v11])
        {
          v69 = 0;
          if (copyconninfo(a1, v12, &v69))
          {
            v13 = **(_DWORD **)(StatusReg + 8);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v14 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446978;
              v72 = "copymptcpinfo";
              v73 = 1024;
              *(_DWORD *)v74 = v12;
              *(_WORD *)&v74[4] = 1024;
              *(_DWORD *)&v74[6] = a1;
              LOWORD(v75) = 1024;
              *(_DWORD *)((char *)&v75 + 2) = v13;
              _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s copyconninfo failed for ifindex %u on fd %d %{darwin.errno}d", buf, 0x1Eu);
            }
          }
          else
          {
            if (*((_DWORD *)v69 + 7) != 1)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v15 = *((_DWORD *)v69 + 7);
              *(_DWORD *)buf = 136446978;
              v72 = "copymptcpinfo";
              v73 = 1024;
              *(_DWORD *)v74 = v15;
              *(_WORD *)&v74[4] = 1024;
              *(_DWORD *)&v74[6] = v12;
              LOWORD(v75) = 1024;
              *(_DWORD *)((char *)&v75 + 2) = a1;
              v16 = (char *)_os_log_send_and_compose_impl();
              type = OS_LOG_TYPE_ERROR;
              v67 = 0;
              if (!__nwlog_fault(v16, &type, &v67))
                goto LABEL_48;
              if (type != OS_LOG_TYPE_FAULT)
              {
                if (v67)
                {
                  v23 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v24 = gLogObj;
                  v25 = type;
                  v26 = os_log_type_enabled((os_log_t)gLogObj, type);
                  if (v23)
                  {
                    if (v26)
                    {
                      v27 = *((_DWORD *)v69 + 7);
                      *(_DWORD *)buf = 136447234;
                      v72 = "copymptcpinfo";
                      v73 = 1024;
                      *(_DWORD *)v74 = v27;
                      *(_WORD *)&v74[4] = 1024;
                      *(_DWORD *)&v74[6] = v12;
                      LOWORD(v75) = 1024;
                      *(_DWORD *)((char *)&v75 + 2) = a1;
                      WORD3(v75) = 2082;
                      *((_QWORD *)&v75 + 1) = v23;
                      _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s Unknown conninfo type %u for ifindex %u on fd %d, dumping backtrace:%{public}s", buf, 0x28u);
                    }
                    free(v23);
                    goto LABEL_48;
                  }
                  if (!v26)
                    goto LABEL_48;
                  v41 = *((_DWORD *)v69 + 7);
                  *(_DWORD *)buf = 136446978;
                  v72 = "copymptcpinfo";
                  v73 = 1024;
                  *(_DWORD *)v74 = v41;
                  *(_WORD *)&v74[4] = 1024;
                  *(_DWORD *)&v74[6] = v12;
                  LOWORD(v75) = 1024;
                  *(_DWORD *)((char *)&v75 + 2) = a1;
                  v20 = v24;
                  v21 = v25;
                  v22 = "%{public}s Unknown conninfo type %u for ifindex %u on fd %d, no backtrace";
                }
                else
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v34 = gLogObj;
                  v35 = type;
                  if (!os_log_type_enabled((os_log_t)gLogObj, type))
                    goto LABEL_48;
                  v36 = *((_DWORD *)v69 + 7);
                  *(_DWORD *)buf = 136446978;
                  v72 = "copymptcpinfo";
                  v73 = 1024;
                  *(_DWORD *)v74 = v36;
                  *(_WORD *)&v74[4] = 1024;
                  *(_DWORD *)&v74[6] = v12;
                  LOWORD(v75) = 1024;
                  *(_DWORD *)((char *)&v75 + 2) = a1;
                  v20 = v34;
                  v21 = v35;
                  v22 = "%{public}s Unknown conninfo type %u for ifindex %u on fd %d, backtrace limit exceeded";
                }
LABEL_47:
                _os_log_impl(&dword_182FBE000, v20, v21, v22, buf, 0x1Eu);
                goto LABEL_48;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v17 = gLogObj;
              v18 = type;
              if (os_log_type_enabled((os_log_t)gLogObj, type))
              {
                v19 = *((_DWORD *)v69 + 7);
                *(_DWORD *)buf = 136446978;
                v72 = "copymptcpinfo";
                v73 = 1024;
                *(_DWORD *)v74 = v19;
                *(_WORD *)&v74[4] = 1024;
                *(_DWORD *)&v74[6] = v12;
                LOWORD(v75) = 1024;
                *(_DWORD *)((char *)&v75 + 2) = a1;
                v20 = v17;
                v21 = v18;
                v22 = "%{public}s Unknown conninfo type %u for ifindex %u on fd %d";
                goto LABEL_47;
              }
LABEL_48:
              if (v16)
                free(v16);
              v42 = v69;
              if (!v69)
                goto LABEL_19;
              v43 = (void *)*((_QWORD *)v69 + 1);
              if (v43)
              {
                free(v43);
                v42[1] = 0;
              }
              v44 = (void *)v42[2];
              if (v44)
              {
LABEL_54:
                free(v44);
                v42[2] = 0;
              }
LABEL_55:
              v45 = (void *)v42[4];
              if (v45)
                free(v45);
              free(v42);
              goto LABEL_19;
            }
            if (!*((_QWORD *)v69 + 4))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              *(_DWORD *)buf = 136446722;
              v72 = "copymptcpinfo";
              v73 = 1024;
              *(_DWORD *)v74 = v12;
              *(_WORD *)&v74[4] = 1024;
              *(_DWORD *)&v74[6] = a1;
              v28 = (char *)_os_log_send_and_compose_impl();
              type = OS_LOG_TYPE_ERROR;
              v67 = 0;
              if (!__nwlog_fault(v28, &type, &v67))
                goto LABEL_64;
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v29 = gLogObj;
                v30 = type;
                if (os_log_type_enabled((os_log_t)gLogObj, type))
                {
                  *(_DWORD *)buf = 136446722;
                  v72 = "copymptcpinfo";
                  v73 = 1024;
                  *(_DWORD *)v74 = v12;
                  *(_WORD *)&v74[4] = 1024;
                  *(_DWORD *)&v74[6] = a1;
                  v31 = v29;
                  v32 = v30;
                  v33 = "%{public}s NULL conninfo aux data for ifindex %u on fd %d";
                  goto LABEL_63;
                }
LABEL_64:
                if (v28)
                  free(v28);
                v42 = v69;
                if (!v69)
                  goto LABEL_19;
                v48 = (void *)*((_QWORD *)v69 + 1);
                if (v48)
                {
                  free(v48);
                  v42[1] = 0;
                }
                v44 = (void *)v42[2];
                if (v44)
                  goto LABEL_54;
                goto LABEL_55;
              }
              if (v67)
              {
                v37 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v38 = gLogObj;
                v39 = type;
                v40 = os_log_type_enabled((os_log_t)gLogObj, type);
                if (v37)
                {
                  if (v40)
                  {
                    *(_DWORD *)buf = 136446978;
                    v72 = "copymptcpinfo";
                    v73 = 1024;
                    *(_DWORD *)v74 = v12;
                    *(_WORD *)&v74[4] = 1024;
                    *(_DWORD *)&v74[6] = a1;
                    LOWORD(v75) = 2082;
                    *(_QWORD *)((char *)&v75 + 2) = v37;
                    _os_log_impl(&dword_182FBE000, v38, v39, "%{public}s NULL conninfo aux data for ifindex %u on fd %d, dumping backtrace:%{public}s", buf, 0x22u);
                  }
                  free(v37);
                  goto LABEL_64;
                }
                if (!v40)
                  goto LABEL_64;
                *(_DWORD *)buf = 136446722;
                v72 = "copymptcpinfo";
                v73 = 1024;
                *(_DWORD *)v74 = v12;
                *(_WORD *)&v74[4] = 1024;
                *(_DWORD *)&v74[6] = a1;
                v31 = v38;
                v32 = v39;
                v33 = "%{public}s NULL conninfo aux data for ifindex %u on fd %d, no backtrace";
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v46 = gLogObj;
                v47 = type;
                if (!os_log_type_enabled((os_log_t)gLogObj, type))
                  goto LABEL_64;
                *(_DWORD *)buf = 136446722;
                v72 = "copymptcpinfo";
                v73 = 1024;
                *(_DWORD *)v74 = v12;
                *(_WORD *)&v74[4] = 1024;
                *(_DWORD *)&v74[6] = a1;
                v31 = v46;
                v32 = v47;
                v33 = "%{public}s NULL conninfo aux data for ifindex %u on fd %d, backtrace limit exceeded";
              }
LABEL_63:
              _os_log_impl(&dword_182FBE000, v31, v32, v33, buf, 0x18u);
              goto LABEL_64;
            }
            *(_QWORD *)(v4[1] + 8 * v65++) = v69;
          }
        }
LABEL_19:
        v11 += 36;
        if (v11 == 164)
        {
          *((_DWORD *)v4 + 4) = v65;
          v2 = v64;
          goto LABEL_4;
        }
      }
    }
    v62 = __nwlog_obj();
    os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v72 = "strict_calloc";
    v73 = 2048;
    *(_QWORD *)v74 = v9;
    *(_WORD *)&v74[8] = 2048;
    *(_QWORD *)&v75 = 8;
    v63 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v63);
    if (!(_DWORD)result)
    {
      free(v63);
      goto LABEL_16;
    }
    goto LABEL_101;
  }
  freemptcpinfo(v4);
  v49 = *(_QWORD **)v70;
  if (!*(_QWORD *)v70)
    return 0xFFFFFFFFLL;
  v50 = *(void **)(*(_QWORD *)v70 + 8);
  if (v50)
  {
    free(v50);
    v49[1] = 0;
  }
  v51 = (void *)v49[2];
  if (v51)
  {
    free(v51);
    v49[2] = 0;
  }
  v52 = (void *)v49[4];
  if (v52)
    free(v52);
  free(v49);
  return 0xFFFFFFFFLL;
}

void freemptcpinfo(_QWORD *a1)
{
  _QWORD *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  unint64_t v7;
  unint64_t i;
  _QWORD *v9;
  void *v10;
  void *v11;
  void *v12;

  if (a1)
  {
    v2 = (_QWORD *)*a1;
    if (*a1)
    {
      v3 = (void *)v2[1];
      if (v3)
      {
        free(v3);
        v2[1] = 0;
      }
      v4 = (void *)v2[2];
      if (v4)
      {
        free(v4);
        v2[2] = 0;
      }
      v5 = (void *)v2[4];
      if (v5)
        free(v5);
      free(v2);
    }
    v6 = (void *)a1[1];
    if (v6)
    {
      v7 = *((unsigned int *)a1 + 4);
      if (!(_DWORD)v7)
        goto LABEL_24;
      for (i = 0; i < v7; ++i)
      {
        v9 = *(_QWORD **)(a1[1] + 8 * i);
        if (v9)
        {
          v10 = (void *)v9[1];
          if (v10)
          {
            free(v10);
            v9[1] = 0;
          }
          v11 = (void *)v9[2];
          if (v11)
          {
            free(v11);
            v9[2] = 0;
          }
          v12 = (void *)v9[4];
          if (v12)
            free(v12);
          free(v9);
          v7 = *((unsigned int *)a1 + 4);
        }
      }
      v6 = (void *)a1[1];
      if (v6)
LABEL_24:
        free(v6);
    }
    free(a1);
  }
}

void nw_quic_metadata_set_original(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[4];
  id v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (!nw_protocol_metadata_is_quic_connection(v3))
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_quic_metadata_set_original";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v6, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_quic_metadata_set_original";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_quic_metadata_set_original";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_quic_metadata_set_original";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_quic_metadata_set_original";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (nw_protocol_metadata_is_quic_connection(v4))
  {
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v19[2] = __nw_quic_metadata_set_original_block_invoke;
    v19[3] = &unk_1E14A9F20;
    v20 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v19);

    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_quic_metadata_set_original";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v6, &type, &v21))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_quic_metadata_set_original";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata)", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v21)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_quic_metadata_set_original";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata), backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_quic_metadata_set_original";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata), no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_quic_metadata_set_original";
    v25 = 2082;
    v26 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_1838D6CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_metadata_set_original_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 24), *(id *)(a1 + 32));
  return 1;
}

BOOL nw_quic_connection_allocate_options(void *a1)
{
  id v1;
  char *v2;
  void *v3;
  NWConcrete_nw_protocol_options *options;
  __int128 v5;
  int v6;
  int v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  _BOOL8 result;
  NSObject *v16;
  void *v17;

  v1 = a1;
  v2 = (char *)malloc_type_calloc(1uLL, 0xE0uLL, 0xEAFB8F1AuLL);
  if (v2)
    goto LABEL_2;
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  v17 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
LABEL_2:
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    v3 = (void *)nw_protocol_boringssl_copy_definition();
    options = nw_protocol_create_options(v3);

    objc_storeStrong((id *)v2 + 12, options);
    *((_DWORD *)v2 + 48) = -1;
    *((_WORD *)v2 + 102) = -1;
    *(_QWORD *)&v5 = -1;
    *((_QWORD *)&v5 + 1) = -1;
    *(_OWORD *)v2 = v5;
    *((_OWORD *)v2 + 1) = v5;
    v6 = *(unsigned __int16 *)(v2 + 215);
    *((_OWORD *)v2 + 2) = v5;
    v7 = v6 | (v2[217] << 16);
    *(_DWORD *)(v2 + 206) = 0;
    *(_DWORD *)(v2 + 209) = 0;
    *((_DWORD *)v2 + 50) = 2;
    v7 &= 0xFE2000u;
    *(_WORD *)(v2 + 215) = v7 | 1;
    v2[217] = BYTE2(v7);
    *((_QWORD *)v2 + 14) = 0;
    *((_QWORD *)v2 + 15) = 0;
    *((_QWORD *)v2 + 13) = 0;
    v8 = (void *)*((_QWORD *)v2 + 17);
    *((_QWORD *)v2 + 17) = 0;

    v9 = (void *)*((_QWORD *)v2 + 18);
    *((_QWORD *)v2 + 18) = 0;

    v10 = (void *)*((_QWORD *)v2 + 20);
    *((_QWORD *)v2 + 20) = 0;

    v11 = (void *)*((_QWORD *)v2 + 21);
    *((_QWORD *)v2 + 21) = 0;

    v12 = (void *)*((_QWORD *)v2 + 22);
    *((_QWORD *)v2 + 22) = 0;

    v13 = (void *)*((_QWORD *)v2 + 23);
    *((_QWORD *)v2 + 23) = 0;

    v14 = (void *)*((_QWORD *)v2 + 19);
    *((_QWORD *)v2 + 19) = 0;

    v2[214] = -1;
    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_1838D6F60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_copy_options(void *a1, uint64_t a2)
{
  id v3;
  char *v4;
  const __CFArray *v5;
  CFAllocatorRef *v6;
  const void *v7;
  const __CFArray *v8;
  const void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  __int16 v14;
  __int16 v15;
  __int16 v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  char v23;
  _BOOL8 result;
  void *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  NSObject *v29;
  void *v30;
  char *backtrace_string;
  os_log_type_t v32;
  _BOOL4 v33;
  os_log_type_t v34;
  char v35;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v38 = "nw_quic_connection_copy_options_internal";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (__nwlog_fault(v26, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_quic_connection_copy_options_internal";
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        v33 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v38 = "nw_quic_connection_copy_options_internal";
            v39 = 2082;
            v40 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v27, v32, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_quic_connection_copy_options_internal";
          _os_log_impl(&dword_182FBE000, v27, v32, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v34 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v38 = "nw_quic_connection_copy_options_internal";
          _os_log_impl(&dword_182FBE000, v27, v34, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_33:
    if (v26)
      free(v26);
    v4 = 0;
    goto LABEL_14;
  }
  v4 = (char *)malloc_type_calloc(1uLL, 0xE0uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    objc_storeStrong((id *)v4 + 12, *(id *)(a2 + 96));
    *((_WORD *)v4 + 102) = *(_WORD *)(a2 + 204);
    *((_DWORD *)v4 + 48) = *(_DWORD *)(a2 + 192);
    *((_OWORD *)v4 + 2) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)v4 = *(_OWORD *)a2;
    *((_OWORD *)v4 + 1) = *(_OWORD *)(a2 + 16);
    *((_OWORD *)v4 + 3) = *(_OWORD *)(a2 + 48);
    *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 64);
    *((_OWORD *)v4 + 5) = *(_OWORD *)(a2 + 80);
    v5 = *(const __CFArray **)(a2 + 104);
    v6 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if (v5)
      *((_QWORD *)v4 + 13) = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5);
    v7 = *(const void **)(a2 + 112);
    if (v7)
      *((_QWORD *)v4 + 14) = CFRetain(v7);
    v8 = *(const __CFArray **)(a2 + 120);
    if (v8)
      *((_QWORD *)v4 + 15) = CFArrayCreateCopy(*v6, v8);
    v9 = *(const void **)(a2 + 128);
    if (v9)
      *((_QWORD *)v4 + 16) = CFRetain(v9);
    objc_storeStrong((id *)v4 + 17, *(id *)(a2 + 136));
    objc_storeStrong((id *)v4 + 18, *(id *)(a2 + 144));
    v10 = _Block_copy(*(const void **)(a2 + 160));
    v11 = (void *)*((_QWORD *)v4 + 20);
    *((_QWORD *)v4 + 20) = v10;

    objc_storeStrong((id *)v4 + 21, *(id *)(a2 + 168));
    v12 = _Block_copy(*(const void **)(a2 + 176));
    v13 = (void *)*((_QWORD *)v4 + 22);
    *((_QWORD *)v4 + 22) = v12;

    objc_storeStrong((id *)v4 + 23, *(id *)(a2 + 184));
    v14 = *(_WORD *)(v4 + 215);
    v4[214] = *(_BYTE *)(a2 + 214);
    v15 = v14 & 0xFFFE | *(_WORD *)(a2 + 215) & 1;
    *(_WORD *)(v4 + 215) = v15;
    v16 = v15 & 0x3F11 | *(_WORD *)(a2 + 215) & 0xC0EE;
    *(_WORD *)(v4 + 215) = v16;
    v17 = *(_DWORD *)(a2 + 206);
    *((_WORD *)v4 + 105) = *(_WORD *)(a2 + 210);
    *(_DWORD *)(v4 + 206) = v17;
    *(_WORD *)(v4 + 215) = *(_WORD *)(a2 + 215) & 0x10 | v16 & 0xFFEF;
    v4[212] = *(_BYTE *)(a2 + 212);
    objc_storeStrong((id *)v4 + 19, *(id *)(a2 + 152));
    v18 = *(unsigned __int16 *)(v4 + 215);
    v19 = v18 & 0xFFFFFCFF | (v4[217] << 16) | ((HIBYTE(*(unsigned __int16 *)(a2 + 215)) & 3) << 8);
    *(_WORD *)(v4 + 215) = v18 & 0xFCFF | ((HIBYTE(*(_WORD *)(a2 + 215)) & 3) << 8);
    *((_DWORD *)v4 + 50) = *(_DWORD *)(a2 + 200);
    *(_WORD *)(v4 + 215) = *(_WORD *)(a2 + 215) & 0x3800 | v19 & 0xC7FF;
    v20 = os_variant_allows_internal_security_policies();
    v21 = *(unsigned __int16 *)(v4 + 215) | (v4[217] << 16);
    if (v20)
    {
      v22 = HIWORD(v21);
      v21 = *(_WORD *)(v4 + 215) & 0xFBFF | (v4[217] << 16) | (((*(unsigned __int16 *)(a2 + 215) >> 10) & 1) << 10);
      v4[217] = v22;
      *(_WORD *)(v4 + 215) = v21;
    }
    v23 = *(_BYTE *)(a2 + 217);
    *(_WORD *)(v4 + 215) = v21;
    v4[217] = (v21 & 0xFFF0FFFF | ((v23 & 0xF) << 16)) >> 16;
LABEL_14:

    return (BOOL)v4;
  }
  __nwlog_obj();
  v29 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v38 = "strict_calloc";
  v39 = 2048;
  v40 = 1;
  v41 = 2048;
  v42 = 224;
  v30 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v30);
  if (!result)
  {
    free(v30);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_1838D74DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_deallocate_options(uint64_t a1, uint64_t a2)
{
  void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  v3 = *(void **)(a2 + 96);
  *(_QWORD *)(a2 + 96) = 0;

  v4 = *(const void **)(a2 + 104);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 104) = 0;
  }
  v5 = *(const void **)(a2 + 112);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a2 + 112) = 0;
  }
  v6 = *(const void **)(a2 + 120);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a2 + 120) = 0;
  }
  v7 = *(const void **)(a2 + 128);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a2 + 128) = 0;
  }
  v8 = *(void **)(a2 + 136);
  *(_QWORD *)(a2 + 136) = 0;

  v9 = *(void **)(a2 + 144);
  *(_QWORD *)(a2 + 144) = 0;

  v10 = *(void **)(a2 + 160);
  *(_QWORD *)(a2 + 160) = 0;

  v11 = *(void **)(a2 + 168);
  *(_QWORD *)(a2 + 168) = 0;

  v12 = *(void **)(a2 + 176);
  *(_QWORD *)(a2 + 176) = 0;

  v13 = *(void **)(a2 + 184);
  *(_QWORD *)(a2 + 184) = 0;

  v14 = *(void **)(a2 + 152);
  *(_QWORD *)(a2 + 152) = 0;

  free((void *)a2);
}

uint64_t nw_quic_connection_option_compare(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 == 1)
    return 1;
  else
    return nw_protocol_option_is_equal(*(void **)(a2 + 96), *(void **)(a3 + 96));
}

double nw_quic_connection_initialize_metadata(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)(a2 + 216) = 0;
  result = 0.0;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_QWORD *)a2 = -1;
  return result;
}

void nw_quic_connection_finalize_metadata(uint64_t a1, id *a2)
{
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;

  if (a2)
  {
    v3 = a2[1];
    a2[1] = 0;

    v4 = a2[2];
    a2[2] = 0;

    v5 = a2[3];
    a2[3] = 0;

    v6 = a2[5];
    a2[5] = 0;

    v7 = a2[4];
    a2[4] = 0;

    v8 = a2[6];
    a2[6] = 0;

    v9 = a2[7];
    a2[7] = 0;

    v10 = a2[8];
    a2[8] = 0;

    v11 = a2[9];
    a2[9] = 0;

    v12 = a2[10];
    a2[10] = 0;

    v13 = a2[11];
    a2[11] = 0;

    v14 = a2[12];
    a2[12] = 0;

    v15 = a2[13];
    a2[13] = 0;

    v16 = a2[14];
    a2[14] = 0;

    v17 = a2[15];
    a2[15] = 0;

    v18 = a2[16];
    a2[16] = 0;

    v19 = a2[17];
    a2[17] = 0;

    v20 = a2[18];
    a2[18] = 0;

    v21 = a2[22];
    a2[22] = 0;

    v22 = a2[19];
    a2[19] = 0;

    v23 = a2[20];
    a2[20] = 0;

    v24 = a2[21];
    a2[21] = 0;

    v25 = a2[25];
    a2[25] = 0;

  }
}

id *nw_quic_metadata_create_reply(void *a1)
{
  id v1;
  void *v2;
  _OWORD *v3;
  id *v4;
  _OWORD *v5;
  uint64_t v6;
  void *v7;
  id *v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  _QWORD v23[4];
  id v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[22];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (nw_protocol_metadata_is_quic_connection(v1))
    {
      v3 = v2;
      *(_OWORD *)buf = v3[1];

      buf[9] |= 1u;
      if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
        dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
      v4 = nw_protocol_metadata_create((void *)nw_protocol_copy_quic_connection_definition::quic_definition, buf);
      if (v4)
      {
        v23[0] = MEMORY[0x1E0C809B0];
        v23[1] = 3221225472;
        v23[2] = ___ZL29nw_quic_metadata_create_replyPU34objcproto23OS_nw_protocol_metadata8NSObject_block_invoke;
        v23[3] = &unk_1E14A9F20;
        v5 = v3;
        v24 = v5;
        v6 = (uint64_t)v4[4];
        if (v6)
        {
          ___ZL29nw_quic_metadata_create_replyPU34objcproto23OS_nw_protocol_metadata8NSObject_block_invoke((uint64_t)v23, v6);
          v7 = v24;
        }
        else
        {
          v7 = v5;
        }
        v8 = v4;

      }
      goto LABEL_11;
    }
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v11, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata)", buf, 0xCu);
        }
LABEL_43:

        goto LABEL_44;
      }
      if (!v25)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
          _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
          _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata), no backtrace", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null nw_protocol_metadata_is_quic_connection(original_metadata), dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_31;
    }
  }
  else
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v11, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null original_metadata", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (!v25)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
          _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null original_metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null original_metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_43;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_quic_metadata_create_reply";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null original_metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_31:

      free(backtrace_string);
    }
  }
LABEL_44:
  if (v11)
    free(v11);
  v4 = 0;
LABEL_11:

  return v4;
}

void sub_1838D7DB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *nw_quic_metadata_copy_original(uint64_t a1, uint64_t a2)
{
  void *v2;
  id v3;

  v2 = *(void **)(a2 + 24);
  if (v2)
    v3 = v2;
  return v2;
}

void nw_quic_deallocate_cache_entry(uint64_t a1, void **a2)
{
  void *v3;
  void *v4;
  void *v5;

  v3 = *a2;
  *a2 = 0;

  v4 = a2[1];
  a2[1] = 0;

  v5 = a2[2];
  a2[2] = 0;

  free(a2);
}

size_t nw_quic_should_flush_cache_entry(uint64_t a1, uint64_t a2, char a3, void *a4, void *a5)
{
  id v7;
  id v8;
  void *v9;
  size_t v10;

  v7 = a4;
  v8 = a5;
  v9 = v8;
  if ((a3 & 1) != 0)
    v10 = 1;
  else
    v10 = nw_path_signature_changed_from_previous(v8, v7);

  return v10;
}

void sub_1838D7E9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__54919(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__54920(uint64_t a1)
{

}

uint64_t ___ZL29nw_quic_metadata_create_replyPU34objcproto23OS_nw_protocol_metadata8NSObject_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 24), *(id *)(a1 + 32));
  return 1;
}

void *nw_protocol_set_quic_overrides(void *result, void *a2, void *a3, void *a4, void *a5)
{
  quic_fillout_definition_callbacks_override = result;
  qpod_conn_create_override = a2;
  qpod_conn_free_override = a3;
  qpod_conn_encode_datagram_override = a4;
  qpod_conn_decode_datagram_override = a5;
  return result;
}

void nw_quic_access_application_result_on_queue(void *a1, void *a2)
{
  id v3;
  void (**v4)(id, uint64_t, uint64_t);
  id v5;
  uint64_t cached_content_for_protocol;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
    v5 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
    if (v5)
    {
      cached_content_for_protocol = nw_association_get_cached_content_for_protocol(v3, v5);
      if (cached_content_for_protocol)
      {
        v7 = *(unsigned int *)(cached_content_for_protocol + 36);
        v8 = *(unsigned int *)(cached_content_for_protocol + 40);
      }
      else
      {
        v7 = 0;
        v8 = 0;
      }
      v4[2](v4, v7, v8);
LABEL_9:

      goto LABEL_10;
    }
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v28 = "nw_quic_access_application_result_on_queue";
    v14 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v14, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_quic_access_application_result_on_queue";
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null definition", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        v22 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            v28 = "nw_quic_access_application_result_on_queue";
            v29 = 2082;
            v30 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v15, v21, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_quic_access_application_result_on_queue";
          _os_log_impl(&dword_182FBE000, v15, v21, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          v28 = "nw_quic_access_application_result_on_queue";
          _os_log_impl(&dword_182FBE000, v15, v24, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_45:
    if (v14)
      free(v14);
    goto LABEL_9;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_quic_access_application_result_on_queue";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v10, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_quic_access_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v25)
    {
      v17 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_quic_access_application_result_on_queue";
          v29 = 2082;
          v30 = v17;
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v17);
        goto LABEL_40;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_quic_access_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_quic_access_application_result_on_queue";
        _os_log_impl(&dword_182FBE000, v11, v23, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_40:
  if (v10)
    free(v10);
LABEL_10:

}

void sub_1838D8428(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

BOOL nw_quic_stream_allocate_options(void *a1)
{
  id v1;
  _QWORD *v2;
  NWConcrete_nw_protocol_options *options;
  void *v4;
  _BOOL8 result;
  NSObject *v6;
  void *v7;

  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (!v2)
  {
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    v7 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v7);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v7);
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  options = nw_protocol_create_options((void *)nw_protocol_copy_quic_connection_definition::quic_definition);
  v4 = (void *)v2[2];
  v2[2] = options;

  return (BOOL)v2;
}

void sub_1838D85B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_quic_stream_copy_options(void *a1, uint64_t a2)
{
  id v3;
  _QWORD *v4;
  NWConcrete_nw_protocol_options *v5;
  void *v6;
  char v7;
  _BOOL8 result;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  NSObject *v13;
  void *v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_quic_stream_copy_options";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_quic_stream_copy_options";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_quic_stream_copy_options";
            v23 = 2082;
            v24 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_quic_stream_copy_options";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_quic_stream_copy_options";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_23:
    if (v10)
      free(v10);
    v4 = 0;
    goto LABEL_4;
  }
  v4 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    v5 = nw_protocol_options_copy(*(void **)(a2 + 16));
    v6 = (void *)v4[2];
    v4[2] = v5;

    v7 = v4[3] & 0xFE | *(_BYTE *)(a2 + 24) & 1;
    *((_BYTE *)v4 + 24) = v7;
    *((_BYTE *)v4 + 24) = v7 & 0xFD | *(_BYTE *)(a2 + 24) & 2;
    *(_OWORD *)v4 = *(_OWORD *)a2;
LABEL_4:

    return (BOOL)v4;
  }
  __nwlog_obj();
  v13 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v22 = "strict_calloc";
  v23 = 2048;
  v24 = 1;
  v25 = 2048;
  v26 = 32;
  v14 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_1838D8960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_stream_deallocate_options(uint64_t a1, _QWORD *a2)
{
  void *v3;

  v3 = (void *)a2[2];
  a2[2] = 0;

  free(a2);
}

uint64_t nw_quic_stream_option_compare(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return nw_protocol_option_is_equal(*(void **)(a2 + 16), *(void **)(a3 + 16));
}

uint64_t nw_quic_stream_serialize_options(void *a1, uint64_t a2, uint64_t a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  _QWORD v22[7];
  char v23;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (a2)
  {
    if (a3)
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v26 = 0;
      v6 = *(void **)(a2 + 16);
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 3221225472;
      v22[2] = ___ZL32nw_quic_stream_serialize_optionsPU36objcproto25OS_nw_protocol_definition8NSObjectPvPm_block_invoke;
      v22[3] = &unk_1E14AA3B8;
      v22[4] = buf;
      v22[5] = a3;
      v22[6] = a2;
      nw_protocol_options_access_handle(v6, v22);
      v7 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null out_length", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
          _os_log_impl(&dword_182FBE000, v11, v21, "%{public}s called with null out_length, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
          _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null out_length, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v18, "%{public}s called with null out_length, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
    v10 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
          _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null existing_handle", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        __nwlog_obj();
        v11 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
          _os_log_impl(&dword_182FBE000, v11, v20, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
          _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_quic_stream_serialize_options";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v10)
    free(v10);
  v7 = 0;
LABEL_4:

  return v7;
}

void sub_1838D8EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_quic_stream_deserialize_options(void *a1, uint64_t a2, unint64_t a3)
{
  id v5;
  _QWORD *v6;
  NWConcrete_nw_protocol_options *options;
  void *v8;
  char v9;
  _BOOL8 result;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  NSObject *v17;
  void *v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  os_log_type_t v25;
  _QWORD v26[7];
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_quic_stream_deserialize_options";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_quic_stream_deserialize_options";
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null serialized_bytes", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v27)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_quic_stream_deserialize_options";
          _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null serialized_bytes, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      v21 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_quic_stream_deserialize_options";
          _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null serialized_bytes, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        v30 = "nw_quic_stream_deserialize_options";
        v31 = 2082;
        v32 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v20, "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
LABEL_42:
    if (v12)
      free(v12);
    v6 = 0;
    goto LABEL_7;
  }
  if (a3 <= 0x13)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_quic_stream_deserialize_options";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_quic_stream_deserialize_options";
          _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null (serialized_length >= sizeof(struct nw_protocol_quic_serialized_options))", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v27)
      {
        __nwlog_obj();
        v13 = objc_claimAutoreleasedReturnValue();
        v25 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_quic_stream_deserialize_options";
          _os_log_impl(&dword_182FBE000, v13, v25, "%{public}s called with null (serialized_length >= sizeof(struct nw_protocol_quic_serialized_options)), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      v23 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          v30 = "nw_quic_stream_deserialize_options";
          _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s called with null (serialized_length >= sizeof(struct nw_protocol_quic_serialized_options)), no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v30 = "nw_quic_stream_deserialize_options";
        v31 = 2082;
        v32 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s called with null (serialized_length >= sizeof(struct nw_protocol_quic_serialized_options)), dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
    goto LABEL_42;
  }
  v6 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_4:
    if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
    options = nw_protocol_create_options((void *)nw_protocol_copy_quic_connection_definition::quic_definition);
    v8 = (void *)v6[2];
    v6[2] = options;

    v26[0] = MEMORY[0x1E0C809B0];
    v26[1] = 3221225472;
    v26[2] = ___ZL34nw_quic_stream_deserialize_optionsPU36objcproto25OS_nw_protocol_definition8NSObjectPKvm_block_invoke;
    v26[3] = &__block_descriptor_56_e9_B16__0_v8l;
    v26[4] = a2;
    v26[5] = a2;
    v26[6] = a3;
    nw_protocol_options_access_handle(options, v26);
    v9 = v6[3] & 0xFE | *(_BYTE *)(a2 + 17) & 1;
    *((_BYTE *)v6 + 24) = v9;
    *((_BYTE *)v6 + 24) = *(_BYTE *)(a2 + 17) & 2 | v9 & 0xFD;
LABEL_7:

    return (BOOL)v6;
  }
  __nwlog_obj();
  v17 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v30 = "strict_calloc";
  v31 = 2048;
  v32 = 1;
  v33 = 2048;
  v34 = 32;
  v18 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v18);
  if (!result)
  {
    free(v18);
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

void sub_1838D94D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double nw_quic_stream_initialize_metadata(uint64_t a1, _OWORD *a2)
{
  double result;

  result = 0.0;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  *((_QWORD *)a2 + 2) = -1;
  return result;
}

void nw_quic_stream_finalize_metadata(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    *(_QWORD *)a2 = -1;
    v3 = *(void **)(a2 + 24);
    *(_QWORD *)(a2 + 24) = 0;

    v4 = *(void **)(a2 + 32);
    *(_QWORD *)(a2 + 32) = 0;

  }
}

uint64_t nw_quic_stream_should_serialize_options(uint64_t a1, uint64_t a2)
{
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
    return nw_protocol_options_access_handle(*(void **)(a2 + 16), &__block_literal_global_57_55090);
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_quic_stream_should_serialize_options";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_quic_stream_should_serialize_options";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null existing_handle", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_quic_stream_should_serialize_options";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_quic_stream_should_serialize_options";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_quic_stream_should_serialize_options";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_19:
  if (v4)
    free(v4);
  return 0;
}

BOOL ___ZL39nw_quic_stream_should_serialize_optionsPU36objcproto25OS_nw_protocol_definition8NSObjectPv_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 128) != 0;
}

uint64_t ___ZL34nw_quic_stream_deserialize_optionsPU36objcproto25OS_nw_protocol_definition8NSObjectPKvm_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  double v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  NWConcrete_nw_protocol_options *options;
  void *v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  size_t v18;
  dispatch_data_t v19;
  void *v20;
  const UInt8 *v21;
  const UInt8 *v22;
  unint64_t v23;
  CFIndex v24;
  const __CFAllocator *v25;
  CFDataRef v26;
  const UInt8 *v27;
  unint64_t v28;
  __CFArray *Mutable;
  unsigned int v30;
  const CFArrayCallBacks *v31;
  CFIndex v32;
  CFDataRef v33;
  const UInt8 *v34;
  unint64_t v35;
  CFIndex v36;
  id v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const UInt8 *v41;
  unint64_t v42;
  __CFArray *v43;
  const __CFAllocator *v44;
  const CFArrayCallBacks *v45;
  CFIndex v46;
  CFDataRef v47;
  const void *v48;
  char *backtrace_string;
  os_log_type_t v51;
  _BOOL4 v52;
  os_log_type_t v53;
  char v54;
  os_log_type_t type;
  _BYTE buffer[22];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v4 = a1[4];
  v5 = *(unsigned __int16 *)(a2 + 215);
  *(_DWORD *)(a2 + 192) = *(_DWORD *)v4;
  v6 = *(double *)(v4 + 4);
  *(double *)(a2 + 204) = v6;
  v7 = v5 & 0xFFFFFFFB | (*(unsigned __int8 *)(a2 + 217) << 16);
  LODWORD(v4) = v7 | (4 * (*(_WORD *)(v4 + 16) & 1));
  v7 >>= 16;
  *(_BYTE *)(a2 + 217) = v7;
  *(_WORD *)(a2 + 215) = v4;
  LODWORD(v4) = v4 & 0xFFFFBFFF | (((*(unsigned __int16 *)(a1[4] + 16) >> 7) & 1) << 14);
  *(_BYTE *)(a2 + 217) = v7;
  *(_WORD *)(a2 + 215) = v4;
  LODWORD(v4) = v4 & 0xFFFFFFDF | (32 * ((*(unsigned __int16 *)(a1[4] + 16) >> 1) & 1));
  *(_BYTE *)(a2 + 217) = v7;
  *(_WORD *)(a2 + 215) = v4;
  LODWORD(v4) = v4 & 0xFFFFFFBF | (((*(unsigned __int16 *)(a1[4] + 16) >> 2) & 1) << 6);
  *(_BYTE *)(a2 + 217) = v7;
  *(_WORD *)(a2 + 215) = v4;
  LODWORD(v4) = v4 & 0xFFFFFF7F | (((*(unsigned __int16 *)(a1[4] + 16) >> 3) & 1) << 7);
  *(_BYTE *)(a2 + 217) = v7;
  *(_WORD *)(a2 + 215) = v4;
  v8 = *(unsigned __int16 *)(a1[4] + 16) >> 10;
  *(_WORD *)(a2 + 215) = v4;
  v9 = v4 & 0xFFFBFFFF | ((v8 & 1) << 18);
  *(_BYTE *)(a2 + 217) = BYTE2(v9);
  v10 = a1[4];
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(v10 + 14);
  v11 = *(_WORD *)(v10 + 16);
  if (((((v5 & 0x1000) == 0) ^ ((v11 & 0x40) >> 6)) & 1) == 0)
  {
    *(_BYTE *)(a2 + 217) = BYTE2(v9);
    *(_WORD *)(a2 + 215) = v9 & 0xEFFF | ((v11 & 0x40) << 6);
    if ((v11 & 0x40) != 0)
    {
      options = nw_swift_tls_create_options(v6);
    }
    else
    {
      v13 = (void *)nw_protocol_boringssl_copy_definition();
      options = nw_protocol_create_options(v13);

    }
    objc_storeStrong((id *)(a2 + 96), options);

    v11 = *(_WORD *)(a1[4] + 16);
    v9 = *(unsigned __int16 *)(a2 + 215) | (*(unsigned __int8 *)(a2 + 217) << 16);
  }
  v14 = v11 & 0x1000;
  if (((((v9 & 0x2000) == 0) ^ (v14 >> 12)) & 1) == 0)
  {
    *(_BYTE *)(a2 + 217) = BYTE2(v9);
    *(_WORD *)(a2 + 215) = v9 & 0xDFFF | (2 * v14);
    if (v14)
      sec_protocol_options_add_tls_key_exchange_group();
  }
  nw_quic_connection_set_trust_certs_internal(a2, (*(unsigned __int16 *)(a1[4] + 16) >> 4) & 1);
  if ((*(_WORD *)(a1[4] + 16) & 0x20) != 0)
  {
    sec_protocol_options_add_transport_specific_application_protocol();
    v15 = *(unsigned __int16 *)(a2 + 215) | (*(unsigned __int8 *)(a2 + 217) << 16) | 0x800;
  }
  else
  {
    v15 = *(_WORD *)(a2 + 215) & 0xF7FF | (*(unsigned __int8 *)(a2 + 217) << 16);
  }
  *(_WORD *)(a2 + 215) = v15;
  *(_BYTE *)(a2 + 217) = BYTE2(v15);
  v16 = a1[4];
  v17 = *(unsigned __int8 *)(v16 + 12);
  if (*(_BYTE *)(v16 + 12))
  {
    memset(buffer, 0, 20);
    if (v17 >= 0x14)
      v18 = 20;
    else
      v18 = v17;
    v19 = dispatch_data_create(buffer, v18, 0, 0);
    v20 = *(void **)(a2 + 152);
    *(_QWORD *)(a2 + 152) = v19;

    v16 = a1[4];
  }
  v21 = (const UInt8 *)(v16 + 18);
  if (*(_BYTE *)(v16 + 13))
  {
    v22 = (const UInt8 *)(v16 + 20);
    v23 = a1[5] + a1[6];
    if ((unint64_t)v22 < v23)
    {
      v24 = *(unsigned __int16 *)v21;
      v21 = &v22[v24];
      if ((unint64_t)&v22[v24] <= v23)
      {
        v25 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v26 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v22, v24);
        v27 = v21 + 2;
        v28 = a1[5] + a1[6];
        if ((unint64_t)(v21 + 2) >= v28)
        {
          Mutable = 0;
        }
        else
        {
          Mutable = 0;
          v30 = 1;
          v31 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
          while (v30 < *(unsigned __int8 *)(a1[4] + 13))
          {
            v32 = *(unsigned __int16 *)v21;
            v21 = &v27[v32];
            if ((unint64_t)&v27[v32] > v28)
            {
              v21 = v27;
              if (v26)
                goto LABEL_32;
              goto LABEL_33;
            }
            v33 = CFDataCreate(v25, v27, v32);
            if (!Mutable)
              Mutable = CFArrayCreateMutable(v25, 0, v31);
            CFArrayAppendValue(Mutable, v33);
            if (v33)
              CFRelease(v33);
            ++v30;
            v27 = v21 + 2;
            v28 = a1[5] + a1[6];
            if ((unint64_t)(v21 + 2) >= v28)
              break;
          }
        }
        if (v26)
        {
LABEL_32:
          nw_quic_connection_set_client_identity_reference_internal(a2, v26, Mutable, 0);
          CFRelease(v26);
        }
LABEL_33:
        if (Mutable)
          CFRelease(Mutable);
      }
      else
      {
        v21 = v22;
      }
    }
  }
  if ((*(_WORD *)(a1[4] + 16) & 0x800) != 0)
  {
    v34 = v21 + 2;
    v35 = a1[5] + a1[6];
    if ((unint64_t)(v21 + 2) < v35)
    {
      v36 = *(unsigned __int16 *)v21;
      v21 = &v34[v36];
      if ((unint64_t)&v34[v36] > v35)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v37 = (id)gLogObj;
        *(_DWORD *)buffer = 136446210;
        *(_QWORD *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
        v38 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v54 = 0;
        if (__nwlog_fault(v38, &type, &v54))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v39 = (id)gLogObj;
            v40 = type;
            if (os_log_type_enabled(v39, type))
            {
              *(_DWORD *)buffer = 136446210;
              *(_QWORD *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
              _os_log_impl(&dword_182FBE000, v39, v40, "%{public}s expected more bytes", buffer, 0xCu);
            }
          }
          else if (v54)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v39 = (id)gLogObj;
            v51 = type;
            v52 = os_log_type_enabled(v39, type);
            if (backtrace_string)
            {
              if (v52)
              {
                *(_DWORD *)buffer = 136446466;
                *(_QWORD *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
                *(_WORD *)&buffer[12] = 2082;
                *(_QWORD *)&buffer[14] = backtrace_string;
                _os_log_impl(&dword_182FBE000, v39, v51, "%{public}s expected more bytes, dumping backtrace:%{public}s", buffer, 0x16u);
              }

              free(backtrace_string);
              if (!v38)
                goto LABEL_45;
              goto LABEL_44;
            }
            if (v52)
            {
              *(_DWORD *)buffer = 136446210;
              *(_QWORD *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
              _os_log_impl(&dword_182FBE000, v39, v51, "%{public}s expected more bytes, no backtrace", buffer, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v39 = (id)gLogObj;
            v53 = type;
            if (os_log_type_enabled(v39, type))
            {
              *(_DWORD *)buffer = 136446210;
              *(_QWORD *)&buffer[4] = "nw_quic_stream_deserialize_options_block_invoke";
              _os_log_impl(&dword_182FBE000, v39, v53, "%{public}s expected more bytes, backtrace limit exceeded", buffer, 0xCu);
            }
          }

        }
        if (!v38)
        {
LABEL_45:
          v21 = (const UInt8 *)(a1[5] + a1[6]);
          goto LABEL_47;
        }
LABEL_44:
        free(v38);
        goto LABEL_45;
      }
      *(_QWORD *)(a2 + 128) = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v34, v36);
    }
  }
LABEL_47:
  v41 = v21 + 2;
  v42 = a1[5] + a1[6];
  if ((unint64_t)(v21 + 2) < v42)
  {
    v43 = 0;
    v44 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v45 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    do
    {
      v46 = *(unsigned __int16 *)v21;
      v21 = &v41[v46];
      if ((unint64_t)&v41[v46] > v42)
        break;
      if (!v43)
        v43 = CFArrayCreateMutable(v44, 0, v45);
      v47 = CFDataCreate(v44, v41, v46);
      CFArrayAppendValue(v43, v47);
      if (v47)
        CFRelease(v47);
      v41 = v21 + 2;
      v42 = a1[5] + a1[6];
    }
    while ((unint64_t)(v21 + 2) < v42);
    if (v43)
    {
      v48 = *(const void **)(a2 + 104);
      if (v48)
      {
        CFRelease(v48);
        *(_QWORD *)(a2 + 104) = 0;
      }
      if (CFArrayGetCount(v43) >= 1)
      {
        *(_QWORD *)(a2 + 104) = CFRetain(v43);
        sec_protocol_options_set_server_raw_public_key_certificates();
      }
      CFRelease(v43);
    }
  }
  return 1;
}

void sub_1838D9F5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_trust_certs_internal(uint64_t a1, int a2)
{
  NSObject *v3;
  id v4;
  _BOOL8 v5;
  int v6;
  int v7;

  if (a2)
  {
    if (os_variant_allows_internal_security_policies())
    {
      v3 = *(NSObject **)(a1 + 96);
      if (nw_context_copy_implicit_context::onceToken[0] != -1)
        dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      v4 = (id)nw_context_copy_implicit_context::implicit_context;
      v5 = nw_context_copy_workloop(v4);
      sec_protocol_options_set_verify_block(v3, &__block_literal_global_58_55115, (dispatch_queue_t)v5);

      *(_WORD *)(a1 + 215) |= 0x400u;
    }
  }
  else
  {
    v6 = *(unsigned __int16 *)(a1 + 215);
    v7 = *(unsigned __int8 *)(a1 + 217);
    *(_WORD *)(a1 + 215) = v6 & 0xFBFF;
    *(_BYTE *)(a1 + 217) = (v6 & 0xFFFFFBFF | (v7 << 16)) >> 16;
  }
}

void sub_1838DA034(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_client_identity_reference_internal(uint64_t a1, const void *a2, CFTypeRef cf, int a4)
{
  const void *v8;
  const void *v9;
  CFIndex Count;
  CFIndex v11;
  __CFArray *v12;
  CFIndex v13;
  const __CFAllocator *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *ValueAtIndex;
  __CFDictionary *Mutable;
  OSStatus v20;
  CFTypeRef v21;
  __CFArray *v22;
  const void *v23;
  NSObject *v24;
  __CFDictionary *v25;
  OSStatus v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  int v30;
  CFTypeRef cfa;
  uint64_t v32;
  const void *v33;
  const void *v34;
  CFTypeRef result;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  OSStatus v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v8 = *(const void **)(a1 + 112);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v32 = a1;
  if (!cf)
  {
    v30 = a4;
    cfa = a2;
    v12 = 0;
    goto LABEL_26;
  }
  *(_QWORD *)(a1 + 120) = CFRetain(cf);
  if (a4)
  {
    Count = CFArrayGetCount((CFArrayRef)cf);
    if (Count < 1)
    {
      if (!a2)
        return;
      v23 = a2;
      v12 = 0;
      *(_QWORD *)(a1 + 112) = CFRetain(a2);
      goto LABEL_28;
    }
    v11 = Count;
    v30 = a4;
    cfa = a2;
    v12 = 0;
    v13 = 0;
    v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v34 = (const void *)*MEMORY[0x1E0CD7028];
    v33 = (const void *)*MEMORY[0x1E0C9AE50];
    v15 = (const void *)*MEMORY[0x1E0CD6C98];
    v16 = (const void *)*MEMORY[0x1E0CD6CA0];
    v17 = (const void *)*MEMORY[0x1E0CD70E0];
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v13);
      Mutable = CFDictionaryCreateMutable(v14, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionaryAddValue(Mutable, v34, v33);
      CFDictionaryAddValue(Mutable, v15, v16);
      CFDictionaryAddValue(Mutable, v17, ValueAtIndex);
      result = 0;
      v20 = SecItemCopyMatching(Mutable, &result);
      if (Mutable)
        CFRelease(Mutable);
      if (v20)
        break;
      v21 = result;
      if (result)
      {
        v22 = v12;
        if (!v12)
        {
          v22 = CFArrayCreateMutable(v14, 0, MEMORY[0x1E0C9B378]);
          v21 = result;
        }
        v12 = v22;
        CFArrayAppendValue(v22, v21);
        if (result)
          CFRelease(result);
      }
      if (v11 == ++v13)
        goto LABEL_26;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v24 = (id)gLogObj;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v37 = "nw_quic_connection_set_client_identity_reference_internal";
      v38 = 1024;
      v39 = v20;
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s Failed to retrieve certificate (%d)", buf, 0x12u);
    }

LABEL_26:
    if (!cfa || (v23 = cfa, *(_QWORD *)(v32 + 112) = CFRetain(cfa), !v30))
    {
LABEL_40:
      if (v12)
        CFRelease(v12);
      return;
    }
LABEL_28:
    v25 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionaryAddValue(v25, (const void *)*MEMORY[0x1E0CD7028], (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionaryAddValue(v25, (const void *)*MEMORY[0x1E0CD6C98], (const void *)*MEMORY[0x1E0CD6CB0]);
    CFDictionaryAddValue(v25, (const void *)*MEMORY[0x1E0CD70E0], v23);
    result = 0;
    v26 = SecItemCopyMatching(v25, &result);
    if (v25)
      CFRelease(v25);
    if (v26)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v27 = (id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v37 = "nw_quic_connection_set_client_identity_reference_internal";
        v38 = 1024;
        v39 = v26;
        _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s Failed to retrieve identity (%d)", buf, 0x12u);
      }

    }
    if (result)
    {
      if (v12)
        v28 = sec_identity_create_with_certificates((SecIdentityRef)result, v12);
      else
        v28 = sec_identity_create((SecIdentityRef)result);
      v29 = v28;
      sec_protocol_options_set_local_identity(*(sec_protocol_options_t *)(v32 + 96), v28);

      if (result)
        CFRelease(result);
    }
    goto LABEL_40;
  }
  if (a2)
    *(_QWORD *)(a1 + 112) = CFRetain(a2);
}

void sub_1838DA4B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL43nw_quic_connection_set_trust_certs_internalP35nw_protocol_quic_connection_optionsb_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, 1);
}

BOOL ___ZL32nw_quic_stream_serialize_optionsPU36objcproto25OS_nw_protocol_definition8NSObjectPvPm_block_invoke(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  uint64_t v7;
  CFIndex i;
  const __CFData *ValueAtIndex;
  NSObject *v10;
  size_t size;
  char v12;
  const __CFData *v13;
  CFIndex v14;
  const __CFArray *v15;
  unsigned __int8 v16;
  CFIndex v17;
  const __CFData *v18;
  const __CFData *v19;
  CFIndex v20;
  CFIndex v21;
  size_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  const __CFData *v38;
  unsigned __int16 Length;
  const UInt8 *BytePtr;
  uint64_t v41;
  unsigned __int16 v42;
  char *v43;
  const UInt8 *v44;
  const __CFArray *v45;
  CFIndex v46;
  CFIndex v47;
  CFIndex j;
  const __CFData *v49;
  const __CFData *v50;
  unsigned __int16 v51;
  const UInt8 *v52;
  char *v53;
  _BOOL8 result;
  uint64_t v55;
  unsigned int v56;
  const __CFData *v57;
  const __CFData *v58;
  unsigned __int16 v59;
  const UInt8 *v60;
  char *v61;
  NSObject *v62;
  void *v63;
  NSObject *v64;
  void *v65;

  v4 = *(const __CFArray **)(a2 + 104);
  if (!v4)
  {
    v7 = 0;
    goto LABEL_8;
  }
  Count = CFArrayGetCount(v4);
  if (Count)
  {
    v6 = Count;
    v7 = 0;
    for (i = 0; i != v6; ++i)
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 104), i);
      if (ValueAtIndex)
        v7 += CFDataGetLength(ValueAtIndex) + 2;
    }
LABEL_8:
    v10 = *(NSObject **)(a2 + 152);
    if (v10)
      goto LABEL_9;
    goto LABEL_20;
  }
  v7 = 0;
  v10 = *(NSObject **)(a2 + 152);
  if (v10)
  {
LABEL_9:
    size = dispatch_data_get_size(v10);
    if (size <= 0xFF)
      v12 = size;
    else
      v12 = 0;
    v13 = *(const __CFData **)(a2 + 112);
    if (v13)
      goto LABEL_13;
LABEL_21:
    v16 = 0;
    v14 = 0;
    goto LABEL_22;
  }
LABEL_20:
  v12 = 0;
  v13 = *(const __CFData **)(a2 + 112);
  if (!v13)
    goto LABEL_21;
LABEL_13:
  v14 = CFDataGetLength(v13) + 2;
  v15 = *(const __CFArray **)(a2 + 120);
  if (!v15)
  {
    v16 = 1;
    v19 = *(const __CFData **)(a2 + 128);
    if (v19)
      goto LABEL_23;
    goto LABEL_25;
  }
  v16 = CFArrayGetCount(v15) + 1;
  if (v16 >= 2u)
  {
    v17 = 0;
    do
    {
      v18 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), v17);
      if (v18)
        v14 += CFDataGetLength(v18) + 2;
      ++v17;
    }
    while (v16 - 1 != v17);
  }
LABEL_22:
  v19 = *(const __CFData **)(a2 + 128);
  if (v19)
  {
LABEL_23:
    v20 = CFDataGetLength(v19) + 2;
    goto LABEL_26;
  }
LABEL_25:
  v20 = 0;
LABEL_26:
  v21 = v7 + v14 + v20;
  v22 = v21 + 20;
  **(_QWORD **)(a1 + 40) = v21 + 20;
  if (v21 == -20)
  {
    __nwlog_obj();
    v62 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
    v63 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v63);
    if (result)
      goto LABEL_49;
    free(v63);
  }
  v23 = malloc_type_calloc(1uLL, v22, 0xEAFB8F1AuLL);
  if (!v23)
  {
    __nwlog_obj();
    v64 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
    v65 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v65);
    if (!result)
    {
      free(v65);
      goto LABEL_28;
    }
LABEL_49:
    __break(1u);
    return result;
  }
LABEL_28:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v23;
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 4) = *(_WORD *)(a2 + 204);
  **(_DWORD **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 192);
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 6) = *(_WORD *)(a2 + 206);
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 8) = *(_WORD *)(a2 + 208);
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 10) = *(_WORD *)(a2 + 210);
  v24 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v24 + 16) = *(_WORD *)(v24 + 16) & 0xFFFE | (*(_WORD *)(a2 + 215) >> 2) & 1;
  v25 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v25 + 16) = *(_WORD *)(v25 + 16) & 0xFF7F | (*(_WORD *)(a2 + 215) >> 7) & 0x80;
  v26 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v26 + 16) = *(_WORD *)(v26 + 16) & 0xFFFD | (*(_WORD *)(a2 + 215) >> 4) & 2;
  v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v27 + 16) = *(_WORD *)(v27 + 16) & 0xFFFB | (*(_WORD *)(a2 + 215) >> 4) & 4;
  v28 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v28 + 16) = *(_WORD *)(v28 + 16) & 0xFFF7 | (*(_WORD *)(a2 + 215) >> 4) & 8;
  v29 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v29 + 16) = *(_WORD *)(v29 + 16) & 0xFFEF | (*(_WORD *)(a2 + 215) >> 6) & 0x10;
  v30 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v30 + 16) = *(_WORD *)(v30 + 16) & 0xFFDF | (*(_WORD *)(a2 + 215) >> 6) & 0x20;
  v31 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v31 + 16) = *(_WORD *)(v31 + 16) & 0xFFBF | (*(_WORD *)(a2 + 215) >> 6) & 0x40;
  v32 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v32 + 16) = *(_WORD *)(v32 + 16) & 0xEFFF | (*(_WORD *)(a2 + 215) >> 1) & 0x1000;
  v33 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v33 + 16) = *(_WORD *)(v33 + 16) & 0xFBFF | *(_WORD *)(a2 + 216) & 0x400;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 14) = *(_DWORD *)(a2 + 200);
  v34 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v34 + 16) = *(_WORD *)(v34 + 16) & 0xFEFF | ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 24) & 1) << 8);
  v35 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  *(_WORD *)(v35 + 16) = *(_WORD *)(v35 + 16) & 0xFDFF | (((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 24) & 2) != 0) << 9);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 12) = v12;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 13) = v16;
  v36 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v37 = (char *)(v36 + 18);
  if (v16)
  {
    v38 = *(const __CFData **)(a2 + 112);
    if (v38)
    {
      Length = CFDataGetLength(*(CFDataRef *)(a2 + 112));
      BytePtr = CFDataGetBytePtr(v38);
      *(_WORD *)(v36 + 18) = Length;
      memcpy((void *)(v36 + 20), BytePtr, Length);
      v37 = (char *)(v36 + 20 + Length);
    }
    if (v16 != 1)
    {
      v55 = v16 - 1;
      v56 = 0;
      do
      {
        v57 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), v56);
        if (v57)
        {
          v58 = v57;
          v59 = CFDataGetLength(v57);
          v60 = CFDataGetBytePtr(v58);
          *(_WORD *)v37 = v59;
          v61 = v37 + 2;
          memcpy(v61, v60, v59);
          v37 = &v61[v59];
        }
        ++v56;
        --v55;
      }
      while (v55);
    }
  }
  if (v20)
  {
    v41 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    *(_WORD *)(v41 + 16) |= 0x800u;
    v42 = CFDataGetLength(*(CFDataRef *)(a2 + 128));
    *(_WORD *)v37 = v42;
    v43 = v37 + 2;
    v44 = CFDataGetBytePtr(*(CFDataRef *)(a2 + 128));
    memcpy(v43, v44, v42);
    v37 = &v43[v42];
  }
  v45 = *(const __CFArray **)(a2 + 104);
  if (v45)
  {
    v46 = CFArrayGetCount(v45);
    if (v46)
    {
      v47 = v46;
      for (j = 0; j != v47; ++j)
      {
        v49 = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 104), j);
        if (v49)
        {
          v50 = v49;
          v51 = CFDataGetLength(v49);
          v52 = CFDataGetBytePtr(v50);
          *(_WORD *)v37 = v51;
          v53 = v37 + 2;
          memcpy(v53, v52, v51);
          v37 = &v53[v51];
        }
      }
    }
  }
  return 1;
}

nw_protocol_definition_t nw_protocol_copy_quic_definition(void)
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  return (nw_protocol_definition_t)(id)nw_protocol_copy_quic_stream_definition::quic_definition;
}

NWConcrete_nw_protocol_options *nw_quic_create_connection_options()
{
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_54912);
  return nw_protocol_create_options((void *)nw_protocol_copy_quic_connection_definition::quic_definition);
}

nw_protocol_options_t nw_quic_create_options(void)
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_12_55083);
  return (nw_protocol_options_t)nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
}

void nw_quic_add_tls_application_protocol(nw_protocol_options_t options, const char *application_protocol)
{
  NSObject *v3;

  v3 = nw_quic_copy_sec_protocol_options(options);
  sec_protocol_options_add_tls_application_protocol(v3, application_protocol);

}

void sub_1838DACAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

sec_protocol_options_t nw_quic_copy_sec_protocol_options(nw_protocol_options_t options)
{
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = options;
  if (nw_protocol_options_is_quic(v1))
  {
    if (nw_protocol_options_is_quic_stream(v1))
    {
      v2 = nw_quic_stream_copy_shared_connection_options(v1);

      v1 = v2;
    }
    v3 = nw_quic_connection_copy_sec_protocol_options(v1);
    goto LABEL_5;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_copy_sec_protocol_options";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_copy_sec_protocol_options";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_options_is_quic(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_copy_sec_protocol_options";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_copy_sec_protocol_options";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_copy_sec_protocol_options";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_5:

  return v3;
}

void sub_1838DAF80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_quic_stream_copy_shared_connection_options(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_copy_shared_connection_options_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_copy_shared_connection_options";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_copy_shared_connection_options";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_stream(stream_options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_copy_shared_connection_options";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(stream_options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_copy_shared_connection_options";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(stream_options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_copy_shared_connection_options";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_stream(stream_options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838DB2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_copy_shared_connection_options_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 16));
  return 1;
}

void nw_quic_connection_set_override_trust_certs_for_tests(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_override_trust_certs_for_tests_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_override_trust_certs_for_tests";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_override_trust_certs_for_tests";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_override_trust_certs_for_tests";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_override_trust_certs_for_tests";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_override_trust_certs_for_tests";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DB5D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_override_trust_certs_for_tests_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_quic_connection_set_trust_certs_internal(a2, *(unsigned __int8 *)(a1 + 32));
  return 1;
}

void nw_quic_connection_add_h3_alpn(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_add_h3_alpn_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_add_h3_alpn";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_add_h3_alpn";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_add_h3_alpn";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_add_h3_alpn";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_add_h3_alpn";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DB8D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_add_h3_alpn_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;

  if (*(_BYTE *)(a1 + 32))
  {
    sec_protocol_options_add_transport_specific_application_protocol();
    *(_WORD *)(a2 + 215) |= 0x800u;
  }
  else
  {
    v3 = *(unsigned __int16 *)(a2 + 215);
    v4 = *(unsigned __int8 *)(a2 + 217);
    *(_WORD *)(a2 + 215) = v3 & 0xF7FF;
    *(_BYTE *)(a2 + 217) = (v3 & 0xFFFFF7FF | (v4 << 16)) >> 16;
  }
  return 1;
}

void nw_quic_connection_set_server_raw_public_keys(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_server_raw_public_keys_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_server_raw_public_keys";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_server_raw_public_keys";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_server_raw_public_keys";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_server_raw_public_keys";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_server_raw_public_keys";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DBC18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_server_raw_public_keys_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;
  const void *v4;

  v3 = *(const void **)(a1 + 32);
  v4 = *(const void **)(a2 + 104);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 104) = 0;
  }
  if (v3 && CFArrayGetCount((CFArrayRef)v3) >= 1)
  {
    *(_QWORD *)(a2 + 104) = CFRetain(v3);
    sec_protocol_options_set_server_raw_public_key_certificates();
  }
  return 1;
}

void nw_quic_connection_set_client_identity_reference(void *a1, uint64_t a2, uint64_t a3)
{
  id v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[6];
  char v15;
  os_log_type_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (nw_protocol_options_is_quic_connection(v5))
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_quic_connection_set_client_identity_reference_block_invoke;
    v14[3] = &__block_descriptor_48_e9_B16__0_v8l;
    v14[4] = a2;
    v14[5] = a3;
    nw_protocol_options_access_handle(v5, v14);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_client_identity_reference";
  v7 = (char *)_os_log_send_and_compose_impl();

  v16 = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_client_identity_reference";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v16;
      v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_client_identity_reference";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_client_identity_reference";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_client_identity_reference";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_1838DBF58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_client_identity_reference_block_invoke(uint64_t a1, uint64_t a2)
{
  nw_quic_connection_set_client_identity_reference_internal(a2, *(const void **)(a1 + 32), *(CFTypeRef *)(a1 + 40), 1);
  return 1;
}

BOOL nw_quic_connection_fetch_client_identity_reference(void *a1, const unsigned __int8 *a2)
{
  id v3;
  _BOOL8 v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[6];
  char v20;
  os_log_type_t type;
  _BYTE buf[24];
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    if (!uuid_is_null(a2))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v23 = 1;
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3221225472;
      v19[2] = __nw_quic_connection_fetch_client_identity_reference_block_invoke;
      v19[3] = &unk_1E14AA1B0;
      v19[4] = buf;
      v19[5] = a2;
      nw_protocol_options_access_handle(v3, v19);
      v4 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null !uuid_is_null(proxy_uuid)", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null !uuid_is_null(proxy_uuid), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null !uuid_is_null(proxy_uuid), no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s called with null !uuid_is_null(proxy_uuid), dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_quic_connection_fetch_client_identity_reference";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_4:

  return v4;
}

void sub_1838DC4A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_fetch_client_identity_reference_block_invoke(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v7;
  const __CFAllocator *v8;
  const __CFData *ValueAtIndex;
  void *v10;
  void *v11;
  __SecIdentity *v12;
  NSObject *v13;
  NSObject *v14;
  void *v15;
  id v16;
  __SecIdentity *v17;
  __SecIdentity *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  __SecIdentity *v22;
  NSObject *v23;
  NSObject *v24;
  id v26[6];
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  char v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  __SecIdentity *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a2 + 112))
  {
    v27 = 0;
    v28 = &v27;
    v29 = 0x2020000000;
    v30 = 0;
    v26[1] = (id)MEMORY[0x1E0C809B0];
    v26[2] = (id)3221225472;
    v26[3] = __nw_quic_connection_fetch_client_identity_reference_block_invoke_2;
    v26[4] = &unk_1E14A9D68;
    v26[5] = &v27;
    sec_protocol_options_access_handle();
    if (!*((_BYTE *)v28 + 24))
    {
      v4 = *(const __CFArray **)(a2 + 120);
      if (v4 && (Count = CFArrayGetCount(v4), Count >= 1))
      {
        Mutable = 0;
        v7 = 0;
        v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        while (1)
        {
          ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), v7);
          CFDataGetBytePtr(ValueAtIndex);
          CFDataGetLength(ValueAtIndex);
          v10 = (void *)NEHelperCopyDataForCertificate();
          v11 = v10;
          if (!v10)
            break;
          xpc_data_get_bytes_ptr(v10);
          xpc_data_get_length(v11);
          v12 = (__SecIdentity *)SecCertificateCreateWithBytes();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = (id)gLogObj;
          v14 = v13;
          if (!v12)
          {
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v32 = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
              _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s Failed to create certificate from data", buf, 0xCu);
            }
            goto LABEL_20;
          }
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
            v33 = 2112;
            v34 = v12;
            _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEBUG, "%{public}s Fetched certificate %@ from NEHelper", buf, 0x16u);
          }

          if (!Mutable)
            Mutable = CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
          CFArrayAppendValue(Mutable, v12);
          CFRelease(v12);

          if (Count == ++v7)
            goto LABEL_21;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v14 = (id)gLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v32 = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
          _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s Failed to fetch certificate from NEHelper", buf, 0xCu);
        }
        v11 = 0;
LABEL_20:

        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      }
      else
      {
        Mutable = 0;
      }
LABEL_21:
      CFDataGetBytePtr(*(CFDataRef *)(a2 + 112));
      CFDataGetLength(*(CFDataRef *)(a2 + 112));
      v15 = (void *)NEHelperCopyXPCEndpointForIdentityProxy();
      if (v15)
      {
        v16 = objc_alloc_init(MEMORY[0x1E0CB3B60]);
        objc_msgSend(v16, "_setEndpoint:", v15);
        v26[0] = 0;
        v17 = (__SecIdentity *)objc_msgSend(MEMORY[0x1E0CD5C88], "createIdentityFromEndpoint:error:", v16, v26);
        v18 = (__SecIdentity *)v26[0];
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v20 = v19;
        if (v18)
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
            v33 = 2112;
            v34 = v18;
            _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_ERROR, "%{public}s Failed to fetch identity from NEHelper: %@", buf, 0x16u);
          }

          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
        }
        else
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            v32 = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
            v33 = 2112;
            v34 = v17;
            _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Fetched identity %@ from NEHelper", buf, 0x16u);
          }

        }
        if (v17)
        {
          if (Mutable)
            v23 = sec_identity_create_with_certificates(v17, Mutable);
          else
            v23 = sec_identity_create(v17);
          v24 = v23;
          sec_protocol_options_set_local_identity(*(sec_protocol_options_t *)(a2 + 96), v23);

          CFRelease(v17);
        }
        if (Mutable)
          CFRelease(Mutable);

      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (id)gLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          v22 = *(__SecIdentity **)(a2 + 112);
          *(_DWORD *)buf = 136446466;
          v32 = "nw_quic_connection_fetch_client_identity_reference_block_invoke";
          v33 = 2112;
          v34 = v22;
          _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s Unable to copy xpc endpoint for client identity %@", buf, 0x16u);
        }

        if (Mutable)
          CFRelease(Mutable);
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      }

    }
    _Block_object_dispose(&v27, 8);
  }
  return 1;
}

void sub_1838DCA54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_fetch_client_identity_reference_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 56))
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return 1;
}

uint64_t nw_quic_connection_get_selected_key_index(void *a1)
{
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  _QWORD v15[5];
  char v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  _BYTE v21[24];
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic(v1))
  {
    if (nw_protocol_options_is_quic_stream(v1))
    {
      v2 = nw_quic_stream_copy_shared_connection_options(v1);

      v1 = v2;
    }
    *(_QWORD *)v21 = 0;
    *(_QWORD *)&v21[8] = v21;
    *(_QWORD *)&v21[16] = 0x2020000000;
    v22 = -1;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __nw_quic_connection_get_selected_key_index_block_invoke;
    v15[3] = &unk_1E14A9D68;
    v15[4] = v21;
    nw_protocol_options_access_handle(v1, v15);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v4 = *(unsigned __int8 *)(*(_QWORD *)&v21[8] + 24);
      *(_DWORD *)buf = 136446466;
      v18 = "nw_quic_connection_get_selected_key_index";
      v19 = 1024;
      v20 = v4;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s Getting key index=%d", buf, 0x12u);
    }

    v5 = *(unsigned __int8 *)(*(_QWORD *)&v21[8] + 24);
    _Block_object_dispose(v21, 8);
    goto LABEL_7;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)v21 = 136446210;
  *(_QWORD *)&v21[4] = "nw_quic_connection_get_selected_key_index";
  v8 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  v16 = 0;
  if (__nwlog_fault(v8, buf, &v16))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = buf[0];
      if (os_log_type_enabled(v9, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v21 = 136446210;
        *(_QWORD *)&v21[4] = "nw_quic_connection_get_selected_key_index";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null nw_protocol_options_is_quic(options)", v21, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = buf[0];
      v13 = os_log_type_enabled(v9, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)v21 = 136446466;
          *(_QWORD *)&v21[4] = "nw_quic_connection_get_selected_key_index";
          *(_WORD *)&v21[12] = 2082;
          *(_QWORD *)&v21[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s", v21, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)v21 = 136446210;
        *(_QWORD *)&v21[4] = "nw_quic_connection_get_selected_key_index";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace", v21, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = buf[0];
      if (os_log_type_enabled(v9, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v21 = 136446210;
        *(_QWORD *)&v21[4] = "nw_quic_connection_get_selected_key_index";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded", v21, 0xCu);
      }
    }

  }
LABEL_24:
  if (v8)
    free(v8);
  v5 = 255;
LABEL_7:

  return v5;
}

void sub_1838DCE98(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  _Block_object_dispose((const void *)(v2 - 96), 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_selected_key_index_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 214);
  return 1;
}

void nw_quic_connection_set_local_identity(void *a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  os_log_type_t v30;
  os_log_type_t v31;
  _QWORD v32[4];
  id v33;
  char v34;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v5 = nw_utilities_public_key_info_for_sec_identity(v4);
    if (v5)
    {
      v6 = nw_quic_copy_sec_protocol_options(v3);
      v7 = v6;
      if (v6)
      {
        sec_protocol_options_set_local_identity(v6, v4);
        v32[0] = MEMORY[0x1E0C809B0];
        v32[1] = 3221225472;
        v32[2] = __nw_quic_connection_set_local_identity_block_invoke;
        v32[3] = &unk_1E14A9F20;
        v33 = v5;
        nw_protocol_options_access_handle(v3, v32);

LABEL_5:
LABEL_6:

        goto LABEL_7;
      }
      __nwlog_obj();
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v37 = "nw_quic_connection_set_local_identity";
      v17 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v34 = 0;
      if (__nwlog_fault(v17, &type, &v34))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "nw_quic_connection_set_local_identity";
            _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null sec_options", buf, 0xCu);
          }
        }
        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v27 = type;
          v28 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v28)
            {
              *(_DWORD *)buf = 136446466;
              v37 = "nw_quic_connection_set_local_identity";
              v38 = 2082;
              v39 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s called with null sec_options, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_60;
          }
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            v37 = "nw_quic_connection_set_local_identity";
            _os_log_impl(&dword_182FBE000, v18, v27, "%{public}s called with null sec_options, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v18 = objc_claimAutoreleasedReturnValue();
          v31 = type;
          if (os_log_type_enabled(v18, type))
          {
            *(_DWORD *)buf = 136446210;
            v37 = "nw_quic_connection_set_local_identity";
            _os_log_impl(&dword_182FBE000, v18, v31, "%{public}s called with null sec_options, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_60:
      if (v17)
        free(v17);
      goto LABEL_5;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v37 = "nw_quic_connection_set_local_identity";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v34 = 0;
    if (__nwlog_fault(v13, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_quic_connection_set_local_identity";
          _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null publicKeyInfo", buf, 0xCu);
        }
      }
      else if (v34)
      {
        v23 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        v25 = os_log_type_enabled(v14, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            v37 = "nw_quic_connection_set_local_identity";
            v38 = 2082;
            v39 = v23;
            _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s called with null publicKeyInfo, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v23);
          goto LABEL_55;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_quic_connection_set_local_identity";
          _os_log_impl(&dword_182FBE000, v14, v24, "%{public}s called with null publicKeyInfo, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v30 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v37 = "nw_quic_connection_set_local_identity";
          _os_log_impl(&dword_182FBE000, v14, v30, "%{public}s called with null publicKeyInfo, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_55:
    if (v13)
      free(v13);
    goto LABEL_6;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v37 = "nw_quic_connection_set_local_identity";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v34 = 0;
  if (__nwlog_fault(v9, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_quic_connection_set_local_identity";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v34)
    {
      v20 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      v22 = os_log_type_enabled(v10, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "nw_quic_connection_set_local_identity";
          v38 = 2082;
          v39 = v20;
          _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
        goto LABEL_50;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_quic_connection_set_local_identity";
        _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v37 = "nw_quic_connection_set_local_identity";
        _os_log_impl(&dword_182FBE000, v10, v29, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_50:
  if (v9)
    free(v9);
LABEL_7:

}

void sub_1838DD60C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_local_identity_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;

  v4 = *(const void **)(a2 + 128);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 128) = 0;
  }
  *(_QWORD *)(a2 + 128) = *(id *)(a1 + 32);
  return 1;
}

id nw_quic_connection_copy_local_public_key(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_copy_local_public_key_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_copy_local_public_key";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_local_public_key";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_copy_local_public_key";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_local_public_key";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_copy_local_public_key";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838DD9AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_copy_local_public_key_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 128));
  return 1;
}

void nw_quic_connection_set_trusted_peer_keys(void *a1, void *a2, void *a3)
{
  NSObject *v5;
  id v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _QWORD verify_block[4];
  id v19;
  id v20;
  char v21;
  os_log_type_t type;
  _BYTE location[12];
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (nw_protocol_options_is_quic(v5))
  {
    if (nw_protocol_options_is_quic_stream(v5))
    {
      v8 = nw_quic_stream_copy_shared_connection_options(v5);

      v5 = v8;
    }
    if (nw_protocol_options_access_handle(v5, &__block_literal_global_17_55263))
    {
      v9 = nw_quic_copy_sec_protocol_options(v5);
      objc_initWeak((id *)location, v5);
      verify_block[0] = MEMORY[0x1E0C809B0];
      verify_block[1] = 3221225472;
      verify_block[2] = __nw_quic_connection_set_trusted_peer_keys_block_invoke_18;
      verify_block[3] = &unk_1E14A4E38;
      v19 = v6;
      objc_copyWeak(&v20, (id *)location);
      sec_protocol_options_set_verify_block(v9, verify_block, v7);
      objc_destroyWeak(&v20);

      objc_destroyWeak((id *)location);
    }
    goto LABEL_6;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)location = 136446210;
  *(_QWORD *)&location[4] = "nw_quic_connection_set_trusted_peer_keys";
  v11 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (__nwlog_fault(v11, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_quic_connection_set_trusted_peer_keys";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null nw_protocol_options_is_quic(options)", location, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)location = 136446466;
          *(_QWORD *)&location[4] = "nw_quic_connection_set_trusted_peer_keys";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s", location, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v16)
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_quic_connection_set_trusted_peer_keys";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace", location, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)location = 136446210;
        *(_QWORD *)&location[4] = "nw_quic_connection_set_trusted_peer_keys";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded", location, 0xCu);
      }
    }

  }
LABEL_23:
  if (v11)
    free(v11);
LABEL_6:

}

void sub_1838DDD7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,id location)
{
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  id *v25;

  objc_destroyWeak(v25);

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void __nw_quic_connection_set_trusted_peer_keys_block_invoke_18(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6;
  void (**v7)(id, uint64_t);
  uint64_t v8;
  id WeakRetained;
  void *v10;
  int v11;
  id v12;
  BOOL is_quic_stream;
  void *v14;
  id v15;
  NSObject *v16;
  void *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  char *backtrace_string;
  os_log_type_t v22;
  _BOOL4 v23;
  os_log_type_t v24;
  unsigned __int8 v25;
  char v26;
  os_log_type_t type;
  _BYTE buf[24];
  void *v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v6 = a3;
  v7 = a4;
  v25 = -1;
  v8 = nw_utilities_trust_ref_matches_public_key(v6, *(void **)(a1 + 32), &v25);
  v7[2](v7, v8);
  if (v25 != 255)
  {
    WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
    v10 = WeakRetained;
    if (!WeakRetained)
    {
LABEL_12:

      goto LABEL_13;
    }
    v11 = v25;
    v12 = WeakRetained;
    if (nw_protocol_options_is_quic_connection(v12))
    {

LABEL_6:
      v14 = v12;
      if (nw_protocol_options_is_quic_stream(v12))
      {
        v15 = nw_quic_stream_copy_shared_connection_options(v12);

        v14 = v15;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_quic_connection_set_selected_key_index";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v11;
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s Setting key index=%d", buf, 0x12u);
      }

      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = ___ZL41nw_quic_connection_set_selected_key_indexPU33objcproto22OS_nw_protocol_options8NSObjecth_block_invoke;
      v29 = &__block_descriptor_33_e9_B16__0_v8l;
      v30 = v11;
      nw_protocol_options_access_handle(v14, buf);
LABEL_11:

      goto LABEL_12;
    }
    is_quic_stream = nw_protocol_options_is_quic_stream(v12);

    if (is_quic_stream)
      goto LABEL_6;
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_quic_connection_set_selected_key_index";
    v18 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_set_selected_key_index";
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null nw_protocol_options_is_quic(options)", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v22 = type;
        v23 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_quic_connection_set_selected_key_index";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_set_selected_key_index";
          _os_log_impl(&dword_182FBE000, v19, v22, "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v19 = objc_claimAutoreleasedReturnValue();
        v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_quic_connection_set_selected_key_index";
          _os_log_impl(&dword_182FBE000, v19, v24, "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_30:
    if (v18)
      free(v18);
    v14 = v12;
    goto LABEL_11;
  }
LABEL_13:

}

void sub_1838DE1D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_quic_connection_set_selected_key_indexPU33objcproto22OS_nw_protocol_options8NSObjecth_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 214) = *(_BYTE *)(a1 + 32);
  return 1;
}

BOOL __nw_quic_connection_set_trusted_peer_keys_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a2 + 128);
  if (v2)
  {
    CFRelease(*(CFTypeRef *)(a2 + 128));
    *(_QWORD *)(a2 + 128) = 0;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = 136446210;
      v7 = "nw_quic_connection_set_trusted_peer_keys_block_invoke";
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_ERROR, "%{public}s Not setting verify block, local_public_key is NULL", (uint8_t *)&v6, 0xCu);
    }

  }
  return v2 != 0;
}

void nw_quic_connection_set_use_swift_tls(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_use_swift_tls_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_use_swift_tls";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_use_swift_tls";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_use_swift_tls";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_use_swift_tls";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_use_swift_tls";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DE5D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_use_swift_tls_block_invoke(uint64_t a1, uint64_t a2, double a3)
{
  int v3;
  int v4;
  unsigned int v6;
  NWConcrete_nw_protocol_options *options;
  void *v8;

  v3 = *(unsigned __int8 *)(a1 + 32);
  v4 = *(unsigned __int16 *)(a2 + 215);
  if ((*(_BYTE *)(a1 + 32) != 0) == ((v4 & 0x1000) == 0))
  {
    v6 = v4 & 0xFFFFEFFF | (*(unsigned __int8 *)(a2 + 217) << 16);
    *(_BYTE *)(a2 + 217) = BYTE2(v6);
    *(_WORD *)(a2 + 215) = v6 | ((v3 != 0) << 12);
    if (v3)
    {
      options = nw_swift_tls_create_options(a3);
    }
    else
    {
      v8 = (void *)nw_protocol_boringssl_copy_definition();
      options = nw_protocol_create_options(v8);

    }
    objc_storeStrong((id *)(a2 + 96), options);

  }
  return 1;
}

void sub_1838DE680(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_use_x25519(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_use_x25519_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_use_x25519";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_use_x25519";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_use_x25519";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_use_x25519";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_use_x25519";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DE95C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_use_x25519_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  unsigned int v4;

  v2 = *(unsigned __int8 *)(a1 + 32);
  v3 = *(unsigned __int16 *)(a2 + 215);
  if ((*(_BYTE *)(a1 + 32) != 0) == ((v3 & 0x2000) == 0))
  {
    v4 = v3 & 0xFFFFDFFF | (*(unsigned __int8 *)(a2 + 217) << 16);
    *(_BYTE *)(a2 + 217) = BYTE2(v4);
    *(_WORD *)(a2 + 215) = v4 | ((v2 != 0) << 13);
    if (v2)
      sec_protocol_options_add_tls_key_exchange_group();
  }
  return 1;
}

void nw_quic_clear_tls_application_protocols(void *a1)
{
  NSObject *v1;
  NSObject *v2;
  void *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic(v1))
  {
    if (nw_protocol_options_is_quic_stream(v1))
    {
      v2 = nw_quic_stream_copy_shared_connection_options(v1);

      v1 = v2;
    }
    nw_protocol_options_access_handle(v1, &__block_literal_global_20);
    goto LABEL_5;
  }
  __nwlog_obj();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_quic_clear_tls_application_protocols";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_quic_clear_tls_application_protocols";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null nw_protocol_options_is_quic(options)", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_quic_clear_tls_application_protocols";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_quic_clear_tls_application_protocols";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_quic_clear_tls_application_protocols";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v4)
    free(v4);
LABEL_5:

}

void sub_1838DEC90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_clear_tls_application_protocols_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 96))
    sec_protocol_options_clear_tls_application_protocols();
  return 1;
}

void nw_quic_iterate_tls_application_protocols(void *a1, void *a2)
{
  NSObject *v3;
  id v4;
  sec_protocol_options_t v5;
  void *v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _QWORD applier[4];
  id v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_options_is_quic(v3))
  {
    v5 = nw_quic_copy_sec_protocol_options(v3);
    v6 = (void *)sec_protocol_options_copy_transport_specific_application_protocol();
    v7 = v6;
    if (v6 && object_getClass(v6) == (Class)MEMORY[0x1E0C812C8])
    {
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 3221225472;
      applier[2] = __nw_quic_iterate_tls_application_protocols_block_invoke;
      applier[3] = &unk_1E14A4E60;
      v17 = v4;
      xpc_array_apply(v7, applier);

    }
    goto LABEL_6;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v21 = "nw_quic_iterate_tls_application_protocols";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v9, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_quic_iterate_tls_application_protocols";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null nw_protocol_options_is_quic(options)", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v21 = "nw_quic_iterate_tls_application_protocols";
          v22 = 2082;
          v23 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_quic_iterate_tls_application_protocols";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v21 = "nw_quic_iterate_tls_application_protocols";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v9)
    free(v9);
LABEL_6:

}

void sub_1838DEFE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_iterate_tls_application_protocols_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;

  v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1E0C81390])
  {
    xpc_string_get_string_ptr(v4);
    v5 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  else
  {
    v5 = 1;
  }

  return v5;
}

void sub_1838DF088(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double ___ZL44nw_protocol_dummy_quic_connection_identifierv_block_invoke()
{
  double result;

  strcpy((char *)&nw_protocol_dummy_quic_connection_identifier(void)::dummy_quic_connection_identifier, "quic-connection");
  *(_QWORD *)&result = 0x200000003;
  qword_1EDCF2298 = 0x200000003;
  return result;
}

double ___ZL40nw_protocol_dummy_quic_stream_identifierv_block_invoke()
{
  double result;

  strcpy((char *)&nw_protocol_dummy_quic_stream_identifier(void)::dummy_quic_stream_identifier, "quic");
  *(_QWORD *)&result = 0x200000003;
  qword_1EDCF22C8 = 0x200000003;
  return result;
}

void nw_quic_connection_set_initial_max_data(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_max_data_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_initial_max_data";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_data";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_initial_max_data";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_data";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_data";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DF3B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_initial_max_data_block_invoke(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_initial_max_data(nw_protocol_options_t options, uint64_t initial_max_data)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_initial_max_data(v3, initial_max_data);

}

void sub_1838DF410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_initial_max_data(nw_protocol_options_t options)
{
  id v1;
  uint64_t initial_max_data;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  initial_max_data = nw_quic_connection_get_initial_max_data(v1);

  return initial_max_data;
}

void sub_1838DF454(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_set_initial_max_streams_bidirectional(nw_protocol_options_t options, uint64_t initial_max_streams_bidirectional)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_initial_max_streams_bidirectional(v3, initial_max_streams_bidirectional);

}

void sub_1838DF49C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_initial_max_streams_bidirectional(nw_protocol_options_t options)
{
  id v1;
  uint64_t initial_max_streams_bidirectional;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  initial_max_streams_bidirectional = nw_quic_connection_get_initial_max_streams_bidirectional(v1);

  return initial_max_streams_bidirectional;
}

void sub_1838DF4E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_set_initial_max_streams_unidirectional(nw_protocol_options_t options, uint64_t initial_max_streams_unidirectional)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_initial_max_streams_unidirectional(v3, initial_max_streams_unidirectional);

}

void sub_1838DF528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_initial_max_streams_unidirectional(nw_protocol_options_t options)
{
  id v1;
  uint64_t initial_max_streams_unidirectional;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  initial_max_streams_unidirectional = nw_quic_connection_get_initial_max_streams_unidirectional(v1);

  return initial_max_streams_unidirectional;
}

void sub_1838DF56C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_initial_max_stream_data_bidirectional_local(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_max_stream_data_bidirectional_local_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DF848(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_initial_max_stream_data_bidirectional_local_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_initial_max_stream_data_bidirectional_local(nw_protocol_options_t options, uint64_t initial_max_stream_data_bidirectional_local)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_initial_max_stream_data_bidirectional_local(v3, initial_max_stream_data_bidirectional_local);

}

void sub_1838DF8A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_initial_max_stream_data_bidirectional_local(nw_protocol_options_t options)
{
  id v1;
  uint64_t initial_max_stream_data_bidirectional_local;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  initial_max_stream_data_bidirectional_local = nw_quic_connection_get_initial_max_stream_data_bidirectional_local(v1);

  return initial_max_stream_data_bidirectional_local;
}

void sub_1838DF8E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_initial_max_stream_data_bidirectional_remote(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_max_stream_data_bidirectional_remote_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_remote";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_remote";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DFBC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_initial_max_stream_data_bidirectional_remote_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t options, uint64_t initial_max_stream_data_bidirectional_remote)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_initial_max_stream_data_bidirectional_remote(v3, initial_max_stream_data_bidirectional_remote);

}

void sub_1838DFC18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_initial_max_stream_data_bidirectional_remote(nw_protocol_options_t options)
{
  id v1;
  uint64_t initial_max_stream_data_bidirectional_remote;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  initial_max_stream_data_bidirectional_remote = nw_quic_connection_get_initial_max_stream_data_bidirectional_remote(v1);

  return initial_max_stream_data_bidirectional_remote;
}

void sub_1838DFC5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_initial_max_stream_data_unidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_max_stream_data_unidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_initial_max_stream_data_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_initial_max_stream_data_unidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_initial_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838DFF38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_initial_max_stream_data_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_initial_max_stream_data_unidirectional(nw_protocol_options_t options, uint64_t initial_max_stream_data_unidirectional)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_initial_max_stream_data_unidirectional(v3, initial_max_stream_data_unidirectional);

}

void sub_1838DFF90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_initial_max_stream_data_unidirectional(nw_protocol_options_t options)
{
  id v1;
  uint64_t initial_max_stream_data_unidirectional;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  initial_max_stream_data_unidirectional = nw_quic_connection_get_initial_max_stream_data_unidirectional(v1);

  return initial_max_stream_data_unidirectional;
}

void sub_1838DFFD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_set_idle_timeout(nw_protocol_options_t options, uint32_t idle_timeout)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_idle_timeout(v3, idle_timeout);

}

void sub_1838E001C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint32_t nw_quic_get_idle_timeout(nw_protocol_options_t options)
{
  id v1;
  uint32_t idle_timeout;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  idle_timeout = nw_quic_connection_get_idle_timeout(v1);

  return idle_timeout;
}

void sub_1838E0060(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_stream_path_affinity(void *a1, int a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  int v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_stream_path_affinity_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_stream_path_affinity";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_stream_path_affinity";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_stream_path_affinity";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_stream_path_affinity";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_stream_path_affinity";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E033C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_stream_path_affinity_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 196) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_stream_path_affinity(void *a1, int a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_stream_path_affinity(v3, a2);

}

void sub_1838E0394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_stream_path_affinity(void *a1)
{
  id v1;
  uint64_t stream_path_affinity;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  stream_path_affinity = nw_quic_connection_get_stream_path_affinity(v1);

  return stream_path_affinity;
}

void sub_1838E03D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_udp_payload_size(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  __int16 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_max_udp_payload_size_block_invoke;
    v12[3] = &__block_descriptor_34_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_max_udp_payload_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_udp_payload_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_max_udp_payload_size";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_udp_payload_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_udp_payload_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E06B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_udp_payload_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 204) = *(_WORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_max_udp_payload_size(nw_protocol_options_t options, uint16_t max_udp_payload_size)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_max_udp_payload_size(v3, max_udp_payload_size);

}

void sub_1838E070C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint16_t nw_quic_get_max_udp_payload_size(nw_protocol_options_t options)
{
  id v1;
  uint16_t max_udp_payload_size;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  max_udp_payload_size = nw_quic_connection_get_max_udp_payload_size(v1);

  return max_udp_payload_size;
}

void sub_1838E0750(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_datagram_frame_size(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  __int16 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_max_datagram_frame_size_block_invoke;
    v12[3] = &__block_descriptor_34_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_max_datagram_frame_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_max_datagram_frame_size";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E0A2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_datagram_frame_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 206) = *(_WORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_max_datagram_frame_size(nw_protocol_options_t options, uint16_t max_datagram_frame_size)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(options);
  nw_quic_connection_set_max_datagram_frame_size(v3, max_datagram_frame_size);

}

void sub_1838E0A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint16_t nw_quic_get_max_datagram_frame_size(nw_protocol_options_t options)
{
  id v1;
  uint16_t max_datagram_frame_size;

  v1 = nw_quic_stream_copy_shared_connection_options(options);
  max_datagram_frame_size = nw_quic_connection_get_max_datagram_frame_size(v1);

  return max_datagram_frame_size;
}

void sub_1838E0AC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_initial_packet_size(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  __int16 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_initial_packet_size_block_invoke;
    v12[3] = &__block_descriptor_34_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_initial_packet_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_initial_packet_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_initial_packet_size";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_initial_packet_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_initial_packet_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E0DA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_initial_packet_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 208) = *(_WORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_initial_packet_size(void *a1, __int16 a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_initial_packet_size(v3, a2);

}

void sub_1838E0DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_initial_packet_size(void *a1)
{
  id v1;
  uint64_t initial_packet_size;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  initial_packet_size = nw_quic_connection_get_initial_packet_size(v1);

  return initial_packet_size;
}

void sub_1838E0E40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_set_keepalive_count(void *a1, __int16 a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_keepalive_count(v3, a2);

}

void sub_1838E0E88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_keepalive_count(void *a1)
{
  id v1;
  uint64_t keepalive_count;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  keepalive_count = nw_quic_connection_get_keepalive_count(v1);

  return keepalive_count;
}

void sub_1838E0ECC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_ack_delay_size(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_ack_delay_size_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_ack_delay_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_ack_delay_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_ack_delay_size";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_ack_delay_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_ack_delay_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E11A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_ack_delay_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 212) = *(_BYTE *)(a1 + 32);
  return 1;
}

void nw_quic_set_ack_delay_size(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_ack_delay_size(v3, a2);

}

void sub_1838E1200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_ack_delay_size(void *a1)
{
  id v1;
  uint64_t ack_delay_size;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  ack_delay_size = nw_quic_connection_get_ack_delay_size(v1);

  return ack_delay_size;
}

void sub_1838E1244(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_source_connection_id(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_set_source_connection_id_block_invoke;
    v13[3] = &unk_1E14A9F20;
    v14 = v4;
    nw_protocol_options_access_handle(v3, v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_source_connection_id";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_source_connection_id";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_source_connection_id";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_source_connection_id";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_source_connection_id";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1838E1538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_source_connection_id_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 152), *(id *)(a1 + 32));
  return 1;
}

void nw_quic_set_source_connection_id(void *a1, void *a2)
{
  id v3;
  id v4;

  v4 = a2;
  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_source_connection_id(v3, v4);

}

void sub_1838E15CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

id nw_quic_get_source_connection_id(void *a1)
{
  id v1;
  id source_connection_id;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  source_connection_id = nw_quic_connection_get_source_connection_id(v1);

  return source_connection_id;
}

void sub_1838E161C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_paths_per_interface(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_max_paths_per_interface_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_max_paths_per_interface";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_paths_per_interface";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_max_paths_per_interface";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_paths_per_interface";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_max_paths_per_interface";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E18F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_paths_per_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 213) = *(_BYTE *)(a1 + 32);
  return 1;
}

void nw_quic_set_max_paths_per_interface(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_max_paths_per_interface(v3, a2);

}

void sub_1838E1950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_max_paths_per_interface(void *a1)
{
  id v1;
  uint64_t max_paths_per_interface;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  max_paths_per_interface = nw_quic_connection_get_max_paths_per_interface(v1);

  return max_paths_per_interface;
}

void sub_1838E1994(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_pmtud(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_pmtud_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_pmtud";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_pmtud";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E1C70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_pmtud_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 215) = *(_WORD *)(a2 + 215) & 0xFFFE | *(unsigned __int8 *)(a1 + 32);
  return 1;
}

void nw_quic_set_pmtud(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_pmtud(v3, a2);

}

void sub_1838E1CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_pmtud(void *a1)
{
  id v1;
  _BOOL8 pmtud;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  pmtud = nw_quic_connection_get_pmtud(v1);

  return pmtud;
}

void sub_1838E1D18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_pmtud_ignore_cost(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_pmtud_ignore_cost_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_pmtud_ignore_cost";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud_ignore_cost";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_pmtud_ignore_cost";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud_ignore_cost";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud_ignore_cost";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E1FF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_pmtud_ignore_cost_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFFFD | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFFD | (2 * (*(_BYTE *)(a1 + 32) & 0x7F));
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_pmtud_ignore_cost(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_pmtud_ignore_cost(v3, a2);

}

void sub_1838E206C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_pmtud_ignore_cost(void *a1)
{
  id v1;
  _BOOL8 pmtud_ignore_cost;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  pmtud_ignore_cost = nw_quic_connection_get_pmtud_ignore_cost(v1);

  return pmtud_ignore_cost;
}

void sub_1838E20B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_pmtud_for_non_transport(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_pmtud_for_non_transport_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_pmtud_for_non_transport";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_pmtud_for_non_transport";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_pmtud_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E238C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_pmtud_for_non_transport_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFFFB | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFFB | (4 * (*(_BYTE *)(a1 + 32) & 0x3F));
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

BOOL nw_quic_connection_get_pmtud_for_non_transport(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_pmtud_for_non_transport_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_for_non_transport";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_for_non_transport";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_pmtud_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838E26CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_pmtud_for_non_transport_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 215) & 4) != 0;
  return 1;
}

void nw_quic_set_pmtud_for_non_transport(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_pmtud_for_non_transport(v3, a2);

}

void sub_1838E274C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_pmtud_for_non_transport(void *a1)
{
  id v1;
  _BOOL8 pmtud_for_non_transport;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  pmtud_for_non_transport = nw_quic_connection_get_pmtud_for_non_transport(v1);

  return pmtud_for_non_transport;
}

void sub_1838E2790(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_migration_for_non_transport(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_migration_for_non_transport_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_migration_for_non_transport";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_migration_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_migration_for_non_transport";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_migration_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_migration_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E2A6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_migration_for_non_transport_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFBFFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 14);
  *(_WORD *)v2 = v3 & 0xBFFF | (*(unsigned __int8 *)(a1 + 32) << 14);
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

BOOL nw_quic_connection_get_migration_for_non_transport(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_migration_for_non_transport_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_migration_for_non_transport";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_migration_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_migration_for_non_transport";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_migration_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_migration_for_non_transport";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838E2DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_migration_for_non_transport_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 215) & 0x4000) != 0;
  return 1;
}

void nw_quic_set_migration_for_non_transport(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_migration_for_non_transport(v3, a2);

}

void sub_1838E2E28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_migration_for_non_transport(void *a1)
{
  id v1;
  _BOOL8 migration_for_non_transport;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  migration_for_non_transport = nw_quic_connection_get_migration_for_non_transport(v1);

  return migration_for_non_transport;
}

void sub_1838E2E6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_retry(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_retry_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_retry";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_retry";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_retry";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_retry";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_retry";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E3148(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_retry_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFFF7 | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFF7 | (8 * (*(_BYTE *)(a1 + 32) & 0x1F));
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

BOOL nw_quic_connection_get_retry(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_retry_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_retry";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_retry";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_retry";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_retry";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_retry";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838E3488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_retry_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 215) & 8) != 0;
  return 1;
}

void nw_quic_set_retry(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_retry(v3, a2);

}

void sub_1838E3508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_retry(void *a1)
{
  id v1;
  _BOOL8 retry;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  retry = nw_quic_connection_get_retry(v1);

  return retry;
}

void sub_1838E354C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_force_version_negotiation(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_force_version_negotiation_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_force_version_negotiation";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_force_version_negotiation";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_force_version_negotiation";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_force_version_negotiation";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_force_version_negotiation";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E3828(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_force_version_negotiation_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFFEF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFEF | (16 * (*(_BYTE *)(a1 + 32) & 0xF));
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_force_version_negotiation(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_force_version_negotiation(v3, a2);

}

void sub_1838E38A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_force_version_negotiation(void *a1)
{
  id v1;
  _BOOL8 force_version_negotiation;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  force_version_negotiation = nw_quic_connection_get_force_version_negotiation(v1);

  return force_version_negotiation;
}

void sub_1838E38E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_datagram_variant_flow_id_enabled(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_datagram_variant_flow_id_enabled_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_datagram_variant_flow_id_enabled";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_variant_flow_id_enabled";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_datagram_variant_flow_id_enabled";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_variant_flow_id_enabled";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_variant_flow_id_enabled";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E3BC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_datagram_variant_flow_id_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFFDF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFDF | (32 * (*(_BYTE *)(a1 + 32) & 7));
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_datagram_variant_flow_id_enabled(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_datagram_variant_flow_id_enabled(v3, a2);

}

void sub_1838E3C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_datagram_variant_flow_id_enabled(void *a1)
{
  id v1;
  _BOOL8 datagram_variant_flow_id_enabled;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  datagram_variant_flow_id_enabled = nw_quic_connection_get_datagram_variant_flow_id_enabled(v1);

  return datagram_variant_flow_id_enabled;
}

void sub_1838E3C7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_datagram_quarter_stream_id(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_datagram_quarter_stream_id_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_datagram_quarter_stream_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_quarter_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_datagram_quarter_stream_id";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_quarter_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_quarter_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E3F58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_datagram_quarter_stream_id_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFFBF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFFBF | ((*(_BYTE *)(a1 + 32) & 3) << 6);
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_datagram_quarter_stream_id(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_datagram_quarter_stream_id(v3, a2);

}

void sub_1838E3FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_datagram_quarter_stream_id(void *a1)
{
  id v1;
  _BOOL8 datagram_quarter_stream_id;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  datagram_quarter_stream_id = nw_quic_connection_get_datagram_quarter_stream_id(v1);

  return datagram_quarter_stream_id;
}

void sub_1838E4014(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_datagram_context_id(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_datagram_context_id_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_datagram_context_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_datagram_context_id";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E42F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_datagram_context_id_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFF7F | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFF7F | ((*(_BYTE *)(a1 + 32) & 1) << 7);
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_datagram_context_id(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_datagram_context_id(v3, a2);

}

void sub_1838E4368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_datagram_context_id(void *a1)
{
  id v1;
  _BOOL8 datagram_context_id;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  datagram_context_id = nw_quic_connection_get_datagram_context_id(v1);

  return datagram_context_id;
}

void sub_1838E43AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_disable_ecn_echo(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_disable_ecn_echo_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_disable_ecn_echo";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_ecn_echo";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_disable_ecn_echo";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_ecn_echo";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_ecn_echo";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E4688(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_disable_ecn_echo_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFEFF | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)v2 = v3 & 0xFEFF | (*(unsigned __int8 *)(a1 + 32) << 8);
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_disable_ecn_echo(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_disable_ecn_echo(v3, a2);

}

void sub_1838E46FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_disable_ecn_echo(void *a1)
{
  id v1;
  _BOOL8 disable_ecn_echo;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  disable_ecn_echo = nw_quic_connection_get_disable_ecn_echo(v1);

  return disable_ecn_echo;
}

void sub_1838E4740(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_disable_ecn(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_disable_ecn_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_disable_ecn";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_disable_ecn";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_ecn";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E4A1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_disable_ecn_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = v3 & 0xFFFFFDFF | (*(unsigned __int8 *)(v2 + 2) << 16) | (*(unsigned __int8 *)(a1 + 32) << 9);
  *(_WORD *)v2 = v3 & 0xFDFF | (*(unsigned __int8 *)(a1 + 32) << 9);
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_disable_ecn(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_disable_ecn(v3, a2);

}

void sub_1838E4A90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_disable_ecn(void *a1)
{
  id v1;
  _BOOL8 disable_ecn;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  disable_ecn = nw_quic_connection_get_disable_ecn(v1);

  return disable_ecn;
}

void sub_1838E4AD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_enable_l4s(void *a1, int a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  int v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_enable_l4s_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_enable_l4s";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_enable_l4s";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_enable_l4s";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E4DB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_enable_l4s_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 200) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_enable_l4s(void *a1, int a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_enable_l4s(v3, a2);

}

void sub_1838E4E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_enable_l4s(void *a1)
{
  id v1;
  uint64_t enable_l4s;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  enable_l4s = nw_quic_connection_get_enable_l4s(v1);

  return enable_l4s;
}

void sub_1838E4E4C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_set_is_speculative_attempt(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_is_speculative_attempt(v3, a2);

}

void sub_1838E4E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_is_speculative_attempt(void *a1)
{
  id v1;
  _BOOL8 is_speculative_attempt;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  is_speculative_attempt = nw_quic_connection_get_is_speculative_attempt(v1);

  return is_speculative_attempt;
}

void sub_1838E4ED8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_disable_spin_bit(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_disable_spin_bit_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_disable_spin_bit";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_spin_bit";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_disable_spin_bit";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_spin_bit";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_disable_spin_bit";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E51B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_disable_spin_bit_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = (v3 | (*(unsigned __int8 *)(v2 + 2) << 16)) & 0xFFFEFFFF | (*(unsigned __int8 *)(a1 + 32) << 16);
  *(_WORD *)v2 = v3;
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_disable_spin_bit(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_disable_spin_bit(v3, a2);

}

void sub_1838E5228(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_disable_spin_bit(void *a1)
{
  id v1;
  _BOOL8 disable_spin_bit;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  disable_spin_bit = nw_quic_connection_get_disable_spin_bit(v1);

  return disable_spin_bit;
}

void sub_1838E526C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_enable_multipath(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_enable_multipath_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_enable_multipath";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_enable_multipath";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_enable_multipath";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_enable_multipath";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_enable_multipath";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E5548(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_enable_multipath_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = (v3 | (*(unsigned __int8 *)(v2 + 2) << 16)) & 0xFFFBFFFF | (*(unsigned __int8 *)(a1 + 32) << 18);
  *(_WORD *)v2 = v3;
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_enable_multipath(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_enable_multipath(v3, a2);

}

void sub_1838E55BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_enable_multipath(void *a1)
{
  id v1;
  _BOOL8 enable_multipath;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  enable_multipath = nw_quic_connection_get_enable_multipath(v1);

  return enable_multipath;
}

void sub_1838E5600(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_probe_simultaneously(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_probe_simultaneously_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_probe_simultaneously";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_probe_simultaneously";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_probe_simultaneously";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_probe_simultaneously";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_probe_simultaneously";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E58DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_probe_simultaneously_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;

  v3 = *(unsigned __int16 *)(a2 + 215);
  v2 = a2 + 215;
  v4 = (v3 | (*(unsigned __int8 *)(v2 + 2) << 16)) & 0xFFF7FFFF | (*(unsigned __int8 *)(a1 + 32) << 19);
  *(_WORD *)v2 = v3;
  *(_BYTE *)(v2 + 2) = BYTE2(v4);
  return 1;
}

void nw_quic_set_probe_simultaneously(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_probe_simultaneously(v3, a2);

}

void sub_1838E5950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL nw_quic_get_probe_simultaneously(void *a1)
{
  id v1;
  _BOOL8 probe_simultaneously;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  probe_simultaneously = nw_quic_connection_get_probe_simultaneously(v1);

  return probe_simultaneously;
}

void sub_1838E5994(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_source_connection_id_length(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_source_connection_id_length_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_source_connection_id_length";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_source_connection_id_length";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_source_connection_id_length";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_source_connection_id_length";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_source_connection_id_length";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E5C70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_source_connection_id_length_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  size_t v4;
  dispatch_data_t v5;
  void *v6;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  const char *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  NSObject *v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  _BYTE buffer[22];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = *(unsigned __int8 *)(a1 + 32);
    if (*(_BYTE *)(a1 + 32))
    {
      memset(buffer, 0, 20);
      if (v3 >= 0x14)
        v4 = 20;
      else
        v4 = v3;
      v5 = dispatch_data_create(buffer, v4, 0, 0);
      v6 = *(void **)(a2 + 152);
      *(_QWORD *)(a2 + 152) = v5;
    }
    else
    {
      v6 = *(void **)(a2 + 152);
      *(_QWORD *)(a2 + 152) = 0;
    }

    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v8 = (id)gLogObj;
  *(_DWORD *)buffer = 136446210;
  *(_QWORD *)&buffer[4] = "nw_quic_connection_set_source_connection_id_length_internal";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v9, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buffer = 136446210;
        *(_QWORD *)&buffer[4] = "nw_quic_connection_set_source_connection_id_length_internal";
        v12 = "%{public}s called with null quic_options";
LABEL_21:
        v16 = v10;
        v17 = v11;
LABEL_22:
        _os_log_impl(&dword_182FBE000, v16, v17, v12, buffer, 0xCu);
      }
    }
    else
    {
      if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v14 = type;
        v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buffer = 136446466;
            *(_QWORD *)&buffer[4] = "nw_quic_connection_set_source_connection_id_length_internal";
            *(_WORD *)&buffer[12] = 2082;
            *(_QWORD *)&buffer[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null quic_options, dumping backtrace:%{public}s", buffer, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (!v15)
          goto LABEL_23;
        *(_DWORD *)buffer = 136446210;
        *(_QWORD *)&buffer[4] = "nw_quic_connection_set_source_connection_id_length_internal";
        v12 = "%{public}s called with null quic_options, no backtrace";
        v16 = v10;
        v17 = v14;
        goto LABEL_22;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buffer = 136446210;
        *(_QWORD *)&buffer[4] = "nw_quic_connection_set_source_connection_id_length_internal";
        v12 = "%{public}s called with null quic_options, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_23:

  }
LABEL_24:
  if (v9)
    free(v9);
  return 1;
}

uint64_t nw_quic_connection_get_source_connection_id_length(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 8;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_source_connection_id_length_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id_length";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id_length";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id_length";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id_length";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_source_connection_id_length";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838E6280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_source_connection_id_length_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;

  v3 = *(NSObject **)(a2 + 152);
  if (v3)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = dispatch_data_get_size(v3);
  return 1;
}

void nw_quic_set_source_connection_id_length(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_shared_connection_options(a1);
  nw_quic_connection_set_source_connection_id_length(v3, a2);

}

void sub_1838E631C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_source_connection_id_length(void *a1)
{
  id v1;
  uint64_t source_connection_id_length;

  v1 = nw_quic_stream_copy_shared_connection_options(a1);
  source_connection_id_length = nw_quic_connection_get_source_connection_id_length(v1);

  return source_connection_id_length;
}

void sub_1838E6360(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_session_state(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _QWORD v16[4];
  id v17;
  id v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (nw_protocol_options_is_quic_connection(v5))
  {
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = __nw_quic_connection_set_session_state_block_invoke;
    v16[3] = &unk_1E14AA2D0;
    v17 = v6;
    v18 = v7;
    nw_protocol_options_access_handle(v5, v16);

    goto LABEL_3;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_quic_connection_set_session_state";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_session_state";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_quic_connection_set_session_state";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_session_state";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_session_state";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v9)
    free(v9);
LABEL_3:

}

void sub_1838E667C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_session_state_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 136), *(id *)(a1 + 32));
  objc_storeStrong((id *)(a2 + 144), *(id *)(a1 + 40));
  return 1;
}

void nw_quic_connection_set_session_state_update_block(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _QWORD v16[4];
  id v17;
  id v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (nw_protocol_options_is_quic_connection(v5))
  {
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = __nw_quic_connection_set_session_state_update_block_block_invoke;
    v16[3] = &unk_1E14AA370;
    v18 = v6;
    v17 = v7;
    nw_protocol_options_access_handle(v5, v16);

    goto LABEL_3;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_quic_connection_set_session_state_update_block";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_session_state_update_block";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_quic_connection_set_session_state_update_block";
          v23 = 2082;
          v24 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_session_state_update_block";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v22 = "nw_quic_connection_set_session_state_update_block";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v9)
    free(v9);
LABEL_3:

}

void sub_1838E69F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_session_state_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  v4 = _Block_copy(*(const void **)(a1 + 40));
  v5 = *(void **)(a2 + 160);
  *(_QWORD *)(a2 + 160) = v4;

  objc_storeStrong((id *)(a2 + 168), *(id *)(a1 + 32));
  return 1;
}

uint64_t __nw_quic_connection_execute_session_state_update_block_block_invoke_2(_QWORD *a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

void nw_quic_connection_execute_max_streams_update_block(void *a1, int a2, uint64_t a3)
{
  id v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[5];
  int v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (nw_protocol_options_is_quic_connection(v5))
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_quic_connection_execute_max_streams_update_block_block_invoke;
    v14[3] = &__block_descriptor_44_e9_B16__0_v8l;
    v15 = a2;
    v14[4] = a3;
    nw_protocol_options_access_handle(v5, v14);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_quic_connection_execute_max_streams_update_block";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_quic_connection_execute_max_streams_update_block";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_quic_connection_execute_max_streams_update_block";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_quic_connection_execute_max_streams_update_block";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_quic_connection_execute_max_streams_update_block";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_1838E6D58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_execute_max_streams_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;
  void *v5;
  NSObject *v6;
  uint64_t v7;
  id v8;
  _QWORD block[4];
  id v11;
  uint64_t v12;
  int v13;

  v3 = *(const void **)(a2 + 176);
  if (v3)
  {
    v5 = _Block_copy(v3);
    v6 = *(NSObject **)(a2 + 184);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __nw_quic_connection_execute_max_streams_update_block_block_invoke_2;
    block[3] = &unk_1E14AD070;
    v13 = *(_DWORD *)(a1 + 40);
    v7 = *(_QWORD *)(a1 + 32);
    v11 = v5;
    v12 = v7;
    v8 = v5;
    dispatch_async(v6, block);

  }
  return 1;
}

uint64_t __nw_quic_connection_execute_max_streams_update_block_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 48), *(_QWORD *)(a1 + 40));
}

void nw_quic_stream_set_is_datagram(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_is_datagram_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_stream_set_is_datagram";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_stream(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_stream_set_is_datagram";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_stream(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E70E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_is_datagram_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 24) = *(_BYTE *)(a2 + 24) & 0xFD | (2 * *(_BYTE *)(a1 + 32));
  return 1;
}

void nw_quic_stream_set_associated_stream_id(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_associated_stream_id_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_stream_set_associated_stream_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_associated_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_stream(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_stream_set_associated_stream_id";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_associated_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_associated_stream_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_stream(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E73E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_associated_stream_id_block_invoke(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_stream_set_datagram_context_id(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_options_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_datagram_context_id_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_stream_set_datagram_context_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_stream(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_stream_set_datagram_context_id";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_stream(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E76DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_datagram_context_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 32);
  return 1;
}

uint64_t nw_quic_stream_get_datagram_context_id(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_options_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_datagram_context_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_context_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_options_is_quic_stream(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_context_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_options_is_quic_stream(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_context_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_options_is_quic_stream(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838E79F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_datagram_context_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 8);
  return 1;
}

id nw_quic_options_copy_local_public_key(void *a1)
{
  id v1;
  id v2;
  BOOL is_quic_stream;
  id v4;
  id v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (!v1)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_quic_options_copy_local_public_key";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (__nwlog_fault(v8, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_quic_options_copy_local_public_key";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null options", buf, 0xCu);
        }
      }
      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            v26 = "nw_quic_options_copy_local_public_key";
            v27 = 2082;
            v28 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_quic_options_copy_local_public_key";
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "nw_quic_options_copy_local_public_key";
          _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_38:
    if (v8)
      free(v8);
    v2 = 0;
    goto LABEL_46;
  }
  v2 = v1;
  if (!nw_protocol_options_is_quic_connection(v2))
  {
    is_quic_stream = nw_protocol_options_is_quic_stream(v2);

    if (is_quic_stream)
      goto LABEL_5;
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_quic_options_copy_local_public_key";
    v12 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v12, &type, &v23))
      goto LABEL_44;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_quic_options_copy_local_public_key";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null nw_protocol_options_is_quic(options)", buf, 0xCu);
      }
    }
    else if (v23)
    {
      v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      v20 = os_log_type_enabled(v13, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_quic_options_copy_local_public_key";
          v27 = 2082;
          v28 = v18;
          _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s called with null nw_protocol_options_is_quic(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        goto LABEL_44;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_quic_options_copy_local_public_key";
        _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s called with null nw_protocol_options_is_quic(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_quic_options_copy_local_public_key";
        _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s called with null nw_protocol_options_is_quic(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_44:
    if (v12)
      free(v12);
LABEL_46:
    v5 = 0;
    goto LABEL_8;
  }

LABEL_5:
  if (nw_protocol_options_is_quic_stream(v2))
  {
    v4 = nw_quic_stream_copy_shared_connection_options(v2);

    v2 = v4;
  }
  v5 = nw_quic_connection_copy_local_public_key(v2);
LABEL_8:

  return v5;
}

void sub_1838E7F30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_metadata_is_quic(nw_protocol_metadata_t metadata)
{
  NSObject *v1;
  BOOL v2;

  v1 = metadata;
  v2 = nw_protocol_metadata_is_quic_connection(v1) || nw_protocol_metadata_is_quic_stream(v1);

  return v2;
}

void sub_1838E7F90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

sec_protocol_metadata_t nw_quic_copy_sec_protocol_metadata(nw_protocol_metadata_t metadata)
{
  NSObject *v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = metadata;
  if (v1)
  {
    v2 = v1;
    if (nw_protocol_metadata_is_quic_stream(v1))
    {
      v3 = nw_quic_stream_copy_connection_metadata(v2);

      v2 = v3;
    }
    v4 = nw_quic_connection_copy_sec_protocol_metadata(v2);
    goto LABEL_5;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_copy_sec_protocol_metadata";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_copy_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_copy_sec_protocol_metadata";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_copy_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_copy_sec_protocol_metadata";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v7)
    free(v7);
  v2 = 0;
  v4 = 0;
LABEL_5:

  return v4;
}

void sub_1838E8254(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id nw_quic_stream_copy_connection_metadata(void *a1)
{
  id v1;
  id v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v16)(uint64_t, uint64_t);
  void (*v17)(uint64_t);
  id v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v16 = __Block_byref_object_copy__54919;
    v17 = __Block_byref_object_dispose__54920;
    v18 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_copy_connection_metadata_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(id *)(*(_QWORD *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_copy_connection_metadata";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_copy_connection_metadata";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_copy_connection_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_copy_connection_metadata";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_copy_connection_metadata";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838E8580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;

  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_copy_connection_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a2 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), *(id *)(a2 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_remote_transport_parameters(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  id v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _QWORD v22[10];
  char v23;
  os_log_type_t v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v13 = a1;
  if (nw_protocol_options_is_quic_connection(v13))
  {
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = __nw_quic_set_remote_transport_parameters_block_invoke;
    v22[3] = &__block_descriptor_80_e9_B16__0_v8l;
    v22[4] = a2;
    v22[5] = a3;
    v22[6] = a4;
    v22[7] = a5;
    v22[8] = a6;
    v22[9] = a7;
    nw_protocol_options_access_handle(v13, v22);
    goto LABEL_3;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_quic_set_remote_transport_parameters";
  v15 = (char *)_os_log_send_and_compose_impl();

  v24 = OS_LOG_TYPE_ERROR;
  v23 = 0;
  if (__nwlog_fault(v15, &v24, &v23))
  {
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = v24;
      if (os_log_type_enabled(v16, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_quic_set_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null nw_protocol_options_is_quic_connection(options)", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v19 = v24;
      v20 = os_log_type_enabled(v16, v24);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_quic_set_remote_transport_parameters";
          v27 = 2082;
          v28 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null nw_protocol_options_is_quic_connection(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_quic_set_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null nw_protocol_options_is_quic_connection(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = v24;
      if (os_log_type_enabled(v16, v24))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_quic_set_remote_transport_parameters";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null nw_protocol_options_is_quic_connection(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v15)
    free(v15);
LABEL_3:

}

void sub_1838E88E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_set_remote_transport_parameters_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  __int16 v3;

  v3 = *(_WORD *)(a2 + 215);
  v2 = a2 + 215;
  *(_QWORD *)(v2 - 167) = a1[4];
  *(_QWORD *)(v2 - 159) = a1[5];
  *(_QWORD *)(v2 - 151) = a1[6];
  *(_QWORD *)(v2 - 143) = a1[7];
  *(_QWORD *)(v2 - 135) = a1[8];
  *(_QWORD *)(v2 - 127) = a1[9];
  *(_BYTE *)(v2 + 2) |= 2u;
  *(_WORD *)v2 = v3;
  return 1;
}

void nw_quic_connection_set_max_data(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_max_data_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_max_data";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_data";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_max_data";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_data";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_data";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E8C10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_data_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 48);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_max_data(void *a1, uint64_t a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_max_data(v3, a2);

}

void sub_1838E8CAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_stream_data_bidirectional_local(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_max_stream_data_bidirectional_local_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_max_stream_data_bidirectional_local";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_max_stream_data_bidirectional_local";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_bidirectional_local";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E8F8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_bidirectional_local_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 56);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_max_stream_data_bidirectional_local(void *a1, uint64_t a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_max_stream_data_bidirectional_local(v3, a2);

}

void sub_1838E9028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_stream_data_bidirectional_remote(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_max_stream_data_bidirectional_remote_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_max_stream_data_bidirectional_remote";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_max_stream_data_bidirectional_remote";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_bidirectional_remote";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E9308(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_bidirectional_remote_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 64);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_max_stream_data_bidirectional_remote(void *a1, uint64_t a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_max_stream_data_bidirectional_remote(v3, a2);

}

void sub_1838E93A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_max_stream_data_unidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_max_stream_data_unidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_max_stream_data_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_max_stream_data_unidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_max_stream_data_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E9684(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_max_stream_data_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 72);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_max_stream_data_unidirectional(void *a1, uint64_t a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_max_stream_data_unidirectional(v3, a2);

}

void sub_1838E9720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_local_max_streams_unidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_local_max_streams_unidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_local_max_streams_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_local_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_local_max_streams_unidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_local_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_local_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E9A00(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_local_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 88);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_local_max_streams_unidirectional(nw_protocol_metadata_t metadata, uint64_t max_streams_unidirectional)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(metadata);
  nw_quic_connection_set_local_max_streams_unidirectional(v3, max_streams_unidirectional);

}

void sub_1838E9A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_local_max_streams_bidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_local_max_streams_bidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_local_max_streams_bidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_local_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_local_max_streams_bidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_local_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_local_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838E9D7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_local_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 80);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_local_max_streams_bidirectional(nw_protocol_metadata_t metadata, uint64_t max_streams_bidirectional)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(metadata);
  nw_quic_connection_set_local_max_streams_bidirectional(v3, max_streams_bidirectional);

}

void sub_1838E9E18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_remote_max_streams_unidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_remote_max_streams_unidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_remote_max_streams_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_remote_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_remote_max_streams_unidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_remote_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_remote_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EA0F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_remote_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 120);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_set_remote_max_streams_bidirectional(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_remote_max_streams_bidirectional_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_remote_max_streams_bidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_remote_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_remote_max_streams_bidirectional";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_remote_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_remote_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EA428(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_remote_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 112);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_keepalive(void *a1, __int16 a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_keepalive(v3, a2);

}

void sub_1838EA4C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_link_flow_controlled(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_link_flow_controlled_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_connection_set_link_flow_controlled";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_link_flow_controlled";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_connection_set_link_flow_controlled";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_link_flow_controlled";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_connection_set_link_flow_controlled";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EA7A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_link_flow_controlled_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 200);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(unsigned __int8 *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_link_flow_controlled(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_link_flow_controlled(v3, a2);

}

void sub_1838EA844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_connection_inject_packet(void *a1, uint64_t a2, uint64_t a3)
{
  id v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[6];
  char v15;
  os_log_type_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (nw_protocol_metadata_is_quic_connection(v5))
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_quic_connection_inject_packet_block_invoke;
    v14[3] = &__block_descriptor_48_e9_B16__0_v8l;
    v14[4] = a2;
    v14[5] = a3;
    nw_protocol_metadata_access_handle((uint64_t)v5, (uint64_t)v14);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_inject_packet";
  v7 = (char *)_os_log_send_and_compose_impl();

  v16 = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_inject_packet";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v16;
      v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_inject_packet";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_inject_packet";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_inject_packet";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
LABEL_3:

}

void sub_1838EAB28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_inject_packet_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 176);
  if (v5)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_connection_get_application_result(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_application_result_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_get_application_result";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_application_result";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_get_application_result";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_application_result";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_get_application_result";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1838EAE70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_application_result_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 192);
  if (v5)
    (*(void (**)(uint64_t, _QWORD))(v5 + 16))(v5, *(_QWORD *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

void nw_quic_set_keepalive_interval(nw_protocol_metadata_t metadata, uint16_t keepalive_interval)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(metadata);
  nw_quic_connection_set_keepalive(v3, keepalive_interval);

}

void sub_1838EAF24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_stream_set_usable_datagram_frame_size(void *a1, __int16 a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  __int16 v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_usable_datagram_frame_size_block_invoke;
    v12[3] = &__block_descriptor_34_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_stream_set_usable_datagram_frame_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_usable_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_stream_set_usable_datagram_frame_size";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_usable_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_usable_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EB208(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_usable_datagram_frame_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 44) = *(_WORD *)(a1 + 32);
  return 1;
}

void nw_quic_stream_set_datagram_variant_flow_id(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_datagram_variant_flow_id_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_stream_set_datagram_variant_flow_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_stream_set_datagram_variant_flow_id";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EB4F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_datagram_variant_flow_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_stream_set_has_datagram_variant_flow_id(void *a1, char a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[4];
  char v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_has_datagram_variant_flow_id_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_quic_stream_set_has_datagram_variant_flow_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_has_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_quic_stream_set_has_datagram_variant_flow_id";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_has_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_quic_stream_set_has_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EB7E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_has_datagram_variant_flow_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 47) = *(_BYTE *)(a2 + 47) & 0xFE | *(_BYTE *)(a1 + 32);
  return 1;
}

void nw_quic_stream_set_application_error_internal(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_application_error_internal_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_stream_set_application_error_internal";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_application_error_internal";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_stream_set_application_error_internal";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_application_error_internal";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_stream_set_application_error_internal";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EBAE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_application_error_internal_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_connection_set_application_error_internal(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_set_application_error_internal_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_quic_connection_set_application_error_internal";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_application_error_internal";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_quic_connection_set_application_error_internal";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_application_error_internal";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_quic_connection_set_application_error_internal";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
LABEL_3:

}

void sub_1838EBDD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_application_error_internal_block_invoke(uint64_t a1, _QWORD *a2)
{
  *a2 = *(_QWORD *)(a1 + 32);
  return 1;
}

void nw_quic_set_application_error_internal(void *a1, uint64_t a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_application_error_internal(v3, a2);

}

void sub_1838EBE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void nw_quic_set_is_early_data_accepted(void *a1, char a2)
{
  id v3;

  v3 = nw_quic_stream_copy_connection_metadata(a1);
  nw_quic_connection_set_is_early_data_accepted(v3, a2);

}

void sub_1838EBE78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_local_max_streams_unidirectional(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_local_max_streams_unidirectional_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_unidirectional";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838EC184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_local_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 104);
  if (v5)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))(v5 + 16))();
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_get_local_max_streams_unidirectional(nw_protocol_metadata_t metadata)
{
  id v1;
  uint64_t local_max_streams_unidirectional;

  v1 = nw_quic_stream_copy_connection_metadata(metadata);
  local_max_streams_unidirectional = nw_quic_connection_get_local_max_streams_unidirectional(v1);

  return local_max_streams_unidirectional;
}

void sub_1838EC23C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_local_max_streams_bidirectional(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_local_max_streams_bidirectional_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_bidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_bidirectional";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_local_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838EC544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_local_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 96);
  if (v5)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))(v5 + 16))();
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_get_local_max_streams_bidirectional(nw_protocol_metadata_t metadata)
{
  id v1;
  uint64_t local_max_streams_bidirectional;

  v1 = nw_quic_stream_copy_connection_metadata(metadata);
  local_max_streams_bidirectional = nw_quic_connection_get_local_max_streams_bidirectional(v1);

  return local_max_streams_bidirectional;
}

void sub_1838EC5FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_remote_max_streams_unidirectional(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_remote_max_streams_unidirectional_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_unidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_unidirectional";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_unidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838EC904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_remote_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 136);
  if (v5)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))(v5 + 16))();
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_get_remote_max_streams_unidirectional(nw_protocol_metadata_t metadata)
{
  id v1;
  uint64_t remote_max_streams_unidirectional;

  v1 = nw_quic_stream_copy_connection_metadata(metadata);
  remote_max_streams_unidirectional = nw_quic_connection_get_remote_max_streams_unidirectional(v1);

  return remote_max_streams_unidirectional;
}

void sub_1838EC9BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_remote_max_streams_bidirectional(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_remote_max_streams_bidirectional_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_bidirectional";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_bidirectional";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_remote_max_streams_bidirectional";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838ECCC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_remote_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 128);
  if (v5)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))(v5 + 16))();
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_get_remote_max_streams_bidirectional(nw_protocol_metadata_t metadata)
{
  id v1;
  uint64_t remote_max_streams_bidirectional;

  v1 = nw_quic_stream_copy_connection_metadata(metadata);
  remote_max_streams_bidirectional = nw_quic_connection_get_remote_max_streams_bidirectional(v1);

  return remote_max_streams_bidirectional;
}

void sub_1838ECD7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_peer_idle_timeout(void *a1)
{
  id v1;
  uint64_t peer_idle_timeout;

  v1 = nw_quic_stream_copy_connection_metadata(a1);
  peer_idle_timeout = nw_quic_connection_get_peer_idle_timeout(v1);

  return peer_idle_timeout;
}

void sub_1838ECDBC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_get_keepalive(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_keepalive_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_keepalive";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838ED0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_keepalive_block_invoke(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  v5 = *(_QWORD *)(a2 + 168);
  if (v5)
    *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(uint64_t (**)(void))(v5 + 16))();
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_get_keepalive(void *a1)
{
  id v1;
  uint64_t keepalive;

  v1 = nw_quic_stream_copy_connection_metadata(a1);
  keepalive = nw_quic_connection_get_keepalive(v1);

  return keepalive;
}

void sub_1838ED17C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint16_t nw_quic_get_keepalive_interval(nw_protocol_metadata_t metadata)
{
  id v1;
  uint16_t keepalive;

  v1 = nw_quic_stream_copy_connection_metadata(metadata);
  keepalive = nw_quic_connection_get_keepalive(v1);

  return keepalive;
}

void sub_1838ED1BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_get_remote_idle_timeout(nw_protocol_metadata_t metadata)
{
  id v1;
  uint64_t peer_idle_timeout;

  v1 = nw_quic_stream_copy_connection_metadata(metadata);
  peer_idle_timeout = nw_quic_connection_get_peer_idle_timeout(v1);

  return peer_idle_timeout;
}

void sub_1838ED1FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_stream_get_usable_datagram_frame_size(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  __int16 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_usable_datagram_frame_size_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(unsigned __int16 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_usable_datagram_frame_size";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_usable_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_usable_datagram_frame_size";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_usable_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_usable_datagram_frame_size";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838ED508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_usable_datagram_frame_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 44);
  return 1;
}

uint64_t nw_quic_stream_get_datagram_variant_flow_id(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_datagram_variant_flow_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_variant_flow_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_variant_flow_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838ED848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_datagram_variant_flow_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 8);
  return 1;
}

BOOL nw_quic_stream_get_has_datagram_variant_flow_id(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_has_datagram_variant_flow_id_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_has_datagram_variant_flow_id";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_has_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_has_datagram_variant_flow_id";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_has_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_has_datagram_variant_flow_id";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838EDB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_has_datagram_variant_flow_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 47) & 1;
  return 1;
}

uint64_t nw_quic_get_application_error(nw_protocol_metadata_t metadata)
{
  id v1;
  uint64_t application_error;

  v1 = nw_quic_stream_copy_connection_metadata(metadata);
  application_error = nw_quic_connection_get_application_error(v1);

  return application_error;
}

void sub_1838EDC0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_quic_stream_get_type(void *a1)
{
  id v1;
  uint64_t v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_type_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_stream_get_type";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_type";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_stream_get_type";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_type";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_stream_get_type";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838EDF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_type_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 46);
  return 1;
}

BOOL nw_quic_connection_get_is_early_data_accepted(void *a1)
{
  id v1;
  _BOOL8 v2;
  void *v4;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  _QWORD v12[5];
  char v13;
  os_log_type_t type;
  _BYTE buf[24];
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (nw_protocol_metadata_is_quic_connection(v1))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v16 = 0;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_connection_get_is_early_data_accepted_block_invoke;
    v12[3] = &unk_1E14A9D68;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    v2 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_early_data_accepted";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_early_data_accepted";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_early_data_accepted";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_early_data_accepted";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_connection_get_is_early_data_accepted";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v5)
    free(v5);
  v2 = 0;
LABEL_3:

  return v2;
}

void sub_1838EE260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_is_early_data_accepted_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 216) & 1;
  return 1;
}

BOOL nw_quic_get_is_early_data_accepted(void *a1)
{
  id v1;
  _BOOL8 is_early_data_accepted;

  v1 = nw_quic_stream_copy_connection_metadata(a1);
  is_early_data_accepted = nw_quic_connection_get_is_early_data_accepted(v1);

  return is_early_data_accepted;
}

void sub_1838EE2D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_stream_execute_locked(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_stream_execute_locked_block_invoke;
    v13[3] = &unk_1E14A9DD0;
    v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_stream_execute_locked";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_execute_locked";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_stream_execute_locked";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_execute_locked";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_stream_execute_locked";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1838EE5CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_execute_locked_block_invoke(uint64_t a1, os_unfair_lock_s *a2)
{
  os_unfair_lock_s *v3;

  v3 = a2 + 10;
  os_unfair_lock_lock(a2 + 10);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  os_unfair_lock_unlock(v3);
  return 1;
}

void nw_quic_set_application_error(nw_protocol_metadata_t metadata, uint64_t application_error, const char *reason)
{
  id v5;
  void *v6;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v5 = nw_quic_stream_copy_connection_metadata(metadata);
  v6 = v5;
  if (v5)
  {
    nw_quic_connection_set_application_error_internal(v5, application_error);
    nw_quic_connection_set_application_error_reason(v6, (uint64_t)reason);
    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_set_application_error";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_set_application_error";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null connection_metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_set_application_error";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection_metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_set_application_error";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null connection_metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_set_application_error";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null connection_metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

}

void sub_1838EE8EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_quic_connection_set_application_error_reason(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[5];
  char v15;
  os_log_type_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (v3)
  {
    v4 = v3;
    if (nw_protocol_metadata_is_quic_stream(v3))
    {
      v5 = nw_quic_stream_copy_connection_metadata(v4);

      v4 = v5;
    }
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_quic_connection_set_application_error_reason_block_invoke;
    v14[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v14[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v4, (uint64_t)v14);
    goto LABEL_5;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_quic_connection_set_application_error_reason";
  v7 = (char *)_os_log_send_and_compose_impl();

  v16 = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_application_error_reason";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = v16;
      v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_quic_connection_set_application_error_reason";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_application_error_reason";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_quic_connection_set_application_error_reason";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_5:

}

void sub_1838EEBDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_set_application_error_reason_block_invoke(uint64_t a1, uint64_t a2)
{
  const char *v3;
  xpc_object_t v4;
  void *v5;

  v3 = *(const char **)(a1 + 32);
  if (v3)
  {
    v4 = xpc_string_create(v3);
    v5 = *(void **)(a2 + 8);
    *(_QWORD *)(a2 + 8) = v4;
  }
  else
  {
    v5 = *(void **)(a2 + 8);
    *(_QWORD *)(a2 + 8) = 0;
  }

  return 1;
}

const char *__cdecl nw_quic_get_application_error_reason(nw_protocol_metadata_t metadata)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  const char *v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD v14[5];
  char v15;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)nw_quic_stream_copy_connection_metadata(metadata);
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v18 = 0;
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __nw_quic_get_application_error_reason_block_invoke;
    v14[3] = &unk_1E14A9D68;
    v14[4] = buf;
    v3 = v1[4];
    if (v3)
    {
      __nw_quic_get_application_error_reason_block_invoke((uint64_t)v14, v3);
      v4 = *(const char **)(*(_QWORD *)&buf[8] + 24);
    }
    else
    {
      v4 = 0;
    }
    _Block_object_dispose(buf, 8);
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_quic_get_application_error_reason";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_get_application_error_reason";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null connection_metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_quic_get_application_error_reason";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null connection_metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_get_application_error_reason";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null connection_metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_quic_get_application_error_reason";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null connection_metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_6:

  return v4;
}

void sub_1838EEF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_get_application_error_reason_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = *(void **)(a2 + 8);
  if (v3)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = xpc_string_get_string_ptr(v3);
  return 1;
}

uint64_t nw_qpod_set_secrets(void *a1, uint64_t a2, void *a3, void *a4, char a5)
{
  id v8;
  id v9;
  id v10;
  uint64_t v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  char *backtrace_string;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  _QWORD v21[4];
  id v22;
  id v23;
  char v24;
  char v25;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = a1;
  v9 = a3;
  v10 = a4;
  if (nw_protocol_options_is_qpod(v8))
  {
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = __nw_qpod_set_secrets_block_invoke;
    v21[3] = &unk_1E14A4EE8;
    v22 = v9;
    v23 = v10;
    v24 = a5;
    v11 = nw_protocol_options_access_handle(v8, v21);

    goto LABEL_3;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v28 = "nw_qpod_set_secrets";
  v14 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v25 = 0;
  if (__nwlog_fault(v14, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_qpod_set_secrets";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null nw_protocol_options_is_qpod(options)", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "nw_qpod_set_secrets";
          v29 = 2082;
          v30 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null nw_protocol_options_is_qpod(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_qpod_set_secrets";
        _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null nw_protocol_options_is_qpod(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        v28 = "nw_qpod_set_secrets";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null nw_protocol_options_is_qpod(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v14)
    free(v14);
  v11 = 0;
LABEL_3:

  return v11;
}

void sub_1838EF2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_qpod(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  _BOOL8 is_equal_unsafe;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[1];

    if (nw_protocol_copy_qpod_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_qpod_definition::onceToken, &__block_literal_global_28_56150);
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_qpod_definition::definition);

    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_options_is_qpod";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_qpod";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_options_is_qpod";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_qpod";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_qpod";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_1838EF5C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_qpod_set_secrets_block_invoke(uint64_t a1, id *location)
{
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  id *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = 136446466;
      v9 = "nw_qpod_set_secrets_block_invoke";
      v10 = 2048;
      v11 = location;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s setting secrets for options %p", (uint8_t *)&v8, 0x16u);
    }

  }
  objc_storeStrong(location, *(id *)(a1 + 32));
  if (*location)
  {
    objc_storeStrong(location + 1, *(id *)(a1 + 40));
    if (location[1])
    {
      *((_BYTE *)location + 32) = *(_BYTE *)(a1 + 48);
      return 1;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = 136446210;
      v9 = "nw_qpod_set_secrets_block_invoke";
      v6 = "%{public}s failed to create server secret";
      goto LABEL_9;
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v8 = 136446210;
      v9 = "nw_qpod_set_secrets_block_invoke";
      v6 = "%{public}s failed to create client secret";
LABEL_9:
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v8, 0xCu);
    }
  }

  return 0;
}

BOOL __nw_protocol_copy_qpod_definition_block_invoke()
{
  nw_protocol_definition_t definition;
  void *v1;
  NSObject *v3;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    __nwlog_obj();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v4 = 136446210;
      v5 = "nw_protocol_copy_qpod_definition_block_invoke";
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s creating definition", (uint8_t *)&v4, 0xCu);
    }

  }
  definition = nw_framer_create_definition("qpod", 0, &__block_literal_global_32);
  v1 = (void *)nw_protocol_copy_qpod_definition::definition;
  nw_protocol_copy_qpod_definition::definition = (uint64_t)definition;

  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_qpod_definition::definition, (uint64_t)qpod_options_allocate, (uint64_t)qpod_options_copy, (uint64_t)qpod_options_deallocate);
  nw_protocol_definition_set_options_equality_check((void *)nw_protocol_copy_qpod_definition::definition, (uint64_t)qpod_options_is_equal);
  nw_protocol_definition_set_options_serializer((void *)nw_protocol_copy_qpod_definition::definition, 1, (uint64_t)qpod_options_serialize, (uint64_t)qpod_options_deserialize);
  return nw_protocol_definition_register((void *)nw_protocol_copy_qpod_definition::definition);
}

BOOL qpod_options_allocate(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 result;
  NSObject *v4;
  void *v5;
  NSObject *v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  if (!v2)
  {
    __nwlog_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v8 = "strict_calloc";
    v9 = 2048;
    v10 = 1;
    v11 = 2048;
    v12 = 40;
    v5 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v5);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v5);
  }
  if (gLogDatapath)
  {
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v8 = "qpod_options_allocate";
      v9 = 2048;
      v10 = (uint64_t)v2;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s allocating options %p", buf, 0x16u);
    }

  }
  return (BOOL)v2;
}

void sub_1838EFA90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL qpod_options_copy(void *a1, uint64_t a2)
{
  id v3;
  id *v4;
  _BOOL8 result;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "qpod_options_copy";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v7, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "qpod_options_copy";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "qpod_options_copy";
            v21 = 2082;
            v22 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "qpod_options_copy";
          _os_log_impl(&dword_182FBE000, v8, v14, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "qpod_options_copy";
          _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_26:
    if (v7)
      free(v7);
    v4 = 0;
    goto LABEL_4;
  }
  v4 = (id *)malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  if (v4)
    goto LABEL_3;
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v20 = "strict_calloc";
  v21 = 2048;
  v22 = 1;
  v23 = 2048;
  v24 = 40;
  v11 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
LABEL_3:
    objc_storeStrong(v4, *(id *)a2);
    objc_storeStrong(v4 + 1, *(id *)(a2 + 8));
    objc_storeStrong(v4 + 2, *(id *)(a2 + 16));
    objc_storeStrong(v4 + 3, *(id *)(a2 + 24));
    *((_BYTE *)v4 + 32) = *(_BYTE *)(a2 + 32);
    if (gLogDatapath)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v20 = "qpod_options_copy";
        v21 = 2048;
        v22 = a2;
        v23 = 2048;
        v24 = (uint64_t)v4;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s copying options %p -> %p", buf, 0x20u);
      }

    }
LABEL_4:

    return (BOOL)v4;
  }
  __break(1u);
  return result;
}

void sub_1838EFEB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void qpod_options_deallocate(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = 136446466;
      v9 = "qpod_options_deallocate";
      v10 = 2048;
      v11 = a2;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%{public}s deallocating options %p", (uint8_t *)&v8, 0x16u);
    }

  }
  v3 = (void *)*a2;
  *a2 = 0;

  v4 = (void *)a2[1];
  a2[1] = 0;

  v5 = (void *)a2[2];
  a2[2] = 0;

  v6 = (void *)a2[3];
  a2[3] = 0;

  free(a2);
}

BOOL qpod_options_is_equal(void *a1, uint64_t a2, uint64_t a3)
{
  id v5;
  _BOOL8 v6;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  _BOOL4 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (a2 && a3)
  {
    v6 = nw_dispatch_data_is_equal(*(dispatch_data_t *)a2, *(NSObject **)a3)
      && nw_dispatch_data_is_equal(*(dispatch_data_t *)(a2 + 8), *(NSObject **)(a3 + 8))
      && nw_dispatch_data_is_equal(*(dispatch_data_t *)(a2 + 16), *(NSObject **)(a3 + 16))
      && nw_dispatch_data_is_equal(*(dispatch_data_t *)(a2 + 24), *(NSObject **)(a3 + 24))
      && *(unsigned __int8 *)(a2 + 32) == *(unsigned __int8 *)(a3 + 32);
    if (gLogDatapath)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v9 = 136446978;
        v10 = "qpod_options_is_equal";
        v11 = 2048;
        v12 = a2;
        v13 = 2048;
        v14 = a3;
        v15 = 1024;
        v16 = v6;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s comparing options %p and %p -> %i", (uint8_t *)&v9, 0x26u);
      }

    }
  }
  else
  {
    v6 = a2 == a3;
  }

  return v6;
}

BOOL qpod_options_serialize(void *a1, uint64_t a2, _QWORD *a3)
{
  id v5;
  size_t size;
  NSObject *v7;
  size_t v8;
  NSObject *v9;
  size_t v10;
  NSObject *v11;
  size_t v12;
  size_t v13;
  size_t v14;
  char *v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  _BOOL8 result;
  NSObject *v31;
  NSObject *v32;
  _BYTE *v33;
  uint64_t v34;
  void *v35;
  NSObject *v36;
  os_log_type_t v37;
  void *v38;
  os_log_type_t v39;
  NSObject *v40;
  void *v41;
  NSObject *v42;
  void *v43;
  char *backtrace_string;
  os_log_type_t v45;
  _BOOL4 v46;
  os_log_type_t v47;
  _BOOL4 v48;
  os_log_type_t v49;
  os_log_type_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  char *v54;
  os_log_type_t type[8];
  os_log_type_t *v56;
  uint64_t v57;
  uint64_t v58;
  _BYTE applier[24];
  void *v60;
  os_log_type_t *v61;
  uint64_t *v62;
  size_t v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "qpod_options_serialize";
    v15 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v51) = 0;
    if (!__nwlog_fault(v15, type, &v51))
      goto LABEL_84;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v37 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "qpod_options_serialize";
        _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s called with null existing_handle", applier, 0xCu);
      }
      goto LABEL_83;
    }
    if (!(_BYTE)v51)
    {
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v49 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "qpod_options_serialize";
        _os_log_impl(&dword_182FBE000, v36, v49, "%{public}s called with null existing_handle, backtrace limit exceeded", applier, 0xCu);
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v36 = objc_claimAutoreleasedReturnValue();
    v45 = type[0];
    v46 = os_log_type_enabled(v36, type[0]);
    if (!backtrace_string)
    {
      if (v46)
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "qpod_options_serialize";
        _os_log_impl(&dword_182FBE000, v36, v45, "%{public}s called with null existing_handle, no backtrace", applier, 0xCu);
      }
      goto LABEL_83;
    }
    if (v46)
    {
      *(_DWORD *)applier = 136446466;
      *(_QWORD *)&applier[4] = "qpod_options_serialize";
      *(_WORD *)&applier[12] = 2082;
      *(_QWORD *)&applier[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v36, v45, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", applier, 0x16u);
    }
    goto LABEL_71;
  }
  if (!a3)
  {
    __nwlog_obj();
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "qpod_options_serialize";
    v15 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v51) = 0;
    if (!__nwlog_fault(v15, type, &v51))
      goto LABEL_84;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v39 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "qpod_options_serialize";
        _os_log_impl(&dword_182FBE000, v36, v39, "%{public}s called with null out_length", applier, 0xCu);
      }
LABEL_83:

LABEL_84:
      if (!v15)
        goto LABEL_35;
      goto LABEL_34;
    }
    if (!(_BYTE)v51)
    {
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v50 = type[0];
      if (os_log_type_enabled(v36, type[0]))
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "qpod_options_serialize";
        _os_log_impl(&dword_182FBE000, v36, v50, "%{public}s called with null out_length, backtrace limit exceeded", applier, 0xCu);
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v36 = objc_claimAutoreleasedReturnValue();
    v47 = type[0];
    v48 = os_log_type_enabled(v36, type[0]);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "qpod_options_serialize";
        _os_log_impl(&dword_182FBE000, v36, v47, "%{public}s called with null out_length, no backtrace", applier, 0xCu);
      }
      goto LABEL_83;
    }
    if (v48)
    {
      *(_DWORD *)applier = 136446466;
      *(_QWORD *)&applier[4] = "qpod_options_serialize";
      *(_WORD *)&applier[12] = 2082;
      *(_QWORD *)&applier[14] = backtrace_string;
      _os_log_impl(&dword_182FBE000, v36, v47, "%{public}s called with null out_length, dumping backtrace:%{public}s", applier, 0x16u);
    }
LABEL_71:

    free(backtrace_string);
    goto LABEL_84;
  }
  if (*(_QWORD *)a2)
  {
    size = dispatch_data_get_size(*(dispatch_data_t *)a2);
    v7 = *(NSObject **)(a2 + 8);
    if (v7)
      goto LABEL_5;
  }
  else
  {
    size = 0;
    v7 = *(NSObject **)(a2 + 8);
    if (v7)
    {
LABEL_5:
      v8 = dispatch_data_get_size(v7);
      v9 = *(NSObject **)(a2 + 16);
      if (v9)
        goto LABEL_6;
LABEL_10:
      v10 = 0;
      v11 = *(NSObject **)(a2 + 24);
      if (v11)
        goto LABEL_7;
      goto LABEL_11;
    }
  }
  v8 = 0;
  v9 = *(NSObject **)(a2 + 16);
  if (!v9)
    goto LABEL_10;
LABEL_6:
  v10 = dispatch_data_get_size(v9);
  v11 = *(NSObject **)(a2 + 24);
  if (v11)
  {
LABEL_7:
    v12 = dispatch_data_get_size(v11);
    goto LABEL_12;
  }
LABEL_11:
  v12 = 0;
LABEL_12:
  v13 = size + v8 + v10 + v12;
  v14 = v13 + 5;
  *a3 = v13 + 5;
  if (v13 == -5)
  {
    __nwlog_obj();
    v40 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
    *(_DWORD *)applier = 136446210;
    *(_QWORD *)&applier[4] = "strict_calloc";
    v41 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v41);
    if (result)
      goto LABEL_86;
    free(v41);
  }
  v15 = (char *)malloc_type_calloc(1uLL, v14, 0xEAFB8F1AuLL);
  if (v15)
  {
LABEL_14:
    v16 = *(id *)a2;
    v17 = v16;
    if (size > 0xFF)
      goto LABEL_22;
    *v15 = size;
    *(_QWORD *)type = 0;
    v56 = type;
    v57 = 0x2000000000;
    v58 = 0;
    v51 = 0;
    v52 = &v51;
    v53 = 0x2000000000;
    v54 = v15 + 1;
    if (v16)
    {
      *(_QWORD *)applier = MEMORY[0x1E0C809B0];
      *(_QWORD *)&applier[8] = 0x40000000;
      *(_QWORD *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      v60 = &unk_1E14A3448;
      v62 = &v51;
      v63 = size;
      v61 = type;
      dispatch_data_apply(v16, applier);
      v18 = *((_QWORD *)v56 + 3);
    }
    else
    {
      v18 = 0;
    }
    _Block_object_dispose(&v51, 8);
    _Block_object_dispose(type, 8);
    if (v18 == size)
    {

      v19 = *(id *)(a2 + 8);
      v20 = v19;
      if (v8 > 0xFF)
        goto LABEL_31;
      v21 = &v15[size + 1];
      *v21 = v8;
      v22 = v21 + 1;
      *(_QWORD *)type = 0;
      v56 = type;
      v57 = 0x2000000000;
      v58 = 0;
      v51 = 0;
      v52 = &v51;
      v53 = 0x2000000000;
      v54 = v22;
      if (v19)
      {
        *(_QWORD *)applier = MEMORY[0x1E0C809B0];
        *(_QWORD *)&applier[8] = 0x40000000;
        *(_QWORD *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
        v60 = &unk_1E14A3448;
        v62 = &v51;
        v63 = v8;
        v61 = type;
        dispatch_data_apply(v19, applier);
        v23 = *((_QWORD *)v56 + 3);
      }
      else
      {
        v23 = 0;
      }
      _Block_object_dispose(&v51, 8);
      _Block_object_dispose(type, 8);
      if (v23 == v8)
      {

        v25 = *(id *)(a2 + 16);
        v26 = v25;
        if (v10 > 0xFF)
          goto LABEL_42;
        v22[v8] = v10;
        v27 = (uint64_t)&v22[v8 + 1];
        *(_QWORD *)type = 0;
        v56 = type;
        v57 = 0x2000000000;
        v58 = 0;
        v51 = 0;
        v52 = &v51;
        v53 = 0x2000000000;
        v54 = (char *)v27;
        if (v25)
        {
          *(_QWORD *)applier = MEMORY[0x1E0C809B0];
          *(_QWORD *)&applier[8] = 0x40000000;
          *(_QWORD *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
          v60 = &unk_1E14A3448;
          v62 = &v51;
          v63 = v10;
          v61 = type;
          dispatch_data_apply(v25, applier);
          v28 = *((_QWORD *)v56 + 3);
        }
        else
        {
          v28 = 0;
        }
        _Block_object_dispose(&v51, 8);
        _Block_object_dispose(type, 8);
        if (v28 == v10)
        {

          v31 = *(id *)(a2 + 24);
          v32 = v31;
          if (v12 <= 0xFF)
          {
            v33 = (_BYTE *)(v27 + v10);
            *v33 = v12;
            v34 = (uint64_t)(v33 + 1);
            if (nw_dispatch_data_copyout(v31, v34, v12) == v12)
            {

              *(_BYTE *)(v34 + v12) = *(_BYTE *)(a2 + 32);
              goto LABEL_36;
            }
          }

          __nwlog_obj();
          v29 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)applier = 136446210;
            *(_QWORD *)&applier[4] = "qpod_options_serialize";
            _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, "%{public}s failed to serialize dcid in qpod options", applier, 0xCu);
          }
        }
        else
        {
LABEL_42:

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v29 = (id)gLogObj;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)applier = 136446210;
            *(_QWORD *)&applier[4] = "qpod_options_serialize";
            _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, "%{public}s failed to serialize scid in qpod options", applier, 0xCu);
          }
        }
      }
      else
      {
LABEL_31:

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = (id)gLogObj;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)applier = 136446210;
          *(_QWORD *)&applier[4] = "qpod_options_serialize";
          _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_ERROR, "%{public}s failed to serialize server_secret in qpod options", applier, 0xCu);
        }
      }

    }
    else
    {
LABEL_22:

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (id)gLogObj;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)applier = 136446210;
        *(_QWORD *)&applier[4] = "qpod_options_serialize";
        _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s failed to serialize client_secret in qpod options", applier, 0xCu);
      }

      if (!v15)
        goto LABEL_35;
    }
LABEL_34:
    free(v15);
LABEL_35:
    v15 = 0;
LABEL_36:

    return (BOOL)v15;
  }
  __nwlog_obj();
  v42 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446722;
  *(_QWORD *)&applier[4] = "strict_calloc";
  *(_WORD *)&applier[12] = 2048;
  *(_QWORD *)&applier[14] = 1;
  *(_WORD *)&applier[22] = 2048;
  v60 = (void *)v14;
  v43 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v43);
  if (!result)
  {
    free(v43);
    goto LABEL_14;
  }
LABEL_86:
  __break(1u);
  return result;
}

void sub_1838F0BEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL qpod_options_deserialize(void *a1, uint64_t a2, uint64_t a3)
{
  id v5;
  _QWORD *v6;
  void (**v7)(void *, os_log_type_t *);
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  _BOOL8 result;
  void *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  NSObject *v25;
  void *v26;
  char *backtrace_string;
  os_log_type_t v28;
  _BOOL4 v29;
  os_log_type_t v30;
  _QWORD aBlock[5];
  os_log_type_t type[15];
  char v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v35 = "qpod_options_deserialize";
    v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v22, type, &v33))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "qpod_options_deserialize";
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with null serialized_buffer", buf, 0xCu);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v28 = type[0];
        v29 = os_log_type_enabled(v23, type[0]);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            v35 = "qpod_options_deserialize";
            v36 = 2082;
            v37 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v23, v28, "%{public}s called with null serialized_buffer, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_43;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          v35 = "qpod_options_deserialize";
          _os_log_impl(&dword_182FBE000, v23, v28, "%{public}s called with null serialized_buffer, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v23 = objc_claimAutoreleasedReturnValue();
        v30 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "qpod_options_deserialize";
          _os_log_impl(&dword_182FBE000, v23, v30, "%{public}s called with null serialized_buffer, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_43:
    if (v22)
      free(v22);
    v6 = 0;
    goto LABEL_24;
  }
  v6 = malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  if (v6)
    goto LABEL_3;
  __nwlog_obj();
  v25 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v35 = "strict_calloc";
  v36 = 2048;
  v37 = 1;
  v38 = 2048;
  v39 = 40;
  v26 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
LABEL_3:
    aBlock[4] = a2 + a3;
    *(_QWORD *)type = a2;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZL24qpod_options_deserializePU36objcproto25OS_nw_protocol_definition8NSObjectPKvm_block_invoke;
    aBlock[3] = &__block_descriptor_40_e37___NSObject_OS_dispatch_data__16__0__8l;
    v7 = (void (**)(void *, os_log_type_t *))_Block_copy(aBlock);
    v7[2](v7, type);
    v8 = objc_claimAutoreleasedReturnValue();
    v9 = (void *)*v6;
    *v6 = v8;

    v10 = MEMORY[0x1E0C80D00];
    if (v8 == MEMORY[0x1E0C80D00])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (id)gLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v35 = "qpod_options_deserialize";
        v19 = "%{public}s failed to deserialize client_secret in qpod options";
        goto LABEL_21;
      }
    }
    else
    {
      v7[2](v7, type);
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = (void *)v6[1];
      v6[1] = v11;

      if (v11 == v10)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = (id)gLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "qpod_options_deserialize";
          v19 = "%{public}s failed to deserialize server_secret in qpod options";
          goto LABEL_21;
        }
      }
      else
      {
        v7[2](v7, type);
        v13 = objc_claimAutoreleasedReturnValue();
        v14 = (void *)v6[2];
        v6[2] = v13;

        if (v13 == v10)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v18 = (id)gLogObj;
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            v35 = "qpod_options_deserialize";
            v19 = "%{public}s failed to deserialize scid in qpod options";
            goto LABEL_21;
          }
        }
        else
        {
          v7[2](v7, type);
          v15 = objc_claimAutoreleasedReturnValue();
          v16 = (void *)v6[3];
          v6[3] = v15;

          if (v15 == v10)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v18 = (id)gLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v35 = "qpod_options_deserialize";
              v19 = "%{public}s failed to deserialize dcid in qpod options";
              goto LABEL_21;
            }
          }
          else
          {
            v17 = *(_QWORD *)type + 1;
            if (*(_QWORD *)type + 1 <= (unint64_t)(a2 + a3))
            {
              *((_BYTE *)v6 + 32) = **(_BYTE **)type;
              *(_QWORD *)type = v17;
              if (v17 - a2 == a3)
              {
LABEL_23:

LABEL_24:
                return (BOOL)v6;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v18 = (id)gLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                v35 = "qpod_options_deserialize";
                v19 = "%{public}s failed to deserialize qpod options";
                goto LABEL_21;
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v18 = (id)gLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                v35 = "qpod_options_deserialize";
                v19 = "%{public}s failed to deserialize is_server in qpod options";
LABEL_21:
                _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_ERROR, v19, buf, 0xCu);
              }
            }
          }
        }
      }
    }

    free(v6);
    v6 = 0;
    goto LABEL_23;
  }
  __break(1u);
  return result;
}

void sub_1838F12DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

dispatch_data_t ___ZL24qpod_options_deserializePU36objcproto25OS_nw_protocol_definition8NSObjectPKvm_block_invoke(uint64_t a1, _QWORD *a2)
{
  const void *v3;
  size_t v5;
  dispatch_data_t v6;
  id v7;

  v3 = (const void *)(*a2 + 1);
  if ((unint64_t)v3 <= *(_QWORD *)(a1 + 32)
    && (v5 = *(unsigned __int8 *)*a2, *a2 = v3, (unint64_t)v3 + v5 <= *(_QWORD *)(a1 + 32)))
  {
    v6 = dispatch_data_create(v3, v5, 0, 0);
    *a2 += v5;
  }
  else
  {
    v6 = (dispatch_data_t)MEMORY[0x1E0C80D00];
    v7 = MEMORY[0x1E0C80D00];
  }
  return v6;
}

uint64_t __nw_protocol_copy_qpod_definition_block_invoke_30(uint64_t a1, void *a2)
{
  NSObject *v2;
  nw_protocol_options_t v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD cleanup_handler[5];
  _QWORD output_handler[4];
  NSObject *v11;
  _QWORD *v12;
  _QWORD input_handler[4];
  NSObject *v14;
  _QWORD *v15;
  _QWORD v16[4];
  NSObject *v17;
  _QWORD *v18;
  _QWORD v19[4];

  v2 = a2;
  v19[0] = 0;
  v19[1] = v19;
  v19[2] = 0x2020000000;
  v19[3] = 0;
  v3 = nw_framer_copy_options(v2);
  v4 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = __nw_protocol_copy_qpod_definition_block_invoke_2;
  v16[3] = &unk_1E14A4F78;
  v5 = v2;
  v17 = v5;
  v18 = v19;
  nw_protocol_options_access_handle(v3, v16);
  input_handler[0] = v4;
  input_handler[1] = 3221225472;
  input_handler[2] = __nw_protocol_copy_qpod_definition_block_invoke_35;
  input_handler[3] = &unk_1E14A4FF0;
  v6 = v5;
  v14 = v6;
  v15 = v19;
  nw_framer_set_input_handler(v6, input_handler);
  output_handler[0] = v4;
  output_handler[1] = 3221225472;
  output_handler[2] = __nw_protocol_copy_qpod_definition_block_invoke_4;
  output_handler[3] = &unk_1E14A5040;
  v7 = v6;
  v11 = v7;
  v12 = v19;
  nw_framer_set_output_handler(v7, output_handler);
  cleanup_handler[0] = v4;
  cleanup_handler[1] = 3221225472;
  cleanup_handler[2] = __nw_protocol_copy_qpod_definition_block_invoke_3_44;
  cleanup_handler[3] = &unk_1E14A5068;
  cleanup_handler[4] = v19;
  nw_framer_set_cleanup_handler(v7, cleanup_handler);
  nw_framer_set_stop_handler(v7, &__block_literal_global_48_56188);

  _Block_object_dispose(v19, 8);
  return 1;
}

void sub_1838F14FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31)
{
  void *v31;
  void *v32;
  uint64_t v33;

  _Block_object_dispose((const void *)(v33 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_copy_qpod_definition_block_invoke_2(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  int v7;
  id v8;
  id v9;
  id v10;
  id v11;
  uint64_t override;
  uint64_t v13;
  NSObject *v15;
  uint64_t v16;
  const char *v17;
  int v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    __nwlog_obj();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v16 = *(_QWORD *)(a1 + 32);
      if (*(_BYTE *)(a2 + 32))
        v17 = "server";
      else
        v17 = "client";
      v18 = 136446978;
      v19 = "nw_protocol_copy_qpod_definition_block_invoke_2";
      v20 = 2048;
      v21 = v16;
      v22 = 2080;
      v23 = v17;
      v24 = 2048;
      v25 = a2;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s created framer %p for %s with options %p", (uint8_t *)&v18, 0x2Au);
    }

  }
  v4 = *(void **)(a2 + 24);
  v5 = *(void **)a2;
  v6 = *(void **)(a2 + 8);
  v7 = *(unsigned __int8 *)(a2 + 32);
  v8 = *(id *)(a2 + 16);
  v9 = v4;
  v10 = v5;
  v11 = v6;
  if (qpod_conn_create_override)
  {
    override = qpod_conn_create_override(v8, v9, v10, v11, v7 != 0);
  }
  else
  {
    if (!MEMORY[0x1E0DE8450])
    {
      v13 = 0;
      goto LABEL_7;
    }
    override = qpod_conn_create();
  }
  v13 = override;
LABEL_7:

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v13;
  return 1;
}

void sub_1838F16E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_copy_qpod_definition_block_invoke_35(uint64_t a1, void *a2)
{
  NSObject *v3;
  id v4;
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  _QWORD parse[4];
  __int128 v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (gLogDatapath)
  {
    __nwlog_obj();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      v7 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      v12 = "nw_protocol_copy_qpod_definition_block_invoke";
      v13 = 2048;
      v14 = v7;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "%{public}s handling input for framer %p", buf, 0x16u);
    }

  }
  parse[0] = MEMORY[0x1E0C809B0];
  parse[1] = 3221225472;
  parse[2] = __nw_protocol_copy_qpod_definition_block_invoke_36;
  parse[3] = &unk_1E14A4FC8;
  v8 = *(_OWORD *)(a1 + 32);
  v4 = (id)v8;
  v10 = v8;
  nw_framer_parse_input(v3, 0, 0x7D0uLL, 0, parse);

  return 0;
}

void sub_1838F184C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void __nw_protocol_copy_qpod_definition_block_invoke_4(uint64_t a1, void *a2)
{
  NSObject *v3;
  id v4;
  NSObject *v5;
  uint64_t v6;
  __int128 v7;
  _QWORD parse[4];
  __int128 v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (gLogDatapath)
  {
    __nwlog_obj();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136446466;
      v11 = "nw_protocol_copy_qpod_definition_block_invoke_4";
      v12 = 2048;
      v13 = v6;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s handling output for framer %p", buf, 0x16u);
    }

  }
  parse[0] = MEMORY[0x1E0C809B0];
  parse[1] = 3221225472;
  parse[2] = __nw_protocol_copy_qpod_definition_block_invoke_41;
  parse[3] = &unk_1E14A4FC8;
  v7 = *(_OWORD *)(a1 + 32);
  v4 = (id)v7;
  v9 = v7;
  nw_framer_parse_output(v3, 0, 0x7D0uLL, 0, parse);

}

void sub_1838F19AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void __nw_protocol_copy_qpod_definition_block_invoke_3_44(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  id v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (gLogDatapath)
  {
    __nwlog_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = 136446466;
      v6 = "nw_protocol_copy_qpod_definition_block_invoke_3";
      v7 = 2048;
      v8 = v3;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, "%{public}s cleaning up framer %p", (uint8_t *)&v5, 0x16u);
    }

  }
  if (qpod_conn_free_override)
  {
    qpod_conn_free_override(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  }
  else if (MEMORY[0x1E0DE8468])
  {
    qpod_conn_free();
  }

}

void sub_1838F1AD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_copy_qpod_definition_block_invoke_46(uint64_t a1, void *a2)
{
  id v2;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  id v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  if (gLogDatapath)
  {
    __nwlog_obj();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      v5 = 136446466;
      v6 = "nw_protocol_copy_qpod_definition_block_invoke";
      v7 = 2048;
      v8 = v2;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, "%{public}s stopping framer %p", (uint8_t *)&v5, 0x16u);
    }

  }
  return 1;
}

uint64_t __nw_protocol_copy_qpod_definition_block_invoke_41(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD v9[4];
  id v10;

  v5 = *(void **)(a1 + 32);
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __nw_protocol_copy_qpod_definition_block_invoke_2_42;
  v9[3] = &unk_1E14A5018;
  v10 = v5;
  v7 = v9;
  if (qpod_conn_encode_datagram_override)
  {
    qpod_conn_encode_datagram_override(v6, a2, (unsigned __int16)a3, v7);
  }
  else if (MEMORY[0x1E0DE8460])
  {
    qpod_conn_encode_datagram();
  }

  return a3;
}

void sub_1838F1C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void __nw_protocol_copy_qpod_definition_block_invoke_2_42(uint64_t a1, const uint8_t *a2, size_t output_length)
{
  nw_framer_write_output(*(nw_framer_t *)(a1 + 32), a2, output_length);
}

uint64_t __nw_protocol_copy_qpod_definition_block_invoke_36(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  void *v10;
  _QWORD v12[4];
  NSObject *v13;
  _QWORD v14[4];
  id v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2020000000;
  v21 = 0;
  v6 = *(void **)(a1 + 32);
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v14[2] = __nw_protocol_copy_qpod_definition_block_invoke_2_37;
  v14[3] = &unk_1E14A4FA0;
  v8 = MEMORY[0x1E0C809B0];
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v17 = a2;
  v15 = v6;
  v16 = &v18;
  v9 = v14;
  if (qpod_conn_decode_datagram_override)
  {
    qpod_conn_decode_datagram_override(v7, a2, (unsigned __int16)a3, v9);
  }
  else if (MEMORY[0x1E0DE8458])
  {
    qpod_conn_decode_datagram();
  }

  if (!*((_BYTE *)v19 + 24))
  {
    v10 = *(void **)(a1 + 32);
    v12[0] = v8;
    v12[1] = 3221225472;
    v12[2] = __nw_protocol_copy_qpod_definition_block_invoke_3;
    v12[3] = &unk_1E14ACFD0;
    v13 = v10;
    nw_framer_async(v13, v12);

  }
  _Block_object_dispose(&v18, 8);
  return a3;
}

void sub_1838F1E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_protocol_copy_qpod_definition_block_invoke_2_37(uint64_t a1, const uint8_t *a2, unsigned int a3)
{
  NSObject *v3;
  size_t v7;
  NSObject *v8;

  v3 = *(NSObject **)(a1 + 32);
  if (a3 == 0xFFFF && *(_QWORD *)(a1 + 48) == (_QWORD)a2)
  {
    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 54);
  }
  else
  {
    v7 = a3;
    v8 = nw_framer_message_create(*(nw_framer_t *)(a1 + 32));
    nw_framer_deliver_input(v3, a2, v7, v8, 1);

    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  }
}

void sub_1838F1ED4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void __nw_protocol_copy_qpod_definition_block_invoke_3(uint64_t a1)
{
  nw_framer_resume_input(*(void **)(a1 + 32));
}

uint64_t nw_qpod_setup_secrets(void *a1, void *a2, uint64_t a3, char a4)
{
  id v7;
  id v8;
  id v9;
  BOOL is_quic_stream;
  uint64_t v11;
  void *v13;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  void *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  char *v22;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  os_log_type_t v26;
  _QWORD v27[4];
  id v28;
  uint64_t v29;
  char v30;
  char v31;
  os_log_type_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  if (!nw_protocol_options_is_qpod(v7))
  {
    __nwlog_obj();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_qpod_setup_secrets";
    v14 = (char *)_os_log_send_and_compose_impl();

    v32 = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v14, &v32, &v31))
      goto LABEL_40;
    if (v32 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v16 = v32;
      if (os_log_type_enabled(v15, v32))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_qpod_setup_secrets";
        _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s called with null nw_protocol_options_is_qpod(options)", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v20 = v32;
      v21 = os_log_type_enabled(v15, v32);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_qpod_setup_secrets";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null nw_protocol_options_is_qpod(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v14)
          goto LABEL_42;
        goto LABEL_41;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_qpod_setup_secrets";
        _os_log_impl(&dword_182FBE000, v15, v20, "%{public}s called with null nw_protocol_options_is_qpod(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v25 = v32;
      if (os_log_type_enabled(v15, v32))
      {
        *(_DWORD *)buf = 136446210;
        v34 = "nw_qpod_setup_secrets";
        _os_log_impl(&dword_182FBE000, v15, v25, "%{public}s called with null nw_protocol_options_is_qpod(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_39;
  }
  v9 = v8;
  if (!nw_protocol_metadata_is_quic_connection(v9))
  {
    is_quic_stream = nw_protocol_metadata_is_quic_stream(v9);

    if (is_quic_stream)
      goto LABEL_5;
    __nwlog_obj();
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_qpod_setup_secrets";
    v14 = (char *)_os_log_send_and_compose_impl();

    v32 = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v14, &v32, &v31))
    {
      if (v32 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v18 = v32;
        if (os_log_type_enabled(v15, v32))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_qpod_setup_secrets";
          _os_log_impl(&dword_182FBE000, v15, v18, "%{public}s called with null nw_protocol_metadata_is_quic(quic_metadata)", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v31)
      {
        __nwlog_obj();
        v15 = objc_claimAutoreleasedReturnValue();
        v26 = v32;
        if (os_log_type_enabled(v15, v32))
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_qpod_setup_secrets";
          _os_log_impl(&dword_182FBE000, v15, v26, "%{public}s called with null nw_protocol_metadata_is_quic(quic_metadata), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v15 = objc_claimAutoreleasedReturnValue();
      v23 = v32;
      v24 = os_log_type_enabled(v15, v32);
      if (!v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          v34 = "nw_qpod_setup_secrets";
          _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null nw_protocol_metadata_is_quic(quic_metadata), no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        v34 = "nw_qpod_setup_secrets";
        v35 = 2082;
        v36 = v22;
        _os_log_impl(&dword_182FBE000, v15, v23, "%{public}s called with null nw_protocol_metadata_is_quic(quic_metadata), dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v22);
    }
LABEL_40:
    if (!v14)
    {
LABEL_42:
      v11 = 0;
      goto LABEL_6;
    }
LABEL_41:
    free(v14);
    goto LABEL_42;
  }

LABEL_5:
  v27[0] = MEMORY[0x1E0C809B0];
  v27[1] = 3221225472;
  v27[2] = __nw_qpod_setup_secrets_block_invoke;
  v27[3] = &unk_1E14A4F10;
  v29 = a3;
  v28 = v9;
  v30 = a4;
  v11 = nw_protocol_options_access_handle(v7, v27);

LABEL_6:
  return v11;
}

void sub_1838F2428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

uint64_t __nw_qpod_setup_secrets_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  unsigned int v6;
  NSObject *v7;
  dispatch_data_t secret;
  void *v9;
  dispatch_data_t v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v17;
  char label[16];
  char __str[16];
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (gLogDatapath)
  {
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v21 = "nw_qpod_setup_secrets_block_invoke";
      v22 = 2048;
      v23 = a2;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s setting up secrets for options %p", buf, 0x16u);
    }

  }
  if (*(_QWORD *)(a1 + 40))
  {
    v4 = snprintf(__str, 0x10uLL, "%s client", *(const char **)(a1 + 40));
    v5 = snprintf(label, 0x10uLL, "%s server", *(const char **)(a1 + 40));
    if ((v5 | v4) >= 0x10)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v14 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 136446466;
        v21 = "nw_qpod_setup_secrets_block_invoke";
        v22 = 2080;
        v23 = v14;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s identifier %s is too long", buf, 0x16u);
      }
    }
    else
    {
      v6 = v5;
      v7 = nw_quic_copy_sec_protocol_metadata(*(nw_protocol_metadata_t *)(a1 + 32));
      secret = sec_protocol_metadata_create_secret(v7, v4, __str, 0x20uLL);
      v9 = *(void **)a2;
      *(_QWORD *)a2 = secret;

      if (*(_QWORD *)a2)
      {
        v10 = sec_protocol_metadata_create_secret(v7, v6, label, 0x20uLL);
        v11 = *(void **)(a2 + 8);
        *(_QWORD *)(a2 + 8) = v10;

        if (*(_QWORD *)(a2 + 8))
        {
          *(_BYTE *)(a2 + 32) = *(_BYTE *)(a1 + 48);
          v12 = 1;
LABEL_19:

          return v12;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = (id)gLogObj;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_qpod_setup_secrets_block_invoke";
          _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s failed to create server secret", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = (id)gLogObj;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_qpod_setup_secrets_block_invoke";
          _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s failed to create client secret", buf, 0xCu);
        }
      }

    }
    v12 = 0;
    goto LABEL_19;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v13 = (id)gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    v21 = "nw_qpod_setup_secrets_block_invoke";
    _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_ERROR, "%{public}s missing identifier", buf, 0xCu);
  }

  return 0;
}

void sub_1838F27E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_qpod_set_scid(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_options_is_qpod(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_qpod_set_scid_block_invoke;
    v13[3] = &unk_1E14A9F20;
    v14 = v4;
    nw_protocol_options_access_handle(v3, v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_qpod_set_scid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_qpod_set_scid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_options_is_qpod(options)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_qpod_set_scid";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_qpod(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_qpod_set_scid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_qpod(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_qpod_set_scid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_options_is_qpod(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1838F2AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_qpod_set_scid_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 16), *(id *)(a1 + 32));
  return 1;
}

void nw_qpod_set_dcid(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  id v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (nw_protocol_options_is_qpod(v3))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_qpod_set_dcid_block_invoke;
    v13[3] = &unk_1E14A9F20;
    v14 = v4;
    nw_protocol_options_access_handle(v3, v13);

    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_qpod_set_dcid";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_qpod_set_dcid";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null nw_protocol_options_is_qpod(options)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_qpod_set_dcid";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_qpod(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_qpod_set_dcid";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null nw_protocol_options_is_qpod(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_qpod_set_dcid";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null nw_protocol_options_is_qpod(options), backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void sub_1838F2E14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

uint64_t __nw_qpod_set_dcid_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 24), *(id *)(a1 + 32));
  return 1;
}

id nw_protocol_copy_qpod_definition()
{
  if (nw_protocol_copy_qpod_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_qpod_definition::onceToken, &__block_literal_global_28_56150);
  return (id)nw_protocol_copy_qpod_definition::definition;
}

nw_protocol_options_t nw_qpod_create_options()
{
  if (nw_protocol_copy_qpod_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_qpod_definition::onceToken, &__block_literal_global_28_56150);
  return nw_framer_create_options((nw_protocol_definition_t)nw_protocol_copy_qpod_definition::definition);
}

id *nw_parameters_create_qpod(void *a1)
{
  void (**v1)(id, nw_protocol_options_t);
  nw_parameters_t v2;
  nw_parameters_t v3;
  nw_protocol_options_t options;
  id *v5;
  id v6;
  id *v7;
  id v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  os_log_type_t v22;
  os_log_type_t v23;
  void *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  os_log_type_t v32;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = nw_parameters_create();
    v3 = v2;
    if (v2)
    {
      nw_parameters_set_data_mode(v2, 1u);
      if (nw_protocol_copy_qpod_definition::onceToken != -1)
        dispatch_once(&nw_protocol_copy_qpod_definition::onceToken, &__block_literal_global_28_56150);
      options = nw_framer_create_options((nw_protocol_definition_t)nw_protocol_copy_qpod_definition::definition);
      if (options)
      {
        v5 = v3;
        v6 = v5[19];

        nw_protocol_stack_append_application_protocol(v6, options);
        if (v1 != (void (**)(id, nw_protocol_options_t))&__block_literal_global_86)
          v1[2](v1, options);
        v7 = v5;

        goto LABEL_49;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v36 = "nw_parameters_create_qpod";
      v13 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v33 = 0;
      if (__nwlog_fault(v13, &type, &v33))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (id)gLogObj;
          v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            v36 = "nw_parameters_create_qpod";
            _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s nw_framer_create_options failed", buf, 0xCu);
          }
        }
        else if (v33)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (id)gLogObj;
          v20 = type;
          v21 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v21)
            {
              *(_DWORD *)buf = 136446466;
              v36 = "nw_parameters_create_qpod";
              v37 = 2082;
              v38 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s nw_framer_create_options failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v13)
              goto LABEL_48;
            goto LABEL_47;
          }
          if (v21)
          {
            *(_DWORD *)buf = 136446210;
            v36 = "nw_parameters_create_qpod";
            _os_log_impl(&dword_182FBE000, v14, v20, "%{public}s nw_framer_create_options failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (id)gLogObj;
          v23 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            v36 = "nw_parameters_create_qpod";
            _os_log_impl(&dword_182FBE000, v14, v23, "%{public}s nw_framer_create_options failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v13)
      {
LABEL_48:
        v7 = 0;
LABEL_49:

        goto LABEL_50;
      }
LABEL_47:
      free(v13);
      goto LABEL_48;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v36 = "nw_parameters_create_qpod";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_parameters_create_qpod";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s nw_parameters_create failed", buf, 0xCu);
        }
      }
      else if (v33)
      {
        v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v17 = type;
        v18 = os_log_type_enabled(v10, type);
        if (v16)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v36 = "nw_parameters_create_qpod";
            v37 = 2082;
            v38 = v16;
            _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v16);
          if (!v9)
            goto LABEL_39;
          goto LABEL_38;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_parameters_create_qpod";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v10 = (id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v36 = "nw_parameters_create_qpod";
          _os_log_impl(&dword_182FBE000, v10, v22, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v9)
    {
LABEL_39:
      v7 = 0;
LABEL_50:

      goto LABEL_51;
    }
LABEL_38:
    free(v9);
    goto LABEL_39;
  }
  __nwlog_obj();
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v36 = "nw_parameters_create_qpod";
  v26 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v33 = 0;
  if (__nwlog_fault(v26, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_parameters_create_qpod";
        _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null configure_qpod", buf, 0xCu);
      }
    }
    else if (v33)
    {
      v29 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      v31 = os_log_type_enabled(v27, type);
      if (v29)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v36 = "nw_parameters_create_qpod";
          v37 = 2082;
          v38 = v29;
          _os_log_impl(&dword_182FBE000, v27, v30, "%{public}s called with null configure_qpod, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v29);
        goto LABEL_68;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_parameters_create_qpod";
        _os_log_impl(&dword_182FBE000, v27, v30, "%{public}s called with null configure_qpod, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v36 = "nw_parameters_create_qpod";
        _os_log_impl(&dword_182FBE000, v27, v32, "%{public}s called with null configure_qpod, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_68:
  if (v26)
    free(v26);
  v7 = 0;
LABEL_51:

  return v7;
}

void sub_1838F36F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t nw_browser_get_description(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  int v3;
  os_unfair_lock_s *v4;
  char *v5;
  uint32_t os_unfair_lock_opaque;
  const char *description;
  uint32_t v8;
  const char *v9;
  uint64_t v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = BYTE2(v1[49]._os_unfair_lock_opaque);
    os_unfair_lock_lock(v1 + 2);
    if (v3)
    {
      v4 = v2 + 44;
      if (!*(_QWORD *)&v2[44]._os_unfair_lock_opaque)
      {
        v5 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)&v2[10]._os_unfair_lock_opaque, 0);
        os_unfair_lock_opaque = v2[48]._os_unfair_lock_opaque;
        description = nw_browse_descriptor_get_description(*(void **)&v2[8]._os_unfair_lock_opaque, 1);
        asprintf((char **)&v2[44], "[B%u %s, %s]", os_unfair_lock_opaque, description, v5);
        goto LABEL_7;
      }
    }
    else
    {
      v4 = v2 + 46;
      if (!*(_QWORD *)&v2[46]._os_unfair_lock_opaque)
      {
        v5 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)&v2[10]._os_unfair_lock_opaque, 0);
        v8 = v2[48]._os_unfair_lock_opaque;
        v9 = nw_browse_descriptor_get_description(*(void **)&v2[8]._os_unfair_lock_opaque, 0);
        asprintf((char **)&v2[46], "[B%u %s, %s]", v8, v9, v5);
LABEL_7:
        if (v5)
          free(v5);
      }
    }
    os_unfair_lock_unlock(v2 + 2);
    v10 = *(_QWORD *)&v4->_os_unfair_lock_opaque;
    goto LABEL_10;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_browser_get_description";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_browser_get_description";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_browser_get_description";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_browser_get_description";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_browser_get_description";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_27:
  if (v13)
    free(v13);
  v10 = 0;
LABEL_10:

  return v10;
}

void sub_1838F42DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_browser_get_next_log_id(void)
{
  unsigned int v0;
  uint64_t result;
  NSObject *v2;
  int v3;
  const char *v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  do
  {
    v0 = __ldaxr(nw_browser_get_next_log_id(void)::s_last_top_level_id);
    result = v0 + 1;
  }
  while (__stlxr(result, nw_browser_get_next_log_id(void)::s_last_top_level_id));
  if (v0 == -2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = 136446466;
      v4 = "nw_browser_get_next_log_id";
      v5 = 1024;
      v6 = -1;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_ERROR, "%{public}s reached %u browser logging ids, wrapping", (uint8_t *)&v3, 0x12u);
    }

    return nw_browser_get_next_log_id();
  }
  return result;
}

nw_browser_t nw_browser_create(nw_browse_descriptor_t descriptor, nw_parameters_t parameters)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  NWConcrete_nw_browser *v7;
  NSObject *v8;
  NSObject *v9;
  id v10;
  void *v11;
  int v12;
  BOOL v13;
  int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  int v18;
  void *v19;
  NSObject *v20;
  nw_parameters_t v21;
  void *v22;
  id v23;
  id v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  char *v28;
  NSObject *v29;
  int v30;
  uint64_t v31;
  char *backtrace_string;
  os_log_type_t v34;
  _BOOL4 v35;
  os_log_type_t v36;
  void *v37;
  char *v38;
  NSObject *v39;
  os_log_type_t receiver;
  void *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  char *v45;
  os_log_type_t v46;
  _BOOL4 v47;
  char *v48;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  os_log_type_t v52;
  NSObject *v53;
  char v54;
  os_log_type_t type;
  objc_super v56;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  _BYTE v60[14];
  __int16 v61;
  char *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v4 = descriptor;
  v5 = parameters;
  v6 = v5;
  if (v4)
  {
    v53 = v5;
    v7 = [NWConcrete_nw_browser alloc];
    v8 = v4;
    v9 = v6;
    if (!v7)
    {
LABEL_21:
      v17 = 0;
LABEL_51:

      v6 = v53;
      goto LABEL_52;
    }
    *((_DWORD *)v7 + 48) = nw_browser_get_next_log_id();
    if (v9)
    {
      *((_BYTE *)v7 + 198) = nw_parameters_get_sensitive_redacted(v9);
    }
    else
    {
      if (nw_context_copy_implicit_context::onceToken[0] != -1)
        dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      v10 = (id)nw_context_copy_implicit_context::implicit_context;
      v11 = v10;
      if (v10 && (v12 = *((_DWORD *)v10 + 31), (v12 - 2) >= 2))
      {
        v13 = v12 != 1;
      }
      else
      {
        if (nwlog_get_sensitive_redacted::onceToken != -1)
          dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
        v13 = nwlog_get_sensitive_redacted::sensitiveRedacted != 0;
      }

      *((_BYTE *)v7 + 198) = v13;
    }
    v14 = nw_browse_descriptor_get_type(v8);
    if (v14 == 1)
    {
      v18 = 3;
    }
    else
    {
      if (!v14)
      {
        if (!nw_parameters_get_logging_disabled(*((_QWORD *)v7 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v15 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            v16 = *((_DWORD *)v7 + 48);
            *(_DWORD *)buf = 136446466;
            v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            v59 = 1024;
            *(_DWORD *)v60 = v16;
            _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s [B%u] failed due to invalid descriptor type", buf, 0x12u);
          }

        }
        goto LABEL_21;
      }
      if (nw_browse_descriptor_is_custom_type(v8))
      {
        v19 = nw_browse_descriptor_copy_custom_browse_block(v8);

        if (v19)
          v18 = 1;
        else
          v18 = 2;
      }
      else
      {
        v18 = 2;
      }
    }
    v56.receiver = v7;
    v56.super_class = (Class)NWConcrete_nw_browser;
    v20 = -[NSObject init](&v56, sel_init);
    v7 = (NWConcrete_nw_browser *)v20;
    if (v20)
    {
      objc_storeStrong((id *)&v20[4].isa, descriptor);
      *((_DWORD *)v7 + 6) = v18;
      *((_DWORD *)v7 + 18) = 0;
      if (v9)
        v21 = v9;
      else
        v21 = nw_parameters_create();
      v22 = (void *)*((_QWORD *)v7 + 5);
      *((_QWORD *)v7 + 5) = v21;

      v23 = nw_parameters_copy_context(*((void **)v7 + 5));
      if (!nw_context_is_inline(v23))
      {
        *((_BYTE *)v7 + 196) = nw_browse_descriptor_get_include_txt_record(*((nw_browse_descriptor_t *)v7 + 4));
        *((_BYTE *)v7 + 197) = nw_browse_descriptor_get_sign_results(*((void **)v7 + 4));
        v28 = nw_parameters_copy_description_internal(*((NWConcrete_nw_parameters **)v7 + 5), 1);
        if (!nw_parameters_get_logging_disabled(*((_QWORD *)v7 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v29 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            v30 = *((_DWORD *)v7 + 48);
            v31 = *((_QWORD *)v7 + 4);
            *(_DWORD *)buf = 136446978;
            v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            v59 = 1024;
            *(_DWORD *)v60 = v30;
            *(_WORD *)&v60[4] = 2112;
            *(_QWORD *)&v60[6] = v31;
            v61 = 2080;
            v62 = v28;
            _os_log_impl(&dword_182FBE000, v29, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] create with %@, parameters: %s", buf, 0x26u);
          }

        }
        if (v28)
          free(v28);
        v17 = v7;
        goto LABEL_50;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v24 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
      v25 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v54 = 0;
      if ((__nwlog_fault(v25, &type, &v54) & 1) != 0)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = (id)gLogObj;
          v27 = type;
          if (os_log_type_enabled(v26, type))
          {
            *(_DWORD *)buf = 136446210;
            v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s Cannot use nw_browser on inline contexts", buf, 0xCu);
          }
        }
        else if (v54)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = (id)gLogObj;
          v34 = type;
          v35 = os_log_type_enabled(v26, type);
          if (backtrace_string)
          {
            if (v35)
            {
              *(_DWORD *)buf = 136446466;
              v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
              v59 = 2082;
              *(_QWORD *)v60 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v26, v34, "%{public}s Cannot use nw_browser on inline contexts, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v25)
              goto LABEL_40;
            goto LABEL_39;
          }
          if (v35)
          {
            *(_DWORD *)buf = 136446210;
            v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            _os_log_impl(&dword_182FBE000, v26, v34, "%{public}s Cannot use nw_browser on inline contexts, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v26 = (id)gLogObj;
          v36 = type;
          if (os_log_type_enabled(v26, type))
          {
            *(_DWORD *)buf = 136446210;
            v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            _os_log_impl(&dword_182FBE000, v26, v36, "%{public}s Cannot use nw_browser on inline contexts, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v25)
      {
LABEL_40:
        v17 = 0;
LABEL_50:

        goto LABEL_51;
      }
LABEL_39:
      free(v25);
      goto LABEL_40;
    }
    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
    v42 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v54 = 0;
    if (__nwlog_fault(v42, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136446210;
          v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
          _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v54)
      {
        v48 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v49 = type;
        v50 = os_log_type_enabled(v43, type);
        if (v48)
        {
          if (v50)
          {
            *(_DWORD *)buf = 136446466;
            v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            v59 = 2082;
            *(_QWORD *)v60 = v48;
            _os_log_impl(&dword_182FBE000, v43, v49, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v48);
          goto LABEL_101;
        }
        if (v50)
        {
          *(_DWORD *)buf = 136446210;
          v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
          _os_log_impl(&dword_182FBE000, v43, v49, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v52 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136446210;
          v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
          _os_log_impl(&dword_182FBE000, v43, v52, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_101:
    if (v42)
      free(v42);
    v7 = 0;
    goto LABEL_21;
  }
  __nwlog_obj();
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v58 = "nw_browser_create";
  v38 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v56.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v38, &v56, &type))
  {
    if (LOBYTE(v56.receiver) == 17)
    {
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)v56.receiver;
      if (os_log_type_enabled(v39, (os_log_type_t)v56.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_browser_create";
        _os_log_impl(&dword_182FBE000, v39, receiver, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (type)
    {
      v45 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      v46 = (os_log_type_t)v56.receiver;
      v47 = os_log_type_enabled(v39, (os_log_type_t)v56.receiver);
      if (v45)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          v58 = "nw_browser_create";
          v59 = 2082;
          *(_QWORD *)v60 = v45;
          _os_log_impl(&dword_182FBE000, v39, v46, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v45);
        goto LABEL_95;
      }
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_browser_create";
        _os_log_impl(&dword_182FBE000, v39, v46, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v39 = objc_claimAutoreleasedReturnValue();
      v51 = (os_log_type_t)v56.receiver;
      if (os_log_type_enabled(v39, (os_log_type_t)v56.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v58 = "nw_browser_create";
        _os_log_impl(&dword_182FBE000, v39, v51, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_95:
  if (v38)
    free(v38);
  v17 = 0;
LABEL_52:

  return v17;
}

void sub_1838F4E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void nw_browser_set_browse_results_changed_handler(nw_browser_t browser, nw_browser_browse_results_changed_handler_t handler)
{
  nw_browser_t v3;
  nw_browser_browse_results_changed_handler_t v4;
  objc_class *v5;
  Class isa;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = browser;
  v4 = handler;
  if (v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v5 = (objc_class *)_Block_copy(v4);
    isa = v3[7].isa;
    v3[7].isa = v5;

    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_browser_set_browse_results_changed_handler";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browser_set_browse_results_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_browser_set_browse_results_changed_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browser_set_browse_results_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browser_set_browse_results_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

}

void nw_browser_set_state_changed_handler(nw_browser_t browser, nw_browser_state_changed_handler_t state_changed_handler)
{
  nw_browser_t v3;
  nw_browser_state_changed_handler_t v4;
  objc_class *v5;
  Class isa;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v3 = browser;
  v4 = state_changed_handler;
  if (v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v5 = (objc_class *)_Block_copy(v4);
    isa = v3[8].isa;
    v3[8].isa = v5;

    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
    goto LABEL_3;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_browser_set_state_changed_handler";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browser_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_browser_set_state_changed_handler";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browser_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_browser_set_state_changed_handler";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v8)
    free(v8);
LABEL_3:

}

void nw_browser_set_queue(nw_browser_t browser, dispatch_queue_t queue)
{
  nw_browser_t v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  char v20;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v3 = browser;
  v4 = queue;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v23 = "nw_browser_set_queue";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_browser_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v23 = "nw_browser_set_queue";
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7)
          goto LABEL_4;
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_browser_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "nw_browser_set_queue";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    objc_storeStrong((id *)&v3[2].isa, queue);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
    goto LABEL_4;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v23 = "nw_browser_set_queue";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_browser_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_browser_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v23 = "nw_browser_set_queue";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v23 = "nw_browser_set_queue";
    v24 = 2082;
    v25 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_39;
LABEL_4:

}

void nw_browser_start(nw_browser_t browser)
{
  nw_browser_t v2;
  nw_browser_t v3;
  int isa;
  os_unfair_lock_s *v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  int v9;
  objc_class *v10;
  Class v11;
  objc_class *v12;
  Class v13;
  _BOOL8 v14;
  Class v15;
  _BOOL8 v16;
  Class v17;
  objc_class *v18;
  Class v19;
  id v20;
  int v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  int v25;
  int v26;
  int v27;
  nw_browser_t v28;
  void *v29;
  void *v30;
  NSObject *v31;
  int v32;
  id v33;
  id v34;
  NSObject *v35;
  char *v36;
  NSObject *v37;
  int v38;
  const char *v39;
  id v40;
  int v41;
  int v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  int v46;
  int v47;
  const char *v48;
  char *v49;
  NSObject *v50;
  os_log_type_t v51;
  int v52;
  pid_t v53;
  int pid;
  NSObject *v55;
  int v56;
  int Connection;
  NSObject *v58;
  int v59;
  const char *v60;
  char *v61;
  NSObject *v62;
  os_log_type_t v63;
  int v64;
  int v65;
  os_log_type_t v66;
  int v67;
  os_log_type_t v68;
  int v69;
  signed int v70;
  NSObject *v71;
  int v72;
  const char *string_for_dns_service_error;
  NSObject *v74;
  int v75;
  NSObject *v76;
  int v77;
  os_log_type_t v78;
  int v79;
  int v80;
  _DNSServiceRef_t *v81;
  id v82;
  _BOOL8 v83;
  nw_interface_t v84;
  char *v85;
  uint64_t isa_low;
  os_log_type_t v87;
  int v88;
  int v89;
  uint64_t v90;
  const char *bonjour_service_type;
  const char *bonjour_service_domain;
  uint64_t v93;
  int v94;
  NSObject *v95;
  const char *v96;
  int v97;
  NSObject *v98;
  int v99;
  char *v100;
  NSObject *v101;
  int v102;
  void **v103;
  NWConcrete_nw_path_evaluator *evaluator_for_browse;
  uint64_t v105;
  char *v106;
  os_unfair_lock_s *v107;
  os_unfair_lock_s *v108;
  id *v109;
  id v110;
  id v111;
  char *v112;
  NSObject *v113;
  os_log_type_t v114;
  void *v115;
  id v116;
  char *v117;
  char *v118;
  os_log_type_t v119;
  _BOOL4 v120;
  void *v121;
  char *v122;
  NSObject *v123;
  os_log_type_t v124;
  os_log_type_t v125;
  char *backtrace_string;
  os_log_type_t v127;
  _BOOL4 v128;
  os_log_type_t v129;
  void *v130;
  char *v131;
  NSObject *v132;
  os_log_type_t v133;
  char *v134;
  os_log_type_t v135;
  _BOOL4 v136;
  os_log_type_t v137;
  char v138;
  os_log_type_t v139;
  _BYTE buf[40];
  id v141;
  _BYTE type[24];
  void *v143;
  char *v144;
  uint8_t v145[4];
  const char *v146;
  __int16 v147;
  char *v148;
  uint64_t v149;

  v149 = *MEMORY[0x1E0C80C00];
  v2 = browser;
  v3 = v2;
  if (!v2)
  {
    __nwlog_obj();
    v121 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browser_start";
    v122 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    v145[0] = 0;
    if (__nwlog_fault(v122, type, v145))
    {
      if (type[0] == 17)
      {
        __nwlog_obj();
        v123 = objc_claimAutoreleasedReturnValue();
        v124 = type[0];
        if (os_log_type_enabled(v123, (os_log_type_t)type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_start";
          _os_log_impl(&dword_182FBE000, v123, v124, "%{public}s called with null browser", buf, 0xCu);
        }
      }
      else if (v145[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v123 = objc_claimAutoreleasedReturnValue();
        v127 = type[0];
        v128 = os_log_type_enabled(v123, (os_log_type_t)type[0]);
        if (backtrace_string)
        {
          if (v128)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_start";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v123, v127, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_227;
        }
        if (v128)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_start";
          _os_log_impl(&dword_182FBE000, v123, v127, "%{public}s called with null browser, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v123 = objc_claimAutoreleasedReturnValue();
        v129 = type[0];
        if (os_log_type_enabled(v123, (os_log_type_t)type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_start";
          _os_log_impl(&dword_182FBE000, v123, v129, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_227:
    if (v122)
      free(v122);
    goto LABEL_186;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&v2[1]);
  isa = (int)v3[9].isa;
  if (!isa)
  {
    if (!v3[2].isa)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
      if (!nw_parameters_get_logging_disabled((uint64_t)v3[5].isa))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v6 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          v27 = (int)v3[24].isa;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_browser_start";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v27;
          _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s [B%u] The browser's client_queue is not set. You must set this browser's client_queue using nw_browser_set_queue() in order to successfully start it.", buf, 0x12u);
        }
        goto LABEL_41;
      }
      goto LABEL_186;
    }
    if (!v3[7].isa && !v3[8].isa && !nw_parameters_get_logging_disabled((uint64_t)v3[5].isa))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v8 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v9 = (int)v3[24].isa;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_start";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v9;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_ERROR, "%{public}s [B%u] The browser does not have any callback handlers set. You must set callback handlers if you wish to receive updates from the browser.", buf, 0x12u);
      }

    }
    objc_storeStrong((id *)&v3[6].isa, browser);
    v10 = (objc_class *)xpc_dictionary_create(0, 0, 0);
    v11 = v3[19].isa;
    v3[19].isa = v10;

    v12 = (objc_class *)xpc_dictionary_create(0, 0, 0);
    v13 = v3[20].isa;
    v3[20].isa = v12;

    v14 = nw_array_create();
    v15 = v3[17].isa;
    v3[17].isa = (Class)v14;

    v16 = nw_array_create();
    v17 = v3[18].isa;
    v3[18].isa = (Class)v16;

    v18 = (objc_class *)nw_dictionary_create();
    v19 = v3[21].isa;
    v3[21].isa = v18;

    switch(LODWORD(v3[3].isa))
    {
      case 0:
        if (nw_parameters_get_logging_disabled((uint64_t)v3[5].isa))
          goto LABEL_152;
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v20 = (id)gbrowserLogObj;
        v21 = (int)v3[24].isa;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_start";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v21;
        v22 = (char *)_os_log_send_and_compose_impl();

        type[0] = 16;
        v145[0] = 0;
        if (!__nwlog_fault(v22, type, v145))
          goto LABEL_109;
        if (type[0] == 17)
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v23 = (id)gbrowserLogObj;
          v24 = type[0];
          if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
          {
            v25 = (int)v3[24].isa;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_start";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v25;
            _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s [B%u] nw_browser_start called on an invalid browser", buf, 0x12u);
          }
LABEL_108:

          goto LABEL_109;
        }
        if (!v145[0])
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v23 = (id)gbrowserLogObj;
          v66 = type[0];
          if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
          {
            v67 = (int)v3[24].isa;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_start";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v67;
            _os_log_impl(&dword_182FBE000, v23, v66, "%{public}s [B%u] nw_browser_start called on an invalid browser, backtrace limit exceeded", buf, 0x12u);
          }
          goto LABEL_108;
        }
        v48 = __nw_create_backtrace_string();
        if (!v48)
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v23 = (id)gbrowserLogObj;
          v68 = type[0];
          if (os_log_type_enabled(v23, (os_log_type_t)type[0]))
          {
            v69 = (int)v3[24].isa;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_start";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v69;
            _os_log_impl(&dword_182FBE000, v23, v68, "%{public}s [B%u] nw_browser_start called on an invalid browser, no backtrace", buf, 0x12u);
          }
          goto LABEL_108;
        }
        v49 = (char *)v48;
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v50 = (id)gbrowserLogObj;
        v51 = type[0];
        if (os_log_type_enabled(v50, (os_log_type_t)type[0]))
        {
          v52 = (int)v3[24].isa;
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_browser_start";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v52;
          *(_WORD *)&buf[18] = 2082;
          *(_QWORD *)&buf[20] = v49;
          _os_log_impl(&dword_182FBE000, v50, v51, "%{public}s [B%u] nw_browser_start called on an invalid browser, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(v49);
LABEL_109:
        if (!v22)
          goto LABEL_152;
        free(v22);
        v70 = 2;
        goto LABEL_185;
      case 1:
        v28 = v3;
        v29 = nw_browse_descriptor_copy_custom_browse_block(v28[4].isa);
        if (v29)
        {
          v30 = v29;
          if (!nw_parameters_get_logging_disabled((uint64_t)v28[5].isa))
          {
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v31 = (id)gbrowserLogObj;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              v32 = (int)v28[24].isa;
              *(_DWORD *)type = 136446466;
              *(_QWORD *)&type[4] = "nw_browser_start_custom_browser_locked";
              *(_WORD *)&type[12] = 1024;
              *(_DWORD *)&type[14] = v32;
              _os_log_impl(&dword_182FBE000, v31, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] start: custom browser", type, 0x12u);
            }

          }
          v33 = nw_parameters_copy_context(v28[5].isa);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke;
          *(_QWORD *)&buf[24] = &unk_1E14ACE18;
          v34 = v30;
          v141 = v34;
          v35 = v28;
          *(_QWORD *)&buf[32] = v35;
          nw_queue_context_async(v33, buf);

          goto LABEL_184;
        }
        __nwlog_obj();
        v130 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)type = 136446210;
        *(_QWORD *)&type[4] = "nw_browser_start_custom_browser_locked";
        v131 = (char *)_os_log_send_and_compose_impl();

        v145[0] = 16;
        v139 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v131, v145, &v139))
          goto LABEL_245;
        if (v145[0] == 17)
        {
          __nwlog_obj();
          v132 = objc_claimAutoreleasedReturnValue();
          v133 = v145[0];
          if (os_log_type_enabled(v132, (os_log_type_t)v145[0]))
          {
            *(_DWORD *)type = 136446210;
            *(_QWORD *)&type[4] = "nw_browser_start_custom_browser_locked";
            _os_log_impl(&dword_182FBE000, v132, v133, "%{public}s called with null browser_block", type, 0xCu);
          }
        }
        else if (v139)
        {
          v134 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v132 = objc_claimAutoreleasedReturnValue();
          v135 = v145[0];
          v136 = os_log_type_enabled(v132, (os_log_type_t)v145[0]);
          if (v134)
          {
            if (v136)
            {
              *(_DWORD *)type = 136446466;
              *(_QWORD *)&type[4] = "nw_browser_start_custom_browser_locked";
              *(_WORD *)&type[12] = 2082;
              *(_QWORD *)&type[14] = v134;
              _os_log_impl(&dword_182FBE000, v132, v135, "%{public}s called with null browser_block, dumping backtrace:%{public}s", type, 0x16u);
            }

            free(v134);
            goto LABEL_245;
          }
          if (v136)
          {
            *(_DWORD *)type = 136446210;
            *(_QWORD *)&type[4] = "nw_browser_start_custom_browser_locked";
            _os_log_impl(&dword_182FBE000, v132, v135, "%{public}s called with null browser_block, no backtrace", type, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v132 = objc_claimAutoreleasedReturnValue();
          v137 = v145[0];
          if (os_log_type_enabled(v132, (os_log_type_t)v145[0]))
          {
            *(_DWORD *)type = 136446210;
            *(_QWORD *)&type[4] = "nw_browser_start_custom_browser_locked";
            _os_log_impl(&dword_182FBE000, v132, v137, "%{public}s called with null browser_block, backtrace limit exceeded", type, 0xCu);
          }
        }

LABEL_245:
        if (v131)
          free(v131);

        goto LABEL_152;
      case 2:
        goto LABEL_175;
      case 3:
        v36 = v3;
        if (!nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v37 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            v38 = *((_DWORD *)v36 + 48);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v38;
            _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] start: dns browser", buf, 0x12u);
          }

        }
        if (nw_browse_descriptor_get_type(*((void **)v36 + 4)) == 1)
        {
          if (nw_browse_descriptor_is_meta_query(*((void **)v36 + 4)))
          {
            v39 = "Invalid meta query type specified. nw_browser_start_dns_browser_locked";
LABEL_150:
            nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v36, -65540, v39);
LABEL_151:

LABEL_152:
            v70 = 2;
            goto LABEL_185;
          }
          v53 = getpid();
          if (!nw_parameters_has_delegated_proc_pid(*((void **)v36 + 5), v53)
            && !nw_parameters_has_delegated_proc_uuid(*((void **)v36 + 5)))
          {
            Connection = DNSServiceCreateConnection((DNSServiceRef *)v36 + 15);
            goto LABEL_139;
          }
          if (nw_parameters_has_delegated_proc_pid(*((void **)v36 + 5), v53))
          {
            pid = nw_parameters_get_pid(*((void **)v36 + 5));
            if (!nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v55 = (id)gbrowserLogObj;
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
              {
                v56 = *((_DWORD *)v36 + 48);
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v56;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = pid;
                _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] Delegating DNS service to PID %d", buf, 0x18u);
              }

            }
            Connection = DNSServiceCreateDelegateConnection();
            if (!Connection)
            {
LABEL_139:
              if (nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v36, Connection, "DNSServiceCreateConnection"))
              {
                goto LABEL_151;
              }
              v81 = (_DNSServiceRef_t *)*((_QWORD *)v36 + 15);
              v82 = nw_parameters_copy_context(*((void **)v36 + 5));
              v83 = nw_context_copy_workloop(v82);
              LODWORD(v81) = DNSServiceSetDispatchQueue(v81, (dispatch_queue_t)v83);

              if (nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v36, (int)v81, "DNSServiceSetDispatchQueue"))
              {
                goto LABEL_151;
              }
              *((_QWORD *)v36 + 16) = *((_QWORD *)v36 + 15);
              v84 = nw_parameters_copy_required_interface(*((nw_parameters_t *)v36 + 5));
              v85 = (char *)v84;
              if (v84)
                isa_low = LODWORD(v84[1].isa);
              else
                isa_low = 0;
              v90 = nw_browser_derive_endpoint_flags((NWConcrete_nw_browser *)v36);
              bonjour_service_type = nw_browse_descriptor_get_bonjour_service_type(*((nw_browse_descriptor_t *)v36 + 4));
              bonjour_service_domain = nw_browse_descriptor_get_bonjour_service_domain(*((nw_browse_descriptor_t *)v36
                                                                                       + 4));
              if (v36[197])
                v93 = MEMORY[0x1E0C839F0];
              else
                v93 = 0;
              v94 = MEMORY[0x186DB2E7C](v36 + 128, v90, isa_low, bonjour_service_type, bonjour_service_domain, v93, nw_browser_dns_service_browse_callback, v36);
              if (nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v36, v94, "DNSServiceBrowse"))
              {

                goto LABEL_152;
              }
              if ((_DWORD)isa_low && !nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
              {
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v95 = (id)gbrowserLogObj;
                if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
                {
                  v96 = "any";
                  v97 = *((_DWORD *)v36 + 48);
                  *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
                  *(_DWORD *)buf = 136446978;
                  if (v85)
                    v96 = v85 + 104;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v97;
                  *(_WORD *)&buf[18] = 2082;
                  *(_QWORD *)&buf[20] = v96;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = isa_low;
                  _os_log_impl(&dword_182FBE000, v95, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] Scoping browse to %{public}s [%d]", buf, 0x22u);
                }

              }
              if (!nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
              {
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v98 = (id)gbrowserLogObj;
                if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
                {
                  v99 = *((_DWORD *)v36 + 48);
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v99;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v90;
                  _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns: start browse with flags %#x", buf, 0x18u);
                }

              }
LABEL_175:
              v100 = v3;
              if (!nw_parameters_get_logging_disabled(*((_QWORD *)v100 + 5)))
              {
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v101 = (id)gbrowserLogObj;
                if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                {
                  v102 = *((_DWORD *)v100 + 48);
                  *(_DWORD *)v145 = 136446466;
                  v146 = "nw_browser_start_path_browser_locked";
                  v147 = 1024;
                  LODWORD(v148) = v102;
                  _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] path: start browser", v145, 0x12u);
                }

              }
              v103 = (void **)(v100 + 88);
              if (*((_QWORD *)v100 + 11) || *((_QWORD *)v100 + 12))
              {

LABEL_184:
                v70 = 1;
LABEL_185:
                nw_browser_set_state_locked(v3, v70, 0);
                os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);
                goto LABEL_186;
              }
              evaluator_for_browse = nw_path_create_evaluator_for_browse(*((void **)v100 + 4), *((void **)v100 + 5));
              if (evaluator_for_browse)
              {
                v105 = MEMORY[0x1E0C809B0];
                *(_QWORD *)buf = MEMORY[0x1E0C809B0];
                *(_QWORD *)&buf[8] = 3221225472;
                *(_QWORD *)&buf[16] = ___ZL36nw_browser_start_path_browser_lockedP21NWConcrete_nw_browser_block_invoke;
                *(_QWORD *)&buf[24] = &unk_1E14AC2C8;
                v106 = v100;
                *(_QWORD *)&buf[32] = v106;
                nw_path_evaluator_set_update_handler(evaluator_for_browse, 0, buf);
                objc_storeStrong((id *)v100 + 11, evaluator_for_browse);
                v107 = (os_unfair_lock_s *)*v103;
                if (*v103)
                {
                  v108 = v107 + 24;
                  v109 = v107;
                  os_unfair_lock_lock(v108);
                  v110 = v109[6];
                  os_unfair_lock_unlock(v108);

                }
                else
                {
                  v110 = 0;
                }
                v115 = (void *)*((_QWORD *)v100 + 12);
                *((_QWORD *)v100 + 12) = v110;

                v116 = nw_parameters_copy_context(*((void **)v100 + 5));
                *(_QWORD *)type = v105;
                *(_QWORD *)&type[8] = 3221225472;
                *(_QWORD *)&type[16] = ___ZL36nw_browser_start_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2;
                v143 = &unk_1E14ACFD0;
                v117 = v106;
                v144 = v117;
                nw_queue_context_async(v116, type);

                goto LABEL_184;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v111 = (id)gLogObj;
              *(_DWORD *)v145 = 136446210;
              v146 = "nw_browser_start_path_browser_locked";
              v112 = (char *)_os_log_send_and_compose_impl();

              v139 = OS_LOG_TYPE_ERROR;
              v138 = 0;
              if ((__nwlog_fault(v112, &v139, &v138) & 1) != 0)
              {
                if (v139 == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v113 = (id)gLogObj;
                  v114 = v139;
                  if (os_log_type_enabled(v113, v139))
                  {
                    *(_DWORD *)v145 = 136446210;
                    v146 = "nw_browser_start_path_browser_locked";
                    _os_log_impl(&dword_182FBE000, v113, v114, "%{public}s nw_path_create_evaluator_for_browse failed", v145, 0xCu);
                  }
                }
                else if (v138)
                {
                  v118 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  v113 = objc_claimAutoreleasedReturnValue();
                  v119 = v139;
                  v120 = os_log_type_enabled(v113, v139);
                  if (v118)
                  {
                    if (v120)
                    {
                      *(_DWORD *)v145 = 136446466;
                      v146 = "nw_browser_start_path_browser_locked";
                      v147 = 2082;
                      v148 = v118;
                      _os_log_impl(&dword_182FBE000, v113, v119, "%{public}s nw_path_create_evaluator_for_browse failed, dumping backtrace:%{public}s", v145, 0x16u);
                    }

                    free(v118);
                    goto LABEL_213;
                  }
                  if (v120)
                  {
                    *(_DWORD *)v145 = 136446210;
                    v146 = "nw_browser_start_path_browser_locked";
                    _os_log_impl(&dword_182FBE000, v113, v119, "%{public}s nw_path_create_evaluator_for_browse failed, no backtrace", v145, 0xCu);
                  }
                }
                else
                {
                  __nwlog_obj();
                  v113 = objc_claimAutoreleasedReturnValue();
                  v125 = v139;
                  if (os_log_type_enabled(v113, v139))
                  {
                    *(_DWORD *)v145 = 136446210;
                    v146 = "nw_browser_start_path_browser_locked";
                    _os_log_impl(&dword_182FBE000, v113, v125, "%{public}s nw_path_create_evaluator_for_browse failed, backtrace limit exceeded", v145, 0xCu);
                  }
                }

              }
LABEL_213:
              if (v112)
                free(v112);

              goto LABEL_152;
            }
            if (!nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v58 = (id)gbrowserLogObj;
              if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
              {
                v59 = *((_DWORD *)v36 + 48);
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v59;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = pid;
                *(_WORD *)&buf[24] = 1024;
                *(_DWORD *)&buf[26] = Connection;
                _os_log_impl(&dword_182FBE000, v58, OS_LOG_TYPE_ERROR, "%{public}s [B%u] DNSServiceCreateDelegateConnection(..., epid=%u, NULL) failed: %d", buf, 0x1Eu);
              }

            }
          }
          else
          {
            Connection = 0;
            pid = 0;
          }
          if (nw_parameters_has_delegated_proc_uuid(*((void **)v36 + 5)))
          {
            if (Connection && !nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v71 = (id)gbrowserLogObj;
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
              {
                v72 = *((_DWORD *)v36 + 48);
                string_for_dns_service_error = nwlog_get_string_for_dns_service_error(Connection);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v72;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = pid;
                *(_WORD *)&buf[24] = 2082;
                *(_QWORD *)&buf[26] = string_for_dns_service_error;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = Connection;
                _os_log_impl(&dword_182FBE000, v71, OS_LOG_TYPE_ERROR, "%{public}s [B%u] Delegating DNS service to PID %d returned failure %{public}s(%d), falling back to eUUID", buf, 0x28u);
              }

            }
            *(_QWORD *)type = 0;
            *(_QWORD *)&type[8] = 0;
            nw_parameters_get_e_proc_uuid(*((void **)v36 + 5), type);
            if (!nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v74 = (id)gbrowserLogObj;
              if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
              {
                v75 = *((_DWORD *)v36 + 48);
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v75;
                _os_log_impl(&dword_182FBE000, v74, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] Delegating DNS service to eUUID", buf, 0x12u);
              }

            }
            Connection = DNSServiceCreateDelegateConnection();
            if (Connection && !nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v76 = (id)gbrowserLogObj;
              if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
              {
                v77 = *((_DWORD *)v36 + 48);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v77;
                *(_WORD *)&buf[18] = 1040;
                *(_DWORD *)&buf[20] = 16;
                *(_WORD *)&buf[24] = 2096;
                *(_QWORD *)&buf[26] = type;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = Connection;
                _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_ERROR, "%{public}s [B%u] DNSServiceCreateDelegateConnection(..., 0, %{uuid_t}.16P) failed: %d", buf, 0x28u);
              }

            }
          }
          goto LABEL_139;
        }
        v39 = "nw_browser_start_dns_browser_locked";
        if (nw_parameters_get_logging_disabled(*((_QWORD *)v36 + 5)))
          goto LABEL_150;
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v40 = (id)gbrowserLogObj;
        v41 = *((_DWORD *)v36 + 48);
        v42 = nw_browse_descriptor_get_type(*((void **)v36 + 4));
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v41;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v42;
        v43 = (char *)_os_log_send_and_compose_impl();

        type[0] = 16;
        v145[0] = 0;
        if (!__nwlog_fault(v43, type, v145))
          goto LABEL_148;
        if (type[0] == 17)
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v44 = (id)gbrowserLogObj;
          v45 = type[0];
          if (os_log_type_enabled(v44, (os_log_type_t)type[0]))
          {
            v46 = *((_DWORD *)v36 + 48);
            v47 = nw_browse_descriptor_get_type(*((void **)v36 + 4));
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v46;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v47;
            _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s [B%u] unknown browser.cppode of operation for type %d", buf, 0x18u);
          }
        }
        else if (v145[0])
        {
          v60 = __nw_create_backtrace_string();
          if (v60)
          {
            v61 = (char *)v60;
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v62 = (id)gbrowserLogObj;
            v63 = type[0];
            if (os_log_type_enabled(v62, (os_log_type_t)type[0]))
            {
              v64 = *((_DWORD *)v36 + 48);
              v65 = nw_browse_descriptor_get_type(*((void **)v36 + 4));
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v64;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v65;
              *(_WORD *)&buf[24] = 2082;
              *(_QWORD *)&buf[26] = v61;
              _os_log_impl(&dword_182FBE000, v62, v63, "%{public}s [B%u] unknown browser.cppode of operation for type %d, dumping backtrace:%{public}s", buf, 0x22u);
            }

            free(v61);
            goto LABEL_148;
          }
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v44 = (id)gbrowserLogObj;
          v87 = type[0];
          if (os_log_type_enabled(v44, (os_log_type_t)type[0]))
          {
            v88 = *((_DWORD *)v36 + 48);
            v89 = nw_browse_descriptor_get_type(*((void **)v36 + 4));
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v88;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v89;
            _os_log_impl(&dword_182FBE000, v44, v87, "%{public}s [B%u] unknown browser.cppode of operation for type %d, no backtrace", buf, 0x18u);
          }
        }
        else
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v44 = (id)gbrowserLogObj;
          v78 = type[0];
          if (os_log_type_enabled(v44, (os_log_type_t)type[0]))
          {
            v79 = *((_DWORD *)v36 + 48);
            v80 = nw_browse_descriptor_get_type(*((void **)v36 + 4));
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_browser_start_dns_browser_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v79;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v80;
            _os_log_impl(&dword_182FBE000, v44, v78, "%{public}s [B%u] unknown browser.cppode of operation for type %d, backtrace limit exceeded", buf, 0x18u);
          }
        }

LABEL_148:
        if (v43)
          free(v43);
        goto LABEL_150;
      default:
        goto LABEL_152;
    }
  }
  v5 = (os_unfair_lock_s *)&v3[1];
  if (isa == 3)
  {
    os_unfair_lock_unlock(v5);
    if (!nw_parameters_get_logging_disabled((uint64_t)v3[5].isa))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v6 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v7 = (int)v3[24].isa;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_start";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v7;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s [B%u] The browser has already been cancelled and cannot be started again. You must create a new browser object and start it.", buf, 0x12u);
      }
LABEL_41:

    }
  }
  else
  {
    os_unfair_lock_unlock(v5);
    if (!nw_parameters_get_logging_disabled((uint64_t)v3[5].isa))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v6 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v26 = (int)v3[24].isa;
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_start";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v26;
        _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_ERROR, "%{public}s [B%u] The browser has already been started, ignoring nw_browser_start().", buf, 0x12u);
      }
      goto LABEL_41;
    }
  }
LABEL_186:

}

void sub_1838F74C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[4];
  _QWORD *v5;

  v1 = *(_QWORD **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v3 = v1[4];
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke_2;
  v4[3] = &unk_1E14A5170;
  v5 = v1;
  (*(void (**)(uint64_t, uint64_t, _QWORD *))(v2 + 16))(v2, v3, v4);

}

void sub_1838F7600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

BOOL nw_browser_fail_on_dns_error_locked(NWConcrete_nw_browser *a1, int a2, const char *a3)
{
  NWConcrete_nw_browser *v5;
  NWConcrete_nw_browser *v6;
  NSObject *v7;
  int v8;
  _DWORD *dns_error;
  signed int v10;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *string_for_dns_service_error;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (a2)
  {
    if (!nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v7 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v8 = *((_DWORD *)v6 + 48);
        v12 = 136447234;
        v13 = "nw_browser_fail_on_dns_error_locked";
        v14 = 1024;
        v15 = v8;
        v16 = 2082;
        v17 = a3;
        v18 = 2082;
        string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a2);
        v20 = 1024;
        v21 = a2;
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s [B%u] %{public}s failed: %{public}s(%d)", (uint8_t *)&v12, 0x2Cu);
      }

    }
    dns_error = nw_error_create_dns_error(a2);
    if (a2 == -65570)
    {
      v10 = 4;
    }
    else
    {
      nw_browser_cancel_dns_browser_locked(v6);
      v10 = 2;
    }
    nw_browser_set_state_locked(v6, v10, dns_error);

  }
  return a2 != 0;
}

void sub_1838F7798(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_browser_derive_endpoint_flags(NWConcrete_nw_browser *a1)
{
  NWConcrete_nw_browser *v1;
  int traffic_class;
  _BOOL4 prohibit_cellular;
  _BOOL4 prohibit_expensive;
  _BOOL4 prohibit_constrained;
  int use_awdl;
  int use_p2p;
  unsigned int v8;
  uint64_t v9;

  v1 = a1;
  traffic_class = nw_parameters_get_traffic_class(*((void **)v1 + 5));
  prohibit_cellular = nw_parameters_get_prohibit_cellular(*((void **)v1 + 5));
  prohibit_expensive = nw_parameters_get_prohibit_expensive(*((nw_parameters_t *)v1 + 5));
  prohibit_constrained = nw_parameters_get_prohibit_constrained(*((nw_parameters_t *)v1 + 5));
  use_awdl = nw_parameters_get_use_awdl(*((void **)v1 + 5));
  use_p2p = nw_parameters_get_use_p2p(*((void **)v1 + 5));
  if (traffic_class == 100)
    v8 = 1074282496;
  else
    v8 = 1073758208;
  if (prohibit_cellular)
    v8 |= 0x8000000u;
  if (prohibit_expensive)
    v8 |= 0x20000000u;
  if (prohibit_constrained)
    v8 |= 0x2000u;
  if (use_awdl)
    v8 |= 0x100000u;
  if (use_p2p)
    v9 = v8 | 0x20000;
  else
    v9 = v8;

  return v9;
}

void sub_1838F7884(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_browser_dns_service_browse_callback(_DNSServiceRef_t *a1, int a2, unsigned int a3, int a4, const char *a5, const char *a6, const char *a7, void *a8)
{
  os_unfair_lock_s *v13;
  os_unfair_lock_s *v14;
  uint32_t os_unfair_lock_opaque;
  size_t v17;
  const char *v18;
  size_t v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  NSObject *v23;
  uint32_t v24;
  NSObject *v25;
  uint32_t v26;
  uint32_t v27;
  id v28;
  NWConcrete_nw_interface *v29;
  NSObject *v30;
  uint32_t v31;
  DNSServiceErrorType v32;
  _DWORD *dns_error;
  id v34;
  uint32_t v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint32_t v39;
  size_t i;
  nw_endpoint_t bonjour_service;
  const void *ValidationData;
  const char *v43;
  char *v44;
  NSObject *v45;
  os_log_type_t v46;
  uint32_t v47;
  os_log_type_t v48;
  uint32_t v49;
  os_log_type_t v50;
  uint32_t v51;
  void *v52;
  char *v53;
  NSObject *v54;
  os_log_type_t v55;
  char *v56;
  os_log_type_t v57;
  _BOOL4 v58;
  os_log_type_t v59;
  id v60;
  uint32_t v61;
  char *v62;
  NSObject *v63;
  os_log_type_t v64;
  uint32_t v65;
  const char *backtrace_string;
  char *v67;
  NSObject *v68;
  os_log_type_t v69;
  uint32_t v70;
  os_log_type_t v71;
  uint32_t v72;
  os_log_type_t v73;
  uint32_t v74;
  _DWORD *v75;
  os_unfair_lock_s *lock;
  char v78;
  _BYTE v79[12];
  __int16 v80;
  uint32_t v81;
  __int16 v82;
  const char *v83;
  __int16 v84;
  const char *v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  _DWORD *v89;
  __int16 v90;
  char *v91;
  uint8_t buf[4];
  const char *v93;
  __int16 v94;
  _BYTE v95[24];
  __int16 v96;
  const char *v97;
  __int16 v98;
  int v99;
  __int16 v100;
  unsigned int v101;
  __int16 v102;
  int v103;
  uint64_t v104;
  char v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  v13 = a8;
  v14 = v13;
  if (v13)
  {
    lock = v13 + 2;
    os_unfair_lock_lock(v13 + 2);
    os_unfair_lock_opaque = v14[18]._os_unfair_lock_opaque;
    if (os_unfair_lock_opaque != 1 && os_unfair_lock_opaque != 4)
    {
      if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v14[10]._os_unfair_lock_opaque))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v21 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          v22 = v14[48]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446466;
          v93 = "nw_browser_dns_service_browse_callback";
          v94 = 1024;
          *(_DWORD *)v95 = v22;
          _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s [B%u] not in ready or waiting state", buf, 0x12u);
        }

      }
      goto LABEL_48;
    }
    if (!BYTE2(v14[49]._os_unfair_lock_opaque))
    {
      if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v14[10]._os_unfair_lock_opaque))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v23 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          v24 = v14[48]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136448002;
          v93 = "nw_browser_dns_service_browse_callback";
          v94 = 1024;
          *(_DWORD *)v95 = v24;
          *(_WORD *)&v95[4] = 2082;
          *(_QWORD *)&v95[6] = a5;
          *(_WORD *)&v95[14] = 2082;
          *(_QWORD *)&v95[16] = a6;
          v96 = 2082;
          v97 = a7;
          v98 = 1024;
          v99 = a2;
          v100 = 1024;
          v101 = a3;
          v102 = 1024;
          v103 = a4;
          _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns: (%{public}s %{public}s %{public}s), flags: %d, if_index: %d, error: %d", buf, 0x42u);
        }

      }
LABEL_31:
      if (nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v14, a4, "nw_browser_dns_service_browse_callback"))
      {
        goto LABEL_48;
      }
      v27 = v14[18]._os_unfair_lock_opaque;
      if (v27 == 4)
      {
        nw_browser_set_state_locked(v14, 1, 0);
        v27 = v14[18]._os_unfair_lock_opaque;
      }
      if (v27 != 1)
        goto LABEL_48;
      if (!a5 || !*a5)
      {
        if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v14[10]._os_unfair_lock_opaque))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v30 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
          {
            v31 = v14[48]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446466;
            v93 = "nw_browser_dns_service_browse_callback";
            v94 = 1024;
            *(_DWORD *)v95 = v31;
            _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_INFO, "%{public}s [B%u] Received empty result, ignoring", buf, 0x12u);
          }

        }
        goto LABEL_48;
      }
      if (a3 - 1 > 0xFFFFFFFD)
      {
        if (a3 == -1)
        {
          v29 = nw_interface_create_with_name("lo0");
          if (!v29)
            goto LABEL_121;
        }
        else
        {
          v29 = 0;
        }
      }
      else
      {
        if (nw_context_copy_implicit_context::onceToken[0] != -1)
          dispatch_once(nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
        v28 = (id)nw_context_copy_implicit_context::implicit_context;
        v29 = nw_path_copy_interface_with_generation(v28, a3, 0);

        if (!v29)
        {
LABEL_121:
          if (nw_parameters_get_logging_disabled(*(_QWORD *)&v14[10]._os_unfair_lock_opaque))
          {
LABEL_48:
            os_unfair_lock_unlock(lock);
            goto LABEL_49;
          }
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v60 = (id)gbrowserLogObj;
          v61 = v14[48]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          v93 = "nw_browser_dns_service_browse_callback";
          v94 = 1024;
          *(_DWORD *)v95 = v61;
          *(_WORD *)&v95[4] = 1024;
          *(_DWORD *)&v95[6] = a3;
          v62 = (char *)_os_log_send_and_compose_impl();

          v79[0] = 16;
          LOBYTE(v104) = 0;
          if (__nwlog_fault(v62, v79, &v104))
          {
            if (v79[0] == 17)
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v63 = (id)gbrowserLogObj;
              v64 = v79[0];
              if (os_log_type_enabled(v63, (os_log_type_t)v79[0]))
              {
                v65 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136446722;
                v93 = "nw_browser_dns_service_browse_callback";
                v94 = 1024;
                *(_DWORD *)v95 = v65;
                *(_WORD *)&v95[4] = 1024;
                *(_DWORD *)&v95[6] = a3;
                _os_log_impl(&dword_182FBE000, v63, v64, "%{public}s [B%u] dns: no interface found for if_index %u", buf, 0x18u);
              }
            }
            else if ((_BYTE)v104)
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                v67 = (char *)backtrace_string;
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v68 = (id)gbrowserLogObj;
                v69 = v79[0];
                if (os_log_type_enabled(v68, (os_log_type_t)v79[0]))
                {
                  v70 = v14[48]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446978;
                  v93 = "nw_browser_dns_service_browse_callback";
                  v94 = 1024;
                  *(_DWORD *)v95 = v70;
                  *(_WORD *)&v95[4] = 1024;
                  *(_DWORD *)&v95[6] = a3;
                  *(_WORD *)&v95[10] = 2082;
                  *(_QWORD *)&v95[12] = v67;
                  _os_log_impl(&dword_182FBE000, v68, v69, "%{public}s [B%u] dns: no interface found for if_index %u, dumping backtrace:%{public}s", buf, 0x22u);
                }

                free(v67);
                goto LABEL_148;
              }
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v63 = (id)gbrowserLogObj;
              v73 = v79[0];
              if (os_log_type_enabled(v63, (os_log_type_t)v79[0]))
              {
                v74 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136446722;
                v93 = "nw_browser_dns_service_browse_callback";
                v94 = 1024;
                *(_DWORD *)v95 = v74;
                *(_WORD *)&v95[4] = 1024;
                *(_DWORD *)&v95[6] = a3;
                _os_log_impl(&dword_182FBE000, v63, v73, "%{public}s [B%u] dns: no interface found for if_index %u, no backtrace", buf, 0x18u);
              }
            }
            else
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v63 = (id)gbrowserLogObj;
              v71 = v79[0];
              if (os_log_type_enabled(v63, (os_log_type_t)v79[0]))
              {
                v72 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)buf = 136446722;
                v93 = "nw_browser_dns_service_browse_callback";
                v94 = 1024;
                *(_DWORD *)v95 = v72;
                *(_WORD *)&v95[4] = 1024;
                *(_DWORD *)&v95[6] = a3;
                _os_log_impl(&dword_182FBE000, v63, v71, "%{public}s [B%u] dns: no interface found for if_index %u, backtrace limit exceeded", buf, 0x18u);
              }
            }

          }
LABEL_148:
          if (v62)
            free(v62);
          goto LABEL_48;
        }
      }
      bzero(buf, 0x3F1uLL);
      v32 = DNSServiceConstructFullName((char *const)buf, a5, a6, a7);
      if (v32)
      {
        dns_error = nw_error_create_dns_error(v32);
        if (nw_parameters_get_logging_disabled(*(_QWORD *)&v14[10]._os_unfair_lock_opaque))
        {
LABEL_101:
          os_unfair_lock_unlock(lock);

          goto LABEL_102;
        }
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v34 = (id)gbrowserLogObj;
        v35 = v14[48]._os_unfair_lock_opaque;
        *(_DWORD *)v79 = 136447491;
        *(_QWORD *)&v79[4] = "nw_browser_dns_service_browse_callback";
        v80 = 1024;
        v81 = v35;
        v82 = 2085;
        v83 = a5;
        v84 = 2082;
        v85 = a6;
        v86 = 2085;
        v87 = a7;
        v88 = 2114;
        v75 = dns_error;
        v89 = dns_error;
        v36 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(v104) = 16;
        v78 = 0;
        if (__nwlog_fault(v36, &v104, &v78))
        {
          if (v104 == 17)
          {
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v37 = (id)gbrowserLogObj;
            v38 = v104;
            if (os_log_type_enabled(v37, (os_log_type_t)v104))
            {
              v39 = v14[48]._os_unfair_lock_opaque;
              *(_DWORD *)v79 = 136447491;
              *(_QWORD *)&v79[4] = "nw_browser_dns_service_browse_callback";
              v80 = 1024;
              v81 = v39;
              v82 = 2085;
              v83 = a5;
              v84 = 2082;
              v85 = a6;
              v86 = 2085;
              v87 = a7;
              v88 = 2114;
              v89 = dns_error;
              _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@", v79, 0x3Au);
            }
          }
          else if (v78)
          {
            v43 = __nw_create_backtrace_string();
            if (v43)
            {
              v44 = (char *)v43;
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v45 = (id)gbrowserLogObj;
              v46 = v104;
              if (os_log_type_enabled(v45, (os_log_type_t)v104))
              {
                v47 = v14[48]._os_unfair_lock_opaque;
                *(_DWORD *)v79 = 136447747;
                *(_QWORD *)&v79[4] = "nw_browser_dns_service_browse_callback";
                v80 = 1024;
                v81 = v47;
                v82 = 2085;
                v83 = a5;
                v84 = 2082;
                v85 = a6;
                v86 = 2085;
                v87 = a7;
                v88 = 2114;
                v89 = v75;
                v90 = 2082;
                v91 = v44;
                _os_log_impl(&dword_182FBE000, v45, v46, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@, dumping backtrace:%{public}s", v79, 0x44u);
              }

              free(v44);
              goto LABEL_98;
            }
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v37 = (id)gbrowserLogObj;
            v50 = v104;
            if (os_log_type_enabled(v37, (os_log_type_t)v104))
            {
              v51 = v14[48]._os_unfair_lock_opaque;
              *(_DWORD *)v79 = 136447491;
              *(_QWORD *)&v79[4] = "nw_browser_dns_service_browse_callback";
              v80 = 1024;
              v81 = v51;
              v82 = 2085;
              v83 = a5;
              v84 = 2082;
              v85 = a6;
              v86 = 2085;
              v87 = a7;
              v88 = 2114;
              v89 = dns_error;
              _os_log_impl(&dword_182FBE000, v37, v50, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@, no backtrace", v79, 0x3Au);
            }
          }
          else
          {
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v37 = (id)gbrowserLogObj;
            v48 = v104;
            if (os_log_type_enabled(v37, (os_log_type_t)v104))
            {
              v49 = v14[48]._os_unfair_lock_opaque;
              *(_DWORD *)v79 = 136447491;
              *(_QWORD *)&v79[4] = "nw_browser_dns_service_browse_callback";
              v80 = 1024;
              v81 = v49;
              v82 = 2085;
              v83 = a5;
              v84 = 2082;
              v85 = a6;
              v86 = 2085;
              v87 = a7;
              v88 = 2114;
              v89 = dns_error;
              _os_log_impl(&dword_182FBE000, v37, v48, "%{public}s [B%u] DNSServiceConstructFullName(..., %{sensitive}s, %{public}s, %{sensitive}s) failed: %{public}@, backtrace limit exceeded", v79, 0x3Au);
            }
          }

        }
LABEL_98:
        if (v36)
          free(v36);
        dns_error = v75;
        goto LABEL_101;
      }
      for (i = 0; i < strlen((const char *)buf); ++i)
        buf[i] = __tolower((char)buf[i]);
      if ((a2 & 2) != 0 && a7)
      {
        bonjour_service = nw_endpoint_create_bonjour_service(a5, a6, a7);
        *(_QWORD *)v79 = 0;
        ValidationData = (const void *)DNSServiceGetValidationData();
        if (ValidationData && *(_QWORD *)v79)
          nw_endpoint_set_signature(bonjour_service, ValidationData, *(size_t *)v79);
        if (!nw_browser_add_result_locked(v14, (const char *)buf, bonjour_service, v29, 0))
        {
          os_unfair_lock_unlock(lock);

          goto LABEL_102;
        }
        if (LOBYTE(v14[49]._os_unfair_lock_opaque))
          nw_browser_start_query_record_for_endpoint_locked(v14, bonjour_service, (const char *)buf, v29);

      }
      else if ((nw_browser_remove_result_locked(v14, (const char *)buf, v29) & 1) == 0)
      {
LABEL_86:
        os_unfair_lock_unlock(lock);
LABEL_102:

        goto LABEL_49;
      }
      if ((a2 & 1) == 0)
        nw_browser_notify_browse_result_changes_locked((NWConcrete_nw_browser *)v14);
      goto LABEL_86;
    }
    v79[8] = 0;
    *(_QWORD *)v79 = 0;
    v105 = 0;
    v104 = 0;
    if (a5)
    {
      v17 = strlen(a5);
      v18 = v79;
      __nwlog_salted_hash(a5, v17, v79);
      if (a7)
      {
LABEL_10:
        v19 = strlen(a7);
        v20 = (const char *)&v104;
        __nwlog_salted_hash(a7, v19, (char *)&v104);
        goto LABEL_25;
      }
    }
    else
    {
      v18 = "<NULL>";
      if (a7)
        goto LABEL_10;
    }
    v20 = "<NULL>";
LABEL_25:
    if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v14[10]._os_unfair_lock_opaque))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v25 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v26 = v14[48]._os_unfair_lock_opaque;
        *(_DWORD *)buf = 136448002;
        v93 = "nw_browser_dns_service_browse_callback";
        v94 = 1024;
        *(_DWORD *)v95 = v26;
        *(_WORD *)&v95[4] = 2082;
        *(_QWORD *)&v95[6] = v18;
        *(_WORD *)&v95[14] = 2082;
        *(_QWORD *)&v95[16] = a6;
        v96 = 2082;
        v97 = v20;
        v98 = 1024;
        v99 = a2;
        v100 = 1024;
        v101 = a3;
        v102 = 1024;
        v103 = a4;
        _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns: (#%{public}s %{public}s #%{public}s), flags: %d, if_index: %d, error: %d", buf, 0x42u);
      }

    }
    goto LABEL_31;
  }
  __nwlog_obj();
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v93 = "nw_browser_dns_service_browse_callback";
  v53 = (char *)_os_log_send_and_compose_impl();

  v79[0] = 16;
  LOBYTE(v104) = 0;
  if (__nwlog_fault(v53, v79, &v104))
  {
    if (v79[0] == 17)
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v55 = v79[0];
      if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_182FBE000, v54, v55, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if ((_BYTE)v104)
    {
      v56 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v57 = v79[0];
      v58 = os_log_type_enabled(v54, (os_log_type_t)v79[0]);
      if (v56)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446466;
          v93 = "nw_browser_dns_service_browse_callback";
          v94 = 2082;
          *(_QWORD *)v95 = v56;
          _os_log_impl(&dword_182FBE000, v54, v57, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v56);
        goto LABEL_119;
      }
      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_182FBE000, v54, v57, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v54 = objc_claimAutoreleasedReturnValue();
      v59 = v79[0];
      if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_dns_service_browse_callback";
        _os_log_impl(&dword_182FBE000, v54, v59, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_119:
  if (v53)
    free(v53);
LABEL_49:

}

void sub_1838F8844(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_browser_set_state_locked(void *a1, signed int a2, void *a3)
{
  unsigned int *v5;
  id v6;
  unsigned int v7;
  BOOL v8;
  char v9;
  id v10;
  unsigned int v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  unsigned int v15;
  uint64_t v16;
  const char *v17;
  char *v18;
  const void *v19;
  void *v20;
  NSObject *v21;
  id v22;
  char *v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  unsigned int v27;
  uint64_t v28;
  const char *v29;
  const char *backtrace_string;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  unsigned int v34;
  uint64_t v35;
  const char *v36;
  os_log_type_t v37;
  unsigned int v38;
  uint64_t v39;
  const char *v40;
  os_log_type_t v41;
  unsigned int v42;
  uint64_t v43;
  const char *v44;
  _QWORD block[4];
  id v46;
  unsigned int *v47;
  id v48;
  signed int v49;
  char v50;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  unsigned int v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  char *v59;
  __int16 v60;
  char *v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  v7 = v5[18];
  if (v7 == a2)
    goto LABEL_53;
  if ((a2 - 1) <= 2 && v7 == 4
    || (a2 == 4 ? (v8 = v7 >= 2) : (v8 = 1), v8 ? (v9 = 0) : (v9 = 1), (int)v7 < a2 || (v9 & 1) != 0))
  {
    if (!nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v14 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = v5[48];
        v16 = v5[18];
        if (v16 > 4)
          v17 = "<unknown>";
        else
          v17 = off_1E14A5370[v16];
        v18 = off_1E14A5370[a2];
        *(_DWORD *)buf = 136446978;
        v53 = "nw_browser_set_state_locked";
        v54 = 1024;
        v55 = v15;
        v56 = 2082;
        v57 = v17;
        v58 = 2082;
        v59 = v18;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] state changed: %{public}s -> %{public}s", buf, 0x26u);
      }

    }
    v5[18] = a2;
    objc_storeStrong((id *)v5 + 10, a3);
    v19 = (const void *)*((_QWORD *)v5 + 8);
    if (v19)
    {
      v20 = _Block_copy(v19);
      v21 = *((_QWORD *)v5 + 2);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ___ZL27nw_browser_set_state_lockedP21NWConcrete_nw_browser18nw_browser_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke;
      block[3] = &unk_1E14A5540;
      v48 = v20;
      v49 = a2;
      v46 = v6;
      v47 = v5;
      v22 = v20;
      dispatch_async(v21, block);

    }
    goto LABEL_53;
  }
  if (nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5)))
    goto LABEL_53;
  if (__nwlog_browser_log::onceToken[0] != -1)
    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
  v10 = (id)gbrowserLogObj;
  v11 = v5[48];
  v12 = v5[18];
  if (v12 > 4)
    v13 = "<unknown>";
  else
    v13 = off_1E14A5370[v12];
  v23 = off_1E14A5370[a2];
  *(_DWORD *)buf = 136446978;
  v53 = "nw_browser_set_state_locked";
  v54 = 1024;
  v55 = v11;
  v56 = 2082;
  v57 = v13;
  v58 = 2082;
  v59 = v23;
  v24 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v50 = 0;
  if (__nwlog_fault(v24, &type, &v50))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v25 = (id)gbrowserLogObj;
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        v27 = v5[48];
        v28 = v5[18];
        if (v28 > 4)
          v29 = "<unknown>";
        else
          v29 = off_1E14A5370[v28];
        *(_DWORD *)buf = 136446978;
        v53 = "nw_browser_set_state_locked";
        v54 = 1024;
        v55 = v27;
        v56 = 2082;
        v57 = v29;
        v58 = 2082;
        v59 = v23;
        _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s [B%u] state changed: invalid transition %{public}s -> %{public}s", buf, 0x26u);
      }
    }
    else if (v50)
    {
      backtrace_string = __nw_create_backtrace_string();
      if (backtrace_string)
      {
        v31 = (char *)backtrace_string;
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v32 = (id)gbrowserLogObj;
        v33 = type;
        if (os_log_type_enabled(v32, type))
        {
          v34 = v5[48];
          v35 = v5[18];
          if (v35 > 4)
            v36 = "<unknown>";
          else
            v36 = off_1E14A5370[v35];
          *(_DWORD *)buf = 136447234;
          v53 = "nw_browser_set_state_locked";
          v54 = 1024;
          v55 = v34;
          v56 = 2082;
          v57 = v36;
          v58 = 2082;
          v59 = v23;
          v60 = 2082;
          v61 = v31;
          _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s [B%u] state changed: invalid transition %{public}s -> %{public}s, dumping backtrace:%{public}s", buf, 0x30u);
        }

        free(v31);
        if (v24)
          goto LABEL_52;
        goto LABEL_53;
      }
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v25 = (id)gbrowserLogObj;
      v41 = type;
      if (os_log_type_enabled(v25, type))
      {
        v42 = v5[48];
        v43 = v5[18];
        if (v43 > 4)
          v44 = "<unknown>";
        else
          v44 = off_1E14A5370[v43];
        *(_DWORD *)buf = 136446978;
        v53 = "nw_browser_set_state_locked";
        v54 = 1024;
        v55 = v42;
        v56 = 2082;
        v57 = v44;
        v58 = 2082;
        v59 = v23;
        _os_log_impl(&dword_182FBE000, v25, v41, "%{public}s [B%u] state changed: invalid transition %{public}s -> %{public}s, no backtrace", buf, 0x26u);
      }
    }
    else
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v25 = (id)gbrowserLogObj;
      v37 = type;
      if (os_log_type_enabled(v25, type))
      {
        v38 = v5[48];
        v39 = v5[18];
        if (v39 > 4)
          v40 = "<unknown>";
        else
          v40 = off_1E14A5370[v39];
        *(_DWORD *)buf = 136446978;
        v53 = "nw_browser_set_state_locked";
        v54 = 1024;
        v55 = v38;
        v56 = 2082;
        v57 = v40;
        v58 = 2082;
        v59 = v23;
        _os_log_impl(&dword_182FBE000, v25, v37, "%{public}s [B%u] state changed: invalid transition %{public}s -> %{public}s, backtrace limit exceeded", buf, 0x26u);
      }
    }

  }
  if (v24)
LABEL_52:
    free(v24);
LABEL_53:

}

uint64_t ___ZL27nw_browser_set_state_lockedP21NWConcrete_nw_browser18nw_browser_state_tPU22objcproto11OS_nw_error8NSObject_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 48) + 16))(*(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 32));
}

void ___ZL36nw_browser_start_path_browser_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v4;
  id v5;

  v5 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  v4 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v4 + 72) == 1)
  {
    objc_storeStrong((id *)(v4 + 96), a2);
    nw_browser_update_path_browser_locked(*(NWConcrete_nw_browser **)(a1 + 32));
    v4 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 8));

}

void sub_1838F8FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZL36nw_browser_start_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2(uint64_t a1)
{
  uint64_t v2;

  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v2 + 72) == 1)
  {
    nw_browser_update_path_browser_locked((NWConcrete_nw_browser *)v2);
    v2 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
}

void nw_browser_update_path_browser_locked(NWConcrete_nw_browser *a1)
{
  NWConcrete_nw_browser *v1;
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  void **v5;
  _QWORD *v6;
  id v7;
  void **v8;
  void *v9;
  _BOOL8 v10;
  _QWORD *v11;
  NSObject *v12;
  uint64_t v13;
  void **v14;
  unsigned __int8 *v15;
  NWConcrete_nw_browser *v16;
  int v17;
  _BOOL8 v18;
  _BOOL8 v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  id v22;
  id v23;
  void **v24;
  id v25;
  _QWORD *v26;
  NSObject **v27;
  NSObject *v28;
  id v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  void *v33;
  _QWORD *v34;
  void *v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  char *backtrace_string;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  _QWORD *v43;
  unsigned __int8 *object;
  _QWORD v45[4];
  NWConcrete_nw_browser *v46;
  id v47;
  _QWORD v48[4];
  void **v49;
  _QWORD v50[4];
  void **v51;
  id v52;
  _QWORD block[4];
  id v54;
  id v55;
  os_log_type_t type[8];
  uint64_t v57;
  uint64_t (*v58)(uint64_t *, uint64_t, void *);
  void *v59;
  id v60;
  id v61;
  NSObject **v62;
  _QWORD v63[4];
  id v64;
  uint8_t v65[4];
  const char *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  uint64_t v70;
  __int16 v71;
  _QWORD *v72;
  _BYTE buf[40];
  id v74;
  id v75;
  void **v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = nw_dictionary_create();
    v3 = (void *)*((_QWORD *)v1 + 12);
    v4 = MEMORY[0x1E0C809B0];
    v50[0] = MEMORY[0x1E0C809B0];
    v50[1] = 3221225472;
    v50[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke;
    v50[3] = &unk_1E14A5198;
    v5 = v1;
    v51 = v5;
    v6 = v2;
    v52 = v6;
    nw_path_enumerate_browse_options(v3, v50);
    objc_storeStrong(v5 + 13, v2);
    v7 = nw_path_copy_discovered_endpoints(*((void **)v1 + 12));
    if (nw_browse_descriptor_get_type(v5[4]) == 2)
    {
      v8 = v5;
      object = (unsigned __int8 *)v7;
      v9 = _Block_copy(v8[7]);
      if (v9)
      {
        v10 = nw_array_create();
        v63[0] = v4;
        v63[1] = 3221225472;
        v63[2] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke;
        v63[3] = &unk_1E14AC200;
        v11 = (id)v10;
        v64 = v11;
        nw_array_apply(object, (uint64_t)v63);
        if (!nw_parameters_get_logging_disabled((uint64_t)v8[5]))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v12 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            if (v11)
              v13 = (uint64_t)(v11[3] - v11[2]) >> 3;
            else
              v13 = 0;
            v17 = *((_DWORD *)v8 + 48);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_browser_app_svc_update_browse_result_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v17;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v13;
            *(_WORD *)&buf[28] = 2112;
            *(_QWORD *)&buf[30] = v11;
            _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] discovered %zu endpoints: %@", buf, 0x26u);
          }

        }
        v43 = v6;
        v18 = nw_array_create();
        v19 = nw_parallel_array_create();
        v20 = (unsigned __int8 *)v8[17];
        *(_QWORD *)buf = v4;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_109;
        *(_QWORD *)&buf[24] = &unk_1E14A5260;
        v21 = v11;
        *(_QWORD *)&buf[32] = v21;
        v22 = (id)v18;
        v74 = v22;
        v23 = (id)v19;
        v75 = v23;
        v24 = v8;
        v76 = v24;
        nw_array_apply(v20, (uint64_t)buf);
        *(_QWORD *)type = v4;
        v57 = 3221225472;
        v58 = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_112;
        v59 = &unk_1E14AA9F0;
        v25 = v23;
        v60 = v25;
        v26 = v22;
        v61 = v26;
        v27 = v24;
        v62 = v27;
        nw_array_apply(v21, (uint64_t)type);
        v28 = v27[2];
        block[0] = v4;
        block[1] = 3221225472;
        block[2] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_113;
        block[3] = &unk_1E14ACE18;
        v29 = v25;
        v54 = v29;
        v55 = v9;
        dispatch_async(v28, block);
        if (!nw_parameters_get_logging_disabled((uint64_t)v8[5]))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v30 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            if (v26)
              v31 = (uint64_t)(v26[3] - v26[2]) >> 3;
            else
              v31 = 0;
            v32 = *((_DWORD *)v27 + 48);
            *(_DWORD *)v65 = 136446978;
            v66 = "nw_browser_app_svc_update_browse_result_locked";
            v67 = 1024;
            v68 = v32;
            v69 = 2048;
            v70 = v31;
            v71 = 2112;
            v72 = v26;
            _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new_results %zu endpoints: %@", v65, 0x26u);
          }

        }
        v33 = v8[17];
        v8[17] = v26;
        v34 = v26;

        v6 = v43;
      }

    }
    else
    {
      v48[0] = v4;
      v48[1] = 3221225472;
      v48[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2;
      v48[3] = &unk_1E14AC200;
      v14 = v5;
      v49 = v14;
      nw_array_apply((unsigned __int8 *)v7, (uint64_t)v48);
      v15 = (unsigned __int8 *)v14[17];
      v45[0] = v4;
      v45[1] = 3221225472;
      v45[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_107;
      v45[3] = &unk_1E14A8D20;
      v16 = v14;
      v46 = v16;
      v47 = v7;
      nw_array_apply(v15, (uint64_t)v45);
      nw_browser_notify_browse_result_changes_locked(v16);

    }
    goto LABEL_26;
  }
  __nwlog_obj();
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_browser_update_path_browser_locked";
  v36 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(block[0]) = 0;
  if (__nwlog_fault(v36, type, block))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v37 = objc_claimAutoreleasedReturnValue();
      v38 = type[0];
      if (os_log_type_enabled(v37, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browser_update_path_browser_locked";
        _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (LOBYTE(block[0]))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v37 = objc_claimAutoreleasedReturnValue();
      v40 = type[0];
      v41 = os_log_type_enabled(v37, type[0]);
      if (backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_browser_update_path_browser_locked";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browser_update_path_browser_locked";
        _os_log_impl(&dword_182FBE000, v37, v40, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v37 = objc_claimAutoreleasedReturnValue();
      v42 = type[0];
      if (os_log_type_enabled(v37, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browser_update_path_browser_locked";
        _os_log_impl(&dword_182FBE000, v37, v42, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_43:
  if (v36)
    free(v36);
LABEL_26:

}

void sub_1838F9740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,void *a32)
{
  void *v32;
  void *v33;
  void *v34;

  _Unwind_Resume(a1);
}

void ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1, unsigned __int8 *uu)
{
  uint64_t v4;
  uint64_t v5;
  void *flow_inner;
  void *v7;
  char out[40];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 104);
  if (!v5)
    goto LABEL_4;
  flow_inner = nw_dictionary_copy_value(v5, (uint64_t)out);
  if (!flow_inner)
  {
    v4 = *(_QWORD *)(a1 + 32);
LABEL_4:
    flow_inner = nw_path_evaluator_create_flow_inner(*(void **)(v4 + 88), 0, 0, 1, 0, uu, 0, 0, 0);
  }
  v7 = flow_inner;
  nw_dictionary_set_value(*(_QWORD *)(a1 + 40), out, flow_inner);

}

uint64_t ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  unsigned __int8 *v5;
  id v6;
  _QWORD v8[4];
  id v9;

  v4 = a3;
  v5 = *(unsigned __int8 **)(a1 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2;
  v8[3] = &unk_1E14AC200;
  v6 = v4;
  v9 = v6;
  if (nw_array_apply(v5, (uint64_t)v8))
    nw_array_append(*(_QWORD *)(a1 + 32), v6);

  return 1;
}

uint64_t ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_109(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  id endpoint;
  void *v6;
  unsigned __int8 *v7;
  id v8;
  NSObject *v9;
  NSObject *v10;
  nw_browse_result_change_t changes;
  _BOOL8 v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  _QWORD v18[4];
  id v19;
  id v20;
  NSObject *v21;
  id v22;
  NSObject *v23;
  id v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  NSObject *v35;
  __int16 v36;
  _BOOL8 v37;
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  endpoint = nw_browse_result_get_endpoint(v4);
  v38 = 0uLL;
  nw_endpoint_get_service_identifier(endpoint, &v38);
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", &v38);
  v26 = 0;
  v27 = &v26;
  v28 = 0x2020000000;
  v29 = 0;
  v7 = *(unsigned __int8 **)(a1 + 32);
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 3221225472;
  v18[2] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2_111;
  v18[3] = &unk_1E14A5238;
  v8 = v6;
  v19 = v8;
  v25 = &v26;
  v20 = *(id *)(a1 + 40);
  v9 = endpoint;
  v21 = v9;
  v22 = *(id *)(a1 + 48);
  v10 = v4;
  v23 = v10;
  v24 = *(id *)(a1 + 56);
  if (nw_array_apply(v7, (uint64_t)v18))
  {
    nw_parallel_array_append(*(_QWORD *)(a1 + 48), v10, 0);
    if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40)))
    {
      changes = nw_browse_result_get_changes(v10, 0);
      v12 = nw_browse_result_get_change_description(changes);
      if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v13 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
        {
          v14 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 192);
          *(_DWORD *)buf = 136446978;
          v31 = "nw_browser_app_svc_update_browse_result_locked_block_invoke";
          v32 = 1024;
          v33 = v14;
          v34 = 2112;
          v35 = v10;
          v36 = 2082;
          v37 = v12;
          _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_INFO, "%{public}s [B%u] browse_result_removed: (%@), %{public}s", buf, 0x26u);
        }

      }
      if (v12)
        free((void *)v12);
    }
  }
  else
  {
    if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 40)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v15 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v16 = *(_DWORD *)(*(_QWORD *)(a1 + 56) + 192);
        *(_DWORD *)buf = 136446722;
        v31 = "nw_browser_app_svc_update_browse_result_locked_block_invoke";
        v32 = 1024;
        v33 = v16;
        v34 = 2112;
        v35 = v9;
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] browse_result_matched existing endpoint: %@", buf, 0x1Cu);
      }

    }
  }

  _Block_object_dispose(&v26, 8);
  return 1;
}

void sub_1838F9C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  void *v15;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_112(uint64_t *a1, uint64_t a2, void *a3)
{
  id v4;
  NSObject *v5;
  nw_browse_result_change_t changes;
  _BOOL8 v7;
  NSObject *v8;
  int v9;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  NSObject *v16;
  __int16 v17;
  _BOOL8 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v5 = nw_browse_result_create(v4);
  nw_parallel_array_append(a1[4], 0, v5);
  nw_array_append(a1[5], v5);
  if (!nw_parameters_get_logging_disabled(*(_QWORD *)(a1[6] + 40)))
  {
    changes = nw_browse_result_get_changes(0, v5);
    v7 = nw_browse_result_get_change_description(changes);
    if (!nw_parameters_get_logging_disabled(*(_QWORD *)(a1[6] + 40)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v8 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        v9 = *(_DWORD *)(a1[6] + 192);
        v11 = 136446978;
        v12 = "nw_browser_app_svc_update_browse_result_locked_block_invoke";
        v13 = 1024;
        v14 = v9;
        v15 = 2112;
        v16 = v5;
        v17 = 2082;
        v18 = v7;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_INFO, "%{public}s [B%u] browse_result_added: (%@), %{public}s", (uint8_t *)&v11, 0x26u);
      }

    }
    if (v7)
      free((void *)v7);
  }

  return 1;
}

void sub_1838F9E64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_113(uint64_t a1)
{
  uint64_t count;
  _QWORD *v3;
  _QWORD v4[4];
  id v5;
  uint64_t v6;

  count = nw_parallel_array_get_count(*(_QWORD **)(a1 + 32));
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2_114;
  v4[3] = &unk_1E14A5288;
  v3 = *(_QWORD **)(a1 + 32);
  v5 = *(id *)(a1 + 40);
  v6 = count;
  nw_parallel_array_apply(v3, (uint64_t)v4);

}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  id v5;
  unsigned __int8 *v6;
  id v7;
  id v8;
  void *v9;
  uint64_t domain_for_policy;
  uint64_t v11;
  int v12;
  size_t i;
  NSObject *v14;
  _QWORD v16[4];
  id v17;
  id v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  char v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  void *v29;
  __int16 v30;
  id v31;
  char __s[1009];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v5 = nw_endpoint_copy_interface(v4);
  v20 = 0;
  v21 = &v20;
  v22 = 0x2020000000;
  v23 = 1;
  v6 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 32) + 136);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_3;
  v16[3] = &unk_1E14A51E8;
  v7 = v4;
  v17 = v7;
  v8 = v5;
  v18 = v8;
  v19 = &v20;
  nw_array_apply(v6, (uint64_t)v16);
  if (*((_BYTE *)v21 + 24))
  {
    v9 = nw_endpoint_copy(v7);
    nw_endpoint_set_interface(v9, 0);
    bzero(__s, 0x3F1uLL);
    domain_for_policy = nw_endpoint_get_domain_for_policy(v9);
    if (domain_for_policy)
    {
      v11 = 0;
      while (1)
      {
        v12 = *(unsigned __int8 *)(domain_for_policy + v11);
        __s[v11] = v12;
        if (!v12)
          break;
        if (++v11 == 1008)
        {
          __s[1008] = 0;
          break;
        }
      }
      for (i = 0; i < strlen(__s); ++i)
        __s[i] = __tolower(__s[i]);
    }
    else
    {
      nw_browser_copy_key_for_application_service_endpoint(v9, __s);
    }
    if ((nw_browser_add_result_locked(*(void **)(a1 + 32), __s, v9, v8, 1) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v25 = "nw_browser_update_path_browser_locked_block_invoke_2";
        v26 = 2080;
        v27 = __s;
        v28 = 2112;
        v29 = v9;
        v30 = 2112;
        v31 = v8;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s Failed to add result for %s/%@ (%@)", buf, 0x2Au);
      }

    }
  }

  _Block_object_dispose(&v20, 8);
  return 1;
}

void sub_1838FA170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_107(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  id endpoint;
  _QWORD enumerator[4];
  id v8;
  id v9;
  id v10;

  v4 = a3;
  if (nw_browse_result_get_discovered_from_path(v4))
  {
    endpoint = nw_browse_result_get_endpoint(v4);
    if (nw_browse_result_get_interfaces_count(v4))
    {
      enumerator[0] = MEMORY[0x1E0C809B0];
      enumerator[1] = 3221225472;
      enumerator[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2_108;
      enumerator[3] = &unk_1E14A5210;
      v8 = *(id *)(a1 + 32);
      v9 = *(id *)(a1 + 40);
      v10 = endpoint;
      nw_browse_result_enumerate_interfaces(v4, enumerator);

    }
    else
    {
      nw_browser_check_and_remove_endpoints_locked(*(void **)(a1 + 32), *(void **)(a1 + 40), endpoint, 0);
    }

  }
  return 1;
}

void sub_1838FA2AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void nw_browser_notify_browse_result_changes_locked(NWConcrete_nw_browser *a1)
{
  NWConcrete_nw_browser *v1;
  NWConcrete_nw_browser *v2;
  xpc_object_t v3;
  void *v4;
  uint64_t v5;
  id v6;
  NWConcrete_nw_browser *v7;
  _QWORD *v8;
  void *v9;
  NWConcrete_nw_browser *v10;
  _QWORD *v11;
  _BOOL8 v12;
  id v13;
  id v14;
  void *v15;
  _QWORD *v16;
  NSObject *v17;
  int v18;
  void *v19;
  uint64_t count;
  uint64_t v21;
  NSObject *v22;
  void *v23;
  id v24;
  void *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  char *backtrace_string;
  os_log_type_t v30;
  _BOOL4 v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  os_log_type_t v36;
  char *v37;
  _BOOL4 v38;
  os_log_type_t v39;
  os_log_type_t v40;
  const char *v41;
  _QWORD block[4];
  _QWORD *v43;
  NWConcrete_nw_browser *v44;
  id v45;
  uint64_t v46;
  _QWORD applier[4];
  id v48;
  NWConcrete_nw_browser *v49;
  _BYTE *v50;
  os_log_type_t type[8];
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t, void *, void *);
  void *v54;
  id v55;
  char v56;
  _BYTE buf[24];
  uint64_t (*v58)(uint64_t, uint64_t);
  void (*v59)(uint64_t);
  _BOOL8 v60;
  _BYTE v61[24];
  void *v62;
  id v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!*((_QWORD *)v1 + 2))
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browser_notify_browse_result_changes_locked";
    v26 = (char *)_os_log_send_and_compose_impl();

    v61[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v26, v61, type))
    {
      if (v61[0] == 17)
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v28 = v61[0];
        if (os_log_type_enabled(v27, (os_log_type_t)v61[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_notify_browse_result_changes_locked";
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null browser->client_queue", buf, 0xCu);
        }
      }
      else if (type[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v30 = v61[0];
        v31 = os_log_type_enabled(v27, (os_log_type_t)v61[0]);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_notify_browse_result_changes_locked";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v27, v30, "%{public}s called with null browser->client_queue, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_45;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_notify_browse_result_changes_locked";
          _os_log_impl(&dword_182FBE000, v27, v30, "%{public}s called with null browser->client_queue, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v36 = v61[0];
        if (os_log_type_enabled(v27, (os_log_type_t)v61[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_notify_browse_result_changes_locked";
          _os_log_impl(&dword_182FBE000, v27, v36, "%{public}s called with null browser->client_queue, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_45:
    if (v26)
      free(v26);
    goto LABEL_18;
  }
  if (*((_DWORD *)v1 + 18) == 1)
  {
    v3 = xpc_dictionary_create(0, 0, 0);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v58 = __Block_byref_object_copy__56505;
    v59 = __Block_byref_object_dispose__56506;
    v60 = nw_parallel_array_create();
    v4 = (void *)*((_QWORD *)v2 + 20);
    v5 = MEMORY[0x1E0C809B0];
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke;
    applier[3] = &unk_1E14A52B0;
    v6 = v3;
    v48 = v6;
    v7 = v2;
    v49 = v7;
    v50 = buf;
    xpc_dictionary_apply(v4, applier);
    v8 = *(id *)(*(_QWORD *)&buf[8] + 40);
    if (nw_browse_descriptor_get_type(*((void **)v7 + 4)) != 2)
    {
      v16 = v8;
LABEL_14:
      v19 = _Block_copy(*((const void **)v7 + 7));
      count = nw_parallel_array_get_count(v16);
      if (v19)
      {
        v21 = count;
        if (count)
        {
          v22 = *((_QWORD *)v2 + 2);
          block[0] = v5;
          block[1] = 3221225472;
          block[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_118;
          block[3] = &unk_1E14A5300;
          v43 = v16;
          v44 = v7;
          v46 = v21;
          v45 = v19;
          dispatch_async(v22, block);

        }
      }
      v23 = (void *)*((_QWORD *)v2 + 20);
      *((_QWORD *)v2 + 20) = v6;
      v24 = v6;

      _Block_object_dispose(buf, 8);
      goto LABEL_18;
    }
    v9 = *(void **)(*(_QWORD *)&buf[8] + 40);
    v10 = v7;
    v11 = v9;
    if (v11)
    {
      v12 = nw_parallel_array_create();
      *(_QWORD *)v61 = v5;
      *(_QWORD *)&v61[8] = 3221225472;
      *(_QWORD *)&v61[16] = ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke;
      v62 = &unk_1E14A5328;
      v13 = (id)v12;
      v63 = v13;
      nw_parallel_array_apply(v11, (uint64_t)v61);
      *(_QWORD *)type = v5;
      v52 = 3221225472;
      v53 = ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke_2;
      v54 = &unk_1E14A5328;
      v14 = v13;
      v55 = v14;
      nw_parallel_array_apply(v11, (uint64_t)type);
      v15 = v55;
      v16 = v14;

LABEL_6:
      goto LABEL_14;
    }
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)v61 = 136446210;
    *(_QWORD *)&v61[4] = "nw_browser_create_ordered_array";
    v41 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v56 = 0;
    v33 = (char *)v41;
    if (!__nwlog_fault(v41, type, &v56))
    {
LABEL_54:
      if (v33)
        free(v33);
      v16 = 0;
      goto LABEL_6;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v35 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)v61 = 136446210;
        *(_QWORD *)&v61[4] = "nw_browser_create_ordered_array";
        _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s called with null results", v61, 0xCu);
      }
    }
    else if (v56)
    {
      v37 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v40 = type[0];
      v38 = os_log_type_enabled(v34, type[0]);
      if (v37)
      {
        if (v38)
        {
          *(_DWORD *)v61 = 136446466;
          *(_QWORD *)&v61[4] = "nw_browser_create_ordered_array";
          *(_WORD *)&v61[12] = 2082;
          *(_QWORD *)&v61[14] = v37;
          _os_log_impl(&dword_182FBE000, v34, v40, "%{public}s called with null results, dumping backtrace:%{public}s", v61, 0x16u);
        }

        free(v37);
        goto LABEL_53;
      }
      if (v38)
      {
        *(_DWORD *)v61 = 136446210;
        *(_QWORD *)&v61[4] = "nw_browser_create_ordered_array";
        _os_log_impl(&dword_182FBE000, v34, v40, "%{public}s called with null results, no backtrace", v61, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v39 = type[0];
      if (os_log_type_enabled(v34, type[0]))
      {
        *(_DWORD *)v61 = 136446210;
        *(_QWORD *)&v61[4] = "nw_browser_create_ordered_array";
        _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s called with null results, backtrace limit exceeded", v61, 0xCu);
      }
    }

LABEL_53:
    v33 = (char *)v41;
    goto LABEL_54;
  }
  if (!nw_parameters_get_logging_disabled(*((_QWORD *)v1 + 5)))
  {
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v17 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      v18 = *((_DWORD *)v2 + 48);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_browser_notify_browse_result_changes_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v18;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] not in ready state", buf, 0x12u);
    }

  }
LABEL_18:

}

void sub_1838FAA78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,void *a29)
{
  void *v29;
  void *v30;
  uint64_t v31;

  _Block_object_dispose((const void *)(v31 - 208), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__56505(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__56506(uint64_t a1)
{

}

uint64_t ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  id v5;
  uint64_t value;
  uint64_t v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL8 v22;
  void **v23;
  void **v24;
  uint64_t v25;
  void *v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _BOOL8 v33;
  void **v34;
  void **v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  NSObject *v39;
  int v40;
  nw_browse_result_change_t changes;
  _BOOL8 v42;
  NSObject *v43;
  int v44;
  void *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  char *v50;
  os_log_type_t v51;
  _BOOL4 v52;
  void *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  void *v57;
  os_log_type_t v58;
  os_log_type_t v59;
  void *v60;
  os_log_type_t v61;
  char *backtrace_string;
  os_log_type_t v63;
  _BOOL4 v64;
  void *v65;
  os_log_type_t v66;
  os_log_type_t v67;
  _BOOL4 v68;
  void *v69;
  os_log_type_t v70;
  void *v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  os_log_type_t v75;
  _BOOL4 v76;
  os_log_type_t v77;
  _BOOL4 v78;
  os_log_type_t v79;
  os_log_type_t v80;
  os_log_type_t v81;
  _BOOL4 v82;
  char *v83;
  os_log_type_t v84;
  _BOOL4 v85;
  os_log_type_t v86;
  os_log_type_t v87;
  os_log_type_t v88;
  os_log_type_t v89;
  char v90;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v93;
  __int16 v94;
  _BYTE v95[14];
  __int16 v96;
  NSObject *v97;
  __int16 v98;
  _BOOL8 v99;
  uint64_t v100;

  v100 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  value = xpc_uint64_get_value(v5);
  v7 = value;
  if (value)
  {
    if ((value & 4) == 0)
    {
      xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 32), a2, 1uLL);
      if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 40)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v8 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          v9 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 192);
          *(_DWORD *)buf = 136446978;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v94 = 1024;
          *(_DWORD *)v95 = v9;
          *(_WORD *)&v95[4] = 2080;
          *(_QWORD *)&v95[6] = a2;
          v96 = 1024;
          LODWORD(v97) = 1;
          _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s = identical(%d)", buf, 0x22u);
        }

      }
      if (v7 == 1)
      {
        v10 = 1;
        goto LABEL_82;
      }
    }
    v11 = nw_browser_copy_old_result_locked(*(NWConcrete_nw_browser **)(a1 + 40), a2);
    v12 = nw_browser_copy_new_result_locked(*(NWConcrete_nw_browser **)(a1 + 40), a2);
    v13 = v12;
    v14 = *(_QWORD *)(a1 + 40);
    if (*(_BYTE *)(v14 + 196))
      v15 = (v7 & 2) == 0;
    else
      v15 = 1;
    if (!v15 && (v7 & 0x20) == 0)
    {
      xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 32), a2, v7);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = (id)gLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v94 = 2080;
        *(_QWORD *)v95 = a2;
        _os_log_impl(&dword_182FBE000, v18, OS_LOG_TYPE_DEBUG, "%{public}s changes_map: %s was added but delaying notify until TXT record is found", buf, 0x16u);
      }

      goto LABEL_80;
    }
    if ((~(_BYTE)v7 & 6) == 0)
    {
      __nwlog_obj();
      v53 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
      v54 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v90 = 0;
      if (!__nwlog_fault(v54, &type, &v90))
        goto LABEL_163;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v56 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s Cannot have both add and remove at the same time", buf, 0xCu);
        }
        goto LABEL_197;
      }
      if (!v90)
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v79 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v55, v79, "%{public}s Cannot have both add and remove at the same time, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_197;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v55 = objc_claimAutoreleasedReturnValue();
      v63 = type;
      v64 = os_log_type_enabled(v55, type);
      if (!backtrace_string)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v55, v63, "%{public}s Cannot have both add and remove at the same time, no backtrace", buf, 0xCu);
        }
        goto LABEL_197;
      }
      if (v64)
      {
        *(_DWORD *)buf = 136446466;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v94 = 2082;
        *(_QWORD *)v95 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v55, v63, "%{public}s Cannot have both add and remove at the same time, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_162;
    }
    if ((v7 & 2) != 0)
    {
      if (!v11 && v12)
      {
        v17 = *(_QWORD *)(v14 + 136);
        goto LABEL_51;
      }
      __nwlog_obj();
      v60 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
      v54 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v90 = 0;
      if (!__nwlog_fault(v54, &type, &v90))
        goto LABEL_163;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v61 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v55, v61, "%{public}s Unexpected result pair for add", buf, 0xCu);
        }
        goto LABEL_197;
      }
      if (!v90)
      {
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v86 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v55, v86, "%{public}s Unexpected result pair for add, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_197;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v55 = objc_claimAutoreleasedReturnValue();
      v75 = type;
      v76 = os_log_type_enabled(v55, type);
      if (!backtrace_string)
      {
        if (v76)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v55, v75, "%{public}s Unexpected result pair for add, no backtrace", buf, 0xCu);
        }
        goto LABEL_197;
      }
      if (v76)
      {
        *(_DWORD *)buf = 136446466;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v94 = 2082;
        *(_QWORD *)v95 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v55, v75, "%{public}s Unexpected result pair for add, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_162;
    }
    if ((v7 & 4) == 0)
    {
      if (!v11 || !v12)
      {
        __nwlog_obj();
        v69 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v54 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v90 = 0;
        if (!__nwlog_fault(v54, &type, &v90))
          goto LABEL_163;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v55 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v55, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_182FBE000, v55, v70, "%{public}s Unexpected result pair for change", buf, 0xCu);
          }
          goto LABEL_197;
        }
        if (!v90)
        {
          __nwlog_obj();
          v55 = objc_claimAutoreleasedReturnValue();
          v88 = type;
          if (os_log_type_enabled(v55, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_182FBE000, v55, v88, "%{public}s Unexpected result pair for change, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_197;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v81 = type;
        v82 = os_log_type_enabled(v55, type);
        if (!backtrace_string)
        {
          if (v82)
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_182FBE000, v55, v81, "%{public}s Unexpected result pair for change, no backtrace", buf, 0xCu);
          }
          goto LABEL_197;
        }
        if (v82)
        {
          *(_DWORD *)buf = 136446466;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v94 = 2082;
          *(_QWORD *)v95 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v55, v81, "%{public}s Unexpected result pair for change, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_162;
      }
      v19 = *(_QWORD *)(v14 + 136);
      if (v19)
      {
LABEL_30:
        v20 = *(_QWORD *)(v19 + 24) - *(_QWORD *)(v19 + 16);
        v21 = v20 >> 3;
        if (v20)
        {
          v22 = nw_array_create();
          std::vector<nw_object_wrapper_t>::reserve(v22 + 16, ((uint64_t)(*(_QWORD *)(v19 + 24) - *(_QWORD *)(v19 + 16)) >> 3) - 1);
          v24 = *(void ***)(v19 + 16);
          v23 = *(void ***)(v19 + 24);
          while (v24 != v23)
          {
            if (*v24 != v11)
              nw_array_append(v22, *v24);
            ++v24;
          }
          goto LABEL_40;
        }
LABEL_39:
        v22 = nw_array_create();
LABEL_40:
        v25 = *(_QWORD *)(a1 + 40);
        v26 = *(void **)(v25 + 136);
        *(_QWORD *)(v25 + 136) = v22;

        if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 40)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v27 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            v28 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 192);
            *(_DWORD *)buf = 136446722;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            v94 = 1024;
            *(_DWORD *)v95 = v28;
            *(_WORD *)&v95[4] = 2112;
            *(_QWORD *)&v95[6] = v11;
            _os_log_impl(&dword_182FBE000, v27, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] old: removed %@ from old_results", buf, 0x1Cu);
          }

        }
        v17 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 136);
        if (v17)
          v29 = (uint64_t)(*(_QWORD *)(v17 + 24) - *(_QWORD *)(v17 + 16)) >> 3;
        else
          v29 = 0;
        if (v21 - 1 == v29)
        {
          if (!v13)
          {
LABEL_69:
            if (nw_browse_result_get_changes(v11, v13) == 1)
            {
              if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 40)))
              {
                changes = nw_browse_result_get_changes(v11, v13);
                v42 = nw_browse_result_get_change_description(changes);
                if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 40)))
                {
                  if (__nwlog_browser_log::onceToken[0] != -1)
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                  v43 = (id)gbrowserLogObj;
                  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
                  {
                    v44 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 192);
                    *(_DWORD *)buf = 136447234;
                    v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    v94 = 1024;
                    *(_DWORD *)v95 = v44;
                    *(_WORD *)&v95[4] = 2112;
                    *(_QWORD *)&v95[6] = v11;
                    v96 = 2112;
                    v97 = v13;
                    v98 = 2082;
                    v99 = v42;
                    _os_log_impl(&dword_182FBE000, v43, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] Suppressing identical results: (%@ -> %@), %{public}s", buf, 0x30u);
                  }

                }
                if (v42)
                  free((void *)v42);
              }
            }
            else
            {
              nw_parallel_array_append(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40), v11, v13);
            }
LABEL_80:
            v10 = 1;
LABEL_81:

            goto LABEL_82;
          }
LABEL_51:
          nw_array_append(v17, v13);
          v30 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 144);
          if (v30)
          {
            v31 = *(_QWORD *)(v30 + 24) - *(_QWORD *)(v30 + 16);
            v32 = v31 >> 3;
            if (v31)
            {
              v33 = nw_array_create();
              std::vector<nw_object_wrapper_t>::reserve(v33 + 16, ((uint64_t)(*(_QWORD *)(v30 + 24) - *(_QWORD *)(v30 + 16)) >> 3) - 1);
              v35 = *(void ***)(v30 + 16);
              v34 = *(void ***)(v30 + 24);
              while (v35 != v34)
              {
                if (*v35 != v13)
                  nw_array_append(v33, *v35);
                ++v35;
              }
LABEL_60:
              v36 = *(_QWORD *)(a1 + 40);
              v37 = *(void **)(v36 + 144);
              *(_QWORD *)(v36 + 144) = v33;

              v38 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 144);
              if (v38)
                v38 = (uint64_t)(*(_QWORD *)(v38 + 24) - *(_QWORD *)(v38 + 16)) >> 3;
              if (v32 - 1 == v38)
              {
                if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 40)))
                {
                  if (__nwlog_browser_log::onceToken[0] != -1)
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                  v39 = (id)gbrowserLogObj;
                  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
                  {
                    v40 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 192);
                    *(_DWORD *)buf = 136446722;
                    v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    v94 = 1024;
                    *(_DWORD *)v95 = v40;
                    *(_WORD *)&v95[4] = 2112;
                    *(_QWORD *)&v95[6] = v13;
                    _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: moved %@ from new_results to old_results", buf, 0x1Cu);
                  }

                }
                goto LABEL_69;
              }
              __nwlog_obj();
              v57 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446210;
              v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
              v54 = (char *)_os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v90 = 0;
              if (__nwlog_fault(v54, &type, &v90))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  v55 = objc_claimAutoreleasedReturnValue();
                  v58 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    _os_log_impl(&dword_182FBE000, v55, v58, "%{public}s Should have removed from new results", buf, 0xCu);
                  }
LABEL_197:

                  goto LABEL_163;
                }
                if (!v90)
                {
                  __nwlog_obj();
                  v55 = objc_claimAutoreleasedReturnValue();
                  v80 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    _os_log_impl(&dword_182FBE000, v55, v80, "%{public}s Should have removed from new results, backtrace limit exceeded", buf, 0xCu);
                  }
                  goto LABEL_197;
                }
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                v55 = objc_claimAutoreleasedReturnValue();
                v67 = type;
                v68 = os_log_type_enabled(v55, type);
                if (!backtrace_string)
                {
                  if (v68)
                  {
                    *(_DWORD *)buf = 136446210;
                    v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                    _os_log_impl(&dword_182FBE000, v55, v67, "%{public}s Should have removed from new results, no backtrace", buf, 0xCu);
                  }
                  goto LABEL_197;
                }
                if (v68)
                {
                  *(_DWORD *)buf = 136446466;
                  v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
                  v94 = 2082;
                  *(_QWORD *)v95 = backtrace_string;
                  _os_log_impl(&dword_182FBE000, v55, v67, "%{public}s Should have removed from new results, dumping backtrace:%{public}s", buf, 0x16u);
                }
                goto LABEL_162;
              }
LABEL_163:
              if (v54)
                free(v54);
              v10 = 0;
              goto LABEL_81;
            }
          }
          else
          {
            v32 = 0;
          }
          v33 = nw_array_create();
          goto LABEL_60;
        }
        __nwlog_obj();
        v65 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        v54 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v90 = 0;
        if (!__nwlog_fault(v54, &type, &v90))
          goto LABEL_163;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v55 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v55, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_182FBE000, v55, v66, "%{public}s Should have removed old result", buf, 0xCu);
          }
          goto LABEL_197;
        }
        if (!v90)
        {
          __nwlog_obj();
          v55 = objc_claimAutoreleasedReturnValue();
          v87 = type;
          if (os_log_type_enabled(v55, type))
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_182FBE000, v55, v87, "%{public}s Should have removed old result, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_197;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v55 = objc_claimAutoreleasedReturnValue();
        v77 = type;
        v78 = os_log_type_enabled(v55, type);
        if (!backtrace_string)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446210;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            _os_log_impl(&dword_182FBE000, v55, v77, "%{public}s Should have removed old result, no backtrace", buf, 0xCu);
          }
          goto LABEL_197;
        }
        if (v78)
        {
          *(_DWORD *)buf = 136446466;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v94 = 2082;
          *(_QWORD *)v95 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v55, v77, "%{public}s Should have removed old result, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_162:

        free(backtrace_string);
        goto LABEL_163;
      }
LABEL_38:
      v21 = 0;
      goto LABEL_39;
    }

    if (v11)
    {
      v13 = 0;
      v19 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 136);
      if (v19)
        goto LABEL_30;
      goto LABEL_38;
    }
    __nwlog_obj();
    v71 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
    v72 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v90 = 0;
    if (__nwlog_fault(v72, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v73 = objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v73, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s Unexpected result pair for remove", buf, 0xCu);
        }
      }
      else if (v90)
      {
        v83 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v73 = objc_claimAutoreleasedReturnValue();
        v84 = type;
        v85 = os_log_type_enabled(v73, type);
        if (v83)
        {
          if (v85)
          {
            *(_DWORD *)buf = 136446466;
            v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
            v94 = 2082;
            *(_QWORD *)v95 = v83;
            _os_log_impl(&dword_182FBE000, v73, v84, "%{public}s Unexpected result pair for remove, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v83);
          goto LABEL_201;
        }
        if (v85)
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v73, v84, "%{public}s Unexpected result pair for remove, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v73 = objc_claimAutoreleasedReturnValue();
        v89 = type;
        if (os_log_type_enabled(v73, type))
        {
          *(_DWORD *)buf = 136446210;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          _os_log_impl(&dword_182FBE000, v73, v89, "%{public}s Unexpected result pair for remove, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_201:
    if (v72)
      free(v72);
    v13 = 0;
    v10 = 0;
    goto LABEL_81;
  }
  __nwlog_obj();
  v46 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
  v47 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v90 = 0;
  if (__nwlog_fault(v47, &type, &v90))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s new_results should not have invalid changes", buf, 0xCu);
      }
    }
    else if (v90)
    {
      v50 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v51 = type;
      v52 = os_log_type_enabled(v48, type);
      if (v50)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446466;
          v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
          v94 = 2082;
          *(_QWORD *)v95 = v50;
          _os_log_impl(&dword_182FBE000, v48, v51, "%{public}s new_results should not have invalid changes, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v50);
        goto LABEL_129;
      }
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        _os_log_impl(&dword_182FBE000, v48, v51, "%{public}s new_results should not have invalid changes, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v48 = objc_claimAutoreleasedReturnValue();
      v59 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        v93 = "nw_browser_notify_browse_result_changes_locked_block_invoke";
        _os_log_impl(&dword_182FBE000, v48, v59, "%{public}s new_results should not have invalid changes, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_129:
  if (v47)
    free(v47);
  v10 = 0;
LABEL_82:

  return v10;
}

void sub_1838FBF4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6;
  id v7;
  NSObject *v8;
  NSObject *v9;

  v6 = a3;
  v7 = a4;
  v8 = v6;
  v9 = v7;
  if ((nw_browse_result_get_changes(v8, v9) & 4) != 0)
    nw_parallel_array_append(*(_QWORD *)(a1 + 32), v8, v9);

  return 1;
}

void sub_1838FBFF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_browser_create_ordered_arrayP21NWConcrete_nw_browserPU31objcproto20OS_nw_parallel_array8NSObject_block_invoke_2(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6;
  id v7;
  NSObject *v8;
  NSObject *v9;

  v6 = a3;
  v7 = a4;
  v8 = v6;
  v9 = v7;
  if ((nw_browse_result_get_changes(v8, v9) & 4) == 0)
    nw_parallel_array_append(*(_QWORD *)(a1 + 32), v8, v9);

  return 1;
}

void sub_1838FC08C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_118(uint64_t a1)
{
  _QWORD *v2;
  id v3;
  uint64_t v4;
  void *v5;
  _QWORD v6[4];
  id v7;
  id v8;
  uint64_t v9;

  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_2;
  v6[3] = &unk_1E14A52D8;
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(id *)(a1 + 40);
  v5 = *(void **)(a1 + 48);
  v4 = *(_QWORD *)(a1 + 56);
  v7 = v3;
  v9 = v4;
  v8 = v5;
  nw_parallel_array_apply(v2, (uint64_t)v6);

}

uint64_t ___ZL46nw_browser_notify_browse_result_changes_lockedP21NWConcrete_nw_browser_block_invoke_2(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6;
  id v7;
  NSObject *v8;
  NWConcrete_nw_browse_result *v9;
  NWConcrete_nw_browse_result *v10;
  NSObject *v11;
  NWConcrete_nw_browse_result *mutable_copy;
  nw_browse_result_change_t changes;
  _BOOL8 v14;
  NSObject *v15;
  int v16;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  NSObject *v23;
  __int16 v24;
  NWConcrete_nw_browse_result *v25;
  __int16 v26;
  _BOOL8 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v6 = a3;
  v7 = a4;
  v8 = v6;
  v9 = (NWConcrete_nw_browse_result *)v7;
  v10 = v9;
  v11 = v8;
  if (nw_browse_descriptor_get_type(*(void **)(*(_QWORD *)(a1 + 32) + 32)) == 2)
  {
    if (v8 && (mutable_copy = nw_browse_result_create_mutable_copy(v8), v8, mutable_copy))
    {
      *((_BYTE *)mutable_copy + 52) |= 1u;
      v11 = mutable_copy;
      if (!v9)
      {
LABEL_5:
        v10 = 0;
        goto LABEL_10;
      }
    }
    else
    {
      v11 = 0;
      if (!v9)
        goto LABEL_5;
    }
    v10 = nw_browse_result_create_mutable_copy(v9);

  }
  if (v10)
    *((_BYTE *)v10 + 52) |= 1u;
LABEL_10:
  if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40)))
  {
    changes = nw_browse_result_get_changes(v11, (nw_browse_result_t)v10);
    v14 = nw_browse_result_get_change_description(changes);
    if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v15 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        v16 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 192);
        v18 = 136447234;
        v19 = "nw_browser_notify_browse_result_changes_locked_block_invoke_2";
        v20 = 1024;
        v21 = v16;
        v22 = 2112;
        v23 = v11;
        v24 = 2112;
        v25 = v10;
        v26 = 2082;
        v27 = v14;
        _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_INFO, "%{public}s [B%u] browse_result_changed: (%@ -> %@), %{public}s", (uint8_t *)&v18, 0x30u);
      }

    }
    if (v14)
      free((void *)v14);
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();

  return 1;
}

void sub_1838FC374(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id nw_browser_copy_old_result_locked(NWConcrete_nw_browser *a1, const char *a2)
{
  NWConcrete_nw_browser *v3;
  NWConcrete_nw_browser *v4;
  unsigned __int8 *v5;
  id v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD v21[4];
  NWConcrete_nw_browser *v22;
  _BYTE *v23;
  const char *v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  id v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v28 = __Block_byref_object_copy__56505;
      v29 = __Block_byref_object_dispose__56506;
      v30 = 0;
      v5 = (unsigned __int8 *)*((_QWORD *)v3 + 17);
      v21[0] = MEMORY[0x1E0C809B0];
      v21[1] = 3221225472;
      v21[2] = ___ZL33nw_browser_copy_old_result_lockedP21NWConcrete_nw_browserPKc_block_invoke;
      v21[3] = &unk_1E14AAFC8;
      v23 = buf;
      v24 = a2;
      v22 = v3;
      nw_array_apply(v5, (uint64_t)v21);
      v6 = *(id *)(*(_QWORD *)&buf[8] + 40);

      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null key_name", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v25)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null key_name, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null key_name, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null key_name, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null browser", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v25)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null browser, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_copy_old_result_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_4:

  return v6;
}

id nw_browser_copy_new_result_locked(NWConcrete_nw_browser *a1, const char *a2)
{
  NWConcrete_nw_browser *v3;
  NWConcrete_nw_browser *v4;
  unsigned __int8 *v5;
  id v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  _QWORD v21[4];
  NWConcrete_nw_browser *v22;
  _BYTE *v23;
  const char *v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v28)(uint64_t, uint64_t);
  void (*v29)(uint64_t);
  id v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x3032000000;
      v28 = __Block_byref_object_copy__56505;
      v29 = __Block_byref_object_dispose__56506;
      v30 = 0;
      v5 = (unsigned __int8 *)*((_QWORD *)v3 + 18);
      v21[0] = MEMORY[0x1E0C809B0];
      v21[1] = 3221225472;
      v21[2] = ___ZL33nw_browser_copy_new_result_lockedP21NWConcrete_nw_browserPKc_block_invoke;
      v21[3] = &unk_1E14AAFC8;
      v23 = buf;
      v24 = a2;
      v22 = v3;
      nw_array_apply(v5, (uint64_t)v21);
      v6 = *(id *)(*(_QWORD *)&buf[8] + 40);

      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null key_name", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v25)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null key_name, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null key_name, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null key_name, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v9, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null browser", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v25)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null browser, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_copy_new_result_locked";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_4:

  return v6;
}

uint64_t ___ZL33nw_browser_copy_new_result_lockedP21NWConcrete_nw_browserPKc_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  id endpoint;
  void *v7;
  int v8;
  const char *bonjour_fullname;
  uint64_t v10;
  char v12[1009];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  endpoint = nw_browse_result_get_endpoint(v5);
  v7 = endpoint;
  if (endpoint)
  {
    v8 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
    if (v8 == 2)
    {
      bzero(v12, 0x3F1uLL);
      if (nw_browser_copy_key_for_application_service_endpoint(v7, v12)
        && !strcasecmp(v12, *(const char **)(a1 + 48)))
      {
        objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);
        goto LABEL_12;
      }
    }
    else if (v8 == 3)
    {
      bonjour_fullname = (const char *)nw_endpoint_get_bonjour_fullname(endpoint);
      if (bonjour_fullname)
      {
        if (!strcasecmp(bonjour_fullname, *(const char **)(a1 + 48)))
        {
          objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);
LABEL_12:
          v10 = 0;
          goto LABEL_10;
        }
      }
    }
  }
  v10 = 1;
LABEL_10:

  return v10;
}

void sub_1838FCF40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_browser_copy_key_for_application_service_endpoint(void *a1, char *a2)
{
  id v3;
  void *v4;
  id v5;
  int v6;
  uint64_t v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  os_log_type_t v20;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_browser_copy_key_for_application_service_endpoint";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v22)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v15 = type;
    v16 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_browser_copy_key_for_application_service_endpoint";
      v26 = 2082;
      v27 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  if (!a2)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_browser_copy_key_for_application_service_endpoint";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_37;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null key_buffer", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v9)
        free(v9);
      goto LABEL_39;
    }
    if (!v22)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null key_buffer, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    v18 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_browser_copy_key_for_application_service_endpoint";
        _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null key_buffer, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_browser_copy_key_for_application_service_endpoint";
      v26 = 2082;
      v27 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v10, v17, "%{public}s called with null key_buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  v5 = v3;
  v6 = objc_msgSend(v5, "type");

  if (v6 != 6)
  {
LABEL_39:
    v7 = 0;
    goto LABEL_40;
  }
  snprintf(a2, 0x3F1uLL, "%016zx", objc_msgSend(v5, "getHash"));
  v7 = 1;
LABEL_40:

  return v7;
}

void sub_1838FD438(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL33nw_browser_copy_old_result_lockedP21NWConcrete_nw_browserPKc_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  id endpoint;
  void *v7;
  int v8;
  const char *bonjour_fullname;
  uint64_t v10;
  char v12[1009];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  endpoint = nw_browse_result_get_endpoint(v5);
  v7 = endpoint;
  if (endpoint)
  {
    v8 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
    if (v8 == 2)
    {
      bzero(v12, 0x3F1uLL);
      if (nw_browser_copy_key_for_application_service_endpoint(v7, v12)
        && !strcasecmp(v12, *(const char **)(a1 + 48)))
      {
        objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);
        goto LABEL_12;
      }
    }
    else if (v8 == 3)
    {
      bonjour_fullname = (const char *)nw_endpoint_get_bonjour_fullname(endpoint);
      if (bonjour_fullname)
      {
        if (!strcasecmp(bonjour_fullname, *(const char **)(a1 + 48)))
        {
          objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a3);
LABEL_12:
          v10 = 0;
          goto LABEL_10;
        }
      }
    }
  }
  v10 = 1;
LABEL_10:

  return v10;
}

void sub_1838FD570(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_browser_check_and_remove_endpoints_locked(void *a1, void *a2, void *a3, void *a4)
{
  id v7;
  unsigned __int8 *v8;
  id v9;
  id v10;
  id v11;
  id v12;
  uint64_t domain_for_policy;
  uint64_t v14;
  int v15;
  size_t i;
  NSObject *v17;
  uint64_t v18;
  void *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  void *v24;
  os_log_type_t v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  _QWORD v33[4];
  id v34;
  id v35;
  char v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  char *v40;
  char __s[4];
  const char *v42;
  __int16 v43;
  char *v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = a4;
  if (!v7)
  {
    __nwlog_obj();
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__s = 136446210;
    v42 = "nw_browser_check_and_remove_endpoints_locked";
    v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v36 = 0;
    if (__nwlog_fault(v21, buf, &v36))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v23 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null browser", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      if (!v36)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v31 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_182FBE000, v22, v31, "%{public}s called with null browser, backtrace limit exceeded", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v27 = buf[0];
      v28 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)__s = 136446210;
          v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s called with null browser, no backtrace", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      if (v28)
      {
        *(_DWORD *)__s = 136446466;
        v42 = "nw_browser_check_and_remove_endpoints_locked";
        v43 = 2082;
        v44 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v22, v27, "%{public}s called with null browser, dumping backtrace:%{public}s", (uint8_t *)__s, 0x16u);
      }
LABEL_38:

      free(backtrace_string);
    }
LABEL_51:
    if (v21)
      free(v21);
    v18 = 0;
    goto LABEL_18;
  }
  if (!v9)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__s = 136446210;
    v42 = "nw_browser_check_and_remove_endpoints_locked";
    v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v36 = 0;
    if (__nwlog_fault(v21, buf, &v36))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v25 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_182FBE000, v22, v25, "%{public}s called with null old_endpoint", (uint8_t *)__s, 0xCu);
        }
LABEL_50:

        goto LABEL_51;
      }
      if (!v36)
      {
        __nwlog_obj();
        v22 = objc_claimAutoreleasedReturnValue();
        v32 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__s = 136446210;
          v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_182FBE000, v22, v32, "%{public}s called with null old_endpoint, backtrace limit exceeded", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v22 = objc_claimAutoreleasedReturnValue();
      v29 = buf[0];
      v30 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)__s = 136446210;
          v42 = "nw_browser_check_and_remove_endpoints_locked";
          _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null old_endpoint, no backtrace", (uint8_t *)__s, 0xCu);
        }
        goto LABEL_50;
      }
      if (v30)
      {
        *(_DWORD *)__s = 136446466;
        v42 = "nw_browser_check_and_remove_endpoints_locked";
        v43 = 2082;
        v44 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v22, v29, "%{public}s called with null old_endpoint, dumping backtrace:%{public}s", (uint8_t *)__s, 0x16u);
      }
      goto LABEL_38;
    }
    goto LABEL_51;
  }
  v33[0] = MEMORY[0x1E0C809B0];
  v33[1] = 3221225472;
  v33[2] = ___ZL44nw_browser_check_and_remove_endpoints_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS1_PU26objcproto15OS_nw_interfaceS1__block_invoke;
  v33[3] = &unk_1E14A8D20;
  v11 = v9;
  v34 = v11;
  v12 = v10;
  v35 = v12;
  if (nw_array_apply(v8, (uint64_t)v33))
  {
    bzero(__s, 0x3F1uLL);
    domain_for_policy = nw_endpoint_get_domain_for_policy(v11);
    if (domain_for_policy)
    {
      v14 = 0;
      while (1)
      {
        v15 = *(unsigned __int8 *)(domain_for_policy + v14);
        __s[v14] = v15;
        if (!v15)
          break;
        if (++v14 == 1008)
        {
          v45 = 0;
          break;
        }
      }
      for (i = 0; i < strlen(__s); ++i)
        __s[i] = __tolower(__s[i]);
    }
    else
    {
      nw_browser_copy_key_for_application_service_endpoint(v11, __s);
    }
    if ((nw_browser_remove_result_locked(v7, __s, v12) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = (id)gLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        v38 = "nw_browser_check_and_remove_endpoints_locked";
        v39 = 2080;
        v40 = __s;
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_ERROR, "%{public}s Failed to remove result for %s", buf, 0x16u);
      }

    }
  }

  v18 = 1;
LABEL_18:

  return v18;
}

void sub_1838FDBD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_2_108(void **a1, void *a2)
{
  return nw_browser_check_and_remove_endpoints_locked(a1[4], a1[5], a1[6], a2);
}

BOOL ___ZL44nw_browser_check_and_remove_endpoints_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS1_PU26objcproto15OS_nw_interfaceS1__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  id v5;
  void *v6;
  _BOOL8 v7;

  v4 = a3;
  v5 = nw_endpoint_copy_interface(v4);
  v7 = 1;
  if (nw_endpoint_is_equal(*(void **)(a1 + 32), v4, 0))
  {
    if (!v5 || (v6 = *(void **)(a1 + 40)) == 0 || nw_interface_shallow_compare(v5, v6))
      v7 = 0;
  }

  return v7;
}

void sub_1838FDCA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_browser_remove_result_locked(void *a1, const char *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t uint64;
  NSObject *v8;
  id v9;
  id v10;
  NSObject *v11;
  int v12;
  uint64_t browser_key_for;
  uint64_t pointer;
  NSObject *v15;
  int v16;
  id v17;
  BOOL logging_disabled;
  id v19;
  int v20;
  const char *v21;
  NSObject *v22;
  os_log_type_t v23;
  int v24;
  NSObject *v25;
  int v26;
  id v27;
  id v28;
  int v29;
  char *v30;
  id v31;
  NSObject *v32;
  os_log_type_t v33;
  int v34;
  const char *backtrace_string;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  int v39;
  const char *v40;
  char *v41;
  NSObject *v42;
  os_log_type_t v43;
  int v44;
  os_log_type_t v45;
  int v46;
  os_log_type_t v47;
  int v48;
  char *v49;
  os_log_type_t v50;
  int v51;
  os_log_type_t v52;
  int v53;
  NSObject *v54;
  int v55;
  uint64_t v56;
  id v57;
  int v58;
  const char *v59;
  NSObject *v60;
  os_log_type_t v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  const char *v65;
  char *v66;
  NSObject *v67;
  os_log_type_t v68;
  int v69;
  _BOOL8 v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  NSObject *v75;
  int v76;
  NSObject *v77;
  int v78;
  id v79;
  _BOOL4 v80;
  id v81;
  int v82;
  os_log_type_t v83;
  int v84;
  os_log_type_t v85;
  int v86;
  const char *v87;
  os_log_type_t v88;
  int v89;
  os_log_type_t v90;
  int v91;
  os_log_type_t v92;
  int v93;
  os_log_type_t v94;
  int v95;
  id v97;
  void *v98;
  NSObject *v99;
  os_log_type_t v100;
  const char *v101;
  _BOOL4 v102;
  char *v103;
  os_log_type_t v104;
  os_log_type_t v105;
  const char *v106;
  NSObject *v107;
  char v108;
  os_log_type_t type;
  _BYTE buf[40];
  uint64_t v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a3;
  uint64 = xpc_dictionary_get_uint64(*((xpc_object_t *)v5 + 20), a2);
  v8 = nw_browser_copy_result_to_modify_locked((NWConcrete_nw_browser *)v5, a2, uint64);
  v107 = v8;
  if (!uint64)
  {
    logging_disabled = nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5));
    if (!v8)
    {
      if (!logging_disabled)
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v25 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          v26 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v26;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = a2;
          _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_ERROR, "%{public}s [B%u] Trying to remove %s with invalid changes", buf, 0x1Cu);
        }

        goto LABEL_181;
      }
      goto LABEL_184;
    }
    if (logging_disabled)
      goto LABEL_184;
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v19 = (id)gbrowserLogObj;
    v20 = *((_DWORD *)v5 + 48);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v20;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = a2;
    v21 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v108 = 0;
    if (__nwlog_fault(v21, &type, &v108))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v22 = (id)gbrowserLogObj;
        v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          v24 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v24;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = a2;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s [B%u] Trying to remove %s with invalid changes", buf, 0x1Cu);
        }
      }
      else if (v108)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          v36 = (char *)backtrace_string;
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v37 = (id)gbrowserLogObj;
          v38 = type;
          if (os_log_type_enabled(v37, type))
          {
            v39 = *((_DWORD *)v5 + 48);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v39;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = a2;
            *(_WORD *)&buf[28] = 2082;
            *(_QWORD *)&buf[30] = v36;
            _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s [B%u] Trying to remove %s with invalid changes, dumping backtrace:%{public}s", buf, 0x26u);
          }

          free(v36);
          if (!v21)
            goto LABEL_181;
          goto LABEL_76;
        }
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v22 = (id)gbrowserLogObj;
        v47 = type;
        if (os_log_type_enabled(v22, type))
        {
          v48 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v48;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = a2;
          _os_log_impl(&dword_182FBE000, v22, v47, "%{public}s [B%u] Trying to remove %s with invalid changes, no backtrace", buf, 0x1Cu);
        }
      }
      else
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v22 = (id)gbrowserLogObj;
        v45 = type;
        if (os_log_type_enabled(v22, type))
        {
          v46 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v46;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = a2;
          _os_log_impl(&dword_182FBE000, v22, v45, "%{public}s [B%u] Trying to remove %s with invalid changes, backtrace limit exceeded", buf, 0x1Cu);
        }
      }

    }
    if (!v21)
      goto LABEL_181;
LABEL_76:
    v49 = (char *)v21;
LABEL_180:
    free(v49);
    goto LABEL_181;
  }
  if (v6 && *((_BYTE *)v5 + 196))
  {
    v9 = v5;
    v10 = v6;
    if (a2)
    {
      if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v11 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v12;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = a2;
          *(_WORD *)&buf[28] = 2112;
          *(_QWORD *)&buf[30] = v10;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] cancel query record for %s on %@", buf, 0x26u);
        }

      }
      browser_key_for = nw_create_browser_key_for (a2, v10);
      pointer = xpc_dictionary_get_pointer();
      if (pointer)
      {
        xpc_dictionary_set_pointer();
        if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v15 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v16 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v16;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = browser_key_for;
            _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns_ref_map: set %s to NULL", buf, 0x1Cu);
          }

        }
        if (browser_key_for)
          free((void *)browser_key_for);
        v17 = nw_parameters_copy_context(*((void **)v9 + 5));
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = ___ZL50nw_browser_cancel_query_record_for_endpoint_lockedP21NWConcrete_nw_browserPKcPU26objcproto15OS_nw_interface8NSObject_block_invoke;
        *(_QWORD *)&buf[24] = &unk_1E14AA348;
        v111 = pointer;
        *(_QWORD *)&buf[32] = v9;
        nw_queue_context_async(v17, buf);

        goto LABEL_92;
      }
      if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
      {
        v27 = v10;
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v28 = (id)gbrowserLogObj;
        v29 = *((_DWORD *)v9 + 48);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v29;
        v106 = (const char *)_os_log_send_and_compose_impl();

        v10 = v27;
        type = OS_LOG_TYPE_ERROR;
        v108 = 0;
        v30 = (char *)v106;
        if (!__nwlog_fault(v106, &type, &v108))
          goto LABEL_88;
        if (type == OS_LOG_TYPE_FAULT)
        {
          v31 = v10;
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v32 = (id)gbrowserLogObj;
          v33 = type;
          if (os_log_type_enabled(v32, type))
          {
            v34 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v34;
            _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s [B%u] Could not find dns_ref for service", buf, 0x12u);
          }
        }
        else if (v108)
        {
          v40 = __nw_create_backtrace_string();
          if (v40)
          {
            v41 = (char *)v40;
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v42 = (id)gbrowserLogObj;
            v43 = type;
            if (os_log_type_enabled(v42, type))
            {
              v44 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v44;
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v41;
              _os_log_impl(&dword_182FBE000, v42, v43, "%{public}s [B%u] Could not find dns_ref for service, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v41);
            goto LABEL_87;
          }
          v31 = v10;
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v32 = (id)gbrowserLogObj;
          v52 = type;
          if (os_log_type_enabled(v32, type))
          {
            v53 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v53;
            _os_log_impl(&dword_182FBE000, v32, v52, "%{public}s [B%u] Could not find dns_ref for service, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          v31 = v10;
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v32 = (id)gbrowserLogObj;
          v50 = type;
          if (os_log_type_enabled(v32, type))
          {
            v51 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v51;
            _os_log_impl(&dword_182FBE000, v32, v50, "%{public}s [B%u] Could not find dns_ref for service, backtrace limit exceeded", buf, 0x12u);
          }
        }

        v10 = v31;
LABEL_87:
        v30 = (char *)v106;
LABEL_88:
        if (v30)
          free(v30);
      }
    }
    else
    {
      __nwlog_obj();
      v97 = v10;
      v98 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
      browser_key_for = _os_log_send_and_compose_impl();

      v10 = v97;
      type = OS_LOG_TYPE_ERROR;
      v108 = 0;
      if (__nwlog_fault((const char *)browser_key_for, &type, &v108))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v99 = objc_claimAutoreleasedReturnValue();
          v100 = type;
          if (os_log_type_enabled(v99, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            _os_log_impl(&dword_182FBE000, v99, v100, "%{public}s called with null fullname", buf, 0xCu);
          }
        }
        else if (v108)
        {
          v101 = __nw_create_backtrace_string();
          __nwlog_obj();
          v99 = objc_claimAutoreleasedReturnValue();
          v105 = type;
          v102 = os_log_type_enabled(v99, type);
          if (v101)
          {
            v103 = (char *)v101;
            if (v102)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v101;
              _os_log_impl(&dword_182FBE000, v99, v105, "%{public}s called with null fullname, dumping backtrace:%{public}s", buf, 0x16u);
            }

            v10 = v97;
            free(v103);
            if (!browser_key_for)
              goto LABEL_92;
            goto LABEL_91;
          }
          if (v102)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            _os_log_impl(&dword_182FBE000, v99, v105, "%{public}s called with null fullname, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v99 = objc_claimAutoreleasedReturnValue();
          v104 = type;
          if (os_log_type_enabled(v99, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_browser_cancel_query_record_for_endpoint_locked";
            _os_log_impl(&dword_182FBE000, v99, v104, "%{public}s called with null fullname, backtrace limit exceeded", buf, 0xCu);
          }
        }

        v10 = v97;
      }
    }
    if (!browser_key_for)
    {
LABEL_92:

      v8 = v107;
      goto LABEL_93;
    }
LABEL_91:
    free((void *)browser_key_for);
    goto LABEL_92;
  }
  if (v6)
  {
LABEL_93:
    if (nw_browse_result_remove_interface(v8, v6))
      goto LABEL_94;
    if (!nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v57 = (id)gbrowserLogObj;
      v58 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v58;
      v59 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v108 = 0;
      if (!__nwlog_fault(v59, &type, &v108))
      {
LABEL_178:
        if (v59)
        {
LABEL_179:
          v49 = (char *)v59;
          goto LABEL_180;
        }
LABEL_181:
        v56 = 0;
LABEL_182:
        v8 = v107;
        goto LABEL_183;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v60 = (id)gbrowserLogObj;
        v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          v62 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v62;
          _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s [B%u] tried to remove non-existent interface", buf, 0x12u);
        }
        goto LABEL_177;
      }
      if (!v108)
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v60 = (id)gbrowserLogObj;
        v85 = type;
        if (os_log_type_enabled(v60, type))
        {
          v86 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v86;
          _os_log_impl(&dword_182FBE000, v60, v85, "%{public}s [B%u] tried to remove non-existent interface, backtrace limit exceeded", buf, 0x12u);
        }
        goto LABEL_177;
      }
      v65 = __nw_create_backtrace_string();
      if (!v65)
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v60 = (id)gbrowserLogObj;
        v90 = type;
        if (os_log_type_enabled(v60, type))
        {
          v91 = *((_DWORD *)v5 + 48);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v91;
          _os_log_impl(&dword_182FBE000, v60, v90, "%{public}s [B%u] tried to remove non-existent interface, no backtrace", buf, 0x12u);
        }
        goto LABEL_177;
      }
      v66 = (char *)v65;
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v67 = (id)gbrowserLogObj;
      v68 = type;
      if (os_log_type_enabled(v67, type))
      {
        v69 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v69;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v66;
        _os_log_impl(&dword_182FBE000, v67, v68, "%{public}s [B%u] tried to remove non-existent interface, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      goto LABEL_161;
    }
LABEL_184:
    v56 = 0;
    goto LABEL_183;
  }
LABEL_94:
  if (nw_browse_result_get_interfaces_count(v8))
  {
    xpc_dictionary_set_uint64(*((xpc_object_t *)v5 + 20), a2, uint64 | 0x10);
    if (nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5)))
    {
      v56 = 1;
      goto LABEL_183;
    }
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v54 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
    {
      v55 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v55;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = a2;
      *(_WORD *)&buf[28] = 2112;
      *(_QWORD *)&buf[30] = v6;
      _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s interface_removed(%@)", buf, 0x26u);
    }

    v56 = 1;
    goto LABEL_182;
  }
  v63 = *((_QWORD *)v5 + 18);
  if (v63)
    v64 = (uint64_t)(*(_QWORD *)(v63 + 24) - *(_QWORD *)(v63 + 16)) >> 3;
  else
    v64 = 0;
  v70 = nw_array_duplicate_array_without_object(v63, v8);
  v71 = (void *)*((_QWORD *)v5 + 18);
  *((_QWORD *)v5 + 18) = v70;

  v72 = *((_QWORD *)v5 + 18);
  if (v72)
    v73 = (uint64_t)(*(_QWORD *)(v72 + 24) - *(_QWORD *)(v72 + 16)) >> 3;
  else
    v73 = 0;
  v74 = nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5));
  if (v64 - 1 != v73)
  {
    if (v74)
      goto LABEL_181;
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v81 = (id)gbrowserLogObj;
    v82 = *((_DWORD *)v5 + 48);
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v82;
    v59 = (const char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v108 = 0;
    if (!__nwlog_fault(v59, &type, &v108))
      goto LABEL_178;
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v60 = (id)gbrowserLogObj;
      v83 = type;
      if (os_log_type_enabled(v60, type))
      {
        v84 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v84;
        _os_log_impl(&dword_182FBE000, v60, v83, "%{public}s [B%u] new: failed to remove from new_results", buf, 0x12u);
      }
LABEL_177:

      goto LABEL_178;
    }
    if (!v108)
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v60 = (id)gbrowserLogObj;
      v92 = type;
      if (os_log_type_enabled(v60, type))
      {
        v93 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v93;
        _os_log_impl(&dword_182FBE000, v60, v92, "%{public}s [B%u] new: failed to remove from new_results, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_177;
    }
    v87 = __nw_create_backtrace_string();
    if (!v87)
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v60 = (id)gbrowserLogObj;
      v94 = type;
      if (os_log_type_enabled(v60, type))
      {
        v95 = *((_DWORD *)v5 + 48);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v95;
        _os_log_impl(&dword_182FBE000, v60, v94, "%{public}s [B%u] new: failed to remove from new_results, no backtrace", buf, 0x12u);
      }
      goto LABEL_177;
    }
    v66 = (char *)v87;
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v67 = (id)gbrowserLogObj;
    v88 = type;
    if (os_log_type_enabled(v67, type))
    {
      v89 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v89;
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v66;
      _os_log_impl(&dword_182FBE000, v67, v88, "%{public}s [B%u] new: failed to remove from new_results, dumping backtrace:%{public}s", buf, 0x1Cu);
    }
LABEL_161:

    free(v66);
    if (!v59)
      goto LABEL_181;
    goto LABEL_179;
  }
  if (!v74)
  {
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v75 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
    {
      v76 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v76;
      *(_WORD *)&buf[18] = 2112;
      *(_QWORD *)&buf[20] = v107;
      _os_log_impl(&dword_182FBE000, v75, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: removed %@ from new_results", buf, 0x1Cu);
    }

  }
  xpc_dictionary_set_uint64(*((xpc_object_t *)v5 + 20), a2, uint64 | 4);
  if (!nw_parameters_get_logging_disabled(*((_QWORD *)v5 + 5)))
  {
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v77 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
    {
      v78 = *((_DWORD *)v5 + 48);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_browser_remove_result_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v78;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = a2;
      *(_WORD *)&buf[28] = 2112;
      *(_QWORD *)&buf[30] = v6;
      _os_log_impl(&dword_182FBE000, v77, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s result_removed(%@)", buf, 0x26u);
    }

  }
  v79 = nw_browser_copy_old_result_locked((NWConcrete_nw_browser *)v5, a2);
  v80 = v79 == 0;

  v8 = v107;
  if (v80)
    xpc_dictionary_set_value(*((xpc_object_t *)v5 + 20), a2, 0);
  nw_dictionary_set_value(*((_QWORD *)v5 + 21), a2, 0);
  v56 = 1;
LABEL_183:

  return v56;
}

void sub_1838FF2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

BOOL nw_browser_copy_result_to_modify_locked(NWConcrete_nw_browser *a1, const char *a2, uint64_t a3)
{
  NWConcrete_nw_browser *v5;
  NWConcrete_nw_browser *v6;
  id v7;
  void *v8;
  NWConcrete_nw_browse_result *mutable_copy;
  id v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  int v14;
  void *v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  char *backtrace_string;
  os_log_type_t v20;
  _BOOL4 v21;
  NSObject *v22;
  void *v23;
  _BOOL8 result;
  NSObject *v25;
  void *v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  _WORD v33[17];

  *(_QWORD *)&v33[13] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = v5;
  if (!a2)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v31 = "nw_browser_copy_result_to_modify_locked";
    v16 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v16, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s called with null key_name", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v20 = type;
        v21 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            v31 = "nw_browser_copy_result_to_modify_locked";
            v32 = 2082;
            *(_QWORD *)v33 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null key_name, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_182FBE000, v17, v20, "%{public}s called with null key_name, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v17 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_browser_copy_result_to_modify_locked";
          _os_log_impl(&dword_182FBE000, v17, v27, "%{public}s called with null key_name, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_41:
    if (v16)
      free(v16);
    goto LABEL_43;
  }
  if (!a3)
  {
LABEL_43:
    mutable_copy = 0;
    goto LABEL_44;
  }
  v7 = nw_browser_copy_new_result_locked(v5, a2);
  v8 = v7;
  if (v7)
  {
    mutable_copy = (NWConcrete_nw_browse_result *)v7;
LABEL_20:

LABEL_44:
    return (BOOL)mutable_copy;
  }
  v10 = nw_browser_copy_old_result_locked(v6, a2);
  if (!v10)
  {
    __nwlog_obj();
    v22 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v31 = "nw_browser_copy_result_to_modify_locked";
    v23 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v23);
    if (result)
      goto LABEL_45;
    free(v23);
  }
  mutable_copy = nw_browse_result_create_mutable_copy(v10);
  if (mutable_copy)
  {
LABEL_7:
    if (!nw_parameters_get_logging_disabled(*((_QWORD *)v6 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v11 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v12 = *((_DWORD *)v6 + 48);
        *(_DWORD *)buf = 136446722;
        v31 = "nw_browser_copy_result_to_modify_locked";
        v32 = 1024;
        *(_DWORD *)v33 = v12;
        v33[2] = 2112;
        *(_QWORD *)&v33[3] = mutable_copy;
        _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] copy %@", buf, 0x1Cu);
      }

    }
    nw_array_append(*((_QWORD *)v6 + 18), mutable_copy);
    if (!nw_parameters_get_logging_disabled(*((_QWORD *)v6 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v13 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v14 = *((_DWORD *)v6 + 48);
        *(_DWORD *)buf = 136446722;
        v31 = "nw_browser_copy_result_to_modify_locked";
        v32 = 1024;
        *(_DWORD *)v33 = v14;
        v33[2] = 2112;
        *(_QWORD *)&v33[3] = mutable_copy;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] add %@ to new_results", buf, 0x1Cu);
      }

    }
    goto LABEL_20;
  }
  __nwlog_obj();
  v25 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  v31 = "nw_browser_copy_result_to_modify_locked";
  v26 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    goto LABEL_7;
  }
LABEL_45:
  __break(1u);
  return result;
}

void sub_1838FF8AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_create_browser_key_for (const char *a1, void *a2)
{
  const char *v3;
  char *v4;
  const char *v5;
  size_t v6;
  size_t v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  _BOOL8 result;
  NSObject *v21;
  void *v22;
  NSObject *v23;
  void *v24;

  v3 = a2;
  v4 = (char *)v3;
  if (v3)
    v5 = v3 + 104;
  else
    v5 = 0;
  v6 = strlen(a1);
  if (v4)
    v7 = strlen(v5);
  else
    v7 = 0;
  if (v6 + v7 == -1)
  {
    __nwlog_obj();
    v21 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
    v22 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v22);
    if (result)
      goto LABEL_32;
    free(v22);
  }
  v8 = malloc_type_malloc(v6 + v7 + 1, 0xF2B69DE5uLL);
  v9 = v8;
  if (v8)
  {
    *v8 = 0;
    if (v6 + v7 != -1)
    {
LABEL_10:
      v10 = v9;
      if (v6 + v7)
      {
        v11 = v6 + v7 + 1;
        v10 = v9;
        while (1)
        {
          v12 = *(unsigned __int8 *)a1;
          *v10 = v12;
          if (!v12)
            break;
          ++v10;
          ++a1;
          if ((unint64_t)--v11 <= 1)
            goto LABEL_14;
        }
      }
      else
      {
LABEL_14:
        *v10 = 0;
      }
      if (v4)
      {
        v13 = 0;
        v14 = 1;
        while (1)
        {
          v15 = &v9[v13];
          if (!v9[v13])
            break;
          ++v13;
          --v14;
          if (v6 + v7 + 1 == v13)
            goto LABEL_26;
        }
        if (v6 + v7 + v14 < 2)
        {
LABEL_25:
          *v15 = 0;
        }
        else
        {
          v16 = 0;
          v17 = 0;
          while (1)
          {
            v18 = v5[v16];
            v9[v16 + v13] = v18;
            if (!v18)
              break;
            v19 = v6 + v7 - v13 + v17--;
            ++v16;
            if (v19 <= 1)
            {
              v15 = &v9[v13 + v16];
              goto LABEL_25;
            }
          }
        }
      }
    }
LABEL_26:

    return (BOOL)v9;
  }
  __nwlog_obj();
  v23 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
  v24 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v24);
  if (!result)
  {
    free(v24);
    MEMORY[0] = 0;
    if (v6 + v7 != -1)
      goto LABEL_10;
    goto LABEL_26;
  }
LABEL_32:
  __break(1u);
  return result;
}

void sub_1838FFB90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL50nw_browser_cancel_query_record_for_endpoint_lockedP21NWConcrete_nw_browserPKcPU26objcproto15OS_nw_interface8NSObject_block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  DNSServiceRefDeallocate(*(DNSServiceRef *)(a1 + 40));
  if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40)))
  {
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v2 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      v3 = *(_QWORD *)(a1 + 40);
      v4 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 192);
      v5 = 136446722;
      v6 = "nw_browser_cancel_query_record_for_endpoint_locked_block_invoke";
      v7 = 1024;
      v8 = v4;
      v9 = 2048;
      v10 = v3;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] deallocate dns_ref %p", (uint8_t *)&v5, 0x1Cu);
    }

  }
}

uint64_t ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  id endpoint;
  int is_equal;
  void *v7;
  id v8;
  uint64_t v9;
  _QWORD v11[4];
  id v12;
  uint64_t v13;

  v4 = a3;
  endpoint = nw_browse_result_get_endpoint(v4);
  is_equal = nw_endpoint_is_equal(endpoint, *(void **)(a1 + 32), 0);
  if (is_equal)
  {
    v7 = *(void **)(a1 + 40);
    if (v7)
    {
      v11[0] = MEMORY[0x1E0C809B0];
      v11[1] = 3221225472;
      v11[2] = ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_4;
      v11[3] = &unk_1E14A51C0;
      v8 = v7;
      v9 = *(_QWORD *)(a1 + 48);
      v12 = v8;
      v13 = v9;
      nw_browse_result_enumerate_interfaces(v4, v11);

    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
    }
  }

  return is_equal ^ 1u;
}

void sub_1838FFD80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_browser_add_result_locked(void *a1, const char *a2, void *a3, void *a4, int a5)
{
  id v9;
  id v10;
  char *v11;
  uint64_t uint64;
  _BOOL8 v13;
  void *v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  id v22;
  int v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  int v27;
  id v28;
  int v29;
  char *v30;
  NSObject *v31;
  os_log_type_t v32;
  int v33;
  const char *backtrace_string;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  int v38;
  const char *v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  int v43;
  os_log_type_t v44;
  int v45;
  os_log_type_t v46;
  int v47;
  os_log_type_t v48;
  int v49;
  os_log_type_t v50;
  int v51;
  void *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  char *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  os_log_type_t v60;
  char v61;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v64;
  __int16 v65;
  _BYTE v66[14];
  __int16 v67;
  const char *v68;
  __int16 v69;
  char *v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v9 = a1;
  v10 = a3;
  v11 = a4;
  if (v9)
  {
    uint64 = xpc_dictionary_get_uint64(*((xpc_object_t *)v9 + 20), a2);
    v13 = nw_browser_copy_result_to_modify_locked((NWConcrete_nw_browser *)v9, a2, uint64);
    v14 = (void *)v13;
    if (uint64)
    {
      if (!v11)
        goto LABEL_26;
      nw_browse_result_set_discovered_from_path((void *)v13, a5);
      if (nw_browse_result_insert_interface(v14, v11))
      {
        xpc_dictionary_set_uint64(*((xpc_object_t *)v9 + 20), a2, uint64 | 8);
        if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v15 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            v16 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            v64 = "nw_browser_add_result_locked";
            v65 = 1024;
            *(_DWORD *)v66 = v16;
            *(_WORD *)&v66[4] = 2080;
            *(_QWORD *)&v66[6] = a2;
            v67 = 2112;
            v68 = v11;
            _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s interface_added(%@)", buf, 0x26u);
          }
LABEL_25:

        }
LABEL_26:
        v21 = 1;
LABEL_89:

        goto LABEL_90;
      }
      if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v22 = (id)gbrowserLogObj;
        v23 = *((_DWORD *)v9 + 48);
        *(_DWORD *)buf = 136446978;
        v64 = "nw_browser_add_result_locked";
        v65 = 1024;
        *(_DWORD *)v66 = v23;
        *(_WORD *)&v66[4] = 2112;
        *(_QWORD *)&v66[6] = v11;
        v67 = 2080;
        v68 = a2;
        v24 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v61 = 0;
        if (__nwlog_fault(v24, &type, &v61))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v25 = (id)gbrowserLogObj;
            v26 = type;
            if (os_log_type_enabled(v25, type))
            {
              v27 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v27;
              *(_WORD *)&v66[4] = 2112;
              *(_QWORD *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s [B%u] tried to insert duplicate interface %@ for %s", buf, 0x26u);
            }
          }
          else if (v61)
          {
            backtrace_string = __nw_create_backtrace_string();
            if (backtrace_string)
            {
              v35 = (char *)backtrace_string;
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v36 = (id)gbrowserLogObj;
              v37 = type;
              if (os_log_type_enabled(v36, type))
              {
                v38 = *((_DWORD *)v9 + 48);
                *(_DWORD *)buf = 136447234;
                v64 = "nw_browser_add_result_locked";
                v65 = 1024;
                *(_DWORD *)v66 = v38;
                *(_WORD *)&v66[4] = 2112;
                *(_QWORD *)&v66[6] = v11;
                v67 = 2080;
                v68 = a2;
                v69 = 2082;
                v70 = v35;
                _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s", buf, 0x30u);
              }

              free(v35);
              if (!v24)
                goto LABEL_88;
              goto LABEL_74;
            }
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v25 = (id)gbrowserLogObj;
            v46 = type;
            if (os_log_type_enabled(v25, type))
            {
              v47 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v47;
              *(_WORD *)&v66[4] = 2112;
              *(_QWORD *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              _os_log_impl(&dword_182FBE000, v25, v46, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, no backtrace", buf, 0x26u);
            }
          }
          else
          {
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v25 = (id)gbrowserLogObj;
            v44 = type;
            if (os_log_type_enabled(v25, type))
            {
              v45 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136446978;
              v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v45;
              *(_WORD *)&v66[4] = 2112;
              *(_QWORD *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              _os_log_impl(&dword_182FBE000, v25, v44, "%{public}s [B%u] tried to insert duplicate interface %@ for %s, backtrace limit exceeded", buf, 0x26u);
            }
          }

        }
        if (v24)
LABEL_74:
          free(v24);
      }
LABEL_88:
      v21 = 0;
      goto LABEL_89;
    }
    v15 = nw_browse_result_create(v10);
    nw_browse_result_set_discovered_from_path(v15, a5);
    if (!v11 || nw_browse_result_insert_interface(v15, v11))
    {
      nw_array_append(*((_QWORD *)v9 + 18), v15);
      if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v17 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          v18 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446722;
          v64 = "nw_browser_add_result_locked";
          v65 = 1024;
          *(_DWORD *)v66 = v18;
          *(_WORD *)&v66[4] = 2112;
          *(_QWORD *)&v66[6] = v15;
          _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] new: added %@ to new_results", buf, 0x1Cu);
        }

      }
      xpc_dictionary_set_uint64(*((xpc_object_t *)v9 + 20), a2, 2uLL);
      if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v19 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          v20 = *((_DWORD *)v9 + 48);
          *(_DWORD *)buf = 136446978;
          v64 = "nw_browser_add_result_locked";
          v65 = 1024;
          *(_DWORD *)v66 = v20;
          *(_WORD *)&v66[4] = 2080;
          *(_QWORD *)&v66[6] = a2;
          v67 = 1024;
          LODWORD(v68) = 2;
          _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s = result_added(%d)", buf, 0x22u);
        }

      }
      goto LABEL_25;
    }
    if (!nw_parameters_get_logging_disabled(*((_QWORD *)v9 + 5)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v28 = (id)gbrowserLogObj;
      v29 = *((_DWORD *)v9 + 48);
      *(_DWORD *)buf = 136446978;
      v64 = "nw_browser_add_result_locked";
      v65 = 1024;
      *(_DWORD *)v66 = v29;
      *(_WORD *)&v66[4] = 2112;
      *(_QWORD *)&v66[6] = v11;
      v67 = 2080;
      v68 = a2;
      v30 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v61 = 0;
      if (__nwlog_fault(v30, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v31 = (id)gbrowserLogObj;
          v32 = type;
          if (os_log_type_enabled(v31, type))
          {
            v33 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            v64 = "nw_browser_add_result_locked";
            v65 = 1024;
            *(_DWORD *)v66 = v33;
            *(_WORD *)&v66[4] = 2112;
            *(_QWORD *)&v66[6] = v11;
            v67 = 2080;
            v68 = a2;
            _os_log_impl(&dword_182FBE000, v31, v32, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s", buf, 0x26u);
          }
        }
        else if (v61)
        {
          v39 = __nw_create_backtrace_string();
          if (v39)
          {
            v40 = (char *)v39;
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v41 = (id)gbrowserLogObj;
            v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              v43 = *((_DWORD *)v9 + 48);
              *(_DWORD *)buf = 136447234;
              v64 = "nw_browser_add_result_locked";
              v65 = 1024;
              *(_DWORD *)v66 = v43;
              *(_WORD *)&v66[4] = 2112;
              *(_QWORD *)&v66[6] = v11;
              v67 = 2080;
              v68 = a2;
              v69 = 2082;
              v70 = v40;
              _os_log_impl(&dword_182FBE000, v41, v42, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, dumping backtrace:%{public}s", buf, 0x30u);
            }

            free(v40);
            if (!v30)
              goto LABEL_87;
            goto LABEL_86;
          }
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v31 = (id)gbrowserLogObj;
          v50 = type;
          if (os_log_type_enabled(v31, type))
          {
            v51 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            v64 = "nw_browser_add_result_locked";
            v65 = 1024;
            *(_DWORD *)v66 = v51;
            *(_WORD *)&v66[4] = 2112;
            *(_QWORD *)&v66[6] = v11;
            v67 = 2080;
            v68 = a2;
            _os_log_impl(&dword_182FBE000, v31, v50, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, no backtrace", buf, 0x26u);
          }
        }
        else
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v31 = (id)gbrowserLogObj;
          v48 = type;
          if (os_log_type_enabled(v31, type))
          {
            v49 = *((_DWORD *)v9 + 48);
            *(_DWORD *)buf = 136446978;
            v64 = "nw_browser_add_result_locked";
            v65 = 1024;
            *(_DWORD *)v66 = v49;
            *(_WORD *)&v66[4] = 2112;
            *(_QWORD *)&v66[6] = v11;
            v67 = 2080;
            v68 = a2;
            _os_log_impl(&dword_182FBE000, v31, v48, "%{public}s [B%u] new: tried to insert duplicate interface %@ for %s, backtrace limit exceeded", buf, 0x26u);
          }
        }

      }
      if (v30)
LABEL_86:
        free(v30);
    }
LABEL_87:

    goto LABEL_88;
  }
  __nwlog_obj();
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v64 = "nw_browser_add_result_locked";
  v54 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v61 = 0;
  if (__nwlog_fault(v54, &type, &v61))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v55 = objc_claimAutoreleasedReturnValue();
      v56 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v61)
    {
      v57 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v55 = objc_claimAutoreleasedReturnValue();
      v58 = type;
      v59 = os_log_type_enabled(v55, type);
      if (v57)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          v64 = "nw_browser_add_result_locked";
          v65 = 2082;
          *(_QWORD *)v66 = v57;
          _os_log_impl(&dword_182FBE000, v55, v58, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v57);
        goto LABEL_107;
      }
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_182FBE000, v55, v58, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v55 = objc_claimAutoreleasedReturnValue();
      v60 = type;
      if (os_log_type_enabled(v55, type))
      {
        *(_DWORD *)buf = 136446210;
        v64 = "nw_browser_add_result_locked";
        _os_log_impl(&dword_182FBE000, v55, v60, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_107:
  if (v54)
    free(v54);
  v21 = 0;
LABEL_90:

  return v21;
}

void sub_183900ACC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

BOOL ___ZL37nw_browser_update_path_browser_lockedP21NWConcrete_nw_browser_block_invoke_4(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = nw_interface_shallow_compare(*(void **)(a1 + 32), a2);
  if (v3)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  return !v3;
}

uint64_t ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2_114(uint64_t a1, unint64_t a2, void *a3, void *a4)
{
  id v7;
  id v8;
  _BYTE *v9;
  id v10;
  void *v11;

  v7 = a3;
  v8 = a4;
  v9 = v7;
  v10 = v8;
  v11 = v10;
  if (v9)
    v9[52] |= 1u;
  if (v10)
    *((_BYTE *)v10 + 52) |= 1u;
  (*(void (**)(_QWORD, _BYTE *, id, BOOL))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), v9, v10, *(_QWORD *)(a1 + 40) - 1 <= a2);

  return 1;
}

void sub_183900BEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2_111(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  void *v6;
  int v7;
  NSObject *v8;
  nw_browse_result_change_t changes;
  _BOOL8 v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  NSObject *v22;
  __int16 v23;
  _BOOL8 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v25 = 0uLL;
  nw_endpoint_get_service_identifier(v5, &v25);
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", &v25);
  v7 = objc_msgSend(*(id *)(a1 + 32), "isEqual:", v6);
  if (v7)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) = a2;
    v8 = nw_browse_result_create(v5);
    nw_array_append(*(_QWORD *)(a1 + 40), v8);
    if ((nw_endpoint_is_equal(*(void **)(a1 + 48), v5, 30) & 1) == 0)
    {
      nw_parallel_array_append(*(_QWORD *)(a1 + 56), *(void **)(a1 + 64), v8);
      if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 40)))
      {
        changes = nw_browse_result_get_changes(*(nw_browse_result_t *)(a1 + 64), v8);
        v10 = nw_browse_result_get_change_description(changes);
        if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 40)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v11 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
          {
            v12 = *(_QWORD *)(a1 + 64);
            v13 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 192);
            v15 = 136447234;
            v16 = "nw_browser_app_svc_update_browse_result_locked_block_invoke_2";
            v17 = 1024;
            v18 = v13;
            v19 = 2112;
            v20 = v12;
            v21 = 2112;
            v22 = v8;
            v23 = 2082;
            v24 = v10;
            _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_INFO, "%{public}s [B%u] browse_result_changed: (%@ -> %@), %{public}s", (uint8_t *)&v15, 0x30u);
          }

        }
        if (v10)
          free((void *)v10);
      }
    }

  }
  return v7 ^ 1u;
}

void sub_183900E08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

BOOL ___ZL46nw_browser_app_svc_update_browse_result_lockedP21NWConcrete_nw_browserPU22objcproto11OS_nw_array8NSObject_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  _BOOL8 v5;
  __int128 uu2;
  __int128 uu1;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  uu1 = 0uLL;
  uu2 = 0uLL;
  nw_endpoint_get_service_identifier(v4, &uu1);
  nw_endpoint_get_service_identifier(*(void **)(a1 + 32), &uu2);
  v5 = uuid_compare((const unsigned __int8 *)&uu1, (const unsigned __int8 *)&uu2) != 0;

  return v5;
}

void sub_183900EE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_browser_start_query_record_for_endpoint_locked(void *a1, void *a2, const char *a3, void *a4)
{
  id context;
  NSObject *v8;
  _DWORD *v9;
  int v10;
  BOOL logging_disabled;
  NSObject *v12;
  int v13;
  DNSServiceFlags v14;
  const DNSServiceAttribute *v15;
  uint32_t v16;
  id v17;
  int v18;
  uint64_t browser_key_for;
  NSObject *v20;
  os_log_type_t v21;
  int v22;
  const char *backtrace_string;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  int v27;
  DNSServiceErrorType RecordWithAttribute;
  int v29;
  os_log_type_t v30;
  int v31;
  os_log_type_t v32;
  int v33;
  void *v34;
  os_log_type_t v35;
  void *v36;
  os_log_type_t v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  os_log_type_t v44;
  size_t out_signature_length;
  os_log_type_t type[8];
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  _BYTE v50[14];
  __int16 v51;
  _DWORD *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  context = a1;
  v8 = a2;
  v9 = a4;
  if (v8)
  {
    if (a3)
    {
      v10 = *((_DWORD *)context + 18);
      logging_disabled = nw_parameters_get_logging_disabled(*((_QWORD *)context + 5));
      if (v10 == 1)
      {
        if (!logging_disabled)
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v12 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            v13 = *((_DWORD *)context + 48);
            *(_DWORD *)buf = 136446978;
            v48 = "nw_browser_start_query_record_for_endpoint_locked";
            v49 = 1024;
            *(_DWORD *)v50 = v13;
            *(_WORD *)&v50[4] = 2080;
            *(_QWORD *)&v50[6] = a3;
            v51 = 2112;
            v52 = v9;
            _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] start query record for %s on %@", buf, 0x26u);
          }

        }
        *(_QWORD *)type = *((_QWORD *)context + 15);
        v14 = nw_browser_derive_endpoint_flags((NWConcrete_nw_browser *)context);
        out_signature_length = 0;
        v15 = 0;
        if (nw_endpoint_get_signature(v8, &out_signature_length) && out_signature_length)
        {
          v15 = DNSServiceAttributeCreate();
          DNSServiceAttrSetValidationData();
        }
        if (v9)
          v16 = v9[2];
        else
          v16 = 0;
        RecordWithAttribute = DNSServiceQueryRecordWithAttribute((DNSServiceRef *)type, v14, v16, a3, 0x10u, 1u, v15, (DNSServiceQueryRecordReply)nw_browser_dns_service_query_record_callback, context);
        if (v15)
          DNSServiceAttributeDeallocate(v15);
        if (nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)context, RecordWithAttribute, "DNSServiceQueryRecord"))
        {
          goto LABEL_55;
        }
        browser_key_for = nw_create_browser_key_for (a3, v9);
        xpc_dictionary_set_pointer();
        if (nw_parameters_get_logging_disabled(*((_QWORD *)context + 5)))
          goto LABEL_53;
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v20 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          v29 = *((_DWORD *)context + 48);
          *(_DWORD *)buf = 136446978;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          v49 = 1024;
          *(_DWORD *)v50 = v29;
          *(_WORD *)&v50[4] = 2080;
          *(_QWORD *)&v50[6] = browser_key_for;
          v51 = 2048;
          v52 = *(_DWORD **)type;
          _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] dns_ref_map: set %s -> %p", buf, 0x26u);
        }
      }
      else
      {
        if (logging_disabled)
          goto LABEL_55;
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v17 = (id)gbrowserLogObj;
        v18 = *((_DWORD *)context + 48);
        *(_DWORD *)buf = 136446466;
        v48 = "nw_browser_start_query_record_for_endpoint_locked";
        v49 = 1024;
        *(_DWORD *)v50 = v18;
        browser_key_for = _os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(out_signature_length) = 0;
        if (!__nwlog_fault((const char *)browser_key_for, type, &out_signature_length))
          goto LABEL_53;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v20 = (id)gbrowserLogObj;
          v21 = type[0];
          if (os_log_type_enabled(v20, type[0]))
          {
            v22 = *((_DWORD *)context + 48);
            *(_DWORD *)buf = 136446466;
            v48 = "nw_browser_start_query_record_for_endpoint_locked";
            v49 = 1024;
            *(_DWORD *)v50 = v22;
            _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s [B%u] not in ready state", buf, 0x12u);
          }
        }
        else if ((_BYTE)out_signature_length)
        {
          backtrace_string = __nw_create_backtrace_string();
          if (backtrace_string)
          {
            v24 = (char *)backtrace_string;
            if (__nwlog_browser_log::onceToken[0] != -1)
              dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
            v25 = (id)gbrowserLogObj;
            v26 = type[0];
            if (os_log_type_enabled(v25, type[0]))
            {
              v27 = *((_DWORD *)context + 48);
              *(_DWORD *)buf = 136446722;
              v48 = "nw_browser_start_query_record_for_endpoint_locked";
              v49 = 1024;
              *(_DWORD *)v50 = v27;
              *(_WORD *)&v50[4] = 2082;
              *(_QWORD *)&v50[6] = v24;
              _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s [B%u] not in ready state, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v24);
            if (browser_key_for)
              goto LABEL_54;
            goto LABEL_55;
          }
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v20 = (id)gbrowserLogObj;
          v32 = type[0];
          if (os_log_type_enabled(v20, type[0]))
          {
            v33 = *((_DWORD *)context + 48);
            *(_DWORD *)buf = 136446466;
            v48 = "nw_browser_start_query_record_for_endpoint_locked";
            v49 = 1024;
            *(_DWORD *)v50 = v33;
            _os_log_impl(&dword_182FBE000, v20, v32, "%{public}s [B%u] not in ready state, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v20 = (id)gbrowserLogObj;
          v30 = type[0];
          if (os_log_type_enabled(v20, type[0]))
          {
            v31 = *((_DWORD *)context + 48);
            *(_DWORD *)buf = 136446466;
            v48 = "nw_browser_start_query_record_for_endpoint_locked";
            v49 = 1024;
            *(_DWORD *)v50 = v31;
            _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s [B%u] not in ready state, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }
      goto LABEL_52;
    }
    __nwlog_obj();
    v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_browser_start_query_record_for_endpoint_locked";
    browser_key_for = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(out_signature_length) = 0;
    if (__nwlog_fault((const char *)browser_key_for, type, &out_signature_length))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v37 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_182FBE000, v20, v37, "%{public}s called with null fullname", buf, 0xCu);
        }
LABEL_52:

        goto LABEL_53;
      }
      if (!(_BYTE)out_signature_length)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v44 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_182FBE000, v20, v44, "%{public}s called with null fullname, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_52;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v41 = type[0];
      v42 = os_log_type_enabled(v20, type[0]);
      if (!v38)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_182FBE000, v20, v41, "%{public}s called with null fullname, no backtrace", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        v48 = "nw_browser_start_query_record_for_endpoint_locked";
        v49 = 2082;
        *(_QWORD *)v50 = v38;
        _os_log_impl(&dword_182FBE000, v20, v41, "%{public}s called with null fullname, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_75:

      free(v38);
      if (!browser_key_for)
        goto LABEL_55;
      goto LABEL_54;
    }
  }
  else
  {
    __nwlog_obj();
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_browser_start_query_record_for_endpoint_locked";
    browser_key_for = _os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(out_signature_length) = 0;
    if (__nwlog_fault((const char *)browser_key_for, type, &out_signature_length))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v35 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_182FBE000, v20, v35, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (!(_BYTE)out_signature_length)
      {
        __nwlog_obj();
        v20 = objc_claimAutoreleasedReturnValue();
        v43 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_182FBE000, v20, v43, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_52;
      }
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v39 = type[0];
      v40 = os_log_type_enabled(v20, type[0]);
      if (!v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_browser_start_query_record_for_endpoint_locked";
          _os_log_impl(&dword_182FBE000, v20, v39, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_52;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v48 = "nw_browser_start_query_record_for_endpoint_locked";
        v49 = 2082;
        *(_QWORD *)v50 = v38;
        _os_log_impl(&dword_182FBE000, v20, v39, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_75;
    }
  }
LABEL_53:
  if (browser_key_for)
LABEL_54:
    free((void *)browser_key_for);
LABEL_55:

}

void sub_183901910(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void nw_browser_dns_service_query_record_callback(_DNSServiceRef_t *a1, char a2, unsigned int a3, int a4, const char *a5, unsigned __int16 a6, unsigned __int16 a7, unsigned int a8, const uint8_t *a9, unsigned int a10, void *a11)
{
  os_unfair_lock_s *v15;
  os_unfair_lock_s *v16;
  size_t i;
  uint64_t v18;
  nw_txt_record_t v19;
  nw_txt_record_t v20;
  NSObject *v21;
  _BOOL4 v22;
  _BOOL8 v23;
  NSObject *v24;
  os_unfair_lock_s *v25;
  os_unfair_lock_s *v26;
  uint64_t v27;
  NSObject *v28;
  uint32_t v29;
  NSObject *v30;
  uint32_t os_unfair_lock_opaque;
  NSObject *v32;
  NSObject *v33;
  uint32_t v34;
  NSObject *v35;
  uint32_t v36;
  NSObject *v37;
  unint64_t v38;
  os_unfair_lock_s *v39;
  NSObject *v40;
  void *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  void *v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  char *v49;
  os_log_type_t v50;
  _BOOL4 v51;
  char *v52;
  os_log_type_t v53;
  _BOOL4 v54;
  os_log_type_t v55;
  os_log_type_t v56;
  void *v57;
  char *v58;
  NSObject *v59;
  os_log_type_t v60;
  char *v61;
  os_log_type_t v62;
  _BOOL4 v63;
  os_log_type_t v64;
  NSObject *v65;
  uint64_t v66;
  uint32_t v67;
  id v68;
  void *v69;
  id *v70;
  uint64_t uint64;
  NSObject *v72;
  NSObject *v73;
  int isa;
  uint32_t v75;
  Class v76;
  Class v77;
  NSObject *v78;
  const void *ValidationData;
  id endpoint;
  void *v81;
  uint64_t v82;
  NSObject *v83;
  uint32_t v84;
  NSObject *v85;
  uint32_t v86;
  id v87;
  uint32_t v88;
  char *v89;
  NSObject *v90;
  os_log_type_t v91;
  uint32_t v92;
  const char *backtrace_string;
  char *v94;
  NSObject *v95;
  os_log_type_t v96;
  uint32_t v97;
  os_log_type_t v98;
  uint32_t v99;
  os_log_type_t v100;
  uint32_t v101;
  _BOOL8 v102;
  NSObject *left;
  char v104;
  os_unfair_lock_s *v105;
  os_log_type_t type[8];
  os_log_type_t *v107;
  uint64_t v108;
  char v109;
  char v110;
  _QWORD v111[4];
  NSObject *v112;
  char key[4];
  const char *v114;
  __int16 v115;
  char *v116;
  _BYTE buf[40];
  __int128 v118;
  os_log_type_t *v119;
  const uint8_t *v120;
  char *v121;
  __int16 v122;
  _BYTE v123[12];
  __int16 v124;
  _BYTE v125[20];
  __int16 v126;
  char *v127;
  uint64_t v128;

  v128 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v15 = a11;
    v16 = v15;
    if (v15)
    {
      os_unfair_lock_lock(v15 + 2);
      if (!nw_browser_fail_on_dns_error_locked((NWConcrete_nw_browser *)v16, a4, "nw_browser_dns_service_query_record_callback")&& v16[18]._os_unfair_lock_opaque == 1)
      {
        v104 = a2;
        bzero(key, 0x3F1uLL);
        for (i = 0; i < strlen(a5); ++i)
          key[i] = __tolower(a5[i]);
        if (xpc_dictionary_get_uint64(*(xpc_object_t *)&v16[40]._os_unfair_lock_opaque, key))
        {
          v105 = v16;
          v18 = (uint64_t)nw_dictionary_copy_value(*(_QWORD *)&v105[42]._os_unfair_lock_opaque, (uint64_t)key);
          v19 = nw_txt_record_create_with_bytes(a9, a8);
          v20 = v19;
          if (!v19)
            goto LABEL_53;
          v21 = v19;
          v22 = (BYTE4(v21[4].isa) & 1) == 0;

          if (v22)
          {
            __nwlog_obj();
            v24 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v123 = 136446210;
              *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
              _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s txt: discovered non-key/value TXT record", v123, 0xCu);
            }
            goto LABEL_52;
          }
          if ((v104 & 2) != 0)
          {
            if (!v18)
            {
              v18 = nw_array_create();
              nw_dictionary_set_value(*(_QWORD *)&v105[42]._os_unfair_lock_opaque, key, (void *)v18);
              if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v105[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v30 = (id)gbrowserLogObj;
                if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
                {
                  os_unfair_lock_opaque = v105[48]._os_unfair_lock_opaque;
                  *(_DWORD *)v123 = 136446722;
                  *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
                  v124 = 1024;
                  *(_DWORD *)v125 = os_unfair_lock_opaque;
                  *(_WORD *)&v125[4] = 2080;
                  *(_QWORD *)&v125[6] = key;
                  _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: create new txt_array for %s", v123, 0x1Cu);
                }

              }
            }
            v111[0] = MEMORY[0x1E0C809B0];
            v111[1] = 3221225472;
            v111[2] = ___ZL32nw_browser_copy_txt_array_lockedP21NWConcrete_nw_browserPKcPKvtj_block_invoke;
            v111[3] = &unk_1E14AC200;
            v32 = v21;
            v112 = v32;
            if (nw_array_apply((unsigned __int8 *)v18, (uint64_t)v111))
            {
              nw_array_append(v18, v32);
              if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v105[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v33 = (id)gbrowserLogObj;
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
                {
                  v34 = v105[48]._os_unfair_lock_opaque;
                  *(_DWORD *)v123 = 136447234;
                  *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
                  v124 = 1024;
                  *(_DWORD *)v125 = v34;
                  *(_WORD *)&v125[4] = 1040;
                  *(_DWORD *)&v125[6] = a8;
                  *(_WORD *)&v125[10] = 2080;
                  *(_QWORD *)&v125[12] = a9;
                  v126 = 2080;
                  v127 = key;
                  _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: add %.*s to %s", v123, 0x2Cu);
                }

              }
            }
            v24 = v112;
            goto LABEL_52;
          }
          if (v18)
          {
            v23 = nw_array_create();
            *(_QWORD *)type = 0;
            v107 = type;
            v108 = 0x2020000000;
            v109 = 0;
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buf[8] = 3221225472;
            *(_QWORD *)&buf[16] = ___ZL32nw_browser_copy_txt_array_lockedP21NWConcrete_nw_browserPKcPKvtj_block_invoke_127;
            *(_QWORD *)&buf[24] = &unk_1E14A5350;
            v119 = type;
            *(_QWORD *)&buf[32] = v21;
            v24 = (id)v23;
            *(_QWORD *)&v118 = v24;
            v25 = v105;
            v26 = v105;
            v122 = a8;
            *((_QWORD *)&v118 + 1) = v26;
            v120 = a9;
            v121 = key;
            nw_array_apply((unsigned __int8 *)v18, (uint64_t)buf);
            if (v24)
              v27 = (v24[3].isa - v24[2].isa) >> 3;
            else
              v27 = 0;
            if (v27 != ((uint64_t)(*(_QWORD *)(v18 + 24) - *(_QWORD *)(v18 + 16)) >> 3) - 1
              && !nw_parameters_get_logging_disabled(*(_QWORD *)&v26[10]._os_unfair_lock_opaque))
            {
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v35 = (id)gbrowserLogObj;
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              {
                v36 = v26[48]._os_unfair_lock_opaque;
                *(_DWORD *)v123 = 136447234;
                *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
                v124 = 1024;
                *(_DWORD *)v125 = v36;
                *(_WORD *)&v125[4] = 1040;
                *(_DWORD *)&v125[6] = a8;
                *(_WORD *)&v125[10] = 2080;
                *(_QWORD *)&v125[12] = a9;
                v126 = 2080;
                v127 = key;
                _os_log_impl(&dword_182FBE000, v35, OS_LOG_TYPE_ERROR, "%{public}s [B%u] txt: failed to remove %.*s from %s", v123, 0x2Cu);
              }

              v25 = v105;
            }
            nw_dictionary_set_value(*(_QWORD *)&v25[42]._os_unfair_lock_opaque, key, v24);
            if (!v24 || v24[3].isa == v24[2].isa)
              v37 = 0;
            else
              v37 = v24;

            _Block_object_dispose(type, 8);
            v18 = (uint64_t)v37;
LABEL_52:

LABEL_53:
            if (v18)
            {
              v38 = *(_QWORD *)(v18 + 24) - *(_QWORD *)(v18 + 16);
              if (v38 >= 9)
              {
                os_unfair_lock_unlock(v16 + 2);
LABEL_172:

                goto LABEL_22;
              }
              v39 = v105;
              if (v38 == 8)
              {
                nw_array_get_object_at_index(v18, 0);
                v40 = objc_claimAutoreleasedReturnValue();
              }
              else
              {
                v40 = 0;
              }
LABEL_117:
              if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v39[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v65 = (id)gbrowserLogObj;
                if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
                {
                  if (v18)
                    v66 = (uint64_t)(*(_QWORD *)(v18 + 24) - *(_QWORD *)(v18 + 16)) >> 3;
                  else
                    v66 = 0;
                  v67 = v39[48]._os_unfair_lock_opaque;
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v67;
                  *(_WORD *)&buf[18] = 2080;
                  *(_QWORD *)&buf[20] = key;
                  *(_WORD *)&buf[28] = 2048;
                  *(_QWORD *)&buf[30] = v66;
                  _os_log_impl(&dword_182FBE000, v65, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: %s has count of %zu in txt_array,", buf, 0x26u);
                }

                v39 = v105;
              }
              v68 = nw_browser_copy_old_result_locked((NWConcrete_nw_browser *)v39, key);
              v69 = v68;
              if (v68)
              {
                v70 = (id *)v68;
                left = v70[3];

                v39 = v105;
              }
              else
              {
                left = 0;
              }
              uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)&v16[40]._os_unfair_lock_opaque, key);
              if ((uint64 & 4) != 0 || nw_txt_record_is_equal(left, v40))
                goto LABEL_161;
              v102 = nw_browser_copy_result_to_modify_locked((NWConcrete_nw_browser *)v39, key, uint64);
              if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v39[10]._os_unfair_lock_opaque))
              {
                if (__nwlog_browser_log::onceToken[0] != -1)
                  dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                v72 = (id)gbrowserLogObj;
                if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
                {
                  v73 = left;
                  if (left)
                  {
                    isa = (int)left[2].isa;
                    v73 = left[1].isa;
                  }
                  else
                  {
                    isa = 0;
                  }
                  v75 = v39[48]._os_unfair_lock_opaque;
                  if (v40)
                  {
                    v77 = v40[1].isa;
                    v76 = v40[2].isa;
                  }
                  else
                  {
                    LODWORD(v76) = 0;
                    v77 = 0;
                  }
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v75;
                  *(_WORD *)&buf[18] = 1040;
                  *(_DWORD *)&buf[20] = isa;
                  *(_WORD *)&buf[24] = 2096;
                  *(_QWORD *)&buf[26] = v73;
                  *(_WORD *)&buf[34] = 1040;
                  *(_DWORD *)&buf[36] = (_DWORD)v76;
                  LOWORD(v118) = 2096;
                  *(_QWORD *)((char *)&v118 + 2) = v77;
                  _os_log_impl(&dword_182FBE000, v72, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: txt record changed from %{network:data}.*P to %{network:data}.*P", buf, 0x32u);
                }

                v39 = v105;
              }
              if (uint64)
              {
                if (v40)
                {
                  if (v40[2].isa == (Class)1)
                    v78 = 0;
                  else
                    v78 = v40;
                }
                else
                {
                  v78 = 0;
                }
                nw_browse_result_set_txt_record_object((void *)v102, v78);
                *(_QWORD *)v123 = 0;
                ValidationData = (const void *)DNSServiceGetValidationData();
                if (ValidationData && *(_QWORD *)v123)
                {
                  endpoint = nw_browse_result_get_endpoint((void *)v102);
                  v81 = endpoint;
                  if (endpoint)
                    nw_endpoint_set_signature(endpoint, ValidationData, *(size_t *)v123);

                }
                v82 = uint64 | 0x20;
                xpc_dictionary_set_uint64(*(xpc_object_t *)&v16[40]._os_unfair_lock_opaque, key, v82);
                if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v105[10]._os_unfair_lock_opaque))
                {
                  if (__nwlog_browser_log::onceToken[0] != -1)
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                  v83 = (id)gbrowserLogObj;
                  if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
                  {
                    v84 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v84;
                    *(_WORD *)&buf[18] = 2080;
                    *(_QWORD *)&buf[20] = key;
                    *(_WORD *)&buf[28] = 2048;
                    *(_QWORD *)&buf[30] = v82;
                    _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] changes_map: %s |= txt_record_changed(%llu)", buf, 0x26u);
                  }

                }
                v39 = v105;
LABEL_161:
                if ((v104 & 1) == 0 && (!v18 || *(_QWORD *)(v18 + 24) - *(_QWORD *)(v18 + 16) <= 0xFuLL))
                {
                  nw_browser_notify_browse_result_changes_locked((NWConcrete_nw_browser *)v39);
                  if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v39[10]._os_unfair_lock_opaque))
                  {
                    if (__nwlog_browser_log::onceToken[0] != -1)
                      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                    v85 = (id)gbrowserLogObj;
                    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
                    {
                      v86 = v39[48]._os_unfair_lock_opaque;
                      *(_DWORD *)buf = 136446722;
                      *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v86;
                      *(_WORD *)&buf[18] = 2080;
                      *(_QWORD *)&buf[20] = key;
                      _os_log_impl(&dword_182FBE000, v85, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: notify txt record change for %s", buf, 0x1Cu);
                    }

                  }
                }
                os_unfair_lock_unlock(v16 + 2);
                goto LABEL_171;
              }
              if (nw_parameters_get_logging_disabled(*(_QWORD *)&v39[10]._os_unfair_lock_opaque))
              {
LABEL_202:
                os_unfair_lock_unlock(v16 + 2);

LABEL_171:
                goto LABEL_172;
              }
              if (__nwlog_browser_log::onceToken[0] != -1)
                dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
              v87 = (id)gbrowserLogObj;
              v88 = v105[48]._os_unfair_lock_opaque;
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v88;
              v89 = (char *)_os_log_send_and_compose_impl();

              v123[0] = 16;
              LOBYTE(v111[0]) = 0;
              if (__nwlog_fault(v89, v123, v111))
              {
                if (v123[0] == 17)
                {
                  if (__nwlog_browser_log::onceToken[0] != -1)
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                  v90 = (id)gbrowserLogObj;
                  v91 = v123[0];
                  if (os_log_type_enabled(v90, (os_log_type_t)v123[0]))
                  {
                    v92 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v92;
                    _os_log_impl(&dword_182FBE000, v90, v91, "%{public}s [B%u] change should not be invalid", buf, 0x12u);
                  }
                }
                else if (LOBYTE(v111[0]))
                {
                  backtrace_string = __nw_create_backtrace_string();
                  if (backtrace_string)
                  {
                    v94 = (char *)backtrace_string;
                    if (__nwlog_browser_log::onceToken[0] != -1)
                      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                    v95 = (id)gbrowserLogObj;
                    v96 = v123[0];
                    if (os_log_type_enabled(v95, (os_log_type_t)v123[0]))
                    {
                      v97 = v105[48]._os_unfair_lock_opaque;
                      *(_DWORD *)buf = 136446722;
                      *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v97;
                      *(_WORD *)&buf[18] = 2082;
                      *(_QWORD *)&buf[20] = v94;
                      _os_log_impl(&dword_182FBE000, v95, v96, "%{public}s [B%u] change should not be invalid, dumping backtrace:%{public}s", buf, 0x1Cu);
                    }

                    free(v94);
                    goto LABEL_200;
                  }
                  if (__nwlog_browser_log::onceToken[0] != -1)
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                  v90 = (id)gbrowserLogObj;
                  v100 = v123[0];
                  if (os_log_type_enabled(v90, (os_log_type_t)v123[0]))
                  {
                    v101 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v101;
                    _os_log_impl(&dword_182FBE000, v90, v100, "%{public}s [B%u] change should not be invalid, no backtrace", buf, 0x12u);
                  }
                }
                else
                {
                  if (__nwlog_browser_log::onceToken[0] != -1)
                    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
                  v90 = (id)gbrowserLogObj;
                  v98 = v123[0];
                  if (os_log_type_enabled(v90, (os_log_type_t)v123[0]))
                  {
                    v99 = v105[48]._os_unfair_lock_opaque;
                    *(_DWORD *)buf = 136446466;
                    *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v99;
                    _os_log_impl(&dword_182FBE000, v90, v98, "%{public}s [B%u] change should not be invalid, backtrace limit exceeded", buf, 0x12u);
                  }
                }

              }
LABEL_200:
              if (v89)
                free(v89);
              goto LABEL_202;
            }
LABEL_116:
            v40 = 0;
            v39 = v105;
            goto LABEL_117;
          }
          __nwlog_obj();
          v57 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)v123 = 136446210;
          *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
          v58 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v110 = 0;
          if (__nwlog_fault(v58, type, &v110))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              v59 = objc_claimAutoreleasedReturnValue();
              v60 = type[0];
              if (os_log_type_enabled(v59, type[0]))
              {
                *(_DWORD *)v123 = 136446210;
                *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
                _os_log_impl(&dword_182FBE000, v59, v60, "%{public}s txt: got remove event for non-existent txt_array", v123, 0xCu);
              }
            }
            else if (v110)
            {
              v61 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v59 = objc_claimAutoreleasedReturnValue();
              v62 = type[0];
              v63 = os_log_type_enabled(v59, type[0]);
              if (v61)
              {
                if (v63)
                {
                  *(_DWORD *)v123 = 136446466;
                  *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
                  v124 = 2082;
                  *(_QWORD *)v125 = v61;
                  _os_log_impl(&dword_182FBE000, v59, v62, "%{public}s txt: got remove event for non-existent txt_array, dumping backtrace:%{public}s", v123, 0x16u);
                }

                free(v61);
                goto LABEL_113;
              }
              if (v63)
              {
                *(_DWORD *)v123 = 136446210;
                *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
                _os_log_impl(&dword_182FBE000, v59, v62, "%{public}s txt: got remove event for non-existent txt_array, no backtrace", v123, 0xCu);
              }
            }
            else
            {
              __nwlog_obj();
              v59 = objc_claimAutoreleasedReturnValue();
              v64 = type[0];
              if (os_log_type_enabled(v59, type[0]))
              {
                *(_DWORD *)v123 = 136446210;
                *(_QWORD *)&v123[4] = "nw_browser_copy_txt_array_locked";
                _os_log_impl(&dword_182FBE000, v59, v64, "%{public}s txt: got remove event for non-existent txt_array, backtrace limit exceeded", v123, 0xCu);
              }
            }

          }
LABEL_113:
          if (v58)
            free(v58);

          v18 = 0;
          goto LABEL_116;
        }
        if (!nw_parameters_get_logging_disabled(*(_QWORD *)&v16[10]._os_unfair_lock_opaque))
        {
          if (__nwlog_browser_log::onceToken[0] != -1)
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
          v28 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            v29 = v16[48]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_browser_dns_service_query_record_callback";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v29;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = a5;
            _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_ERROR, "%{public}s [B%u] txt: a TXT record was delivered for an unknown %s", buf, 0x1Cu);
          }

        }
      }
      os_unfair_lock_unlock(v16 + 2);
LABEL_22:

      return;
    }
    __nwlog_obj();
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)key = 136446210;
    v114 = "nw_browser_dns_service_query_record_callback";
    v46 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v123[0] = 0;
    if (__nwlog_fault(v46, buf, v123))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        v47 = objc_claimAutoreleasedReturnValue();
        v48 = buf[0];
        if (os_log_type_enabled(v47, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)key = 136446210;
          v114 = "nw_browser_dns_service_query_record_callback";
          _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null browser", (uint8_t *)key, 0xCu);
        }
      }
      else if (v123[0])
      {
        v52 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v47 = objc_claimAutoreleasedReturnValue();
        v53 = buf[0];
        v54 = os_log_type_enabled(v47, (os_log_type_t)buf[0]);
        if (v52)
        {
          if (v54)
          {
            *(_DWORD *)key = 136446466;
            v114 = "nw_browser_dns_service_query_record_callback";
            v115 = 2082;
            v116 = v52;
            _os_log_impl(&dword_182FBE000, v47, v53, "%{public}s called with null browser, dumping backtrace:%{public}s", (uint8_t *)key, 0x16u);
          }

          free(v52);
          goto LABEL_93;
        }
        if (v54)
        {
          *(_DWORD *)key = 136446210;
          v114 = "nw_browser_dns_service_query_record_callback";
          _os_log_impl(&dword_182FBE000, v47, v53, "%{public}s called with null browser, no backtrace", (uint8_t *)key, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v47 = objc_claimAutoreleasedReturnValue();
        v56 = buf[0];
        if (os_log_type_enabled(v47, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)key = 136446210;
          v114 = "nw_browser_dns_service_query_record_callback";
          _os_log_impl(&dword_182FBE000, v47, v56, "%{public}s called with null browser, backtrace limit exceeded", (uint8_t *)key, 0xCu);
        }
      }

    }
LABEL_93:
    if (v46)
      free(v46);
    goto LABEL_22;
  }
  __nwlog_obj();
  v41 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)key = 136446210;
  v114 = "nw_browser_dns_service_query_record_callback";
  v42 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  v123[0] = 0;
  if (__nwlog_fault(v42, buf, v123))
  {
    if (buf[0] == 17)
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v44 = buf[0];
      if (os_log_type_enabled(v43, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)key = 136446210;
        v114 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s called with null dns_service", (uint8_t *)key, 0xCu);
      }
    }
    else if (v123[0])
    {
      v49 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v50 = buf[0];
      v51 = os_log_type_enabled(v43, (os_log_type_t)buf[0]);
      if (v49)
      {
        if (v51)
        {
          *(_DWORD *)key = 136446466;
          v114 = "nw_browser_dns_service_query_record_callback";
          v115 = 2082;
          v116 = v49;
          _os_log_impl(&dword_182FBE000, v43, v50, "%{public}s called with null dns_service, dumping backtrace:%{public}s", (uint8_t *)key, 0x16u);
        }

        free(v49);
        goto LABEL_88;
      }
      if (v51)
      {
        *(_DWORD *)key = 136446210;
        v114 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl(&dword_182FBE000, v43, v50, "%{public}s called with null dns_service, no backtrace", (uint8_t *)key, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v55 = buf[0];
      if (os_log_type_enabled(v43, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)key = 136446210;
        v114 = "nw_browser_dns_service_query_record_callback";
        _os_log_impl(&dword_182FBE000, v43, v55, "%{public}s called with null dns_service, backtrace limit exceeded", (uint8_t *)key, 0xCu);
      }
    }

  }
LABEL_88:
  if (v42)
    free(v42);
}

void sub_183902E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

BOOL ___ZL32nw_browser_copy_txt_array_lockedP21NWConcrete_nw_browserPKcPKvtj_block_invoke(uint64_t a1, int a2, nw_txt_record_t right)
{
  return !nw_txt_record_is_equal(*(nw_txt_record_t *)(a1 + 32), right);
}

uint64_t ___ZL32nw_browser_copy_txt_array_lockedP21NWConcrete_nw_browserPKcPKvtj_block_invoke_127(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  NSObject *v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24)
    || !nw_txt_record_is_equal(*(nw_txt_record_t *)(a1 + 32), v4))
  {
    nw_array_append(*(_QWORD *)(a1 + 40), v4);
  }
  else
  {
    if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 40)))
    {
      if (__nwlog_browser_log::onceToken[0] != -1)
        dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
      v5 = (id)gbrowserLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        v6 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 192);
        v7 = *(unsigned __int16 *)(a1 + 80);
        v8 = *(_QWORD *)(a1 + 64);
        v9 = *(_QWORD *)(a1 + 72);
        v11 = 136447234;
        v12 = "nw_browser_copy_txt_array_locked_block_invoke";
        v13 = 1024;
        v14 = v6;
        v15 = 1040;
        v16 = v7;
        v17 = 2080;
        v18 = v8;
        v19 = 2080;
        v20 = v9;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] txt: remove %.*s from %s", (uint8_t *)&v11, 0x2Cu);
      }

    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
  }

  return 1;
}

void sub_183903048(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_browser_cancel_dns_browser_locked(NWConcrete_nw_browser *a1)
{
  NWConcrete_nw_browser *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  id v6;
  _QWORD v7[4];
  NWConcrete_nw_browser *v8;
  uint64_t v9;

  v1 = a1;
  v2 = (void *)*((_QWORD *)v1 + 19);
  *((_QWORD *)v1 + 19) = 0;

  v3 = (void *)*((_QWORD *)v1 + 21);
  *((_QWORD *)v1 + 21) = 0;

  v4 = (void *)*((_QWORD *)v1 + 20);
  *((_QWORD *)v1 + 20) = 0;

  v5 = *((_QWORD *)v1 + 15);
  if (v5)
  {
    *((_QWORD *)v1 + 15) = 0;
    *((_QWORD *)v1 + 16) = 0;
    v6 = nw_parameters_copy_context(*((void **)v1 + 5));
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZL36nw_browser_cancel_dns_browser_lockedP21NWConcrete_nw_browser_block_invoke;
    v7[3] = &unk_1E14AA348;
    v9 = v5;
    v8 = v1;
    nw_queue_context_async(v6, v7);

  }
}

void sub_183903128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void ___ZL36nw_browser_cancel_dns_browser_lockedP21NWConcrete_nw_browser_block_invoke(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  DNSServiceRefDeallocate(*(DNSServiceRef *)(a1 + 40));
  if (!nw_parameters_get_logging_disabled(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40)))
  {
    if (__nwlog_browser_log::onceToken[0] != -1)
      dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
    v2 = (id)gbrowserLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      v3 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 192);
      v4 = 136446466;
      v5 = "nw_browser_cancel_dns_browser_locked_block_invoke";
      v6 = 1024;
      v7 = v3;
      _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEBUG, "%{public}s [B%u] deallocate primary DNS ref", (uint8_t *)&v4, 0x12u);
    }

  }
}

void ___ZL38nw_browser_start_custom_browser_lockedP21NWConcrete_nw_browser_block_invoke_2(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 8));
}

void nw_browser_cancel(nw_browser_t browser)
{
  nw_browser_t v1;
  nw_browser_t v2;
  NSObject *v3;
  int isa;
  NSObject *v5;
  NSObject *v6;
  int v7;
  Class v8;
  Class v9;
  Class v10;
  Class v11;
  Class v12;
  Class v13;
  Class v14;
  Class v15;
  Class v16;
  Class v17;
  Class v18;
  void *v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  char *backtrace_string;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  char *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v1 = browser;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v1[1]);
    if (LODWORD(v2[9].isa) == 3)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&v2[1]);
      if (!nw_parameters_get_logging_disabled((uint64_t)v2[5].isa))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v3 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          isa = (int)v2[24].isa;
          *(_DWORD *)buf = 136446466;
          v30 = "nw_browser_cancel";
          v31 = 1024;
          LODWORD(v32) = isa;
          _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_ERROR, "%{public}s [B%u] The browser has already been cancelled, ignoring nw_browser_cancel().", buf, 0x12u);
        }

      }
    }
    else
    {
      v5 = v2;
      if (!nw_parameters_get_logging_disabled((uint64_t)v2[5].isa))
      {
        if (__nwlog_browser_log::onceToken[0] != -1)
          dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44175);
        v6 = (id)gbrowserLogObj;
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          v7 = (int)v5[24].isa;
          *(_DWORD *)buf = 136446466;
          v30 = "nw_browser_cancel_path_browser_locked";
          v31 = 1024;
          LODWORD(v32) = v7;
          _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] path: cancel browse", buf, 0x12u);
        }

      }
      v8 = v5[12].isa;
      v5[12].isa = 0;

      v9 = v5[13].isa;
      v5[13].isa = 0;

      v10 = v5[11].isa;
      if (v10)
      {
        nw_path_evaluator_cancel(v10);
        v11 = v5[11].isa;
        v5[11].isa = 0;

      }
      nw_browser_cancel_dns_browser_locked((NWConcrete_nw_browser *)v5);
      v12 = v5[17].isa;
      v5[17].isa = 0;

      v13 = v5[18].isa;
      v5[18].isa = 0;

      v14 = v5[14].isa;
      v5[14].isa = 0;

      nw_browser_set_state_locked(v5, 3, 0);
      v15 = v5[7].isa;
      v5[7].isa = 0;

      v16 = v5[8].isa;
      v5[8].isa = 0;

      v17 = v5[2].isa;
      v5[2].isa = 0;

      v18 = v5[6].isa;
      v5[6].isa = 0;

      os_unfair_lock_unlock((os_unfair_lock_t)&v2[1]);
    }
    goto LABEL_18;
  }
  __nwlog_obj();
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_browser_cancel";
  v20 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (__nwlog_fault(v20, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_browser_cancel";
        _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v24 = type;
      v25 = os_log_type_enabled(v21, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_browser_cancel";
          v31 = 2082;
          v32 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_browser_cancel";
        _os_log_impl(&dword_182FBE000, v21, v24, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v21 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        v30 = "nw_browser_cancel";
        _os_log_impl(&dword_182FBE000, v21, v26, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_35:
  if (v20)
    free(v20);
LABEL_18:

}

void sub_18390370C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

nw_parameters_t nw_browser_copy_parameters(nw_browser_t browser)
{
  nw_browser_t v1;
  nw_browser_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = browser;
  v2 = v1;
  if (v1)
  {
    v3 = v1[5].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browser_copy_parameters";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browser_copy_parameters";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_parameters";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

nw_browse_descriptor_t nw_browser_copy_browse_descriptor(nw_browser_t browser)
{
  nw_browser_t v1;
  nw_browser_t v2;
  NSObject *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = browser;
  v2 = v1;
  if (v1)
  {
    v3 = v1[4].isa;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browser_copy_browse_descriptor";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_browse_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browser_copy_browse_descriptor";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_browse_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_browse_descriptor";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

id nw_browser_copy_browse_results(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    v3 = *(id *)&v2[34]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_browser_copy_browse_results";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_browse_results";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_browser_copy_browse_results";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_browse_results";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_browser_copy_browse_results";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_browser_get_state(void *a1, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  void (**v5)(_QWORD);
  uint64_t v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _QWORD aBlock[4];
  os_unfair_lock_s *v17;
  _BYTE *v18;
  uint64_t v19;
  char v20;
  os_log_type_t type;
  _BYTE buf[24];
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v23 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_browser_get_state_block_invoke;
    aBlock[3] = &unk_1E14AAE00;
    v18 = buf;
    v17 = v3;
    v19 = a2;
    v5 = (void (**)(_QWORD))_Block_copy(aBlock);
    os_unfair_lock_lock(v4 + 2);
    v5[2](v5);
    os_unfair_lock_unlock(v4 + 2);

    v6 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_browser_get_state";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v20 = 0;
  if (__nwlog_fault(v9, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browser_get_state";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null browser", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_browser_get_state";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null browser, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browser_get_state";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null browser, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_browser_get_state";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null browser, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v9)
    free(v9);
  v6 = 0;
LABEL_3:

  return v6;
}

void sub_18390424C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_browser_get_state_block_invoke(uint64_t a1)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 72);
  if (*(_QWORD *)(a1 + 48))
    objc_storeStrong(*(id **)(a1 + 48), *(id *)(*(_QWORD *)(a1 + 32) + 80));
}

nw_txt_record_t nw_txt_record_create_with_bytes(const uint8_t *txt_bytes, size_t txt_len)
{
  const uint8_t *v3;
  NWConcrete_nw_txt_record *v4;
  void *v5;
  BOOL v6;
  id v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  size_t v11;
  NWConcrete_nw_txt_record *v12;
  char *v13;
  os_log_type_t v14;
  _BOOL4 v15;
  const uint8_t *v16;
  unint64_t v17;
  const uint8_t *v18;
  const uint8_t *v19;
  const uint8_t *v20;
  const uint8_t *v21;
  const uint8_t *v22;
  os_log_type_t v23;
  nw_txt_record_t result;
  void *v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  void *v29;
  os_log_type_t v30;
  void *v31;
  os_log_type_t v32;
  NSObject *v33;
  void *v34;
  char *backtrace_string;
  os_log_type_t v36;
  _BOOL4 v37;
  os_log_type_t v38;
  _BOOL4 v39;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  os_log_type_t v43;
  os_log_type_t v44;
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  size_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!txt_bytes)
  {
    __nwlog_obj();
    v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_txt_record_create_with_bytes";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v26, &type, &v45))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null (txt_bytes != __null)", buf, 0xCu);
      }
      goto LABEL_93;
    }
    if (!v45)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v42 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_182FBE000, v27, v42, "%{public}s called with null (txt_bytes != __null), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_93;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    v36 = type;
    v37 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_182FBE000, v27, v36, "%{public}s called with null (txt_bytes != __null), no backtrace", buf, 0xCu);
      }
      goto LABEL_93;
    }
    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      v48 = "nw_txt_record_create_with_bytes";
      v49 = 2082;
      v50 = (size_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v27, v36, "%{public}s called with null (txt_bytes != __null), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_75:

    free(backtrace_string);
    goto LABEL_94;
  }
  if (!txt_len)
  {
    __nwlog_obj();
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_txt_record_create_with_bytes";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v26, &type, &v45))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v30 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_182FBE000, v27, v30, "%{public}s txt_record cannot have length 0", buf, 0xCu);
      }
      goto LABEL_93;
    }
    if (!v45)
    {
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_182FBE000, v27, v43, "%{public}s txt_record cannot have length 0, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_93;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v27 = objc_claimAutoreleasedReturnValue();
    v38 = type;
    v39 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        v48 = "nw_txt_record_create_with_bytes";
        _os_log_impl(&dword_182FBE000, v27, v38, "%{public}s txt_record cannot have length 0, no backtrace", buf, 0xCu);
      }
      goto LABEL_93;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      v48 = "nw_txt_record_create_with_bytes";
      v49 = 2082;
      v50 = (size_t)backtrace_string;
      _os_log_impl(&dword_182FBE000, v27, v38, "%{public}s txt_record cannot have length 0, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_75;
  }
  if (txt_len >= 0x10000)
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_txt_record_create_with_bytes";
    v26 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v26, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl(&dword_182FBE000, v27, v32, "%{public}s txt_record cannot have length > 65535", buf, 0xCu);
        }
LABEL_93:

        goto LABEL_94;
      }
      if (!v45)
      {
        __nwlog_obj();
        v27 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl(&dword_182FBE000, v27, v44, "%{public}s txt_record cannot have length > 65535, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_93;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v27 = objc_claimAutoreleasedReturnValue();
      v40 = type;
      v41 = os_log_type_enabled(v27, type);
      if (!backtrace_string)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl(&dword_182FBE000, v27, v40, "%{public}s txt_record cannot have length > 65535, no backtrace", buf, 0xCu);
        }
        goto LABEL_93;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        v48 = "nw_txt_record_create_with_bytes";
        v49 = 2082;
        v50 = (size_t)backtrace_string;
        _os_log_impl(&dword_182FBE000, v27, v40, "%{public}s txt_record cannot have length > 65535, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_75;
    }
LABEL_94:
    if (v26)
      free(v26);
    return 0;
  }
  v3 = txt_bytes;
  v4 = objc_alloc_init(NWConcrete_nw_txt_record);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v48 = "nw_txt_record_create_with_bytes";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (__nwlog_fault(v8, &type, &v45))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s [nw_txt_record init] failed", buf, 0xCu);
        }
      }
      else if (v45)
      {
        v13 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v14 = type;
        v15 = os_log_type_enabled(v9, type);
        if (v13)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v48 = "nw_txt_record_create_with_bytes";
            v49 = 2082;
            v50 = (size_t)v13;
            _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s [nw_txt_record init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v13);
          if (!v8)
            goto LABEL_42;
          goto LABEL_41;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s [nw_txt_record init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        v23 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v48 = "nw_txt_record_create_with_bytes";
          _os_log_impl(&dword_182FBE000, v9, v23, "%{public}s [nw_txt_record init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
    if (!v8)
    {
LABEL_42:

      return (nw_txt_record_t)v4;
    }
LABEL_41:
    free(v8);
    goto LABEL_42;
  }
  v5 = malloc_type_malloc(txt_len, 0xF2B69DE5uLL);
  if (v5)
  {
LABEL_6:
    *((_QWORD *)v4 + 1) = v5;
    memcpy(v5, v3, txt_len);
    if (txt_len - 8901 >= 0xFFFFFFFFFFFFDD3CLL)
    {
      v11 = *v3;
      if (txt_len == 1 && !*v3 || v11 + 1 == txt_len)
      {
        v6 = 1;
      }
      else
      {
        v16 = &v3[txt_len];
        v17 = (unint64_t)&v3[v11 + 1];
        do
        {
          v6 = v17 <= (unint64_t)v16;
          if (v17 > (unint64_t)v16)
            break;
          v18 = v3;
          v3 = (const uint8_t *)v17;
          v19 = v18 + 1;
          v20 = (const uint8_t *)memchr((void *)(v18 + 1), 61, v11);
          v21 = &v18[v11];
          if (v20)
            v21 = v20;
          if (v19 < v21)
          {
            v22 = &v21[~(unint64_t)v18];
            while (*v19 - 127 > 0xFFFFFFA0)
            {
              ++v19;
              if (!--v22)
                goto LABEL_25;
            }
            goto LABEL_7;
          }
LABEL_25:
          v11 = *v3;
          v17 = (unint64_t)&v3[v11 + 1];
          v6 = 1;
        }
        while ((const uint8_t *)v17 != v16);
      }
    }
    else
    {
LABEL_7:
      v6 = 0;
    }
    *((_BYTE *)v4 + 36) = *((_BYTE *)v4 + 36) & 0xFE | v6;
    *((_QWORD *)v4 + 2) = txt_len;
    *((_QWORD *)v4 + 3) = txt_len;
    v12 = v4;
    goto LABEL_42;
  }
  __nwlog_obj();
  v33 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v48 = "strict_malloc";
  v49 = 2048;
  v50 = txt_len;
  v34 = (void *)_os_log_send_and_compose_impl();

  result = (nw_txt_record_t)__nwlog_abort((uint64_t)v34);
  if (!(_DWORD)result)
  {
    free(v34);
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

void sub_183905308(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_txt_record_conforms_to_rfc_1464(_BYTE *a1, uint64_t a2)
{
  _BOOL8 result;
  size_t v4;
  _BYTE *v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  char *v11;

  result = 0;
  if (a1 && (unint64_t)(a2 - 8901) >= 0xFFFFFFFFFFFFDD3CLL)
  {
    v4 = *a1;
    if (a2 == 1 && !*a1 || v4 + 1 == a2)
    {
      return 1;
    }
    else
    {
      v5 = &a1[a2];
      v6 = (unint64_t)&a1[v4 + 1];
      do
      {
        result = v6 <= (unint64_t)v5;
        if (v6 > (unint64_t)v5)
          break;
        v7 = (unint64_t)a1;
        a1 = (_BYTE *)v6;
        v8 = (unsigned __int8 *)(v7 + 1);
        v9 = (unsigned __int8 *)memchr((void *)(v7 + 1), 61, v4);
        v10 = (unsigned __int8 *)(v7 + v4);
        if (v9)
          v10 = v9;
        if (v8 < v10)
        {
          v11 = (char *)&v10[~v7];
          while (*v8 - 127 > 0xFFFFFFA0)
          {
            ++v8;
            if (!--v11)
              goto LABEL_8;
          }
          return 0;
        }
LABEL_8:
        v4 = *a1;
        v6 = (unint64_t)&a1[v4 + 1];
        result = 1;
      }
      while ((_BYTE *)v6 != v5);
    }
  }
  return result;
}

BOOL nw_txt_record_is_dictionary(nw_txt_record_t txt_record)
{
  nw_txt_record_t v1;
  nw_txt_record_t v2;
  BOOL v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = txt_record;
  v2 = v1;
  if (v1)
  {
    v3 = BYTE4(v1[4].isa) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_txt_record_is_dictionary";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_txt_record_is_dictionary";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null txt_record", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_txt_record_is_dictionary";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_txt_record_is_dictionary";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_txt_record_is_dictionary";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

nw_txt_record_find_key_t nw_txt_record_find_key(nw_txt_record_t txt_record, const char *key)
{
  nw_txt_record_t v3;
  os_unfair_lock_s *v4;
  nw_txt_record_find_key_t start_of_key_locked;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  NSObject *v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = txt_record;
  v4 = (os_unfair_lock_s *)v3;
  if (!v3)
  {
    __nwlog_obj();
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_txt_record_find_key";
    v8 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_txt_record_find_key";
          _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null txt_record", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        v14 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_txt_record_find_key";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v9, v13, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_txt_record_find_key";
          _os_log_impl(&dword_182FBE000, v9, v13, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v9 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v19 = "nw_txt_record_find_key";
          _os_log_impl(&dword_182FBE000, v9, v15, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_28:
    if (v8)
      free(v8);
    goto LABEL_30;
  }
  if ((BYTE4(v3[4].isa) & 1) == 0)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v19 = "nw_txt_record_find_key";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }
    goto LABEL_13;
  }
  if ((nw_txt_record_key_is_valid((uint64_t)key) & 1) == 0)
  {
    __nwlog_obj();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v19 = "nw_txt_record_find_key";
      _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_ERROR, "%{public}s invalid key", buf, 0xCu);
    }
LABEL_13:

LABEL_30:
    start_of_key_locked = nw_txt_record_find_key_invalid;
    goto LABEL_5;
  }
  os_unfair_lock_lock(v4 + 8);
  start_of_key_locked = nw_txt_record_find_start_of_key_locked(v4, key, 0, 0, 0, 0);
  os_unfair_lock_unlock(v4 + 8);
LABEL_5:

  return start_of_key_locked;
}

void sub_183905A3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_txt_record_access_key(nw_txt_record_t txt_record, const char *key, nw_txt_record_access_key_t access_value)
{
  nw_txt_record_t v5;
  nw_txt_record_access_key_t v6;
  uint64_t (**v7)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t start_of_key_locked;
  char v9;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  void *v15;
  os_log_type_t v16;
  NSObject *v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  os_log_type_t v23;
  os_log_type_t v24;
  os_log_type_t type[15];
  char v26;
  _BYTE buf[12];
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = txt_record;
  v6 = access_value;
  v7 = (uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v6;
  if (!v5)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
    v12 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v12, type, &v26))
      goto LABEL_45;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s called with null txt_record", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (!v26)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v23 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_182FBE000, v13, v23, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v19 = type[0];
    v20 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
      v28 = 2082;
      v29 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_32;
  }
  if (!v6)
  {
    __nwlog_obj();
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
    v12 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v26 = 0;
    if (!__nwlog_fault(v12, type, &v26))
      goto LABEL_45;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v16 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_182FBE000, v13, v16, "%{public}s called with null access_value", buf, 0xCu);
      }
LABEL_44:

LABEL_45:
      if (v12)
        free(v12);
      goto LABEL_47;
    }
    if (!v26)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v24 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_182FBE000, v13, v24, "%{public}s called with null access_value, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v13 = objc_claimAutoreleasedReturnValue();
    v21 = type[0];
    v22 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
        _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null access_value, no backtrace", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
      v28 = 2082;
      v29 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v13, v21, "%{public}s called with null access_value, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_32:

    free(backtrace_string);
    goto LABEL_45;
  }
  if ((BYTE4(v5[4].isa) & 1) == 0)
  {
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }
    goto LABEL_19;
  }
  if ((nw_txt_record_key_is_valid((uint64_t)key) & 1) == 0)
  {
    __nwlog_obj();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_txt_record_access_key";
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_ERROR, "%{public}s invalid key", buf, 0xCu);
    }
LABEL_19:

LABEL_47:
    v9 = 0;
    goto LABEL_6;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)type = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&v5[4]);
  start_of_key_locked = nw_txt_record_find_start_of_key_locked(v5, key, 0, 0, buf, type);
  v9 = ((uint64_t (**)(_QWORD, const char *, uint64_t, _QWORD, _QWORD))v7)[2](v7, key, start_of_key_locked, *(_QWORD *)buf, *(_QWORD *)type);
  os_unfair_lock_unlock((os_unfair_lock_t)&v5[4]);
LABEL_6:

  return v9;
}

void sub_18390601C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_txt_record_remove_key(nw_txt_record_t txt_record, const char *key)
{
  nw_txt_record_t v3;
  nw_txt_record_t v4;
  BOOL v5;
  int start_of_key_locked;
  uint64_t v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  _BYTE __dst[12];
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = txt_record;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__dst = 136446210;
    *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v11, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)__dst = 136446210;
          *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null txt_record", __dst, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        v17 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)__dst = 136446466;
            *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s called with null txt_record, dumping backtrace:%{public}s", __dst, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }
        if (v17)
        {
          *(_DWORD *)__dst = 136446210;
          *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key";
          _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s called with null txt_record, no backtrace", __dst, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)__dst = 136446210;
          *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key";
          _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s called with null txt_record, backtrace limit exceeded", __dst, 0xCu);
        }
      }

    }
LABEL_33:
    if (v11)
      free(v11);
    goto LABEL_35;
  }
  if ((BYTE4(v3[4].isa) & 1) == 0)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__dst = 136446210;
      *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key";
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", __dst, 0xCu);
    }
    goto LABEL_18;
  }
  if ((nw_txt_record_key_is_valid((uint64_t)key) & 1) == 0)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__dst = 136446210;
      *(_QWORD *)&__dst[4] = "nw_txt_record_remove_key";
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s invalid key", __dst, 0xCu);
    }
LABEL_18:

LABEL_35:
    v5 = 0;
    goto LABEL_10;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&v4[4]);
  if (v4[2].isa == (Class)1)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&v4[4]);
    v5 = 0;
  }
  else
  {
    *(_QWORD *)__dst = 0;
    start_of_key_locked = nw_txt_record_find_start_of_key_locked(v4, key, __dst, 0, 0, 0);
    v5 = start_of_key_locked != 1;
    if (start_of_key_locked != 1)
    {
      v7 = **(_BYTE **)__dst + 1;
      memmove(*(void **)__dst, (const void *)(*(_QWORD *)__dst + v7), (size_t)v4[1].isa + (unint64_t)v4[2].isa - *(_QWORD *)__dst - v7);
      v8 = (uint64_t)v4[2].isa - v7;
      v4[2].isa = (Class)v8;
      if (!v8)
      {
        *(_BYTE *)v4[1].isa = 0;
        v4[2].isa = (Class)1;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&v4[4]);
  }
LABEL_10:

  return v5;
}

void sub_183906434(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

size_t nw_txt_record_get_key_count(nw_txt_record_t txt_record)
{
  nw_txt_record_t v1;
  nw_txt_record_t v2;
  uint64_t isa;
  size_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = txt_record;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v20 = "nw_txt_record_get_key_count";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_txt_record_get_key_count";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null txt_record", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v20 = "nw_txt_record_get_key_count";
            v21 = 2082;
            v22 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_txt_record_get_key_count";
          _os_log_impl(&dword_182FBE000, v10, v14, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v20 = "nw_txt_record_get_key_count";
          _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_33:
    if (v9)
      free(v9);
    goto LABEL_5;
  }
  if ((BYTE4(v1[4].isa) & 1) == 0)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v20 = "nw_txt_record_get_key_count";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }

    goto LABEL_5;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&v1[4]);
  isa = (uint64_t)v2[2].isa;
  if (isa == 1)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&v2[4]);
LABEL_5:
    v4 = 0;
    goto LABEL_13;
  }
  if (isa >= 1)
  {
    v4 = 0;
    v5 = (unsigned __int8 *)v2[1].isa;
    v6 = &v5[isa];
    while (1)
    {
      v5 += *v5 + 1;
      if (v5 > v6)
        goto LABEL_5;
      ++v4;
      if (v5 >= v6)
        goto LABEL_12;
    }
  }
  v4 = 0;
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)&v2[4]);
LABEL_13:

  return v4;
}

BOOL nw_txt_record_apply(nw_txt_record_t txt_record, nw_txt_record_applier_t applier)
{
  nw_txt_record_t v3;
  nw_txt_record_applier_t v4;
  void *v5;
  char v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  NSObject *v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = txt_record;
  v4 = applier;
  v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_txt_record_apply";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_txt_record_apply";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null txt_record", buf, 0xCu);
      }
      goto LABEL_40;
    }
    if (!v22)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_txt_record_apply";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v16 = type;
    v17 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_txt_record_apply";
        _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }
      goto LABEL_40;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_txt_record_apply";
      v26 = 2082;
      v27 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v10, v16, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_28;
  }
  if (!v4)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_txt_record_apply";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_41;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_txt_record_apply";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null applier", buf, 0xCu);
      }
LABEL_40:

LABEL_41:
      if (v9)
        free(v9);
      goto LABEL_43;
    }
    if (!v22)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_txt_record_apply";
        _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null applier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    v19 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_txt_record_apply";
        _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null applier, no backtrace", buf, 0xCu);
      }
      goto LABEL_40;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      v25 = "nw_txt_record_apply";
      v26 = 2082;
      v27 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null applier, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_28:

    free(backtrace_string);
    goto LABEL_41;
  }
  if ((BYTE4(v3[4].isa) & 1) == 0)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_txt_record_apply";
      _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s txt_record is not of type dictionary", buf, 0xCu);
    }

LABEL_43:
    v6 = 0;
    goto LABEL_5;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&v3[4]);
  v6 = nw_txt_record_apply_internal_locked(v3, &__block_literal_global_57028, v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
LABEL_5:

  return v6;
}

void sub_183906CD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __nw_txt_record_apply_block_invoke(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  id v13;
  size_t v14;
  uint64_t v15;
  _OWORD v17[16];
  _BYTE __dst[256];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v13 = a8;
  if (a3 <= 0xFF)
    v14 = 256 - a3;
  else
    v14 = 0;
  bzero(&__dst[a3], v14);
  memcpy(__dst, a2, a3);
  __dst[a3] = 0;
  memset(v17, 0, 255);
  if (a5 && (_DWORD)a7 != 2)
    memcpy(v17, a4, a5);
  v15 = (*((uint64_t (**)(id, _BYTE *, uint64_t, _OWORD *, size_t))v13 + 2))(v13, __dst, a7, v17, a5);

  return v15;
}

void sub_183906E10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL __nw_txt_record_is_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  void *v8;
  int v9;
  _BOOL8 v10;
  _QWORD v12[9];
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = __nw_txt_record_is_equal_block_invoke_2;
  v12[3] = &unk_1E14A53E0;
  v13 = a7;
  v12[6] = a2;
  v12[7] = a5;
  v12[8] = a4;
  v12[4] = &v14;
  v12[5] = a3;
  v8 = _Block_copy(v12);
  nw_txt_record_apply_internal_locked(*(void **)(a1 + 32), v8, 0);
  v9 = *((unsigned __int8 *)v15 + 24);
  if (!*((_BYTE *)v15 + 24))
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
  v10 = v9 != 0;

  _Block_object_dispose(&v14, 8);
  return v10;
}

void sub_183906EF0(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  _Block_object_dispose((const void *)(v2 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_txt_record_is_equal_block_invoke_2(uint64_t a1, const char *a2, size_t a3, const void *a4, size_t a5, uint64_t a6, int a7)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 72) != a7
    || *(_QWORD *)(a1 + 40) != a3
    || strncasecmp(*(const char **)(a1 + 48), a2, a3)
    || a7 == 4 && (*(_QWORD *)(a1 + 56) != a5 || memcmp(*(const void **)(a1 + 64), a4, a5)))
  {
    return 1;
  }
  result = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return result;
}

uint64_t nw_txt_record_get_key(void *a1, const char *a2, _QWORD *a3, int *a4)
{
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  int start_of_key_locked;
  uint64_t v10;
  void *v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  void *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  void *v20;
  os_log_type_t v21;
  char *backtrace_string;
  os_log_type_t v23;
  _BOOL4 v24;
  os_log_type_t v25;
  _BOOL4 v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  _BOOL4 v30;
  os_log_type_t v31;
  os_log_type_t v32;
  os_log_type_t v33;
  os_log_type_t v34;
  char v35;
  os_log_type_t type;
  _BYTE buf[12];
  __int16 v38;
  char *v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s called with null txt_record", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (!v35)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v31, "%{public}s called with null txt_record, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_76;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v23 = type;
    v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v23, "%{public}s called with null txt_record, no backtrace", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v23, "%{public}s called with null txt_record, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_49:

    free(backtrace_string);
    goto LABEL_50;
  }
  if ((v7[9]._os_unfair_lock_opaque & 1) == 0)
  {
    __nwlog_obj();
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v17, "%{public}s called with null (txt_record->is_dictionary == true)", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (!v35)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v32, "%{public}s called with null (txt_record->is_dictionary == true), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_76;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v25 = type;
    v26 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v25, "%{public}s called with null (txt_record->is_dictionary == true), no backtrace", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v25, "%{public}s called with null (txt_record->is_dictionary == true), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_49;
  }
  if ((nw_txt_record_key_is_valid((uint64_t)a2) & 1) == 0)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35))
      goto LABEL_50;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v19, "%{public}s called with null nw_txt_record_key_is_valid(key)", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (!v35)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v33, "%{public}s called with null nw_txt_record_key_is_valid(key), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_76;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v27 = type;
    v28 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v27, "%{public}s called with null nw_txt_record_key_is_valid(key), no backtrace", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v27, "%{public}s called with null nw_txt_record_key_is_valid(key), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_49;
  }
  if (a3)
  {
    os_unfair_lock_lock(v8 + 8);
    *(_QWORD *)buf = 0;
    if (*(_QWORD *)&v8[4]._os_unfair_lock_opaque == 1)
    {
      *a3 = 0;
      start_of_key_locked = 1;
    }
    else
    {
      start_of_key_locked = nw_txt_record_find_start_of_key_locked(v8, a2, 0, 0, buf, a3);
    }
    *a4 = start_of_key_locked;
    os_unfair_lock_unlock(v8 + 8);
    v10 = *(_QWORD *)buf;
    goto LABEL_9;
  }
  __nwlog_obj();
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
  v13 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v35 = 0;
  if (__nwlog_fault(v13, &type, &v35))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v21, "%{public}s called with null value_len", buf, 0xCu);
      }
LABEL_76:

      goto LABEL_50;
    }
    if (!v35)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v34 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v34, "%{public}s called with null value_len, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_76;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v29 = type;
    v30 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
        _os_log_impl(&dword_182FBE000, v14, v29, "%{public}s called with null value_len, no backtrace", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_txt_record_get_key";
      v38 = 2082;
      v39 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v14, v29, "%{public}s called with null value_len, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_49;
  }
LABEL_50:
  if (v13)
    free(v13);
  v10 = 0;
LABEL_9:

  return v10;
}

void sub_1839078B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_txt_record_get_key_value_result(unsigned __int8 *a1, uint64_t a2)
{
  unint64_t v2;

  if (!a1)
    return 1;
  v2 = *a1;
  if (v2 == a2)
    return 2;
  if (a2 + 1 == v2)
    return 3;
  if (a2 + 1 >= v2)
    __assert_rtn("nw_txt_record_get_key_value_result", "txt_record.cpp", 758, "false");
  return 4;
}

nw_txt_record_t nw_txt_record_copy(nw_txt_record_t txt_record)
{
  if (txt_record)
    return nw_txt_record_create_with_bytes((const uint8_t *)txt_record[1].isa, (size_t)txt_record[2].isa);
  return txt_record;
}

uint64_t nw_txt_record_get_bytes(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

uint64_t nw_txt_record_get_length(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

const char *nw_activity_reporting_strategy_to_string(unsigned int a1)
{
  if (a1 > 3)
    return "invalid";
  else
    return off_1E14A5580[a1];
}

const char *nw_activity_completion_reason_to_string(int a1)
{
  if ((a1 - 1) > 3)
    return "invalid";
  else
    return off_1E14A6B58[a1 - 1];
}

uint64_t nw_activity_is_activated(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[132] >> 2) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_is_activated";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_activated";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_is_activated";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_activated";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_activated";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

char *nw_activity_create_from_xpc_token(void *a1)
{
  id v1;
  void *v2;
  char *v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  _BYTE buf[22];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (object_getClass(v1) == (Class)MEMORY[0x1E0C813A0])
    {
      *(_OWORD *)buf = *(_OWORD *)xpc_uuid_get_bytes(v2);
      v3 = -[NWConcrete_nw_activity initWithToken:]([NWConcrete_nw_activity alloc], buf);
      goto LABEL_4;
    }
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid))", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v18)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid)), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid)), no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null (xpc_get_type(token) == (&_xpc_type_uuid)), dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v6, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null token", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v18)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null token, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null token, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_activity_create_from_xpc_token";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null token, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_4:

  return v3;
}

void sub_183908A18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *nw_activity_create_retry(void *a1)
{
  id v1;
  NWConcrete_nw_activity *v2;
  id v3;
  _DWORD *v4;
  _QWORD *v5;
  char v6;
  id v7;
  void *v8;
  void *v9;
  _DWORD *v10;
  _BOOL4 v11;
  id v12;
  void *v13;
  NSObject *v14;
  os_log_type_t v15;
  NSObject *v16;
  int v17;
  int v18;
  _BYTE *v19;
  char v20;
  _QWORD *v21;
  void *v22;
  NSObject *v23;
  char *backtrace_string;
  os_log_type_t v26;
  _BOOL4 v27;
  os_log_type_t v28;
  void *v29;
  char *v30;
  NSObject *v31;
  os_log_type_t receiver;
  void *v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  char *v37;
  os_log_type_t v38;
  _BOOL4 v39;
  char *v40;
  os_log_type_t v41;
  _BOOL4 v42;
  os_log_type_t v43;
  os_log_type_t v44;
  char v45;
  os_log_type_t type;
  objc_super v47;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  _WORD v51[9];

  *(_QWORD *)&v51[5] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    v2 = [NWConcrete_nw_activity alloc];
    v3 = v1;
    if (!v2)
    {
LABEL_83:
      v21 = 0;
LABEL_32:

      goto LABEL_33;
    }
    v47.receiver = v2;
    v47.super_class = (Class)NWConcrete_nw_activity;
    v4 = objc_msgSendSuper2(&v47, sel_init);
    v5 = v4;
    if (v4)
    {
      v4[27] = *((_DWORD *)v3 + 27);
      v4[26] = *((_DWORD *)v3 + 26);
      v4[31] = *((_DWORD *)v3 + 31);
      v6 = *((_BYTE *)v4 + 132) | 1;
      *((_BYTE *)v4 + 132) = v6;
      *((_BYTE *)v4 + 132) = *((_BYTE *)v3 + 132) & 2 | v6 & 0xFD;
      v7 = v3;
      v8 = (void *)v5[7];
      if ((v5[8] & 1) != 0 && v8)
      {
        v5[7] = 0;

        v8 = (void *)v5[7];
      }
      v5[7] = 0;

      v9 = (void *)v5[7];
      v5[7] = v7;

      *((_BYTE *)v5 + 64) |= 1u;
      v10 = v7;
      v11 = (*((_BYTE *)v3 + 132) & 4) == 0;

      if (!v11)
        goto LABEL_15;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
      v13 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v45 = 0;
      if (__nwlog_fault((const char *)v13, &type, &v45))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (id)gLogObj;
          v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
            _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity", buf, 0xCu);
          }
        }
        else if (v45)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (id)gLogObj;
          v26 = type;
          v27 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v27)
            {
              *(_DWORD *)buf = 136446466;
              v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
              v50 = 2082;
              *(_QWORD *)v51 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v14, v26, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v13)
              goto LABEL_15;
LABEL_14:
            free(v13);
LABEL_15:
            if ((*((_BYTE *)v3 + 132) & 8) != 0 && (v10[29] || v10[30]))
            {
              if (__nwlog_activity_log::onceToken != -1)
                dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
              v16 = (id)gactivityLogObj;
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
              {
                v17 = v10[29];
                v18 = v10[30];
                *(_DWORD *)buf = 138412802;
                v49 = (const char *)v10;
                v50 = 1024;
                *(_DWORD *)v51 = v17;
                v51[2] = 1024;
                *(_DWORD *)&v51[3] = v18;
                _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "Original activity %@ was completed, ignoring underlying error domain: %d, code: %d", buf, 0x18u);
              }

            }
            v19 = v10;
            v20 = v19[17];

            v21 = v5;
            uuid_generate_random((unsigned __int8 *)v21 + 8);
            *((_BYTE *)v21 + 17) = *((_BYTE *)v21 + 17) & 0xFE | v20 & 1;
            os_unfair_lock_lock((os_unfair_lock_t)v21 + 24);
            v22 = (void *)v21[10];
            if ((v21[11] & 1) != 0 && v22)
            {
              v21[10] = 0;

              v22 = (void *)v21[10];
            }
            v21[10] = 0;

            os_unfair_lock_unlock((os_unfair_lock_t)v21 + 24);
            if (nw_activity_should_log(v21))
            {
              if (__nwlog_activity_log::onceToken != -1)
                dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
              v23 = (id)gactivityLogObj;
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138543362;
                v49 = (const char *)v21;
                _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEFAULT, "Create activity %{public}@", buf, 0xCu);
              }

            }
            goto LABEL_32;
          }
          if (v27)
          {
            *(_DWORD *)buf = 136446210;
            v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
            _os_log_impl(&dword_182FBE000, v14, v26, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = (id)gLogObj;
          v28 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
            _os_log_impl(&dword_182FBE000, v14, v28, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot create retry of a non-activated activity, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
      if (!v13)
        goto LABEL_15;
      goto LABEL_14;
    }
    __nwlog_obj();
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
    v34 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if ((__nwlog_fault(v34, &type, &v45) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v45)
      {
        v40 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v41 = type;
        v42 = os_log_type_enabled(v35, type);
        if (v40)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446466;
            v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
            v50 = 2082;
            *(_QWORD *)v51 = v40;
            _os_log_impl(&dword_182FBE000, v35, v41, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v40);
          goto LABEL_81;
        }
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_182FBE000, v35, v41, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v35 = objc_claimAutoreleasedReturnValue();
        v44 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          v49 = "-[NWConcrete_nw_activity initWithOriginal:]";
          _os_log_impl(&dword_182FBE000, v35, v44, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_81:
    if (v34)
      free(v34);
    goto LABEL_83;
  }
  __nwlog_obj();
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v49 = "nw_activity_create_retry";
  v30 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v47.receiver) = 16;
  type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v30, &v47, &type))
  {
    if (LOBYTE(v47.receiver) == 17)
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      receiver = (os_log_type_t)v47.receiver;
      if (os_log_type_enabled(v31, (os_log_type_t)v47.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_activity_create_retry";
        _os_log_impl(&dword_182FBE000, v31, receiver, "%{public}s called with null original", buf, 0xCu);
      }
    }
    else if (type)
    {
      v37 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v38 = (os_log_type_t)v47.receiver;
      v39 = os_log_type_enabled(v31, (os_log_type_t)v47.receiver);
      if (v37)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          v49 = "nw_activity_create_retry";
          v50 = 2082;
          *(_QWORD *)v51 = v37;
          _os_log_impl(&dword_182FBE000, v31, v38, "%{public}s called with null original, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v37);
        goto LABEL_75;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_activity_create_retry";
        _os_log_impl(&dword_182FBE000, v31, v38, "%{public}s called with null original, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v31 = objc_claimAutoreleasedReturnValue();
      v43 = (os_log_type_t)v47.receiver;
      if (os_log_type_enabled(v31, (os_log_type_t)v47.receiver))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "nw_activity_create_retry";
        _os_log_impl(&dword_182FBE000, v31, v43, "%{public}s called with null original, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_75:
  if (v30)
    free(v30);
  v21 = 0;
LABEL_33:

  return v21;
}

void sub_1839093B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t nw_activity_deep_is_equal(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  BOOL v6;
  uint64_t v7;
  void *v9;
  id v10;

  v3 = a1;
  v4 = a2;
  v5 = v4;
  if (v3 && v4 && !uuid_is_null((const unsigned __int8 *)v3 + 8) && !uuid_is_null((const unsigned __int8 *)v5 + 8))
  {
    if (*((_DWORD *)v3 + 27) != *((_DWORD *)v5 + 27)
      || *((_DWORD *)v3 + 26) != *((_DWORD *)v5 + 26)
      || *((_QWORD *)v3 + 3) != *((_QWORD *)v5 + 3)
      || *((_DWORD *)v3 + 31) != *((_DWORD *)v5 + 31)
      || *((_DWORD *)v3 + 32) != *((_DWORD *)v5 + 32)
      || ((*((_BYTE *)v5 + 132) ^ *((_BYTE *)v3 + 132)) & 0xD) != 0
      || (v9 = (void *)*((_QWORD *)v5 + 7),
          v10 = *((id *)v3 + 7),
          LOBYTE(v9) = nw_activity_is_equal(v10, v9),
          v10,
          (v9 & 1) == 0)
      || *((_QWORD *)v3 + 1) != *((_QWORD *)v5 + 1)
      || *((_QWORD *)v3 + 2) != *((_QWORD *)v5 + 2))
    {
      v7 = 0;
      goto LABEL_9;
    }
    v6 = *((_QWORD *)v3 + 4) == *((_QWORD *)v5 + 4);
  }
  else
  {
    v6 = v3 == v5;
  }
  v7 = v6;
LABEL_9:

  return v7;
}

void sub_183909528(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

BOOL nw_activity_has_global_investigation_identifier()
{
  return nw_activity_get_investigation_id_from_defaults() != 0;
}

BOOL nw_activity_should_write_metric_stream_to_log()
{
  return networkd_settings_get_BOOL((const char *)nw_setting_activity_write_metric_stream_to_log);
}

uint64_t nw_activity_should_report_to_destination(int a1)
{
  int64_t int64_with_default;
  int64_t v3;
  char v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  NSObject *v12;
  char *backtrace_string;
  _BOOL4 v14;
  NSObject *v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v19 = "nw_activity_should_report_to_destination";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v7, &type, &v16))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_activity_should_report_to_destination";
        v10 = "%{public}s called with null destination";
LABEL_37:
        _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
      }
    }
    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            v19 = "nw_activity_should_report_to_destination";
            v20 = 2082;
            v21 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null destination, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }
        if (!v14)
          goto LABEL_38;
        *(_DWORD *)buf = 136446210;
        v19 = "nw_activity_should_report_to_destination";
        v10 = "%{public}s called with null destination, no backtrace";
        goto LABEL_37;
      }
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_activity_should_report_to_destination";
        v10 = "%{public}s called with null destination, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
LABEL_38:

LABEL_39:
    if (v7)
      free(v7);
    goto LABEL_41;
  }
  int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_activity_report_destination, 12);
  v3 = int64_with_default;
  if (!gLogDatapath)
  {
    if ((int64_with_default & a1) != 0)
      v4 = -1;
    else
      v4 = 0;
    return v4 & 1;
  }
  if (__nwlog_activity_log::onceToken != -1)
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
  v11 = (id)gactivityLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446466;
    v19 = "nw_activity_should_report_to_destination";
    v20 = 2048;
    v21 = (char *)v3;
    _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Activity destination: %llu", buf, 0x16u);
  }

  v4 = gLogDatapath;
  if ((v3 & a1) == 0)
  {
    if (!gLogDatapath)
      return v4 & 1;
    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v15 = (id)gactivityLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_activity_should_report_to_destination";
      v20 = 1024;
      LODWORD(v21) = a1;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_DEBUG, "%{public}s Destination %u is not configured", buf, 0x12u);
    }

LABEL_41:
    v4 = 0;
    return v4 & 1;
  }
  if (gLogDatapath)
  {
    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v12 = (id)gactivityLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v19 = "nw_activity_should_report_to_destination";
      v20 = 1024;
      LODWORD(v21) = a1;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Destination %u is configured", buf, 0x12u);
    }

    v4 = 1;
  }
  else
  {
    v4 = 1;
  }
  return v4 & 1;
}

const char *nw_activity_domain_to_string(int a1)
{
  const char *v2;

  if ((a1 - 11) < 0x32)
    return off_1E14A58C0[a1 - 11];
  if ((a1 - 1) >= 0xA)
    v2 = "invalid";
  else
    v2 = "reserved";
  if ((a1 - 900) >= 0x64)
    return v2;
  else
    return "experimental";
}

BOOL nw_activity_domain_is_valid(int a1)
{
  return (a1 - 900) < 0x64 || (a1 - 11) < 0x32;
}

void __nw_activity_activate_block_invoke_49(uint64_t a1)
{
  NWConcrete_nw_activity *v1;
  NWConcrete_nw_activity *v2;
  NWConcrete_nw_activity *v3;
  void *v4;
  NSObject *v5;
  id v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *v10;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  os_log_type_t v19;
  char *backtrace_string;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  char v28;
  os_log_type_t type;
  void *v30;
  nw_activity_report_s v31;
  int buf;
  const char *v33;
  __int16 v34;
  char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v1 = (NWConcrete_nw_activity *)*(id *)(a1 + 32);
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(v31.investigation_identifier) = 136446210;
    *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
    v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(buf) = 16;
    LOBYTE(v30) = 0;
    if (!__nwlog_fault(v15, &buf, &v30))
      goto LABEL_73;
    if (buf == 17)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = buf;
      if (os_log_type_enabled(v16, (os_log_type_t)buf))
      {
        LODWORD(v31.investigation_identifier) = 136446210;
        *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null activity", (uint8_t *)&v31, 0xCu);
      }
    }
    else if ((_BYTE)v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = buf;
      v22 = os_log_type_enabled(v16, (os_log_type_t)buf);
      if (backtrace_string)
      {
        if (v22)
        {
          LODWORD(v31.investigation_identifier) = 136446466;
          *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
          LOWORD(v31.label) = 2082;
          *(_QWORD *)((char *)&v31.label + 2) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null activity, dumping backtrace:%{public}s", (uint8_t *)&v31, 0x16u);
        }

        free(backtrace_string);
LABEL_73:
        if (!v15)
          goto LABEL_39;
        goto LABEL_74;
      }
      if (v22)
      {
        LODWORD(v31.investigation_identifier) = 136446210;
        *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null activity, no backtrace", (uint8_t *)&v31, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v26 = buf;
      if (os_log_type_enabled(v16, (os_log_type_t)buf))
      {
        LODWORD(v31.investigation_identifier) = 136446210;
        *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
        _os_log_impl(&dword_182FBE000, v16, v26, "%{public}s called with null activity, backtrace limit exceeded", (uint8_t *)&v31, 0xCu);
      }
    }
LABEL_72:

    goto LABEL_73;
  }
  if ((*((_BYTE *)v1 + 132) & 4) == 0)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(v31.investigation_identifier) = 136446210;
    *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
    v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(buf) = 16;
    LOBYTE(v30) = 0;
    if (!__nwlog_fault(v15, &buf, &v30))
      goto LABEL_73;
    if (buf == 17)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v19 = buf;
      if (os_log_type_enabled(v16, (os_log_type_t)buf))
      {
        LODWORD(v31.investigation_identifier) = 136446210;
        *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
        _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s Cannot report activity before activation", (uint8_t *)&v31, 0xCu);
      }
    }
    else if ((_BYTE)v30)
    {
      v23 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v24 = buf;
      v25 = os_log_type_enabled(v16, (os_log_type_t)buf);
      if (v23)
      {
        if (v25)
        {
          LODWORD(v31.investigation_identifier) = 136446466;
          *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
          LOWORD(v31.label) = 2082;
          *(_QWORD *)((char *)&v31.label + 2) = v23;
          _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s Cannot report activity before activation, dumping backtrace:%{public}s", (uint8_t *)&v31, 0x16u);
        }

        free(v23);
        if (!v15)
          goto LABEL_39;
LABEL_74:
        free(v15);
        goto LABEL_39;
      }
      if (v25)
      {
        LODWORD(v31.investigation_identifier) = 136446210;
        *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
        _os_log_impl(&dword_182FBE000, v16, v24, "%{public}s Cannot report activity before activation, no backtrace", (uint8_t *)&v31, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v27 = buf;
      if (os_log_type_enabled(v16, (os_log_type_t)buf))
      {
        LODWORD(v31.investigation_identifier) = 136446210;
        *(unint64_t *)((char *)&v31.investigation_identifier + 4) = (unint64_t)"nw_activity_report_if_selected";
        _os_log_impl(&dword_182FBE000, v16, v27, "%{public}s Cannot report activity before activation, backtrace limit exceeded", (uint8_t *)&v31, 0xCu);
      }
    }
    goto LABEL_72;
  }
  if ((v1->token[9] & 1) == 0)
    goto LABEL_39;
  memset(&v31, 0, sizeof(v31));
  nw_activity_fill_out_activity_report(v1, &v31);
  if (os_variant_has_internal_diagnostics()
    && networkd_settings_get_BOOL((const char *)nw_setting_activity_write_metric_stream_to_log))
  {
    v3 = v2;
    v4 = nw_activity_create_activity_dictionary(v3, &v31);
    v30 = 0;
    if (nw_activity_metric_object_is_valid(v4, 0, (const char **)&v30))
    {
      if (__nwlog_metricstream_log::onceToken != -1)
        dispatch_once(&__nwlog_metricstream_log::onceToken, &__block_literal_global_51_44220);
      v5 = (id)gmetricstreamLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        buf = 136446210;
        v33 = (const char *)v30;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&buf, 0xCu);
      }

      goto LABEL_34;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v6 = (id)gLogObj;
    buf = 136446210;
    v33 = "nw_activity_write_activity_report_to_log";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v28 = 0;
    if (__nwlog_fault(v7, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = (id)gLogObj;
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          buf = 136446210;
          v33 = "nw_activity_write_activity_report_to_log";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s generated activity dictionary is not valid", (uint8_t *)&buf, 0xCu);
        }
      }
      else if (v28)
      {
        v10 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (v10)
        {
          if (v12)
          {
            buf = 136446466;
            v33 = "nw_activity_write_activity_report_to_log";
            v34 = 2082;
            v35 = v10;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s generated activity dictionary is not valid, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x16u);
          }

          free(v10);
          if (!v7)
            goto LABEL_34;
          goto LABEL_33;
        }
        if (v12)
        {
          buf = 136446210;
          v33 = "nw_activity_write_activity_report_to_log";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s generated activity dictionary is not valid, no backtrace", (uint8_t *)&buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          buf = 136446210;
          v33 = "nw_activity_write_activity_report_to_log";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s generated activity dictionary is not valid, backtrace limit exceeded", (uint8_t *)&buf, 0xCu);
        }
      }

    }
    if (!v7)
    {
LABEL_34:
      if (v30)
        free(v30);
      if (v4)

      goto LABEL_39;
    }
LABEL_33:
    free(v7);
    goto LABEL_34;
  }
  if (nw_connection_get_symptom_reporter_handle::once[0] != -1)
    dispatch_once(nw_connection_get_symptom_reporter_handle::once, &__block_literal_global_77956);
  symptom_new();
  symptom_set_qualifier();
  symptom_set_additional_qualifier();
  symptom_send();
LABEL_39:

}

void sub_18390A280(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  if (v3)

  _Unwind_Resume(a1);
}

void nw_activity_fill_out_activity_report(NWConcrete_nw_activity *a1, nw_activity_report_s *a2)
{
  NWConcrete_nw_activity *v3;
  NWConcrete_nw_activity *v4;
  NWConcrete_nw_activity *m_obj;
  unsigned __int8 *v6;
  char *bundle_id;
  uint64_t v8;
  int v9;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  char v18;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!a2)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v21 = "nw_activity_fill_out_activity_report";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_activity_fill_out_activity_report";
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null report", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            v21 = "nw_activity_fill_out_activity_report";
            v22 = 2082;
            v23 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_activity_fill_out_activity_report";
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          v21 = "nw_activity_fill_out_activity_report";
          _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_29:
    if (v11)
      free(v11);
    goto LABEL_12;
  }
  a2->domain = v3->domain;
  a2->label = v3->label;
  *(_OWORD *)a2->activity_uuid = *(_OWORD *)v3->token;
  m_obj = v3->parent.m_obj;
  if (m_obj && !uuid_is_null(m_obj->token))
    *(_OWORD *)a2->parent_activity_uuid = *(_OWORD *)v4->parent.m_obj->token;
  *((_BYTE *)a2 + 304) = *((_BYTE *)a2 + 304) & 0xFE | *((_BYTE *)v4 + 132) & 1;
  a2->investigation_identifier = v4->investigation_identifier;
  if (nw_utilities_get_self_bundle_id::onceToken != -1)
    dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_7);
  v6 = (unsigned __int8 *)nw_utilities_get_self_bundle_id::bundle_identifier_string;
  if (nw_utilities_get_self_bundle_id::bundle_identifier_string)
  {
    bundle_id = a2->bundle_id;
    v8 = 256;
    while (1)
    {
      v9 = *v6;
      *bundle_id = v9;
      if (!v9)
        break;
      ++bundle_id;
      ++v6;
      if ((unint64_t)--v8 <= 1)
      {
        *bundle_id = 0;
        break;
      }
    }
  }
LABEL_12:

}

void sub_18390A5F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *nw_activity_create_activity_dictionary(NWConcrete_nw_activity *a1, nw_activity_report_s *a2)
{
  NWConcrete_nw_activity *v3;
  xpc_object_t v4;
  void *v5;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type[8];
  char v25;
  os_log_type_t v26;
  uuid_string_t out;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  if (a2)
  {
    v4 = xpc_dictionary_create(0, 0, 0);
    v5 = v4;
    *(_QWORD *)type = v4;
    v25 = -1;
    if (v4)
    {
      xpc_dictionary_set_uint64(v4, "activityDomain", a2->domain);
      xpc_dictionary_set_uint64(v5, "activityLabel", a2->label);
      if (!uuid_is_null(a2->activity_uuid))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse(a2->activity_uuid, out);
        xpc_dictionary_set_string(v5, "activityUUID", out);
      }
      if (!uuid_is_null(a2->parent_activity_uuid))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse(a2->parent_activity_uuid, out);
        xpc_dictionary_set_string(v5, "parentActivityUUID", out);
      }
      xpc_dictionary_set_BOOL(v5, "isRetry", *((_BYTE *)a2 + 304) & 1);
      if (a2->bundle_id[0])
        xpc_dictionary_set_string(v5, "bundleID", a2->bundle_id);
      xpc_dictionary_set_uint64(v5, "investigationID", a2->investigation_identifier);
      goto LABEL_10;
    }
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)out = 136446210;
    *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
    v12 = (char *)_os_log_send_and_compose_impl();

    v26 = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v12, &v26, &v23))
      goto LABEL_46;
    if (v26 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v14 = v26;
      if (os_log_type_enabled(v13, v26))
      {
        *(_DWORD *)out = 136446210;
        *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s failed to allocate dictionary", (uint8_t *)out, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v19 = v26;
      v20 = os_log_type_enabled(v13, v26);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)out = 136446466;
          *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
          *(_WORD *)&out[12] = 2082;
          *(_QWORD *)&out[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s failed to allocate dictionary, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_46;
      }
      if (v20)
      {
        *(_DWORD *)out = 136446210;
        *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_182FBE000, v13, v19, "%{public}s failed to allocate dictionary, no backtrace", (uint8_t *)out, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      v22 = v26;
      if (os_log_type_enabled(v13, v26))
      {
        *(_DWORD *)out = 136446210;
        *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_182FBE000, v13, v22, "%{public}s failed to allocate dictionary, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
    }

LABEL_46:
    if (v12)
      free(v12);
    goto LABEL_10;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)out = 136446210;
  *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
  v8 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v26 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v8, type, &v26))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null activity_report", (uint8_t *)out, 0xCu);
      }
    }
    else if (v26)
    {
      v15 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v16 = type[0];
      v17 = os_log_type_enabled(v9, type[0]);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)out = 136446466;
          *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
          *(_WORD *)&out[12] = 2082;
          *(_QWORD *)&out[14] = v15;
          _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null activity_report, dumping backtrace:%{public}s", (uint8_t *)out, 0x16u);
        }

        free(v15);
        goto LABEL_40;
      }
      if (v17)
      {
        *(_DWORD *)out = 136446210;
        *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_182FBE000, v9, v16, "%{public}s called with null activity_report, no backtrace", (uint8_t *)out, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v21 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *(_DWORD *)out = 136446210;
        *(_QWORD *)&out[4] = "nw_activity_create_activity_dictionary";
        _os_log_impl(&dword_182FBE000, v9, v21, "%{public}s called with null activity_report, backtrace limit exceeded", (uint8_t *)out, 0xCu);
      }
    }

  }
LABEL_40:
  if (v8)
    free(v8);
  v5 = 0;
LABEL_10:

  return v5;
}

void sub_18390ABA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  va_list va;

  va_start(va, a6);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);

  _Unwind_Resume(a1);
}

BOOL nw_activity_metric_object_is_valid(void *a1, unsigned int a2, const char **a3)
{
  id v5;
  NSObject *v6;
  Class Class;
  const char *v8;
  NSObject *v9;
  _BOOL8 v10;
  objc_class *v11;
  NSObject *v12;
  void *v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  _QWORD v27[6];
  unsigned int v28;
  _QWORD applier[7];
  unsigned int v30;
  char v31;
  _BYTE v32[24];
  char v33;
  _BYTE buf[24];
  unsigned int v35;
  __int16 v36;
  id v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  if (v5)
  {
    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v6 = (id)gactivityLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      Class = object_getClass(v5);
      v8 = "";
      *(_DWORD *)buf = 136315906;
      if (!a2)
        v8 = "top level ";
      *(_QWORD *)&buf[4] = v8;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = Class;
      *(_WORD *)&buf[22] = 1024;
      v35 = a2;
      v36 = 2112;
      v37 = v5;
      _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "Inspecting %s%@ at depth %u: %@", buf, 0x26u);
    }

    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    LOBYTE(v35) = 1;
    if (a2 < 0xB)
    {
      v11 = (objc_class *)MEMORY[0x1E0C812F8];
      if (a2 || object_getClass(v5) == v11)
      {
        if (object_getClass(v5) == v11)
        {
          nw_append_format(a3, "{");
          *(_QWORD *)v32 = 0;
          *(_QWORD *)&v32[8] = v32;
          *(_QWORD *)&v32[16] = 0x2020000000;
          v33 = 1;
          applier[0] = MEMORY[0x1E0C809B0];
          applier[1] = 3221225472;
          applier[2] = __nw_activity_metric_object_is_valid_block_invoke;
          applier[3] = &unk_1E14A54A0;
          v30 = a2;
          applier[4] = v32;
          applier[5] = buf;
          applier[6] = a3;
          xpc_dictionary_apply(v5, applier);
          nw_append_format(a3, "}");
          _Block_object_dispose(v32, 8);
        }
        else if (object_getClass(v5) == (Class)MEMORY[0x1E0C812C8])
        {
          nw_append_format(a3, "[");
          v27[0] = MEMORY[0x1E0C809B0];
          v27[1] = 3221225472;
          v27[2] = __nw_activity_metric_object_is_valid_block_invoke_70;
          v27[3] = &unk_1E14A54C8;
          v28 = a2;
          v27[4] = buf;
          v27[5] = a3;
          xpc_array_apply(v5, v27);
          nw_append_format(a3, "]");
        }
        else if (object_getClass(v5) == (Class)MEMORY[0x1E0C81390])
        {
          if (gLogDatapath)
          {
            if (__nwlog_activity_log::onceToken != -1)
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
            v22 = (id)gactivityLogObj;
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v32 = 136446466;
              *(_QWORD *)&v32[4] = "nw_activity_metric_object_is_valid";
              *(_WORD *)&v32[12] = 2112;
              *(_QWORD *)&v32[14] = object_getClass(v5);
              _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %@ is allowed", v32, 0x16u);
            }

          }
          xpc_string_get_string_ptr(v5);
          nw_append_format(a3, "\"%s\"");
        }
        else if (object_getClass(v5) == (Class)MEMORY[0x1E0C81328])
        {
          if (gLogDatapath)
          {
            if (__nwlog_activity_log::onceToken != -1)
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
            v23 = (id)gactivityLogObj;
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v32 = 136446466;
              *(_QWORD *)&v32[4] = "nw_activity_metric_object_is_valid";
              *(_WORD *)&v32[12] = 2112;
              *(_QWORD *)&v32[14] = object_getClass(v5);
              _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %@ is allowed", v32, 0x16u);
            }

          }
          xpc_int64_get_value(v5);
          nw_append_format(a3, "%lld");
        }
        else if (object_getClass(v5) == (Class)MEMORY[0x1E0C81398])
        {
          if (gLogDatapath)
          {
            if (__nwlog_activity_log::onceToken != -1)
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
            v24 = (id)gactivityLogObj;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v32 = 136446466;
              *(_QWORD *)&v32[4] = "nw_activity_metric_object_is_valid";
              *(_WORD *)&v32[12] = 2112;
              *(_QWORD *)&v32[14] = object_getClass(v5);
              _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %@ is allowed", v32, 0x16u);
            }

          }
          xpc_uint64_get_value(v5);
          nw_append_format(a3, "%llu");
        }
        else if (object_getClass(v5) == (Class)MEMORY[0x1E0C81300])
        {
          if (gLogDatapath)
          {
            if (__nwlog_activity_log::onceToken != -1)
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
            v25 = (id)gactivityLogObj;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v32 = 136446466;
              *(_QWORD *)&v32[4] = "nw_activity_metric_object_is_valid";
              *(_WORD *)&v32[12] = 2112;
              *(_QWORD *)&v32[14] = object_getClass(v5);
              _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %@ is allowed", v32, 0x16u);
            }

          }
          xpc_double_get_value(v5);
          nw_append_format(a3, "%f");
        }
        else if (object_getClass(v5) == (Class)MEMORY[0x1E0C812D0])
        {
          if (gLogDatapath)
          {
            if (__nwlog_activity_log::onceToken != -1)
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
            v26 = (id)gactivityLogObj;
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v32 = 136446466;
              *(_QWORD *)&v32[4] = "nw_activity_metric_object_is_valid";
              *(_WORD *)&v32[12] = 2112;
              *(_QWORD *)&v32[14] = object_getClass(v5);
              _os_log_impl(&dword_182FBE000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %@ is allowed", v32, 0x16u);
            }

          }
          xpc_BOOL_get_value(v5);
          nw_append_format(a3, "%s");
        }
        else
        {
          if (__nwlog_activity_log::onceToken != -1)
            dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
          v12 = (id)gactivityLogObj;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)v32 = 138412546;
            *(_QWORD *)&v32[4] = v5;
            *(_WORD *)&v32[12] = 2112;
            *(_QWORD *)&v32[14] = object_getClass(v5);
            _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_INFO, "Invalid type in metric object: %@ (%@)", v32, 0x16u);
          }

          *(_BYTE *)(*(_QWORD *)&buf[8] + 24) = 0;
        }
        v10 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
        goto LABEL_46;
      }
      if (__nwlog_activity_log::onceToken != -1)
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
      v9 = (id)gactivityLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)v32 = 138412290;
        *(_QWORD *)&v32[4] = v5;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_INFO, "Top level metrics object is not a dictionary: %@", v32, 0xCu);
      }
    }
    else
    {
      if (__nwlog_activity_log::onceToken != -1)
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
      v9 = (id)gactivityLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)v32 = 138412290;
        *(_QWORD *)&v32[4] = v5;
        _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_INFO, "Exceeded max depth with object: %@", v32, 0xCu);
      }
    }

    v10 = 0;
LABEL_46:
    _Block_object_dispose(buf, 8);
    goto LABEL_47;
  }
  __nwlog_obj();
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_activity_metric_object_is_valid";
  v15 = (char *)_os_log_send_and_compose_impl();

  v32[0] = 16;
  v31 = 0;
  if (__nwlog_fault(v15, v32, &v31))
  {
    if (v32[0] == 17)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v17 = v32[0];
      if (os_log_type_enabled(v16, (os_log_type_t)v32[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_metric_object_is_valid";
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s called with null metrics", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v19 = v32[0];
      v20 = os_log_type_enabled(v16, (os_log_type_t)v32[0]);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_activity_metric_object_is_valid";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null metrics, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_64;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_metric_object_is_valid";
        _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s called with null metrics, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v21 = v32[0];
      if (os_log_type_enabled(v16, (os_log_type_t)v32[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_metric_object_is_valid";
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s called with null metrics, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_64:
  if (v15)
    free(v15);
  v10 = 0;
LABEL_47:

  return v10;
}

void sub_18390B66C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  _Block_object_dispose((const void *)(v3 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_activity_metric_object_is_valid_block_invoke(uint64_t a1, const char *a2, void *a3)
{
  id v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t is_valid;
  uint8_t buf[4];
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v6 + 24))
  {
    nw_append_format(*(const char ***)(a1 + 48), ",");
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  }
  *(_BYTE *)(v6 + 24) = 0;
  if (__nwlog_activity_log::onceToken != -1)
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
  v7 = (id)gactivityLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315138;
    v11 = a2;
    _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "Inspecting dictionary key: %s", buf, 0xCu);
  }

  nw_append_format(*(const char ***)(a1 + 48), "\"%s\":", a2);
  is_valid = nw_activity_metric_object_is_valid(v5, (*(_DWORD *)(a1 + 56) + 1), *(_QWORD *)(a1 + 48));
  if ((is_valid & 1) == 0)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;

  return is_valid;
}

void sub_18390B848(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_activity_metric_object_is_valid_block_invoke_70(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  NSObject *v6;
  uint64_t is_valid;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = a3;
  if (a2)
    nw_append_format(*(const char ***)(a1 + 40), ",");
  if (__nwlog_activity_log::onceToken != -1)
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
  v6 = (id)gactivityLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v9 = 134217984;
    v10 = a2;
    _os_log_impl(&dword_182FBE000, v6, OS_LOG_TYPE_DEBUG, "Inspecting array index: %zu", (uint8_t *)&v9, 0xCu);
  }

  is_valid = nw_activity_metric_object_is_valid(v5, (*(_DWORD *)(a1 + 48) + 1), *(_QWORD *)(a1 + 40));
  if ((is_valid & 1) == 0)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;

  return is_valid;
}

void sub_18390B984(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_activity_uuid_is_selected_for_reporting(uint64_t a1)
{
  void *v2;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  char v9;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_BYTE *)(a1 + 9) & 1;
  __nwlog_obj();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v12 = "nw_activity_uuid_is_selected_for_reporting";
  v3 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_activity_uuid_is_selected_for_reporting";
        v6 = "%{public}s called with null uuid";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
      }
    }
    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v4 = objc_claimAutoreleasedReturnValue();
        v5 = type;
        v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)buf = 136446466;
            v12 = "nw_activity_uuid_is_selected_for_reporting";
            v13 = 2082;
            v14 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v4, v5, "%{public}s called with null uuid, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v8)
          goto LABEL_18;
        *(_DWORD *)buf = 136446210;
        v12 = "nw_activity_uuid_is_selected_for_reporting";
        v6 = "%{public}s called with null uuid, no backtrace";
        goto LABEL_17;
      }
      __nwlog_obj();
      v4 = objc_claimAutoreleasedReturnValue();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v12 = "nw_activity_uuid_is_selected_for_reporting";
        v6 = "%{public}s called with null uuid, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:

  }
LABEL_19:
  if (v3)
    free(v3);
  return 0;
}

void nw_activity_set_reporting_strategy(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  void *v13;
  os_log_type_t v14;
  char *backtrace_string;
  os_log_type_t v16;
  _BOOL4 v17;
  char *v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  _BOOL4 v22;
  char *v23;
  os_log_type_t v24;
  _BOOL4 v25;
  os_log_type_t v26;
  os_log_type_t v27;
  os_log_type_t v28;
  os_log_type_t v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  char *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_activity_set_reporting_strategy";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v6, &type, &v30))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      v17 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          v33 = "nw_activity_set_reporting_strategy";
          v34 = 2082;
          v35 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_73:
        if (!v6)
          goto LABEL_6;
LABEL_74:
        free(v6);
        goto LABEL_6;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v26, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_72:

    goto LABEL_73;
  }
  if ((*((_BYTE *)v3 + 132) & 4) != 0)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_activity_set_reporting_strategy";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v6, &type, &v30))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (!v30)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v27, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_72;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v7, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, no backtrace", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_activity_set_reporting_strategy";
      v34 = 2082;
      v35 = v18;
      _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_41;
  }
  if ((*((_BYTE *)v3 + 132) & 8) != 0)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v33 = "nw_activity_set_reporting_strategy";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v30 = 0;
    if (!__nwlog_fault(v6, &type, &v30))
      goto LABEL_73;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (!v30)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v28, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_72;
    }
    v18 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    v22 = os_log_type_enabled(v7, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_activity_set_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", buf, 0xCu);
      }
      goto LABEL_72;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_activity_set_reporting_strategy";
      v34 = 2082;
      v35 = v18;
      _os_log_impl(&dword_182FBE000, v7, v21, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_41:

    free(v18);
    if (!v6)
      goto LABEL_6;
    goto LABEL_74;
  }
  if ((a2 & 0xFC) == 0)
  {
    *((_DWORD *)v3 + 31) = a2;
    goto LABEL_6;
  }
  __nwlog_obj();
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446466;
  v33 = "nw_activity_set_reporting_strategy";
  v34 = 2082;
  v35 = "Invalid reporting strategy";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v30 = 0;
  if (!__nwlog_fault(v6, &type, &v30))
    goto LABEL_73;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v14 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_activity_set_reporting_strategy";
      v34 = 2082;
      v35 = "Invalid reporting strategy";
      _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
    }
    goto LABEL_72;
  }
  if (!v30)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v29 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_activity_set_reporting_strategy";
      v34 = 2082;
      v35 = "Invalid reporting strategy";
      _os_log_impl(&dword_182FBE000, v7, v29, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_72;
  }
  v23 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v24 = type;
  v25 = os_log_type_enabled(v7, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      v33 = "nw_activity_set_reporting_strategy";
      v34 = 2082;
      v35 = "Invalid reporting strategy";
      _os_log_impl(&dword_182FBE000, v7, v24, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_72;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446722;
    v33 = "nw_activity_set_reporting_strategy";
    v34 = 2082;
    v35 = "Invalid reporting strategy";
    v36 = 2082;
    v37 = v23;
    _os_log_impl(&dword_182FBE000, v7, v24, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v23);
  if (v6)
    goto LABEL_74;
LABEL_6:

}

uint64_t nw_activity_get_reporting_strategy(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[31];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_get_reporting_strategy";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_get_reporting_strategy";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_reporting_strategy";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_activity_get_is_retry(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 132) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_get_is_retry";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_is_retry";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_get_is_retry";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_is_retry";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_is_retry";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_activity_set_global_parent_block_invoke_56(uint64_t a1)
{
  objc_storeStrong((id *)&global_parent, *(id *)(a1 + 32));
}

void nw_activity_set_investigation_identifier(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  char *v16;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_activity_set_investigation_identifier";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v27 = "nw_activity_set_investigation_identifier";
          v28 = 2082;
          v29 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v6)
          goto LABEL_5;
LABEL_56:
        free(v6);
        goto LABEL_5;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v21, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if ((*((_BYTE *)v3 + 132) & 4) != 0)
  {
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_activity_set_investigation_identifier";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v24)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v22, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    v18 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v27 = "nw_activity_set_investigation_identifier";
      v28 = 2082;
      v29 = v16;
      _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after activation, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if ((*((_BYTE *)v3 + 132) & 8) != 0)
  {
    __nwlog_obj();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_activity_set_investigation_identifier";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (!__nwlog_fault(v6, &type, &v24))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v24)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v23 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    v16 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v7, type);
    if (!v16)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v27 = "nw_activity_set_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v27 = "nw_activity_set_investigation_identifier";
      v28 = 2082;
      v29 = v16;
      _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot set nw_activity settings after completion, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v16);
    if (!v6)
      goto LABEL_5;
    goto LABEL_56;
  }
  *((_QWORD *)v3 + 3) = a2;
LABEL_5:

}

uint64_t nw_activity_get_investigation_identifier(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 3);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_get_investigation_identifier";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_get_investigation_identifier";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_get_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_activity_has_investigation_identifier(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 3) != 0;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_has_investigation_identifier";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_has_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_has_investigation_identifier";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_has_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_has_investigation_identifier";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

xpc_object_t nw_activity_copy_xpc_token(void *a1)
{
  const unsigned __int8 *v1;
  unsigned __int8 *v2;
  xpc_object_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *v11;
  os_log_type_t v12;
  _BOOL4 v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (unsigned __int8 *)v1;
  if (v1)
  {
    if ((v1[132] & 4) != 0)
    {
      v3 = xpc_uuid_create(v1 + 8);
      goto LABEL_4;
    }
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    v22 = "nw_activity_copy_xpc_token";
    v23 = 2082;
    v24 = "Cannot copy xpc token before activation";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_activity_copy_xpc_token";
          v23 = 2082;
          v24 = "Cannot copy xpc token before activation";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v15 = type;
        v16 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446722;
            v22 = "nw_activity_copy_xpc_token";
            v23 = 2082;
            v24 = "Cannot copy xpc token before activation";
            v25 = 2082;
            v26 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_37;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_activity_copy_xpc_token";
          v23 = 2082;
          v24 = "Cannot copy xpc token before activation";
          _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446466;
          v22 = "nw_activity_copy_xpc_token";
          v23 = 2082;
          v24 = "Cannot copy xpc token before activation";
          _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
        }
      }
      goto LABEL_36;
    }
  }
  else
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v22 = "nw_activity_copy_xpc_token";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_activity_copy_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v19)
      {
        v11 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v12 = type;
        v13 = os_log_type_enabled(v7, type);
        if (v11)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v22 = "nw_activity_copy_xpc_token";
            v23 = 2082;
            v24 = v11;
            _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v11);
          goto LABEL_37;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_activity_copy_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v22 = "nw_activity_copy_xpc_token";
          _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
LABEL_36:

    }
  }
LABEL_37:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_4:

  return v3;
}

void sub_18390DACC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_activity_get_activation_time(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  void *v11;
  os_log_type_t v12;
  char *v13;
  os_log_type_t v14;
  _BOOL4 v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  os_log_type_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((*((_BYTE *)v1 + 132) & 4) != 0)
    {
      if ((*((_BYTE *)v1 + 132) & 2) == 0)
      {
        v3 = *((_QWORD *)v1 + 4);
        goto LABEL_5;
      }
      __nwlog_obj();
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v27 = "nw_activity_get_activation_time";
      v28 = 2082;
      v29 = "Cannot get activation time from lightweight representation of an activity";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v24 = 0;
      if (__nwlog_fault(v6, &type, &v24))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v7 = objc_claimAutoreleasedReturnValue();
          v12 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            v28 = 2082;
            v29 = "Cannot get activation time from lightweight representation of an activity";
            _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
          }
LABEL_53:

          goto LABEL_54;
        }
        if (!v24)
        {
          __nwlog_obj();
          v7 = objc_claimAutoreleasedReturnValue();
          v23 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            v28 = 2082;
            v29 = "Cannot get activation time from lightweight representation of an activity";
            _os_log_impl(&dword_182FBE000, v7, v23, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_53;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        v20 = os_log_type_enabled(v7, type);
        if (!backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            v28 = 2082;
            v29 = "Cannot get activation time from lightweight representation of an activity";
            _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_53;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446722;
          v27 = "nw_activity_get_activation_time";
          v28 = 2082;
          v29 = "Cannot get activation time from lightweight representation of an activity";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v19, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }
        goto LABEL_35;
      }
    }
    else
    {
      __nwlog_obj();
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v27 = "nw_activity_get_activation_time";
      v28 = 2082;
      v29 = "Cannot get activation time before activation";
      v6 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v24 = 0;
      if (__nwlog_fault(v6, &type, &v24))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v7 = objc_claimAutoreleasedReturnValue();
          v10 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            v28 = 2082;
            v29 = "Cannot get activation time before activation";
            _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
          }
          goto LABEL_53;
        }
        if (!v24)
        {
          __nwlog_obj();
          v7 = objc_claimAutoreleasedReturnValue();
          v22 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            v28 = 2082;
            v29 = "Cannot get activation time before activation";
            _os_log_impl(&dword_182FBE000, v7, v22, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_53;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        v18 = os_log_type_enabled(v7, type);
        if (!backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            v28 = 2082;
            v29 = "Cannot get activation time before activation";
            _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
          }
          goto LABEL_53;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446722;
          v27 = "nw_activity_get_activation_time";
          v28 = 2082;
          v29 = "Cannot get activation time before activation";
          v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }
LABEL_35:

        free(backtrace_string);
      }
    }
  }
  else
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_activity_get_activation_time";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v6, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_get_activation_time";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v24)
      {
        v13 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v14 = type;
        v15 = os_log_type_enabled(v7, type);
        if (v13)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_get_activation_time";
            v28 = 2082;
            v29 = v13;
            _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v13);
          goto LABEL_54;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_get_activation_time";
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_get_activation_time";
          _os_log_impl(&dword_182FBE000, v7, v21, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_53;
    }
  }
LABEL_54:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_5:

  return v3;
}

uint64_t nw_activity_get_fragments_quenched(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  void *v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  _QWORD aBlock[4];
  os_unfair_lock_s *v15;
  _BYTE *v16;
  void *v17;
  char v18;
  os_log_type_t type;
  _BYTE buf[24];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v21 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_activity_get_fragments_quenched_block_invoke;
    aBlock[3] = &unk_1E14ACE40;
    v16 = buf;
    v15 = v1;
    v3 = _Block_copy(aBlock);
    v17 = v3;
    nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v2 + 18, (uint64_t)&v17);

    v4 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_activity_get_fragments_quenched";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v18 = 0;
  if (__nwlog_fault(v7, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_get_fragments_quenched";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_activity_get_fragments_quenched";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_get_fragments_quenched";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_get_fragments_quenched";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_3:

  return v4;
}

void sub_18390E51C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_activity_get_underlying_error_domain(void *a1)
{
  unsigned int *v1;
  char *v2;
  NSObject *v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (char *)v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_activity_get_underlying_error_domain";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_underlying_error_domain";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_activity_get_underlying_error_domain";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_underlying_error_domain";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_underlying_error_domain";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v7)
      free(v7);
    goto LABEL_8;
  }
  if ((v1[33] & 8) != 0)
  {
    v4 = v1[29];
    goto LABEL_10;
  }
  if (__nwlog_activity_log::onceToken != -1)
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
  v3 = (id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    v17 = v2;
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning 0 for underlying error domain", buf, 0xCu);
  }

LABEL_8:
  v4 = 0;
LABEL_10:

  return v4;
}

uint64_t nw_activity_get_underlying_error_code(void *a1)
{
  unsigned int *v1;
  char *v2;
  NSObject *v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (char *)v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_activity_get_underlying_error_code";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_activity_get_underlying_error_code";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_underlying_error_code";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v7)
      free(v7);
    goto LABEL_8;
  }
  if ((v1[33] & 8) != 0)
  {
    v4 = v1[30];
    goto LABEL_10;
  }
  if (__nwlog_activity_log::onceToken != -1)
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
  v3 = (id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    v17 = v2;
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning 0 for underlying error code", buf, 0xCu);
  }

LABEL_8:
  v4 = 0;
LABEL_10:

  return v4;
}

uint64_t nw_activity_get_completion_reason(void *a1)
{
  unsigned int *v1;
  char *v2;
  NSObject *v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (char *)v1;
  if (!v1)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v17 = "nw_activity_get_completion_reason";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_completion_reason";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            v17 = "nw_activity_get_completion_reason";
            v18 = 2082;
            v19 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_completion_reason";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          v17 = "nw_activity_get_completion_reason";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_27:
    if (v7)
      free(v7);
    goto LABEL_8;
  }
  if ((v1[33] & 8) != 0)
  {
    v4 = v1[32];
    goto LABEL_10;
  }
  if (__nwlog_activity_log::onceToken != -1)
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
  v3 = (id)gactivityLogObj;
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    v17 = v2;
    _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}@ not complete, returning nw_activity_completion_reason_invalid", buf, 0xCu);
  }

LABEL_8:
  v4 = 0;
LABEL_10:

  return v4;
}

uint64_t __nw_activity_get_fragments_quenched_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(result + 32) + 48);
  return result;
}

void nw_activity_submit_metrics(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  os_unfair_lock_s *v6;
  id v7;
  void *v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  void *v11;
  os_unfair_lock_s *v12;
  void *v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  unsigned __int8 *v18;
  os_unfair_lock_s *v19;
  uint64_t v20;
  int v21;
  uint64_t *v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  void *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  void *v30;
  os_log_type_t v31;
  void *v32;
  os_log_type_t v33;
  char *backtrace_string;
  os_log_type_t v35;
  _BOOL4 v36;
  char *v37;
  os_log_type_t v38;
  _BOOL4 v39;
  os_log_type_t v40;
  _BOOL4 v41;
  void *v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  os_log_type_t v46;
  os_log_type_t v47;
  os_log_type_t v48;
  os_unfair_lock_s *v49;
  void *v50;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  char *v54;
  os_log_type_t v55;
  _BOOL4 v56;
  char *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  os_log_type_t v60;
  os_log_type_t v61;
  void *v62;
  _QWORD v63[4];
  os_unfair_lock_s *v64;
  _BYTE *v65;
  void *v66;
  _QWORD aBlock[4];
  os_unfair_lock_s *v68;
  os_log_type_t *v69;
  uint64_t *v70;
  void *v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  int v75;
  os_log_type_t type[8];
  os_log_type_t *v77;
  uint64_t v78;
  char v79;
  char v80;
  os_log_type_t v81;
  uint8_t buf[22];
  __int16 v83;
  void *v84;
  __int16 v85;
  int v86;
  char v87;
  uint64_t v88;
  _BYTE v89[24];
  int v90;
  uint64_t v91;

  v1 = (void *)MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v91 = *MEMORY[0x1E0C80C00];
  v6 = v1;
  v7 = v3;
  v8 = v7;
  if (!v6)
  {
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
    v27 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v72) = 0;
    if (!__nwlog_fault(v27, type, &v72))
      goto LABEL_105;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if ((_BYTE)v72)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v35 = type[0];
      v36 = os_log_type_enabled(v28, type[0]);
      if (backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v28, v35, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_105:
        if (!v27)
          goto LABEL_40;
LABEL_106:
        free(v27);
        goto LABEL_40;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v35, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v46 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v46, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_104:

    goto LABEL_105;
  }
  if (!v5)
  {
    __nwlog_obj();
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
    v27 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v72) = 0;
    if (!__nwlog_fault(v27, type, &v72))
      goto LABEL_105;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v31 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v31, "%{public}s called with null metric_name", buf, 0xCu);
      }
      goto LABEL_104;
    }
    if (!(_BYTE)v72)
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v47 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v47, "%{public}s called with null metric_name, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_104;
    }
    v37 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v28 = objc_claimAutoreleasedReturnValue();
    v38 = type[0];
    v39 = os_log_type_enabled(v28, type[0]);
    if (!v37)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v38, "%{public}s called with null metric_name, no backtrace", buf, 0xCu);
      }
      goto LABEL_104;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v37;
      _os_log_impl(&dword_182FBE000, v28, v38, "%{public}s called with null metric_name, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_70;
  }
  if (!v7)
  {
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
    v27 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v72) = 0;
    if (!__nwlog_fault(v27, type, &v72))
      goto LABEL_105;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v33 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v33, "%{public}s called with null metrics", buf, 0xCu);
      }
      goto LABEL_104;
    }
    if (!(_BYTE)v72)
    {
      __nwlog_obj();
      v28 = objc_claimAutoreleasedReturnValue();
      v48 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v48, "%{public}s called with null metrics, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_104;
    }
    v37 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v28 = objc_claimAutoreleasedReturnValue();
    v40 = type[0];
    v41 = os_log_type_enabled(v28, type[0]);
    if (!v37)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        _os_log_impl(&dword_182FBE000, v28, v40, "%{public}s called with null metrics, no backtrace", buf, 0xCu);
      }
      goto LABEL_104;
    }
    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v37;
      _os_log_impl(&dword_182FBE000, v28, v40, "%{public}s called with null metrics, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_70:

    free(v37);
    if (!v27)
      goto LABEL_40;
    goto LABEL_106;
  }
  *(_QWORD *)type = 0;
  v77 = type;
  v78 = 0x2020000000;
  v79 = 1;
  v72 = 0;
  v73 = &v72;
  v75 = 0;
  v74 = 0x2020000000;
  v9 = MEMORY[0x1E0C809B0];
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 3221225472;
  aBlock[2] = __nw_activity_submit_metrics_block_invoke;
  aBlock[3] = &unk_1E14A54F0;
  v10 = v6;
  v68 = v10;
  v69 = type;
  v70 = &v72;
  v11 = _Block_copy(aBlock);
  v71 = v11;
  nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v6 + 18, (uint64_t)&v71);

  if (*((_BYTE *)v77 + 24))
  {
    if (*((_DWORD *)v73 + 6) >= 0xBu)
    {
      *(_QWORD *)v89 = 0;
      *(_QWORD *)&v89[8] = v89;
      v90 = 0;
      *(_QWORD *)&v89[16] = 0x2020000000;
      v63[0] = v9;
      v63[1] = 3221225472;
      v63[2] = __nw_activity_submit_metrics_block_invoke_82;
      v63[3] = &unk_1E14ACE40;
      v12 = v10;
      v64 = v12;
      v65 = v89;
      v13 = _Block_copy(v63);
      v66 = v13;
      nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v6 + 18, (uint64_t)&v66);

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        v15 = *(_DWORD *)(*(_QWORD *)&v89[8] + 24);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v12;
        v83 = 2080;
        v84 = v5;
        v85 = 1024;
        v86 = v15;
        _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_INFO, "%{public}s Activity %{public}@ exceeded max client metric count, dropping metric named %s (%u total quenched)", buf, 0x26u);
      }

      _Block_object_dispose(v89, 8);
      goto LABEL_39;
    }
    v62 = 0;
    if (nw_activity_metric_object_is_valid(v8, 0, (const char **)&v62))
    {
      if (__nwlog_metrics_log::onceToken != -1)
        dispatch_once(&__nwlog_metrics_log::onceToken, &__block_literal_global_36_44202);
      v16 = (id)gmetricsLogObj;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138543874;
        *(_QWORD *)&buf[4] = v10;
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v5;
        v83 = 2082;
        v84 = v62;
        _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_INFO, "%{public}@ submitting metrics \"%{public}s\": %{public}s", buf, 0x20u);
      }

      if ((v10[4]._os_unfair_lock_opaque & 0x100) == 0 || !v62)
      {
        if (__nwlog_activity_log::onceToken != -1)
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
        v25 = (id)gactivityLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543362;
          *(_QWORD *)&buf[4] = v10;
          _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}@ not selected for reporting, metrics complete", buf, 0xCu);
        }

        goto LABEL_37;
      }
      if (__nwlog_activity_log::onceToken != -1)
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
      v17 = (id)gactivityLogObj;
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v10;
        _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_DEBUG, "%{public}@ selected for reporting, sending metric report to symptoms", buf, 0xCu);
      }

      bzero(buf, 0x1498uLL);
      v18 = (unsigned __int8 *)v62;
      v19 = v10;
      if (v18)
      {
        v20 = 0;
        *(_OWORD *)buf = *(_OWORD *)&v19[2]._os_unfair_lock_opaque;
        while (1)
        {
          v21 = v5[v20];
          buf[v20 + 16] = v21;
          if (!v21)
            break;
          if (++v20 == 255)
          {
            v87 = 0;
            break;
          }
        }
        v22 = &v88;
        v23 = 4999;
        while (1)
        {
          v24 = *v18;
          *(_BYTE *)v22 = v24;
          if (!v24)
            goto LABEL_29;
          v22 = (uint64_t *)((char *)v22 + 1);
          ++v18;
          if (!--v23)
          {
            *(_BYTE *)v22 = 0;
            goto LABEL_29;
          }
        }
      }
      v49 = v19;
      __nwlog_obj();
      v50 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)v89 = 136446210;
      *(_QWORD *)&v89[4] = "nw_activity_fill_out_client_metric_report";
      v51 = (char *)_os_log_send_and_compose_impl();

      v81 = OS_LOG_TYPE_ERROR;
      v80 = 0;
      if (__nwlog_fault(v51, &v81, &v80))
      {
        if (v81 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v52 = objc_claimAutoreleasedReturnValue();
          v53 = v81;
          if (os_log_type_enabled(v52, v81))
          {
            *(_DWORD *)v89 = 136446210;
            *(_QWORD *)&v89[4] = "nw_activity_fill_out_client_metric_report";
            _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null client_metric", v89, 0xCu);
          }
        }
        else if (v80)
        {
          v57 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v52 = objc_claimAutoreleasedReturnValue();
          v58 = v81;
          v59 = os_log_type_enabled(v52, v81);
          if (v57)
          {
            if (v59)
            {
              *(_DWORD *)v89 = 136446466;
              *(_QWORD *)&v89[4] = "nw_activity_fill_out_client_metric_report";
              *(_WORD *)&v89[12] = 2082;
              *(_QWORD *)&v89[14] = v57;
              _os_log_impl(&dword_182FBE000, v52, v58, "%{public}s called with null client_metric, dumping backtrace:%{public}s", v89, 0x16u);
            }

            free(v57);
            goto LABEL_126;
          }
          if (v59)
          {
            *(_DWORD *)v89 = 136446210;
            *(_QWORD *)&v89[4] = "nw_activity_fill_out_client_metric_report";
            _os_log_impl(&dword_182FBE000, v52, v58, "%{public}s called with null client_metric, no backtrace", v89, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v52 = objc_claimAutoreleasedReturnValue();
          v61 = v81;
          if (os_log_type_enabled(v52, v81))
          {
            *(_DWORD *)v89 = 136446210;
            *(_QWORD *)&v89[4] = "nw_activity_fill_out_client_metric_report";
            _os_log_impl(&dword_182FBE000, v52, v61, "%{public}s called with null client_metric, backtrace limit exceeded", v89, 0xCu);
          }
        }

      }
LABEL_126:
      if (v51)
        free(v51);
      v19 = v49;
LABEL_29:

      if (nw_connection_get_symptom_reporter_handle::once[0] != -1)
        dispatch_once(nw_connection_get_symptom_reporter_handle::once, &__block_literal_global_77956);
      symptom_new();
      symptom_set_qualifier();
      symptom_set_additional_qualifier();
      symptom_send();
LABEL_37:
      if (v62)
        free(v62);
      goto LABEL_39;
    }
    __nwlog_obj();
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = "Invalid metric object submitted";
    v43 = (char *)_os_log_send_and_compose_impl();

    v89[0] = 16;
    v81 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v43, v89, &v81))
    {
      if (v89[0] == 17)
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v45 = v89[0];
        if (os_log_type_enabled(v44, (os_log_type_t)v89[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "Invalid metric object submitted";
          _os_log_impl(&dword_182FBE000, v44, v45, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
        }
      }
      else if (v81)
      {
        v54 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v55 = v89[0];
        v56 = os_log_type_enabled(v44, (os_log_type_t)v89[0]);
        if (v54)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = "Invalid metric object submitted";
            v83 = 2082;
            v84 = v54;
            _os_log_impl(&dword_182FBE000, v44, v55, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v54);
          goto LABEL_118;
        }
        if (v56)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "Invalid metric object submitted";
          _os_log_impl(&dword_182FBE000, v44, v55, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        __nwlog_obj();
        v44 = objc_claimAutoreleasedReturnValue();
        v60 = v89[0];
        if (os_log_type_enabled(v44, (os_log_type_t)v89[0]))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_activity_submit_metrics";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "Invalid metric object submitted";
          _os_log_impl(&dword_182FBE000, v44, v60, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
        }
      }

    }
LABEL_118:
    if (v43)
      free(v43);
    goto LABEL_37;
  }
LABEL_39:

  _Block_object_dispose(&v72, 8);
  _Block_object_dispose(type, 8);
LABEL_40:

}

void sub_18390FE78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  void *v34;
  void *v35;
  void *v36;
  uint64_t v37;

  _Block_object_dispose((const void *)(v37 - 144), 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a34, 8);

  _Unwind_Resume(a1);
}

void __nw_activity_submit_metrics_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  void *v10;
  char *backtrace_string;
  _BOOL4 v12;
  NSObject *v13;
  uint64_t v14;
  char *v15;
  _BOOL4 v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = a1[4];
  if ((*(_BYTE *)(v2 + 132) & 4) == 0)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    v20 = "nw_activity_submit_metrics_block_invoke";
    v21 = 2082;
    v22 = "Cannot submit metrics before activation";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_activity_submit_metrics_block_invoke";
        v21 = 2082;
        v22 = "Cannot submit metrics before activation";
        v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_38:
        _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0x16u);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v12 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          v20 = "nw_activity_submit_metrics_block_invoke";
          v21 = 2082;
          v22 = "Cannot submit metrics before activation";
          v23 = 2082;
          v24 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v6)
        {
LABEL_42:
          *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 0;
          return;
        }
LABEL_41:
        free(v6);
        goto LABEL_42;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_activity_submit_metrics_block_invoke";
        v21 = 2082;
        v22 = "Cannot submit metrics before activation";
        v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_38;
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_activity_submit_metrics_block_invoke";
        v21 = 2082;
        v22 = "Cannot submit metrics before activation";
        v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if ((*(_BYTE *)(v2 + 132) & 8) != 0)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    v20 = "nw_activity_submit_metrics_block_invoke";
    v21 = 2082;
    v22 = "Cannot submit metrics after completion";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_activity_submit_metrics_block_invoke";
        v21 = 2082;
        v22 = "Cannot submit metrics after completion";
        v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
        goto LABEL_38;
      }
    }
    else
    {
      if (v17)
      {
        v15 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        v16 = os_log_type_enabled(v7, type);
        if (v15)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446722;
            v20 = "nw_activity_submit_metrics_block_invoke";
            v21 = 2082;
            v22 = "Cannot submit metrics after completion";
            v23 = 2082;
            v24 = (uint64_t)v15;
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v15);
          if (!v6)
            goto LABEL_42;
          goto LABEL_41;
        }
        if (!v16)
          goto LABEL_39;
        *(_DWORD *)buf = 136446466;
        v20 = "nw_activity_submit_metrics_block_invoke";
        v21 = 2082;
        v22 = "Cannot submit metrics after completion";
        v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_38;
      }
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446466;
        v20 = "nw_activity_submit_metrics_block_invoke";
        v21 = 2082;
        v22 = "Cannot submit metrics after completion";
        v9 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
    goto LABEL_39;
  }
  v3 = *(unsigned int *)(v2 + 112) + 1;
  v4 = v3 << 31 >> 31;
  *(_DWORD *)(v2 + 112) = v3;
  if (v4 != v3 || v4 < 0)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v14 = *(unsigned int *)(a1[4] + 112);
        *(_DWORD *)buf = 136446978;
        v20 = "nw_activity_submit_metrics_block_invoke";
        v21 = 2082;
        v22 = "activity->client_metric_count";
        v23 = 2048;
        v24 = 1;
        v25 = 2048;
        v26 = v14;
        _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
      }

    }
    *(_DWORD *)(a1[4] + 112) = -1;
  }
  *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = *(_DWORD *)(a1[4] + 112);
}

void __nw_activity_submit_metrics_block_invoke_82(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(unsigned int *)(v2 + 48) + 1;
  v4 = v3 << 31 >> 31;
  *(_DWORD *)(v2 + 48) = v3;
  if (v4 != v3 || v4 < 0)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        v6 = *(unsigned int *)(*(_QWORD *)(a1 + 32) + 48);
        v7 = 136446978;
        v8 = "nw_activity_submit_metrics_block_invoke";
        v9 = 2082;
        v10 = "activity->fragments_quenched";
        v11 = 2048;
        v12 = 1;
        v13 = 2048;
        v14 = v6;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", (uint8_t *)&v7, 0x2Au);
      }

    }
    *(_DWORD *)(*(_QWORD *)(a1 + 32) + 48) = -1;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 48);
}

void nw_activity_retrieve_metrics(void *a1, void *a2, void *a3)
{
  _BYTE *v5;
  id v6;
  id v7;
  void *v8;
  NSObject *v9;
  qos_class_t v10;
  void *v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  NSObject *v15;
  NSObject *v16;
  dispatch_block_t v17;
  void *v18;
  char *v19;
  NSObject *v20;
  os_log_type_t v21;
  void *v22;
  os_log_type_t v23;
  void *v24;
  os_log_type_t v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  void *v32;
  char *v33;
  NSObject *v34;
  os_log_type_t v35;
  os_log_type_t v36;
  _BOOL4 v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  char *v41;
  os_log_type_t v42;
  _BOOL4 v43;
  os_log_type_t v44;
  os_log_type_t v45;
  os_log_type_t v46;
  os_log_type_t v47;
  os_log_type_t v48;
  NSObject *v49;
  dispatch_block_t v50;
  NSObject *v51;
  dispatch_block_t v52;
  _QWORD block[4];
  NSObject *v54;
  _BYTE *v55;
  id v56;
  qos_class_t v57;
  _QWORD v58[4];
  id v59;
  _QWORD v60[4];
  id v61;
  char v62;
  os_log_type_t v63;
  uint8_t buf[4];
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  char *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v65 = "nw_activity_retrieve_metrics";
    v19 = (char *)_os_log_send_and_compose_impl();

    v63 = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v19, &v63, &v62))
      goto LABEL_87;
    if (v63 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v21 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v21, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v62)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v27 = v63;
      v28 = os_log_type_enabled(v20, v63);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v65 = "nw_activity_retrieve_metrics";
          v66 = 2082;
          v67 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v20, v27, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_87:
        if (!v19)
          goto LABEL_22;
LABEL_88:
        free(v19);
        goto LABEL_22;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v27, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v44 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v44, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_86:

    goto LABEL_87;
  }
  if (!v6)
  {
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v65 = "nw_activity_retrieve_metrics";
    v19 = (char *)_os_log_send_and_compose_impl();

    v63 = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v19, &v63, &v62))
      goto LABEL_87;
    if (v63 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v23 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v23, "%{public}s called with null callback_queue", buf, 0xCu);
      }
      goto LABEL_86;
    }
    if (!v62)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v45 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v45, "%{public}s called with null callback_queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_86;
    }
    v29 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v20 = objc_claimAutoreleasedReturnValue();
    v30 = v63;
    v31 = os_log_type_enabled(v20, v63);
    if (!v29)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s called with null callback_queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_86;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      v65 = "nw_activity_retrieve_metrics";
      v66 = 2082;
      v67 = v29;
      _os_log_impl(&dword_182FBE000, v20, v30, "%{public}s called with null callback_queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
  if (!v7)
  {
    __nwlog_obj();
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v65 = "nw_activity_retrieve_metrics";
    v19 = (char *)_os_log_send_and_compose_impl();

    v63 = OS_LOG_TYPE_ERROR;
    v62 = 0;
    if (!__nwlog_fault(v19, &v63, &v62))
      goto LABEL_87;
    if (v63 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v25 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v25, "%{public}s called with null completion", buf, 0xCu);
      }
      goto LABEL_86;
    }
    if (!v62)
    {
      __nwlog_obj();
      v20 = objc_claimAutoreleasedReturnValue();
      v46 = v63;
      if (os_log_type_enabled(v20, v63))
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v46, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_86;
    }
    v29 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v20 = objc_claimAutoreleasedReturnValue();
    v36 = v63;
    v37 = os_log_type_enabled(v20, v63);
    if (!v29)
    {
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v65 = "nw_activity_retrieve_metrics";
        _os_log_impl(&dword_182FBE000, v20, v36, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
      goto LABEL_86;
    }
    if (v37)
    {
      *(_DWORD *)buf = 136446466;
      v65 = "nw_activity_retrieve_metrics";
      v66 = 2082;
      v67 = v29;
      _os_log_impl(&dword_182FBE000, v20, v36, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_57:

    free(v29);
    if (!v19)
      goto LABEL_22;
    goto LABEL_88;
  }
  if (__nwlog_activity_log::onceToken != -1)
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
  v9 = (id)gactivityLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138543362;
    v65 = v5;
    _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_DEBUG, "%{public}@ retrieving metrics", buf, 0xCu);
  }

  v10 = qos_class_self();
  if ((v5[132] & 2) != 0)
  {
    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v15 = (id)gactivityLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138543362;
      v65 = v5;
      _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_INFO, "%{public}@ speculatively retrieving metrics", buf, 0xCu);
    }

    goto LABEL_21;
  }
  if ((v5[132] & 4) != 0)
  {
    if ((v5[132] & 8) == 0)
    {
      __nwlog_obj();
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446466;
      v65 = "nw_activity_retrieve_metrics";
      v66 = 2082;
      v67 = "Cannot retrieve metrics before completion";
      v12 = (char *)_os_log_send_and_compose_impl();

      v63 = OS_LOG_TYPE_ERROR;
      v62 = 0;
      if (__nwlog_fault(v12, &v63, &v62))
      {
        if (v63 == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v13 = objc_claimAutoreleasedReturnValue();
          v14 = v63;
          if (os_log_type_enabled(v13, v63))
          {
            *(_DWORD *)buf = 136446466;
            v65 = "nw_activity_retrieve_metrics";
            v66 = 2082;
            v67 = "Cannot retrieve metrics before completion";
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
          }
        }
        else if (v62)
        {
          v41 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v13 = objc_claimAutoreleasedReturnValue();
          v42 = v63;
          v43 = os_log_type_enabled(v13, v63);
          if (v41)
          {
            if (v43)
            {
              *(_DWORD *)buf = 136446722;
              v65 = "nw_activity_retrieve_metrics";
              v66 = 2082;
              v67 = "Cannot retrieve metrics before completion";
              v68 = 2082;
              v69 = v41;
              _os_log_impl(&dword_182FBE000, v13, v42, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v41);
            goto LABEL_104;
          }
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            v65 = "nw_activity_retrieve_metrics";
            v66 = 2082;
            v67 = "Cannot retrieve metrics before completion";
            _os_log_impl(&dword_182FBE000, v13, v42, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
          }
        }
        else
        {
          __nwlog_obj();
          v13 = objc_claimAutoreleasedReturnValue();
          v48 = v63;
          if (os_log_type_enabled(v13, v63))
          {
            *(_DWORD *)buf = 136446466;
            v65 = "nw_activity_retrieve_metrics";
            v66 = 2082;
            v67 = "Cannot retrieve metrics before completion";
            _os_log_impl(&dword_182FBE000, v13, v48, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
          }
        }

      }
LABEL_104:
      if (v12)
        free(v12);
      v58[0] = MEMORY[0x1E0C809B0];
      v58[1] = 3221225472;
      v58[2] = __nw_activity_retrieve_metrics_block_invoke_87;
      v58[3] = &unk_1E14AC390;
      v59 = v8;
      v51 = v6;
      v52 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, v10, 0, v58);
      dispatch_async(v51, v52);

      goto LABEL_22;
    }
LABEL_21:
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __nw_activity_retrieve_metrics_block_invoke_2;
    block[3] = &unk_1E14A5540;
    v16 = v6;
    v54 = v16;
    v57 = v10;
    v56 = v8;
    v55 = v5;
    v17 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, v10, 0, block);
    dispatch_async(v16, v17);

    goto LABEL_22;
  }
  __nwlog_obj();
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446466;
  v65 = "nw_activity_retrieve_metrics";
  v66 = 2082;
  v67 = "Cannot retrieve metrics before activation";
  v33 = (char *)_os_log_send_and_compose_impl();

  v63 = OS_LOG_TYPE_ERROR;
  v62 = 0;
  if (__nwlog_fault(v33, &v63, &v62))
  {
    if (v63 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v35 = v63;
      if (os_log_type_enabled(v34, v63))
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl(&dword_182FBE000, v34, v35, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }
    else if (v62)
    {
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v39 = v63;
      v40 = os_log_type_enabled(v34, v63);
      if (v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446722;
          v65 = "nw_activity_retrieve_metrics";
          v66 = 2082;
          v67 = "Cannot retrieve metrics before activation";
          v68 = 2082;
          v69 = v38;
          _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v38);
        goto LABEL_98;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl(&dword_182FBE000, v34, v39, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
    }
    else
    {
      __nwlog_obj();
      v34 = objc_claimAutoreleasedReturnValue();
      v47 = v63;
      if (os_log_type_enabled(v34, v63))
      {
        *(_DWORD *)buf = 136446466;
        v65 = "nw_activity_retrieve_metrics";
        v66 = 2082;
        v67 = "Cannot retrieve metrics before activation";
        _os_log_impl(&dword_182FBE000, v34, v47, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
    }

  }
LABEL_98:
  if (v33)
    free(v33);
  v60[0] = MEMORY[0x1E0C809B0];
  v60[1] = 3221225472;
  v60[2] = __nw_activity_retrieve_metrics_block_invoke;
  v60[3] = &unk_1E14AC390;
  v61 = v8;
  v49 = v6;
  v50 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, v10, 0, v60);
  dispatch_async(v49, v50);

LABEL_22:
}

void sub_1839113C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void __nw_activity_retrieve_metrics_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
  (*(void (**)(uint64_t, _QWORD))(v1 + 16))(v1, 0);

}

void sub_183911440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void __nw_activity_retrieve_metrics_block_invoke_87(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
  (*(void (**)(uint64_t, _QWORD))(v1 + 16))(v1, 0);

}

void sub_1839114B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void __nw_activity_retrieve_metrics_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  _DWORD *v7;
  _QWORD v8[4];
  id v9;
  id v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  void (*v16)(uint64_t);
  id v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13 = &v12;
  v14 = 0x3032000000;
  v15 = __Block_byref_object_copy__57859;
  v16 = __Block_byref_object_dispose__57860;
  v17 = 0;
  gotLoadHelper_x20__OBJC_CLASS___NWActivityXPC(COERCE_DOUBLE(0x3032000000));
  if (objc_opt_class())
  {
    v3 = objc_msgSend(objc_alloc(*(Class *)(v1 + 736)), "initWithQueue:qosClass:", *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 56));
    v4 = (void *)v13[5];
    v13[5] = v3;

  }
  if (v13[5])
  {
    v18 = 0uLL;
    nw_activity_get_token(*(void **)(a1 + 40), &v18);
    v5 = (void *)v13[5];
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = __nw_activity_retrieve_metrics_block_invoke_89;
    v8[3] = &unk_1E14A5518;
    v9 = *(id *)(a1 + 40);
    v10 = *(id *)(a1 + 48);
    v11 = &v12;
    objc_msgSend(v5, "retrieveMetricsForActivity:completion:", &v18, v8);

  }
  else
  {
    v6 = *(_QWORD *)(a1 + 48);
    v7 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 20);
    (*(void (**)(uint64_t, _QWORD, _DWORD *, uint64_t))(v6 + 16))(v6, 0, v7, 1);

  }
  _Block_object_dispose(&v12, 8);

}

void sub_183911654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21)
{
  void *v21;

  _Block_object_dispose(&a16, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__57859(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__57860(uint64_t a1)
{

}

void __nw_activity_retrieve_metrics_block_invoke_89(_QWORD *a1, void *a2, int a3)
{
  id v5;
  void *v6;
  NSObject *v7;
  uint64_t v8;
  unint64_t i;
  void *v10;
  void *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *posix_error;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  int v21;
  uint64_t v22;
  __int16 v23;
  void *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = v5;
  if (v5 && !a3 && objc_msgSend(v5, "count"))
  {
    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v7 = (id)gactivityLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = a1[4];
      v21 = 138412546;
      v22 = v8;
      v23 = 2112;
      v24 = v6;
      _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_DEBUG, "%@ got results: %@", (uint8_t *)&v21, 0x16u);
    }

    for (i = 0; i < objc_msgSend(v6, "count"); ++i)
    {
      objc_msgSend(v6, "count");
      objc_msgSend(v6, "objectAtIndex:", i);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      v11 = (void *)_CFXPCCreateXPCObjectFromCFObject();
      (*(void (**)(void))(a1[5] + 16))();

    }
    v18 = a1[6];
    v16 = a1 + 6;
    objc_msgSend(*(id *)(*(_QWORD *)(v18 + 8) + 40), "cancel");
  }
  else
  {
    if (__nwlog_activity_log::onceToken != -1)
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44172);
    v12 = (id)gactivityLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      v13 = a1[4];
      v21 = 138412802;
      v22 = v13;
      v23 = 2112;
      v24 = v6;
      v25 = 1024;
      v26 = a3;
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%@ failed lookup, results: %@, error: %{errno}d", (uint8_t *)&v21, 0x1Cu);
    }

    v14 = a1[5];
    posix_error = nw_error_create_posix_error(a3);
    (*(void (**)(uint64_t, _QWORD, _DWORD *, uint64_t))(v14 + 16))(v14, 0, posix_error, 1);

    v17 = a1[6];
    v16 = a1 + 6;
    objc_msgSend(*(id *)(*(_QWORD *)(v17 + 8) + 40), "cancel");
  }
  v19 = *(_QWORD *)(*v16 + 8);
  v20 = *(void **)(v19 + 40);
  *(_QWORD *)(v19 + 40) = 0;

}

void sub_183911930(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_activity_is_complete(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[132] >> 3) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_is_complete";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_complete";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_is_complete";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_complete";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_complete";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

const char *nw_activity_label_to_string(int a1, int a2)
{
  const char *result;
  const char *v3;
  const char *v4;
  const char *v5;

  switch(a1)
  {
    case 11:
      if ((a2 - 1) >= 9)
        goto LABEL_99;
      return off_1E14A6B78[a2 - 1];
    case 12:
      if ((a2 - 1) >= 4)
        goto LABEL_99;
      return off_1E14A6BC0[a2 - 1];
    case 13:
      if ((a2 - 1) >= 3)
        goto LABEL_99;
      return off_1E14A6BE0[a2 - 1];
    case 14:
      if ((a2 - 1) >= 0xD)
        goto LABEL_99;
      return off_1E14A6BF8[a2 - 1];
    case 15:
      if ((a2 - 1) >= 0xA)
        goto LABEL_99;
      return off_1E14A6C60[a2 - 1];
    case 16:
      if ((a2 - 1) >= 3)
        goto LABEL_99;
      return off_1E14A6CB0[a2 - 1];
    case 17:
      if ((a2 - 1) >= 5)
        goto LABEL_99;
      return off_1E14A6CC8[a2 - 1];
    case 18:
      if ((a2 - 1) >= 0x12)
        goto LABEL_99;
      return off_1E14A6CF0[a2 - 1];
    case 19:
    case 20:
    case 56:
    case 57:
      if (a2 == 1)
        return "invalid_max";
      else
        return "invalid";
    case 21:
      if ((a2 - 1) >= 0x18)
        goto LABEL_99;
      return off_1E14A6D80[a2 - 1];
    case 22:
      if ((a2 - 1) >= 7)
        goto LABEL_99;
      return off_1E14A6E40[a2 - 1];
    case 23:
      if ((a2 - 1) >= 0x19)
        goto LABEL_99;
      return off_1E14A6E78[a2 - 1];
    case 24:
      if ((a2 - 1) >= 3)
        goto LABEL_99;
      return off_1E14A6F40[a2 - 1];
    case 25:
    case 26:
      if ((a2 - 1) >= 3)
        goto LABEL_99;
      return off_1E14A6F58[a2 - 1];
    case 27:
    case 28:
    case 29:
      if ((a2 - 1) >= 0x43)
        goto LABEL_99;
      return off_1E14A6F70[a2 - 1];
    case 30:
      if ((a2 - 1) >= 5)
        goto LABEL_99;
      return off_1E14A7188[a2 - 1];
    case 31:
      v3 = "invalid";
      v4 = "captive_probe";
      goto LABEL_64;
    case 32:
      if ((a2 - 1) >= 0xD)
        goto LABEL_99;
      return off_1E14A71B0[a2 - 1];
    case 33:
      if ((a2 - 1) >= 4)
        goto LABEL_99;
      return off_1E14A7218[a2 - 1];
    case 34:
      if ((a2 - 1) >= 0xC)
        goto LABEL_99;
      return off_1E14A7238[a2 - 1];
    case 35:
      if ((a2 - 1) >= 3)
        goto LABEL_99;
      return off_1E14A7298[a2 - 1];
    case 36:
      if ((a2 - 1) >= 0xB)
        goto LABEL_99;
      return off_1E14A72B0[a2 - 1];
    case 37:
      if ((a2 - 1) >= 0xE)
        goto LABEL_99;
      return off_1E14A7308[a2 - 1];
    case 38:
      if ((a2 - 1) >= 4)
        goto LABEL_99;
      return off_1E14A7378[a2 - 1];
    case 39:
      v3 = "invalid";
      v4 = "session";
      goto LABEL_64;
    case 40:
      if ((a2 - 1) >= 8)
        goto LABEL_99;
      return off_1E14A7398[a2 - 1];
    case 41:
      if ((a2 - 1) >= 7)
        goto LABEL_99;
      return off_1E14A73D8[a2 - 1];
    case 42:
      if ((a2 - 1) >= 4)
        goto LABEL_99;
      return off_1E14A7410[a2 - 1];
    case 43:
      if ((a2 - 1) >= 0x11)
        goto LABEL_99;
      return off_1E14A7430[a2 - 1];
    case 44:
      if ((a2 - 1) >= 8)
        goto LABEL_99;
      return off_1E14A74B8[a2 - 1];
    case 45:
      if ((a2 - 1) >= 0xA)
        goto LABEL_99;
      return off_1E14A74F8[a2 - 1];
    case 46:
      v3 = "invalid";
      v4 = "stereo_pair_volume_sync";
LABEL_64:
      if (a2 == 1)
        v3 = v4;
      if (a2 == 2)
        return "invalid_max";
      else
        return v3;
    case 47:
      if ((a2 - 1) >= 0xE)
        goto LABEL_99;
      result = off_1E14A7548[a2 - 1];
      break;
    case 48:
      if ((a2 - 1) >= 4)
        goto LABEL_99;
      result = off_1E14A75B8[a2 - 1];
      break;
    case 49:
      if ((a2 - 1) >= 0xB)
        goto LABEL_99;
      result = off_1E14A75D8[a2 - 1];
      break;
    case 50:
      if ((a2 - 1) >= 3)
        goto LABEL_99;
      result = off_1E14A7630[a2 - 1];
      break;
    case 51:
      if ((a2 - 1) >= 3)
        goto LABEL_99;
      result = off_1E14A7648[a2 - 1];
      break;
    case 52:
      if ((a2 - 1) >= 8)
        goto LABEL_99;
      result = off_1E14A7660[a2 - 1];
      break;
    case 53:
      if ((a2 - 1) >= 6)
        goto LABEL_99;
      result = off_1E14A76A0[a2 - 1];
      break;
    case 54:
      if ((a2 - 1) >= 5)
        goto LABEL_99;
      result = off_1E14A76D0[a2 - 1];
      break;
    case 55:
      if ((a2 - 1) >= 5)
        goto LABEL_99;
      result = off_1E14A76F8[a2 - 1];
      break;
    case 58:
      if ((a2 - 1) >= 0x12)
        goto LABEL_99;
      result = off_1E14A7720[a2 - 1];
      break;
    case 59:
      if ((a2 - 1) >= 5)
        goto LABEL_99;
      result = off_1E14A77B0[a2 - 1];
      break;
    case 60:
      if ((a2 - 1) >= 0xC)
LABEL_99:
        result = "invalid";
      else
        result = off_1E14A77D8[a2 - 1];
      break;
    default:
      if ((a1 - 1) >= 0xA)
        v5 = "invalid";
      else
        v5 = "reserved";
      if ((a1 - 900) >= 0x64)
        result = v5;
      else
        result = "experimental";
      break;
  }
  return result;
}

BOOL nw_activity_copy_redacted_description(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  size_t v4;
  const void *v5;
  void *v6;
  _BOOL8 result;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  void *v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  uint8_t *v22;
  uint64_t v23;
  char v24;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  size_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v27 = "nw_activity_copy_redacted_description";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v24 = 0;
    if (__nwlog_fault(v9, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_copy_redacted_description";
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v19 = type;
        v20 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            v27 = "nw_activity_copy_redacted_description";
            v28 = 2082;
            v29 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_copy_redacted_description";
          _os_log_impl(&dword_182FBE000, v10, v19, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v10 = objc_claimAutoreleasedReturnValue();
        v21 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          v27 = "nw_activity_copy_redacted_description";
          _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_29:
    if (v9)
      free(v9);
    v6 = 0;
    goto LABEL_6;
  }
  objc_msgSend(v1, "redactedDescription");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "length");
  if (!v4)
  {
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v27 = "nw_activity_copy_redacted_description";
    LODWORD(v23) = 12;
    v22 = buf;
    v13 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v13);
    if (result)
      goto LABEL_32;
    free(v13);
  }
  v5 = (const void *)objc_msgSend(v3, "UTF8String", v22, v23);
  if (v4 == -1)
  {
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v27 = "strict_calloc";
    v15 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v15);
    if (result)
      goto LABEL_32;
    free(v15);
  }
  v6 = malloc_type_calloc(1uLL, v4 + 1, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_5:
    memcpy(v6, v5, v4);

LABEL_6:
    return (BOOL)v6;
  }
  __nwlog_obj();
  v16 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v27 = "strict_calloc";
  v28 = 2048;
  v29 = 1;
  v30 = 2048;
  v31 = v4 + 1;
  v17 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_5;
  }
LABEL_32:
  __break(1u);
  return result;
}

void sub_1839125F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__int128 *nw_path_ipv6_default_address()
{
  return &xmmword_183BA8C20;
}

__int128 *nw_path_ipv4_default_address()
{
  return &xmmword_183C6F0E8;
}

uint64_t nw_path_is_endpoint_localhost(void *a1)
{
  id v1;
  void *v2;
  NSObject *v3;
  int v4;
  NSObject *v5;
  const char *v6;
  BOOL v7;
  const sockaddr *address;
  int sa_family;
  int v10;
  int v11;
  uint64_t v12;

  v1 = a1;
  v2 = v1;
  if (!v1)
    goto LABEL_20;
  v3 = v1;
  v4 = -[NSObject type](v3, "type");

  if (v4 == 1)
  {
    address = nw_endpoint_get_address(v3);
    sa_family = address->sa_family;
    if (sa_family == 2)
    {
      if (address->sa_len < 0x10u)
        goto LABEL_20;
      v10 = *(_DWORD *)&address->sa_data[2];
      v11 = 16777343;
    }
    else
    {
      if (sa_family != 30
        || address->sa_len < 0x1Cu
        || *(_DWORD *)&address->sa_data[6]
        || *(_DWORD *)&address->sa_data[10]
        || *(_DWORD *)&address[1].sa_len)
      {
        goto LABEL_20;
      }
      v10 = *(_DWORD *)&address[1].sa_data[2];
      v11 = 0x1000000;
    }
    v7 = v10 == v11;
    goto LABEL_17;
  }
  if (v4 != 2)
  {
LABEL_20:
    v12 = 0;
    goto LABEL_21;
  }
  v5 = v3;
  v6 = (const char *)-[NSObject hostname](v5, "hostname");

  if (!strcasecmp("localhost", v6))
  {
    v12 = 1;
    goto LABEL_21;
  }
  v7 = strcasecmp("localhost.", v6) == 0;
LABEL_17:
  v12 = v7;
LABEL_21:

  return v12;
}

void sub_18391274C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_path_evaluator_add_endpoint_to_necp_message_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t a5)
{
  size_t v5;
  BOOL v6;
  void *v7;
  uint64_t v8;

  v5 = *(unsigned __int8 *)(a1 + 40) - a3 - 8;
  v6 = v5 > a5;
  if (v5 >= a5)
    v5 = a5;
  v7 = (void *)(*(_QWORD *)(a1 + 32) + a3 + 8);
  v8 = !v6;
  memcpy(v7, __src, v5);
  return v8;
}

uint64_t __Block_byref_object_copy__58214(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__58215(uint64_t a1)
{

}

uint64_t nw_path_struct_size_for_browse_descriptor(void *a1, unint64_t *a2)
{
  NSObject *v3;
  int v4;
  const char *bonjour_service_type;
  const char *bonjour_service_domain;
  const char *v7;
  size_t v8;
  unint64_t v9;
  uint64_t v10;
  const char *application_service_name;
  uint64_t bundle_id;
  const char *v13;
  size_t v14;
  size_t v15;
  NSObject *v16;
  NSObject *v17;
  size_t size;
  id v19;
  char *v20;
  NSObject *v21;
  os_log_type_t v22;
  unint64_t v23;
  char v24;
  unsigned __int8 v25;
  char *backtrace_string;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  char v31;
  os_log_type_t type;
  _QWORD v33[5];
  _BYTE buf[32];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = nw_browse_descriptor_get_type(v3);
  if (v4 == 2)
  {
    application_service_name = nw_browse_descriptor_get_application_service_name(v3);
    bundle_id = nw_browse_descriptor_get_bundle_id(v3);
    v13 = (const char *)bundle_id;
    if (application_service_name)
    {
      v14 = strlen(application_service_name) + 23;
      if (v13)
      {
LABEL_12:
        v15 = strlen(v13) + 1;
LABEL_26:
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        *(_QWORD *)&buf[24] = 0;
        v33[0] = MEMORY[0x1E0C809B0];
        v33[1] = 3221225472;
        v33[2] = ___ZL41nw_path_struct_size_for_browse_descriptorPU34objcproto23OS_nw_browse_descriptor8NSObjectPm_block_invoke;
        v33[3] = &unk_1E14A7900;
        v33[4] = buf;
        nw_browse_descriptor_enumerate_device_filters(v3, v33);
        v23 = v14 + v15 + *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
        if (a2)
          *a2 = v23;
        if (v23 <= 0x1C)
          v10 = 28;
        else
          v10 = v23;
        _Block_object_dispose(buf, 8);
        goto LABEL_55;
      }
    }
    else
    {
      v14 = 23;
      if (bundle_id)
        goto LABEL_12;
    }
    v15 = 1;
    goto LABEL_26;
  }
  if (v4 == 1)
  {
    bonjour_service_type = nw_browse_descriptor_get_bonjour_service_type(v3);
    bonjour_service_domain = nw_browse_descriptor_get_bonjour_service_domain(v3);
    v7 = bonjour_service_domain;
    if (bonjour_service_type)
    {
      v8 = strlen(bonjour_service_type) + 9;
      if (v7)
        goto LABEL_5;
    }
    else
    {
      v8 = 9;
      if (bonjour_service_domain)
      {
LABEL_5:
        v9 = strlen(v7) + 1 + v8;
        if (!a2)
          goto LABEL_7;
        goto LABEL_6;
      }
    }
    v9 = v8 + 1;
    if (!a2)
    {
LABEL_7:
      if (v9 <= 0x1C)
        v10 = 28;
      else
        v10 = v9;
      goto LABEL_55;
    }
LABEL_6:
    *a2 = v9;
    goto LABEL_7;
  }
  if (!nw_browse_descriptor_is_custom_type(v3))
  {
LABEL_54:
    v10 = 28;
    goto LABEL_55;
  }
  v16 = nw_browse_descriptor_copy_custom_data(v3);
  v17 = v16;
  if (!v16)
  {
LABEL_53:

    goto LABEL_54;
  }
  size = dispatch_data_get_size(v16);
  if (size >= 0x401)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_path_struct_size_for_browse_descriptor";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1024;
    v20 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (__nwlog_fault(v20, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v21 = (id)gLogObj;
        v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_struct_size_for_browse_descriptor";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1024;
          _os_log_impl(&dword_182FBE000, v21, v22, "%{public}s Custom data size must be no larger than %d", buf, 0x12u);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v27 = type;
        v28 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_path_struct_size_for_browse_descriptor";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1024;
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_51;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_struct_size_for_browse_descriptor";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1024;
          _os_log_impl(&dword_182FBE000, v21, v27, "%{public}s Custom data size must be no larger than %d, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        __nwlog_obj();
        v21 = objc_claimAutoreleasedReturnValue();
        v29 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_struct_size_for_browse_descriptor";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1024;
          _os_log_impl(&dword_182FBE000, v21, v29, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
LABEL_51:
    if (v20)
      free(v20);
    goto LABEL_53;
  }
  v24 = -9;
  if (size < 0xF7)
    v24 = size;
  v25 = v24 + 8;
  if (a2)
    *a2 = v25;
  if (v25 <= 0x1Cu)
    v10 = 28;
  else
    v10 = v25;

LABEL_55:
  return v10;
}

uint64_t nw_path_struct_size_for_advertise_descriptor(void *a1, unint64_t *a2)
{
  NSObject *v3;
  int type;
  const char *bonjour_name;
  const char *bonjour_type;
  const char *bonjour_domain;
  size_t v8;
  size_t v9;
  size_t v10;
  const char *application_service_name;
  uint64_t bundle_id;
  const char *v13;
  size_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t txt_record;
  uint64_t v18;
  uint64_t v20;

  v3 = a1;
  type = nw_advertise_descriptor_get_type(v3);
  if (type != 2)
  {
    if (type != 1)
    {
      v16 = 28;
      goto LABEL_22;
    }
    bonjour_name = (const char *)nw_advertise_descriptor_get_bonjour_name(v3);
    bonjour_type = (const char *)nw_advertise_descriptor_get_bonjour_type(v3);
    bonjour_domain = (const char *)nw_advertise_descriptor_get_bonjour_domain(v3);
    if (bonjour_name)
    {
      v8 = strlen(bonjour_name) + 9;
      if (bonjour_type)
        goto LABEL_5;
    }
    else
    {
      v8 = 9;
      if (bonjour_type)
      {
LABEL_5:
        v9 = strlen(bonjour_type) + 1;
        if (bonjour_domain)
        {
LABEL_6:
          v10 = strlen(bonjour_domain) + 1;
          goto LABEL_15;
        }
LABEL_14:
        v10 = 1;
LABEL_15:
        v20 = 0;
        txt_record = nw_advertise_descriptor_get_txt_record(v3, &v20);
        v18 = v20;
        if (!txt_record)
          v18 = 0;
        v15 = v9 + v8 + v10 + v18;
        if (!a2)
          goto LABEL_19;
        goto LABEL_18;
      }
    }
    v9 = 1;
    if (bonjour_domain)
      goto LABEL_6;
    goto LABEL_14;
  }
  application_service_name = nw_advertise_descriptor_get_application_service_name(v3);
  bundle_id = nw_advertise_descriptor_get_bundle_id(v3);
  v13 = (const char *)bundle_id;
  if (application_service_name)
  {
    v14 = strlen(application_service_name) + 17;
    if (v13)
      goto LABEL_9;
  }
  else
  {
    v14 = 17;
    if (bundle_id)
    {
LABEL_9:
      v15 = v14 + strlen(v13) + 1;
      if (!a2)
        goto LABEL_19;
LABEL_18:
      *a2 = v15;
      goto LABEL_19;
    }
  }
  v15 = v14 + 1;
  if (a2)
    goto LABEL_18;
LABEL_19:
  if (v15 <= 0x1C)
    v16 = 28;
  else
    v16 = v15;
LABEL_22:

  return v16;
}

uint64_t __nw_path_create_necp_parameters_block_invoke_2(uint64_t a1)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 73;
  return 1;
}

uint64_t __nw_path_create_necp_parameters_block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  unsigned int length;
  const void *bytes_ptr;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  unint64_t v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  uint64_t v20;
  id v21;
  void *v22;
  char *v23;
  NSObject *v24;
  os_log_type_t v25;
  void *v26;
  os_log_type_t v27;
  void *v28;
  char *v29;
  NSObject *v30;
  os_log_type_t v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  char *v35;
  os_log_type_t v36;
  _BOOL4 v37;
  char *v38;
  os_log_type_t v39;
  _BOOL4 v40;
  void *v41;
  char *v42;
  NSObject *v43;
  os_log_type_t v44;
  os_log_type_t v45;
  os_log_type_t v46;
  os_log_type_t v47;
  char *v48;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  char v52;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  _BYTE v57[10];
  _BYTE v58[10];
  _BYTE v59[10];
  _BYTE v60[10];
  __int16 v61;
  char *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  v4 = a3;
  length = xpc_data_get_length(v4);
  bytes_ptr = xpc_data_get_bytes_ptr(v4);
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (!v7)
  {
    v20 = a1;
    v21 = v4;
    __nwlog_obj();
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_necp_append_tlv";
    v23 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v23, &type, &v52))
      goto LABEL_86;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s called with null tlv_start", buf, 0xCu);
      }
    }
    else if (v52)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      v34 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v55 = "nw_necp_append_tlv";
          v56 = 2082;
          *(_QWORD *)v57 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_86:
        if (!v23)
        {
LABEL_88:
          v14 = 0;
          v4 = v21;
          a1 = v20;
          goto LABEL_29;
        }
LABEL_87:
        free(v23);
        goto LABEL_88;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_182FBE000, v24, v33, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_182FBE000, v24, v45, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_85:

    goto LABEL_86;
  }
  v8 = *(_QWORD *)(a1 + 40);
  if (!v8)
  {
    v20 = a1;
    v21 = v4;
    __nwlog_obj();
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_necp_append_tlv";
    v23 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v23, &type, &v52))
      goto LABEL_86;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_182FBE000, v24, v27, "%{public}s called with null beyond", buf, 0xCu);
      }
    }
    else if (v52)
    {
      v35 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v36 = type;
      v37 = os_log_type_enabled(v24, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          v55 = "nw_necp_append_tlv";
          v56 = 2082;
          *(_QWORD *)v57 = v35;
          _os_log_impl(&dword_182FBE000, v24, v36, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v35);
        if (!v23)
          goto LABEL_88;
        goto LABEL_87;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_182FBE000, v24, v36, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v24 = objc_claimAutoreleasedReturnValue();
      v46 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "nw_necp_append_tlv";
        _os_log_impl(&dword_182FBE000, v24, v46, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_85;
  }
  if (v7 < v8)
  {
    v9 = length + 5;
    if (v8 - v7 < v9)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v10 = (id)gLogObj;
      *(_DWORD *)buf = 136447490;
      v55 = "nw_necp_append_tlv";
      v56 = 2048;
      *(_QWORD *)v57 = v7;
      *(_WORD *)&v57[8] = 2048;
      *(_QWORD *)v58 = length + 5;
      *(_WORD *)&v58[8] = 2048;
      *(_QWORD *)v59 = v8;
      *(_WORD *)&v59[8] = 1024;
      *(_DWORD *)v60 = 222;
      *(_WORD *)&v60[4] = 1024;
      *(_DWORD *)&v60[6] = length;
      v11 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v52 = 0;
      if (__nwlog_fault(v11, &type, &v52))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = (id)gLogObj;
          v13 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447490;
            v55 = "nw_necp_append_tlv";
            v56 = 2048;
            *(_QWORD *)v57 = v7;
            *(_WORD *)&v57[8] = 2048;
            *(_QWORD *)v58 = length + 5;
            *(_WORD *)&v58[8] = 2048;
            *(_QWORD *)v59 = v8;
            *(_WORD *)&v59[8] = 1024;
            *(_DWORD *)v60 = 222;
            *(_WORD *)&v60[4] = 1024;
            *(_DWORD *)&v60[6] = length;
            _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
          }
        }
        else if (v52)
        {
          v15 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = (id)gLogObj;
          v16 = type;
          v17 = os_log_type_enabled(v12, type);
          if (v15)
          {
            if (v17)
            {
              *(_DWORD *)buf = 136447746;
              v55 = "nw_necp_append_tlv";
              v56 = 2048;
              *(_QWORD *)v57 = v7;
              *(_WORD *)&v57[8] = 2048;
              *(_QWORD *)v58 = length + 5;
              *(_WORD *)&v58[8] = 2048;
              *(_QWORD *)v59 = v8;
              *(_WORD *)&v59[8] = 1024;
              *(_DWORD *)v60 = 222;
              *(_WORD *)&v60[4] = 1024;
              *(_DWORD *)&v60[6] = length;
              v61 = 2082;
              v62 = v15;
              _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
            }

            free(v15);
            if (!v11)
              goto LABEL_28;
            goto LABEL_27;
          }
          if (v17)
          {
            *(_DWORD *)buf = 136447490;
            v55 = "nw_necp_append_tlv";
            v56 = 2048;
            *(_QWORD *)v57 = v7;
            *(_WORD *)&v57[8] = 2048;
            *(_QWORD *)v58 = length + 5;
            *(_WORD *)&v58[8] = 2048;
            *(_QWORD *)v59 = v8;
            *(_WORD *)&v59[8] = 1024;
            *(_DWORD *)v60 = 222;
            *(_WORD *)&v60[4] = 1024;
            *(_DWORD *)&v60[6] = length;
            _os_log_impl(&dword_182FBE000, v12, v16, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v12 = (id)gLogObj;
          v18 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447490;
            v55 = "nw_necp_append_tlv";
            v56 = 2048;
            *(_QWORD *)v57 = v7;
            *(_WORD *)&v57[8] = 2048;
            *(_QWORD *)v58 = length + 5;
            *(_WORD *)&v58[8] = 2048;
            *(_QWORD *)v59 = v8;
            *(_WORD *)&v59[8] = 1024;
            *(_DWORD *)v60 = 222;
            *(_WORD *)&v60[4] = 1024;
            *(_DWORD *)&v60[6] = length;
            _os_log_impl(&dword_182FBE000, v12, v18, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
          }
        }

      }
      if (!v11)
      {
LABEL_28:
        v14 = 0;
        goto LABEL_29;
      }
LABEL_27:
      free(v11);
      goto LABEL_28;
    }
    *(_BYTE *)v7 = -34;
    *(_DWORD *)(v7 + 1) = length;
    if (!length)
      goto LABEL_13;
    if (bytes_ptr)
    {
      memcpy((void *)(v7 + 5), bytes_ptr, length);
LABEL_13:
      v14 = v7 + v9;
      goto LABEL_29;
    }
    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446722;
    v55 = "nw_necp_append_tlv";
    v56 = 1024;
    *(_DWORD *)v57 = 222;
    *(_WORD *)&v57[4] = 1024;
    *(_DWORD *)&v57[6] = length;
    v42 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v42, &type, &v52))
      goto LABEL_101;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_necp_append_tlv";
        v56 = 1024;
        *(_DWORD *)v57 = 222;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = length;
        _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
      }
    }
    else if (v52)
    {
      v48 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v49 = type;
      v50 = os_log_type_enabled(v43, type);
      if (v48)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446978;
          v55 = "nw_necp_append_tlv";
          v56 = 1024;
          *(_DWORD *)v57 = 222;
          *(_WORD *)&v57[4] = 1024;
          *(_DWORD *)&v57[6] = length;
          *(_WORD *)v58 = 2082;
          *(_QWORD *)&v58[2] = v48;
          _os_log_impl(&dword_182FBE000, v43, v49, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(v48);
        goto LABEL_101;
      }
      if (v50)
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_necp_append_tlv";
        v56 = 1024;
        *(_DWORD *)v57 = 222;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = length;
        _os_log_impl(&dword_182FBE000, v43, v49, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
      }
    }
    else
    {
      __nwlog_obj();
      v43 = objc_claimAutoreleasedReturnValue();
      v51 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446722;
        v55 = "nw_necp_append_tlv";
        v56 = 1024;
        *(_DWORD *)v57 = 222;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = length;
        _os_log_impl(&dword_182FBE000, v43, v51, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
      }
    }

LABEL_101:
    if (v42)
      free(v42);
    v14 = 0;
    goto LABEL_29;
  }
  __nwlog_obj();
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136447234;
  v55 = "nw_necp_append_tlv";
  v56 = 2048;
  *(_QWORD *)v57 = v7;
  *(_WORD *)&v57[8] = 2048;
  *(_QWORD *)v58 = v8;
  *(_WORD *)&v58[8] = 1024;
  *(_DWORD *)v59 = 222;
  *(_WORD *)&v59[4] = 1024;
  *(_DWORD *)&v59[6] = length;
  v29 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v52 = 0;
  if (__nwlog_fault(v29, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136447234;
        v55 = "nw_necp_append_tlv";
        v56 = 2048;
        *(_QWORD *)v57 = v7;
        *(_WORD *)&v57[8] = 2048;
        *(_QWORD *)v58 = v8;
        *(_WORD *)&v58[8] = 1024;
        *(_DWORD *)v59 = 222;
        *(_WORD *)&v59[4] = 1024;
        *(_DWORD *)&v59[6] = length;
        _os_log_impl(&dword_182FBE000, v30, v31, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
      }
    }
    else if (v52)
    {
      v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v30, type);
      if (v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136447490;
          v55 = "nw_necp_append_tlv";
          v56 = 2048;
          *(_QWORD *)v57 = v7;
          *(_WORD *)&v57[8] = 2048;
          *(_QWORD *)v58 = v8;
          *(_WORD *)&v58[8] = 1024;
          *(_DWORD *)v59 = 222;
          *(_WORD *)&v59[4] = 1024;
          *(_DWORD *)&v59[6] = length;
          *(_WORD *)v60 = 2082;
          *(_QWORD *)&v60[2] = v38;
          _os_log_impl(&dword_182FBE000, v30, v39, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
        }

        free(v38);
        goto LABEL_92;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136447234;
        v55 = "nw_necp_append_tlv";
        v56 = 2048;
        *(_QWORD *)v57 = v7;
        *(_WORD *)&v57[8] = 2048;
        *(_QWORD *)v58 = v8;
        *(_WORD *)&v58[8] = 1024;
        *(_DWORD *)v59 = 222;
        *(_WORD *)&v59[4] = 1024;
        *(_DWORD *)&v59[6] = length;
        _os_log_impl(&dword_182FBE000, v30, v39, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
      }
    }
    else
    {
      __nwlog_obj();
      v30 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136447234;
        v55 = "nw_necp_append_tlv";
        v56 = 2048;
        *(_QWORD *)v57 = v7;
        *(_WORD *)&v57[8] = 2048;
        *(_QWORD *)v58 = v8;
        *(_WORD *)&v58[8] = 1024;
        *(_DWORD *)v59 = 222;
        *(_WORD *)&v59[4] = 1024;
        *(_DWORD *)&v59[6] = length;
        _os_log_impl(&dword_182FBE000, v30, v47, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
      }
    }

  }
LABEL_92:
  if (v29)
    free(v29);
  v14 = 0;
LABEL_29:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v14;

  return 1;
}

void sub_183913C2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL55nw_path_evaluator_add_browse_descriptor_to_necp_messagePU34objcproto23OS_nw_browse_descriptor8NSObjecthPhPKh_block_invoke(uint64_t a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s) + 1;
  memcpy((void *)(*(_QWORD *)(a1 + 40) + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 8), __s, v4);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v4;
  return 1;
}

uint64_t ___ZL55nw_path_evaluator_add_browse_descriptor_to_necp_messagePU34objcproto23OS_nw_browse_descriptor8NSObjecthPhPKh_block_invoke_26(uint64_t a1, int a2, uint64_t a3, void *__src, size_t a5)
{
  size_t v5;
  BOOL v6;
  void *v7;
  uint64_t v8;

  v5 = *(unsigned __int8 *)(a1 + 40) - a3 - 8;
  v6 = v5 > a5;
  if (v5 >= a5)
    v5 = a5;
  v7 = (void *)(*(_QWORD *)(a1 + 32) + a3 + 8);
  v8 = !v6;
  memcpy(v7, __src, v5);
  return v8;
}

BOOL __nw_path_create_necp_parameters_block_invoke_5(uint64_t a1, size_t __n, __int16 a3, void *__src, const void *a5)
{
  __int16 v7;
  size_t v9;
  unint64_t v10;
  unint64_t v11;
  id v12;
  char *v13;
  NSObject *v14;
  os_log_type_t v15;
  const char *v16;
  __int128 v17;
  __int128 v18;
  unint64_t v19;
  char *backtrace_string;
  _BOOL4 v21;
  const char *v22;
  NSObject *v23;
  os_log_type_t v24;
  uint32_t v25;
  void *v27;
  os_log_type_t v28;
  const char *v29;
  void *v30;
  void *v31;
  os_log_type_t v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  NSObject *v36;
  os_log_type_t v37;
  uint32_t v38;
  char v39;
  os_log_type_t type;
  __int128 __dst;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  char *v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  _BYTE v52[10];
  _BYTE v53[10];
  __int16 v54;
  char *v55;
  uint64_t v56;

  v7 = __n;
  v56 = *MEMORY[0x1E0C80C00];
  v43 = 0u;
  v44 = 0u;
  __dst = 0u;
  v42 = 0u;
  v9 = __n;
  memcpy(&v43, __src, __n);
  memcpy(&__dst, a5, v9);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (!v10)
  {
    __nwlog_obj();
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_necp_append_tlv";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
      goto LABEL_16;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null tlv_start";
LABEL_62:
      v36 = v14;
      v37 = v28;
      v38 = 12;
LABEL_66:
      _os_log_impl(&dword_182FBE000, v36, v37, v29, buf, v38);
      goto LABEL_67;
    }
    if (!v39)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null tlv_start, backtrace limit exceeded";
      goto LABEL_62;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v28 = type;
    v33 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v33)
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null tlv_start, no backtrace";
      goto LABEL_62;
    }
    if (!v33)
      goto LABEL_15;
    *(_DWORD *)buf = 136446466;
    v46 = "nw_necp_append_tlv";
    v47 = 2082;
    v48 = backtrace_string;
    v22 = "%{public}s called with null tlv_start, dumping backtrace:%{public}s";
LABEL_47:
    v23 = v14;
    v24 = v28;
    v25 = 22;
LABEL_14:
    _os_log_impl(&dword_182FBE000, v23, v24, v22, buf, v25);
LABEL_15:

    free(backtrace_string);
    goto LABEL_16;
  }
  v11 = *(_QWORD *)(a1 + 40);
  if (!v11)
  {
    __nwlog_obj();
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v46 = "nw_necp_append_tlv";
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
      goto LABEL_16;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null beyond";
      goto LABEL_62;
    }
    if (!v39)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v28 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null beyond, backtrace limit exceeded";
      goto LABEL_62;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v14 = objc_claimAutoreleasedReturnValue();
    v28 = type;
    v34 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v34)
        goto LABEL_67;
      *(_DWORD *)buf = 136446210;
      v46 = "nw_necp_append_tlv";
      v29 = "%{public}s called with null beyond, no backtrace";
      goto LABEL_62;
    }
    if (!v34)
      goto LABEL_15;
    *(_DWORD *)buf = 136446466;
    v46 = "nw_necp_append_tlv";
    v47 = 2082;
    v48 = backtrace_string;
    v22 = "%{public}s called with null beyond, dumping backtrace:%{public}s";
    goto LABEL_47;
  }
  if (v10 >= v11)
  {
    __nwlog_obj();
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = (char *)v10;
    v49 = 2048;
    v50 = v11;
    v51 = 1024;
    *(_DWORD *)v52 = 251;
    *(_WORD *)&v52[4] = 1024;
    *(_DWORD *)&v52[6] = 68;
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
      goto LABEL_16;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136447234;
        v46 = "nw_necp_append_tlv";
        v47 = 2048;
        v48 = (char *)v10;
        v49 = 2048;
        v50 = v11;
        v51 = 1024;
        *(_DWORD *)v52 = 251;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = 68;
        v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u";
LABEL_65:
        v36 = v14;
        v37 = v32;
        v38 = 44;
        goto LABEL_66;
      }
    }
    else
    {
      if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v14 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        v35 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (!v35)
            goto LABEL_15;
          *(_DWORD *)buf = 136447490;
          v46 = "nw_necp_append_tlv";
          v47 = 2048;
          v48 = (char *)v10;
          v49 = 2048;
          v50 = v11;
          v51 = 1024;
          *(_DWORD *)v52 = 251;
          *(_WORD *)&v52[4] = 1024;
          *(_DWORD *)&v52[6] = 68;
          *(_WORD *)v53 = 2082;
          *(_QWORD *)&v53[2] = backtrace_string;
          v22 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s";
          v23 = v14;
          v24 = v32;
          v25 = 54;
          goto LABEL_14;
        }
        if (!v35)
          goto LABEL_67;
        *(_DWORD *)buf = 136447234;
        v46 = "nw_necp_append_tlv";
        v47 = 2048;
        v48 = (char *)v10;
        v49 = 2048;
        v50 = v11;
        v51 = 1024;
        *(_DWORD *)v52 = 251;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = 68;
        v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace";
        goto LABEL_65;
      }
      __nwlog_obj();
      v14 = objc_claimAutoreleasedReturnValue();
      v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136447234;
        v46 = "nw_necp_append_tlv";
        v47 = 2048;
        v48 = (char *)v10;
        v49 = 2048;
        v50 = v11;
        v51 = 1024;
        *(_DWORD *)v52 = 251;
        *(_WORD *)&v52[4] = 1024;
        *(_DWORD *)&v52[6] = 68;
        v29 = "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded";
        goto LABEL_65;
      }
    }
LABEL_67:

LABEL_16:
    if (!v13)
    {
LABEL_18:
      v19 = 0;
      goto LABEL_19;
    }
LABEL_17:
    free(v13);
    goto LABEL_18;
  }
  if (v11 - v10 <= 0x48)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = (char *)v10;
    v49 = 2048;
    v50 = 73;
    v51 = 2048;
    *(_QWORD *)v52 = v11;
    *(_WORD *)&v52[8] = 1024;
    *(_DWORD *)v53 = 251;
    *(_WORD *)&v53[4] = 1024;
    *(_DWORD *)&v53[6] = 68;
    v13 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v39 = 0;
    if (!__nwlog_fault(v13, &type, &v39))
      goto LABEL_16;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (id)gLogObj;
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = (char *)v10;
      v49 = 2048;
      v50 = 73;
      v51 = 2048;
      *(_QWORD *)v52 = v11;
      *(_WORD *)&v52[8] = 1024;
      *(_DWORD *)v53 = 251;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = 68;
      v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u";
      goto LABEL_24;
    }
    if (!v39)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v14 = (id)gLogObj;
      v15 = type;
      if (!os_log_type_enabled(v14, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = (char *)v10;
      v49 = 2048;
      v50 = 73;
      v51 = 2048;
      *(_QWORD *)v52 = v11;
      *(_WORD *)&v52[8] = 1024;
      *(_DWORD *)v53 = 251;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = 68;
      v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    v15 = type;
    v21 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (!v21)
        goto LABEL_25;
      *(_DWORD *)buf = 136447490;
      v46 = "nw_necp_append_tlv";
      v47 = 2048;
      v48 = (char *)v10;
      v49 = 2048;
      v50 = 73;
      v51 = 2048;
      *(_QWORD *)v52 = v11;
      *(_WORD *)&v52[8] = 1024;
      *(_DWORD *)v53 = 251;
      *(_WORD *)&v53[4] = 1024;
      *(_DWORD *)&v53[6] = 68;
      v16 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace";
LABEL_24:
      _os_log_impl(&dword_182FBE000, v14, v15, v16, buf, 0x36u);
LABEL_25:

      if (!v13)
        goto LABEL_18;
      goto LABEL_17;
    }
    if (!v21)
      goto LABEL_15;
    *(_DWORD *)buf = 136447746;
    v46 = "nw_necp_append_tlv";
    v47 = 2048;
    v48 = (char *)v10;
    v49 = 2048;
    v50 = 73;
    v51 = 2048;
    *(_QWORD *)v52 = v11;
    *(_WORD *)&v52[8] = 1024;
    *(_DWORD *)v53 = 251;
    *(_WORD *)&v53[4] = 1024;
    *(_DWORD *)&v53[6] = 68;
    v54 = 2082;
    v55 = backtrace_string;
    v22 = "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s";
    v23 = v14;
    v24 = v15;
    v25 = 64;
    goto LABEL_14;
  }
  v17 = v42;
  *(_OWORD *)(v10 + 9) = __dst;
  *(_OWORD *)(v10 + 25) = v17;
  v18 = v44;
  *(_OWORD *)(v10 + 41) = v43;
  *(_BYTE *)v10 = -5;
  *(_DWORD *)(v10 + 1) = 68;
  *(_WORD *)(v10 + 5) = a3;
  *(_WORD *)(v10 + 7) = v7;
  v19 = v10 + 73;
  *(_OWORD *)(v10 + 57) = v18;
LABEL_19:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v19;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t ___ZL41nw_path_struct_size_for_browse_descriptorPU34objcproto23OS_nw_browse_descriptor8NSObjectPm_block_invoke(uint64_t a1, char *__s)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += strlen(__s) + 1;
  return 1;
}

BOOL nw_path_create_flow_result_from_tlv(NWConcrete_nw_path *a1, const unsigned __int8 *a2, unint64_t a3)
{
  NWConcrete_nw_path *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  NWConcrete_nw_path_flow *v9;
  NWConcrete_nw_path_flow *v10;
  unint64_t v11;
  char *backtrace_string;
  NSObject *v13;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  int v17;
  size_t v18;
  id v20;
  void *v21;
  NSObject *v22;
  os_log_type_t v23;
  NWConcrete_nw_path *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  unsigned __int8 *v29;
  os_log_type_t v30;
  __int128 v31;
  void *v32;
  NSObject *v33;
  OS_nw_protocol_options *assigned_protocol;
  int v35;
  char *v36;
  nw_endpoint_t v37;
  nw_endpoint_t v38;
  NSObject *v39;
  OS_nw_endpoint *endpoint;
  OS_nw_endpoint *v41;
  char is_equal;
  OS_nw_endpoint *v43;
  id v44;
  NWConcrete_nw_interface *v45;
  OS_nw_interface *interface;
  int v47;
  necp_client_result_interface v48;
  void *nexus_key;
  void *v50;
  nw_endpoint_t v51;
  NSObject *v52;
  uint64_t resolved_endpoints;
  _BOOL8 v54;
  OS_nw_array *v55;
  nw_endpoint_t v56;
  NSObject *v57;
  uint64_t discovered_endpoints;
  _BOOL8 v59;
  OS_nw_array *v60;
  int v61;
  OS_nw_error *dns_error;
  id v63;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  NSObject *v67;
  uint64_t v68;
  __int128 v69;
  _BYTE *v70;
  _BYTE *v71;
  NWConcrete_nw_protocol_options *deserialized_options;
  OS_nw_error *error;
  char *v74;
  NSObject *v75;
  os_log_type_t v76;
  _BOOL4 v77;
  OS_nw_endpoint *v78;
  OS_nw_endpoint *v79;
  void *v80;
  os_log_type_t v81;
  void *v82;
  os_log_type_t v83;
  NWConcrete_nw_path *v84;
  char *v85;
  NSObject *v86;
  os_log_type_t v87;
  _BOOL4 v88;
  os_log_type_t v89;
  NWConcrete_nw_path *v90;
  char *v91;
  NSObject *v92;
  os_log_type_t v93;
  _BOOL4 v94;
  NSObject *p_super;
  os_log_type_t v96;
  NWConcrete_nw_protocol_options *v97;
  NSObject *v98;
  os_log_type_t v99;
  NSObject *v100;
  NSObject *v101;
  NSObject *v102;
  NSObject *v103;
  NSObject *v104;
  NSObject *v105;
  NSObject *v106;
  NSObject *v107;
  NSObject *v108;
  NWConcrete_nw_path *v109;
  NSObject *v110;
  NSObject *v111;
  NSObject *v112;
  NSObject *v113;
  void *v114;
  _BOOL8 result;
  id v116;
  char *v117;
  NSObject *v118;
  os_log_type_t v119;
  NSObject *v120;
  os_log_type_t v121;
  char *v122;
  os_log_type_t v123;
  _BOOL4 v124;
  char *v125;
  NSObject *v126;
  os_log_type_t v127;
  _BOOL4 v128;
  os_log_type_t v129;
  os_log_type_t v130;
  id v131;
  char *v132;
  NSObject *v133;
  os_log_type_t v134;
  char *v135;
  NSObject *v136;
  os_log_type_t v137;
  _BOOL4 v138;
  os_log_type_t v139;
  OS_nw_endpoint *local_endpoint;
  OS_nw_endpoint *v141;
  int v142;
  const sockaddr *address;
  nw_endpoint_t v144;
  OS_nw_endpoint *v145;
  nw_endpoint_t v146;
  OS_nw_endpoint *v147;
  nw_endpoint_t v148;
  OS_nw_endpoint *remote_endpoint;
  OS_nw_endpoint *v150;
  int v151;
  const sockaddr *v152;
  nw_endpoint_t v153;
  OS_nw_endpoint *v154;
  NWConcrete_nw_path_flow *v155;
  void *v156;
  char *v157;
  NSObject *v158;
  os_log_type_t v159;
  char *v160;
  NSObject *v161;
  os_log_type_t v162;
  _BOOL4 v163;
  os_log_type_t v164;
  unsigned __int8 *__dst;
  id *location;
  unsigned __int8 *v167;
  necp_client_result_netagent *p_nexus_agent_struct;
  unsigned __int8 *uu;
  uint64_t v170;
  nw_endpoint_t object;
  int v173;
  __int16 v174;
  int v175;
  __int16 v176;
  char v177;
  uint8_t v178[4];
  const char *v179;
  __int16 v180;
  _BYTE *v181;
  _BYTE buf[50];
  uint64_t v183;

  v183 = *MEMORY[0x1E0C80C00];
  v4 = a1;
  if (a3 <= 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = a3;
    v6 = (char *)_os_log_send_and_compose_impl();

    v178[0] = 16;
    LOBYTE(v175) = 0;
    if (!__nwlog_fault(v6, v178, &v175))
      goto LABEL_317;
    if (v178[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = v178[0];
      if (os_log_type_enabled(v7, (os_log_type_t)v178[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = a3;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s NECP buffer too short %zu", buf, 0x16u);
      }
    }
    else
    {
      if ((_BYTE)v175)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v13 = (id)gLogObj;
        v14 = v178[0];
        v15 = os_log_type_enabled(v13, (os_log_type_t)v178[0]);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = a3;
            *(_WORD *)&buf[22] = 2082;
            *(_QWORD *)&buf[24] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s NECP buffer too short %zu, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          if (!v6)
            goto LABEL_319;
          goto LABEL_318;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = a3;
          _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s NECP buffer too short %zu, no backtrace", buf, 0x16u);
        }

LABEL_317:
        if (!v6)
        {
LABEL_319:
          v10 = 0;
LABEL_346:

          return (BOOL)v10;
        }
LABEL_318:
        free(v6);
        goto LABEL_319;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v16 = v178[0];
      if (os_log_type_enabled(v7, (os_log_type_t)v178[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = a3;
        _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s NECP buffer too short %zu, backtrace limit exceeded", buf, 0x16u);
      }
    }

    goto LABEL_317;
  }
  v9 = nw_path_flow_create();
  v10 = v9;
  if (!v9)
  {
LABEL_345:

    goto LABEL_346;
  }
  v176 = 0;
  v175 = 0;
  v174 = 0;
  v173 = 0;
  if (a3 == 5)
  {
    v170 = 0;
    object = 0;
    v11 = 0;
    goto LABEL_334;
  }
  v170 = 0;
  object = 0;
  v11 = 0;
  __dst = v9->tfo_cookie;
  location = (id *)&v9->local_endpoint;
  uu = &v9->nexus_instance[4];
  v167 = &v9->flow_id[4];
  p_nexus_agent_struct = &v9->nexus_agent_struct;
  while (2)
  {
    v17 = a2[v11];
    v18 = *(unsigned int *)&a2[v11 + 1];
    if ((_DWORD)v18)
    {
      if (v18 <= 0xFFFFFFF9 && a3 >= v18 + 5 && a3 - (v18 + 5) >= v11)
      {
        v29 = (unsigned __int8 *)&a2[v11 + 5];
        goto LABEL_46;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v20 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_necp_buffer_get_tlv_value";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v11;
      *(_WORD *)&buf[22] = 2048;
      *(_QWORD *)&buf[24] = a3;
      *(_WORD *)&buf[32] = 1024;
      *(_DWORD *)&buf[34] = v18;
      v21 = (void *)_os_log_send_and_compose_impl();

      v178[0] = 16;
      v177 = 0;
      if (__nwlog_fault((const char *)v21, v178, &v177))
      {
        if (v178[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v23 = v178[0];
          if (os_log_type_enabled(v22, (os_log_type_t)v178[0]))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v11;
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)&buf[24] = a3;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v18;
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u", buf, 0x26u);
          }
        }
        else
        {
          if (v177)
          {
            v24 = v4;
            v25 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v26 = (id)gLogObj;
            v27 = v178[0];
            v28 = os_log_type_enabled(v26, (os_log_type_t)v178[0]);
            if (v25)
            {
              if (v28)
              {
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_necp_buffer_get_tlv_value";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v11;
                *(_WORD *)&buf[22] = 2048;
                *(_QWORD *)&buf[24] = a3;
                *(_WORD *)&buf[32] = 1024;
                *(_DWORD *)&buf[34] = v18;
                *(_WORD *)&buf[38] = 2082;
                *(_QWORD *)&buf[40] = v25;
                _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, dumping backtrace:%{public}s", buf, 0x30u);
              }

              v4 = v24;
              free(v25);
              if (!v21)
                goto LABEL_45;
            }
            else
            {
              if (v28)
              {
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_necp_buffer_get_tlv_value";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v11;
                *(_WORD *)&buf[22] = 2048;
                *(_QWORD *)&buf[24] = a3;
                *(_WORD *)&buf[32] = 1024;
                *(_DWORD *)&buf[34] = v18;
                _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, no backtrace", buf, 0x26u);
              }

              v4 = v24;
              if (!v21)
                goto LABEL_45;
            }
LABEL_44:
            free(v21);
            goto LABEL_45;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = (id)gLogObj;
          v30 = v178[0];
          if (os_log_type_enabled(v22, (os_log_type_t)v178[0]))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_necp_buffer_get_tlv_value";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v11;
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)&buf[24] = a3;
            *(_WORD *)&buf[32] = 1024;
            *(_DWORD *)&buf[34] = v18;
            _os_log_impl(&dword_182FBE000, v22, v30, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, backtrace limit exceeded", buf, 0x26u);
          }
        }

      }
      if (v21)
        goto LABEL_44;
    }
LABEL_45:
    v29 = 0;
LABEL_46:
    v11 += v18 + 5;
    if (v11 > a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v131 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v18;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v11;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = a3;
      v132 = (char *)_os_log_send_and_compose_impl();

      v178[0] = 16;
      v177 = 0;
      if (!__nwlog_fault(v132, v178, &v177))
        goto LABEL_332;
      if (v178[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v133 = (id)gLogObj;
        v134 = v178[0];
        if (os_log_type_enabled(v133, (os_log_type_t)v178[0]))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v11;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a3;
          _os_log_impl(&dword_182FBE000, v133, v134, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu)", buf, 0x26u);
        }
      }
      else
      {
        if (v177)
        {
          v135 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v136 = objc_claimAutoreleasedReturnValue();
          v137 = v178[0];
          v138 = os_log_type_enabled(v136, (os_log_type_t)v178[0]);
          if (v135)
          {
            if (v138)
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v11;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = a3;
              *(_WORD *)&buf[38] = 2082;
              *(_QWORD *)&buf[40] = v135;
              _os_log_impl(&dword_182FBE000, v136, v137, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), dumping backtrace:%{public}s", buf, 0x30u);
            }

            free(v135);
            if (!v132)
            {
LABEL_334:
              if (v11 == a3)
              {
LABEL_335:
                if ((v170 & 0x100000000) != 0)
                {
                  local_endpoint = v10->local_endpoint;
                  if (local_endpoint
                    && (v141 = local_endpoint,
                        v142 = -[OS_nw_endpoint type](v141, "type"),
                        v141,
                        v142 == 1))
                  {
                    address = nw_endpoint_get_address((nw_endpoint_t)v10->local_endpoint);
                    v144 = nw_endpoint_create_address_with_ethernet(address, &v175);
                    v145 = v10->local_endpoint;
                    v10->local_endpoint = (OS_nw_endpoint *)v144;

                  }
                  else
                  {
                    *(_QWORD *)&buf[8] = 0;
                    *(_QWORD *)&buf[2] = 0;
                    *(_WORD *)buf = 16;
                    v146 = nw_endpoint_create_address_with_ethernet((const sockaddr *)buf, &v175);
                    v147 = v10->local_endpoint;
                    v10->local_endpoint = (OS_nw_endpoint *)v146;

                  }
                }
                v148 = object;
                if ((v170 & 1) != 0)
                {
                  remote_endpoint = v10->remote_endpoint;
                  if (remote_endpoint)
                  {
                    v150 = remote_endpoint;
                    v151 = -[OS_nw_endpoint type](v150, "type");

                    v148 = object;
                    if (v151 == 1)
                    {
                      v152 = nw_endpoint_get_address((nw_endpoint_t)v10->remote_endpoint);
                      v153 = nw_endpoint_create_address_with_ethernet(v152, &v173);
                      v154 = v10->remote_endpoint;
                      v10->remote_endpoint = (OS_nw_endpoint *)v153;

                      nw_endpoint_clone_parent_endpoint_properties(v10->remote_endpoint, v4->endpoint);
                      v148 = object;
                    }
                  }
                }
                v155 = v10;

                goto LABEL_345;
              }
              __nwlog_obj();
              v156 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v11;
              *(_WORD *)&buf[22] = 2048;
              *(_QWORD *)&buf[24] = a3;
              v157 = (char *)_os_log_send_and_compose_impl();

              v178[0] = 16;
              v177 = 0;
              if (__nwlog_fault(v157, v178, &v177))
              {
                if (v178[0] == 17)
                {
                  __nwlog_obj();
                  v158 = objc_claimAutoreleasedReturnValue();
                  v159 = v178[0];
                  if (os_log_type_enabled(v158, (os_log_type_t)v178[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v11;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)&buf[24] = a3;
                    _os_log_impl(&dword_182FBE000, v158, v159, "%{public}s cursor has unexpected value %zu != %zu", buf, 0x20u);
                  }
                }
                else
                {
                  if (v177)
                  {
                    v160 = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    v161 = objc_claimAutoreleasedReturnValue();
                    v162 = v178[0];
                    v163 = os_log_type_enabled(v161, (os_log_type_t)v178[0]);
                    if (v160)
                    {
                      if (v163)
                      {
                        *(_DWORD *)buf = 136446978;
                        *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                        *(_WORD *)&buf[12] = 2048;
                        *(_QWORD *)&buf[14] = v11;
                        *(_WORD *)&buf[22] = 2048;
                        *(_QWORD *)&buf[24] = a3;
                        *(_WORD *)&buf[32] = 2082;
                        *(_QWORD *)&buf[34] = v160;
                        _os_log_impl(&dword_182FBE000, v161, v162, "%{public}s cursor has unexpected value %zu != %zu, dumping backtrace:%{public}s", buf, 0x2Au);
                      }

                      free(v160);
                    }
                    else
                    {
                      if (v163)
                      {
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                        *(_WORD *)&buf[12] = 2048;
                        *(_QWORD *)&buf[14] = v11;
                        *(_WORD *)&buf[22] = 2048;
                        *(_QWORD *)&buf[24] = a3;
                        _os_log_impl(&dword_182FBE000, v161, v162, "%{public}s cursor has unexpected value %zu != %zu, no backtrace", buf, 0x20u);
                      }

                    }
                    goto LABEL_363;
                  }
                  __nwlog_obj();
                  v158 = objc_claimAutoreleasedReturnValue();
                  v164 = v178[0];
                  if (os_log_type_enabled(v158, (os_log_type_t)v178[0]))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v11;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)&buf[24] = a3;
                    _os_log_impl(&dword_182FBE000, v158, v164, "%{public}s cursor has unexpected value %zu != %zu, backtrace limit exceeded", buf, 0x20u);
                  }
                }

              }
LABEL_363:
              if (v157)
                free(v157);
              goto LABEL_335;
            }
LABEL_333:
            free(v132);
            goto LABEL_334;
          }
          if (v138)
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v18;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v11;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = a3;
            _os_log_impl(&dword_182FBE000, v136, v137, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), no backtrace", buf, 0x26u);
          }

LABEL_332:
          if (!v132)
            goto LABEL_334;
          goto LABEL_333;
        }
        __nwlog_obj();
        v133 = objc_claimAutoreleasedReturnValue();
        v139 = v178[0];
        if (os_log_type_enabled(v133, (os_log_type_t)v178[0]))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v11;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = a3;
          _os_log_impl(&dword_182FBE000, v133, v139, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), backtrace limit exceeded", buf, 0x26u);
        }
      }

      goto LABEL_332;
    }
    if (!(_DWORD)v18 || !v29)
      goto LABEL_21;
    switch(v17)
    {
      case 6:
        if ((_DWORD)v18 == 20)
          goto LABEL_51;
        if (v18 >= 0x15)
        {
          __nwlog_obj();
          v100 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 6;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 20;
            _os_log_impl(&dword_182FBE000, v100, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_51:
          v31 = *(_OWORD *)v29;
          *(_DWORD *)&p_nexus_agent_struct->netagent_uuid[12] = *((_DWORD *)v29 + 4);
          *(_OWORD *)&p_nexus_agent_struct->generation = v31;
        }
        goto LABEL_21;
      case 7:
        if ((_DWORD)v18 == 4)
          goto LABEL_74;
        if (v18 < 5)
          goto LABEL_21;
        __nwlog_obj();
        v104 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v104, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 7;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v18;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = 4;
          _os_log_impl(&dword_182FBE000, v104, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
        }

LABEL_74:
        v35 = *(_DWORD *)v29;
        if ((*(_DWORD *)v29 & 0x80) != 0)
        {
          BYTE1(v10[1].super.isa) |= 1u;
          if ((v35 & 0x40) == 0)
          {
LABEL_76:
            if ((v35 & 0x200) == 0)
              goto LABEL_77;
            goto LABEL_134;
          }
        }
        else if ((v35 & 0x40) == 0)
        {
          goto LABEL_76;
        }
        BYTE1(v10[1].super.isa) |= 2u;
        if ((v35 & 0x200) == 0)
        {
LABEL_77:
          if ((v35 & 0x400) == 0)
            goto LABEL_78;
          goto LABEL_135;
        }
LABEL_134:
        BYTE1(v10[1].super.isa) |= 4u;
        if ((v35 & 0x400) == 0)
        {
LABEL_78:
          if ((v35 & 1) == 0)
            goto LABEL_79;
          goto LABEL_136;
        }
LABEL_135:
        BYTE1(v10[1].super.isa) |= 8u;
        if ((v35 & 1) == 0)
        {
LABEL_79:
          if ((v35 & 2) == 0)
            goto LABEL_80;
          goto LABEL_137;
        }
LABEL_136:
        BYTE1(v10[1].super.isa) |= 0x10u;
        if ((v35 & 2) == 0)
        {
LABEL_80:
          if ((v35 & 0x10) == 0)
            goto LABEL_81;
          goto LABEL_138;
        }
LABEL_137:
        BYTE1(v10[1].super.isa) |= 0x20u;
        if ((v35 & 0x10) == 0)
        {
LABEL_81:
          if ((v35 & 4) == 0)
            goto LABEL_82;
          goto LABEL_139;
        }
LABEL_138:
        BYTE2(v10[1].super.isa) |= 4u;
        if ((v35 & 4) == 0)
        {
LABEL_82:
          if ((v35 & 8) == 0)
            goto LABEL_83;
          goto LABEL_140;
        }
LABEL_139:
        BYTE1(v10[1].super.isa) |= 0x40u;
        if ((v35 & 8) == 0)
        {
LABEL_83:
          if ((v35 & 0x2000) == 0)
            goto LABEL_21;
          goto LABEL_141;
        }
LABEL_140:
        BYTE1(v10[1].super.isa) |= 0x80u;
        if ((v35 & 0x2000) == 0)
          goto LABEL_21;
LABEL_141:
        BYTE2(v10[1].super.isa) |= 1u;
        goto LABEL_21;
      case 8:
        if ((_DWORD)v18 == 8)
          goto LABEL_102;
        if (v18 >= 9)
        {
          __nwlog_obj();
          v106 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v106, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 8;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 8;
            _os_log_impl(&dword_182FBE000, v106, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_102:
          v10->interface_struct = *(necp_client_result_interface *)v29;
        }
        v44 = nw_parameters_copy_context(v4->parameters);
        v45 = nw_path_copy_interface_with_generation(v44, v10->interface_struct.index, v10->interface_struct.generation);
        interface = v10->interface;
        v10->interface = (OS_nw_interface *)v45;

        goto LABEL_21;
      case 12:
        if ((_DWORD)v18 == 12)
          goto LABEL_107;
        if (v18 >= 0xD)
        {
          __nwlog_obj();
          v107 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 12;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 12;
            _os_log_impl(&dword_182FBE000, v107, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_107:
          v47 = *((_DWORD *)v29 + 2);
          v48 = *(necp_client_result_interface *)v29;
          BYTE2(v10[1].super.isa) |= 2u;
          *(necp_client_result_interface *)&v10->ctl_command_value = v48;
          *(_DWORD *)&v10->tfo_cookie_len = v47;
        }
        goto LABEL_21;
      case 13:
        if (v18 <= 0x10)
        {
          memcpy(__dst, v29, v18);
          LOBYTE(v10[1].super.isa) = v18;
          goto LABEL_21;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v63 = (id)gLogObj;
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 13;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v18;
        *(_WORD *)&buf[24] = 2080;
        *(_QWORD *)&buf[26] = "nw_path_create_flow_result_from_tlv";
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = 2413;
        v64 = (char *)_os_log_send_and_compose_impl();

        v178[0] = 16;
        v177 = 0;
        if (!__nwlog_fault(v64, v178, &v177))
          goto LABEL_218;
        if (v178[0] == 17)
        {
          __nwlog_obj();
          v65 = objc_claimAutoreleasedReturnValue();
          v66 = v178[0];
          if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 13;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 2080;
            *(_QWORD *)&buf[26] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = 2413;
            _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
          }
          goto LABEL_217;
        }
        if (v177)
        {
          v74 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v75 = objc_claimAutoreleasedReturnValue();
          v76 = v178[0];
          v77 = os_log_type_enabled(v75, (os_log_type_t)v178[0]);
          if (v74)
          {
            if (v77)
            {
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 13;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v18;
              *(_WORD *)&buf[24] = 2080;
              *(_QWORD *)&buf[26] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 2413;
              *(_WORD *)&buf[40] = 2082;
              *(_QWORD *)&buf[42] = v74;
              _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
            }

            free(v74);
          }
          else
          {
            if (v77)
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 13;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v18;
              *(_WORD *)&buf[24] = 2080;
              *(_QWORD *)&buf[26] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[34] = 1024;
              *(_DWORD *)&buf[36] = 2413;
              _os_log_impl(&dword_182FBE000, v75, v76, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }

          }
          goto LABEL_218;
        }
        __nwlog_obj();
        v65 = objc_claimAutoreleasedReturnValue();
        v89 = v178[0];
        if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 13;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v18;
          *(_WORD *)&buf[24] = 2080;
          *(_QWORD *)&buf[26] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[34] = 1024;
          *(_DWORD *)&buf[36] = 2413;
          _os_log_impl(&dword_182FBE000, v65, v89, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }
        goto LABEL_217;
      case 16:
        if ((_DWORD)v18 == 16)
          goto LABEL_91;
        if (v18 >= 0x11)
        {
          __nwlog_obj();
          v105 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 16;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 16;
            _os_log_impl(&dword_182FBE000, v105, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_91:
          *(_OWORD *)v167 = *(_OWORD *)v29;
        }
        goto LABEL_21;
      case 100:
        uuid_clear(uu);
        if ((_DWORD)v18 == 16)
          goto LABEL_93;
        if (v18 >= 0x11)
        {
          __nwlog_obj();
          v112 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 100;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 16;
            _os_log_impl(&dword_182FBE000, v112, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_93:
          *(_OWORD *)uu = *(_OWORD *)v29;
        }
        goto LABEL_21;
      case 101:
        if ((_DWORD)v18 == 2)
          goto LABEL_113;
        if (v18 < 3)
        {
          v10->ctl_command_code = 0;
        }
        else
        {
          __nwlog_obj();
          v108 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 101;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 2;
            _os_log_impl(&dword_182FBE000, v108, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_113:
          v10->ctl_command_code = *(unsigned __int16 *)v29;
        }
        goto LABEL_21;
      case 102:
        nexus_key = v10->nexus_key;
        if (nexus_key)
        {
          free(nexus_key);
          v10->nexus_key = 0;
        }
        v10->nexus_flow_index = 0;
        v50 = malloc_type_malloc(v18, 0xF2B69DE5uLL);
        if (v50)
        {
          v10->nexus_key = v50;
          memcpy(v50, v29, v18);
          v10->nexus_flow_index = v18;
LABEL_21:
          if (v11 >= a3 - 5)
            goto LABEL_334;
          continue;
        }
        __nwlog_obj();
        v113 = objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "strict_malloc";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v18;
        v114 = (void *)_os_log_send_and_compose_impl();

        v109 = v4;
        result = __nwlog_abort((uint64_t)v114);
        if (!result)
        {
          free(v114);
          v10->nexus_key = 0;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v116 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          v117 = (char *)_os_log_send_and_compose_impl();

          v178[0] = 16;
          v177 = 0;
          if (__nwlog_fault(v117, v178, &v177))
          {
            if (v178[0] == 17)
            {
              __nwlog_obj();
              v118 = objc_claimAutoreleasedReturnValue();
              v119 = v178[0];
              if (os_log_type_enabled(v118, (os_log_type_t)v178[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v18;
                _os_log_impl(&dword_182FBE000, v118, v119, "%{public}s malloc(%u) failed", buf, 0x12u);
              }
              goto LABEL_302;
            }
            if (v177)
            {
              v122 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v118 = objc_claimAutoreleasedReturnValue();
              v123 = v178[0];
              v124 = os_log_type_enabled(v118, (os_log_type_t)v178[0]);
              if (v122)
              {
                if (v124)
                {
                  *(_DWORD *)buf = 136446722;
                  *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v18;
                  *(_WORD *)&buf[18] = 2082;
                  *(_QWORD *)&buf[20] = v122;
                  _os_log_impl(&dword_182FBE000, v118, v123, "%{public}s malloc(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
                }

                free(v122);
                goto LABEL_306;
              }
              if (v124)
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v18;
                _os_log_impl(&dword_182FBE000, v118, v123, "%{public}s malloc(%u) failed, no backtrace", buf, 0x12u);
              }
            }
            else
            {
              __nwlog_obj();
              v118 = objc_claimAutoreleasedReturnValue();
              v129 = v178[0];
              if (os_log_type_enabled(v118, (os_log_type_t)v178[0]))
              {
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v18;
                _os_log_impl(&dword_182FBE000, v118, v129, "%{public}s malloc(%u) failed, backtrace limit exceeded", buf, 0x12u);
              }
            }
LABEL_302:

          }
LABEL_306:
          if (v117)
            free(v117);
          v4 = v109;
          goto LABEL_21;
        }
        __break(1u);
        return result;
      case 103:
        v10->nexus_port = 0;
        if ((_DWORD)v18 == 4)
          goto LABEL_66;
        if (v18 >= 5)
        {
          __nwlog_obj();
          v102 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 103;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 4;
            _os_log_impl(&dword_182FBE000, v102, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_66:
          v10->nexus_port = *(_DWORD *)v29;
        }
        goto LABEL_21;
      case 104:
        goto LABEL_21;
      case 156:
        if (object)
        {
          if ((_DWORD)v18 == 16)
            goto LABEL_89;
          if (v18 >= 0x11)
          {
            __nwlog_obj();
            v120 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 156;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v18;
              *(_WORD *)&buf[24] = 1024;
              *(_DWORD *)&buf[26] = 16;
              _os_log_impl(&dword_182FBE000, v120, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
            }

LABEL_89:
            v36 = object;
            *(_OWORD *)(v36 + 28) = *(_OWORD *)v29;
            object = (nw_endpoint_t)v36;

            goto LABEL_21;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v67 = (id)gLogObj;
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
            _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_ERROR, "%{public}s No previous endpoint to apply endpoint agent to", buf, 0xCu);
          }
LABEL_159:

          object = 0;
        }
        goto LABEL_21;
      case 158:
        if (object)
        {
          *(_QWORD *)buf = 0;
          asprintf((char **)buf, "%.*s", v18, (const char *)v29);
          nw_endpoint_set_device_id(object, *(const char **)buf);
          if (*(_QWORD *)buf)
            free(*(void **)buf);
          goto LABEL_21;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v67 = (id)gLogObj;
        if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_ERROR, "%{public}s No previous endpoint to apply endpoint device id to", buf, 0xCu);
        }
        goto LABEL_159;
      case 159:
        if (object)
        {
          objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v29, v18);
          v32 = (void *)objc_claimAutoreleasedReturnValue();
          nw_endpoint_append_public_key(object, v32);

          goto LABEL_21;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v67 = (id)gLogObj;
        if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          _os_log_impl(&dword_182FBE000, v67, OS_LOG_TYPE_ERROR, "%{public}s No previous endpoint to apply public key to", buf, 0xCu);
        }
        goto LABEL_159;
      case 200:
        v37 = nw_path_copy_endpoint_from_tlv(200, v18, v29);

        object = v37;
        if (object)
          objc_storeStrong(location, v37);

        goto LABEL_21;
      case 201:
        v38 = nw_path_copy_endpoint_from_tlv(201, v18, v29);

        v39 = v38;
        object = v39;
        if (v39)
        {
          endpoint = v4->endpoint;
          v41 = (OS_nw_endpoint *)v39;
          if (endpoint)
          {
            is_equal = nw_endpoint_is_equal(v39, endpoint, 0);
            v43 = v4->endpoint;
            if ((is_equal & 1) != 0)
            {
              v41 = v4->endpoint;
            }
            else
            {
              v41 = (OS_nw_endpoint *)object;
              if (v43)
              {
                v41 = (OS_nw_endpoint *)object;
                nw_endpoint_clone_parent_endpoint_properties(object, v43);
              }
            }
          }
          v78 = v41;
          v79 = v10->remote_endpoint;
          v10->remote_endpoint = v78;

          v39 = object;
        }

        goto LABEL_21;
      case 202:
        v56 = nw_path_copy_endpoint_from_tlv(202, v18, v29);

        v57 = v56;
        v33 = v57;
        object = v57;
        if (v57)
        {
          nw_endpoint_set_interface(v57, v10->interface);
          discovered_endpoints = (uint64_t)v10->discovered_endpoints;
          if (!discovered_endpoints)
          {
            v59 = nw_array_create();
            v60 = v10->discovered_endpoints;
            v10->discovered_endpoints = (OS_nw_array *)v59;

            discovered_endpoints = (uint64_t)v10->discovered_endpoints;
          }
          v33 = object;
          nw_array_append(discovered_endpoints, object);
        }
        goto LABEL_20;
      case 203:
        v51 = nw_path_copy_endpoint_from_tlv(203, v18, v29);

        v52 = v51;
        if (v52)
        {
          resolved_endpoints = (uint64_t)v10->resolved_endpoints;
          if (!resolved_endpoints)
          {
            v54 = nw_array_create();
            v55 = v10->resolved_endpoints;
            v10->resolved_endpoints = (OS_nw_array *)v54;

            resolved_endpoints = (uint64_t)v10->resolved_endpoints;
          }
          nw_array_append(resolved_endpoints, v52);
        }
        object = v52;

        goto LABEL_21;
      case 204:
        if ((_DWORD)v18 == 6)
          goto LABEL_57;
        if (v18 >= 7)
        {
          __nwlog_obj();
          v101 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 204;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 6;
            _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_57:
          v175 = *(_DWORD *)v29;
          v176 = *((_WORD *)v29 + 2);
        }
        BYTE4(v170) = 1;
        goto LABEL_21;
      case 205:
        if ((_DWORD)v18 == 6)
          goto LABEL_71;
        if (v18 >= 7)
        {
          __nwlog_obj();
          v103 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 205;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 6;
            _os_log_impl(&dword_182FBE000, v103, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_71:
          v173 = *(_DWORD *)v29;
          v174 = *((_WORD *)v29 + 2);
        }
        LOBYTE(v170) = 1;
        goto LABEL_21;
      case 216:
        if ((_DWORD)v18 == 8)
          goto LABEL_125;
        v109 = v4;
        __nwlog_obj();
        v110 = objc_claimAutoreleasedReturnValue();
        v111 = v110;
        if (v18 >= 9)
        {
          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = "nw_path_verify_tlv_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 216;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = 8;
            _os_log_impl(&dword_182FBE000, v111, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
          }

LABEL_125:
          v61 = *(_DWORD *)v29;
          if (*(_DWORD *)v29 >> 8 == 16776959)
          {
            dns_error = (OS_nw_error *)nw_error_create_dns_error(v61);
          }
          else if ((v61 + 9899) > 0x63)
          {
            dns_error = (OS_nw_error *)nw_error_create_posix_error(v61);
          }
          else
          {
            dns_error = (OS_nw_error *)nw_error_create_tls_error(v61);
          }
          error = v10->error;
          v10->error = dns_error;

          goto LABEL_21;
        }
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v18;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = 8;
        v117 = (char *)_os_log_send_and_compose_impl();

        v178[0] = 16;
        v177 = 0;
        if (!__nwlog_fault(v117, v178, &v177))
          goto LABEL_306;
        if (v178[0] == 17)
        {
          __nwlog_obj();
          v118 = objc_claimAutoreleasedReturnValue();
          v121 = v178[0];
          if (os_log_type_enabled(v118, (os_log_type_t)v178[0]))
          {
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v18;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = 8;
            _os_log_impl(&dword_182FBE000, v118, v121, "%{public}s Invalid length %u for NECP_CLIENT_RESULT_AGENT_ERROR, should be %zu", buf, 0x1Cu);
          }
          goto LABEL_302;
        }
        if (v177)
        {
          v125 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v126 = objc_claimAutoreleasedReturnValue();
          v127 = v178[0];
          v128 = os_log_type_enabled(v126, (os_log_type_t)v178[0]);
          if (v125)
          {
            if (v128)
            {
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = 8;
              *(_WORD *)&buf[28] = 2082;
              *(_QWORD *)&buf[30] = v125;
              _os_log_impl(&dword_182FBE000, v126, v127, "%{public}s Invalid length %u for NECP_CLIENT_RESULT_AGENT_ERROR, should be %zu, dumping backtrace:%{public}s", buf, 0x26u);
            }

            free(v125);
          }
          else
          {
            if (v128)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = 8;
              _os_log_impl(&dword_182FBE000, v126, v127, "%{public}s Invalid length %u for NECP_CLIENT_RESULT_AGENT_ERROR, should be %zu, no backtrace", buf, 0x1Cu);
            }

          }
          goto LABEL_306;
        }
        __nwlog_obj();
        v118 = objc_claimAutoreleasedReturnValue();
        v130 = v178[0];
        if (os_log_type_enabled(v118, (os_log_type_t)v178[0]))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = 8;
          _os_log_impl(&dword_182FBE000, v118, v130, "%{public}s Invalid length %u for NECP_CLIENT_RESULT_AGENT_ERROR, should be %zu, backtrace limit exceeded", buf, 0x1Cu);
        }
        goto LABEL_302;
      case 222:
        if (v10->assigned_protocol)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v33 = (id)gLogObj;
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            assigned_protocol = v10->assigned_protocol;
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = assigned_protocol;
            _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_ERROR, "%{public}s Flow already has protocol %@ assigned, ignoring extra protocol", buf, 0x16u);
          }
LABEL_20:

        }
        else if (v18 < 0x2A)
        {
          __nwlog_obj();
          v80 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v18;
          v64 = (char *)_os_log_send_and_compose_impl();

          v178[0] = 16;
          v177 = 0;
          if (!__nwlog_fault(v64, v178, &v177))
            goto LABEL_218;
          if (v178[0] == 17)
          {
            __nwlog_obj();
            v65 = objc_claimAutoreleasedReturnValue();
            v81 = v178[0];
            if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              _os_log_impl(&dword_182FBE000, v65, v81, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad length %u", buf, 0x12u);
            }
            goto LABEL_217;
          }
          if (!v177)
          {
            __nwlog_obj();
            v65 = objc_claimAutoreleasedReturnValue();
            v96 = v178[0];
            if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              _os_log_impl(&dword_182FBE000, v65, v96, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad length %u, backtrace limit exceeded", buf, 0x12u);
            }
LABEL_217:

LABEL_218:
            if (!v64)
              goto LABEL_21;
LABEL_219:
            free(v64);
            goto LABEL_21;
          }
          v84 = v4;
          v85 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v86 = objc_claimAutoreleasedReturnValue();
          v87 = v178[0];
          v88 = os_log_type_enabled(v86, (os_log_type_t)v178[0]);
          if (v85)
          {
            if (v88)
            {
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v85;
              _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad length %u, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            v4 = v84;
            free(v85);
            if (v64)
              goto LABEL_219;
          }
          else
          {
            if (v88)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v18;
              _os_log_impl(&dword_182FBE000, v86, v87, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad length %u, no backtrace", buf, 0x12u);
            }

            v4 = v84;
            if (v64)
              goto LABEL_219;
          }
        }
        else
        {
          v68 = *((unsigned __int16 *)v29 + 20);
          if (v68 + 42 == v18)
          {
            if (nw_path_flow_load_protocols(void)::onceToken[0] != -1)
              dispatch_once(nw_path_flow_load_protocols(void)::onceToken, &__block_literal_global_27_58486);
            v69 = *((_OWORD *)v29 + 1);
            *(_OWORD *)buf = *(_OWORD *)v29;
            *(_OWORD *)&buf[16] = v69;
            *(_QWORD *)&buf[32] = *((_QWORD *)v29 + 4);
            v70 = nw_protocol_copy_definition_for_identifier(buf);
            v71 = v70;
            if (v70)
            {
              if (*((_WORD *)v29 + 20))
                deserialized_options = nw_protocol_create_deserialized_options(v70, (uint64_t)(v29 + 42), *((unsigned __int16 *)v29 + 20));
              else
                deserialized_options = nw_protocol_create_options(v70);
              p_super = &deserialized_options->super;
              if (deserialized_options)
              {
                v97 = deserialized_options;
                v98 = v10->assigned_protocol;
                v10->assigned_protocol = (OS_nw_protocol_options *)v97;
              }
              else
              {
                __nwlog_obj();
                v98 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v178 = 136446466;
                  v179 = "nw_path_create_flow_result_from_tlv";
                  v180 = 2112;
                  v181 = v71;
                  _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_DEFAULT, "%{public}s Failed to deserialize options for %@", v178, 0x16u);
                }
              }

            }
            else
            {
              __nwlog_obj();
              p_super = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(p_super, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v178 = 136446466;
                v179 = "nw_path_create_flow_result_from_tlv";
                v180 = 2080;
                v181 = buf;
                _os_log_impl(&dword_182FBE000, p_super, OS_LOG_TYPE_DEFAULT, "%{public}s No protocol definition registered for \"%s\"", v178, 0x16u);
              }
            }

          }
          else
          {
            __nwlog_obj();
            v82 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v68;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v18;
            v64 = (char *)_os_log_send_and_compose_impl();

            v178[0] = 16;
            v177 = 0;
            if (!__nwlog_fault(v64, v178, &v177))
              goto LABEL_218;
            if (v178[0] == 17)
            {
              __nwlog_obj();
              v65 = objc_claimAutoreleasedReturnValue();
              v83 = v178[0];
              if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
              {
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v68;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v18;
                _os_log_impl(&dword_182FBE000, v65, v83, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad options length %u (total %u)", buf, 0x18u);
              }
              goto LABEL_217;
            }
            if (!v177)
            {
              __nwlog_obj();
              v65 = objc_claimAutoreleasedReturnValue();
              v99 = v178[0];
              if (os_log_type_enabled(v65, (os_log_type_t)v178[0]))
              {
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v68;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v18;
                _os_log_impl(&dword_182FBE000, v65, v99, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad options length %u (total %u), backtrace limit exceeded", buf, 0x18u);
              }
              goto LABEL_217;
            }
            v90 = v4;
            v91 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v92 = objc_claimAutoreleasedReturnValue();
            v93 = v178[0];
            v94 = os_log_type_enabled(v92, (os_log_type_t)v178[0]);
            if (v91)
            {
              if (v94)
              {
                *(_DWORD *)buf = 136446978;
                *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v68;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v18;
                *(_WORD *)&buf[24] = 2082;
                *(_QWORD *)&buf[26] = v91;
                _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad options length %u (total %u), dumping backtrace:%{public}s", buf, 0x22u);
              }

              v4 = v90;
              free(v91);
              if (v64)
                goto LABEL_219;
            }
            else
            {
              if (v94)
              {
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v68;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v18;
                _os_log_impl(&dword_182FBE000, v92, v93, "%{public}s NW_NECP_CLIENT_PARAMETER_APPLICATION_PROTOCOL has bad options length %u (total %u), no backtrace", buf, 0x18u);
              }

              v4 = v90;
              if (v64)
                goto LABEL_219;
            }
          }
        }
        goto LABEL_21;
      default:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v33 = (id)gLogObj;
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_path_create_flow_result_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v17;
          _os_log_impl(&dword_182FBE000, v33, OS_LOG_TYPE_ERROR, "%{public}s Received unknown flow result TLV (type %d)", buf, 0x12u);
        }
        goto LABEL_20;
    }
  }
}

void sub_183917288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  void *v32;
  void *v33;
  void *v34;

  _Unwind_Resume(a1);
}

void ___ZL27nw_path_flow_load_protocolsv_block_invoke(double a1)
{
  double Helper_x8__nwrapport_copy_protocol_definition;
  uint64_t v2;
  void *inited;
  NSObject *v4;
  id v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  Helper_x8__nwrapport_copy_protocol_definition = gotLoadHelper_x8__nwrapport_copy_protocol_definition(a1);
  if (*(_QWORD *)(v2 + 2552))
  {
    inited = (void *)nwrapport_copy_protocol_definition_delayInitStub(Helper_x8__nwrapport_copy_protocol_definition);
    if (inited)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v4 = (id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        v6 = 136446210;
        v7 = "nw_path_flow_load_protocols_block_invoke";
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_DEBUG, "%{public}s registering rapport protocol", (uint8_t *)&v6, 0xCu);
      }

      v5 = inited;
      nw_protocol_register_handle((uint64_t)v5 + 8, v5, (uint64_t)nw_protocol_implementation_create, (uint64_t)nw_protocol_implementation_accept);

    }
  }
}

uint64_t *nw_path_copy_group_descriptor_from_tlv(unsigned int a1, uint64_t a2, const unsigned __int8 *a3)
{
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  _BYTE buf[20];
  unsigned int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1 >= 0x14)
  {
    *(_OWORD *)buf = *(_OWORD *)a2;
    *(_DWORD *)&buf[16] = *(_DWORD *)(a2 + 16);
    return nw_group_descriptor_create_with_type(*(int *)buf, &buf[4]);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v5 = (id)gLogObj;
  *(_DWORD *)buf = 136447234;
  *(_QWORD *)&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
  *(_WORD *)&buf[12] = 1024;
  *(_DWORD *)&buf[14] = 205;
  *(_WORD *)&buf[18] = 1024;
  v16 = a1;
  v17 = 2080;
  v18 = "nw_path_copy_group_descriptor_from_tlv";
  v19 = 1024;
  v20 = 2094;
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 205;
        *(_WORD *)&buf[18] = 1024;
        v16 = a1;
        v17 = 2080;
        v18 = "nw_path_copy_group_descriptor_from_tlv";
        v19 = 1024;
        v20 = 2094;
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 205;
          *(_WORD *)&buf[18] = 1024;
          v16 = a1;
          v17 = 2080;
          v18 = "nw_path_copy_group_descriptor_from_tlv";
          v19 = 1024;
          v20 = 2094;
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }

        free(backtrace_string);
        if (!v6)
          return 0;
        goto LABEL_9;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 205;
        *(_WORD *)&buf[18] = 1024;
        v16 = a1;
        v17 = 2080;
        v18 = "nw_path_copy_group_descriptor_from_tlv";
        v19 = 1024;
        v20 = 2094;
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_path_copy_group_descriptor_from_tlv";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 205;
        *(_WORD *)&buf[18] = 1024;
        v16 = a1;
        v17 = 2080;
        v18 = "nw_path_copy_group_descriptor_from_tlv";
        v19 = 1024;
        v20 = 2094;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
    }

  }
  if (v6)
LABEL_9:
    free(v6);
  return 0;
}

nw_browse_descriptor_t nw_path_copy_browse_descriptor_from_tlv(unsigned int a1, unsigned __int8 *a2, const unsigned __int8 *a3)
{
  unsigned int v4;
  const char *v5;
  size_t v6;
  size_t v7;
  const char *v8;
  id v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  NWConcrete_nw_browse_descriptor *custom;
  int v19;
  int v20;
  const char *v21;
  size_t v22;
  const char *v23;
  size_t v24;
  size_t v25;
  void *v26;
  os_log_type_t v27;
  unsigned int v28;
  dispatch_data_t v29;
  dispatch_data_t v30;
  id v31;
  os_log_type_t v32;
  id v33;
  os_log_type_t v34;
  void *v35;
  os_log_type_t v36;
  void *v37;
  os_log_type_t v38;
  char *v39;
  os_log_type_t v40;
  _BOOL4 v41;
  os_log_type_t v42;
  _BOOL4 v43;
  int v44;
  _BOOL8 application_service_with_bundle_id;
  size_t v46;
  void *v47;
  char *v48;
  NSObject *v49;
  os_log_type_t v50;
  os_log_type_t v51;
  _BOOL4 v52;
  os_log_type_t v53;
  _BOOL4 v54;
  os_log_type_t v55;
  os_log_type_t v56;
  uint64_t v57;
  uint64_t v58;
  void *v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  os_log_type_t v63;
  _BOOL4 v64;
  os_log_type_t v65;
  os_log_type_t v66;
  char *v67;
  os_log_type_t v68;
  _BOOL4 v69;
  os_log_type_t v70;
  os_log_type_t v71;
  char *v72;
  _BOOL4 v73;
  os_log_type_t v74;
  int v75;
  NSObject *v76;
  os_log_type_t v77;
  char v78;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v81;
  __int16 v82;
  int v83;
  __int16 v84;
  unsigned int v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  int v89;
  __int16 v90;
  char *v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  if (a1 < 0x1C)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v10 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v81 = "nw_path_copy_browse_descriptor_from_tlv";
    v82 = 1024;
    v83 = 202;
    v84 = 1024;
    v85 = a1;
    v86 = 2080;
    v87 = "nw_path_copy_browse_descriptor_from_tlv";
    v88 = 1024;
    v89 = 1997;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (!__nwlog_fault(v11, &type, &v78))
      goto LABEL_26;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136447234;
        v81 = "nw_path_copy_browse_descriptor_from_tlv";
        v82 = 1024;
        v83 = 202;
        v84 = 1024;
        v85 = a1;
        v86 = 2080;
        v87 = "nw_path_copy_browse_descriptor_from_tlv";
        v88 = 1024;
        v89 = 1997;
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
    }
    else if (v78)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v15 = type;
      v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136447490;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1997;
          v90 = 2082;
          v91 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }

        free(backtrace_string);
        if (!v11)
          return 0;
        goto LABEL_27;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136447234;
        v81 = "nw_path_copy_browse_descriptor_from_tlv";
        v82 = 1024;
        v83 = 202;
        v84 = 1024;
        v85 = a1;
        v86 = 2080;
        v87 = "nw_path_copy_browse_descriptor_from_tlv";
        v88 = 1024;
        v89 = 1997;
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v12 = (id)gLogObj;
      v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136447234;
        v81 = "nw_path_copy_browse_descriptor_from_tlv";
        v82 = 1024;
        v83 = 202;
        v84 = 1024;
        v85 = a1;
        v86 = 2080;
        v87 = "nw_path_copy_browse_descriptor_from_tlv";
        v88 = 1024;
        v89 = 1997;
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
    }
    goto LABEL_25;
  }
  if (a2[1])
    return 0;
  v4 = *((_DWORD *)a2 + 1);
  if (!v4)
    return 0;
  v5 = (const char *)(a2 + 8);
  v6 = a1 - 8;
  if (v4 == 2)
  {
    v20 = *((_DWORD *)a2 + 2);
    v19 = *((_DWORD *)a2 + 3);
    v21 = (const char *)(a2 + 16);
    v22 = strnlen((const char *)a2 + 16, v6 - 8);
    if (v22 + 8 >= v6)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v33 = (id)gLogObj;
      *(_DWORD *)buf = 136447234;
      v81 = "nw_path_copy_browse_descriptor_from_tlv";
      v82 = 1024;
      v83 = 202;
      v84 = 1024;
      v85 = a1;
      v86 = 2080;
      v87 = "nw_path_copy_browse_descriptor_from_tlv";
      v88 = 1024;
      v89 = 1926;
      v11 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (__nwlog_fault(v11, &type, &v78))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v12 = objc_claimAutoreleasedReturnValue();
          v34 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1926;
            _os_log_impl(&dword_182FBE000, v12, v34, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
          }
          goto LABEL_25;
        }
        if (!v78)
        {
          __nwlog_obj();
          v12 = objc_claimAutoreleasedReturnValue();
          v56 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1926;
            _os_log_impl(&dword_182FBE000, v12, v56, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
          }
          goto LABEL_25;
        }
        v39 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v42 = type;
        v43 = os_log_type_enabled(v12, type);
        if (!v39)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1926;
            _os_log_impl(&dword_182FBE000, v12, v42, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
          }
          goto LABEL_25;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136447490;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1926;
          v90 = 2082;
          v91 = v39;
          _os_log_impl(&dword_182FBE000, v12, v42, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }
        goto LABEL_110;
      }
      goto LABEL_26;
    }
    v23 = &v5[v22 + 9];
    v24 = strnlen(v23, v6 - (v22 + 9)) + v22 + 9;
    if (v24 >= v6)
    {
      __nwlog_obj();
      v37 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v81 = "nw_path_copy_browse_descriptor_from_tlv";
      v82 = 1024;
      v83 = 202;
      v84 = 1024;
      v85 = a1;
      v86 = 2080;
      v87 = "nw_path_copy_browse_descriptor_from_tlv";
      v88 = 1024;
      v89 = 1933;
      v11 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (__nwlog_fault(v11, &type, &v78))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v12 = objc_claimAutoreleasedReturnValue();
          v38 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1933;
            _os_log_impl(&dword_182FBE000, v12, v38, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
          }
          goto LABEL_25;
        }
        if (!v78)
        {
          __nwlog_obj();
          v12 = objc_claimAutoreleasedReturnValue();
          v66 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1933;
            _os_log_impl(&dword_182FBE000, v12, v66, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
          }
          goto LABEL_25;
        }
        v39 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v53 = type;
        v54 = os_log_type_enabled(v12, type);
        if (!v39)
        {
          if (v54)
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1933;
            _os_log_impl(&dword_182FBE000, v12, v53, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
          }
          goto LABEL_25;
        }
        if (v54)
        {
          *(_DWORD *)buf = 136447490;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1933;
          v90 = 2082;
          v91 = v39;
          _os_log_impl(&dword_182FBE000, v12, v53, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }
        goto LABEL_110;
      }
      goto LABEL_26;
    }
    v25 = v24 + 2;
    if (v24 + 2 > v6)
    {
      __nwlog_obj();
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v81 = "nw_path_copy_browse_descriptor_from_tlv";
      v82 = 1024;
      v83 = 202;
      v84 = 1024;
      v85 = a1;
      v86 = 2080;
      v87 = "nw_path_copy_browse_descriptor_from_tlv";
      v88 = 1024;
      v89 = 1941;
      v11 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (__nwlog_fault(v11, &type, &v78))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v12 = objc_claimAutoreleasedReturnValue();
          v27 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1941;
            _os_log_impl(&dword_182FBE000, v12, v27, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
          }
          goto LABEL_25;
        }
        if (!v78)
        {
          __nwlog_obj();
          v12 = objc_claimAutoreleasedReturnValue();
          v70 = type;
          if (os_log_type_enabled(v12, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1941;
            _os_log_impl(&dword_182FBE000, v12, v70, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
          }
          goto LABEL_25;
        }
        v39 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v63 = type;
        v64 = os_log_type_enabled(v12, type);
        if (!v39)
        {
          if (v64)
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1941;
            _os_log_impl(&dword_182FBE000, v12, v63, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
          }
          goto LABEL_25;
        }
        if (v64)
        {
          *(_DWORD *)buf = 136447490;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1941;
          v90 = 2082;
          v91 = v39;
          _os_log_impl(&dword_182FBE000, v12, v63, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }
        goto LABEL_110;
      }
      goto LABEL_26;
    }
    v44 = v5[v24 + 1];
    application_service_with_bundle_id = nw_browse_descriptor_create_application_service_with_bundle_id(v21, v23);
    custom = (NWConcrete_nw_browse_descriptor *)application_service_with_bundle_id;
    v46 = v24 + 3;
    if (v46 > v6)
    {
      __nwlog_obj();
      v47 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v81 = "nw_path_copy_browse_descriptor_from_tlv";
      v82 = 1024;
      v83 = 202;
      v84 = 1024;
      v85 = a1;
      v86 = 2080;
      v87 = "nw_path_copy_browse_descriptor_from_tlv";
      v88 = 1024;
      v89 = 1951;
      v48 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v78 = 0;
      if (__nwlog_fault(v48, &type, &v78))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v49 = objc_claimAutoreleasedReturnValue();
          v50 = type;
          if (os_log_type_enabled(v49, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1951;
            _os_log_impl(&dword_182FBE000, v49, v50, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
          }
        }
        else if (v78)
        {
          v67 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v49 = objc_claimAutoreleasedReturnValue();
          v68 = type;
          v69 = os_log_type_enabled(v49, type);
          if (v67)
          {
            if (v69)
            {
              *(_DWORD *)buf = 136447490;
              v81 = "nw_path_copy_browse_descriptor_from_tlv";
              v82 = 1024;
              v83 = 202;
              v84 = 1024;
              v85 = a1;
              v86 = 2080;
              v87 = "nw_path_copy_browse_descriptor_from_tlv";
              v88 = 1024;
              v89 = 1951;
              v90 = 2082;
              v91 = v67;
              _os_log_impl(&dword_182FBE000, v49, v68, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
            }

            free(v67);
            goto LABEL_152;
          }
          if (v69)
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1951;
            _os_log_impl(&dword_182FBE000, v49, v68, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
          }
        }
        else
        {
          __nwlog_obj();
          v49 = objc_claimAutoreleasedReturnValue();
          v71 = type;
          if (os_log_type_enabled(v49, type))
          {
            *(_DWORD *)buf = 136447234;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1951;
            _os_log_impl(&dword_182FBE000, v49, v71, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
          }
        }

      }
LABEL_152:
      if (v48)
        free(v48);
      return (nw_browse_descriptor_t)custom;
    }
    v57 = v5[v25];
    if (!v57)
    {
LABEL_162:
      if (custom)
      {
        v75 = *(_DWORD *)&v5[v46];
        nw_browse_descriptor_set_device_types(custom, v20);
        nw_browse_descriptor_set_browse_scope(custom, v19);
        nw_browse_descriptor_set_discover_application_service_endpoints_only(custom, v44 != 0);
        nw_browse_descriptor_set_invitation_scope(custom, v75);
      }
      return (nw_browse_descriptor_t)custom;
    }
    if (application_service_with_bundle_id)
    {
      while (1)
      {
        v58 = (uint64_t)&v5[v46];
        v46 += strnlen(&v5[v46], v6 - v46);
        if (v46 >= v6)
          break;
        nw_browse_descriptor_add_device_filter(custom, v58);
        ++v46;
        if (!--v57)
          goto LABEL_162;
      }
    }
    else
    {
      while (1)
      {
        v46 += strnlen(&v5[v46], v6 - v46);
        if (v46 >= v6)
          break;
        ++v46;
        if (!--v57)
          goto LABEL_162;
      }
    }
    __nwlog_obj();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v81 = "nw_path_copy_browse_descriptor_from_tlv";
    v82 = 1024;
    v83 = 202;
    v84 = 1024;
    v85 = a1;
    v86 = 2080;
    v87 = "nw_path_copy_browse_descriptor_from_tlv";
    v88 = 1024;
    v89 = 1958;
    v60 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (__nwlog_fault(v60, &type, &v78))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v61 = objc_claimAutoreleasedReturnValue();
        v62 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1958;
          _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }
      }
      else if (v78)
      {
        v72 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v61 = objc_claimAutoreleasedReturnValue();
        v77 = type;
        v73 = os_log_type_enabled(v61, type);
        if (v72)
        {
          if (v73)
          {
            *(_DWORD *)buf = 136447490;
            v81 = "nw_path_copy_browse_descriptor_from_tlv";
            v82 = 1024;
            v83 = 202;
            v84 = 1024;
            v85 = a1;
            v86 = 2080;
            v87 = "nw_path_copy_browse_descriptor_from_tlv";
            v88 = 1024;
            v89 = 1958;
            v90 = 2082;
            v91 = v72;
            _os_log_impl(&dword_182FBE000, v61, v77, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
          }

          free(v72);
          goto LABEL_160;
        }
        if (v73)
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1958;
          _os_log_impl(&dword_182FBE000, v61, v77, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }
      }
      else
      {
        __nwlog_obj();
        v61 = objc_claimAutoreleasedReturnValue();
        v74 = type;
        if (os_log_type_enabled(v61, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1958;
          _os_log_impl(&dword_182FBE000, v61, v74, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }
      }

    }
LABEL_160:
    if (v60)
      free(v60);
    goto LABEL_162;
  }
  if (v4 != 1)
  {
    v28 = *a2;
    if (v28 != a1)
    {
      if (v28 >= a1)
        return 0;
      __nwlog_obj();
      v76 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v81 = "nw_path_verify_tlv_length";
        v82 = 1024;
        v83 = 202;
        v84 = 1024;
        v85 = a1;
        v86 = 1024;
        LODWORD(v87) = v28;
        _os_log_impl(&dword_182FBE000, v76, OS_LOG_TYPE_DEBUG, "%{public}s Permitting TLV of type %u with larger length %u, should be %u", buf, 0x1Eu);
      }

    }
    if (v28 > 8)
    {
      v29 = dispatch_data_create(v5, v28 - 8, 0, 0);
      if (v29)
      {
        v30 = v29;
        custom = nw_browse_descriptor_create_custom(v4, v29, 0);

        return (nw_browse_descriptor_t)custom;
      }
    }
    return 0;
  }
  v7 = strnlen((const char *)a2 + 8, a1 - 8);
  if (v7 >= v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v31 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v81 = "nw_path_copy_browse_descriptor_from_tlv";
    v82 = 1024;
    v83 = 202;
    v84 = 1024;
    v85 = a1;
    v86 = 2080;
    v87 = "nw_path_copy_browse_descriptor_from_tlv";
    v88 = 1024;
    v89 = 1900;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (__nwlog_fault(v11, &type, &v78))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v32 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1900;
          _os_log_impl(&dword_182FBE000, v12, v32, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }
        goto LABEL_25;
      }
      if (!v78)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v55 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1900;
          _os_log_impl(&dword_182FBE000, v12, v55, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }
        goto LABEL_25;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v40 = type;
      v41 = os_log_type_enabled(v12, type);
      if (!v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1900;
          _os_log_impl(&dword_182FBE000, v12, v40, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }
        goto LABEL_25;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136447490;
        v81 = "nw_path_copy_browse_descriptor_from_tlv";
        v82 = 1024;
        v83 = 202;
        v84 = 1024;
        v85 = a1;
        v86 = 2080;
        v87 = "nw_path_copy_browse_descriptor_from_tlv";
        v88 = 1024;
        v89 = 1900;
        v90 = 2082;
        v91 = v39;
        _os_log_impl(&dword_182FBE000, v12, v40, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
      }
      goto LABEL_110;
    }
  }
  else
  {
    v8 = &v5[v7 + 1];
    if (strnlen(v8, v6 - (v7 + 1)) + v7 + 1 < v6)
      return nw_browse_descriptor_create_bonjour_service(v5, v8);
    __nwlog_obj();
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v81 = "nw_path_copy_browse_descriptor_from_tlv";
    v82 = 1024;
    v83 = 202;
    v84 = 1024;
    v85 = a1;
    v86 = 2080;
    v87 = "nw_path_copy_browse_descriptor_from_tlv";
    v88 = 1024;
    v89 = 1907;
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v78 = 0;
    if (__nwlog_fault(v11, &type, &v78))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v36 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1907;
          _os_log_impl(&dword_182FBE000, v12, v36, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }
LABEL_25:

        goto LABEL_26;
      }
      if (!v78)
      {
        __nwlog_obj();
        v12 = objc_claimAutoreleasedReturnValue();
        v65 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1907;
          _os_log_impl(&dword_182FBE000, v12, v65, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }
        goto LABEL_25;
      }
      v39 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v51 = type;
      v52 = os_log_type_enabled(v12, type);
      if (!v39)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136447234;
          v81 = "nw_path_copy_browse_descriptor_from_tlv";
          v82 = 1024;
          v83 = 202;
          v84 = 1024;
          v85 = a1;
          v86 = 2080;
          v87 = "nw_path_copy_browse_descriptor_from_tlv";
          v88 = 1024;
          v89 = 1907;
          _os_log_impl(&dword_182FBE000, v12, v51, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }
        goto LABEL_25;
      }
      if (v52)
      {
        *(_DWORD *)buf = 136447490;
        v81 = "nw_path_copy_browse_descriptor_from_tlv";
        v82 = 1024;
        v83 = 202;
        v84 = 1024;
        v85 = a1;
        v86 = 2080;
        v87 = "nw_path_copy_browse_descriptor_from_tlv";
        v88 = 1024;
        v89 = 1907;
        v90 = 2082;
        v91 = v39;
        _os_log_impl(&dword_182FBE000, v12, v51, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
      }
LABEL_110:

      free(v39);
      if (!v11)
        return 0;
      goto LABEL_27;
    }
  }
LABEL_26:
  if (v11)
LABEL_27:
    free(v11);
  return 0;
}

void sub_183919A94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *nw_path_copy_advertise_descriptor_from_tlv(unsigned int a1, uint64_t a2, const unsigned __int8 *a3)
{
  const char *v4;
  int v5;
  unint64_t v6;
  size_t v7;
  const char *v8;
  size_t v9;
  const char *v10;
  size_t v11;
  NSObject *bonjour_service;
  void *v13;
  id v14;
  char *v15;
  NSObject *v16;
  os_log_type_t v17;
  char *backtrace_string;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  size_t v22;
  const char *v23;
  size_t v24;
  const char *v25;
  int v26;
  int v27;
  id v28;
  os_log_type_t v29;
  id v30;
  os_log_type_t v31;
  void *v32;
  os_log_type_t v33;
  void *v34;
  os_log_type_t v35;
  char *v36;
  os_log_type_t v37;
  _BOOL4 v38;
  os_log_type_t v39;
  _BOOL4 v40;
  void *v41;
  os_log_type_t v42;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  _BOOL4 v46;
  os_log_type_t v47;
  os_log_type_t v48;
  os_log_type_t v49;
  _BOOL4 v50;
  os_log_type_t v51;
  os_log_type_t v52;
  os_log_type_t v53;
  char v55;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  int v60;
  __int16 v61;
  unsigned int v62;
  __int16 v63;
  const char *v64;
  __int16 v65;
  int v66;
  __int16 v67;
  char *v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (a1 < 0x1C)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v14 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2080;
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
      goto LABEL_111;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2080;
        _os_log_impl(&dword_182FBE000, v16, v17, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
    }
    else if (v55)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      v19 = type;
      v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136447490;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2080;
          v67 = 2082;
          v68 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
        }

        free(backtrace_string);
        if (!v15)
          return 0;
        goto LABEL_112;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2080;
        _os_log_impl(&dword_182FBE000, v16, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v16 = (id)gLogObj;
      v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2080;
        _os_log_impl(&dword_182FBE000, v16, v21, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
    }
    goto LABEL_110;
  }
  if (*(_BYTE *)(a2 + 1))
    return 0;
  v4 = (const char *)(a2 + 8);
  v5 = *(_DWORD *)(a2 + 4);
  v6 = a1 - 8;
  if (v5 == 2)
  {
    v22 = strnlen((const char *)(a2 + 8), a1 - 8);
    if (v22 >= v6)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v30 = (id)gLogObj;
      *(_DWORD *)buf = 136447234;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2049;
      v15 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (!__nwlog_fault(v15, &type, &v55))
        goto LABEL_111;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v31 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2049;
          _os_log_impl(&dword_182FBE000, v16, v31, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }
        goto LABEL_110;
      }
      if (!v55)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v48 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2049;
          _os_log_impl(&dword_182FBE000, v16, v48, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }
        goto LABEL_110;
      }
      v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v39 = type;
      v40 = os_log_type_enabled(v16, type);
      if (!v36)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2049;
          _os_log_impl(&dword_182FBE000, v16, v39, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }
        goto LABEL_110;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136447490;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2049;
        v67 = 2082;
        v68 = v36;
        _os_log_impl(&dword_182FBE000, v16, v39, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
      }
    }
    else
    {
      v23 = &v4[v22 + 1];
      v24 = strnlen(v23, v6 - (v22 + 1)) + v22 + 1;
      if (v24 < v6)
      {
        v25 = &v4[v24];
        v26 = *(_DWORD *)(v25 + 1);
        v27 = *(_DWORD *)(v25 + 5);
        nw_advertise_descriptor_create_application_service_with_bundle_id(v4, v23);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        nw_advertise_descriptor_set_invitation(v13, v26, v27);
        return v13;
      }
      __nwlog_obj();
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2056;
      v15 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v55 = 0;
      if (!__nwlog_fault(v15, &type, &v55))
      {
LABEL_111:
        if (v15)
LABEL_112:
          free(v15);
        return 0;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v35 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2056;
          _os_log_impl(&dword_182FBE000, v16, v35, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
        }
        goto LABEL_110;
      }
      if (!v55)
      {
        __nwlog_obj();
        v16 = objc_claimAutoreleasedReturnValue();
        v52 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2056;
          _os_log_impl(&dword_182FBE000, v16, v52, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
        }
        goto LABEL_110;
      }
      v36 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v45 = type;
      v46 = os_log_type_enabled(v16, type);
      if (!v36)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136447234;
          v58 = "nw_path_copy_advertise_descriptor_from_tlv";
          v59 = 1024;
          v60 = 204;
          v61 = 1024;
          v62 = a1;
          v63 = 2080;
          v64 = "nw_path_copy_advertise_descriptor_from_tlv";
          v65 = 1024;
          v66 = 2056;
          _os_log_impl(&dword_182FBE000, v16, v45, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
        }
        goto LABEL_110;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136447490;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2056;
        v67 = 2082;
        v68 = v36;
        _os_log_impl(&dword_182FBE000, v16, v45, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
      }
    }
    goto LABEL_85;
  }
  if (v5 != 1)
    return 0;
  v7 = strnlen((const char *)(a2 + 8), a1 - 8);
  if (v7 >= v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v28 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2017;
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
      goto LABEL_111;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2017;
        _os_log_impl(&dword_182FBE000, v16, v29, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
      goto LABEL_110;
    }
    if (!v55)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v47 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2017;
        _os_log_impl(&dword_182FBE000, v16, v47, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
      goto LABEL_110;
    }
    v36 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v37 = type;
    v38 = os_log_type_enabled(v16, type);
    if (!v36)
    {
      if (v38)
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2017;
        _os_log_impl(&dword_182FBE000, v16, v37, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
      goto LABEL_110;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136447490;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2017;
      v67 = 2082;
      v68 = v36;
      _os_log_impl(&dword_182FBE000, v16, v37, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }
    goto LABEL_85;
  }
  v8 = &v4[v7 + 1];
  v9 = strnlen(v8, v6 - (v7 + 1)) + v7 + 1;
  if (v9 >= v6)
  {
    __nwlog_obj();
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2024;
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
      goto LABEL_111;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v33 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2024;
        _os_log_impl(&dword_182FBE000, v16, v33, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
      goto LABEL_110;
    }
    if (!v55)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v51 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2024;
        _os_log_impl(&dword_182FBE000, v16, v51, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
      goto LABEL_110;
    }
    v36 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v43 = type;
    v44 = os_log_type_enabled(v16, type);
    if (!v36)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2024;
        _os_log_impl(&dword_182FBE000, v16, v43, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
      goto LABEL_110;
    }
    if (v44)
    {
      *(_DWORD *)buf = 136447490;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2024;
      v67 = 2082;
      v68 = v36;
      _os_log_impl(&dword_182FBE000, v16, v43, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }
    goto LABEL_85;
  }
  v10 = &v4[v9 + 1];
  v11 = strnlen(v10, v6 - (v9 + 1)) + v9 + 1;
  if (v11 >= v6)
  {
    __nwlog_obj();
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136447234;
    v58 = "nw_path_copy_advertise_descriptor_from_tlv";
    v59 = 1024;
    v60 = 204;
    v61 = 1024;
    v62 = a1;
    v63 = 2080;
    v64 = "nw_path_copy_advertise_descriptor_from_tlv";
    v65 = 1024;
    v66 = 2031;
    v15 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v55 = 0;
    if (!__nwlog_fault(v15, &type, &v55))
      goto LABEL_111;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v42 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2031;
        _os_log_impl(&dword_182FBE000, v16, v42, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
LABEL_110:

      goto LABEL_111;
    }
    if (!v55)
    {
      __nwlog_obj();
      v16 = objc_claimAutoreleasedReturnValue();
      v53 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2031;
        _os_log_impl(&dword_182FBE000, v16, v53, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
      goto LABEL_110;
    }
    v36 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v16 = objc_claimAutoreleasedReturnValue();
    v49 = type;
    v50 = os_log_type_enabled(v16, type);
    if (!v36)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136447234;
        v58 = "nw_path_copy_advertise_descriptor_from_tlv";
        v59 = 1024;
        v60 = 204;
        v61 = 1024;
        v62 = a1;
        v63 = 2080;
        v64 = "nw_path_copy_advertise_descriptor_from_tlv";
        v65 = 1024;
        v66 = 2031;
        _os_log_impl(&dword_182FBE000, v16, v49, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
      goto LABEL_110;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136447490;
      v58 = "nw_path_copy_advertise_descriptor_from_tlv";
      v59 = 1024;
      v60 = 204;
      v61 = 1024;
      v62 = a1;
      v63 = 2080;
      v64 = "nw_path_copy_advertise_descriptor_from_tlv";
      v65 = 1024;
      v66 = 2031;
      v67 = 2082;
      v68 = v36;
      _os_log_impl(&dword_182FBE000, v16, v49, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }
LABEL_85:

    free(v36);
    if (!v15)
      return 0;
    goto LABEL_112;
  }
  bonjour_service = nw_advertise_descriptor_create_bonjour_service(v4, v8, v10);
  v13 = bonjour_service;
  if (v6 > v11 + 1)
    nw_advertise_descriptor_set_txt_record(bonjour_service, &v4[v11 + 1], v6 - (v11 + 1));
  return v13;
}

void sub_18391AE48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_path_create_assign_message_internal(size_t *a1, _OWORD *a2, unsigned int a3, const void *a4, unsigned int a5, void *a6, void *a7, void *a8)
{
  id v15;
  id v16;
  id v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  char *v21;
  unint64_t v22;
  id v23;
  char *v24;
  NSObject *v25;
  os_log_type_t v26;
  id v27;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  char *v31;
  NSObject *v32;
  os_log_type_t v33;
  _BOOL4 v34;
  unint64_t v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  _BOOL4 v39;
  os_log_type_t v40;
  id v41;
  void *v42;
  NSObject *v43;
  os_log_type_t v44;
  char *v45;
  os_log_type_t v46;
  _BOOL4 v47;
  os_log_type_t v48;
  void *v49;
  void *v50;
  void *v51;
  char *v52;
  id v53;
  const char *v54;
  NSObject *v55;
  os_log_type_t v56;
  __int128 v57;
  __int128 v58;
  char *v59;
  NSObject *v60;
  os_log_type_t v61;
  _BOOL4 v62;
  os_log_type_t v63;
  os_log_type_t v64;
  char *v65;
  NSObject *v66;
  size_t *v67;
  id v68;
  char *v69;
  NSObject *v70;
  os_log_type_t v71;
  char *v72;
  NSObject *v73;
  os_log_type_t v74;
  _BOOL4 v75;
  os_log_type_t v76;
  _BOOL8 result;
  void *v78;
  char *v79;
  NSObject *v80;
  os_log_type_t v81;
  NSObject *v82;
  void *v83;
  NSObject *v84;
  void *v85;
  void *v86;
  char *v87;
  NSObject *v88;
  os_log_type_t v89;
  void *v90;
  os_log_type_t v91;
  void *v92;
  const char *v93;
  NSObject *v94;
  os_log_type_t v95;
  void *v96;
  os_log_type_t v97;
  void *v98;
  os_log_type_t v99;
  char *backtrace_string;
  os_log_type_t v101;
  _BOOL4 v102;
  void *v103;
  const char *v104;
  NSObject *v105;
  os_log_type_t v106;
  void *v107;
  os_log_type_t v108;
  char *v109;
  os_log_type_t v110;
  _BOOL4 v111;
  void *v112;
  os_log_type_t v113;
  char *v114;
  os_log_type_t v115;
  _BOOL4 v116;
  void *v117;
  const char *v118;
  NSObject *v119;
  os_log_type_t v120;
  void *v121;
  os_log_type_t v122;
  char *v123;
  os_log_type_t v124;
  _BOOL4 v125;
  char *v126;
  os_log_type_t v127;
  _BOOL4 v128;
  char *v129;
  os_log_type_t v130;
  _BOOL4 v131;
  char *v132;
  os_log_type_t v133;
  _BOOL4 v134;
  os_log_type_t v135;
  _BOOL4 v136;
  char *v137;
  os_log_type_t v138;
  _BOOL4 v139;
  char *v140;
  NSObject *v141;
  os_log_type_t v142;
  _BOOL4 v143;
  char *v144;
  NSObject *v145;
  os_log_type_t v146;
  _BOOL4 v147;
  os_log_type_t v148;
  os_log_type_t v149;
  os_log_type_t v150;
  os_log_type_t v151;
  os_log_type_t v152;
  os_log_type_t v153;
  os_log_type_t v154;
  os_log_type_t v155;
  os_log_type_t v156;
  os_log_type_t v157;
  os_log_type_t v158;
  char *v159;
  size_t __n;
  unsigned int v161;
  size_t *v162;
  id v163;
  id v164;
  char v165;
  os_log_type_t type;
  os_log_type_t v167[16];
  __int128 v168;
  uint64_t v169;
  uint8_t buf[4];
  const char *v171;
  __int16 v172;
  _BYTE v173[20];
  _BYTE v174[10];
  _BYTE v175[10];
  __int16 v176;
  char *v177;
  uint64_t v178;

  v178 = *MEMORY[0x1E0C80C00];
  v164 = a6;
  v15 = a7;
  v16 = a8;
  v163 = v16;
  if (a3 >= 0x10000)
  {
    __nwlog_obj();
    v78 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    v171 = "nw_path_create_assign_message_internal";
    v172 = 1024;
    *(_DWORD *)v173 = a3;
    v79 = (char *)_os_log_send_and_compose_impl();

    v167[0] = OS_LOG_TYPE_ERROR;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v79, v167, &type))
    {
      if (v167[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v80 = objc_claimAutoreleasedReturnValue();
        v81 = v167[0];
        if (os_log_type_enabled(v80, v167[0]))
        {
          *(_DWORD *)buf = 136446466;
          v171 = "nw_path_create_assign_message_internal";
          v172 = 1024;
          *(_DWORD *)v173 = a3;
          _os_log_impl(&dword_182FBE000, v80, v81, "%{public}s nexus_port %u > NEXUS_PORT_MAX", buf, 0x12u);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v80 = objc_claimAutoreleasedReturnValue();
        v101 = v167[0];
        v102 = os_log_type_enabled(v80, v167[0]);
        if (backtrace_string)
        {
          if (v102)
          {
            *(_DWORD *)buf = 136446722;
            v171 = "nw_path_create_assign_message_internal";
            v172 = 1024;
            *(_DWORD *)v173 = a3;
            *(_WORD *)&v173[4] = 2082;
            *(_QWORD *)&v173[6] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v80, v101, "%{public}s nexus_port %u > NEXUS_PORT_MAX, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_270;
        }
        if (v102)
        {
          *(_DWORD *)buf = 136446466;
          v171 = "nw_path_create_assign_message_internal";
          v172 = 1024;
          *(_DWORD *)v173 = a3;
          _os_log_impl(&dword_182FBE000, v80, v101, "%{public}s nexus_port %u > NEXUS_PORT_MAX, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        __nwlog_obj();
        v80 = objc_claimAutoreleasedReturnValue();
        v148 = v167[0];
        if (os_log_type_enabled(v80, v167[0]))
        {
          *(_DWORD *)buf = 136446466;
          v171 = "nw_path_create_assign_message_internal";
          v172 = 1024;
          *(_DWORD *)v173 = a3;
          _os_log_impl(&dword_182FBE000, v80, v148, "%{public}s nexus_port %u > NEXUS_PORT_MAX, backtrace limit exceeded", buf, 0x12u);
        }
      }

    }
LABEL_270:
    v51 = v163;
    if (v79)
      free(v79);
    v21 = 0;
    goto LABEL_142;
  }
  v17 = v16;
  v169 = 0;
  *(_OWORD *)v167 = 0u;
  v168 = 0u;
  if (a1)
    *a1 = 0;
  __n = a5;
  if (a4 != 0 && a5 != 0)
    v18 = a5 + 33;
  else
    v18 = 28;
  if (v164)
    v18 += nw_path_struct_size_for_endpoint_and_metadata(v164, 0, 7);
  if (v15)
    v18 += nw_path_struct_size_for_endpoint_and_metadata(v15, 0, 7);
  if (v17)
    v19 = v18 + 47;
  else
    v19 = v18;
  v161 = a5;
  if (!v19)
  {
    __nwlog_obj();
    v82 = objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v82, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    v171 = "strict_calloc";
    v83 = (void *)_os_log_send_and_compose_impl();

    result = __nwlog_abort((uint64_t)v83);
    if (result)
      goto LABEL_339;
    free(v83);
  }
  v20 = (char *)malloc_type_calloc(1uLL, v19, 0xEAFB8F1AuLL);
  v21 = v20;
  v162 = a1;
  if (v20)
  {
    v22 = (unint64_t)&v20[v19];
    if ((uint64_t)v19 <= 0)
    {
      __nwlog_obj();
      v90 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v171 = "nw_necp_append_tlv";
      v172 = 2048;
      *(_QWORD *)v173 = v21;
      *(_WORD *)&v173[8] = 2048;
      *(_QWORD *)&v173[10] = &v21[v19];
      *(_WORD *)&v173[18] = 1024;
      *(_DWORD *)v174 = 100;
      *(_WORD *)&v174[4] = 1024;
      *(_DWORD *)&v174[6] = 16;
      v24 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (!__nwlog_fault(v24, &type, &v165))
        goto LABEL_49;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v91 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136447234;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = &v21[v19];
          *(_WORD *)&v173[18] = 1024;
          *(_DWORD *)v174 = 100;
          *(_WORD *)&v174[4] = 1024;
          *(_DWORD *)&v174[6] = 16;
          _os_log_impl(&dword_182FBE000, v25, v91, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
        }
        goto LABEL_299;
      }
      if (!v165)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v150 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136447234;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = &v21[v19];
          *(_WORD *)&v173[18] = 1024;
          *(_DWORD *)v174 = 100;
          *(_WORD *)&v174[4] = 1024;
          *(_DWORD *)&v174[6] = 16;
          _os_log_impl(&dword_182FBE000, v25, v150, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
        }
        goto LABEL_299;
      }
      v114 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v32 = objc_claimAutoreleasedReturnValue();
      v115 = type;
      v116 = os_log_type_enabled(v32, type);
      if (v114)
      {
        if (v116)
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = &v21[v19];
          *(_WORD *)&v173[18] = 1024;
          *(_DWORD *)v174 = 100;
          *(_WORD *)&v174[4] = 1024;
          *(_DWORD *)&v174[6] = 16;
          *(_WORD *)v175 = 2082;
          *(_QWORD *)&v175[2] = v114;
          _os_log_impl(&dword_182FBE000, v32, v115, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
        }

        free(v114);
        if (!v24)
          goto LABEL_51;
        goto LABEL_50;
      }
      if (v116)
      {
        *(_DWORD *)buf = 136447234;
        v171 = "nw_necp_append_tlv";
        v172 = 2048;
        *(_QWORD *)v173 = v21;
        *(_WORD *)&v173[8] = 2048;
        *(_QWORD *)&v173[10] = &v21[v19];
        *(_WORD *)&v173[18] = 1024;
        *(_DWORD *)v174 = 100;
        *(_WORD *)&v174[4] = 1024;
        *(_DWORD *)&v174[6] = 16;
        _os_log_impl(&dword_182FBE000, v32, v115, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
      }
      goto LABEL_48;
    }
    if (v19 <= 0x14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = (id)gLogObj;
      *(_DWORD *)buf = 136447490;
      v171 = "nw_necp_append_tlv";
      v172 = 2048;
      *(_QWORD *)v173 = v21;
      *(_WORD *)&v173[8] = 2048;
      *(_QWORD *)&v173[10] = 21;
      *(_WORD *)&v173[18] = 2048;
      *(_QWORD *)v174 = &v21[v19];
      *(_WORD *)&v174[8] = 1024;
      *(_DWORD *)v175 = 100;
      *(_WORD *)&v175[4] = 1024;
      *(_DWORD *)&v175[6] = 16;
      v24 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (!__nwlog_fault(v24, &type, &v165))
        goto LABEL_49;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = 21;
          *(_WORD *)&v173[18] = 2048;
          *(_QWORD *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 100;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 16;
          _os_log_impl(&dword_182FBE000, v25, v26, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
        }
LABEL_299:

        goto LABEL_49;
      }
      if (!v165)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v25 = (id)gLogObj;
        v40 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = 21;
          *(_WORD *)&v173[18] = 2048;
          *(_QWORD *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 100;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 16;
          _os_log_impl(&dword_182FBE000, v25, v40, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
        }
        goto LABEL_299;
      }
      v31 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v32 = (id)gLogObj;
      v33 = type;
      v34 = os_log_type_enabled(v32, type);
      if (v31)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136447746;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = 21;
          *(_WORD *)&v173[18] = 2048;
          *(_QWORD *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 100;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 16;
          v176 = 2082;
          v177 = v31;
          _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
        }

        free(v31);
        if (!v24)
          goto LABEL_51;
        goto LABEL_50;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136447490;
        v171 = "nw_necp_append_tlv";
        v172 = 2048;
        *(_QWORD *)v173 = v21;
        *(_WORD *)&v173[8] = 2048;
        *(_QWORD *)&v173[10] = 21;
        *(_WORD *)&v173[18] = 2048;
        *(_QWORD *)v174 = &v21[v19];
        *(_WORD *)&v174[8] = 1024;
        *(_DWORD *)v175 = 100;
        *(_WORD *)&v175[4] = 1024;
        *(_DWORD *)&v175[6] = 16;
        _os_log_impl(&dword_182FBE000, v32, v33, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
      }
LABEL_48:

      goto LABEL_49;
    }
    *v20 = 100;
    *(_DWORD *)(v20 + 1) = 16;
    if (!a2)
    {
      __nwlog_obj();
      v112 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446722;
      v171 = "nw_necp_append_tlv";
      v172 = 1024;
      *(_DWORD *)v173 = 100;
      *(_WORD *)&v173[4] = 1024;
      *(_DWORD *)&v173[6] = 16;
      v24 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (!__nwlog_fault(v24, &type, &v165))
        goto LABEL_49;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v113 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446722;
          v171 = "nw_necp_append_tlv";
          v172 = 1024;
          *(_DWORD *)v173 = 100;
          *(_WORD *)&v173[4] = 1024;
          *(_DWORD *)&v173[6] = 16;
          _os_log_impl(&dword_182FBE000, v25, v113, "%{public}s type=%u length=%u but value is NULL", buf, 0x18u);
        }
        goto LABEL_299;
      }
      if (!v165)
      {
        __nwlog_obj();
        v25 = objc_claimAutoreleasedReturnValue();
        v156 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446722;
          v171 = "nw_necp_append_tlv";
          v172 = 1024;
          *(_DWORD *)v173 = 100;
          *(_WORD *)&v173[4] = 1024;
          *(_DWORD *)&v173[6] = 16;
          _os_log_impl(&dword_182FBE000, v25, v156, "%{public}s type=%u length=%u but value is NULL, backtrace limit exceeded", buf, 0x18u);
        }
        goto LABEL_299;
      }
      v137 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v32 = objc_claimAutoreleasedReturnValue();
      v138 = type;
      v139 = os_log_type_enabled(v32, type);
      if (v137)
      {
        if (v139)
        {
          *(_DWORD *)buf = 136446978;
          v171 = "nw_necp_append_tlv";
          v172 = 1024;
          *(_DWORD *)v173 = 100;
          *(_WORD *)&v173[4] = 1024;
          *(_DWORD *)&v173[6] = 16;
          *(_WORD *)&v173[10] = 2082;
          *(_QWORD *)&v173[12] = v137;
          _os_log_impl(&dword_182FBE000, v32, v138, "%{public}s type=%u length=%u but value is NULL, dumping backtrace:%{public}s", buf, 0x22u);
        }

        free(v137);
LABEL_49:
        if (!v24)
        {
LABEL_51:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v41 = (id)gLogObj;
          *(_DWORD *)buf = 136446210;
          v171 = "nw_necp_append_tlv";
          v42 = (void *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v165 = 0;
          if (!__nwlog_fault((const char *)v42, &type, &v165))
          {
LABEL_67:
            if (v42)
              free(v42);
            v35 = 0;
LABEL_70:
            v50 = v15;
            v49 = v164;
            v51 = v163;
            if (a4 == 0 || a5 == 0)
              goto LABEL_71;
            goto LABEL_112;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = (id)gLogObj;
            v44 = type;
            if (os_log_type_enabled(v43, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v43, v44, "%{public}s called with null tlv_start", buf, 0xCu);
            }
          }
          else if (v165)
          {
            v45 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = (id)gLogObj;
            v46 = type;
            v47 = os_log_type_enabled(v43, type);
            if (v45)
            {
              if (v47)
              {
                *(_DWORD *)buf = 136446466;
                v171 = "nw_necp_append_tlv";
                v172 = 2082;
                *(_QWORD *)v173 = v45;
                _os_log_impl(&dword_182FBE000, v43, v46, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v45);
              goto LABEL_67;
            }
            if (v47)
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v43, v46, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v43 = (id)gLogObj;
            v48 = type;
            if (os_log_type_enabled(v43, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v43, v48, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
            }
          }
LABEL_66:

          goto LABEL_67;
        }
LABEL_50:
        free(v24);
        goto LABEL_51;
      }
      if (v139)
      {
        *(_DWORD *)buf = 136446722;
        v171 = "nw_necp_append_tlv";
        v172 = 1024;
        *(_DWORD *)v173 = 100;
        *(_WORD *)&v173[4] = 1024;
        *(_DWORD *)&v173[6] = 16;
        _os_log_impl(&dword_182FBE000, v32, v138, "%{public}s type=%u length=%u but value is NULL, no backtrace", buf, 0x18u);
      }
      goto LABEL_48;
    }
    *(_OWORD *)(v20 + 5) = *a2;
    if (v19 <= 0x15)
    {
      __nwlog_obj();
      v121 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136447234;
      v171 = "nw_necp_append_tlv";
      v172 = 2048;
      *(_QWORD *)v173 = v21 + 21;
      *(_WORD *)&v173[8] = 2048;
      *(_QWORD *)&v173[10] = &v21[v19];
      *(_WORD *)&v173[18] = 1024;
      *(_DWORD *)v174 = 101;
      *(_WORD *)&v174[4] = 1024;
      *(_DWORD *)&v174[6] = 2;
      v42 = (void *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (!__nwlog_fault((const char *)v42, &type, &v165))
        goto LABEL_67;
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v122 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136447234;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = &v21[v19];
          *(_WORD *)&v173[18] = 1024;
          *(_DWORD *)v174 = 101;
          *(_WORD *)&v174[4] = 1024;
          *(_DWORD *)&v174[6] = 2;
          _os_log_impl(&dword_182FBE000, v43, v122, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
        }
      }
      else
      {
        if (v165)
        {
          v144 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v145 = objc_claimAutoreleasedReturnValue();
          v146 = type;
          v147 = os_log_type_enabled(v145, type);
          if (v144)
          {
            if (v147)
            {
              *(_DWORD *)buf = 136447490;
              v171 = "nw_necp_append_tlv";
              v172 = 2048;
              *(_QWORD *)v173 = v21 + 21;
              *(_WORD *)&v173[8] = 2048;
              *(_QWORD *)&v173[10] = &v21[v19];
              *(_WORD *)&v173[18] = 1024;
              *(_DWORD *)v174 = 101;
              *(_WORD *)&v174[4] = 1024;
              *(_DWORD *)&v174[6] = 2;
              *(_WORD *)v175 = 2082;
              *(_QWORD *)&v175[2] = v144;
              _os_log_impl(&dword_182FBE000, v145, v146, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
            }

            free(v144);
          }
          else
          {
            if (v147)
            {
              *(_DWORD *)buf = 136447234;
              v171 = "nw_necp_append_tlv";
              v172 = 2048;
              *(_QWORD *)v173 = v21 + 21;
              *(_WORD *)&v173[8] = 2048;
              *(_QWORD *)&v173[10] = &v21[v19];
              *(_WORD *)&v173[18] = 1024;
              *(_DWORD *)v174 = 101;
              *(_WORD *)&v174[4] = 1024;
              *(_DWORD *)&v174[6] = 2;
              _os_log_impl(&dword_182FBE000, v145, v146, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
            }

          }
          goto LABEL_67;
        }
        __nwlog_obj();
        v43 = objc_claimAutoreleasedReturnValue();
        v158 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136447234;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = &v21[v19];
          *(_WORD *)&v173[18] = 1024;
          *(_DWORD *)v174 = 101;
          *(_WORD *)&v174[4] = 1024;
          *(_DWORD *)&v174[6] = 2;
          _os_log_impl(&dword_182FBE000, v43, v158, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
        }
      }
      goto LABEL_66;
    }
    if (v19 - 21 > 6)
    {
      v20[21] = 101;
      *(_DWORD *)(v20 + 22) = 2;
      *((_WORD *)v20 + 13) = a3;
      v35 = (unint64_t)(v20 + 28);
      goto LABEL_70;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v27 = (id)gLogObj;
    *(_DWORD *)buf = 136447490;
    v171 = "nw_necp_append_tlv";
    v172 = 2048;
    *(_QWORD *)v173 = v21 + 21;
    *(_WORD *)&v173[8] = 2048;
    *(_QWORD *)&v173[10] = 7;
    *(_WORD *)&v173[18] = 2048;
    *(_QWORD *)v174 = &v21[v19];
    *(_WORD *)&v174[8] = 1024;
    *(_DWORD *)v175 = 101;
    *(_WORD *)&v175[4] = 1024;
    *(_DWORD *)&v175[6] = 2;
    v28 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (__nwlog_fault(v28, &type, &v165))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = (id)gLogObj;
        v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = 7;
          *(_WORD *)&v173[18] = 2048;
          *(_QWORD *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
        }
LABEL_30:

        goto LABEL_109;
      }
      if (!v165)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v29 = (id)gLogObj;
        v64 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = 7;
          *(_WORD *)&v173[18] = 2048;
          *(_QWORD *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          _os_log_impl(&dword_182FBE000, v29, v64, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
        }
        goto LABEL_30;
      }
      v36 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v37 = (id)gLogObj;
      v38 = type;
      v39 = os_log_type_enabled(v37, type);
      if (v36)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136447746;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = 7;
          *(_WORD *)&v173[18] = 2048;
          *(_QWORD *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          v176 = 2082;
          v177 = v36;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
        }

        free(v36);
      }
      else
      {
        if (v39)
        {
          *(_DWORD *)buf = 136447490;
          v171 = "nw_necp_append_tlv";
          v172 = 2048;
          *(_QWORD *)v173 = v21 + 21;
          *(_WORD *)&v173[8] = 2048;
          *(_QWORD *)&v173[10] = 7;
          *(_WORD *)&v173[18] = 2048;
          *(_QWORD *)v174 = &v21[v19];
          *(_WORD *)&v174[8] = 1024;
          *(_DWORD *)v175 = 101;
          *(_WORD *)&v175[4] = 1024;
          *(_DWORD *)&v175[6] = 2;
          _os_log_impl(&dword_182FBE000, v37, v38, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
        }

      }
    }
LABEL_109:
    v51 = v163;
    if (v28)
      free(v28);
    v35 = 0;
    v50 = v15;
    v49 = v164;
    if (a4 == 0 || a5 == 0)
    {
LABEL_71:
      if (v49)
        goto LABEL_72;
LABEL_138:
      if (!v50)
      {
LABEL_73:
        if (v51)
          goto LABEL_74;
        goto LABEL_140;
      }
LABEL_139:
      v35 = nw_path_evaluator_add_endpoint_to_necp_message(v50, 201, v35, v22, 7);
      if (v51)
      {
LABEL_74:
        v52 = v51;

        *(_OWORD *)v167 = *(_OWORD *)(v52 + 8);
        v168 = *(_OWORD *)(v52 + 24);
        v169 = *((_QWORD *)v52 + 5);
        if (v35)
        {
          if (v22)
          {
            if (v35 >= v22)
            {
              __nwlog_obj();
              v98 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 136447234;
              v171 = "nw_necp_append_tlv";
              v172 = 2048;
              *(_QWORD *)v173 = v35;
              *(_WORD *)&v173[8] = 2048;
              *(_QWORD *)&v173[10] = v22;
              *(_WORD *)&v173[18] = 1024;
              *(_DWORD *)v174 = 222;
              *(_WORD *)&v174[4] = 1024;
              *(_DWORD *)&v174[6] = 42;
              v54 = (const char *)_os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v165 = 0;
              if (!__nwlog_fault(v54, &type, &v165))
                goto LABEL_99;
              if (type == OS_LOG_TYPE_FAULT)
              {
                __nwlog_obj();
                v55 = objc_claimAutoreleasedReturnValue();
                v99 = type;
                if (os_log_type_enabled(v55, type))
                {
                  *(_DWORD *)buf = 136447234;
                  v171 = "nw_necp_append_tlv";
                  v172 = 2048;
                  *(_QWORD *)v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(_QWORD *)&v173[10] = v22;
                  *(_WORD *)&v173[18] = 1024;
                  *(_DWORD *)v174 = 222;
                  *(_WORD *)&v174[4] = 1024;
                  *(_DWORD *)&v174[6] = 42;
                  _os_log_impl(&dword_182FBE000, v55, v99, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
                }
                goto LABEL_290;
              }
              if (!v165)
              {
                __nwlog_obj();
                v55 = objc_claimAutoreleasedReturnValue();
                v153 = type;
                if (os_log_type_enabled(v55, type))
                {
                  *(_DWORD *)buf = 136447234;
                  v171 = "nw_necp_append_tlv";
                  v172 = 2048;
                  *(_QWORD *)v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(_QWORD *)&v173[10] = v22;
                  *(_WORD *)&v173[18] = 1024;
                  *(_DWORD *)v174 = 222;
                  *(_WORD *)&v174[4] = 1024;
                  *(_DWORD *)&v174[6] = 42;
                  _os_log_impl(&dword_182FBE000, v55, v153, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
                }
                goto LABEL_290;
              }
              v129 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              v60 = objc_claimAutoreleasedReturnValue();
              v130 = type;
              v131 = os_log_type_enabled(v60, type);
              if (!v129)
              {
                if (v131)
                {
                  *(_DWORD *)buf = 136447234;
                  v171 = "nw_necp_append_tlv";
                  v172 = 2048;
                  *(_QWORD *)v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(_QWORD *)&v173[10] = v22;
                  *(_WORD *)&v173[18] = 1024;
                  *(_DWORD *)v174 = 222;
                  *(_WORD *)&v174[4] = 1024;
                  *(_DWORD *)&v174[6] = 42;
                  _os_log_impl(&dword_182FBE000, v60, v130, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
                }
                goto LABEL_98;
              }
              if (v131)
              {
                *(_DWORD *)buf = 136447490;
                v171 = "nw_necp_append_tlv";
                v172 = 2048;
                *(_QWORD *)v173 = v35;
                *(_WORD *)&v173[8] = 2048;
                *(_QWORD *)&v173[10] = v22;
                *(_WORD *)&v173[18] = 1024;
                *(_DWORD *)v174 = 222;
                *(_WORD *)&v174[4] = 1024;
                *(_DWORD *)&v174[6] = 42;
                *(_WORD *)v175 = 2082;
                *(_QWORD *)&v175[2] = v129;
                _os_log_impl(&dword_182FBE000, v60, v130, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
              }

              free(v129);
            }
            else
            {
              if (v22 - v35 > 0x2E)
              {
                *(_BYTE *)v35 = -34;
                *(_DWORD *)(v35 + 1) = 42;
                v57 = *(_OWORD *)v167;
                v58 = v168;
                *(_QWORD *)(v35 + 37) = v169;
                *(_OWORD *)(v35 + 21) = v58;
                *(_OWORD *)(v35 + 5) = v57;
                *(_WORD *)(v35 + 45) = 0;
                goto LABEL_102;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v53 = (id)gLogObj;
              *(_DWORD *)buf = 136447490;
              v171 = "nw_necp_append_tlv";
              v172 = 2048;
              *(_QWORD *)v173 = v35;
              *(_WORD *)&v173[8] = 2048;
              *(_QWORD *)&v173[10] = 47;
              *(_WORD *)&v173[18] = 2048;
              *(_QWORD *)v174 = v22;
              *(_WORD *)&v174[8] = 1024;
              *(_DWORD *)v175 = 222;
              *(_WORD *)&v175[4] = 1024;
              *(_DWORD *)&v175[6] = 42;
              v54 = (const char *)_os_log_send_and_compose_impl();

              type = OS_LOG_TYPE_ERROR;
              v165 = 0;
              if (__nwlog_fault(v54, &type, &v165))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v55 = (id)gLogObj;
                  v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136447490;
                    v171 = "nw_necp_append_tlv";
                    v172 = 2048;
                    *(_QWORD *)v173 = v35;
                    *(_WORD *)&v173[8] = 2048;
                    *(_QWORD *)&v173[10] = 47;
                    *(_WORD *)&v173[18] = 2048;
                    *(_QWORD *)v174 = v22;
                    *(_WORD *)&v174[8] = 1024;
                    *(_DWORD *)v175 = 222;
                    *(_WORD *)&v175[4] = 1024;
                    *(_DWORD *)&v175[6] = 42;
                    _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
                  }
LABEL_290:

                  goto LABEL_99;
                }
                if (!v165)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v55 = (id)gLogObj;
                  v63 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136447490;
                    v171 = "nw_necp_append_tlv";
                    v172 = 2048;
                    *(_QWORD *)v173 = v35;
                    *(_WORD *)&v173[8] = 2048;
                    *(_QWORD *)&v173[10] = 47;
                    *(_WORD *)&v173[18] = 2048;
                    *(_QWORD *)v174 = v22;
                    *(_WORD *)&v174[8] = 1024;
                    *(_DWORD *)v175 = 222;
                    *(_WORD *)&v175[4] = 1024;
                    *(_DWORD *)&v175[6] = 42;
                    _os_log_impl(&dword_182FBE000, v55, v63, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
                  }
                  goto LABEL_290;
                }
                v59 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v60 = (id)gLogObj;
                v61 = type;
                v62 = os_log_type_enabled(v60, type);
                if (v59)
                {
                  if (v62)
                  {
                    *(_DWORD *)buf = 136447746;
                    v171 = "nw_necp_append_tlv";
                    v172 = 2048;
                    *(_QWORD *)v173 = v35;
                    *(_WORD *)&v173[8] = 2048;
                    *(_QWORD *)&v173[10] = 47;
                    *(_WORD *)&v173[18] = 2048;
                    *(_QWORD *)v174 = v22;
                    *(_WORD *)&v174[8] = 1024;
                    *(_DWORD *)v175 = 222;
                    *(_WORD *)&v175[4] = 1024;
                    *(_DWORD *)&v175[6] = 42;
                    v176 = 2082;
                    v177 = v59;
                    _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                  }

                  free(v59);
                  if (v54)
                  {
LABEL_100:
                    v65 = (char *)v54;
LABEL_101:
                    free(v65);
                  }
LABEL_102:
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v66 = (id)gLogObj;
                  if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446466;
                    v171 = "nw_path_create_assign_message_internal";
                    v172 = 2112;
                    *(_QWORD *)v173 = v52;
                    _os_log_impl(&dword_182FBE000, v66, OS_LOG_TYPE_DEBUG, "%{public}s Serialized peer protocol %@", buf, 0x16u);
                  }

                  v51 = v163;
                  v67 = v162;
                  if (!v162)
                    goto LABEL_142;
                  goto LABEL_141;
                }
                if (v62)
                {
                  *(_DWORD *)buf = 136447490;
                  v171 = "nw_necp_append_tlv";
                  v172 = 2048;
                  *(_QWORD *)v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(_QWORD *)&v173[10] = 47;
                  *(_WORD *)&v173[18] = 2048;
                  *(_QWORD *)v174 = v22;
                  *(_WORD *)&v174[8] = 1024;
                  *(_DWORD *)v175 = 222;
                  *(_WORD *)&v175[4] = 1024;
                  *(_DWORD *)&v175[6] = 42;
                  _os_log_impl(&dword_182FBE000, v60, v61, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                }
LABEL_98:

              }
            }
LABEL_99:
            if (!v54)
              goto LABEL_102;
            goto LABEL_100;
          }
          __nwlog_obj();
          v96 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v171 = "nw_necp_append_tlv";
          v93 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v165 = 0;
          if (!__nwlog_fault(v93, &type, &v165))
            goto LABEL_312;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v94 = objc_claimAutoreleasedReturnValue();
            v97 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v94, v97, "%{public}s called with null beyond", buf, 0xCu);
            }
          }
          else if (v165)
          {
            v126 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v94 = objc_claimAutoreleasedReturnValue();
            v127 = type;
            v128 = os_log_type_enabled(v94, type);
            if (v126)
            {
              if (v128)
              {
                *(_DWORD *)buf = 136446466;
                v171 = "nw_necp_append_tlv";
                v172 = 2082;
                *(_QWORD *)v173 = v126;
                _os_log_impl(&dword_182FBE000, v94, v127, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v126);
              if (!v93)
                goto LABEL_102;
LABEL_313:
              v65 = (char *)v93;
              goto LABEL_101;
            }
            if (v128)
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v94, v127, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v94 = objc_claimAutoreleasedReturnValue();
            v152 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v94, v152, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        else
        {
          __nwlog_obj();
          v92 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 136446210;
          v171 = "nw_necp_append_tlv";
          v93 = (const char *)_os_log_send_and_compose_impl();

          type = OS_LOG_TYPE_ERROR;
          v165 = 0;
          if (!__nwlog_fault(v93, &type, &v165))
            goto LABEL_312;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            v94 = objc_claimAutoreleasedReturnValue();
            v95 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v94, v95, "%{public}s called with null tlv_start", buf, 0xCu);
            }
          }
          else if (v165)
          {
            v123 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v94 = objc_claimAutoreleasedReturnValue();
            v124 = type;
            v125 = os_log_type_enabled(v94, type);
            if (v123)
            {
              if (v125)
              {
                *(_DWORD *)buf = 136446466;
                v171 = "nw_necp_append_tlv";
                v172 = 2082;
                *(_QWORD *)v173 = v123;
                _os_log_impl(&dword_182FBE000, v94, v124, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v123);
LABEL_312:
              if (!v93)
                goto LABEL_102;
              goto LABEL_313;
            }
            if (v125)
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v94, v124, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            __nwlog_obj();
            v94 = objc_claimAutoreleasedReturnValue();
            v151 = type;
            if (os_log_type_enabled(v94, type))
            {
              *(_DWORD *)buf = 136446210;
              v171 = "nw_necp_append_tlv";
              _os_log_impl(&dword_182FBE000, v94, v151, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }

        goto LABEL_312;
      }
LABEL_140:
      v67 = v162;
      if (!v162)
      {
LABEL_142:

        return (BOOL)v21;
      }
LABEL_141:
      *v67 = v19;
      goto LABEL_142;
    }
LABEL_112:
    if (v35)
    {
      if (v22)
      {
        if (v35 < v22)
        {
          if (v22 - v35 < (unint64_t)a5 + 5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v68 = (id)gLogObj;
            *(_DWORD *)buf = 136447490;
            v171 = "nw_necp_append_tlv";
            v172 = 2048;
            *(_QWORD *)v173 = v35;
            *(_WORD *)&v173[8] = 2048;
            *(_QWORD *)&v173[10] = a5 + 5;
            *(_WORD *)&v173[18] = 2048;
            *(_QWORD *)v174 = v22;
            *(_WORD *)&v174[8] = 1024;
            *(_DWORD *)v175 = 102;
            *(_WORD *)&v175[4] = 1024;
            *(_DWORD *)&v175[6] = a5;
            v69 = (char *)_os_log_send_and_compose_impl();

            type = OS_LOG_TYPE_ERROR;
            v165 = 0;
            if (!__nwlog_fault(v69, &type, &v165))
              goto LABEL_135;
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v70 = (id)gLogObj;
              v71 = type;
              if (os_log_type_enabled(v70, type))
              {
                *(_DWORD *)buf = 136447490;
                v171 = "nw_necp_append_tlv";
                v172 = 2048;
                *(_QWORD *)v173 = v35;
                *(_WORD *)&v173[8] = 2048;
                *(_QWORD *)&v173[10] = a5 + 5;
                *(_WORD *)&v173[18] = 2048;
                *(_QWORD *)v174 = v22;
                *(_WORD *)&v174[8] = 1024;
                *(_DWORD *)v175 = 102;
                *(_WORD *)&v175[4] = 1024;
                *(_DWORD *)&v175[6] = a5;
                _os_log_impl(&dword_182FBE000, v70, v71, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u", buf, 0x36u);
              }
            }
            else
            {
              if (v165)
              {
                v72 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v73 = (id)gLogObj;
                v74 = type;
                v75 = os_log_type_enabled(v73, type);
                if (v72)
                {
                  if (v75)
                  {
                    *(_DWORD *)buf = 136447746;
                    v171 = "nw_necp_append_tlv";
                    v172 = 2048;
                    *(_QWORD *)v173 = v35;
                    *(_WORD *)&v173[8] = 2048;
                    *(_QWORD *)&v173[10] = __n + 5;
                    *(_WORD *)&v173[18] = 2048;
                    *(_QWORD *)v174 = v22;
                    *(_WORD *)&v174[8] = 1024;
                    *(_DWORD *)v175 = 102;
                    *(_WORD *)&v175[4] = 1024;
                    *(_DWORD *)&v175[6] = v161;
                    v176 = 2082;
                    v177 = v72;
                    _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x40u);
                  }

                  free(v72);
                  if (!v69)
                  {
LABEL_137:
                    v35 = 0;
                    v50 = v15;
                    v49 = v164;
                    v51 = v163;
                    if (!v164)
                      goto LABEL_138;
                    goto LABEL_72;
                  }
LABEL_136:
                  free(v69);
                  goto LABEL_137;
                }
                if (v75)
                {
                  *(_DWORD *)buf = 136447490;
                  v171 = "nw_necp_append_tlv";
                  v172 = 2048;
                  *(_QWORD *)v173 = v35;
                  *(_WORD *)&v173[8] = 2048;
                  *(_QWORD *)&v173[10] = __n + 5;
                  *(_WORD *)&v173[18] = 2048;
                  *(_QWORD *)v174 = v22;
                  *(_WORD *)&v174[8] = 1024;
                  *(_DWORD *)v175 = 102;
                  *(_WORD *)&v175[4] = 1024;
                  *(_DWORD *)&v175[6] = v161;
                  _os_log_impl(&dword_182FBE000, v73, v74, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, no backtrace", buf, 0x36u);
                }

LABEL_135:
                if (!v69)
                  goto LABEL_137;
                goto LABEL_136;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v70 = (id)gLogObj;
              v76 = type;
              if (os_log_type_enabled(v70, type))
              {
                *(_DWORD *)buf = 136447490;
                v171 = "nw_necp_append_tlv";
                v172 = 2048;
                *(_QWORD *)v173 = v35;
                *(_WORD *)&v173[8] = 2048;
                *(_QWORD *)&v173[10] = a5 + 5;
                *(_WORD *)&v173[18] = 2048;
                *(_QWORD *)v174 = v22;
                *(_WORD *)&v174[8] = 1024;
                *(_DWORD *)v175 = 102;
                *(_WORD *)&v175[4] = 1024;
                *(_DWORD *)&v175[6] = a5;
                _os_log_impl(&dword_182FBE000, v70, v76, "%{public}s buffer too short tlv_start=%p full_tlv_len=%zu beyond=%p type=%u length=%u, backtrace limit exceeded", buf, 0x36u);
              }
            }

            goto LABEL_135;
          }
          *(_BYTE *)v35 = 102;
          *(_DWORD *)(v35 + 1) = a5;
          memcpy((void *)(v35 + 5), a4, a5);
          v35 += a5 + 5;
          v50 = v15;
          v49 = v164;
          if (!v164)
            goto LABEL_138;
LABEL_72:
          v35 = nw_path_evaluator_add_endpoint_to_necp_message(v49, 200, v35, v22, 7);
          if (!v50)
            goto LABEL_73;
          goto LABEL_139;
        }
        __nwlog_obj();
        v117 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 136447234;
        v171 = "nw_necp_append_tlv";
        v172 = 2048;
        *(_QWORD *)v173 = v35;
        *(_WORD *)&v173[8] = 2048;
        *(_QWORD *)&v173[10] = v22;
        *(_WORD *)&v173[18] = 1024;
        *(_DWORD *)v174 = 102;
        *(_WORD *)&v174[4] = 1024;
        *(_DWORD *)&v174[6] = a5;
        v118 = (const char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v165 = 0;
        if (!__nwlog_fault(v118, &type, &v165))
          goto LABEL_331;
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v119 = objc_claimAutoreleasedReturnValue();
          v120 = type;
          if (os_log_type_enabled(v119, type))
          {
            *(_DWORD *)buf = 136447234;
            v171 = "nw_necp_append_tlv";
            v172 = 2048;
            *(_QWORD *)v173 = v35;
            *(_WORD *)&v173[8] = 2048;
            *(_QWORD *)&v173[10] = v22;
            *(_WORD *)&v173[18] = 1024;
            *(_DWORD *)v174 = 102;
            *(_WORD *)&v174[4] = 1024;
            *(_DWORD *)&v174[6] = a5;
            _os_log_impl(&dword_182FBE000, v119, v120, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u", buf, 0x2Cu);
          }
        }
        else
        {
          if (v165)
          {
            v140 = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            v141 = objc_claimAutoreleasedReturnValue();
            v142 = type;
            v143 = os_log_type_enabled(v141, type);
            if (v140)
            {
              if (v143)
              {
                *(_DWORD *)buf = 136447490;
                v171 = "nw_necp_append_tlv";
                v172 = 2048;
                *(_QWORD *)v173 = v35;
                *(_WORD *)&v173[8] = 2048;
                *(_QWORD *)&v173[10] = v22;
                *(_WORD *)&v173[18] = 1024;
                *(_DWORD *)v174 = 102;
                *(_WORD *)&v174[4] = 1024;
                *(_DWORD *)&v174[6] = v161;
                *(_WORD *)v175 = 2082;
                *(_QWORD *)&v175[2] = v140;
                _os_log_impl(&dword_182FBE000, v141, v142, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, dumping backtrace:%{public}s", buf, 0x36u);
              }

              free(v140);
            }
            else
            {
              if (v143)
              {
                *(_DWORD *)buf = 136447234;
                v171 = "nw_necp_append_tlv";
                v172 = 2048;
                *(_QWORD *)v173 = v35;
                *(_WORD *)&v173[8] = 2048;
                *(_QWORD *)&v173[10] = v22;
                *(_WORD *)&v173[18] = 1024;
                *(_DWORD *)v174 = 102;
                *(_WORD *)&v174[4] = 1024;
                *(_DWORD *)&v174[6] = v161;
                _os_log_impl(&dword_182FBE000, v141, v142, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, no backtrace", buf, 0x2Cu);
              }

            }
            goto LABEL_331;
          }
          __nwlog_obj();
          v119 = objc_claimAutoreleasedReturnValue();
          v157 = type;
          if (os_log_type_enabled(v119, type))
          {
            *(_DWORD *)buf = 136447234;
            v171 = "nw_necp_append_tlv";
            v172 = 2048;
            *(_QWORD *)v173 = v35;
            *(_WORD *)&v173[8] = 2048;
            *(_QWORD *)&v173[10] = v22;
            *(_WORD *)&v173[18] = 1024;
            *(_DWORD *)v174 = 102;
            *(_WORD *)&v174[4] = 1024;
            *(_DWORD *)&v174[6] = a5;
            _os_log_impl(&dword_182FBE000, v119, v157, "%{public}s Invalid tlv_start %p >= beyond %p type=%u length=%u, backtrace limit exceeded", buf, 0x2Cu);
          }
        }

LABEL_331:
        v51 = v163;
        if (!v118)
          goto LABEL_334;
        v159 = (char *)v118;
LABEL_333:
        free(v159);
LABEL_334:
        v35 = 0;
        v50 = v15;
        v49 = v164;
        if (!v164)
          goto LABEL_138;
        goto LABEL_72;
      }
      __nwlog_obj();
      v107 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v171 = "nw_necp_append_tlv";
      v104 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (__nwlog_fault(v104, &type, &v165))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v105 = objc_claimAutoreleasedReturnValue();
          v108 = type;
          if (os_log_type_enabled(v105, type))
          {
            *(_DWORD *)buf = 136446210;
            v171 = "nw_necp_append_tlv";
            _os_log_impl(&dword_182FBE000, v105, v108, "%{public}s called with null beyond", buf, 0xCu);
          }
LABEL_322:

          goto LABEL_323;
        }
        if (!v165)
        {
          __nwlog_obj();
          v105 = objc_claimAutoreleasedReturnValue();
          v155 = type;
          if (os_log_type_enabled(v105, type))
          {
            *(_DWORD *)buf = 136446210;
            v171 = "nw_necp_append_tlv";
            _os_log_impl(&dword_182FBE000, v105, v155, "%{public}s called with null beyond, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_322;
        }
        v132 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v105 = objc_claimAutoreleasedReturnValue();
        v135 = type;
        v136 = os_log_type_enabled(v105, type);
        if (!v132)
        {
          if (v136)
          {
            *(_DWORD *)buf = 136446210;
            v171 = "nw_necp_append_tlv";
            _os_log_impl(&dword_182FBE000, v105, v135, "%{public}s called with null beyond, no backtrace", buf, 0xCu);
          }
          goto LABEL_322;
        }
        if (v136)
        {
          *(_DWORD *)buf = 136446466;
          v171 = "nw_necp_append_tlv";
          v172 = 2082;
          *(_QWORD *)v173 = v132;
          _os_log_impl(&dword_182FBE000, v105, v135, "%{public}s called with null beyond, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_242;
      }
    }
    else
    {
      __nwlog_obj();
      v103 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v171 = "nw_necp_append_tlv";
      v104 = (const char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v165 = 0;
      if (__nwlog_fault(v104, &type, &v165))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v105 = objc_claimAutoreleasedReturnValue();
          v106 = type;
          if (os_log_type_enabled(v105, type))
          {
            *(_DWORD *)buf = 136446210;
            v171 = "nw_necp_append_tlv";
            _os_log_impl(&dword_182FBE000, v105, v106, "%{public}s called with null tlv_start", buf, 0xCu);
          }
          goto LABEL_322;
        }
        if (!v165)
        {
          __nwlog_obj();
          v105 = objc_claimAutoreleasedReturnValue();
          v154 = type;
          if (os_log_type_enabled(v105, type))
          {
            *(_DWORD *)buf = 136446210;
            v171 = "nw_necp_append_tlv";
            _os_log_impl(&dword_182FBE000, v105, v154, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_322;
        }
        v132 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v105 = objc_claimAutoreleasedReturnValue();
        v133 = type;
        v134 = os_log_type_enabled(v105, type);
        if (!v132)
        {
          if (v134)
          {
            *(_DWORD *)buf = 136446210;
            v171 = "nw_necp_append_tlv";
            _os_log_impl(&dword_182FBE000, v105, v133, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
          }
          goto LABEL_322;
        }
        if (v134)
        {
          *(_DWORD *)buf = 136446466;
          v171 = "nw_necp_append_tlv";
          v172 = 2082;
          *(_QWORD *)v173 = v132;
          _os_log_impl(&dword_182FBE000, v105, v133, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_242:

        free(v132);
      }
    }
LABEL_323:
    v51 = v163;
    if (!v104)
      goto LABEL_334;
    v159 = (char *)v104;
    goto LABEL_333;
  }
  __nwlog_obj();
  v84 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v84, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v171 = "strict_calloc";
  v172 = 2048;
  *(_QWORD *)v173 = 1;
  *(_WORD *)&v173[8] = 2048;
  *(_QWORD *)&v173[10] = v19;
  v85 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v85);
  if (!result)
  {
    free(v85);
    __nwlog_obj();
    v86 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v171 = "nw_necp_append_tlv";
    v87 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v165 = 0;
    if (__nwlog_fault(v87, &type, &v165))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v88 = objc_claimAutoreleasedReturnValue();
        v89 = type;
        if (os_log_type_enabled(v88, type))
        {
          *(_DWORD *)buf = 136446210;
          v171 = "nw_necp_append_tlv";
          _os_log_impl(&dword_182FBE000, v88, v89, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }
      else if (v165)
      {
        v109 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v88 = objc_claimAutoreleasedReturnValue();
        v110 = type;
        v111 = os_log_type_enabled(v88, type);
        if (v109)
        {
          if (v111)
          {
            *(_DWORD *)buf = 136446466;
            v171 = "nw_necp_append_tlv";
            v172 = 2082;
            *(_QWORD *)v173 = v109;
            _os_log_impl(&dword_182FBE000, v88, v110, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v109);
          goto LABEL_276;
        }
        if (v111)
        {
          *(_DWORD *)buf = 136446210;
          v171 = "nw_necp_append_tlv";
          _os_log_impl(&dword_182FBE000, v88, v110, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __nwlog_obj();
        v88 = objc_claimAutoreleasedReturnValue();
        v149 = type;
        if (os_log_type_enabled(v88, type))
        {
          *(_DWORD *)buf = 136446210;
          v171 = "nw_necp_append_tlv";
          _os_log_impl(&dword_182FBE000, v88, v149, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_276:
    if (v87)
      free(v87);
    v22 = v19;
    goto LABEL_51;
  }
LABEL_339:
  __break(1u);
  return result;
}

void sub_18391DE94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21)
{

  _Unwind_Resume(a1);
}

BOOL nw_path_create_assign_message(size_t *a1, _OWORD *a2, unsigned int a3, const void *a4, unsigned int a5, void *a6, void *a7)
{
  return nw_path_create_assign_message_internal(a1, a2, a3, a4, a5, a6, a7, 0);
}

BOOL nw_path_create_browse_result(_QWORD *a1, void *a2)
{
  return nw_path_create_endpoint_array_result(a1, a2, 202);
}

BOOL nw_path_create_endpoint_array_result(_QWORD *a1, void *a2, char a3)
{
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  unint64_t v13;
  _BOOL8 result;
  NSObject *v15;
  void *v16;
  _QWORD v17[6];
  char v18;
  _QWORD v19[5];
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  unint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = v5;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v27 = 0;
  v20 = 0;
  v21 = &v20;
  v22 = 0x2020000000;
  v23 = 0;
  if (a1)
    *a1 = 0;
  v7 = MEMORY[0x1E0C809B0];
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 3221225472;
  v19[2] = ___ZL36nw_path_create_endpoint_array_resultPmPU22objcproto11OS_nw_array8NSObjecth_block_invoke;
  v19[3] = &unk_1E14A8DC0;
  v19[4] = &v20;
  nw_array_apply(v5, (uint64_t)v19);
  v8 = v21[3];
  if (!v8)
    goto LABEL_14;
  if (v8 >= 0x6000)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v9 = (id)gLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      if (v6)
        v10 = (uint64_t)(*((_QWORD *)v6 + 3) - *((_QWORD *)v6 + 2)) >> 3;
      else
        v10 = 0;
      v13 = v21[3];
      *(_DWORD *)buf = 136446722;
      v29 = "nw_path_create_endpoint_array_result";
      v30 = 2048;
      v31 = v10;
      v32 = 2048;
      v33 = v13;
      _os_log_impl(&dword_182FBE000, v9, OS_LOG_TYPE_ERROR, "%{public}s Endpoint array too large; number of endpoints: %zu, total size: %zu",
        buf,
        0x20u);
    }

LABEL_14:
    v11 = 0;
LABEL_15:
    _Block_object_dispose(&v20, 8);
    _Block_object_dispose(&v24, 8);

    return (BOOL)v11;
  }
  v11 = (char *)malloc_type_calloc(1uLL, v21[3], 0xEAFB8F1AuLL);
  if (v11)
  {
LABEL_9:
    v12 = &v11[v21[3]];
    v25[3] = (uint64_t)v11;
    v17[0] = v7;
    v17[1] = 3221225472;
    v17[2] = ___ZL36nw_path_create_endpoint_array_resultPmPU22objcproto11OS_nw_array8NSObjecth_block_invoke_28;
    v17[3] = &unk_1E14A7948;
    v18 = a3;
    v17[4] = &v24;
    v17[5] = v12;
    nw_array_apply(v6, (uint64_t)v17);
    if (a1)
      *a1 = v21[3];
    goto LABEL_15;
  }
  __nwlog_obj();
  v15 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  v29 = "strict_calloc";
  v30 = 2048;
  v31 = 1;
  v32 = 2048;
  v33 = v8;
  v16 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v16);
  if (!result)
  {
    free(v16);
    goto LABEL_9;
  }
  __break(1u);
  return result;
}

void sub_18391E1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  void *v27;

  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL36nw_path_create_endpoint_array_resultPmPU22objcproto11OS_nw_array8NSObjecth_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += nw_path_struct_size_for_endpoint_and_metadata(v4, 0, 7);

  return 1;
}

void sub_18391E248(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL36nw_path_create_endpoint_array_resultPmPU22objcproto11OS_nw_array8NSObjecth_block_invoke_28(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = nw_path_evaluator_add_endpoint_to_necp_message(v4, *(unsigned __int8 *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)+ 24), *(_QWORD *)(a1 + 40), 7);

  return 1;
}

void sub_18391E2A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL nw_path_create_resolve_result(_QWORD *a1, void *a2)
{
  return nw_path_create_endpoint_array_result(a1, a2, 203);
}

BOOL nw_path_create_group_members_result(_QWORD *a1, void *a2)
{
  return nw_path_create_endpoint_array_result(a1, a2, 213);
}

uint64_t __nw_path_create_necp_agent_group_action_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += nw_path_struct_size_for_endpoint_and_metadata(v4, 0, 7);
  ++*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);

  return 1;
}

void sub_18391E328(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_path_create_necp_agent_group_action_block_invoke_2(_QWORD *a1, uint64_t a2, void *a3)
{
  id v4;

  v4 = a3;
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = nw_path_evaluator_add_endpoint_to_necp_message(v4, 213, *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24), a1[6] + *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) + 18, 7);

  return 1;
}

void sub_18391E39C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sa_dst_compare(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *v8;
  _BOOL4 v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
      return sa_dst_compare_internal(a1, a3, a2, a3, 1);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "sa_dst_compare";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (__nwlog_fault(v4, &type, &v12))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "sa_dst_compare";
        v7 = "%{public}s called with null dst2";
        goto LABEL_31;
      }
      if (!v12)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "sa_dst_compare";
        v7 = "%{public}s called with null dst2, backtrace limit exceeded";
        goto LABEL_31;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "sa_dst_compare";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null dst2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v4)
          return 0;
        goto LABEL_33;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "sa_dst_compare";
        v7 = "%{public}s called with null dst2, no backtrace";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "sa_dst_compare";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst1";
      goto LABEL_31;
    }
    if (!v12)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst1, backtrace limit exceeded";
      goto LABEL_31;
    }
    v8 = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!v8)
    {
      if (!v9)
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "sa_dst_compare";
      v7 = "%{public}s called with null dst1, no backtrace";
      goto LABEL_31;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "sa_dst_compare";
      v16 = 2082;
      v17 = v8;
      _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null dst1, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v8);
  }
LABEL_32:
  if (v4)
LABEL_33:
    free(v4);
  return 0;
}

uint64_t sa_dst_compare_no_stats(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *v8;
  _BOOL4 v9;
  char *backtrace_string;
  _BOOL4 v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (a2)
      return sa_dst_compare_internal(a1, a3, a2, a3, 0);
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "sa_dst_compare_no_stats";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (__nwlog_fault(v4, &type, &v12))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "sa_dst_compare_no_stats";
        v7 = "%{public}s called with null dst2";
        goto LABEL_31;
      }
      if (!v12)
      {
        v5 = __nwlog_obj();
        v6 = type;
        if (!os_log_type_enabled(v5, type))
          goto LABEL_32;
        *(_DWORD *)buf = 136446210;
        v15 = "sa_dst_compare_no_stats";
        v7 = "%{public}s called with null dst2, backtrace limit exceeded";
        goto LABEL_31;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v5 = __nwlog_obj();
      v6 = type;
      v11 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "sa_dst_compare_no_stats";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null dst2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v4)
          return 0;
        goto LABEL_33;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "sa_dst_compare_no_stats";
        v7 = "%{public}s called with null dst2, no backtrace";
LABEL_31:
        _os_log_impl(&dword_182FBE000, v5, v6, v7, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v15 = "sa_dst_compare_no_stats";
    v4 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst1";
      goto LABEL_31;
    }
    if (!v12)
    {
      v5 = __nwlog_obj();
      v6 = type;
      if (!os_log_type_enabled(v5, type))
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst1, backtrace limit exceeded";
      goto LABEL_31;
    }
    v8 = (char *)__nw_create_backtrace_string();
    v5 = __nwlog_obj();
    v6 = type;
    v9 = os_log_type_enabled(v5, type);
    if (!v8)
    {
      if (!v9)
        goto LABEL_32;
      *(_DWORD *)buf = 136446210;
      v15 = "sa_dst_compare_no_stats";
      v7 = "%{public}s called with null dst1, no backtrace";
      goto LABEL_31;
    }
    if (v9)
    {
      *(_DWORD *)buf = 136446466;
      v15 = "sa_dst_compare_no_stats";
      v16 = 2082;
      v17 = v8;
      _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null dst1, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v8);
  }
LABEL_32:
  if (v4)
LABEL_33:
    free(v4);
  return 0;
}

uint64_t sa_dst_compare_no_dependencies(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  NSObject *v12;
  const char *v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  BOOL v18;
  int v19;
  int v20;
  NSObject *v21;
  const char *v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  BOOL v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v34;
  unsigned int v35;
  char *v36;
  NSObject *v37;
  os_log_type_t v38;
  const char *v39;
  char *backtrace_string;
  _BOOL4 v41;
  const char *v42;
  _BOOL4 v43;
  char v44;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v47;
  __int16 v48;
  _WORD v49[9];

  *(_QWORD *)&v49[5] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v36 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v36, &type, &v44))
      goto LABEL_143;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v44)
      {
        v37 = __nwlog_obj();
        v38 = type;
        if (!os_log_type_enabled(v37, type))
          goto LABEL_143;
        *(_DWORD *)buf = 136446210;
        v47 = "sa_dst_compare_no_dependencies";
        v39 = "%{public}s called with null dst1, backtrace limit exceeded";
        goto LABEL_142;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v37 = __nwlog_obj();
      v38 = type;
      v41 = os_log_type_enabled(v37, type);
      if (!backtrace_string)
      {
        if (!v41)
          goto LABEL_143;
        *(_DWORD *)buf = 136446210;
        v47 = "sa_dst_compare_no_dependencies";
        v39 = "%{public}s called with null dst1, no backtrace";
        goto LABEL_142;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "sa_dst_compare_no_dependencies";
        v48 = 2082;
        *(_QWORD *)v49 = backtrace_string;
        v42 = "%{public}s called with null dst1, dumping backtrace:%{public}s";
LABEL_132:
        _os_log_impl(&dword_182FBE000, v37, v38, v42, buf, 0x16u);
      }
LABEL_133:
      free(backtrace_string);
      goto LABEL_143;
    }
    v37 = __nwlog_obj();
    v38 = type;
    if (!os_log_type_enabled(v37, type))
      goto LABEL_143;
    *(_DWORD *)buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v39 = "%{public}s called with null dst1";
LABEL_142:
    _os_log_impl(&dword_182FBE000, v37, v38, v39, buf, 0xCu);
LABEL_143:
    if (v36)
      free(v36);
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v36 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v44 = 0;
    if (!__nwlog_fault(v36, &type, &v44))
      goto LABEL_143;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type))
        goto LABEL_143;
      *(_DWORD *)buf = 136446210;
      v47 = "sa_dst_compare_no_dependencies";
      v39 = "%{public}s called with null dst2";
      goto LABEL_142;
    }
    if (!v44)
    {
      v37 = __nwlog_obj();
      v38 = type;
      if (!os_log_type_enabled(v37, type))
        goto LABEL_143;
      *(_DWORD *)buf = 136446210;
      v47 = "sa_dst_compare_no_dependencies";
      v39 = "%{public}s called with null dst2, backtrace limit exceeded";
      goto LABEL_142;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v37 = __nwlog_obj();
    v38 = type;
    v43 = os_log_type_enabled(v37, type);
    if (backtrace_string)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        v47 = "sa_dst_compare_no_dependencies";
        v48 = 2082;
        *(_QWORD *)v49 = backtrace_string;
        v42 = "%{public}s called with null dst2, dumping backtrace:%{public}s";
        goto LABEL_132;
      }
      goto LABEL_133;
    }
    if (!v43)
      goto LABEL_143;
    *(_DWORD *)buf = 136446210;
    v47 = "sa_dst_compare_no_dependencies";
    v39 = "%{public}s called with null dst2, no backtrace";
    goto LABEL_142;
  }
  v2 = *(unsigned __int8 *)(a1 + 1);
  if (v2 == 2)
    goto LABEL_17;
  if (v2 != 30)
  {
    v5 = 0;
    goto LABEL_26;
  }
  v3 = *(_DWORD *)(a1 + 8);
  v4 = (unsigned __int16)v3;
  if (!v3)
  {
    if (*(_DWORD *)(a1 + 12))
      goto LABEL_23;
    v6 = *(_DWORD *)(a1 + 16);
    if (v6 != -65536)
    {
      if (!v6)
      {
        v7 = *(_DWORD *)(a1 + 20);
        if (v7)
        {
          if (v7 == 0x1000000)
          {
            v5 = 50;
            goto LABEL_26;
          }
LABEL_22:
          v5 = 1;
          goto LABEL_26;
        }
      }
LABEL_23:
      if (v4 == 65087)
        v5 = 1;
      else
        v5 = 40;
      goto LABEL_26;
    }
LABEL_17:
    v5 = 35;
    goto LABEL_26;
  }
  if ((unsigned __int16)v3 == 544)
  {
    v5 = 30;
    goto LABEL_26;
  }
  if ((unsigned __int16)v3 != 288 || v3 >= 0x10000)
  {
    if ((v3 & 0xFE) == 0xFC)
    {
      v5 = 3;
      goto LABEL_26;
    }
    if ((v3 & 0xC0FF) == 0xC0FE)
      goto LABEL_22;
    goto LABEL_23;
  }
  v5 = 5;
LABEL_26:
  v8 = *(unsigned __int8 *)(a2 + 1);
  if (v8 == 2)
    goto LABEL_52;
  if (v8 != 30)
  {
    v11 = 0;
    if (!v5)
      goto LABEL_35;
    goto LABEL_53;
  }
  v9 = *(_DWORD *)(a2 + 8);
  v10 = (unsigned __int16)v9;
  if (v9)
  {
    if ((unsigned __int16)v9 == 544)
    {
      v11 = 30;
      if (v5 > 0x1E)
        goto LABEL_53;
      goto LABEL_35;
    }
    if ((unsigned __int16)v9 == 288 && v9 < 0x10000)
    {
      v11 = 5;
      if (v5 <= 5)
        goto LABEL_35;
LABEL_53:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v21 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v47 = "sa_dst_compare_no_dependencies";
        v48 = 1024;
        *(_DWORD *)v49 = v5;
        v49[2] = 1024;
        *(_DWORD *)&v49[3] = v11;
        v22 = "%{public}s ND Rule 6, prefer d1, d1 precedence %d > d2 precedence %d";
LABEL_85:
        _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_DEBUG, v22, buf, 0x18u);
        return 1;
      }
      return 1;
    }
    if ((v9 & 0xFE) == 0xFC)
    {
      v11 = 3;
      if (v5 > 3)
        goto LABEL_53;
      goto LABEL_35;
    }
    if ((v9 & 0xC0FF) == 0xC0FE)
      goto LABEL_95;
    goto LABEL_97;
  }
  if (*(_DWORD *)(a2 + 12))
    goto LABEL_97;
  v19 = *(_DWORD *)(a2 + 16);
  if (v19 == -65536)
  {
LABEL_52:
    v11 = 35;
    if (v5 <= 0x23)
      goto LABEL_35;
    goto LABEL_53;
  }
  if (!v19)
  {
    v20 = *(_DWORD *)(a2 + 20);
    if (v20)
    {
      if (v20 == 0x1000000)
      {
        v11 = 50;
        goto LABEL_35;
      }
LABEL_95:
      v11 = 1;
      if (v5 > 1)
        goto LABEL_53;
      goto LABEL_35;
    }
  }
LABEL_97:
  if (v10 == 65087)
    v11 = 1;
  else
    v11 = 40;
  if (v5 > v11)
    goto LABEL_53;
LABEL_35:
  if (v11 > v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v47 = "sa_dst_compare_no_dependencies";
      v48 = 1024;
      *(_DWORD *)v49 = v11;
      v49[2] = 1024;
      *(_DWORD *)&v49[3] = v5;
      v13 = "%{public}s ND Rule 6, prefer d2, d2 precedence %d > d1 precedence %d";
LABEL_90:
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, v13, buf, 0x18u);
      return 0xFFFFFFFFLL;
    }
    return 0xFFFFFFFFLL;
  }
  if (v2 == 2)
  {
    v23 = bswap32(*(_DWORD *)(a1 + 4));
    v18 = HIWORD(v23) == 43518 || HIBYTE(v23) == 127;
    v17 = 14;
    goto LABEL_62;
  }
  if (v2 != 30)
  {
    v24 = 0;
    goto LABEL_66;
  }
  v14 = *(unsigned __int8 *)(a1 + 8);
  if (v14 == 255)
  {
    v34 = (*(_BYTE *)(a1 + 9) & 0xF) - 1;
    if (v34 >= 5)
      v24 = 14;
    else
      v24 = dword_183C6E2E4[v34];
  }
  else
  {
    if (v14 == 254)
    {
      v15 = *(unsigned __int8 *)(a1 + 9);
      v16 = v15 & 0xC0;
      if (v15 <= 0xBF)
        v17 = 14;
      else
        v17 = 5;
      v18 = v16 == 128;
LABEL_62:
      if (v18)
        v24 = 2;
      else
        v24 = v17;
      goto LABEL_66;
    }
    v24 = 14;
    if (!(*(_QWORD *)(a1 + 8) | *(_QWORD *)(a1 + 15)))
    {
      if (*(_BYTE *)(a1 + 23) == 1)
        v24 = 2;
      else
        v24 = 14;
    }
  }
LABEL_66:
  v25 = *(unsigned __int8 *)(a2 + 1);
  if (v25 == 2)
  {
    v31 = bswap32(*(_DWORD *)(a2 + 4));
    v30 = HIWORD(v31) == 43518 || HIBYTE(v31) == 127;
    v29 = 14;
LABEL_78:
    if (v30)
      v32 = 2;
    else
      v32 = v29;
    goto LABEL_82;
  }
  if (v25 == 30)
  {
    v26 = *(unsigned __int8 *)(a2 + 8);
    if (v26 == 255)
    {
      v35 = (*(_BYTE *)(a2 + 9) & 0xF) - 1;
      if (v35 >= 5)
        v32 = 14;
      else
        v32 = dword_183C6E2E4[v35];
      goto LABEL_82;
    }
    if (v26 != 254)
    {
      v32 = 14;
      if (!(*(_QWORD *)(a2 + 8) | *(_QWORD *)(a2 + 15)))
      {
        if (*(_BYTE *)(a2 + 23) == 1)
          v32 = 2;
        else
          v32 = 14;
      }
      goto LABEL_82;
    }
    v27 = *(unsigned __int8 *)(a2 + 9);
    v28 = v27 & 0xC0;
    if (v27 <= 0xBF)
      v29 = 14;
    else
      v29 = 5;
    v30 = v28 == 128;
    goto LABEL_78;
  }
  v32 = 0;
LABEL_82:
  if (v24 < v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v47 = "sa_dst_compare_no_dependencies";
      v48 = 1024;
      *(_DWORD *)v49 = v24;
      v49[2] = 1024;
      *(_DWORD *)&v49[3] = v32;
      v22 = "%{public}s ND Rule 8, prefer d1, d1 scope %d < d2 scope %d";
      goto LABEL_85;
    }
    return 1;
  }
  if (v32 < v24)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v47 = "sa_dst_compare_no_dependencies";
      v48 = 1024;
      *(_DWORD *)v49 = v32;
      v49[2] = 1024;
      *(_DWORD *)&v49[3] = v24;
      v13 = "%{public}s ND Rule 8, prefer d2, d2 scope %d < d1 scope %d";
      goto LABEL_90;
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

NWConcrete_nw_hsts_storage *nw_hsts_storage_create_ns(void *a1)
{
  _NSHSTSStorage *v1;
  NWConcrete_nw_hsts_storage *v2;
  _NSHSTSStorage *HSTSStorage;

  v1 = a1;
  v2 = objc_alloc_init(NWConcrete_nw_hsts_storage);
  HSTSStorage = v2->HSTSStorage;
  v2->HSTSStorage = v1;

  return v2;
}

NWConcrete_nw_protocol_transform *nw_protocol_transform_create()
{
  return objc_alloc_init(NWConcrete_nw_protocol_transform);
}

void nw_protocol_transform_replace_endpoint(void *a1, void *a2)
{
  id *v3;
  id v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (v3)
  {
    objc_storeStrong(v3 + 4, a2);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_replace_endpoint";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_replace_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_replace_endpoint";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_replace_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_replace_endpoint";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t __nw_protocol_transform_modify_parameters_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  _QWORD *bytes_ptr;

  v4 = a3;
  bytes_ptr = xpc_data_get_bytes_ptr(v4);
  nw_parameters_remove_from_protocol_stack(*(void **)(a1 + 32), 5, bytes_ptr);
  nw_parameters_remove_from_protocol_stack(*(void **)(a1 + 32), 4, bytes_ptr);
  nw_parameters_remove_from_protocol_stack(*(void **)(a1 + 32), 3, bytes_ptr);
  nw_parameters_remove_from_protocol_stack(*(void **)(a1 + 32), 2, bytes_ptr);

  return 1;
}

void sub_183923150(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_transform_disable_protocol(void *a1, const void *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  xpc_object_t v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_transform_disable_protocol";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_transform_disable_protocol";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_transform_disable_protocol";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9)
          goto LABEL_6;
LABEL_41:
        free(v9);
        goto LABEL_6;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_transform_disable_protocol";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_transform_disable_protocol";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (a2)
  {
    v5 = (void *)v3[5];
    if (!v5)
    {
      v6 = xpc_array_create(0, 0);
      v7 = (void *)v4[5];
      v4[5] = v6;

      v5 = (void *)v4[5];
    }
    xpc_array_set_data(v5, 0xFFFFFFFFFFFFFFFFLL, a2, 0x28uLL);
    goto LABEL_6;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_protocol_transform_disable_protocol";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_transform_disable_protocol";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null protocol_identifier", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_transform_disable_protocol";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null protocol_identifier, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_transform_disable_protocol";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null protocol_identifier, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_protocol_transform_disable_protocol";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_41;
LABEL_6:

}

void sub_183923630(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_transform_clear_protocols_at_level(void *a1, int a2)
{
  id v3;
  void *v4;
  id v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  id v9;
  NSObject *v10;
  os_log_type_t v11;
  NSObject *v12;
  const char *backtrace_string;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  os_log_type_t v21;
  os_log_type_t v22;
  os_log_type_t v23;
  os_log_type_t v24;
  void *v25;
  os_log_type_t v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  char v30;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  _WORD v35[17];

  *(_QWORD *)&v35[13] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    switch(a2)
    {
      case 0:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v5 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_transform_clear_protocols_at_level";
        v6 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v30 = 0;
        if (!__nwlog_fault(v6, &type, &v30))
          goto LABEL_47;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v7 = (id)gLogObj;
          v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v33 = "nw_protocol_transform_clear_protocols_at_level";
            _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s Undefined protocol level", buf, 0xCu);
          }
          goto LABEL_65;
        }
        if (!v30)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v7 = (id)gLogObj;
          v21 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v33 = "nw_protocol_transform_clear_protocols_at_level";
            _os_log_impl(&dword_182FBE000, v7, v21, "%{public}s Undefined protocol level, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_65;
        }
        backtrace_string = __nw_create_backtrace_string();
        if (!backtrace_string)
        {
          __nwlog_obj();
          v7 = objc_claimAutoreleasedReturnValue();
          v23 = type;
          if (os_log_type_enabled(v7, type))
          {
            *(_DWORD *)buf = 136446210;
            v33 = "nw_protocol_transform_clear_protocols_at_level";
            _os_log_impl(&dword_182FBE000, v7, v23, "%{public}s Undefined protocol level, no backtrace", buf, 0xCu);
          }
          goto LABEL_65;
        }
        v14 = (char *)backtrace_string;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v15 = (id)gLogObj;
        v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446466;
          v33 = "nw_protocol_transform_clear_protocols_at_level";
          v34 = 2082;
          *(_QWORD *)v35 = v14;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s Undefined protocol level, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v14);
        if (v6)
          goto LABEL_48;
        goto LABEL_49;
      case 1:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_protocol_transform_clear_protocols_at_level";
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Link level protocols are currently unsupported", buf, 0xCu);
        }
        goto LABEL_15;
      case 2:
        *((_BYTE *)v3 + 8) |= 4u;
        goto LABEL_49;
      case 3:
        *((_BYTE *)v3 + 8) |= 2u;
        goto LABEL_49;
      case 4:
        *((_BYTE *)v3 + 8) |= 1u;
        goto LABEL_49;
      case 5:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v12 = (id)gLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v33 = "nw_protocol_transform_clear_protocols_at_level";
          _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Persistent protocols are currently unsupported", buf, 0xCu);
        }
LABEL_15:

        goto LABEL_49;
      default:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v9 = (id)gLogObj;
        *(_DWORD *)buf = 136446466;
        v33 = "nw_protocol_transform_clear_protocols_at_level";
        v34 = 1024;
        *(_DWORD *)v35 = a2;
        v6 = (char *)_os_log_send_and_compose_impl();

        type = OS_LOG_TYPE_ERROR;
        v30 = 0;
        if (!__nwlog_fault(v6, &type, &v30))
          goto LABEL_47;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          v11 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v33 = "nw_protocol_transform_clear_protocols_at_level";
            v34 = 1024;
            *(_DWORD *)v35 = a2;
            _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s Invalid protocol level %u", buf, 0x12u);
          }
LABEL_46:

          goto LABEL_47;
        }
        if (!v30)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v10 = (id)gLogObj;
          v22 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v33 = "nw_protocol_transform_clear_protocols_at_level";
            v34 = 1024;
            *(_DWORD *)v35 = a2;
            _os_log_impl(&dword_182FBE000, v10, v22, "%{public}s Invalid protocol level %u, backtrace limit exceeded", buf, 0x12u);
          }
          goto LABEL_46;
        }
        v17 = __nw_create_backtrace_string();
        if (!v17)
        {
          __nwlog_obj();
          v10 = objc_claimAutoreleasedReturnValue();
          v24 = type;
          if (os_log_type_enabled(v10, type))
          {
            *(_DWORD *)buf = 136446466;
            v33 = "nw_protocol_transform_clear_protocols_at_level";
            v34 = 1024;
            *(_DWORD *)v35 = a2;
            _os_log_impl(&dword_182FBE000, v10, v24, "%{public}s Invalid protocol level %u, no backtrace", buf, 0x12u);
          }
          goto LABEL_46;
        }
        v18 = (char *)v17;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v19 = (id)gLogObj;
        v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446722;
          v33 = "nw_protocol_transform_clear_protocols_at_level";
          v34 = 1024;
          *(_DWORD *)v35 = a2;
          v35[2] = 2082;
          *(_QWORD *)&v35[3] = v18;
          _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s Invalid protocol level %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        break;
    }
LABEL_33:
    free(v18);
    if (!v6)
      goto LABEL_49;
    goto LABEL_48;
  }
  __nwlog_obj();
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v33 = "nw_protocol_transform_clear_protocols_at_level";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v30 = 0;
  if (__nwlog_fault(v6, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_transform_clear_protocols_at_level";
        _os_log_impl(&dword_182FBE000, v7, v26, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v30)
    {
      v18 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v27 = type;
      v28 = os_log_type_enabled(v7, type);
      if (v18)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          v33 = "nw_protocol_transform_clear_protocols_at_level";
          v34 = 2082;
          *(_QWORD *)v35 = v18;
          _os_log_impl(&dword_182FBE000, v7, v27, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        goto LABEL_33;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_transform_clear_protocols_at_level";
        _os_log_impl(&dword_182FBE000, v7, v27, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v29 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v33 = "nw_protocol_transform_clear_protocols_at_level";
        _os_log_impl(&dword_182FBE000, v7, v29, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_65:

  }
LABEL_47:
  if (v6)
LABEL_48:
    free(v6);
LABEL_49:

}

void nw_protocol_transform_set_multipath_service(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 9) |= 2u;
    *((_DWORD *)v3 + 5) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_set_multipath_service";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_multipath_service";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_set_multipath_service";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_multipath_service";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_multipath_service";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_protocol_transform_get_multipath_service(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[5];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_multipath_service";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_multipath_service";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_multipath_service";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_multipath_service";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_multipath_service";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_no_proxy(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 8;
    else
      v5 = 0;
    *((_BYTE *)v3 + 8) = *((_BYTE *)v3 + 8) & 0xF7 | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_transform_set_no_proxy";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_no_proxy";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_transform_set_no_proxy";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_no_proxy";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_no_proxy";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

uint64_t nw_protocol_transform_get_no_proxy(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[8] >> 3) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_no_proxy";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_no_proxy";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_no_proxy";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_no_proxy";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_no_proxy";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_no_path_fallback(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 0x80;
    else
      v5 = 0;
    *((_BYTE *)v3 + 8) = v5 & 0x80 | *((_BYTE *)v3 + 8) & 0x7F;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_transform_set_no_path_fallback";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_no_path_fallback";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_transform_set_no_path_fallback";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_no_path_fallback";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_no_path_fallback";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

BOOL nw_protocol_transform_get_no_path_fallback(void *a1)
{
  char *v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[8] < 0;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_no_path_fallback";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_no_path_fallback";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_no_path_fallback";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_no_path_fallback";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_no_path_fallback";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_tfo(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 32;
    else
      v5 = 0;
    *((_BYTE *)v3 + 8) = *((_BYTE *)v3 + 8) & 0xDF | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_transform_set_tfo";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_tfo";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_transform_set_tfo";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_tfo";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_tfo";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

uint64_t nw_protocol_transform_get_tfo(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[8] >> 5) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_tfo";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_tfo";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_tfo";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_tfo";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_tfo";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_tfo_no_cookie(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 64;
    else
      v5 = 0;
    *((_BYTE *)v3 + 8) = *((_BYTE *)v3 + 8) & 0xBF | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_transform_set_tfo_no_cookie";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_tfo_no_cookie";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_transform_set_tfo_no_cookie";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_tfo_no_cookie";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_tfo_no_cookie";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

uint64_t nw_protocol_transform_get_tfo_no_cookie(void *a1)
{
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (v1[8] >> 6) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_tfo_no_cookie";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_tfo_no_cookie";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_tfo_no_cookie";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_tfo_no_cookie";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_tfo_no_cookie";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_use_tfo_heuristics(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  char *backtrace_string;
  os_log_type_t v8;
  _BOOL4 v9;
  os_log_type_t v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  v3 = v2;
  if (a1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v14 = "nw_protocol_transform_set_use_tfo_heuristics";
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s nw_protocol_transform_set_use_tfo_heuristics is deprecated", buf, 0xCu);
    }

    return;
  }
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_transform_set_use_tfo_heuristics";
  v4 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_transform_set_use_tfo_heuristics";
        _os_log_impl(&dword_182FBE000, v5, v6, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          v14 = "nw_protocol_transform_set_use_tfo_heuristics";
          v15 = 2082;
          v16 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_transform_set_use_tfo_heuristics";
        _os_log_impl(&dword_182FBE000, v5, v8, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v5 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_transform_set_use_tfo_heuristics";
        _os_log_impl(&dword_182FBE000, v5, v10, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v4)
    free(v4);
}

uint64_t nw_protocol_transform_get_use_tfo_heuristics(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  char *v5;
  NSObject *v6;
  os_log_type_t v7;
  char *backtrace_string;
  os_log_type_t v9;
  _BOOL4 v10;
  os_log_type_t v11;
  char v12;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  v2 = (id)gLogObj;
  v3 = v2;
  if (a1)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v15 = "nw_protocol_transform_get_use_tfo_heuristics";
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s nw_protocol_transform_set_use_tfo_heuristics is deprecated", buf, 0xCu);
    }

    return 0;
  }
  *(_DWORD *)buf = 136446210;
  v15 = "nw_protocol_transform_get_use_tfo_heuristics";
  v5 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_transform_get_use_tfo_heuristics";
        _os_log_impl(&dword_182FBE000, v6, v7, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          v15 = "nw_protocol_transform_get_use_tfo_heuristics";
          v16 = 2082;
          v17 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_transform_get_use_tfo_heuristics";
        _os_log_impl(&dword_182FBE000, v6, v9, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v6 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v15 = "nw_protocol_transform_get_use_tfo_heuristics";
        _os_log_impl(&dword_182FBE000, v6, v11, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v5)
    free(v5);
  return 0;
}

void nw_protocol_transform_set_fast_open_force_enable(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 9) = *((_BYTE *)v3 + 9) & 0xFE | a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_set_fast_open_force_enable";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_set_fast_open_force_enable";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_protocol_transform_get_fast_open_force_enable(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = *((_BYTE *)v1 + 9) & 1;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_fast_open_force_enable";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_fast_open_force_enable";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_fast_open_force_enable";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_traffic_class(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_BYTE *)v3 + 9) |= 4u;
    *((_DWORD *)v3 + 3) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_set_traffic_class";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_set_traffic_class";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_protocol_transform_get_traffic_class(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[3];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_traffic_class";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_traffic_class";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_traffic_class";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_data_mode(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 6) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_set_data_mode";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_data_mode";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_set_data_mode";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_data_mode";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_data_mode";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

uint64_t nw_protocol_transform_get_data_mode(void *a1)
{
  unsigned int *v1;
  void *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = v1[6];
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_get_data_mode";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_data_mode";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_get_data_mode";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_data_mode";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_get_data_mode";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_transform_set_fallback_mode(void *a1, int a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 4) = a2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_set_fallback_mode";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_fallback_mode";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_set_fallback_mode";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_fallback_mode";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_set_fallback_mode";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
LABEL_3:

}

void nw_protocol_transform_set_prohibit_direct(void *a1, int a2)
{
  id v3;
  void *v4;
  char v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  char *backtrace_string;
  os_log_type_t v11;
  _BOOL4 v12;
  os_log_type_t v13;
  char v14;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
      v5 = 16;
    else
      v5 = 0;
    *((_BYTE *)v3 + 8) = *((_BYTE *)v3 + 8) & 0xEF | v5;
    goto LABEL_6;
  }
  __nwlog_obj();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v17 = "nw_protocol_transform_set_prohibit_direct";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_prohibit_direct";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          v17 = "nw_protocol_transform_set_prohibit_direct";
          v18 = 2082;
          v19 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_prohibit_direct";
        _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v17 = "nw_protocol_transform_set_prohibit_direct";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_23:
  if (v7)
    free(v7);
LABEL_6:

}

void nw_protocol_transform_add_match_url_scheme(void *a1, const char *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  xpc_object_t v6;
  void *v7;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  void *v12;
  os_log_type_t v13;
  char *backtrace_string;
  os_log_type_t v15;
  _BOOL4 v16;
  char *v17;
  os_log_type_t v18;
  _BOOL4 v19;
  os_log_type_t v20;
  os_log_type_t v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_protocol_transform_add_match_url_scheme";
    v9 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22))
      goto LABEL_40;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_transform_add_match_url_scheme";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_protocol_transform_add_match_url_scheme";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9)
          goto LABEL_6;
LABEL_41:
        free(v9);
        goto LABEL_6;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_transform_add_match_url_scheme";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_protocol_transform_add_match_url_scheme";
        _os_log_impl(&dword_182FBE000, v10, v20, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (a2)
  {
    v5 = (void *)v3[6];
    if (!v5)
    {
      v6 = xpc_array_create(0, 0);
      v7 = (void *)v4[6];
      v4[6] = v6;

      v5 = (void *)v4[6];
    }
    xpc_array_set_string(v5, 0xFFFFFFFFFFFFFFFFLL, a2);
    goto LABEL_6;
  }
  __nwlog_obj();
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_protocol_transform_add_match_url_scheme";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_transform_add_match_url_scheme";
      _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null scheme", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v22)
  {
    __nwlog_obj();
    v10 = objc_claimAutoreleasedReturnValue();
    v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_transform_add_match_url_scheme";
      _os_log_impl(&dword_182FBE000, v10, v21, "%{public}s called with null scheme, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  v17 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v10 = objc_claimAutoreleasedReturnValue();
  v18 = type;
  v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_protocol_transform_add_match_url_scheme";
      _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null scheme, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_protocol_transform_add_match_url_scheme";
    v26 = 2082;
    v27 = v17;
    _os_log_impl(&dword_182FBE000, v10, v18, "%{public}s called with null scheme, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9)
    goto LABEL_41;
LABEL_6:

}

void sub_1839278B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_protocol_transform_clear_match_url_schemes(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)v1[6];
    if (v3)
    {
      xpc_release(v3);
      v4 = (void *)v2[6];
      v2[6] = 0;

    }
    goto LABEL_4;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_protocol_transform_clear_match_url_schemes";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_clear_match_url_schemes";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_protocol_transform_clear_match_url_schemes";
          v17 = 2082;
          v18 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_clear_match_url_schemes";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_protocol_transform_clear_match_url_schemes";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_21:
  if (v6)
    free(v6);
LABEL_4:

}

void sub_183927B64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_transform_supports_endpoint_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;
  const char *string_ptr;

  v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1E0C81390])
  {
    string_ptr = xpc_string_get_string_ptr(v4);
    v5 = 1;
    if (!strcasecmp(string_ptr, *(const char **)(a1 + 40)))
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
      v5 = 0;
    }
  }
  else
  {
    v5 = 1;
  }

  return v5;
}

void sub_183927BF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_transform_compare(void *a1, void *a2, int a3)
{
  unint64_t v5;
  id v6;
  void **v7;
  uint64_t is_equal;

  v5 = a1;
  v6 = a2;
  v7 = (void **)v6;
  if (!(v5 | (unint64_t)v6))
  {
    is_equal = 1;
    goto LABEL_9;
  }
  is_equal = 0;
  if (v5 && v6)
  {
    if (*(_DWORD *)(v5 + 16) != *((_DWORD *)v6 + 4)
      || *((unsigned __int8 *)v6 + 8) != *(unsigned __int8 *)(v5 + 8)
      || ((*((_BYTE *)v6 + 9) ^ *(_BYTE *)(v5 + 9)) & 3) != 0)
    {
LABEL_8:
      is_equal = 0;
      goto LABEL_9;
    }
    is_equal = 0;
    if (((*((_BYTE *)v6 + 9) ^ *(_BYTE *)(v5 + 9)) & 4) == 0 && *(_DWORD *)(v5 + 20) == *((_DWORD *)v6 + 5))
    {
      if (*(_DWORD *)(v5 + 12) == *((_DWORD *)v6 + 3)
        && *(_DWORD *)(v5 + 24) == *((_DWORD *)v6 + 6)
        && (nw_endpoint_is_equal(*(void **)(v5 + 32), *((void **)v6 + 4), 0) & 1) != 0
        && nw_xpc_objects_equal(*(void **)(v5 + 40), v7[5])
        && nw_xpc_objects_equal(*(void **)(v5 + 48), v7[6]))
      {
        is_equal = nw_protocol_stack_is_equal(*(void **)(v5 + 56), v7[7], a3);
        goto LABEL_9;
      }
      goto LABEL_8;
    }
  }
LABEL_9:

  return is_equal;
}

void sub_183927D20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_183927D98(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_transform_is_equal(void *a1, void *a2)
{
  return nw_protocol_transform_compare(a1, a2, 0);
}

uint64_t nw_protocol_transform_get_hash(void *a1)
{
  char *v1;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  __int128 v6;
  __int16 v7;
  __int16 v8;
  CC_SHA256_CTX c;
  unsigned __int8 md[32];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    memset(&c, 0, sizeof(c));
    CC_SHA256_Init(&c);
    v6 = *(_OWORD *)(v1 + 12);
    v7 = ((((v1[9] & 2) != 0) << 9) | ((v1[9] & 1) << 8)) & 0xFBFF | (((v1[9] & 4) != 0) << 10) | v1[8];
    v8 = 0;
    CC_SHA256_Update(&c, &v6, 0x14u);
    CC_SHA256_Final(md, &c);
    v2 = objc_msgSend(*((id *)v1 + 4), "getHash");
    v3 = (void *)*((_QWORD *)v1 + 6);
    if (v3)
      v2 ^= xpc_hash(v3);
    v4 = nw_protocol_stack_get_hash(*((void **)v1 + 7)) ^ v2;
  }
  else
  {
    v4 = 0;
  }

  return v4;
}

void sub_183927EAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_connection_multipath_get_subflow_count(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v19 = 0;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_multipath_get_subflow_count_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_multipath_get_subflow_count_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(unsigned int *)(*(_QWORD *)&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_multipath_get_subflow_count";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_multipath_get_subflow_count";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_multipath_get_subflow_count";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_multipath_get_subflow_count";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_multipath_get_subflow_count";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_multipath_get_subflow_count_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  _QWORD *v8;
  _QWORD *v9;
  id v10;
  void *v11;
  id *v12;
  id v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(void);
  uint64_t v17;
  void **v18;
  int v19;
  NSObject *v20;
  id v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  id v25;
  char *v26;
  NSObject *v27;
  os_log_type_t v28;
  char *v29;
  os_log_type_t v30;
  _BOOL4 v31;
  char *backtrace_string;
  os_log_type_t v33;
  _BOOL4 v34;
  os_log_type_t v35;
  os_log_type_t v36;
  NSObject *v37;
  os_log_type_t type[8];
  os_log_type_t *v39;
  uint64_t v40;
  int v41;
  char v42;
  _BYTE buf[24];
  void *v44;
  os_log_type_t *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) != 0)
  {
    v6 = (os_unfair_lock_s *)*(id *)(v2 + 144);
    v7 = v6;
    if (v6)
    {
      os_unfair_lock_lock(v6 + 28);
      if (v7[29]._os_unfair_lock_opaque != 2)
      {
        v19 = 0;
LABEL_34:
        os_unfair_lock_unlock(v7 + 28);
LABEL_35:

        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v19;
        return;
      }
      v8 = *(id *)&v7[62]._os_unfair_lock_opaque;
      v9 = v8;
      if (v8)
      {
        *(_QWORD *)type = 0;
        v39 = type;
        v41 = 0;
        v40 = 0x2020000000;
        if (!nw_endpoint_flow_is_multipath(v8))
        {
LABEL_32:
          v19 = *((_DWORD *)v39 + 6);
          _Block_object_dispose(type, 8);
LABEL_33:

          goto LABEL_34;
        }
        v10 = nw_endpoint_flow_copy_connected_socket_wrapper(v9);
        v11 = (void *)v9[117];
        if (v11)
        {
          v12 = v11;
          v13 = v12[4];

          if (v13 && nw_parameters_get_upper_transport_protocol(v13) == 253)
          {
            if (gLogDatapath)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v37 = (id)gLogObj;
              if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
                _os_log_impl(&dword_182FBE000, v37, OS_LOG_TYPE_DEBUG, "%{public}s Querying QUIC for subflow count", buf, 0xCu);
              }

            }
            v14 = v9[51];
            if (v14)
            {
              v15 = *(_QWORD *)(v14 + 24);
              if (v15)
              {
                v16 = *(uint64_t (**)(void))(v15 + 224);
                if (v16)
                {
                  v17 = v16();
                  v18 = (void **)v17;
                  if (v17)
                  {
                    *((_DWORD *)v39 + 6) = *(_DWORD *)(v17 + 8);
                    nw_array_remove_all_objects(*(_QWORD *)v17);
                    if (*v18)
                      os_release(*v18);
                    free(v18);
                  }
                }
              }
            }
LABEL_31:

            goto LABEL_32;
          }
        }
        else
        {
          v13 = 0;
        }
        if (v10)
        {
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 3221225472;
          *(_QWORD *)&buf[16] = ___Z44nw_endpoint_flow_get_multipath_subflow_countP27NWConcrete_nw_endpoint_flow_block_invoke;
          v44 = &unk_1E14AB578;
          v45 = type;
          nw_fd_wrapper_get_fd(v10, buf);
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v20 = (id)gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Protocol not supported", buf, 0xCu);
          }

        }
        goto LABEL_31;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v25 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
      v26 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v42 = 0;
      if (__nwlog_fault(v26, type, &v42))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = (id)gLogObj;
          v28 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s called with null endpoint_flow", buf, 0xCu);
          }
        }
        else if (v42)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = (id)gLogObj;
          v33 = type[0];
          v34 = os_log_type_enabled(v27, type[0]);
          if (backtrace_string)
          {
            if (v34)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v27, v33, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_72;
          }
          if (v34)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_182FBE000, v27, v33, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = (id)gLogObj;
          v36 = type[0];
          if (os_log_type_enabled(v27, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_get_multipath_subflow_count";
            _os_log_impl(&dword_182FBE000, v27, v36, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
          }
        }

      }
LABEL_72:
      if (v26)
        free(v26);
      v19 = 0;
      goto LABEL_33;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v21 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
    v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v42 = 0;
    if (__nwlog_fault(v22, type, &v42))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v42)
      {
        v29 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v30 = type[0];
        v31 = os_log_type_enabled(v23, type[0]);
        if (v29)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v29;
            _os_log_impl(&dword_182FBE000, v23, v30, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v29);
          goto LABEL_63;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
          _os_log_impl(&dword_182FBE000, v23, v30, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v35 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_get_multipath_subflow_count";
          _os_log_impl(&dword_182FBE000, v23, v35, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_63:
    if (v22)
      free(v22);
    v19 = 0;
    goto LABEL_35;
  }
  v3 = *(_QWORD *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1)
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
    v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_connection_multipath_get_subflow_count_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v5;
      _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s [C%u]  has no connected handler", buf, 0x12u);
    }

  }
}

void sub_183928A78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a6);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_connection_multipath_get_primary_subflow_interface_index(void *a1)
{
  id v1;
  void *v2;
  id v3;
  void *v4;
  NWConcrete_nw_path *v5;
  uint64_t routed_interface_index;
  NSObject *v7;
  void *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  char *backtrace_string;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  char v17;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = nw_connection_copy_connected_path(v1);
    v4 = v3;
    if (v3)
    {
      v5 = (NWConcrete_nw_path *)v3;
      if (nw_path_network_is_satisfied_update_reason(v5, 0))
        routed_interface_index = v5->policy_result.routed_interface_index;
      else
        routed_interface_index = 0;

    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = (id)gLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_182FBE000, v7, OS_LOG_TYPE_ERROR, "%{public}s No connected path", buf, 0xCu);
      }

      routed_interface_index = 0;
    }

    goto LABEL_11;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
  v10 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_182FBE000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v11 = objc_claimAutoreleasedReturnValue();
      v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        v20 = "nw_connection_multipath_get_primary_subflow_interface_index";
        _os_log_impl(&dword_182FBE000, v11, v16, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_28:
  if (v10)
    free(v10);
  routed_interface_index = 0;
LABEL_11:

  return routed_interface_index;
}

void sub_183928DF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id nw_connection_multipath_copy_subflow_counts(void *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  id v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  char *backtrace_string;
  os_log_type_t v10;
  _BOOL4 v11;
  os_log_type_t v12;
  _QWORD v13[4];
  os_unfair_lock_s *v14;
  _BYTE *v15;
  char v16;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t (*v19)(uint64_t, uint64_t);
  void (*v20)(uint64_t);
  id v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v19 = __Block_byref_object_copy__59789;
    v20 = __Block_byref_object_dispose__59790;
    v21 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_multipath_copy_subflow_counts_block_invoke;
    v13[3] = &unk_1E14ACE40;
    v14 = v1;
    v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_multipath_copy_subflow_counts_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    v3 = *(id *)(*(_QWORD *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  __nwlog_obj();
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_connection_multipath_copy_subflow_counts";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_multipath_copy_subflow_counts";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_connection_multipath_copy_subflow_counts";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_multipath_copy_subflow_counts";
        _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_connection_multipath_copy_subflow_counts";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __Block_byref_object_copy__59789(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__59790(uint64_t a1)
{

}

void __nw_connection_multipath_copy_subflow_counts_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  id v9;
  void *v10;
  NSObject *v11;
  NSObject *v12;
  xpc_object_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  char *v22;
  NSObject *v23;
  os_log_type_t v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  _BOOL4 v28;
  os_log_type_t v29;
  NSObject *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  id v38;
  char *v39;
  NSObject *v40;
  os_log_type_t v41;
  char *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  os_log_type_t v45;
  id v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  id v50;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  char *backtrace_string;
  os_log_type_t v55;
  _BOOL4 v56;
  char *v57;
  os_log_type_t v58;
  _BOOL4 v59;
  os_log_type_t v60;
  os_log_type_t v61;
  NSObject *v62;
  unint64_t StatusReg;
  id v64;
  char v65;
  os_log_type_t type;
  os_log_type_t v67[8];
  os_log_type_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint8_t v71[4];
  const char *v72;
  __int16 v73;
  _QWORD v74[3];
  char key[8];
  uint64_t v76;
  char v77;
  _BYTE buf[24];
  void *v79;
  os_log_type_t *v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(v2 + 109) & 0x40) == 0)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(_QWORD *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1)
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44184);
      v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 448);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_connection_multipath_copy_subflow_counts_block_invoke";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v5;
        _os_log_impl(&dword_182FBE000, v4, OS_LOG_TYPE_INFO, "%{public}s [C%u]  has no connected handler", buf, 0x12u);
      }

    }
    return;
  }
  v6 = (os_unfair_lock_s *)*(id *)(v2 + 144);
  v7 = v6;
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v46 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
    v47 = (char *)_os_log_send_and_compose_impl();

    v67[0] = OS_LOG_TYPE_ERROR;
    v71[0] = 0;
    if (__nwlog_fault(v47, v67, v71))
    {
      if (v67[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v48 = (id)gLogObj;
        v49 = v67[0];
        if (os_log_type_enabled(v48, v67[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v71[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v48 = (id)gLogObj;
        v55 = v67[0];
        v56 = os_log_type_enabled(v48, v67[0]);
        if (backtrace_string)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v48, v55, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_111;
        }
        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v48, v55, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v48 = (id)gLogObj;
        v60 = v67[0];
        if (os_log_type_enabled(v48, v67[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_handler_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v48, v60, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_111:
    if (v47)
      free(v47);
    v13 = 0;
    goto LABEL_65;
  }
  v8 = v6 + 28;
  os_unfair_lock_lock(v6 + 28);
  if (v7[29]._os_unfair_lock_opaque != 2)
  {
    v13 = 0;
    goto LABEL_64;
  }
  v9 = *(id *)&v7[62]._os_unfair_lock_opaque;
  v10 = v9;
  if (!v9)
  {
    v32 = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v50 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
    v51 = (char *)_os_log_send_and_compose_impl();

    v67[0] = OS_LOG_TYPE_ERROR;
    v71[0] = 0;
    if (__nwlog_fault(v51, v67, v71))
    {
      if (v67[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v52 = (id)gLogObj;
        v53 = v67[0];
        if (os_log_type_enabled(v52, v67[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v52, v53, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if (v71[0])
      {
        v57 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v52 = (id)gLogObj;
        v58 = v67[0];
        v59 = os_log_type_enabled(v52, v67[0]);
        if (v57)
        {
          if (v59)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v57;
            _os_log_impl(&dword_182FBE000, v52, v58, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v57);
          goto LABEL_120;
        }
        if (v59)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v52, v58, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v52 = (id)gLogObj;
        v61 = v67[0];
        if (os_log_type_enabled(v52, v67[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v52, v61, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }

    }
LABEL_120:
    if (v51)
      free(v51);
    v13 = 0;
    goto LABEL_63;
  }
  *(_QWORD *)v67 = 0;
  v68 = v67;
  v69 = 0x2020000000;
  v70 = 0;
  v64 = v9;
  if ((nw_endpoint_flow_is_multipath(v9) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
      _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_ERROR, "%{public}s Called on non-Multipath connection", buf, 0xCu);
    }
    goto LABEL_53;
  }
  v11 = nw_endpoint_flow_copy_connected_socket_wrapper(v10);
  v12 = v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v30 = (id)gLogObj;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_endpoint_flow_copy_multipath_subflow_counts";
      _os_log_impl(&dword_182FBE000, v30, OS_LOG_TYPE_DEBUG, "%{public}s connected_fd is not yet set", buf, 0xCu);
    }

    v12 = 0;
    goto LABEL_53;
  }
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 3221225472;
  *(_QWORD *)&buf[16] = ___Z46nw_endpoint_flow_copy_multipath_subflow_countsP27NWConcrete_nw_endpoint_flow_block_invoke;
  v79 = &unk_1E14AB578;
  v80 = v67;
  if ((nw_fd_wrapper_get_fd(v11, buf) & 1) == 0)
  {
LABEL_53:
    v13 = 0;
    goto LABEL_54;
  }
  v13 = xpc_dictionary_create(0, 0, 0);
  v62 = v12;
  if (!v13)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v38 = (id)gLogObj;
    *(_DWORD *)v71 = 136446210;
    v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
    v39 = (char *)_os_log_send_and_compose_impl();

    key[0] = 16;
    type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v39, key, &type))
    {
      if (key[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = (id)gLogObj;
        v41 = key[0];
        if (os_log_type_enabled(v40, (os_log_type_t)key[0]))
        {
          *(_DWORD *)v71 = 136446210;
          v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v40, v41, "%{public}s xpc_dictionary_create failed", v71, 0xCu);
        }
      }
      else if (type)
      {
        v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = (id)gLogObj;
        v43 = key[0];
        v44 = os_log_type_enabled(v40, (os_log_type_t)key[0]);
        if (v42)
        {
          if (v44)
          {
            *(_DWORD *)v71 = 136446466;
            v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
            v73 = 2082;
            v74[0] = v42;
            _os_log_impl(&dword_182FBE000, v40, v43, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", v71, 0x16u);
          }

          free(v42);
          goto LABEL_83;
        }
        if (v44)
        {
          *(_DWORD *)v71 = 136446210;
          v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v40, v43, "%{public}s xpc_dictionary_create failed, no backtrace", v71, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v40 = (id)gLogObj;
        v45 = key[0];
        if (os_log_type_enabled(v40, (os_log_type_t)key[0]))
        {
          *(_DWORD *)v71 = 136446210;
          v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          _os_log_impl(&dword_182FBE000, v40, v45, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", v71, 0xCu);
        }
      }

    }
LABEL_83:
    if (v39)
      free(v39);
    goto LABEL_53;
  }
  v14 = 0;
  v15 = *(_QWORD *)(*((_QWORD *)v68 + 3) + 32);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  do
  {
    v16 = v15 + v14;
    if (!*(_WORD *)(v15 + v14 + 40))
      goto LABEL_19;
    *(_QWORD *)key = 0;
    v76 = 0;
    v77 = 0;
    if (if_indextoname(*(unsigned __int16 *)(v16 + 40), key))
    {
      xpc_dictionary_set_uint64(v13, key, *(unsigned __int16 *)(v15 + v14 + 42));
      goto LABEL_19;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v18 = *(unsigned __int16 *)(v16 + 40);
      *(_DWORD *)v71 = 136446466;
      v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
      v73 = 1024;
      LODWORD(v74[0]) = v18;
      _os_log_impl(&dword_182FBE000, v17, OS_LOG_TYPE_ERROR, "%{public}s if_indextoname failed for outif: %d", v71, 0x12u);
    }

    v19 = **(_DWORD **)(StatusReg + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v20 = (id)gLogObj;
    v21 = v20;
    if (v19 == 6)
    {
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v71 = 136446466;
        v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
        v73 = 1024;
        LODWORD(v74[0]) = 6;
        _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, "%{public}s if_indextoname %{darwin.errno}d", v71, 0x12u);
      }

    }
    else
    {
      *(_DWORD *)v71 = 136446466;
      v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
      v73 = 1024;
      LODWORD(v74[0]) = v19;
      v22 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v65 = 0;
      if (!__nwlog_fault(v22, &type, &v65))
        goto LABEL_45;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)v71 = 136446466;
          v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          v73 = 1024;
          LODWORD(v74[0]) = v19;
          _os_log_impl(&dword_182FBE000, v23, v24, "%{public}s if_indextoname %{darwin.errno}d", v71, 0x12u);
        }
        goto LABEL_32;
      }
      if (!v65)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v23 = (id)gLogObj;
        v29 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)v71 = 136446466;
          v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          v73 = 1024;
          LODWORD(v74[0]) = v19;
          _os_log_impl(&dword_182FBE000, v23, v29, "%{public}s if_indextoname %{darwin.errno}d, backtrace limit exceeded", v71, 0x12u);
        }
LABEL_32:

LABEL_45:
        if (!v22)
          goto LABEL_19;
LABEL_46:
        free(v22);
        goto LABEL_19;
      }
      v25 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v26 = (id)gLogObj;
      v27 = type;
      v28 = os_log_type_enabled(v26, type);
      if (!v25)
      {
        if (v28)
        {
          *(_DWORD *)v71 = 136446466;
          v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
          v73 = 1024;
          LODWORD(v74[0]) = v19;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s if_indextoname %{darwin.errno}d, no backtrace", v71, 0x12u);
        }

        goto LABEL_45;
      }
      if (v28)
      {
        *(_DWORD *)v71 = 136446722;
        v72 = "nw_endpoint_flow_copy_multipath_subflow_counts";
        v73 = 1024;
        LODWORD(v74[0]) = v19;
        WORD2(v74[0]) = 2082;
        *(_QWORD *)((char *)v74 + 6) = v25;
        _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s if_indextoname %{darwin.errno}d, dumping backtrace:%{public}s", v71, 0x1Cu);
      }

      free(v25);
      if (v22)
        goto LABEL_46;
    }
LABEL_19:
    v14 += 72;
  }
  while (v14 != 288);
  v12 = v62;
LABEL_54:

  v31 = (_QWORD *)*((_QWORD *)v68 + 3);
  v32 = v64;
  if (v31)
  {
    v33 = (void *)v31[1];
    if (v33)
    {
      free(v33);
      v31[1] = 0;
    }
    v34 = (void *)v31[2];
    if (v34)
    {
      free(v34);
      v31[2] = 0;
    }
    v35 = (void *)v31[4];
    if (v35)
      free(v35);
    free(v31);
  }
  _Block_object_dispose(v67, 8);
LABEL_63:

  v8 = v7 + 28;
LABEL_64:
  os_unfair_lock_unlock(v8);
LABEL_65:

  v36 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v37 = *(void **)(v36 + 40);
  *(_QWORD *)(v36 + 40) = v13;

}

void sub_18392A0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  void *v15;
  void *v16;
  va_list va;

  va_start(va, a15);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_options *nw_webtransport_create_options()
{
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
  return nw_protocol_create_options((void *)nw_protocol_copy_webtransport_definition::definition);
}

BOOL __nw_protocol_copy_webtransport_definition_block_invoke()
{
  NWConcrete_nw_protocol_definition *v0;
  void *v1;

  if (nw_protocol_webtransport_identifier::onceToken != -1)
    dispatch_once(&nw_protocol_webtransport_identifier::onceToken, &__block_literal_global_33397);
  v0 = nw_protocol_definition_create_with_identifier((__int128 *)nw_protocol_webtransport_identifier::protocol_identifier);
  v1 = (void *)nw_protocol_copy_webtransport_definition::definition;
  nw_protocol_copy_webtransport_definition::definition = (uint64_t)v0;

  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_webtransport_definition::definition, (uint64_t)nw_webtransport_allocate_options, (uint64_t)nw_webtransport_copy_options, (uint64_t)nw_webtransport_deallocate_options);
  nw_protocol_definition_set_options_comparator((void *)nw_protocol_copy_webtransport_definition::definition, (uint64_t)nw_webtransport_compare_options);
  nw_protocol_definition_set_metadata_allocator((void *)nw_protocol_copy_webtransport_definition::definition, (uint64_t)nw_webtransport_allocate_stream_metadata, (uint64_t)nw_webtransport_deallocate_stream_metadata);
  nw_protocol_definition_set_metadata_comparator((void *)nw_protocol_copy_webtransport_definition::definition, (uint64_t)nw_webtransport_compare_stream_metadata);
  return nw_protocol_register_handle((uint64_t)nw_protocol_webtransport_identifier::protocol_identifier, (void *)nw_protocol_copy_webtransport_definition::definition, (uint64_t)nw_protocol_webtransport_create, (uint64_t)nw_protocol_webtransport_accept);
}

BOOL nw_webtransport_allocate_options(void *a1)
{
  id v1;
  _QWORD *v2;
  _BOOL8 result;
  NSObject *v4;
  void *v5;

  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x14uLL, 0xEAFB8F1AuLL);
  if (v2)
    goto LABEL_2;
  __nwlog_obj();
  v4 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  v5 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    *v2 = 0;
    v2[1] = 0;
    *((_DWORD *)v2 + 4) = 0;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_18392A354(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t nw_webtransport_copy_options(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  uint64_t options;
  char v6;
  void *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (a2)
  {
    options = nw_webtransport_allocate_options(v3);
    *(_OWORD *)options = *(_OWORD *)a2;
    v6 = *(_BYTE *)(options + 16) & 0xFE | *(_BYTE *)(a2 + 16) & 1;
    *(_BYTE *)(options + 16) = v6;
    *(_BYTE *)(options + 16) = v6 & 0xFD | *(_BYTE *)(a2 + 16) & 2;
    goto LABEL_3;
  }
  __nwlog_obj();
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v19 = "nw_webtransport_copy_options";
  v9 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_webtransport_copy_options";
        _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s called with null existing_handle", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v19 = "nw_webtransport_copy_options";
          v20 = 2082;
          v21 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_webtransport_copy_options";
        _os_log_impl(&dword_182FBE000, v10, v13, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v10 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "nw_webtransport_copy_options";
        _os_log_impl(&dword_182FBE000, v10, v15, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_20:
  if (v9)
    free(v9);
  options = 0;
LABEL_3:

  return options;
}

void sub_18392A630(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_webtransport_deallocate_options(int a1, void *a2)
{
  if (a2)
    free(a2);
}

uint64_t nw_webtransport_compare_options(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_webtransport_compare_options";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v11, &type, &v23))
      goto LABEL_44;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null handle1", buf, 0xCu);
      }
      goto LABEL_43;
    }
    if (!v23)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null handle1, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null handle1, no backtrace", buf, 0xCu);
      }
      goto LABEL_43;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v26 = "nw_webtransport_compare_options";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null handle1, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_31;
  }
  if (!a3)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_webtransport_compare_options";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v11, &type, &v23))
      goto LABEL_44;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null handle2", buf, 0xCu);
      }
LABEL_43:

LABEL_44:
      if (v11)
        free(v11);
      goto LABEL_10;
    }
    if (!v23)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null handle2, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_options";
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null handle2, no backtrace", buf, 0xCu);
      }
      goto LABEL_43;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v26 = "nw_webtransport_compare_options";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null handle2, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_31:

    free(backtrace_string);
    goto LABEL_44;
  }
  if (*(_DWORD *)a2 != *(_DWORD *)a3
    || *(_DWORD *)(a2 + 4) != *(_DWORD *)(a3 + 4)
    || *(_DWORD *)(a2 + 8) != *(_DWORD *)(a3 + 8)
    || *(_DWORD *)(a2 + 12) != *(_DWORD *)(a3 + 12)
    || !a4 && ((*(_BYTE *)(a3 + 16) ^ *(_BYTE *)(a2 + 16)) & 3) != 0)
  {
LABEL_10:
    v8 = 0;
    goto LABEL_11;
  }
  v8 = 1;
LABEL_11:

  return v8;
}

BOOL nw_webtransport_allocate_stream_metadata(void *a1)
{
  id v1;
  _QWORD *v2;
  _BOOL8 result;
  NSObject *v4;
  void *v5;

  v1 = a1;
  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (v2)
    goto LABEL_2;
  __nwlog_obj();
  v4 = objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  v5 = (void *)_os_log_send_and_compose_impl();

  result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_18392AC90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void nw_webtransport_deallocate_stream_metadata(int a1, void *a2)
{
  if (a2)
    free(a2);
}

uint64_t nw_webtransport_compare_stream_metadata(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7;
  uint64_t v8;
  void *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  os_log_type_t v15;
  char *backtrace_string;
  os_log_type_t v17;
  _BOOL4 v18;
  os_log_type_t v19;
  _BOOL4 v20;
  os_log_type_t v21;
  os_log_type_t v22;
  char v23;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  if (!a2)
  {
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_webtransport_compare_stream_metadata";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v11, &type, &v23))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s called with null handle1", buf, 0xCu);
      }
      goto LABEL_41;
    }
    if (!v23)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v21 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_182FBE000, v12, v21, "%{public}s called with null handle1, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v17 = type;
    v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null handle1, no backtrace", buf, 0xCu);
      }
      goto LABEL_41;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      v26 = "nw_webtransport_compare_stream_metadata";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v17, "%{public}s called with null handle1, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_29;
  }
  if (!a3)
  {
    __nwlog_obj();
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v26 = "nw_webtransport_compare_stream_metadata";
    v11 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v23 = 0;
    if (!__nwlog_fault(v11, &type, &v23))
      goto LABEL_42;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_182FBE000, v12, v15, "%{public}s called with null handle2", buf, 0xCu);
      }
LABEL_41:

LABEL_42:
      if (v11)
        free(v11);
      goto LABEL_5;
    }
    if (!v23)
    {
      __nwlog_obj();
      v12 = objc_claimAutoreleasedReturnValue();
      v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_182FBE000, v12, v22, "%{public}s called with null handle2, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    v12 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    v20 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_webtransport_compare_stream_metadata";
        _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null handle2, no backtrace", buf, 0xCu);
      }
      goto LABEL_41;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v26 = "nw_webtransport_compare_stream_metadata";
      v27 = 2082;
      v28 = backtrace_string;
      _os_log_impl(&dword_182FBE000, v12, v19, "%{public}s called with null handle2, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_29:

    free(backtrace_string);
    goto LABEL_42;
  }
  if (*(_QWORD *)a2 == *(_QWORD *)a3
    && ((*(_BYTE *)(a3 + 16) ^ *(_BYTE *)(a2 + 16)) & 7) == 0
    && (a4 || *(_QWORD *)(a2 + 8) == *(_QWORD *)(a3 + 8)))
  {
    v8 = 1;
    goto LABEL_6;
  }
LABEL_5:
  v8 = 0;
LABEL_6:

  return v8;
}

id nw_protocol_copy_webtransport_definition()
{
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
  return (id)nw_protocol_copy_webtransport_definition::definition;
}

BOOL nw_protocol_options_is_webtransport(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  _BOOL8 is_equal_unsafe;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[1];

    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_webtransport_definition::definition);

    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_options_is_webtransport";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_webtransport";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_options_is_webtransport";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_webtransport";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_options_is_webtransport";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_18392B4BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL nw_webtransport_options_get_is_unidirectional(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  os_log_type_t v17;
  _QWORD v18[5];
  char v19;
  os_log_type_t type;
  _BYTE buf[24];
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (nw_protocol_options_is_webtransport(v1))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v22 = 0;
      v18[0] = MEMORY[0x1E0C809B0];
      v18[1] = 3221225472;
      v18[2] = __nw_webtransport_options_get_is_unidirectional_block_invoke;
      v18[3] = &unk_1E14A9D68;
      v18[4] = buf;
      nw_protocol_options_access_handle(v2, v18);
      v3 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s protocol options are not webtransport", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v19)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v19)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_unidirectional";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_4:

  return v3;
}

void sub_18392B9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_options_get_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 16) & 1;
  return 1;
}

void nw_webtransport_options_set_is_unidirectional(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[4];
  char v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_webtransport_options_set_is_unidirectional";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v6, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_options_set_is_unidirectional";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_webtransport_options_set_is_unidirectional";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_options_set_is_unidirectional";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_options_set_is_unidirectional";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (nw_protocol_options_is_webtransport(v3))
  {
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v19[2] = __nw_webtransport_options_set_is_unidirectional_block_invoke;
    v19[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v20 = a2;
    nw_protocol_options_access_handle(v4, v19);
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_webtransport_options_set_is_unidirectional";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v6, &type, &v21))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_options_set_is_unidirectional";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s protocol options are not webtransport", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v21)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_options_set_is_unidirectional";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_options_set_is_unidirectional";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_webtransport_options_set_is_unidirectional";
    v25 = 2082;
    v26 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_18392BF0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_options_set_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 16) = *(_BYTE *)(a2 + 16) & 0xFE | *(_BYTE *)(a1 + 32);
  return 1;
}

BOOL nw_webtransport_options_get_is_datagram(void *a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  _BOOL4 v15;
  os_log_type_t v16;
  os_log_type_t v17;
  _QWORD v18[5];
  char v19;
  os_log_type_t type;
  _BYTE buf[24];
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (nw_protocol_options_is_webtransport(v1))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v22 = 0;
      v18[0] = MEMORY[0x1E0C809B0];
      v18[1] = 3221225472;
      v18[2] = __nw_webtransport_options_get_is_datagram_block_invoke;
      v18[3] = &unk_1E14A9D68;
      v18[4] = buf;
      nw_protocol_options_access_handle(v2, v18);
      v3 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }
    __nwlog_obj();
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v10 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s protocol options are not webtransport", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v19)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      v15 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v14, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v19 = 0;
    if (__nwlog_fault(v6, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v19)
      {
        __nwlog_obj();
        v7 = objc_claimAutoreleasedReturnValue();
        v16 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v7, v16, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (!backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_options_get_is_datagram";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v6)
    free(v6);
  v3 = 0;
LABEL_4:

  return v3;
}

void sub_18392C444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_options_get_is_datagram_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 16) & 2) != 0;
  return 1;
}

void nw_webtransport_options_set_is_datagram(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  char *v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[4];
  char v20;
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_webtransport_options_set_is_datagram";
    v6 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v6, &type, &v21))
      goto LABEL_38;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_options_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_webtransport_options_set_is_datagram";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6)
          goto LABEL_4;
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_options_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v7, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v7 = objc_claimAutoreleasedReturnValue();
      v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_options_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v7, v17, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (nw_protocol_options_is_webtransport(v3))
  {
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 3221225472;
    v19[2] = __nw_webtransport_options_set_is_datagram_block_invoke;
    v19[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v20 = a2;
    nw_protocol_options_access_handle(v4, v19);
    goto LABEL_4;
  }
  __nwlog_obj();
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_webtransport_options_set_is_datagram";
  v6 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v6, &type, &v21))
    goto LABEL_38;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_options_set_is_datagram";
      _os_log_impl(&dword_182FBE000, v7, v10, "%{public}s protocol options are not webtransport", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v21)
  {
    __nwlog_obj();
    v7 = objc_claimAutoreleasedReturnValue();
    v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_options_set_is_datagram";
      _os_log_impl(&dword_182FBE000, v7, v18, "%{public}s protocol options are not webtransport, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  v14 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v7 = objc_claimAutoreleasedReturnValue();
  v15 = type;
  v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_options_set_is_datagram";
      _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s protocol options are not webtransport, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_webtransport_options_set_is_datagram";
    v25 = 2082;
    v26 = v14;
    _os_log_impl(&dword_182FBE000, v7, v15, "%{public}s protocol options are not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6)
    goto LABEL_39;
LABEL_4:

}

void sub_18392C970(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_options_set_is_datagram_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 16) = *(_BYTE *)(a2 + 16) & 0xFD | (2 * *(_BYTE *)(a1 + 32));
  return 1;
}

id *nw_webtransport_create_metadata()
{
  if (nw_protocol_copy_webtransport_definition::onceToken != -1)
    dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
  return nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_webtransport_definition::definition);
}

BOOL nw_protocol_metadata_is_webtransport(void *a1)
{
  id v1;
  void *v2;
  id *v3;
  id v4;
  _BOOL8 is_equal_unsafe;
  void *v7;
  char *v8;
  NSObject *v9;
  os_log_type_t v10;
  char *backtrace_string;
  os_log_type_t v12;
  _BOOL4 v13;
  os_log_type_t v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (id *)v1;
    v4 = v3[1];

    if (nw_protocol_copy_webtransport_definition::onceToken != -1)
      dispatch_once(&nw_protocol_copy_webtransport_definition::onceToken, &__block_literal_global_59802);
    is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_webtransport_definition::definition);

    goto LABEL_5;
  }
  __nwlog_obj();
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_metadata_is_webtransport";
  v8 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_webtransport";
        _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v12 = type;
      v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          v18 = "nw_protocol_metadata_is_webtransport";
          v19 = 2082;
          v20 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_webtransport";
        _os_log_impl(&dword_182FBE000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v9 = objc_claimAutoreleasedReturnValue();
      v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        v18 = "nw_protocol_metadata_is_webtransport";
        _os_log_impl(&dword_182FBE000, v9, v14, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }

  }
LABEL_22:
  if (v8)
    free(v8);
  is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_18392CCC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t nw_webtransport_metadata_get_stream_id(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[5];
  char v20;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (nw_protocol_metadata_is_webtransport(v1))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v23 = 0;
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3221225472;
      v19[2] = __nw_webtransport_metadata_get_stream_id_block_invoke;
      v19[3] = &unk_1E14A9D68;
      v19[4] = buf;
      v3 = v2[4];
      if (v3)
      {
        __nw_webtransport_metadata_get_stream_id_block_invoke((uint64_t)v19, v3);
        v4 = *(_QWORD *)(*(_QWORD *)&buf[8] + 24);
      }
      else
      {
        v4 = 0;
      }
      _Block_object_dispose(buf, 8);
      goto LABEL_7;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_stream_id";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
  }
LABEL_40:
  if (v7)
    free(v7);
  v4 = -1;
LABEL_7:

  return v4;
}

void sub_18392D1E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_get_stream_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 8);
  return 1;
}

void nw_webtransport_metadata_set_stream_id(void *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  _QWORD v20[5];
  char v21;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v24 = "nw_webtransport_metadata_set_stream_id";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v21 = 0;
    if (!__nwlog_fault(v7, &type, &v21))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_metadata_set_stream_id";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v24 = "nw_webtransport_metadata_set_stream_id";
          v25 = 2082;
          v26 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7)
          goto LABEL_5;
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_metadata_set_stream_id";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v24 = "nw_webtransport_metadata_set_stream_id";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __nw_webtransport_metadata_set_stream_id_block_invoke;
    v20[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v20[4] = a2;
    v5 = v4[4];
    if (v5)
      __nw_webtransport_metadata_set_stream_id_block_invoke((uint64_t)v20, v5);
    goto LABEL_5;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v24 = "nw_webtransport_metadata_set_stream_id";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v21 = 0;
  if (!__nwlog_fault(v7, &type, &v21))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v21)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v24 = "nw_webtransport_metadata_set_stream_id";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v24 = "nw_webtransport_metadata_set_stream_id";
    v25 = 2082;
    v26 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_40;
LABEL_5:

}

void sub_18392D6FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_set_stream_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 32);
  return 1;
}

BOOL nw_webtransport_metadata_get_is_unidirectional(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  _BOOL8 v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[5];
  char v20;
  os_log_type_t type;
  _BYTE buf[24];
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (nw_protocol_metadata_is_webtransport(v1))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v23 = 0;
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3221225472;
      v19[2] = __nw_webtransport_metadata_get_is_unidirectional_block_invoke;
      v19[3] = &unk_1E14A9D68;
      v19[4] = buf;
      v3 = v2[4];
      if (v3)
      {
        __nw_webtransport_metadata_get_is_unidirectional_block_invoke((uint64_t)v19, v3);
        v4 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
      }
      else
      {
        v4 = 0;
      }
      _Block_object_dispose(buf, 8);
      goto LABEL_7;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_unidirectional";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
  }
LABEL_40:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_7:

  return v4;
}

void sub_18392DC3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_get_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 16) & 1;
  return 1;
}

void nw_webtransport_metadata_set_is_unidirectional(void *a1, char a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  _QWORD v20[4];
  char v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_webtransport_metadata_set_is_unidirectional";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_unidirectional";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_webtransport_metadata_set_is_unidirectional";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7)
          goto LABEL_5;
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_unidirectional";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_unidirectional";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __nw_webtransport_metadata_set_is_unidirectional_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v21 = a2;
    v5 = v4[4];
    if (v5)
      __nw_webtransport_metadata_set_is_unidirectional_block_invoke((uint64_t)v20, v5);
    goto LABEL_5;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_webtransport_metadata_set_is_unidirectional";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v7, &type, &v22))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v22)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_unidirectional";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_webtransport_metadata_set_is_unidirectional";
    v26 = 2082;
    v27 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_40;
LABEL_5:

}

void sub_18392E154(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_set_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 16) = *(_BYTE *)(a2 + 16) & 0xFE | *(_BYTE *)(a1 + 32);
  return 1;
}

BOOL nw_webtransport_metadata_get_is_datagram(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  _BOOL8 v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[5];
  char v20;
  os_log_type_t type;
  _BYTE buf[24];
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (nw_protocol_metadata_is_webtransport(v1))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v23 = 0;
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3221225472;
      v19[2] = __nw_webtransport_metadata_get_is_datagram_block_invoke;
      v19[3] = &unk_1E14A9D68;
      v19[4] = buf;
      v3 = v2[4];
      if (v3)
      {
        __nw_webtransport_metadata_get_is_datagram_block_invoke((uint64_t)v19, v3);
        v4 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
      }
      else
      {
        v4 = 0;
      }
      _Block_object_dispose(buf, 8);
      goto LABEL_7;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_datagram";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
  }
LABEL_40:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_7:

  return v4;
}

void sub_18392E6A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_get_is_datagram_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 16) & 2) != 0;
  return 1;
}

void nw_webtransport_metadata_set_is_datagram(void *a1, char a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  _QWORD v20[4];
  char v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_webtransport_metadata_set_is_datagram";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_webtransport_metadata_set_is_datagram";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7)
          goto LABEL_5;
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_datagram";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __nw_webtransport_metadata_set_is_datagram_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v21 = a2;
    v5 = v4[4];
    if (v5)
      __nw_webtransport_metadata_set_is_datagram_block_invoke((uint64_t)v20, v5);
    goto LABEL_5;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_webtransport_metadata_set_is_datagram";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v7, &type, &v22))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v22)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_datagram";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_webtransport_metadata_set_is_datagram";
    v26 = 2082;
    v27 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_40;
LABEL_5:

}

void sub_18392EBB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_set_is_datagram_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 16) = *(_BYTE *)(a2 + 16) & 0xFD | (2 * *(_BYTE *)(a1 + 32));
  return 1;
}

BOOL nw_webtransport_metadata_get_is_peer_initiated(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  _BOOL8 v4;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  os_log_type_t v15;
  _BOOL4 v16;
  os_log_type_t v17;
  os_log_type_t v18;
  _QWORD v19[5];
  char v20;
  os_log_type_t type;
  _BYTE buf[24];
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if (nw_protocol_metadata_is_webtransport(v1))
    {
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = buf;
      *(_QWORD *)&buf[16] = 0x2020000000;
      v23 = 0;
      v19[0] = MEMORY[0x1E0C809B0];
      v19[1] = 3221225472;
      v19[2] = __nw_webtransport_metadata_get_is_peer_initiated_block_invoke;
      v19[3] = &unk_1E14A9D68;
      v19[4] = buf;
      v3 = v2[4];
      if (v3)
      {
        __nw_webtransport_metadata_get_is_peer_initiated_block_invoke((uint64_t)v19, v3);
        v4 = *(_BYTE *)(*(_QWORD *)&buf[8] + 24) != 0;
      }
      else
      {
        v4 = 0;
      }
      _Block_object_dispose(buf, 8);
      goto LABEL_7;
    }
    __nwlog_obj();
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v15 = type;
      v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v15, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
  }
  else
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v20 = 0;
    if (__nwlog_fault(v7, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v20)
      {
        __nwlog_obj();
        v8 = objc_claimAutoreleasedReturnValue();
        v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_182FBE000, v8, v17, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_webtransport_metadata_get_is_peer_initiated";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
  }
LABEL_40:
  if (v7)
    free(v7);
  v4 = 0;
LABEL_7:

  return v4;
}

void sub_18392F104(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_get_is_peer_initiated_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_BYTE *)(a2 + 16) & 4) != 0;
  return 1;
}

void nw_webtransport_metadata_set_is_peer_initiated(void *a1, char a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  void *v10;
  os_log_type_t v11;
  char *backtrace_string;
  os_log_type_t v13;
  _BOOL4 v14;
  char *v15;
  os_log_type_t v16;
  _BOOL4 v17;
  os_log_type_t v18;
  os_log_type_t v19;
  _QWORD v20[4];
  char v21;
  char v22;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  char *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    v25 = "nw_webtransport_metadata_set_is_peer_initiated";
    v7 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22))
      goto LABEL_39;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_peer_initiated";
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v13 = type;
      v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          v25 = "nw_webtransport_metadata_set_is_peer_initiated";
          v26 = 2082;
          v27 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7)
          goto LABEL_5;
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_peer_initiated";
        _os_log_impl(&dword_182FBE000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v8 = objc_claimAutoreleasedReturnValue();
      v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        v25 = "nw_webtransport_metadata_set_is_peer_initiated";
        _os_log_impl(&dword_182FBE000, v8, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (nw_protocol_metadata_is_webtransport(v3))
  {
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __nw_webtransport_metadata_set_is_peer_initiated_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    v21 = a2;
    v5 = v4[4];
    if (v5)
      __nw_webtransport_metadata_set_is_peer_initiated_block_invoke((uint64_t)v20, v5);
    goto LABEL_5;
  }
  __nwlog_obj();
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  v25 = "nw_webtransport_metadata_set_is_peer_initiated";
  v7 = (char *)_os_log_send_and_compose_impl();

  type = OS_LOG_TYPE_ERROR;
  v22 = 0;
  if (!__nwlog_fault(v7, &type, &v22))
    goto LABEL_39;
  if (type == OS_LOG_TYPE_FAULT)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl(&dword_182FBE000, v8, v11, "%{public}s protocol metadata is not webtransport", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v22)
  {
    __nwlog_obj();
    v8 = objc_claimAutoreleasedReturnValue();
    v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl(&dword_182FBE000, v8, v19, "%{public}s protocol metadata is not webtransport, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  v15 = (char *)__nw_create_backtrace_string();
  __nwlog_obj();
  v8 = objc_claimAutoreleasedReturnValue();
  v16 = type;
  v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v25 = "nw_webtransport_metadata_set_is_peer_initiated";
      _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    v25 = "nw_webtransport_metadata_set_is_peer_initiated";
    v26 = 2082;
    v27 = v15;
    _os_log_impl(&dword_182FBE000, v8, v16, "%{public}s protocol metadata is not webtransport, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7)
    goto LABEL_40;
LABEL_5:

}

void sub_18392F61C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __nw_webtransport_metadata_set_is_peer_initiated_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 16) = *(_BYTE *)(a2 + 16) & 0xFB | (4 * *(_BYTE *)(a1 + 32));
  return 1;
}

BOOL nw_protocol_http3_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  char *v7;
  uint64_t v8;
  _WORD *v9;
  int v10;
  unsigned int v11;
  void *v12;
  void *v13;
  id *metadata;
  id v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  BOOL is_equal_unsafe;
  id v21;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  int v25;
  const char *v26;
  _BOOL8 result;
  char *v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  NSObject *v32;
  void *v33;
  void *v34;
  char *v35;
  NSObject *v36;
  os_log_type_t v37;
  void *v38;
  os_log_type_t v39;
  char *backtrace_string;
  _BOOL4 v41;
  char *v42;
  os_log_type_t v43;
  _BOOL4 v44;
  char *v45;
  os_log_type_t v46;
  _BOOL4 v47;
  os_log_type_t v48;
  os_log_type_t v49;
  _QWORD v50[5];
  _QWORD aBlock[5];
  char v52;
  os_log_type_t type;
  _BYTE buf[24];
  uint64_t v55;
  void *v56;
  char *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http3_create";
    v28 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (__nwlog_fault(v28, &type, &v52))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http3_create";
          v31 = "%{public}s called with null identifier";
LABEL_73:
          _os_log_impl(&dword_182FBE000, v29, v30, v31, buf, 0xCu);
        }
      }
      else if (v52)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v29 = __nwlog_obj();
        v30 = type;
        v41 = os_log_type_enabled(v29, type);
        if (backtrace_string)
        {
          if (v41)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_http3_create";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v29, v30, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_74;
        }
        if (v41)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http3_create";
          v31 = "%{public}s called with null identifier, no backtrace";
          goto LABEL_73;
        }
      }
      else
      {
        v29 = __nwlog_obj();
        v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http3_create";
          v31 = "%{public}s called with null identifier, backtrace limit exceeded";
          goto LABEL_73;
        }
      }
    }
LABEL_74:
    if (v28)
      free(v28);
    return 0;
  }
  v7 = (char *)malloc_type_calloc(1uLL, 0x560uLL, 0xEAFB8F1AuLL);
  if (v7)
    goto LABEL_3;
  v32 = __nwlog_obj();
  os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  *(_QWORD *)&buf[4] = "strict_calloc";
  *(_WORD *)&buf[12] = 2048;
  *(_QWORD *)&buf[14] = 1;
  *(_WORD *)&buf[22] = 2048;
  v55 = 1376;
  v33 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v33);
  if (!result)
  {
    free(v33);
LABEL_3:
    bzero(v7, 0x560uLL);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v8 = MEMORY[0x1E0C809B0];
    v55 = (uint64_t)v7;
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 0x40000000;
    aBlock[2] = __nw_protocol_http3_create_block_invoke;
    aBlock[3] = &unk_1E14A79E8;
    aBlock[4] = buf;
    *((_QWORD *)v7 + 130) = _Block_copy(aBlock);
    _Block_object_dispose(buf, 8);
    if (nw_protocol_http3_get_callbacks(void)::onceToken != -1)
      dispatch_once(&nw_protocol_http3_get_callbacks(void)::onceToken, &__block_literal_global_57_59991);
    *((_QWORD *)v7 + 2) = a1;
    *((_QWORD *)v7 + 3) = &nw_protocol_http3_get_callbacks(void)::protocol_callbacks;
    *((_QWORD *)v7 + 5) = v7;
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 9) = v7;
    v7[130] = 0;
    if (nw_protocol_http3_get_listen_callbacks(void)::onceToken != -1)
      dispatch_once(&nw_protocol_http3_get_listen_callbacks(void)::onceToken, &__block_literal_global_169);
    *((_QWORD *)v7 + 17) = &nw_protocol_http3_get_listen_callbacks(void)::listen_protocol_callbacks;
    *((_QWORD *)v7 + 20) = v7;
    *((_QWORD *)v7 + 21) = -1;
    *((_OWORD *)v7 + 11) = 0u;
    *((_OWORD *)v7 + 13) = 0u;
    *((_QWORD *)v7 + 28) = v7 + 216;
    *(_OWORD *)(v7 + 232) = 0u;
    *(_QWORD *)(v7 + 246) = 0;
    *((_QWORD *)v7 + 24) = v7;
    *((_QWORD *)v7 + 25) = v7;
    *((_QWORD *)v7 + 141) = 0;
    v9 = v7 + 1373;
    *(_WORD *)(v7 + 1373) = *(_WORD *)(v7 + 1373) & 0xFFFE | nw_parameters_get_server_mode(a4);
    *((_QWORD *)v7 + 157) = nw_parameters_copy_context(a4);
    *((_OWORD *)v7 + 20) = 0u;
    *((_OWORD *)v7 + 21) = 0u;
    *((_OWORD *)v7 + 22) = 0u;
    *((_OWORD *)v7 + 23) = 0u;
    *((_OWORD *)v7 + 16) = 0u;
    *((_OWORD *)v7 + 17) = 0u;
    *((_OWORD *)v7 + 18) = 0u;
    *((_OWORD *)v7 + 19) = 0u;
    *((_OWORD *)v7 + 24) = 0u;
    *((_OWORD *)v7 + 25) = 0u;
    *((_OWORD *)v7 + 26) = 0u;
    *((_OWORD *)v7 + 27) = 0u;
    *((_OWORD *)v7 + 28) = 0u;
    *((_OWORD *)v7 + 29) = 0u;
    *((_QWORD *)v7 + 40) = v7 + 312;
    *((_QWORD *)v7 + 43) = v7 + 336;
    *((_QWORD *)v7 + 45) = v7 + 352;
    *((_QWORD *)v7 + 47) = v7 + 368;
    *((_OWORD *)v7 + 51) = 0u;
    *((_OWORD *)v7 + 52) = 0u;
    *((_OWORD *)v7 + 49) = 0u;
    *((_OWORD *)v7 + 50) = 0u;
    *((_OWORD *)v7 + 47) = 0u;
    *((_OWORD *)v7 + 48) = 0u;
    *((_OWORD *)v7 + 45) = 0u;
    *((_OWORD *)v7 + 46) = 0u;
    *((_OWORD *)v7 + 43) = 0u;
    *((_OWORD *)v7 + 44) = 0u;
    *((_OWORD *)v7 + 41) = 0u;
    *((_OWORD *)v7 + 42) = 0u;
    *((_OWORD *)v7 + 39) = 0u;
    *((_OWORD *)v7 + 40) = 0u;
    *((_OWORD *)v7 + 37) = 0u;
    *((_OWORD *)v7 + 38) = 0u;
    *((_OWORD *)v7 + 35) = 0u;
    *((_OWORD *)v7 + 36) = 0u;
    *((_OWORD *)v7 + 33) = 0u;
    *((_OWORD *)v7 + 34) = 0u;
    *((_OWORD *)v7 + 31) = 0u;
    *((_OWORD *)v7 + 32) = 0u;
    *((_OWORD *)v7 + 30) = 0u;
    *(_QWORD *)(v7 + 500) = 0x3FFF00003FFFLL;
    *((int32x2_t *)v7 + 66) = vdup_n_s32(0x3FDu);
    *((_QWORD *)v7 + 64) = 0x1FF00000064;
    *((_QWORD *)v7 + 67) = &nw_qpack_dec_callbacks;
    *((_QWORD *)v7 + 73) = v7 + 576;
    *((_QWORD *)v7 + 75) = v7 + 592;
    *((_QWORD *)v7 + 77) = v7 + 608;
    *((_QWORD *)v7 + 79) = v7 + 624;
    *((_QWORD *)v7 + 81) = v7 + 640;
    *((_QWORD *)v7 + 83) = v7 + 656;
    *((_QWORD *)v7 + 85) = v7 + 672;
    *((_QWORD *)v7 + 87) = v7 + 688;
    *((_QWORD *)v7 + 89) = v7 + 704;
    *((_QWORD *)v7 + 110) = 0;
    *((_QWORD *)v7 + 111) = v7 + 880;
    *((_QWORD *)v7 + 112) = 0;
    *((_QWORD *)v7 + 113) = v7 + 896;
    *((_QWORD *)v7 + 114) = 0;
    *((_QWORD *)v7 + 115) = v7 + 912;
    *((_QWORD *)v7 + 116) = 0;
    *((_QWORD *)v7 + 117) = v7 + 928;
    *((_QWORD *)v7 + 118) = 0;
    *((_QWORD *)v7 + 119) = v7 + 944;
    *((_QWORD *)v7 + 120) = 0;
    *((_QWORD *)v7 + 121) = v7 + 960;
    *((_OWORD *)v7 + 62) = 0u;
    *((_QWORD *)v7 + 126) = -1;
    *((_DWORD *)v7 + 318) = 0;
    if (nw_parameters_get_logging_disabled((uint64_t)a4))
      v10 = 0x400000;
    else
      v10 = 0;
    v11 = (*(unsigned __int16 *)(v7 + 1373) | (v7[1375] << 16)) & 0xFFBFFFFF;
    *v9 = *(_WORD *)(v7 + 1373);
    v7[1375] = (v11 | v10) >> 16;
    *((_QWORD *)v7 + 127) = 240000;
    if (a3)
    {
      *((_QWORD *)v7 + 137) = os_retain(a3);
      if (a4)
      {
LABEL_12:
        v12 = os_retain(a4);
        goto LABEL_15;
      }
    }
    else
    {
      *((_QWORD *)v7 + 137) = 0;
      if (a4)
        goto LABEL_12;
    }
    v12 = 0;
LABEL_15:
    *((_QWORD *)v7 + 140) = v12;
    v13 = (void *)*((_QWORD *)v7 + 157);
    v50[0] = v8;
    v50[1] = 0x40000000;
    v50[2] = __nw_protocol_http3_create_block_invoke_2;
    v50[3] = &__block_descriptor_tmp_4_59992;
    v50[4] = v7;
    metadata = nw_http_connection_create_metadata(v13, v50, 0);
    *((_QWORD *)v7 + 156) = metadata;
    nw_http_connection_metadata_set_version(metadata, 5);
    v15 = *((id *)v7 + 156);
    v16 = &__block_literal_global_59993;
    v17 = &__block_literal_global_59993;
    if (v15)
    {
      v18 = v15;
      v19 = *((id *)v18 + 1);

      if (nw_protocol_copy_http_connection_definition_onceToken != -1)
        dispatch_once(&nw_protocol_copy_http_connection_definition_onceToken, &__block_literal_global_62);
      is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v19, nw_protocol_copy_http_connection_definition_definition);

      if (is_equal_unsafe)
      {
        *(_QWORD *)buf = v8;
        *(_QWORD *)&buf[8] = 3221225472;
        *(_QWORD *)&buf[16] = __nw_http_connection_metadata_set_send_certificate_block_invoke;
        v55 = (uint64_t)&unk_1E14AA3E0;
        v57 = v7;
        v21 = &__block_literal_global_59993;
        v56 = &__block_literal_global_59993;
        v22 = *((_QWORD *)v18 + 4);
        if (v22)
        {
          __nw_http_connection_metadata_set_send_certificate_block_invoke((uint64_t)buf, v22);
          v16 = v56;
        }

        goto LABEL_22;
      }
      __nwlog_obj();
      v38 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
      v35 = (char *)_os_log_send_and_compose_impl();

      type = OS_LOG_TYPE_ERROR;
      v52 = 0;
      if (__nwlog_fault(v35, &type, &v52))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v39 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
            _os_log_impl(&dword_182FBE000, v36, v39, "%{public}s metadata must be http_connection", buf, 0xCu);
          }
        }
        else if (v52)
        {
          v45 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v46 = type;
          v47 = os_log_type_enabled(v36, type);
          if (v45)
          {
            if (v47)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v45;
              _os_log_impl(&dword_182FBE000, v36, v46, "%{public}s metadata must be http_connection, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v45);
            if (!v35)
              goto LABEL_22;
            goto LABEL_84;
          }
          if (v47)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
            _os_log_impl(&dword_182FBE000, v36, v46, "%{public}s metadata must be http_connection, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __nwlog_obj();
          v36 = objc_claimAutoreleasedReturnValue();
          v49 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
            _os_log_impl(&dword_182FBE000, v36, v49, "%{public}s metadata must be http_connection, backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_82;
      }
LABEL_83:
      if (!v35)
      {
LABEL_22:

        if ((((unsigned __int16)*v9 | (v7[1375] << 16)) & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v23 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            v24 = v7 + 1289;
            v25 = *((_DWORD *)v7 + 320);
            *(_QWORD *)&buf[4] = "nw_protocol_http3_create";
            *(_WORD *)&buf[12] = 2082;
            *(_DWORD *)buf = 136447234;
            if (!v7)
              v24 = "";
            *(_QWORD *)&buf[14] = v24;
            if (v7)
              v26 = " ";
            else
              v26 = "";
            *(_WORD *)&buf[22] = 2080;
            v55 = (uint64_t)v26;
            LOWORD(v56) = 1024;
            *(_DWORD *)((char *)&v56 + 2) = v25;
            HIWORD(v56) = 2048;
            v57 = v7;
            _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> created %p", buf, 0x30u);
          }
        }
        return (BOOL)v7;
      }
LABEL_84:
      free(v35);
      goto LABEL_22;
    }
    __nwlog_obj();
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
    v35 = (char *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v35, &type, &v52))
      goto LABEL_83;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v37 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
        _os_log_impl(&dword_182FBE000, v36, v37, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v52)
    {
      v42 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v43 = type;
      v44 = os_log_type_enabled(v36, type);
      if (v42)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v42;
          _os_log_impl(&dword_182FBE000, v36, v43, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v42);
        goto LABEL_83;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
        _os_log_impl(&dword_182FBE000, v36, v43, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __nwlog_obj();
      v36 = objc_claimAutoreleasedReturnValue();
      v48 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http_connection_metadata_set_send_certificate";
        _os_log_impl(&dword_182FBE000, v36, v48, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_82:

    goto LABEL_83;
  }
  __break(1u);
  return result;
}

uint64_t __nw_protocol_http3_create_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void __nw_protocol_http3_create_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  nw_protocol *v4;
  nw_protocol *output_handler;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *backtrace_string;
  _BOOL4 v12;
  char v13;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
  {
    if (((*(unsigned __int16 *)(v1 + 1373) | (*(unsigned __int8 *)(v1 + 1375) << 16)) & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v2 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        v3 = *(_DWORD *)(v1 + 1280);
        *(_DWORD *)buf = 136446978;
        v16 = "nw_http3_cancel";
        v17 = 2082;
        v18 = (char *)(v1 + 1289);
        v19 = 2080;
        v20 = " ";
        v21 = 1024;
        v22 = v3;
        _os_log_impl(&dword_182FBE000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u> cancelling", buf, 0x26u);
      }
    }
    v4 = *(nw_protocol **)(v1 + 880);
    if (v4)
    {
      do
      {
        output_handler = v4[8].output_handler;
        nw_protocol_http3_stream_error(v4, (nw_protocol *)v1, 89);
        v4 = output_handler;
      }
      while (output_handler);
    }
    v6 = *(void **)(v1 + 1240);
    if (v6)
      nw_quic_connection_close_with_error(v6, 256);
    nw_http3_async_close_connection_if_no_stream(v1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_http3_cancel";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_http3_cancel";
      v10 = "%{public}s called with null http3";
      goto LABEL_24;
    }
    if (!v13)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v16 = "nw_http3_cancel";
      v10 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v12 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        v16 = "nw_http3_cancel";
        v17 = 2082;
        v18 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_25;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      v16 = "nw_http3_cancel";
      v10 = "%{public}s called with null http3, no backtrace";
LABEL_24:
      _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    }
  }
LABEL_25:
  if (v7)
    free(v7);
}

void __nw_protocol_http3_create_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5;
  void *v6;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  char *backtrace_string;
  _BOOL4 v14;
  NSObject *v15;
  int v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *v21;
  _BOOL4 v22;
  char *v23;
  _BOOL4 v24;
  char v25;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = nw_quic_connection_copy_sec_protocol_metadata(*(void **)(a2 + 1240));
    if (v5)
    {
      v6 = v5;
      if (!*(_QWORD *)(a2 + 1192))
      {
        v11 = sec_protocol_metadata_copy_authenticator();
        *(_QWORD *)(a2 + 1192) = v11;
        if (v11)
        {
          v12 = *(void **)(a2 + 1256);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___ZL34nw_protocol_http3_send_certificatePvP12sec_identity_block_invoke;
          v28 = (const char *)&__block_descriptor_tmp_27_60015;
          v29 = a2;
          nw_queue_context_async(v12, buf);
        }
        else if (((*(unsigned __int16 *)(a2 + 1373) | (*(unsigned __int8 *)(a2 + 1375) << 16)) & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v15 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v16 = *(_DWORD *)(a2 + 1280);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = a2 + 1289;
            *(_WORD *)&buf[22] = 2080;
            v28 = " ";
            LOWORD(v29) = 1024;
            *(_DWORD *)((char *)&v29 + 2) = v16;
            HIWORD(v29) = 2112;
            v30 = a3;
            _os_log_impl(&dword_182FBE000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Failed to generate authenticator for identity %@", buf, 0x30u);
          }
        }
        goto LABEL_25;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
      v7 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v25 = 0;
      if (__nwlog_fault(v7, &type, &v25))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = gLogObj;
          v9 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_23;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
          v10 = "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring";
          goto LABEL_22;
        }
        if (!v25)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v8 = gLogObj;
          v9 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type))
            goto LABEL_23;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
          v10 = "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring, backtrace limit exceeded";
          goto LABEL_22;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v8 = gLogObj;
        v9 = type;
        v14 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_23;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
          v10 = "%{public}s HTTP3 got request to send certificate while one is already being sent, ignoring, no backtrace";
LABEL_22:
          _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
        }
      }
LABEL_23:
      if (v7)
        free(v7);
LABEL_25:
      os_release(v6);
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (__nwlog_fault(v17, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (!os_log_type_enabled(v18, type))
          goto LABEL_55;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
        v20 = "%{public}s called with null sec_metadata";
        goto LABEL_54;
      }
      if (!v25)
      {
        v18 = __nwlog_obj();
        v19 = type;
        if (!os_log_type_enabled(v18, type))
          goto LABEL_55;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
        v20 = "%{public}s called with null sec_metadata, backtrace limit exceeded";
        goto LABEL_54;
      }
      v23 = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type;
      v24 = os_log_type_enabled(v18, type);
      if (v23)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v23;
          _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null sec_metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v23);
        if (v17)
          goto LABEL_56;
        return;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
        v20 = "%{public}s called with null sec_metadata, no backtrace";
LABEL_54:
        _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
    v17 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v25 = 0;
    if (!__nwlog_fault(v17, &type, &v25))
      goto LABEL_55;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_55;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
      v20 = "%{public}s called with null handle";
      goto LABEL_54;
    }
    if (!v25)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_55;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
      v20 = "%{public}s called with null handle, backtrace limit exceeded";
      goto LABEL_54;
    }
    v21 = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v22 = os_log_type_enabled(v18, type);
    if (!v21)
    {
      if (!v22)
        goto LABEL_55;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
      v20 = "%{public}s called with null handle, no backtrace";
      goto LABEL_54;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_send_certificate";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v21;
      _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v21);
  }
LABEL_55:
  if (v17)
LABEL_56:
    free(v17);
}

void ___ZL34nw_protocol_http3_send_certificatePvP12sec_identity_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v2 + 1272) == 3 && !*(_QWORD *)(v2 + 912))
  {
    *(_DWORD *)(v2 + 1272) = 2;
    nw_http3_control_stream_process_output(v2, a2);
  }
  else
  {
    *(_BYTE *)(v2 + 1375) = (*(unsigned __int16 *)(v2 + 1373) | (*(unsigned __int8 *)(v2 + 1375) << 16) | 0x40000u) >> 16;
  }
}

void nw_http3_control_stream_process_output(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned __int16 *v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  _DWORD **v8;
  NSObject *v9;
  unsigned int size;
  uint64_t v11;
  uint64_t v12;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, uint64_t);
  uint64_t v21;
  size_t v22;
  uint32_t v23;
  size_t v24;
  uint32_t v25;
  size_t v26;
  size_t v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  const char *v39;
  char *v40;
  uint64_t v41;
  const char *v42;
  char *v43;
  _BOOL4 v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  const char *v48;
  uint64_t v49;
  const char *v50;
  NSObject *v51;
  os_log_type_t v52;
  const char *v53;
  char *v54;
  NSObject *v55;
  os_log_type_t v56;
  const char *v57;
  char *v58;
  _BOOL4 v59;
  char *v60;
  NSObject *v61;
  os_log_type_t v62;
  const char *v63;
  char *backtrace_string;
  _BOOL4 v65;
  os_log_type_t v66;
  os_log_type_t v67;
  os_log_type_t v68;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  _QWORD v72[6];
  unsigned int v73;
  _QWORD v74[2];
  uint64_t (*v75)(uint64_t, uint64_t);
  void *v76;
  _QWORD *v77;
  uint64_t v78;
  unsigned int v79;
  _QWORD v80[6];
  char v81;
  _QWORD v82[2];
  uint64_t (*v83)(uint64_t, uint64_t);
  void *v84;
  _QWORD *v85;
  uint64_t v86;
  char v87;
  _QWORD v88[7];
  _QWORD v89[2];
  uint64_t (*v90)(_QWORD *);
  void *v91;
  os_log_type_t *v92;
  size_t v93;
  _QWORD *v94;
  uint64_t v95;
  os_log_type_t type[8];
  os_log_type_t *v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t __src;
  os_log_type_t v101[8];
  os_log_type_t *v102;
  uint64_t v103;
  __n128 (*v104)(uint64_t, uint64_t);
  uint64_t (*v105)();
  _DWORD *v106[2];
  _QWORD buf[12];

  buf[9] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
    v60 = (char *)_os_log_send_and_compose_impl();
    v101[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v60, v101, type))
      goto LABEL_143;
    if (v101[0] == OS_LOG_TYPE_FAULT)
    {
      v61 = __nwlog_obj();
      v62 = v101[0];
      if (!os_log_type_enabled(v61, v101[0]))
        goto LABEL_143;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
      v63 = "%{public}s called with null http3";
    }
    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v61 = __nwlog_obj();
      v62 = v101[0];
      v65 = os_log_type_enabled(v61, v101[0]);
      if (backtrace_string)
      {
        if (v65)
        {
          LODWORD(buf[0]) = 136446466;
          *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
          WORD2(buf[1]) = 2082;
          *(_QWORD *)((char *)&buf[1] + 6) = backtrace_string;
          _os_log_impl(&dword_182FBE000, v61, v62, "%{public}s called with null http3, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_143;
      }
      if (!v65)
      {
LABEL_143:
        if (v60)
          free(v60);
        return;
      }
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
      v63 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      v61 = __nwlog_obj();
      v62 = v101[0];
      if (!os_log_type_enabled(v61, v101[0]))
        goto LABEL_143;
      LODWORD(buf[0]) = 136446210;
      *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
      v63 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v61, v62, v63, (uint8_t *)buf, 0xCu);
    goto LABEL_143;
  }
  v3 = a1 + 168;
  v4 = (unsigned __int16 *)(a1 + 1373);
  while (2)
  {
    *(_QWORD *)v101 = 0;
    v102 = v101;
    v103 = 0x3802000000;
    v104 = __Block_byref_object_copy__60023;
    v105 = __Block_byref_object_dispose__60024;
    v106[0] = 0;
    v106[1] = v106;
    switch(*(_DWORD *)(a1 + 1272))
    {
      case 0:
        if (!nw_http3_framer_get_output_frames_for_single_http3_frame(v3, 4uLL, 0x3Fu, v106))
          goto LABEL_131;
        memset((char *)&buf[4] + 6, 0, 25);
        memset((char *)buf + 6, 0, 32);
        LOBYTE(buf[0]) = 1;
        *(_WORD *)((char *)buf + 1) = -129;
        BYTE3(buf[0]) = 7;
        WORD2(buf[0]) = 25664;
        if ((*v4 & 2) != 0)
        {
          v21 = 30274;
          if ((*v4 & 4) != 0)
          {
            v22 = 2;
          }
          else
          {
            v21 = 51;
            v22 = 1;
          }
          __src = v21;
          memcpy((char *)buf + 6, &__src, v22);
          *((_BYTE *)buf + v22 + 6) = 1;
          v5 = v22 + 7;
        }
        else
        {
          v5 = 6;
        }
        v23 = arc4random();
        if (v23)
        {
          if (v23 > 0x20F)
          {
            if (v23 > 0x210841F)
            {
              __src = bswap64((31 * v23 + 33) | 0xC000000000000000);
              v24 = 8;
            }
            else
            {
              __src = bswap32((31 * v23 + 33) | 0x80000000);
              v24 = 4;
            }
          }
          else
          {
            __src = bswap32((31 * v23 + 33) | 0x4000) >> 16;
            v24 = 2;
          }
        }
        else
        {
          __src = 33;
          v24 = 1;
        }
        memcpy((char *)buf + v5, &__src, v24);
        v25 = arc4random();
        if (v25 > 0x3F)
        {
          if (v25 >> 14)
          {
            if (v25 >> 30)
            {
              __src = bswap64(v25 | 0xC000000000000000);
              v26 = 8;
            }
            else
            {
              __src = bswap32(v25 | 0x80000000);
              v26 = 4;
            }
          }
          else
          {
            __src = bswap32(v25 | 0x4000) >> 16;
            v26 = 2;
          }
        }
        else
        {
          __src = v25;
          v26 = 1;
        }
        v27 = v24 + v5;
        memcpy((char *)buf + v27, &__src, v26);
        v28 = v26 + v27;
        *(_QWORD *)type = 0;
        v97 = type;
        v98 = 0x2000000000;
        v99 = 0;
        v89[0] = MEMORY[0x1E0C809B0];
        v89[1] = 0x40000000;
        v90 = (uint64_t (*)(_QWORD *))___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_30;
        v91 = &unk_1E14A7B80;
        v92 = type;
        v93 = v28;
        v94 = buf;
        v95 = a1;
        v29 = *((_QWORD *)v102 + 5);
        do
        {
          if (!v29)
            break;
          v30 = *(_QWORD *)(v29 + 32);
          v31 = v90(v89);
          v29 = v30;
        }
        while ((v31 & 1) != 0);
        v88[0] = MEMORY[0x1E0C809B0];
        v88[1] = 0x40000000;
        v88[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2;
        v88[3] = &unk_1E14A7C50;
        v88[5] = a1;
        v88[6] = v28;
        v88[4] = v101;
        _Block_object_dispose(type, 8);
        v14 = v88;
        goto LABEL_64;
      case 1:
        v6 = *(_QWORD *)(a1 + 984);
        if (v6 >= 0x40)
        {
          if (v6 >= 0x4000)
          {
            if (v6 >> 30)
            {
              if (v6 >> 62)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
                LODWORD(buf[0]) = 136446466;
                *(_QWORD *)((char *)buf + 4) = "_http_vle_encode";
                WORD2(buf[1]) = 2048;
                *(_QWORD *)((char *)&buf[1] + 6) = v6;
                v32 = (void *)_os_log_send_and_compose_impl();
                if (__nwlog_abort((uint64_t)v32))
                {
                  __break(1u);
                  return;
                }
                free(v32);
                v7 = 0;
                v8 = (_DWORD **)(v102 + 40);
              }
              else
              {
                v7 = 8;
                v8 = v106;
              }
            }
            else
            {
              v7 = 4;
              v8 = v106;
            }
          }
          else
          {
            v7 = 2;
            v8 = v106;
          }
        }
        else
        {
          v7 = 1;
          v8 = v106;
        }
        if (!nw_http3_framer_get_output_frames_for_single_http3_frame(v3, 7uLL, v7, v8))
          goto LABEL_131;
        buf[0] = 0;
        buf[1] = buf;
        buf[2] = 0x2000000000;
        buf[3] = 0;
        v82[0] = MEMORY[0x1E0C809B0];
        v82[1] = 0x40000000;
        v83 = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_46;
        v84 = &unk_1E14A7C78;
        v87 = v7;
        v85 = buf;
        v86 = a1;
        v33 = *((_QWORD *)v102 + 5);
        do
        {
          if (!v33)
            break;
          v34 = *(_QWORD *)(v33 + 32);
          v35 = ((uint64_t (*)(_QWORD *))v83)(v82);
          v33 = v34;
        }
        while ((v35 & 1) != 0);
        v80[0] = MEMORY[0x1E0C809B0];
        v80[1] = 0x40000000;
        v80[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_48;
        v80[3] = &unk_1E14A7CA0;
        v81 = v7;
        v80[4] = v101;
        v80[5] = a1;
        _Block_object_dispose(buf, 8);
        v14 = v80;
        goto LABEL_64;
      case 2:
        v9 = *(NSObject **)(a1 + 1192);
        if (v9)
        {
          size = dispatch_data_get_size(v9);
          if (!nw_http3_framer_get_output_frames_for_single_http3_frame(v3, 0xFF8E1EB5uLL, size, v106))
            goto LABEL_131;
          buf[0] = 0;
          buf[1] = buf;
          buf[2] = 0x2000000000;
          buf[3] = 0;
          v74[0] = MEMORY[0x1E0C809B0];
          v74[1] = 0x40000000;
          v75 = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_50;
          v76 = &unk_1E14A7CC8;
          v79 = size;
          v77 = buf;
          v78 = a1;
          v11 = *((_QWORD *)v102 + 5);
          do
          {
            if (!v11)
              break;
            v12 = *(_QWORD *)(v11 + 32);
            v13 = ((uint64_t (*)(_QWORD *))v75)(v74);
            v11 = v12;
          }
          while ((v13 & 1) != 0);
          v72[0] = MEMORY[0x1E0C809B0];
          v72[1] = 0x40000000;
          v72[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_52;
          v72[3] = &unk_1E14A7CF0;
          v73 = size;
          v72[4] = v101;
          v72[5] = a1;
          _Block_object_dispose(buf, 8);
          v14 = v72;
LABEL_64:
          v36 = *v4 | (*((unsigned __int8 *)v4 + 2) << 16);
          if ((v36 & 0x40000) != 0)
          {
            *(_DWORD *)(a1 + 1272) = 2;
            v37 = v36 & 0xFFFBFFFF;
          }
          else
          {
            if ((v36 & 0x20000) == 0)
            {
              *(_DWORD *)(a1 + 1272) = 3;
              goto LABEL_4;
            }
            *(_DWORD *)(a1 + 1272) = 1;
            v37 = v36 & 0xFFFDFFFF;
          }
          *v4 = v37;
          *((_BYTE *)v4 + 2) = BYTE2(v37);
LABEL_4:
          ((void (*)(_QWORD *, uint64_t))v14[2])(v14, a2);
          _Block_object_dispose(v101, 8);
          continue;
        }
        __nwlog_obj();
        LODWORD(buf[0]) = 136446210;
        *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
        v54 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(__src) = 0;
        if (!__nwlog_fault(v54, type, &__src))
          goto LABEL_129;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          v55 = __nwlog_obj();
          v56 = type[0];
          if (os_log_type_enabled(v55, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
            v57 = "%{public}s called with null http3->authenticator_data";
            goto LABEL_128;
          }
          goto LABEL_129;
        }
        if (!(_BYTE)__src)
        {
          v55 = __nwlog_obj();
          v56 = type[0];
          if (!os_log_type_enabled(v55, type[0]))
            goto LABEL_129;
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
          v57 = "%{public}s called with null http3->authenticator_data, backtrace limit exceeded";
          goto LABEL_128;
        }
        v58 = (char *)__nw_create_backtrace_string();
        v55 = __nwlog_obj();
        v56 = type[0];
        v59 = os_log_type_enabled(v55, type[0]);
        if (v58)
        {
          if (v59)
          {
            LODWORD(buf[0]) = 136446466;
            *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v58;
            _os_log_impl(&dword_182FBE000, v55, v56, "%{public}s called with null http3->authenticator_data, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
          }
          free(v58);
          goto LABEL_129;
        }
        if (v59)
        {
          LODWORD(buf[0]) = 136446210;
          *(_QWORD *)((char *)buf + 4) = "nw_http3_control_stream_process_output";
          v57 = "%{public}s called with null http3->authenticator_data, no backtrace";
LABEL_128:
          _os_log_impl(&dword_182FBE000, v55, v56, v57, (uint8_t *)buf, 0xCu);
        }
LABEL_129:
        if (v54)
          free(v54);
LABEL_131:
        _Block_object_dispose(v101, 8);
        return;
      case 3:
        v15 = *(_QWORD *)(a1 + 912);
        if (!v15)
          goto LABEL_131;
        v16 = *(unsigned __int16 *)(v15 + 736);
        if ((v16 & 0x400) == 0 || *(_QWORD *)(v15 + 528) || *(_BYTE *)(v15 + 634) || *(_BYTE *)(v15 + 635))
          goto LABEL_26;
        v17 = v16 & 0xFFFFFBFF | (*(unsigned __int8 *)(v15 + 738) << 16);
        *(_WORD *)(v15 + 736) = v16 & 0xFBFF;
        *(_BYTE *)(v15 + 738) = BYTE2(v17);
        v18 = *(_QWORD *)(v15 + 32);
        if (v18)
        {
          v19 = *(_QWORD *)(v18 + 24);
          if (v19)
          {
            v20 = *(void (**)(uint64_t, uint64_t))(v19 + 32);
            if (v20)
            {
              v20(v18, v15);
              goto LABEL_26;
            }
          }
        }
        __nwlog_obj();
        v38 = *(_QWORD *)(v15 + 32);
        if (v38)
        {
          v39 = *(const char **)(v38 + 16);
          if (!v39)
            v39 = "invalid";
        }
        else
        {
          v39 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "nw_http3_stream_control_stream_output_available";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v39;
        v40 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(__src) = 0;
        if (!__nwlog_fault(v40, type, &__src))
          goto LABEL_106;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          log = __nwlog_obj();
          v66 = type[0];
          if (os_log_type_enabled(log, type[0]))
          {
            v41 = *(_QWORD *)(v15 + 32);
            if (v41)
            {
              v42 = *(const char **)(v41 + 16);
              if (!v42)
                v42 = "invalid";
            }
            else
            {
              v42 = "invalid";
            }
            LODWORD(buf[0]) = 136446466;
            *(_QWORD *)((char *)buf + 4) = "nw_http3_stream_control_stream_output_available";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v42;
            v51 = log;
            v52 = v66;
            v53 = "%{public}s protocol %{public}s has invalid disconnect callback";
            goto LABEL_105;
          }
          goto LABEL_106;
        }
        if (!(_BYTE)__src)
        {
          logb = __nwlog_obj();
          v68 = type[0];
          if (os_log_type_enabled(logb, type[0]))
          {
            v47 = *(_QWORD *)(v15 + 32);
            if (v47)
            {
              v48 = *(const char **)(v47 + 16);
              if (!v48)
                v48 = "invalid";
            }
            else
            {
              v48 = "invalid";
            }
            LODWORD(buf[0]) = 136446466;
            *(_QWORD *)((char *)buf + 4) = "nw_http3_stream_control_stream_output_available";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v48;
            v51 = logb;
            v52 = v68;
            v53 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
LABEL_105:
            _os_log_impl(&dword_182FBE000, v51, v52, v53, (uint8_t *)buf, 0x16u);
          }
LABEL_106:
          if (!v40)
            goto LABEL_26;
LABEL_107:
          free(v40);
          goto LABEL_26;
        }
        v43 = (char *)__nw_create_backtrace_string();
        loga = __nwlog_obj();
        v67 = type[0];
        v44 = os_log_type_enabled(loga, type[0]);
        if (v43)
        {
          if (v44)
          {
            v45 = *(_QWORD *)(v15 + 32);
            if (v45)
            {
              v46 = *(const char **)(v45 + 16);
              if (!v46)
                v46 = "invalid";
            }
            else
            {
              v46 = "invalid";
            }
            LODWORD(buf[0]) = 136446722;
            *(_QWORD *)((char *)buf + 4) = "nw_http3_stream_control_stream_output_available";
            WORD2(buf[1]) = 2082;
            *(_QWORD *)((char *)&buf[1] + 6) = v46;
            HIWORD(buf[2]) = 2082;
            buf[3] = v43;
            _os_log_impl(&dword_182FBE000, loga, v67, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x20u);
          }
          free(v43);
          goto LABEL_106;
        }
        if (!v44)
          goto LABEL_106;
        v49 = *(_QWORD *)(v15 + 32);
        if (v49)
        {
          v50 = *(const char **)(v49 + 16);
          if (!v50)
            v50 = "invalid";
        }
        else
        {
          v50 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "nw_http3_stream_control_stream_output_available";
        WORD2(buf[1]) = 2082;
        *(_QWORD *)((char *)&buf[1] + 6) = v50;
        _os_log_impl(&dword_182FBE000, loga, v67, "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace", (uint8_t *)buf, 0x16u);
        if (v40)
          goto LABEL_107;
LABEL_26:
        v14 = &__block_literal_global_29_60022;
        if (v15 == *(_QWORD *)(a1 + 912))
          goto LABEL_131;
        goto LABEL_64;
      default:
        v14 = &__block_literal_global_29_60022;
        goto LABEL_64;
    }
  }
}

__n128 __Block_byref_object_copy__60023(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t nw_http3_framer_get_output_frames_for_single_http3_frame(uint64_t a1, unint64_t a2, unsigned int a3, _DWORD **a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _DWORD **);
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  char *v20;
  _BOOL4 v21;
  uint64_t v22;
  NSObject *v24;
  char *v25;
  NSObject *v26;
  os_log_type_t v27;
  const char *v28;
  char *backtrace_string;
  _BOOL4 v30;
  char v31;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
    v25 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v31 = 0;
    if (!__nwlog_fault(v25, &type, &v31))
      goto LABEL_60;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
      v28 = "%{public}s called with null http3_framer";
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v26 = __nwlog_obj();
      v27 = type;
      v30 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
          v35 = 2082;
          v36 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v26, v27, "%{public}s called with null http3_framer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_60;
      }
      if (!v30)
      {
LABEL_60:
        if (v25)
          free(v25);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
      v28 = "%{public}s called with null http3_framer, no backtrace";
    }
    else
    {
      v26 = __nwlog_obj();
      v27 = type;
      if (!os_log_type_enabled(v26, type))
        goto LABEL_60;
      *(_DWORD *)buf = 136446210;
      v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
      v28 = "%{public}s called with null http3_framer, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v26, v27, v28, buf, 0xCu);
    goto LABEL_60;
  }
  v5 = *(_QWORD *)(a1 + 32);
  if (!v5
    || (v6 = *(_QWORD *)(v5 + 24)) == 0
    || (v7 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _DWORD **))(v6 + 88)) == 0)
  {
    v24 = __nwlog_obj();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
      v35 = 2048;
      v36 = (const char *)v5;
      _os_log_impl(&dword_182FBE000, v24, OS_LOG_TYPE_ERROR, "%{public}s Output handler (%p)'s get_output_frames callback is not properly set", buf, 0x16u);
    }
    return 0;
  }
  if (a2 >> 30)
    v9 = 8;
  else
    v9 = 4;
  if (a2 >= 0x4000)
    v10 = v9;
  else
    v10 = 2;
  if (a2 >= 0x40)
    v11 = v10;
  else
    v11 = 1;
  if (a3 >> 30)
    v12 = 8;
  else
    v12 = 4;
  if (a3 < 0x4000)
    v12 = 2;
  if (a3 >= 0x40)
    v13 = v12;
  else
    v13 = 1;
  v14 = (v13 + v11);
  v15 = a3 + v14;
  if (!__CFADD__(a3, (_DWORD)v14))
    goto LABEL_41;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446978;
  v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
  v35 = 2082;
  v36 = "bytes";
  v37 = 2048;
  v38 = v14;
  v39 = 2048;
  v40 = v15;
  v16 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v31 = 0;
  if (__nwlog_fault(v16, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446978;
        v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
        v35 = 2082;
        v36 = "bytes";
        v37 = 2048;
        v38 = v14;
        v39 = 2048;
        v40 = v15;
        v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_37:
        _os_log_impl(&dword_182FBE000, v17, v18, v19, buf, 0x2Au);
      }
    }
    else if (v31)
    {
      v20 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v20)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136447234;
          v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
          v35 = 2082;
          v36 = "bytes";
          v37 = 2048;
          v38 = v14;
          v39 = 2048;
          v40 = v15;
          v41 = 2082;
          v42 = v20;
          _os_log_impl(&dword_182FBE000, v17, v18, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v20);
        goto LABEL_38;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446978;
        v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
        v35 = 2082;
        v36 = "bytes";
        v37 = 2048;
        v38 = v14;
        v39 = 2048;
        v40 = v15;
        v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
        goto LABEL_37;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v17 = gLogObj;
      v18 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446978;
        v34 = "nw_http3_framer_get_output_frames_for_single_http3_frame";
        v35 = 2082;
        v36 = "bytes";
        v37 = 2048;
        v38 = v14;
        v39 = 2048;
        v40 = v15;
        v19 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
        goto LABEL_37;
      }
    }
  }
LABEL_38:
  if (v16)
    free(v16);
  v7 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, _DWORD **))(*(_QWORD *)(v5 + 24) + 88);
  v15 = 0xFFFFFFFFLL;
LABEL_41:
  v22 = v7(v5, *(_QWORD *)(a1 + 24), v15, v15, 0xFFFFFFFFLL, a4);
  if ((_DWORD)v22)
    nw_http3_framer_claim_http3_frame_header(v14, *a4);
  return v22;
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_30(_QWORD *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  unint64_t v6;
  const void *v7;
  uint64_t v8;
  size_t __n;

  LODWORD(__n) = 0;
  v4 = (void *)nw_frame_unclaimed_bytes(a2, &__n);
  v5 = *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
  v6 = a1[5] - v5;
  v7 = (const void *)(a1[6] + v5);
  if (v6 >= __n)
  {
    memcpy(v4, v7, __n);
  }
  else
  {
    memcpy(v4, v7, a1[5] - v5);
    nw_frame_claim(a2, v8, 0, __n - v6);
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += __n;
  return 1;
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t);
  uint64_t v18;
  const char *v19;
  char *v20;
  uint64_t v21;
  const char *v22;
  const char *backtrace_string;
  _BOOL4 v24;
  char *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  char *v38;
  os_log_type_t v39;
  os_log_type_t log;
  NSObject *loga;
  os_log_type_t logb;
  NSObject *v43;
  char *v44;
  NSObject *v45;
  char v46;
  os_log_type_t type;
  _QWORD v48[5];
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(v2 + 200);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 24);
    if (v4)
    {
      if (*(_QWORD *)(v4 + 96))
      {
        v5 = *(_DWORD *)(a1 + 48);
        v6 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
        if (v5 >> 30)
          v7 = 9;
        else
          v7 = 5;
        if (v5 >= 0x4000)
          v8 = v7;
        else
          v8 = 3;
        if (v5 >= 0x40)
          v9 = v8;
        else
          v9 = 2;
        nw_http3_framer_write_http3_frame_header(v2 + 168, 4uLL, v5, v9, *v6);
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)(v3 + 24) + 96))(v3, v6);
        v2 = *(_QWORD *)(a1 + 40);
      }
    }
  }
  v10 = *(_QWORD *)(v2 + 880);
  if (v10)
  {
    v11 = 0;
    v12 = MEMORY[0x1E0C809B0];
    while (1)
    {
      v13 = v10;
      v10 = *(_QWORD *)(v10 + 544);
      if ((*(_WORD *)(v13 + 736) & 0x80) == 0)
        goto LABEL_18;
      if ((*(_WORD *)(v13 + 736) & 0x800) == 0)
      {
        if (gLogDatapath)
        {
          v28 = __nwlog_obj();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            v29 = *(_DWORD *)(*(_QWORD *)(v13 + 336) + 1280);
            v30 = *(_QWORD *)(v13 + 240);
            *(_DWORD *)buf = 136447490;
            v50 = "nw_http3_control_stream_process_output_block_invoke_2";
            v51 = 2082;
            v52 = (const char *)(v13 + 636);
            v53 = 2080;
            v54 = " ";
            v55 = 1024;
            v56 = v29;
            v57 = 2048;
            v58 = v30;
            v59 = 2048;
            v60 = v30;
            _os_log_impl(&dword_182FBE000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Marking stream %llu connected after sending SETTINGS", buf, 0x3Au);
          }
        }
      }
      *(_BYTE *)(v13 + 738) |= 8u;
      v14 = *(void **)(v13 + 392);
      v48[0] = v12;
      v48[1] = 0x40000000;
      v48[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_32;
      v48[3] = &__block_descriptor_tmp_44_60065;
      v48[4] = v13;
      nw_http_transaction_metadata_set_event_handler(v14, v48);
      *(_WORD *)(v13 + 736) |= 0x40u;
      nw_http3_signal_output_pending(*(_QWORD *)(a1 + 40), 1);
      v15 = *(_QWORD *)(v13 + 48);
      if (!v15)
        break;
      v16 = *(_QWORD *)(v15 + 24);
      if (!v16)
        break;
      v17 = *(void (**)(uint64_t, uint64_t))(v16 + 40);
      if (!v17)
        break;
      v17(v15, v13);
LABEL_17:
      v11 = 1;
LABEL_18:
      if (!v10)
      {
        if ((v11 & 1) != 0)
          nw_http3_signal_output_pending(*(_QWORD *)(a1 + 40), 0);
        return;
      }
    }
    __nwlog_obj();
    v18 = *(_QWORD *)(v13 + 48);
    if (v18)
    {
      v19 = *(const char **)(v18 + 16);
      if (!v19)
        v19 = "invalid";
    }
    else
    {
      v19 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    v50 = "nw_http3_control_stream_process_output_block_invoke_2";
    v51 = 2082;
    v52 = v19;
    v20 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v46 = 0;
    if (__nwlog_fault(v20, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v43 = __nwlog_obj();
        log = type;
        if (!os_log_type_enabled(v43, type))
          goto LABEL_66;
        v21 = *(_QWORD *)(v13 + 48);
        if (v21)
        {
          v22 = *(const char **)(v21 + 16);
          if (!v22)
            v22 = "invalid";
        }
        else
        {
          v22 = "invalid";
        }
        v35 = v43;
        v36 = log;
        *(_DWORD *)buf = 136446466;
        v50 = "nw_http3_control_stream_process_output_block_invoke";
        v51 = 2082;
        v52 = v22;
        v37 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_65;
      }
      if (!v46)
      {
        v45 = __nwlog_obj();
        logb = type;
        if (!os_log_type_enabled(v45, type))
          goto LABEL_66;
        v31 = *(_QWORD *)(v13 + 48);
        if (v31)
        {
          v32 = *(const char **)(v31 + 16);
          if (!v32)
            v32 = "invalid";
        }
        else
        {
          v32 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        v50 = "nw_http3_control_stream_process_output_block_invoke";
        v51 = 2082;
        v52 = v32;
        v35 = v45;
        v36 = logb;
        v37 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_65;
      }
      v44 = v20;
      backtrace_string = __nw_create_backtrace_string();
      loga = __nwlog_obj();
      v39 = type;
      v24 = os_log_type_enabled(loga, type);
      if (backtrace_string)
      {
        v25 = (char *)backtrace_string;
        v20 = v44;
        if (v24)
        {
          v26 = *(_QWORD *)(v13 + 48);
          if (v26)
          {
            v27 = *(const char **)(v26 + 16);
            if (!v27)
              v27 = "invalid";
          }
          else
          {
            v27 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v50 = "nw_http3_control_stream_process_output_block_invoke";
          v51 = 2082;
          v52 = v27;
          v53 = 2082;
          v54 = v25;
          v38 = v25;
          _os_log_impl(&dword_182FBE000, loga, v39, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
          v25 = v38;
          v20 = v44;
        }
        free(v25);
        goto LABEL_66;
      }
      v20 = v44;
      if (v24)
      {
        v33 = *(_QWORD *)(v13 + 48);
        if (v33)
        {
          v34 = *(const char **)(v33 + 16);
          if (!v34)
            v34 = "invalid";
        }
        else
        {
          v34 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        v50 = "nw_http3_control_stream_process_output_block_invoke";
        v51 = 2082;
        v52 = v34;
        v35 = loga;
        v36 = v39;
        v37 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_65:
        _os_log_impl(&dword_182FBE000, v35, v36, v37, buf, 0x16u);
      }
    }
LABEL_66:
    if (v20)
      free(v20);
    goto LABEL_17;
  }
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_46(uint64_t a1, uint64_t a2)
{
  void *v4;
  const void *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  size_t __n;

  LODWORD(__n) = 0;
  v4 = (void *)nw_frame_unclaimed_bytes(a2, &__n);
  v5 = (const void *)(a1 + 48);
  v6 = *(unsigned __int8 *)(a1 + 48);
  v7 = v6 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v7 >= __n)
  {
    memcpy(v4, v5, __n);
  }
  else
  {
    memcpy(v4, v5, v6 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    nw_frame_claim(a2, v8, 0, __n - v7);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += __n;
  return 1;
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_48(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  unsigned int v7;

  v1 = *(_QWORD *)(result + 40);
  v2 = *(_QWORD *)(v1 + 200);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 24);
    if (v3)
    {
      if (*(_QWORD *)(v3 + 96))
      {
        v4 = v1 + 168;
        v5 = *(unsigned __int8 *)(result + 48);
        v6 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 40);
        if (v5 < 0x40)
          v7 = 2;
        else
          v7 = 3;
        nw_http3_framer_write_http3_frame_header(v4, 7uLL, v5, v7, *v6);
        return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)(v2 + 24) + 96))(v2, v6);
      }
    }
  }
  return result;
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_50(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  NSObject *v6;
  uint64_t v7;
  unsigned int v9;
  uint64_t applier;
  uint64_t v11;
  BOOL (*v12)(_QWORD *, int, int, void *, size_t);
  void *v13;
  uint64_t *v14;
  uint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v9 = 0;
  v4 = nw_frame_unclaimed_bytes(a2, &v9);
  v5 = *(unsigned int *)(a1 + 48) - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v6 = *(NSObject **)(*(_QWORD *)(a1 + 40) + 1192);
  if (v5 >= v9)
  {
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = 0;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = v4;
    if (v6)
    {
      applier = MEMORY[0x1E0C809B0];
      v11 = 0x40000000;
      v12 = __nw_dispatch_data_copyout_block_invoke;
      v13 = &unk_1E14A3448;
      v15 = &v17;
      v16 = v9;
      v14 = &v21;
      dispatch_data_apply(v6, &applier);
    }
    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v21, 8);
  }
  else
  {
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = 0;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = v4;
    if (v6)
    {
      applier = MEMORY[0x1E0C809B0];
      v11 = 0x40000000;
      v12 = __nw_dispatch_data_copyout_block_invoke;
      v13 = &unk_1E14A3448;
      v15 = &v17;
      v16 = v5;
      v14 = &v21;
      dispatch_data_apply(v6, &applier);
    }
    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v21, 8);
    nw_frame_claim(a2, v7, 0, v9 - v5);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v9;
  return 1;
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_52(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  int v7;
  int v8;
  unsigned int v9;
  void *v10;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(v2 + 200);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 24);
    if (v4)
    {
      if (*(_QWORD *)(v4 + 96))
      {
        v5 = *(_DWORD *)(a1 + 48);
        v6 = (uint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
        if (v5 >> 30)
          v7 = 16;
        else
          v7 = 12;
        if (v5 >= 0x4000)
          v8 = v7;
        else
          v8 = 10;
        if (v5 >= 0x40)
          v9 = v8;
        else
          v9 = 9;
        nw_http3_framer_write_http3_frame_header(v2 + 168, 0xFF8E1EB5uLL, v5, v9, *v6);
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)(v3 + 24) + 96))(v3, v6);
        v2 = *(_QWORD *)(a1 + 40);
      }
    }
  }
  v10 = *(void **)(v2 + 1192);
  if (v10)
  {
    os_release(v10);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1192) = 0;
  }
}

BOOL nw_http3_framer_write_http3_frame_header(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *subrange;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  unsigned int v16;
  char *v17;
  NSObject *v18;
  os_log_type_t v19;
  const char *v20;
  char *backtrace_string;
  _BOOL4 v22;
  const char *v23;
  char *v24;
  _BOOL4 v25;
  uint64_t v26;
  NSObject *v27;
  void *v28;
  _BOOL8 result;
  unsigned int v30;
  NSObject *alloc;
  NSObject *concat;
  uint64_t v33;
  char *v34;
  NSObject *v35;
  os_log_type_t v36;
  const char *v37;
  char *v38;
  _BOOL4 v39;
  NSObject *v40;
  void *v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  int v45;
  int v46;
  _BOOL4 v47;
  char v48;
  os_log_type_t v49;
  unsigned int v50;
  uint64_t v51;
  unint64_t __src;
  os_log_type_t type[8];
  size_t offset;
  uint8_t buf[4];
  const char *v56;
  __int16 v57;
  _BYTE v58[10];
  __int16 v59;
  char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v56 = "nw_http3_framer_write_http3_frame_header";
    v17 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__src) = 0;
    if (!__nwlog_fault(v17, type, &__src))
      goto LABEL_54;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type[0];
      if (!os_log_type_enabled(v18, type[0]))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      v20 = "%{public}s called with null http3_framer";
    }
    else if ((_BYTE)__src)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v18 = __nwlog_obj();
      v19 = type[0];
      v47 = os_log_type_enabled(v18, type[0]);
      if (backtrace_string)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          v56 = "nw_http3_framer_write_http3_frame_header";
          v57 = 2082;
          *(_QWORD *)v58 = backtrace_string;
          v23 = "%{public}s called with null http3_framer, dumping backtrace:%{public}s";
          goto LABEL_29;
        }
LABEL_30:
        free(backtrace_string);
        if (!v17)
          return 0;
        goto LABEL_55;
      }
      if (!v47)
      {
LABEL_54:
        if (!v17)
          return 0;
LABEL_55:
        free(v17);
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      v20 = "%{public}s called with null http3_framer, no backtrace";
    }
    else
    {
      v18 = __nwlog_obj();
      v19 = type[0];
      if (!os_log_type_enabled(v18, type[0]))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      v20 = "%{public}s called with null http3_framer, backtrace limit exceeded";
    }
LABEL_53:
    _os_log_impl(&dword_182FBE000, v18, v19, v20, buf, 0xCu);
    goto LABEL_54;
  }
  if (!nw_frame_uses_external_data(a5))
  {
    nw_frame_unclaim(a5, v9, a4, 0);
    LODWORD(__src) = 0;
    v14 = nw_frame_unclaimed_bytes(a5, &__src);
    if (v14)
    {
      v15 = (char *)v14;
      *(_QWORD *)type = 0;
      if (a2 > 0x3F)
      {
        if (a2 >> 14)
        {
          if (a2 >> 30)
          {
            if (a2 >> 62)
            {
              v40 = __nwlog_obj();
              os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
              *(_DWORD *)buf = 136446466;
              v56 = "_http_vle_encode";
              v57 = 2048;
              *(_QWORD *)v58 = a2;
              v41 = (void *)_os_log_send_and_compose_impl();
              result = __nwlog_abort((uint64_t)v41);
              if (result)
                goto LABEL_114;
              free(v41);
              v16 = 0;
            }
            else
            {
              *(_QWORD *)type = bswap64(a2 | 0xC000000000000000);
              v16 = 8;
            }
          }
          else
          {
            *(_QWORD *)type = bswap32(a2 | 0x80000000);
            v16 = 4;
          }
        }
        else
        {
          *(_QWORD *)type = bswap32(a2 | 0x4000) >> 16;
          v16 = 2;
        }
      }
      else
      {
        *(_QWORD *)type = a2;
        v16 = 1;
      }
      v42 = v16;
      memcpy(v15, type, v16);
      if (a3 > 0x3F)
      {
        if (a3 >> 14)
        {
          if (a3 >> 30)
          {
            *(_QWORD *)type = bswap64(a3 | 0xC000000000000000);
            v43 = 8;
          }
          else
          {
            *(_QWORD *)type = bswap32(a3 | 0x80000000);
            v43 = 4;
          }
        }
        else
        {
          *(_QWORD *)type = bswap32(a3 | 0x4000) >> 16;
          v43 = 2;
        }
      }
      else
      {
        *(_QWORD *)type = a3;
        v43 = 1;
      }
      memcpy(&v15[v42], type, v43);
      v26 = v43 + v42;
      if (a4 <= v26)
        return v26;
      memmove(&v15[v26], &v15[a4], __src - a4);
      v44 = a5;
      v45 = 0;
      v46 = a4 - v26;
      goto LABEL_100;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v56 = "nw_http3_framer_write_http3_frame_header";
    v17 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v51) = 0;
    if (__nwlog_fault(v17, type, &v51))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v56 = "nw_http3_framer_write_http3_frame_header";
        v20 = "%{public}s Unable to fillout H3 frame header because nw_frame_unclaimed_bytes() returned NULL";
        goto LABEL_53;
      }
      if (!(_BYTE)v51)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        v19 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v56 = "nw_http3_framer_write_http3_frame_header";
        v20 = "%{public}s Unable to fillout H3 frame header because nw_frame_unclaimed_bytes() returned NULL, backtrace limit exceeded";
        goto LABEL_53;
      }
      v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v19 = type[0];
      v25 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!v24)
      {
        if (!v25)
          goto LABEL_54;
        *(_DWORD *)buf = 136446210;
        v56 = "nw_http3_framer_write_http3_frame_header";
        v20 = "%{public}s Unable to fillout H3 frame header because nw_frame_unclaimed_bytes() returned NULL, no backtrace";
        goto LABEL_53;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        v56 = "nw_http3_framer_write_http3_frame_header";
        v57 = 2082;
        *(_QWORD *)v58 = v24;
        _os_log_impl(&dword_182FBE000, v18, v19, "%{public}s Unable to fillout H3 frame header because nw_frame_unclaimed_bytes() returned NULL, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v24);
    }
    goto LABEL_54;
  }
  nw_frame_unclaim(a5, v9, 0, a4);
  offset = 0;
  v10 = nw_frame_copy_external_data(a5, (_DWORD *)&offset + 1, &offset);
  v11 = v10;
  if (HIDWORD(offset))
  {
    subrange = dispatch_data_create_subrange(v10, HIDWORD(offset), 0xFFFFFFFFFFFFFFFFLL);
    if (v11)
      dispatch_release(v11);
    if (subrange)
      goto LABEL_7;
LABEL_13:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v56 = "nw_http3_framer_write_http3_frame_header";
    v17 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__src) = 0;
    if (!__nwlog_fault(v17, type, &__src))
      goto LABEL_54;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v19 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      v20 = "%{public}s Unable to fillout H3 frame header because nw_frame_copy_external_data() returned NULL";
      goto LABEL_53;
    }
    if (!(_BYTE)__src)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v18 = gLogObj;
      v19 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0]))
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      v20 = "%{public}s Unable to fillout H3 frame header because nw_frame_copy_external_data() returned NULL, backtrace limit exceeded";
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v18 = gLogObj;
    v19 = type[0];
    v22 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (!backtrace_string)
    {
      if (!v22)
        goto LABEL_54;
      *(_DWORD *)buf = 136446210;
      v56 = "nw_http3_framer_write_http3_frame_header";
      v20 = "%{public}s Unable to fillout H3 frame header because nw_frame_copy_external_data() returned NULL, no backtrace";
      goto LABEL_53;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v56 = "nw_http3_framer_write_http3_frame_header";
      v57 = 2082;
      *(_QWORD *)v58 = backtrace_string;
      v23 = "%{public}s Unable to fillout H3 frame header because nw_frame_copy_external_data() returned NULL, dumping ba"
            "cktrace:%{public}s";
LABEL_29:
      _os_log_impl(&dword_182FBE000, v18, v19, v23, buf, 0x16u);
      goto LABEL_30;
    }
    goto LABEL_30;
  }
  subrange = v10;
  if (!v10)
    goto LABEL_13;
LABEL_7:
  *(_QWORD *)type = 0;
  if (a2 <= 0x3F)
  {
    *(_QWORD *)type = a2;
    v13 = 1;
    goto LABEL_59;
  }
  if (!(a2 >> 14))
  {
    *(_QWORD *)type = bswap32(a2 | 0x4000) >> 16;
    v13 = 2;
    goto LABEL_59;
  }
  if (!(a2 >> 30))
  {
    *(_QWORD *)type = bswap32(a2 | 0x80000000);
    v13 = 4;
    goto LABEL_59;
  }
  if (!(a2 >> 62))
  {
    *(_QWORD *)type = bswap64(a2 | 0xC000000000000000);
    v13 = 8;
    goto LABEL_59;
  }
  v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v56 = "_http_vle_encode";
  v57 = 2048;
  *(_QWORD *)v58 = a2;
  v28 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    v13 = 0;
LABEL_59:
    if (a3 > 0x3F)
    {
      if (a3 >> 14)
      {
        if (a3 >> 30)
        {
          __src = bswap64(a3 | 0xC000000000000000);
          v30 = 8;
        }
        else
        {
          __src = bswap32(a3 | 0x80000000);
          v30 = 4;
        }
      }
      else
      {
        __src = bswap32(a3 | 0x4000) >> 16;
        v30 = 2;
      }
    }
    else
    {
      __src = a3;
      v30 = 1;
    }
    v26 = v30 + v13;
    v51 = 0;
    alloc = dispatch_data_create_alloc();
    memcpy((void *)(a4 - v26), type, v13);
    memcpy((void *)(a4 - (unint64_t)v30), &__src, v30);
    concat = dispatch_data_create_concat(alloc, subrange);
    if (alloc)
      dispatch_release(alloc);
    dispatch_release(subrange);
    v50 = 0;
    nw_frame_set_external_data(a5, concat, &v50);
    if (concat)
      dispatch_release(concat);
    if (v50 == (_DWORD)offset)
    {
LABEL_98:
      v45 = a4 - v26;
      if (a4 > v26)
      {
        v44 = a5;
        v46 = 0;
LABEL_100:
        nw_frame_claim(v44, v33, v45, v46);
      }
      return v26;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v56 = "nw_http3_framer_write_http3_frame_header";
    v57 = 1024;
    *(_DWORD *)v58 = v50;
    *(_WORD *)&v58[4] = 1024;
    *(_DWORD *)&v58[6] = offset;
    v34 = (char *)_os_log_send_and_compose_impl();
    v49 = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (__nwlog_fault(v34, &v49, &v48))
    {
      if (v49 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = v49;
        if (!os_log_type_enabled((os_log_t)gLogObj, v49))
          goto LABEL_96;
        *(_DWORD *)buf = 136446722;
        v56 = "nw_http3_framer_write_http3_frame_header";
        v57 = 1024;
        *(_DWORD *)v58 = v50;
        *(_WORD *)&v58[4] = 1024;
        *(_DWORD *)&v58[6] = offset;
        v37 = "%{public}s Incorrect frame length set: %u != %u";
        goto LABEL_95;
      }
      if (!v48)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v35 = gLogObj;
        v36 = v49;
        if (!os_log_type_enabled((os_log_t)gLogObj, v49))
          goto LABEL_96;
        *(_DWORD *)buf = 136446722;
        v56 = "nw_http3_framer_write_http3_frame_header";
        v57 = 1024;
        *(_DWORD *)v58 = v50;
        *(_WORD *)&v58[4] = 1024;
        *(_DWORD *)&v58[6] = offset;
        v37 = "%{public}s Incorrect frame length set: %u != %u, backtrace limit exceeded";
        goto LABEL_95;
      }
      v38 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = gLogObj;
      v36 = v49;
      v39 = os_log_type_enabled((os_log_t)gLogObj, v49);
      if (v38)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446978;
          v56 = "nw_http3_framer_write_http3_frame_header";
          v57 = 1024;
          *(_DWORD *)v58 = v50;
          *(_WORD *)&v58[4] = 1024;
          *(_DWORD *)&v58[6] = offset;
          v59 = 2082;
          v60 = v38;
          _os_log_impl(&dword_182FBE000, v35, v36, "%{public}s Incorrect frame length set: %u != %u, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v38);
        goto LABEL_96;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446722;
        v56 = "nw_http3_framer_write_http3_frame_header";
        v57 = 1024;
        *(_DWORD *)v58 = v50;
        *(_WORD *)&v58[4] = 1024;
        *(_DWORD *)&v58[6] = offset;
        v37 = "%{public}s Incorrect frame length set: %u != %u, no backtrace";
LABEL_95:
        _os_log_impl(&dword_182FBE000, v35, v36, v37, buf, 0x18u);
      }
    }
LABEL_96:
    if (v34)
      free(v34);
    goto LABEL_98;
  }
LABEL_114:
  __break(1u);
  return result;
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_32(uint64_t a1, void *a2, int a3)
{
  id outbound_message;
  id v6;
  id v7;
  id v8;
  _QWORD *v9;
  id v10;
  int status_code;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  const char *v20;
  uint64_t outbound_body_size;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  BOOL v27;
  int v28;
  uint64_t v29;
  const char *v30;
  id v31;
  id v32;
  _QWORD *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  const char *v38;
  BOOL v39;
  int v40;
  uint64_t v41;
  void *v42;
  uint64_t inbound_body_size;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  const char *v47;
  BOOL v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  id v53;
  void *v54;
  id v55;
  id v56;
  id inbound_message;
  id v58;
  int v59;
  id v60;
  _QWORD *v61;
  _QWORD v62[5];
  __int16 v63;
  _QWORD v64[6];
  _QWORD v65[5];
  _QWORD v66[5];
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  uint64_t v76;
  __int16 v77;
  uint64_t v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  switch(a3)
  {
    case 0:
      outbound_message = nw_http_transaction_metadata_get_outbound_message(a2);
      v6 = nw_http_metadata_copy_request(outbound_message);
      v7 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v66[0] = MEMORY[0x1E0C809B0];
        v66[1] = 0x40000000;
        v66[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_33;
        v66[3] = &__block_descriptor_tmp_35_60079;
        v66[4] = *(_QWORD *)(a1 + 32);
        v8 = v6;
        v9 = v66;
        _nw_http_request_access_method((uint64_t)v8, v9);

      }
      if (!v7)
        goto LABEL_34;
      v10 = v7;
      status_code = _nw_http_response_get_status_code();

      v12 = *(_QWORD *)(a1 + 32);
      if (v12 && (*(_WORD *)(v12 + 736) & 0x800) != 0)
        goto LABEL_33;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        goto LABEL_33;
      v14 = *(_QWORD *)(a1 + 32);
      v15 = (const char *)(v14 + 636);
      v16 = "";
      v17 = v14 == 0;
      if (!v14)
        v15 = "";
      v18 = *(_DWORD *)(*(_QWORD *)(v14 + 336) + 1280);
      v19 = *(_QWORD *)(v14 + 240);
      if (!v17)
        v16 = " ";
      *(_DWORD *)buf = 136447490;
      v68 = "nw_http3_control_stream_process_output_block_invoke";
      v69 = 2082;
      v70 = v15;
      v71 = 2080;
      v72 = v16;
      v73 = 1024;
      v74 = v18;
      v75 = 2048;
      v76 = v19;
      v77 = 1024;
      LODWORD(v78) = status_code;
      v20 = "%{public}s %{public}s%s<i%u:s%llu> [http] sending response header {status=%hu}";
      goto LABEL_32;
    case 1:
      outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(a2);
      v22 = *(_QWORD *)(a1 + 32);
      if (v22 && (*(_WORD *)(v22 + 736) & 0x800) != 0)
        return;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        return;
      v24 = *(_QWORD *)(a1 + 32);
      v25 = (const char *)(v24 + 636);
      v26 = "";
      v27 = v24 == 0;
      if (!v24)
        v25 = "";
      v28 = *(_DWORD *)(*(_QWORD *)(v24 + 336) + 1280);
      v29 = *(_QWORD *)(v24 + 240);
      if (!v27)
        v26 = " ";
      *(_DWORD *)buf = 136447490;
      v68 = "nw_http3_control_stream_process_output_block_invoke";
      v69 = 2082;
      v70 = v25;
      v71 = 2080;
      v72 = v26;
      v73 = 1024;
      v74 = v28;
      v75 = 2048;
      v76 = v29;
      v77 = 2048;
      v78 = outbound_body_size;
      v30 = "%{public}s %{public}s%s<i%u:s%llu> [http] finished sending {body_bytes=%llu}";
      goto LABEL_46;
    case 2:
      outbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
      v6 = nw_http_metadata_copy_request(outbound_message);
      v31 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v65[0] = MEMORY[0x1E0C809B0];
        v65[1] = 0x40000000;
        v65[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_36;
        v65[3] = &__block_descriptor_tmp_37_60082;
        v65[4] = *(_QWORD *)(a1 + 32);
        v32 = v6;
        v33 = v65;
        _nw_http_request_access_method((uint64_t)v32, v33);

      }
      if (v31)
      {
        v10 = v31;
        v34 = _nw_http_response_get_status_code();

        v35 = *(_QWORD *)(a1 + 32);
        if (!v35 || (*(_WORD *)(v35 + 736) & 0x800) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v13 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            v36 = *(_QWORD *)(a1 + 32);
            v37 = (const char *)(v36 + 636);
            v38 = "";
            v39 = v36 == 0;
            if (!v36)
              v37 = "";
            v40 = *(_DWORD *)(*(_QWORD *)(v36 + 336) + 1280);
            v41 = *(_QWORD *)(v36 + 240);
            if (!v39)
              v38 = " ";
            *(_DWORD *)buf = 136447490;
            v68 = "nw_http3_control_stream_process_output_block_invoke";
            v69 = 2082;
            v70 = v37;
            v71 = 2080;
            v72 = v38;
            v73 = 1024;
            v74 = v40;
            v75 = 2048;
            v76 = v41;
            v77 = 1024;
            LODWORD(v78) = v34;
            v20 = "%{public}s %{public}s%s<i%u:s%llu> [http] receiving response header {status=%hu}";
LABEL_32:
            _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_INFO, v20, buf, 0x36u);
          }
        }
LABEL_33:
        os_release(v10);
      }
LABEL_34:
      if (v6)
        os_release(v6);
      if (!outbound_message)
        return;
      v42 = outbound_message;
      goto LABEL_68;
    case 3:
      inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      v44 = *(_QWORD *)(a1 + 32);
      if (v44 && (*(_WORD *)(v44 + 736) & 0x800) != 0)
        return;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v23 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        return;
      v45 = *(_QWORD *)(a1 + 32);
      v46 = (const char *)(v45 + 636);
      v47 = "";
      v48 = v45 == 0;
      if (!v45)
        v46 = "";
      v49 = *(_DWORD *)(*(_QWORD *)(v45 + 336) + 1280);
      v50 = *(_QWORD *)(v45 + 240);
      if (!v48)
        v47 = " ";
      *(_DWORD *)buf = 136447490;
      v68 = "nw_http3_control_stream_process_output_block_invoke";
      v69 = 2082;
      v70 = v46;
      v71 = 2080;
      v72 = v47;
      v73 = 1024;
      v74 = v49;
      v75 = 2048;
      v76 = v50;
      v77 = 2048;
      v78 = inbound_body_size;
      v30 = "%{public}s %{public}s%s<i%u:s%llu> [http] finished receiving {body_bytes=%llu}";
LABEL_46:
      _os_log_impl(&dword_182FBE000, v23, OS_LOG_TYPE_INFO, v30, buf, 0x3Au);
      return;
    case 4:
      v51 = MEMORY[0x1E0C809B0];
      v64[0] = MEMORY[0x1E0C809B0];
      v64[1] = 0x40000000;
      v64[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_38;
      v64[3] = &__block_descriptor_tmp_40_60085;
      v52 = *(_QWORD *)(a1 + 32);
      v64[4] = a2;
      v64[5] = v52;
      v53 = nw_http_transaction_metadata_get_outbound_message(a2);
      v54 = v53;
      if (v53)
      {
        v55 = nw_http_metadata_copy_request(v53);
        v56 = nw_http_metadata_copy_response(v54);
        inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message)
          goto LABEL_56;
        if (v55)
        {
          if (v56)
            goto LABEL_57;
          goto LABEL_55;
        }
      }
      else
      {
        v58 = nw_http_transaction_metadata_get_inbound_message(a2);
        v56 = 0;
        if (!v58)
        {
          v59 = 0;
          inbound_message = 0;
          goto LABEL_71;
        }
        inbound_message = v58;
      }
      v55 = nw_http_metadata_copy_request(inbound_message);
      if (v56)
        goto LABEL_57;
LABEL_55:
      v56 = nw_http_metadata_copy_response(inbound_message);
LABEL_56:
      if (!v56)
      {
        v59 = 0;
        if (!v55)
          goto LABEL_71;
LABEL_60:
        v62[0] = v51;
        v62[1] = 0x40000000;
        v62[2] = ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_41;
        v62[3] = &unk_1E14A7C08;
        v62[4] = v64;
        v63 = v59;
        v60 = v55;
        v61 = v62;
        _nw_http_request_access_method((uint64_t)v60, v61);

        if (!inbound_message)
          goto LABEL_62;
        goto LABEL_61;
      }
LABEL_57:
      v56 = v56;
      v59 = _nw_http_response_get_status_code();

      if (v55)
        goto LABEL_60;
LABEL_71:
      ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_38((uint64_t)v64, (uint64_t)"", v59);
      v60 = 0;
      if (inbound_message)
LABEL_61:
        os_release(inbound_message);
LABEL_62:
      if (v54)
        os_release(v54);
      if (v56)
        os_release(v56);
      if (v60)
      {
        v42 = v60;
LABEL_68:
        os_release(v42);
      }
      return;
    default:
      return;
  }
}

void nw_http3_signal_output_pending(uint64_t a1, int a2)
{
  int v4;
  int v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(void);
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  const char *v13;
  char *backtrace_string;
  _BOOL4 v15;
  NSObject *v16;
  int v17;
  const char *v18;
  char v19;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  const char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = *(unsigned __int16 *)(a1 + 1373);
    v5 = v4 | (*(unsigned __int8 *)(a1 + 1375) << 16);
    if (((((v4 & 0x80) == 0) ^ a2) & 1) == 0)
    {
      if (a2)
        v6 = 128;
      else
        v6 = 0;
      *(_BYTE *)(a1 + 1375) = (v5 & 0xFFFFFF7F) >> 16;
      *(_WORD *)(a1 + 1373) = v5 & 0xFF7F | v6;
      if ((v5 & 0x400000) == 0)
      {
        if (gLogDatapath)
        {
          v16 = __nwlog_obj();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            v17 = *(_DWORD *)(a1 + 1280);
            v18 = "no longer ";
            *(_DWORD *)buf = 136447234;
            v22 = "nw_http3_signal_output_pending";
            v23 = 2082;
            if (a2)
              v18 = "";
            v24 = (char *)(a1 + 1289);
            v25 = 2080;
            v26 = " ";
            v27 = 1024;
            v28 = v17;
            v29 = 2082;
            v30 = v18;
            _os_log_impl(&dword_182FBE000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> signalling output %{public}spending", buf, 0x30u);
          }
        }
      }
      v7 = *(_QWORD *)(a1 + 32);
      buf[0] = a2;
      if (v7)
      {
        v8 = *(_QWORD *)(v7 + 24);
        if (v8)
        {
          v9 = *(void (**)(void))(v8 + 160);
          if (v9)
            v9();
        }
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v22 = "nw_http3_signal_output_pending";
  v10 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v19 = 0;
  if (__nwlog_fault(v10, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_http3_signal_output_pending";
      v13 = "%{public}s called with null http3";
      goto LABEL_30;
    }
    if (!v19)
    {
      v11 = __nwlog_obj();
      v12 = type;
      if (!os_log_type_enabled(v11, type))
        goto LABEL_31;
      *(_DWORD *)buf = 136446210;
      v22 = "nw_http3_signal_output_pending";
      v13 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_30;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v11 = __nwlog_obj();
    v12 = type;
    v15 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        v22 = "nw_http3_signal_output_pending";
        v23 = 2082;
        v24 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_31;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      v22 = "nw_http3_signal_output_pending";
      v13 = "%{public}s called with null http3, no backtrace";
LABEL_30:
      _os_log_impl(&dword_182FBE000, v11, v12, v13, buf, 0xCu);
    }
  }
LABEL_31:
  if (v10)
    free(v10);
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_2_33(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4 || (*(_WORD *)(v4 + 736) & 0x800) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v6 = *(_QWORD *)(a1 + 32);
      v7 = (const char *)(v6 + 636);
      v8 = "";
      v9 = v6 == 0;
      if (!v6)
        v7 = "";
      v10 = *(_DWORD *)(*(_QWORD *)(v6 + 336) + 1280);
      v11 = *(_QWORD *)(v6 + 240);
      if (!v9)
        v8 = " ";
      v12 = 136447490;
      v13 = "nw_http3_control_stream_process_output_block_invoke_2";
      v14 = 2082;
      v15 = v7;
      v16 = 2080;
      v17 = v8;
      v18 = 1024;
      v19 = v10;
      v20 = 2048;
      v21 = v11;
      v22 = 2082;
      v23 = a2;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> [http] sending request header {method=\"%{public}s\"}", (uint8_t *)&v12, 0x3Au);
    }
  }
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_36(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  const char *v7;
  const char *v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  int v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (!v4 || (*(_WORD *)(v4 + 736) & 0x800) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v6 = *(_QWORD *)(a1 + 32);
      v7 = (const char *)(v6 + 636);
      v8 = "";
      v9 = v6 == 0;
      if (!v6)
        v7 = "";
      v10 = *(_DWORD *)(*(_QWORD *)(v6 + 336) + 1280);
      v11 = *(_QWORD *)(v6 + 240);
      if (!v9)
        v8 = " ";
      v12 = 136447490;
      v13 = "nw_http3_control_stream_process_output_block_invoke";
      v14 = 2082;
      v15 = v7;
      v16 = 2080;
      v17 = v8;
      v18 = 1024;
      v19 = v10;
      v20 = 2048;
      v21 = v11;
      v22 = 2082;
      v23 = a2;
      _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> [http] receiving request header {method=\"%{public}s\"}", (uint8_t *)&v12, 0x3Au);
    }
  }
}

void ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_38(uint64_t a1, uint64_t a2, int a3)
{
  int start_reason;
  uint64_t start_time;
  uint64_t end_time;
  uint64_t outbound_message_start_time;
  uint64_t outbound_message_end_time;
  uint64_t inbound_message_start_time;
  uint64_t inbound_message_end_time;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  const char *v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  const char *v29;
  int v30;
  uint64_t v31;
  const char *v32;
  const char *v33;
  uint64_t inbound_body_size;
  uint64_t outbound_body_size;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  uint64_t v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  start_reason = nw_http_transaction_metadata_get_start_reason(*(void **)(a1 + 32));
  start_time = nw_http_transaction_metadata_get_start_time(*(void **)(a1 + 32));
  end_time = nw_http_transaction_metadata_get_end_time(*(void **)(a1 + 32));
  outbound_message_start_time = nw_http_transaction_metadata_get_outbound_message_start_time(*(void **)(a1 + 32));
  outbound_message_end_time = nw_http_transaction_metadata_get_outbound_message_end_time(*(void **)(a1 + 32));
  inbound_message_start_time = nw_http_transaction_metadata_get_inbound_message_start_time(*(void **)(a1 + 32));
  inbound_message_end_time = nw_http_transaction_metadata_get_inbound_message_end_time(*(void **)(a1 + 32));
  outbound_body_size = nw_http_transaction_metadata_get_outbound_body_size(*(void **)(a1 + 32));
  inbound_body_size = nw_http_transaction_metadata_get_inbound_body_size(*(void **)(a1 + 32));
  v12 = *(_QWORD *)(a1 + 40);
  if (!v12 || (*(_WORD *)(v12 + 736) & 0x800) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_QWORD *)(a1 + 40);
      if (v14)
        v15 = (const char *)(v14 + 636);
      else
        v15 = "";
      if (v14)
        v16 = " ";
      else
        v16 = "";
      v32 = v15;
      v33 = v16;
      if ((start_reason - 1) > 2)
        v17 = "initial";
      else
        v17 = off_1E14AA478[start_reason - 1];
      v29 = v17;
      v30 = *(_DWORD *)(*(_QWORD *)(v14 + 336) + 1280);
      v31 = *(_QWORD *)(v14 + 240);
      v18 = -1;
      if (start_time && end_time)
      {
        v19 = nw_delta_nanos(start_time, end_time);
        if (v19 > 0xF423FFFFFFFFFLL)
          v18 = -1;
        else
          v18 = v19 / 0xF4240;
      }
      v20 = -1;
      v21 = a3;
      if (start_time && outbound_message_start_time)
      {
        v22 = nw_delta_nanos(start_time, outbound_message_start_time);
        if (v22 > 0xF423FFFFFFFFFLL)
          v20 = -1;
        else
          v20 = v22 / 0xF4240;
      }
      v23 = -1;
      if (outbound_message_start_time && outbound_message_end_time)
      {
        v24 = nw_delta_nanos(outbound_message_start_time, outbound_message_end_time);
        if (v24 > 0xF423FFFFFFFFFLL)
          v23 = -1;
        else
          v23 = v24 / 0xF4240;
      }
      v25 = -1;
      if (start_time && inbound_message_start_time)
      {
        v26 = nw_delta_nanos(start_time, inbound_message_start_time);
        if (v26 > 0xF423FFFFFFFFFLL)
          v25 = -1;
        else
          v25 = v26 / 0xF4240;
      }
      LODWORD(v27) = -1;
      if (inbound_message_start_time && inbound_message_end_time)
      {
        v28 = nw_delta_nanos(inbound_message_start_time, inbound_message_end_time);
        v27 = v28 / 0xF4240;
        if (v28 > 0xF423FFFFFFFFFLL)
          LODWORD(v27) = -1;
      }
      *(_DWORD *)buf = 136449794;
      v38 = "nw_http3_control_stream_process_output_block_invoke";
      v39 = 2082;
      v40 = v32;
      v41 = 2080;
      v42 = v33;
      v43 = 1024;
      v44 = v30;
      v45 = 2048;
      v46 = v31;
      v47 = 2080;
      v48 = v29;
      v49 = 1024;
      v50 = v18;
      v51 = 2082;
      v52 = a2;
      v53 = 1024;
      v54 = v21;
      v55 = 1024;
      v56 = v20;
      v57 = 1024;
      v58 = v23;
      v59 = 1024;
      v60 = v25;
      v61 = 1024;
      v62 = v27;
      v63 = 2048;
      v64 = outbound_body_size;
      v65 = 2048;
      v66 = inbound_body_size;
      _os_log_impl(&dword_182FBE000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u:s%llu> [http] transaction summary {start_reason=\"%s\", duration_ms=%d, request_method=\"%{public}s\", response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound_start_ms=%d, inbound_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}", buf, 0x7Cu);
    }
  }
}

uint64_t ___ZL38nw_http3_control_stream_process_outputP17nw_protocol_http3_block_invoke_41(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2, *(unsigned __int16 *)(a1 + 40));
}

void nw_http3_framer_claim_http3_frame_header(unsigned int a1, _DWORD *a2)
{
  unsigned int v4;
  unsigned int v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  char *backtrace_string;
  _BOOL4 v15;
  char v16;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  unsigned int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = nw_frame_unclaimed_length(a2);
  if (v4 < a1)
  {
    v5 = v4;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    v19 = "nw_http3_framer_claim_http3_frame_header";
    v20 = 1024;
    v21 = v5;
    v22 = 1024;
    v23 = a1;
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v16 = 0;
    if (!__nwlog_fault(v6, &type, &v16))
      goto LABEL_20;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446722;
      v19 = "nw_http3_framer_claim_http3_frame_header";
      v20 = 1024;
      v21 = v5;
      v22 = 1024;
      v23 = a1;
      v9 = "%{public}s Expected unclaimed_frame_length (%u) to be >= to length_to_claim (%u)";
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446978;
          v19 = "nw_http3_framer_claim_http3_frame_header";
          v20 = 1024;
          v21 = v5;
          v22 = 1024;
          v23 = a1;
          v24 = 2082;
          v25 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s Expected unclaimed_frame_length (%u) to be >= to length_to_claim (%u), dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v15)
      {
LABEL_20:
        if (v6)
          free(v6);
        return;
      }
      *(_DWORD *)buf = 136446722;
      v19 = "nw_http3_framer_claim_http3_frame_header";
      v20 = 1024;
      v21 = v5;
      v22 = 1024;
      v23 = a1;
      v9 = "%{public}s Expected unclaimed_frame_length (%u) to be >= to length_to_claim (%u), no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_20;
      *(_DWORD *)buf = 136446722;
      v19 = "nw_http3_framer_claim_http3_frame_header";
      v20 = 1024;
      v21 = v5;
      v22 = 1024;
      v23 = a1;
      v9 = "%{public}s Expected unclaimed_frame_length (%u) to be >= to length_to_claim (%u), backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0x18u);
    goto LABEL_20;
  }
  if (nw_frame_uses_external_data((uint64_t)a2))
  {
    v11 = (uint64_t)a2;
    v12 = 0;
    v13 = a1;
  }
  else
  {
    v11 = (uint64_t)a2;
    v12 = a1;
    v13 = 0;
  }
  nw_frame_claim(v11, v10, v12, v13);
}

void nw_protocol_http3_stream_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  _QWORD *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*error)(void);
  nw_protocol *v9;
  nw_protocol_callbacks *v10;
  nw_protocol *v11;
  const char *v12;
  nw_protocol_identifier *identifier;
  char *v14;
  NSObject *v15;
  os_log_type_t v16;
  nw_protocol *v17;
  const char *v18;
  nw_protocol_identifier *v19;
  const char *v20;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  char *v28;
  _BOOL4 v29;
  nw_protocol *v30;
  const char *v31;
  nw_protocol_identifier *v32;
  char *backtrace_string;
  _BOOL4 v34;
  char *v35;
  _BOOL4 v36;
  const char *v37;
  _BOOL4 v38;
  NSObject *v39;
  int v40;
  uint64_t v41;
  nw_protocol *v42;
  const char *v43;
  nw_protocol_identifier *v44;
  nw_protocol *v45;
  const char *v46;
  nw_protocol_identifier *v47;
  char v48;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v51;
  __int16 v52;
  char *v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http3_stream_error";
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v21, &type, &v48))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http3_stream_error";
      v24 = "%{public}s called with null protocol";
    }
    else if (v48)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v34 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          v51 = "nw_protocol_http3_stream_error";
          v52 = 2082;
          v53 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_94:
        if (!v21)
          return;
        goto LABEL_95;
      }
      if (!v34)
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http3_stream_error";
      v24 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http3_stream_error";
      v24 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_93;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http3_stream_error";
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v21, &type, &v48))
      goto LABEL_94;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v48)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (!os_log_type_enabled(v22, type))
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_http3_stream_error";
        v24 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_93;
      }
      v35 = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v36 = os_log_type_enabled(v22, type);
      if (!v35)
      {
        if (!v36)
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        v51 = "nw_protocol_http3_stream_error";
        v24 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_93;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        v51 = "nw_protocol_http3_stream_error";
        v52 = 2082;
        v53 = v35;
        v37 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_63:
        _os_log_impl(&dword_182FBE000, v22, v23, v37, buf, 0x16u);
      }
LABEL_64:
      free(v35);
      if (!v21)
        return;
LABEL_95:
      free(v21);
      return;
    }
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
      goto LABEL_94;
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http3_stream_error";
    v24 = "%{public}s called with null http3_stream";
LABEL_93:
    _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
    goto LABEL_94;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v51 = "nw_protocol_http3_stream_error";
    v21 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v21, &type, &v48))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http3_stream_error";
      v24 = "%{public}s called with null other_protocol";
      goto LABEL_93;
    }
    if (!v48)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http3_stream_error";
      v24 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_93;
    }
    v35 = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v38 = os_log_type_enabled(v22, type);
    if (!v35)
    {
      if (!v38)
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v51 = "nw_protocol_http3_stream_error";
      v24 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_93;
    }
    if (v38)
    {
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http3_stream_error";
      v52 = 2082;
      v53 = v35;
      v37 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_63;
    }
    goto LABEL_64;
  }
  if ((handle[92] & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      v25 = __nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        v26 = *(_DWORD *)(handle[42] + 1280);
        v27 = handle[30];
        *(_DWORD *)buf = 136447234;
        v51 = "nw_protocol_http3_stream_error";
        v52 = 2082;
        v53 = (char *)handle + 636;
        v54 = 2080;
        v55 = " ";
        v56 = 1024;
        v57 = v26;
        v58 = 2048;
        v59 = v27;
        _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> called", buf, 0x30u);
      }
    }
  }
  if (a3 == 35)
  {
    if ((handle[92] & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        v39 = __nwlog_obj();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          v40 = *(_DWORD *)(handle[42] + 1280);
          v41 = handle[30];
          *(_DWORD *)buf = 136447234;
          v51 = "nw_protocol_http3_stream_error";
          v52 = 2082;
          v53 = (char *)handle + 636;
          v54 = 2080;
          v55 = " ";
          v56 = 1024;
          v57 = v40;
          v58 = 2048;
          v59 = v41;
          _os_log_impl(&dword_182FBE000, v39, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> early data rejected", buf, 0x30u);
        }
      }
    }
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        error = (void (*)(void))callbacks->error;
        if (error)
          goto LABEL_16;
      }
    }
    __nwlog_obj();
    v11 = a1->default_input_handler;
    v12 = "invalid";
    if (v11)
    {
      identifier = v11->identifier;
      if (identifier)
        v12 = (const char *)identifier;
    }
    *(_DWORD *)buf = 136446466;
    v51 = "nw_protocol_http3_stream_error";
    v52 = 2082;
    v53 = (char *)v12;
    v14 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v48 = 0;
    if (!__nwlog_fault(v14, &type, &v48))
      goto LABEL_85;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_85;
      v17 = a1->default_input_handler;
      v18 = "invalid";
      if (v17)
      {
        v19 = v17->identifier;
        if (v19)
          v18 = (const char *)v19;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http3_stream_error";
      v52 = 2082;
      v53 = (char *)v18;
      v20 = "%{public}s protocol %{public}s has invalid error callback";
    }
    else if (v48)
    {
      v28 = (char *)__nw_create_backtrace_string();
      v15 = __nwlog_obj();
      v16 = type;
      v29 = os_log_type_enabled(v15, type);
      if (v28)
      {
        if (v29)
        {
          v30 = a1->default_input_handler;
          v31 = "invalid";
          if (v30)
          {
            v32 = v30->identifier;
            if (v32)
              v31 = (const char *)v32;
          }
          *(_DWORD *)buf = 136446722;
          v51 = "nw_protocol_http3_stream_error";
          v52 = 2082;
          v53 = (char *)v31;
          v54 = 2082;
          v55 = v28;
          _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v28);
        goto LABEL_85;
      }
      if (!v29)
      {
LABEL_85:
        if (v14)
          free(v14);
        return;
      }
      v45 = a1->default_input_handler;
      v46 = "invalid";
      if (v45)
      {
        v47 = v45->identifier;
        if (v47)
          v46 = (const char *)v47;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http3_stream_error";
      v52 = 2082;
      v53 = (char *)v46;
      v20 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
    }
    else
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_85;
      v42 = a1->default_input_handler;
      v43 = "invalid";
      if (v42)
      {
        v44 = v42->identifier;
        if (v44)
          v43 = (const char *)v44;
      }
      *(_DWORD *)buf = 136446466;
      v51 = "nw_protocol_http3_stream_error";
      v52 = 2082;
      v53 = (char *)v43;
      v20 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v15, v16, v20, buf, 0x16u);
    goto LABEL_85;
  }
  nw_http3_stream_get_application_error((uint64_t)handle);
  v9 = a1->default_input_handler;
  if (v9)
  {
    v10 = v9->callbacks;
    if (v10)
    {
      error = (void (*)(void))v10->error;
      if (error)
LABEL_16:
        error();
    }
  }
}

void nw_http3_async_close_connection_if_no_stream(uint64_t a1)
{
  _WORD *v2;
  uint64_t v3;
  void *v4;
  NSObject *v5;
  int v6;
  _QWORD v7[5];
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = (_WORD *)(a1 + 1373);
  if (((*(unsigned __int16 *)(a1 + 1373) | (*(unsigned __int8 *)(a1 + 1375) << 16)) & 0x400000) == 0)
  {
    if (gLogDatapath)
    {
      v5 = __nwlog_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        v6 = *(_DWORD *)(a1 + 1280);
        *(_DWORD *)buf = 136446978;
        v9 = "nw_http3_async_close_connection_if_no_stream";
        v10 = 2082;
        v11 = a1 + 1289;
        v12 = 2080;
        v13 = " ";
        v14 = 1024;
        v15 = v6;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
  }
  *v2 |= 8u;
  nw_protocol_remove_instance(a1);
  if (!*(_QWORD *)(a1 + 880))
  {
    v3 = *(_QWORD *)(a1 + 1040);
    v4 = *(void **)(a1 + 1256);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = ___ZL44nw_http3_async_close_connection_if_no_streamP17nw_protocol_http3_block_invoke;
    v7[3] = &unk_1E14A7AD8;
    v7[4] = v3;
    nw_queue_context_async(v4, v7);
  }
}

void ___ZL44nw_http3_async_close_connection_if_no_streamP17nw_protocol_http3_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v1)
    nw_http3_connection_destroy(v1, v2);
}

void nw_http3_connection_destroy(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int16 *v3;
  void *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  char *v16;
  NSObject *v17;
  os_log_type_t v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  void *v22;
  char *backtrace_string;
  NSObject *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  NSObject *v27;
  os_log_type_t v28;
  int v29;
  uint64_t v30;
  void (*v31)(uint64_t, uint64_t);
  uint64_t v32;
  uint64_t v33;
  void (*v34)(uint64_t, uint64_t);
  uint64_t v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t);
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  _DWORD *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void (*v53)(uint64_t, uint64_t);
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void (*v57)(uint64_t, uint64_t);
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  void (*v66)(uint64_t, uint64_t);
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void (*v70)(uint64_t, uint64_t);
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  char v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void (*v79)(uint64_t, uint64_t);
  _QWORD *v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  uint64_t v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  void (*v89)(uint64_t, _QWORD *);
  uint64_t v90;
  uint64_t v91;
  const char *v92;
  char *v93;
  uint64_t v94;
  const char *v95;
  const char *v96;
  _BOOL4 v97;
  char *v98;
  uint64_t v99;
  const char *v100;
  NSObject *v101;
  uint64_t v102;
  const char *v103;
  uint64_t v104;
  const char *v105;
  NSObject *v106;
  os_log_type_t v107;
  const char *v108;
  char *v109;
  void *v110;
  void *v111;
  void *v112;
  void *v113;
  void *v114;
  void *v115;
  void *v116;
  void *v117;
  void *v118;
  void *v119;
  void *v120;
  void *v121;
  void *v122;
  NSObject *v123;
  NSObject *v124;
  NSObject *v125;
  NSObject *v126;
  NSObject *v127;
  NSObject *v128;
  NSObject *v129;
  NSObject *v130;
  NSObject *v131;
  const void *v132;
  NSObject *v133;
  const void *v134;
  uint64_t v135;
  const char *v136;
  const char *v137;
  char *v138;
  NSObject *v139;
  os_log_type_t v140;
  uint64_t v141;
  const char *v142;
  const char *v143;
  uint64_t v144;
  const char *v145;
  const char *v146;
  char *v147;
  NSObject *v148;
  os_log_type_t v149;
  uint64_t v150;
  const char *v151;
  const char *v152;
  const char *v153;
  uint64_t v154;
  const char *v155;
  const char *v156;
  char *v157;
  NSObject *v158;
  os_log_type_t v159;
  uint64_t v160;
  const char *v161;
  const char *v162;
  const char *v163;
  uint64_t v164;
  const char *v165;
  const char *v166;
  char *v167;
  NSObject *v168;
  os_log_type_t v169;
  uint64_t v170;
  const char *v171;
  const char *v172;
  const char *v173;
  uint64_t v174;
  const char *v175;
  const char *v176;
  char *v177;
  NSObject *v178;
  os_log_type_t v179;
  uint64_t v180;
  const char *v181;
  const char *v182;
  const char *v183;
  uint64_t v184;
  const char *v185;
  const char *v186;
  char *v187;
  NSObject *v188;
  os_log_type_t v189;
  uint64_t v190;
  const char *v191;
  const char *v192;
  const char *v193;
  NSObject *v194;
  os_log_type_t v195;
  const char *v196;
  NSObject *v197;
  int v198;
  char *v199;
  NSObject *v200;
  os_log_type_t v201;
  _BOOL4 v202;
  uint64_t v203;
  const char *v204;
  const char *v205;
  char *v206;
  _BOOL4 v207;
  uint64_t v208;
  const char *v209;
  const char *v210;
  char *v211;
  _BOOL4 v212;
  uint64_t v213;
  const char *v214;
  const char *v215;
  char *v216;
  _BOOL4 v217;
  uint64_t v218;
  const char *v219;
  const char *v220;
  char *v221;
  _BOOL4 v222;
  uint64_t v223;
  const char *v224;
  const char *v225;
  char *v226;
  _BOOL4 v227;
  uint64_t v228;
  const char *v229;
  const char *v230;
  NSObject *v231;
  NSObject *v232;
  NSObject *v233;
  NSObject *v234;
  char *v235;
  _BOOL4 v236;
  NSObject *v237;
  int v238;
  uint64_t v239;
  const char *v240;
  const char *v241;
  const char *v242;
  uint64_t v243;
  const char *v244;
  const char *v245;
  uint64_t v246;
  const char *v247;
  const char *v248;
  uint64_t v249;
  const char *v250;
  const char *v251;
  uint64_t v252;
  const char *v253;
  const char *v254;
  uint64_t v255;
  const char *v256;
  const char *v257;
  uint64_t v258;
  const char *v259;
  const char *v260;
  uint64_t v261;
  const char *v262;
  const char *v263;
  uint64_t v264;
  const char *v265;
  const char *v266;
  uint64_t v267;
  const char *v268;
  const char *v269;
  uint64_t v270;
  const char *v271;
  const char *v272;
  uint64_t v273;
  const char *v274;
  const char *v275;
  uint64_t v276;
  const char *v277;
  const char *v278;
  char *v279;
  NSObject *v280;
  os_log_type_t v281;
  uint64_t v282;
  const char *v283;
  const char *v284;
  const char *v285;
  char *v286;
  _BOOL4 v287;
  uint64_t v288;
  const char *v289;
  const char *v290;
  uint64_t v291;
  const char *v292;
  const char *v293;
  uint64_t v294;
  const char *v295;
  const char *v296;
  os_log_type_t v297;
  os_log_type_t v298;
  NSObject *v299;
  os_log_type_t v300;
  NSObject *v301;
  char *v302;
  NSObject *v303;
  NSObject *log;
  uint64_t v305;
  char v306;
  os_log_type_t type;
  _BYTE buf[24];
  const char *v309;
  _QWORD *v310;
  uint64_t v311;
  uint64_t v312;

  v312 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = a1;
    v3 = (unsigned __int16 *)(a1 + 1373);
    v4 = &unk_1ECD84000;
    if (((*(unsigned __int16 *)(a1 + 1373) | (*(unsigned __int8 *)(a1 + 1375) << 16)) & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        v6 = *(_DWORD *)(v2 + 1280);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v2 + 1289;
        *(_WORD *)&buf[22] = 2080;
        v309 = " ";
        LOWORD(v310) = 1024;
        *(_DWORD *)((char *)&v310 + 2) = v6;
        HIWORD(v310) = 2048;
        v311 = v2;
        _os_log_impl(&dword_182FBE000, v5, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> destroying %p", buf, 0x30u);
      }
    }
    v7 = *(_QWORD *)(v2 + 1264);
    if (v7)
    {
      nw_queue_cancel_source(v7, a2);
      *(_QWORD *)(v2 + 1264) = 0;
    }
    v8 = *(_QWORD *)(v2 + 1088);
    if (v8)
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v8 + 8))(v8, v2, 0);
    nw_http_connection_metadata_closed(*(void **)(v2 + 1248));
    v9 = *(void **)(v2 + 1240);
    if (v9)
    {
      nw_quic_connection_close_with_error(v9, 256);
      v10 = *(void **)(v2 + 1240);
      if (v10)
      {
        os_release(v10);
        *(_QWORD *)(v2 + 1240) = 0;
      }
    }
    v11 = *(void **)(v2 + 1248);
    if (v11)
    {
      os_release(v11);
      *(_QWORD *)(v2 + 1248) = 0;
    }
    v305 = v2;
    v12 = *(_QWORD *)(v2 + 880);
    if (v12)
    {
      do
      {
        v13 = *(_QWORD *)(v12 + 544);
        if (((*v3 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v14 = *((_QWORD *)v4 + 463);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            v15 = *(_DWORD *)(v2 + 1280);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v2 + 1289;
            *(_WORD *)&buf[22] = 2080;
            v309 = " ";
            LOWORD(v310) = 1024;
            *(_DWORD *)((char *)&v310 + 2) = v15;
            HIWORD(v310) = 2048;
            v311 = v12;
            _os_log_impl(&dword_182FBE000, v14, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> should not have stream %p left, destroying anyways", buf, 0x30u);
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
        v16 = (char *)_os_log_send_and_compose_impl();
        type = OS_LOG_TYPE_ERROR;
        v306 = 0;
        if (!__nwlog_fault(v16, &type, &v306))
          goto LABEL_34;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v17 = *((_QWORD *)v4 + 463);
          v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
            v19 = v17;
            v20 = v18;
            v21 = "%{public}s should not have streams left when destroying";
LABEL_33:
            _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
          }
        }
        else if (v306)
        {
          v22 = v4;
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v24 = *((_QWORD *)v22 + 463);
          v25 = type;
          v26 = os_log_type_enabled(v24, type);
          if (backtrace_string)
          {
            if (v26)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_182FBE000, v24, v25, "%{public}s should not have streams left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            v4 = &unk_1ECD84000;
            goto LABEL_34;
          }
          v4 = &unk_1ECD84000;
          if (v26)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
            v19 = v24;
            v20 = v25;
            v21 = "%{public}s should not have streams left when destroying, no backtrace";
            goto LABEL_33;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v27 = *((_QWORD *)v4 + 463);
          v28 = type;
          if (os_log_type_enabled(v27, type))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
            v19 = v27;
            v20 = v28;
            v21 = "%{public}s should not have streams left when destroying, backtrace limit exceeded";
            goto LABEL_33;
          }
        }
LABEL_34:
        if (v16)
          free(v16);
        nw_protocol_http3_stream_destroy(v12);
        v12 = v13;
      }
      while (v13);
    }
    if (((*v3 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v197 = __nwlog_obj();
        if (os_log_type_enabled(v197, OS_LOG_TYPE_DEBUG))
        {
          v198 = *(_DWORD *)(v2 + 1280);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v2 + 1289;
          *(_WORD *)&buf[22] = 2080;
          v309 = " ";
          LOWORD(v310) = 1024;
          *(_DWORD *)((char *)&v310 + 2) = v198;
          _os_log_impl(&dword_182FBE000, v197, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    nw_protocol_remove_instance(v2);
    v29 = *v3;
    if ((v29 & 0x800) == 0)
    {
LABEL_52:
      v38 = MEMORY[0x1E0C809B0];
      v39 = (_QWORD *)&unk_183BA7000;
      if (!*(_QWORD *)(v2 + 1048))
        goto LABEL_71;
      v40 = *(_QWORD *)(v2 + 216);
      while (v40)
      {
        v41 = (_DWORD *)v40;
        v40 = *(_QWORD *)(v40 + 32);
        if (gLogDatapath)
        {
          log = __nwlog_obj();
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
          {
            v42 = nw_frame_unclaimed_length(v41);
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = "nw_http3_framer_cleanup_block_invoke";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v41;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v309) = v42;
            _os_log_impl(&dword_182FBE000, log, OS_LOG_TYPE_DEBUG, "%{public}s input frames unprocessed still has frames in it: frame %p (%u bytes)", buf, 0x1Cu);
          }
        }
      }
      if (gLogDatapath)
      {
        v231 = __nwlog_obj();
        if (os_log_type_enabled(v231, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_182FBE000, v231, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }
      *(_QWORD *)buf = v38;
      v39 = &unk_183BA7000;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60151;
      v309 = (const char *)&__block_descriptor_tmp_26_60152;
      v310 = (_QWORD *)(v2 + 216);
      LOBYTE(v311) = 0;
      v43 = *(_QWORD *)(v2 + 216);
      v2 = v305;
      do
      {
        if (!v43)
          break;
        v44 = *(_QWORD *)(v43 + 32);
        v45 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v43 = v44;
      }
      while ((v45 & 1) != 0);
      *(_DWORD *)(v305 + 232) = 0;
      v46 = (_QWORD *)(*(_QWORD *)(v305 + 1048) + 104);
      if (gLogDatapath)
      {
        v232 = __nwlog_obj();
        if (os_log_type_enabled(v232, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_182FBE000, v232, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }
      *(_QWORD *)buf = v38;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60151;
      v309 = (const char *)&__block_descriptor_tmp_26_60152;
      v310 = v46;
      LOBYTE(v311) = 0;
      v47 = *v46;
      do
      {
        if (!v47)
          break;
        v48 = *(_QWORD *)(v47 + 32);
        v49 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
        v47 = v48;
      }
      while ((v49 & 1) != 0);
      v50 = *(_QWORD *)(v305 + 1048);
      v51 = *(_QWORD *)(v50 + 32);
      if (v51)
      {
        v52 = *(_QWORD *)(v51 + 24);
        if (v52)
        {
          v53 = *(void (**)(uint64_t, uint64_t))(v52 + 8);
          if (v53)
          {
            v53(v51, v50);
LABEL_70:
            nw_protocol_http3_uni_stream_destroy(*(_QWORD *)(v2 + 1048));
            *(_QWORD *)(v2 + 1048) = 0;
LABEL_71:
            v54 = *(_QWORD *)(v2 + 1056);
            if (!v54)
              goto LABEL_77;
            v55 = *(_QWORD *)(v54 + 32);
            if (v55)
            {
              v56 = *(_QWORD *)(v55 + 24);
              if (v56)
              {
                v57 = *(void (**)(uint64_t, uint64_t))(v56 + 8);
                if (v57)
                {
                  v57(v55, v54);
LABEL_76:
                  nw_protocol_http3_uni_stream_destroy(*(_QWORD *)(v2 + 1056));
                  *(_QWORD *)(v2 + 1056) = 0;
LABEL_77:
                  v58 = *(_QWORD *)(v2 + 1064);
                  if (!v58)
                    goto LABEL_87;
                  v59 = (_QWORD *)(v58 + 104);
                  if (gLogDatapath)
                  {
                    v233 = __nwlog_obj();
                    if (os_log_type_enabled(v233, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
                      _os_log_impl(&dword_182FBE000, v233, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                    }
                  }
                  *(_QWORD *)buf = v38;
                  *(_QWORD *)&buf[8] = v39[197];
                  *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60151;
                  v309 = (const char *)&__block_descriptor_tmp_26_60152;
                  v310 = v59;
                  LOBYTE(v311) = 0;
                  v60 = *v59;
                  do
                  {
                    if (!v60)
                      break;
                    v61 = *(_QWORD *)(v60 + 32);
                    v62 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                    v60 = v61;
                  }
                  while ((v62 & 1) != 0);
                  v63 = *(_QWORD *)(v2 + 1064);
                  v64 = *(_QWORD *)(v63 + 32);
                  if (v64)
                  {
                    v65 = *(_QWORD *)(v64 + 24);
                    if (v65)
                    {
                      v66 = *(void (**)(uint64_t, uint64_t))(v65 + 8);
                      if (v66)
                      {
                        v66(v64, v63);
LABEL_86:
                        nw_protocol_http3_uni_stream_destroy(*(_QWORD *)(v2 + 1064));
                        *(_QWORD *)(v2 + 1064) = 0;
LABEL_87:
                        v67 = *(_QWORD *)(v2 + 1072);
                        if (!v67)
                          goto LABEL_93;
                        v68 = *(_QWORD *)(v67 + 32);
                        if (v68)
                        {
                          v69 = *(_QWORD *)(v68 + 24);
                          if (v69)
                          {
                            v70 = *(void (**)(uint64_t, uint64_t))(v69 + 8);
                            if (v70)
                            {
                              v70(v68, v67);
LABEL_92:
                              nw_protocol_http3_uni_stream_destroy(*(_QWORD *)(v2 + 1072));
                              *(_QWORD *)(v2 + 1072) = 0;
LABEL_93:
                              v71 = *(_QWORD *)(v2 + 1080);
                              if (!v71)
                              {
LABEL_103:
                                v80 = *(_QWORD **)(v2 + 896);
                                if (v80)
                                {
                                  v81 = v39[197];
                                  while (1)
                                  {
                                    v83 = (_QWORD *)v80[10];
                                    if (gLogDatapath)
                                    {
                                      v101 = __nwlog_obj();
                                      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
                                      {
                                        *(_DWORD *)buf = 136446210;
                                        *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
                                        _os_log_impl(&dword_182FBE000, v101, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                                      }
                                    }
                                    *(_QWORD *)buf = v38;
                                    *(_QWORD *)&buf[8] = v81;
                                    *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60151;
                                    v309 = (const char *)&__block_descriptor_tmp_26_60152;
                                    v310 = v80 + 13;
                                    LOBYTE(v311) = 0;
                                    v84 = v80[13];
                                    do
                                    {
                                      if (!v84)
                                        break;
                                      v85 = *(_QWORD *)(v84 + 32);
                                      v86 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                                      v84 = v85;
                                    }
                                    while ((v86 & 1) != 0);
                                    v87 = v80[4];
                                    if (!v87)
                                      break;
                                    v88 = *(_QWORD *)(v87 + 24);
                                    if (!v88)
                                      break;
                                    v89 = *(void (**)(uint64_t, _QWORD *))(v88 + 8);
                                    if (!v89)
                                      break;
                                    v89(v87, v80);
LABEL_115:
                                    v90 = v80[10];
                                    v82 = (_QWORD *)v80[11];
                                    if (v90)
                                    {
                                      *(_QWORD *)(v90 + 88) = v82;
                                      v82 = (_QWORD *)v80[11];
                                    }
                                    else
                                    {
                                      *(_QWORD *)(v305 + 904) = v82;
                                    }
                                    *v82 = v90;
                                    v80[10] = 0;
                                    v80[11] = 0;
                                    nw_protocol_http3_uni_stream_destroy((uint64_t)v80);
                                    v80 = v83;
                                    if (!v83)
                                      goto LABEL_160;
                                  }
                                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                                  networkd_settings_init();
                                  v91 = v80[4];
                                  if (v91)
                                  {
                                    v92 = *(const char **)(v91 + 16);
                                    if (!v92)
                                      v92 = "invalid";
                                  }
                                  else
                                  {
                                    v92 = "invalid";
                                  }
                                  *(_DWORD *)buf = 136446466;
                                  *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                  *(_WORD *)&buf[12] = 2082;
                                  *(_QWORD *)&buf[14] = v92;
                                  v93 = (char *)_os_log_send_and_compose_impl();
                                  type = OS_LOG_TYPE_ERROR;
                                  v306 = 0;
                                  if (__nwlog_fault(v93, &type, &v306))
                                  {
                                    if (type == OS_LOG_TYPE_FAULT)
                                    {
                                      v301 = __nwlog_obj();
                                      v298 = type;
                                      if (!os_log_type_enabled(v301, type))
                                        goto LABEL_158;
                                      v94 = v80[4];
                                      if (v94)
                                      {
                                        v95 = *(const char **)(v94 + 16);
                                        if (!v95)
                                          v95 = "invalid";
                                      }
                                      else
                                      {
                                        v95 = "invalid";
                                      }
                                      *(_DWORD *)buf = 136446466;
                                      *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                      *(_WORD *)&buf[12] = 2082;
                                      *(_QWORD *)&buf[14] = v95;
                                      v106 = v301;
                                      v107 = v298;
                                      v108 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
                                      goto LABEL_157;
                                    }
                                    if (!v306)
                                    {
                                      v303 = __nwlog_obj();
                                      v300 = type;
                                      if (!os_log_type_enabled(v303, type))
                                        goto LABEL_158;
                                      v102 = v80[4];
                                      if (v102)
                                      {
                                        v103 = *(const char **)(v102 + 16);
                                        if (!v103)
                                          v103 = "invalid";
                                      }
                                      else
                                      {
                                        v103 = "invalid";
                                      }
                                      *(_DWORD *)buf = 136446466;
                                      *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                      *(_WORD *)&buf[12] = 2082;
                                      *(_QWORD *)&buf[14] = v103;
                                      v106 = v303;
                                      v107 = v300;
                                      v108 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, b"
                                             "acktrace limit exceeded";
                                      goto LABEL_157;
                                    }
                                    v302 = v93;
                                    v96 = __nw_create_backtrace_string();
                                    v299 = __nwlog_obj();
                                    v297 = type;
                                    v97 = os_log_type_enabled(v299, type);
                                    if (v96)
                                    {
                                      v98 = (char *)v96;
                                      v93 = v302;
                                      if (v97)
                                      {
                                        v99 = v80[4];
                                        if (v99)
                                        {
                                          v100 = *(const char **)(v99 + 16);
                                          if (!v100)
                                            v100 = "invalid";
                                        }
                                        else
                                        {
                                          v100 = "invalid";
                                        }
                                        *(_DWORD *)buf = 136446722;
                                        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                        *(_WORD *)&buf[12] = 2082;
                                        *(_QWORD *)&buf[14] = v100;
                                        *(_WORD *)&buf[22] = 2082;
                                        v309 = v98;
                                        v109 = v98;
                                        _os_log_impl(&dword_182FBE000, v299, v297, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                                        v98 = v109;
                                        v93 = v302;
                                      }
                                      free(v98);
                                      goto LABEL_158;
                                    }
                                    v93 = v302;
                                    if (v97)
                                    {
                                      v104 = v80[4];
                                      if (v104)
                                      {
                                        v105 = *(const char **)(v104 + 16);
                                        if (!v105)
                                          v105 = "invalid";
                                      }
                                      else
                                      {
                                        v105 = "invalid";
                                      }
                                      v106 = v299;
                                      v107 = v297;
                                      *(_DWORD *)buf = 136446466;
                                      *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                      *(_WORD *)&buf[12] = 2082;
                                      *(_QWORD *)&buf[14] = v105;
                                      v108 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_157:
                                      _os_log_impl(&dword_182FBE000, v106, v107, v108, buf, 0x16u);
                                    }
                                  }
LABEL_158:
                                  if (v93)
                                    free(v93);
                                  goto LABEL_115;
                                }
LABEL_160:
                                v110 = (void *)v305;
                                lsqpack_enc_cleanup(v305 + 256);
                                lsqpack_dec_cleanup(v305 + 496);
                                v111 = *(void **)(v305 + 1216);
                                if (v111)
                                {
                                  v112 = *(void **)(v305 + 1224);
                                  if (v112)
                                    nw_association_unregister(v111, v112);
                                }
                                v113 = *(void **)(v305 + 1208);
                                if (v113)
                                {
                                  os_release(v113);
                                  *(_QWORD *)(v305 + 1208) = 0;
                                }
                                v114 = *(void **)(v305 + 1216);
                                if (v114)
                                {
                                  os_release(v114);
                                  *(_QWORD *)(v305 + 1216) = 0;
                                }
                                v115 = *(void **)(v305 + 1224);
                                if (v115)
                                {
                                  os_release(v115);
                                  *(_QWORD *)(v305 + 1224) = 0;
                                }
                                v116 = *(void **)(v305 + 1232);
                                if (v116)
                                {
                                  os_release(v116);
                                  *(_QWORD *)(v305 + 1232) = 0;
                                }
                                v117 = *(void **)(v305 + 1096);
                                if (v117)
                                {
                                  os_release(v117);
                                  *(_QWORD *)(v305 + 1096) = 0;
                                }
                                v118 = *(void **)(v305 + 1104);
                                if (v118)
                                {
                                  os_release(v118);
                                  *(_QWORD *)(v305 + 1104) = 0;
                                }
                                v119 = *(void **)(v305 + 1112);
                                if (v119)
                                {
                                  os_release(v119);
                                  *(_QWORD *)(v305 + 1112) = 0;
                                }
                                v120 = *(void **)(v305 + 1120);
                                if (v120)
                                {
                                  os_release(v120);
                                  *(_QWORD *)(v305 + 1120) = 0;
                                }
                                v121 = *(void **)(v305 + 1128);
                                if (v121)
                                {
                                  os_release(v121);
                                  *(_QWORD *)(v305 + 1128) = 0;
                                }
                                v122 = *(void **)(v305 + 1256);
                                if (v122)
                                {
                                  os_release(v122);
                                  *(_QWORD *)(v305 + 1256) = 0;
                                }
                                v123 = *(NSObject **)(v305 + 1176);
                                if (v123)
                                {
                                  dispatch_release(v123);
                                  *(_QWORD *)(v305 + 1176) = 0;
                                }
                                v124 = *(NSObject **)(v305 + 1184);
                                if (v124)
                                {
                                  dispatch_release(v124);
                                  *(_QWORD *)(v305 + 1184) = 0;
                                }
                                v125 = *(NSObject **)(v305 + 1192);
                                if (v125)
                                {
                                  dispatch_release(v125);
                                  *(_QWORD *)(v305 + 1192) = 0;
                                }
                                v126 = *(NSObject **)(v305 + 1160);
                                if (v126)
                                {
                                  dispatch_release(v126);
                                  *(_QWORD *)(v305 + 1160) = 0;
                                }
                                v127 = *(NSObject **)(v305 + 1168);
                                if (v127)
                                {
                                  dispatch_release(v127);
                                  *(_QWORD *)(v305 + 1168) = 0;
                                }
                                v128 = *(NSObject **)(v305 + 1152);
                                if (v128)
                                {
                                  dispatch_release(v128);
                                  *(_QWORD *)(v305 + 1152) = 0;
                                }
                                v129 = *(NSObject **)(v305 + 1136);
                                if (v129)
                                {
                                  dispatch_release(v129);
                                  *(_QWORD *)(v305 + 1136) = 0;
                                }
                                v130 = *(NSObject **)(v305 + 1144);
                                if (v130)
                                {
                                  dispatch_release(v130);
                                  *(_QWORD *)(v305 + 1144) = 0;
                                }
                                v131 = *(NSObject **)(v305 + 1200);
                                if (v131)
                                {
                                  dispatch_release(v131);
                                  *(_QWORD *)(v305 + 1200) = 0;
                                }
                                v132 = *(const void **)(v305 + 864);
                                if (v132)
                                {
                                  _Block_release(v132);
                                  *(_QWORD *)(v305 + 864) = 0;
                                }
                                v133 = *(NSObject **)(v305 + 872);
                                if (v133)
                                {
                                  dispatch_release(v133);
                                  *(_QWORD *)(v305 + 872) = 0;
                                }
                                (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v305 + 1040) + 16))(*(_QWORD *)(v305 + 1040), 0);
                                v134 = *(const void **)(v305 + 1040);
                                if (v134)
                                  _Block_release(v134);
                                goto LABEL_207;
                              }
                              v72 = (_QWORD *)(v71 + 104);
                              if (gLogDatapath)
                              {
                                v234 = __nwlog_obj();
                                if (os_log_type_enabled(v234, OS_LOG_TYPE_DEBUG))
                                {
                                  *(_DWORD *)buf = 136446210;
                                  *(_QWORD *)&buf[4] = "nw_protocol_finalize_temp_frame_array";
                                  _os_log_impl(&dword_182FBE000, v234, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
                                }
                              }
                              *(_QWORD *)buf = v38;
                              *(_QWORD *)&buf[8] = v39[197];
                              *(_QWORD *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60151;
                              v309 = (const char *)&__block_descriptor_tmp_26_60152;
                              v310 = v72;
                              LOBYTE(v311) = 0;
                              v73 = *v72;
                              do
                              {
                                if (!v73)
                                  break;
                                v74 = *(_QWORD *)(v73 + 32);
                                v75 = (*(uint64_t (**)(_BYTE *))&buf[16])(buf);
                                v73 = v74;
                              }
                              while ((v75 & 1) != 0);
                              v76 = *(_QWORD *)(v2 + 1080);
                              v77 = *(_QWORD *)(v76 + 32);
                              if (v77)
                              {
                                v78 = *(_QWORD *)(v77 + 24);
                                if (v78)
                                {
                                  v79 = *(void (**)(uint64_t, uint64_t))(v78 + 8);
                                  if (v79)
                                  {
                                    v79(v77, v76);
LABEL_102:
                                    nw_protocol_http3_uni_stream_destroy(*(_QWORD *)(v2 + 1080));
                                    *(_QWORD *)(v2 + 1080) = 0;
                                    goto LABEL_103;
                                  }
                                }
                              }
                              __nwlog_obj();
                              v174 = *(_QWORD *)(*(_QWORD *)(v2 + 1080) + 32);
                              v175 = "invalid";
                              if (v174)
                              {
                                v176 = *(const char **)(v174 + 16);
                                if (v176)
                                  v175 = v176;
                              }
                              *(_DWORD *)buf = 136446466;
                              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                              *(_WORD *)&buf[12] = 2082;
                              *(_QWORD *)&buf[14] = v175;
                              v177 = (char *)_os_log_send_and_compose_impl();
                              type = OS_LOG_TYPE_ERROR;
                              v306 = 0;
                              if (__nwlog_fault(v177, &type, &v306))
                              {
                                if (type == OS_LOG_TYPE_FAULT)
                                {
                                  v178 = __nwlog_obj();
                                  v179 = type;
                                  if (os_log_type_enabled(v178, type))
                                  {
                                    v180 = *(_QWORD *)(*(_QWORD *)(v305 + 1080) + 32);
                                    v181 = "invalid";
                                    if (v180)
                                    {
                                      v182 = *(const char **)(v180 + 16);
                                      if (v182)
                                        v181 = v182;
                                    }
                                    *(_DWORD *)buf = 136446466;
                                    *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                    *(_WORD *)&buf[12] = 2082;
                                    *(_QWORD *)&buf[14] = v181;
                                    v183 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
LABEL_409:
                                    _os_log_impl(&dword_182FBE000, v178, v179, v183, buf, 0x16u);
                                  }
                                }
                                else if (v306)
                                {
                                  v221 = (char *)__nw_create_backtrace_string();
                                  v178 = __nwlog_obj();
                                  v179 = type;
                                  v222 = os_log_type_enabled(v178, type);
                                  if (v221)
                                  {
                                    if (v222)
                                    {
                                      v223 = *(_QWORD *)(*(_QWORD *)(v305 + 1080) + 32);
                                      v224 = "invalid";
                                      if (v223)
                                      {
                                        v225 = *(const char **)(v223 + 16);
                                        if (v225)
                                          v224 = v225;
                                      }
                                      *(_DWORD *)buf = 136446722;
                                      *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                      *(_WORD *)&buf[12] = 2082;
                                      *(_QWORD *)&buf[14] = v224;
                                      *(_WORD *)&buf[22] = 2082;
                                      v309 = v221;
                                      _os_log_impl(&dword_182FBE000, v178, v179, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                                    }
                                    free(v221);
                                    goto LABEL_410;
                                  }
                                  if (v222)
                                  {
                                    v270 = *(_QWORD *)(*(_QWORD *)(v305 + 1080) + 32);
                                    v271 = "invalid";
                                    if (v270)
                                    {
                                      v272 = *(const char **)(v270 + 16);
                                      if (v272)
                                        v271 = v272;
                                    }
                                    *(_DWORD *)buf = 136446466;
                                    *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                    *(_WORD *)&buf[12] = 2082;
                                    *(_QWORD *)&buf[14] = v271;
                                    v183 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
                                    goto LABEL_409;
                                  }
                                }
                                else
                                {
                                  v178 = __nwlog_obj();
                                  v179 = type;
                                  if (os_log_type_enabled(v178, type))
                                  {
                                    v252 = *(_QWORD *)(*(_QWORD *)(v305 + 1080) + 32);
                                    v253 = "invalid";
                                    if (v252)
                                    {
                                      v254 = *(const char **)(v252 + 16);
                                      if (v254)
                                        v253 = v254;
                                    }
                                    *(_DWORD *)buf = 136446466;
                                    *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                    *(_WORD *)&buf[12] = 2082;
                                    *(_QWORD *)&buf[14] = v253;
                                    v183 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, bac"
                                           "ktrace limit exceeded";
                                    goto LABEL_409;
                                  }
                                }
                              }
LABEL_410:
                              if (v177)
                                free(v177);
                              v2 = v305;
                              goto LABEL_102;
                            }
                          }
                        }
                        __nwlog_obj();
                        v164 = *(_QWORD *)(*(_QWORD *)(v2 + 1072) + 32);
                        v165 = "invalid";
                        if (v164)
                        {
                          v166 = *(const char **)(v164 + 16);
                          if (v166)
                            v165 = v166;
                        }
                        *(_DWORD *)buf = 136446466;
                        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v165;
                        v167 = (char *)_os_log_send_and_compose_impl();
                        type = OS_LOG_TYPE_ERROR;
                        v306 = 0;
                        if (__nwlog_fault(v167, &type, &v306))
                        {
                          if (type == OS_LOG_TYPE_FAULT)
                          {
                            v168 = __nwlog_obj();
                            v169 = type;
                            if (os_log_type_enabled(v168, type))
                            {
                              v170 = *(_QWORD *)(*(_QWORD *)(v305 + 1072) + 32);
                              v171 = "invalid";
                              if (v170)
                              {
                                v172 = *(const char **)(v170 + 16);
                                if (v172)
                                  v171 = v172;
                              }
                              *(_DWORD *)buf = 136446466;
                              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                              *(_WORD *)&buf[12] = 2082;
                              *(_QWORD *)&buf[14] = v171;
                              v173 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
LABEL_400:
                              _os_log_impl(&dword_182FBE000, v168, v169, v173, buf, 0x16u);
                            }
                          }
                          else if (v306)
                          {
                            v216 = (char *)__nw_create_backtrace_string();
                            v168 = __nwlog_obj();
                            v169 = type;
                            v217 = os_log_type_enabled(v168, type);
                            if (v216)
                            {
                              if (v217)
                              {
                                v218 = *(_QWORD *)(*(_QWORD *)(v305 + 1072) + 32);
                                v219 = "invalid";
                                if (v218)
                                {
                                  v220 = *(const char **)(v218 + 16);
                                  if (v220)
                                    v219 = v220;
                                }
                                *(_DWORD *)buf = 136446722;
                                *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                                *(_WORD *)&buf[12] = 2082;
                                *(_QWORD *)&buf[14] = v219;
                                *(_WORD *)&buf[22] = 2082;
                                v309 = v216;
                                _os_log_impl(&dword_182FBE000, v168, v169, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                              }
                              free(v216);
                              goto LABEL_401;
                            }
                            if (v217)
                            {
                              v267 = *(_QWORD *)(*(_QWORD *)(v305 + 1072) + 32);
                              v268 = "invalid";
                              if (v267)
                              {
                                v269 = *(const char **)(v267 + 16);
                                if (v269)
                                  v268 = v269;
                              }
                              *(_DWORD *)buf = 136446466;
                              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                              *(_WORD *)&buf[12] = 2082;
                              *(_QWORD *)&buf[14] = v268;
                              v173 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
                              goto LABEL_400;
                            }
                          }
                          else
                          {
                            v168 = __nwlog_obj();
                            v169 = type;
                            if (os_log_type_enabled(v168, type))
                            {
                              v249 = *(_QWORD *)(*(_QWORD *)(v305 + 1072) + 32);
                              v250 = "invalid";
                              if (v249)
                              {
                                v251 = *(const char **)(v249 + 16);
                                if (v251)
                                  v250 = v251;
                              }
                              *(_DWORD *)buf = 136446466;
                              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                              *(_WORD *)&buf[12] = 2082;
                              *(_QWORD *)&buf[14] = v250;
                              v173 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
                              goto LABEL_400;
                            }
                          }
                        }
LABEL_401:
                        if (v167)
                          free(v167);
                        v2 = v305;
                        goto LABEL_92;
                      }
                    }
                  }
                  __nwlog_obj();
                  v154 = *(_QWORD *)(*(_QWORD *)(v2 + 1064) + 32);
                  v155 = "invalid";
                  if (v154)
                  {
                    v156 = *(const char **)(v154 + 16);
                    if (v156)
                      v155 = v156;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v155;
                  v157 = (char *)_os_log_send_and_compose_impl();
                  type = OS_LOG_TYPE_ERROR;
                  v306 = 0;
                  if (__nwlog_fault(v157, &type, &v306))
                  {
                    if (type == OS_LOG_TYPE_FAULT)
                    {
                      v158 = __nwlog_obj();
                      v159 = type;
                      if (os_log_type_enabled(v158, type))
                      {
                        v160 = *(_QWORD *)(*(_QWORD *)(v305 + 1064) + 32);
                        v161 = "invalid";
                        if (v160)
                        {
                          v162 = *(const char **)(v160 + 16);
                          if (v162)
                            v161 = v162;
                        }
                        *(_DWORD *)buf = 136446466;
                        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v161;
                        v163 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
LABEL_391:
                        _os_log_impl(&dword_182FBE000, v158, v159, v163, buf, 0x16u);
                      }
                    }
                    else if (v306)
                    {
                      v211 = (char *)__nw_create_backtrace_string();
                      v158 = __nwlog_obj();
                      v159 = type;
                      v212 = os_log_type_enabled(v158, type);
                      if (v211)
                      {
                        if (v212)
                        {
                          v213 = *(_QWORD *)(*(_QWORD *)(v305 + 1064) + 32);
                          v214 = "invalid";
                          if (v213)
                          {
                            v215 = *(const char **)(v213 + 16);
                            if (v215)
                              v214 = v215;
                          }
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v214;
                          *(_WORD *)&buf[22] = 2082;
                          v309 = v211;
                          _os_log_impl(&dword_182FBE000, v158, v159, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                        }
                        free(v211);
                        goto LABEL_392;
                      }
                      if (v212)
                      {
                        v264 = *(_QWORD *)(*(_QWORD *)(v305 + 1064) + 32);
                        v265 = "invalid";
                        if (v264)
                        {
                          v266 = *(const char **)(v264 + 16);
                          if (v266)
                            v265 = v266;
                        }
                        *(_DWORD *)buf = 136446466;
                        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v265;
                        v163 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
                        goto LABEL_391;
                      }
                    }
                    else
                    {
                      v158 = __nwlog_obj();
                      v159 = type;
                      if (os_log_type_enabled(v158, type))
                      {
                        v246 = *(_QWORD *)(*(_QWORD *)(v305 + 1064) + 32);
                        v247 = "invalid";
                        if (v246)
                        {
                          v248 = *(const char **)(v246 + 16);
                          if (v248)
                            v247 = v248;
                        }
                        *(_DWORD *)buf = 136446466;
                        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                        *(_WORD *)&buf[12] = 2082;
                        *(_QWORD *)&buf[14] = v247;
                        v163 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
                        goto LABEL_391;
                      }
                    }
                  }
LABEL_392:
                  if (v157)
                    free(v157);
                  v2 = v305;
                  goto LABEL_86;
                }
              }
            }
            __nwlog_obj();
            v144 = *(_QWORD *)(*(_QWORD *)(v2 + 1056) + 32);
            v145 = "invalid";
            if (v144)
            {
              v146 = *(const char **)(v144 + 16);
              if (v146)
                v145 = v146;
            }
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v145;
            v147 = (char *)_os_log_send_and_compose_impl();
            type = OS_LOG_TYPE_ERROR;
            v306 = 0;
            if (__nwlog_fault(v147, &type, &v306))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                v148 = __nwlog_obj();
                v149 = type;
                if (os_log_type_enabled(v148, type))
                {
                  v150 = *(_QWORD *)(*(_QWORD *)(v305 + 1056) + 32);
                  v151 = "invalid";
                  if (v150)
                  {
                    v152 = *(const char **)(v150 + 16);
                    if (v152)
                      v151 = v152;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v151;
                  v153 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
LABEL_382:
                  _os_log_impl(&dword_182FBE000, v148, v149, v153, buf, 0x16u);
                }
              }
              else if (v306)
              {
                v206 = (char *)__nw_create_backtrace_string();
                v148 = __nwlog_obj();
                v149 = type;
                v207 = os_log_type_enabled(v148, type);
                if (v206)
                {
                  if (v207)
                  {
                    v208 = *(_QWORD *)(*(_QWORD *)(v305 + 1056) + 32);
                    v209 = "invalid";
                    if (v208)
                    {
                      v210 = *(const char **)(v208 + 16);
                      if (v210)
                        v209 = v210;
                    }
                    *(_DWORD *)buf = 136446722;
                    *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v209;
                    *(_WORD *)&buf[22] = 2082;
                    v309 = v206;
                    _os_log_impl(&dword_182FBE000, v148, v149, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }
                  free(v206);
                  goto LABEL_383;
                }
                if (v207)
                {
                  v261 = *(_QWORD *)(*(_QWORD *)(v305 + 1056) + 32);
                  v262 = "invalid";
                  if (v261)
                  {
                    v263 = *(const char **)(v261 + 16);
                    if (v263)
                      v262 = v263;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v262;
                  v153 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
                  goto LABEL_382;
                }
              }
              else
              {
                v148 = __nwlog_obj();
                v149 = type;
                if (os_log_type_enabled(v148, type))
                {
                  v243 = *(_QWORD *)(*(_QWORD *)(v305 + 1056) + 32);
                  v244 = "invalid";
                  if (v243)
                  {
                    v245 = *(const char **)(v243 + 16);
                    if (v245)
                      v244 = v245;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v244;
                  v153 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
                  goto LABEL_382;
                }
              }
            }
LABEL_383:
            if (v147)
              free(v147);
            v2 = v305;
            goto LABEL_76;
          }
        }
      }
      __nwlog_obj();
      v135 = *(_QWORD *)(*(_QWORD *)(v305 + 1048) + 32);
      v136 = "invalid";
      if (v135)
      {
        v137 = *(const char **)(v135 + 16);
        if (v137)
          v136 = v137;
      }
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v136;
      v138 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v306 = 0;
      if (__nwlog_fault(v138, &type, &v306))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v139 = __nwlog_obj();
          v140 = type;
          if (os_log_type_enabled(v139, type))
          {
            v141 = *(_QWORD *)(*(_QWORD *)(v305 + 1048) + 32);
            v142 = "invalid";
            if (v141)
            {
              v143 = *(const char **)(v141 + 16);
              if (v143)
                v142 = v143;
            }
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v142;
            _os_log_impl(&dword_182FBE000, v139, v140, "%{public}s protocol %{public}s has invalid remove_input_handler callback", buf, 0x16u);
          }
          goto LABEL_374;
        }
        if (v306)
        {
          v199 = (char *)__nw_create_backtrace_string();
          v200 = __nwlog_obj();
          v201 = type;
          v202 = os_log_type_enabled(v200, type);
          if (v199)
          {
            if (v202)
            {
              v203 = *(_QWORD *)(*(_QWORD *)(v305 + 1048) + 32);
              v204 = "invalid";
              if (v203)
              {
                v205 = *(const char **)(v203 + 16);
                if (v205)
                  v204 = v205;
              }
              *(_DWORD *)buf = 136446722;
              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v204;
              *(_WORD *)&buf[22] = 2082;
              v309 = v199;
              _os_log_impl(&dword_182FBE000, v200, v201, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
              v39 = (_QWORD *)&unk_183BA7000;
            }
            free(v199);
            goto LABEL_374;
          }
          if (v202)
          {
            v258 = *(_QWORD *)(*(_QWORD *)(v305 + 1048) + 32);
            v259 = "invalid";
            if (v258)
            {
              v260 = *(const char **)(v258 + 16);
              if (v260)
                v259 = v260;
            }
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v259;
            v242 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_373:
            _os_log_impl(&dword_182FBE000, v200, v201, v242, buf, 0x16u);
            v39 = (_QWORD *)&unk_183BA7000;
          }
        }
        else
        {
          v200 = __nwlog_obj();
          v201 = type;
          if (os_log_type_enabled(v200, type))
          {
            v239 = *(_QWORD *)(*(_QWORD *)(v305 + 1048) + 32);
            v240 = "invalid";
            if (v239)
            {
              v241 = *(const char **)(v239 + 16);
              if (v241)
                v240 = v241;
            }
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v240;
            v242 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
            goto LABEL_373;
          }
        }
      }
LABEL_374:
      if (v138)
        free(v138);
      v2 = v305;
      goto LABEL_70;
    }
    if (((v29 | (*((unsigned __int8 *)v3 + 2) << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v237 = __nwlog_obj();
        if (os_log_type_enabled(v237, OS_LOG_TYPE_DEBUG))
        {
          v238 = *(_DWORD *)(v2 + 1280);
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v2 + 1289;
          *(_WORD *)&buf[22] = 2080;
          v309 = " ";
          LOWORD(v310) = 1024;
          *(_DWORD *)((char *)&v310 + 2) = v238;
          _os_log_impl(&dword_182FBE000, v237, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> stopping control stream", buf, 0x26u);
        }
      }
    }
    v30 = *(_QWORD *)(v2 + 1088);
    if (v30)
    {
      if (*(_QWORD *)v30)
      {
        v31 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)v30 + 8);
        if (v31)
          v31(v30, v2);
      }
    }
    v32 = *(_QWORD *)(v2 + 32);
    if (v32)
    {
      v33 = *(_QWORD *)(v32 + 24);
      if (v33)
      {
        v34 = *(void (**)(uint64_t, uint64_t))(v33 + 240);
        if (v34)
        {
          v34(v32, v2 + 136);
          v35 = *(_QWORD *)(v2 + 32);
          if (!v35)
            goto LABEL_424;
LABEL_49:
          v36 = *(_QWORD *)(v35 + 24);
          if (v36)
          {
            v37 = *(void (**)(uint64_t, uint64_t))(v36 + 8);
            if (v37)
            {
              v37(v35, v2);
              goto LABEL_52;
            }
          }
LABEL_424:
          __nwlog_obj();
          v276 = *(_QWORD *)(v2 + 32);
          v277 = "invalid";
          if (v276)
          {
            v278 = *(const char **)(v276 + 16);
            if (v278)
              v277 = v278;
          }
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v277;
          v279 = (char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v306 = 0;
          if (!__nwlog_fault(v279, &type, &v306))
            goto LABEL_453;
          if (type == OS_LOG_TYPE_FAULT)
          {
            v280 = __nwlog_obj();
            v281 = type;
            if (os_log_type_enabled(v280, type))
            {
              v282 = *(_QWORD *)(v305 + 32);
              v283 = "invalid";
              if (v282)
              {
                v284 = *(const char **)(v282 + 16);
                if (v284)
                  v283 = v284;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v283;
              v285 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
LABEL_452:
              _os_log_impl(&dword_182FBE000, v280, v281, v285, buf, 0x16u);
            }
          }
          else if (v306)
          {
            v286 = (char *)__nw_create_backtrace_string();
            v280 = __nwlog_obj();
            v281 = type;
            v287 = os_log_type_enabled(v280, type);
            if (v286)
            {
              if (v287)
              {
                v288 = *(_QWORD *)(v305 + 32);
                v289 = "invalid";
                if (v288)
                {
                  v290 = *(const char **)(v288 + 16);
                  if (v290)
                    v289 = v290;
                }
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v289;
                *(_WORD *)&buf[22] = 2082;
                v309 = v286;
                _os_log_impl(&dword_182FBE000, v280, v281, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v286);
              goto LABEL_453;
            }
            if (v287)
            {
              v294 = *(_QWORD *)(v305 + 32);
              v295 = "invalid";
              if (v294)
              {
                v296 = *(const char **)(v294 + 16);
                if (v296)
                  v295 = v296;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v295;
              v285 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
              goto LABEL_452;
            }
          }
          else
          {
            v280 = __nwlog_obj();
            v281 = type;
            if (os_log_type_enabled(v280, type))
            {
              v291 = *(_QWORD *)(v305 + 32);
              v292 = "invalid";
              if (v291)
              {
                v293 = *(const char **)(v291 + 16);
                if (v293)
                  v292 = v293;
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v292;
              v285 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
              goto LABEL_452;
            }
          }
LABEL_453:
          if (v279)
            free(v279);
          v2 = v305;
          goto LABEL_52;
        }
      }
    }
    __nwlog_obj();
    v184 = *(_QWORD *)(v2 + 32);
    v185 = "invalid";
    if (v184)
    {
      v186 = *(const char **)(v184 + 16);
      if (v186)
        v185 = v186;
    }
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v185;
    v187 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v306 = 0;
    if (__nwlog_fault(v187, &type, &v306))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v188 = __nwlog_obj();
        v189 = type;
        if (!os_log_type_enabled(v188, type))
          goto LABEL_421;
        v190 = *(_QWORD *)(v305 + 32);
        v191 = "invalid";
        if (v190)
        {
          v192 = *(const char **)(v190 + 16);
          if (v192)
            v191 = v192;
        }
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v191;
        v193 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback";
LABEL_420:
        _os_log_impl(&dword_182FBE000, v188, v189, v193, buf, 0x16u);
        goto LABEL_421;
      }
      if (!v306)
      {
        v188 = __nwlog_obj();
        v189 = type;
        if (!os_log_type_enabled(v188, type))
          goto LABEL_421;
        v255 = *(_QWORD *)(v305 + 32);
        v256 = "invalid";
        if (v255)
        {
          v257 = *(const char **)(v255 + 16);
          if (v257)
            v256 = v257;
        }
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v256;
        v193 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, backtrace limit exceeded";
        goto LABEL_420;
      }
      v226 = (char *)__nw_create_backtrace_string();
      v188 = __nwlog_obj();
      v189 = type;
      v227 = os_log_type_enabled(v188, type);
      if (!v226)
      {
        if (!v227)
          goto LABEL_421;
        v273 = *(_QWORD *)(v305 + 32);
        v274 = "invalid";
        if (v273)
        {
          v275 = *(const char **)(v273 + 16);
          if (v275)
            v274 = v275;
        }
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v274;
        v193 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, no backtrace";
        goto LABEL_420;
      }
      if (v227)
      {
        v228 = *(_QWORD *)(v305 + 32);
        v229 = "invalid";
        if (v228)
        {
          v230 = *(const char **)(v228 + 16);
          if (v230)
            v229 = v230;
        }
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "nw_http3_teardown_uni_streams";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v229;
        *(_WORD *)&buf[22] = 2082;
        v309 = v226;
        _os_log_impl(&dword_182FBE000, v188, v189, "%{public}s protocol %{public}s has invalid remove_listen_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v226);
    }
LABEL_421:
    if (v187)
      free(v187);
    v2 = v305;
    v35 = *(_QWORD *)(v305 + 32);
    if (!v35)
      goto LABEL_424;
    goto LABEL_49;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
  v110 = (void *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v306 = 0;
  if (!__nwlog_fault((const char *)v110, &type, &v306))
  {
LABEL_459:
    if (!v110)
      return;
LABEL_207:
    free(v110);
    return;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    v194 = __nwlog_obj();
    v195 = type;
    if (!os_log_type_enabled(v194, type))
      goto LABEL_459;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
    v196 = "%{public}s called with null http3";
LABEL_458:
    _os_log_impl(&dword_182FBE000, v194, v195, v196, buf, 0xCu);
    goto LABEL_459;
  }
  if (!v306)
  {
    v194 = __nwlog_obj();
    v195 = type;
    if (!os_log_type_enabled(v194, type))
      goto LABEL_459;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
    v196 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_458;
  }
  v235 = (char *)__nw_create_backtrace_string();
  v194 = __nwlog_obj();
  v195 = type;
  v236 = os_log_type_enabled(v194, type);
  if (!v235)
  {
    if (!v236)
      goto LABEL_459;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
    v196 = "%{public}s called with null http3, no backtrace";
    goto LABEL_458;
  }
  if (v236)
  {
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_http3_connection_destroy";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v235;
    _os_log_impl(&dword_182FBE000, v194, v195, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v235);
  if (v110)
    goto LABEL_207;
}

void nw_protocol_http3_stream_destroy(uint64_t a1)
{
  unsigned __int16 *v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  char *backtrace_string;
  _BOOL4 v11;
  char *v12;
  NSObject *v13;
  os_log_type_t v14;
  const char *v15;
  char *v16;
  _BOOL4 v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  char *v22;
  _BOOL4 v23;
  void *v24;
  uint64_t v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  NSObject *v35;
  NSObject *v36;
  const void *v37;
  void *v38;
  const void *v39;
  void *v40;
  char v41;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  char *v46;
  __int16 v47;
  const char *v48;
  __int16 v49;
  int v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v2 = (unsigned __int16 *)(a1 + 736);
  if ((*(_WORD *)(a1 + 736) & 0x800) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v3 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      v4 = *(_DWORD *)(*(_QWORD *)(a1 + 336) + 1280);
      v5 = *(_QWORD *)(a1 + 240);
      *(_DWORD *)buf = 136447490;
      v44 = "nw_protocol_http3_stream_destroy";
      v45 = 2082;
      v46 = (char *)(a1 + 636);
      v47 = 2080;
      v48 = " ";
      v49 = 1024;
      v50 = v4;
      v51 = 2048;
      v52 = v5;
      v53 = 2048;
      v54 = a1;
      _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%llu> destroying stream %p", buf, 0x3Au);
    }
  }
  if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x80000) != 0)
    nw_http_transaction_metadata_set_event_handler(*(void **)(a1 + 392), 0);
  if (*(_QWORD *)(a1 + 216))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v44 = "nw_protocol_http3_stream_destroy";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v41 = 0;
    if (!__nwlog_fault(v6, &type, &v41))
      goto LABEL_21;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v9 = "%{public}s should not have unprocessed input frames left when destroying";
    }
    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v44 = "nw_protocol_http3_stream_destroy";
          v45 = 2082;
          v46 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v7, v8, "%{public}s should not have unprocessed input frames left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (!v11)
      {
LABEL_21:
        if (v6)
          free(v6);
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v9 = "%{public}s should not have unprocessed input frames left when destroying, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v7 = gLogObj;
      v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_21;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v9 = "%{public}s should not have unprocessed input frames left when destroying, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v7, v8, v9, buf, 0xCu);
    goto LABEL_21;
  }
LABEL_23:
  if (!*(_QWORD *)(a1 + 176))
    goto LABEL_40;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v44 = "nw_protocol_http3_stream_destroy";
  v12 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v12, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v15 = "%{public}s should not have unprocessed framer input frames left when destroying";
      goto LABEL_37;
    }
    if (!v41)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v13 = gLogObj;
      v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_38;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v15 = "%{public}s should not have unprocessed framer input frames left when destroying, backtrace limit exceeded";
      goto LABEL_37;
    }
    v16 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v13 = gLogObj;
    v14 = type;
    v17 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v16)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_protocol_http3_stream_destroy";
        v45 = 2082;
        v46 = v16;
        _os_log_impl(&dword_182FBE000, v13, v14, "%{public}s should not have unprocessed framer input frames left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v16);
      goto LABEL_38;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v15 = "%{public}s should not have unprocessed framer input frames left when destroying, no backtrace";
LABEL_37:
      _os_log_impl(&dword_182FBE000, v13, v14, v15, buf, 0xCu);
    }
  }
LABEL_38:
  if (v12)
    free(v12);
LABEL_40:
  if (!*(_QWORD *)(a1 + 376))
    goto LABEL_57;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  v44 = "nw_protocol_http3_stream_destroy";
  v18 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v41 = 0;
  if (__nwlog_fault(v18, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      v20 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_55;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v21 = "%{public}s should not have input_fields_frame left when destroying";
      goto LABEL_54;
    }
    if (!v41)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v19 = gLogObj;
      v20 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type))
        goto LABEL_55;
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v21 = "%{public}s should not have input_fields_frame left when destroying, backtrace limit exceeded";
      goto LABEL_54;
    }
    v22 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = gLogObj;
    v20 = type;
    v23 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v22)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        v44 = "nw_protocol_http3_stream_destroy";
        v45 = 2082;
        v46 = v22;
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s should not have input_fields_frame left when destroying, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v22);
      goto LABEL_55;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      v44 = "nw_protocol_http3_stream_destroy";
      v21 = "%{public}s should not have input_fields_frame left when destroying, no backtrace";
LABEL_54:
      _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
    }
  }
LABEL_55:
  if (v18)
    free(v18);
LABEL_57:
  nw_frame_reset(*(_QWORD *)(a1 + 384), 0, 0, 0, 0);
  v24 = *(void **)(a1 + 384);
  if (v24)
  {
    os_release(v24);
    *(_QWORD *)(a1 + 384) = 0;
  }
  v25 = *(_QWORD *)(a1 + 608);
  v26 = *(_QWORD **)(a1 + 616);
  if (v25)
  {
    *(_QWORD *)(v25 + 616) = v26;
    v26 = *(_QWORD **)(a1 + 616);
  }
  else
  {
    if (!v26)
      goto LABEL_64;
    *(_QWORD *)(*(_QWORD *)(a1 + 336) + 968) = v26;
  }
  *v26 = v25;
  *(_QWORD *)(a1 + 608) = 0;
  *(_QWORD *)(a1 + 616) = 0;
LABEL_64:
  v27 = *(void **)(a1 + 344);
  if (v27)
  {
    os_release(v27);
    *(_QWORD *)(a1 + 344) = 0;
  }
  v28 = *(void **)(a1 + 352);
  if (v28)
  {
    os_release(v28);
    *(_QWORD *)(a1 + 352) = 0;
  }
  v29 = *(void **)(a1 + 360);
  if (v29)
  {
    os_release(v29);
    *(_QWORD *)(a1 + 360) = 0;
  }
  v30 = *(void **)(a1 + 392);
  if (v30)
  {
    os_release(v30);
    *(_QWORD *)(a1 + 392) = 0;
  }
  v31 = *(void **)(a1 + 536);
  if (v31)
  {
    os_release(v31);
    *(_QWORD *)(a1 + 536) = 0;
  }
  v32 = *(void **)(a1 + 416);
  if (v32)
  {
    os_release(v32);
    *(_QWORD *)(a1 + 416) = 0;
  }
  v33 = *(void **)(a1 + 424);
  if (v33)
  {
    os_release(v33);
    *(_QWORD *)(a1 + 424) = 0;
  }
  v34 = *(void **)(a1 + 488);
  if (v34)
  {
    free(v34);
    *(_QWORD *)(a1 + 488) = 0;
  }
  v35 = *(NSObject **)(a1 + 520);
  if (v35)
  {
    dispatch_release(v35);
    *(_QWORD *)(a1 + 520) = 0;
  }
  v36 = *(NSObject **)(a1 + 528);
  if (v36)
  {
    dispatch_release(v36);
    *(_QWORD *)(a1 + 528) = 0;
  }
  (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 328) + 16))(*(_QWORD *)(a1 + 328), 0);
  v37 = *(const void **)(a1 + 328);
  if (v37)
  {
    _Block_release(v37);
    *(_QWORD *)(a1 + 328) = 0;
  }
  if ((*(_BYTE *)(a1 + 512) & 1) != 0)
  {
    v38 = *(void **)(a1 + 504);
    if (v38)
      os_release(v38);
  }
  *(_QWORD *)(a1 + 504) = 0;
  if ((*(_BYTE *)(a1 + 440) & 1) != 0)
  {
    v39 = *(const void **)(a1 + 432);
    if (v39)
      _Block_release(v39);
  }
  *(_QWORD *)(a1 + 432) = 0;
  if ((*(_BYTE *)(a1 + 408) & 1) != 0)
  {
    v40 = *(void **)(a1 + 400);
    if (v40)
      os_release(v40);
  }
  free((void *)a1);
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_60151(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = *(_QWORD **)(a2 + 40);
  if (v2)
  {
    *(_QWORD *)(v2 + 40) = v3;
    v3 = *(_QWORD **)(a2 + 40);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v3;
  }
  *v3 = v2;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

void nw_protocol_http3_uni_stream_destroy(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  const void *v8;
  NSObject *v9;
  os_log_type_t v10;
  const char *v11;
  NSObject *v12;
  char *v13;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = a1;
    if (gLogDatapath)
    {
      v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        _os_log_impl(&dword_182FBE000, v12, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
      }
    }
    if (!*(_QWORD *)(v1 + 104))
      goto LABEL_20;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v19 = 2048;
    v20 = v1;
    v2 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v15 = 0;
    if (__nwlog_fault(v2, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        v4 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_18;
        *(_DWORD *)buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        v5 = "%{public}s unistream %p input_frames_unprocessed is not empty";
        goto LABEL_17;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v3 = gLogObj;
        v4 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_18;
        *(_DWORD *)buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        v5 = "%{public}s unistream %p input_frames_unprocessed is not empty, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v3 = gLogObj;
      v4 = type;
      v7 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446722;
          v18 = "nw_protocol_http3_uni_stream_destroy";
          v19 = 2048;
          v20 = v1;
          v21 = 2082;
          v22 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s unistream %p input_frames_unprocessed is not empty, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "nw_protocol_http3_uni_stream_destroy";
        v19 = 2048;
        v20 = v1;
        v5 = "%{public}s unistream %p input_frames_unprocessed is not empty, no backtrace";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0x16u);
      }
    }
LABEL_18:
    if (v2)
      free(v2);
LABEL_20:
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v1 + 96) + 16))(*(_QWORD *)(v1 + 96), 0);
    v8 = *(const void **)(v1 + 96);
    if (v8)
      _Block_release(v8);
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_protocol_http3_uni_stream_destroy";
  v1 = _os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (!__nwlog_fault((const char *)v1, &type, &v15))
    goto LABEL_40;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream";
    goto LABEL_39;
  }
  if (!v15)
  {
    v9 = __nwlog_obj();
    v10 = type;
    if (!os_log_type_enabled(v9, type))
      goto LABEL_40;
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream, backtrace limit exceeded";
    goto LABEL_39;
  }
  v13 = (char *)__nw_create_backtrace_string();
  v9 = __nwlog_obj();
  v10 = type;
  v14 = os_log_type_enabled(v9, type);
  if (v13)
  {
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      v18 = "nw_protocol_http3_uni_stream_destroy";
      v19 = 2082;
      v20 = (uint64_t)v13;
      _os_log_impl(&dword_182FBE000, v9, v10, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v13);
    if (v1)
      goto LABEL_22;
    return;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446210;
    v18 = "nw_protocol_http3_uni_stream_destroy";
    v11 = "%{public}s called with null http3_stream, no backtrace";
LABEL_39:
    _os_log_impl(&dword_182FBE000, v9, v10, v11, buf, 0xCu);
  }
LABEL_40:
  if (v1)
LABEL_22:
    free((void *)v1);
}

uint64_t nw_http3_stream_get_application_error(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t (*v3)(void);
  unsigned __int8 *v4;
  uint64_t v5;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v1 = *(_QWORD *)(a1 + 32);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 24);
    if (v2)
    {
      v3 = *(uint64_t (**)(void))(v2 + 224);
      if (v3)
      {
        v4 = (unsigned __int8 *)v3();
        v7[0] = MEMORY[0x1E0C809B0];
        v7[1] = 0x40000000;
        v7[2] = ___ZL37nw_http3_stream_get_application_errorP24nw_protocol_http3_stream_block_invoke;
        v7[3] = &unk_1E14A7AB0;
        v7[4] = &v8;
        nw_array_apply(v4, (uint64_t)v7);
        if (v4)
          os_release(v4);
      }
    }
  }
  v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

BOOL ___ZL37nw_http3_stream_get_application_errorP24nw_protocol_http3_stream_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  _BOOL4 is_quic_stream;

  is_quic_stream = nw_protocol_metadata_is_quic_stream(a3);
  if (is_quic_stream)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = nw_quic_stream_get_application_error(a3);
  return !is_quic_stream;
}

void nw_http3_stream_fields_unblocked(_QWORD *a1)
{
  _QWORD *v2;
  NSObject *v3;
  const char *v4;
  const char *v5;
  int v6;
  uint64_t v7;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1 || (a1[92] & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      v3 = __nwlog_obj();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      {
        v4 = (char *)a1 + 636;
        v5 = " ";
        v6 = *(_DWORD *)(a1[42] + 1280);
        v7 = a1[30];
        if (!a1)
        {
          v5 = "";
          v4 = "";
        }
        v8 = 136447234;
        v9 = "nw_http3_stream_fields_unblocked";
        v10 = 2082;
        v11 = v4;
        v12 = 2080;
        v13 = v5;
        v14 = 1024;
        v15 = v6;
        v16 = 2048;
        v17 = v7;
        _os_log_impl(&dword_182FBE000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> qpack unblocked", (uint8_t *)&v8, 0x30u);
      }
    }
  }
  a1[76] = 0;
  v2 = *(_QWORD **)(a1[42] + 968);
  a1[77] = v2;
  *v2 = a1;
  *(_QWORD *)(a1[42] + 968) = a1 + 76;
}

uint64_t nw_http3_stream_fields_prepare_decode(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  size_t v7;
  void *v8;
  void *v9;
  uint64_t result;
  NSObject *v11;
  void *v12;

  v5 = *(_QWORD *)(a1 + 496);
  if (v5 >= a3)
  {
    v9 = *(void **)(a1 + 488);
    if (!a2)
      goto LABEL_10;
    goto LABEL_12;
  }
  v6 = 2 * v5;
  if (v6 <= a3)
    v6 = a3;
  if (v6 <= 0x200)
    v7 = 512;
  else
    v7 = v6;
  *(_QWORD *)(a1 + 496) = v7;
  v8 = *(void **)(a1 + 488);
  if (v8)
  {
    v9 = (void *)nw_reallocf_type<char *>(v8, v7);
    goto LABEL_14;
  }
  v9 = malloc_type_malloc(v7, 0xF2B69DE5uLL);
  if (v9)
  {
LABEL_14:
    *(_QWORD *)(a1 + 488) = v9;
    v5 = *(_QWORD *)(a1 + 496);
    if (!a2)
    {
LABEL_10:
      *(_OWORD *)(a1 + 472) = 0u;
      *(_OWORD *)(a1 + 456) = 0u;
      if (v5 >= 0xFFFF)
        LOWORD(v5) = -1;
    }
LABEL_12:
    *(_QWORD *)(a1 + 448) = v9;
    *(_WORD *)(a1 + 474) = v5;
    return a1 + 448;
  }
  v11 = __nwlog_obj();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  v12 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v12);
  if (!(_DWORD)result)
  {
    free(v12);
    v9 = 0;
    goto LABEL_14;
  }
  __break(1u);
  return result;
}

uint64_t nw_http3_stream_fields_process_field(uint64_t a1, uint64_t a2)
{
  char *v3;
  size_t v4;
  char *v5;
  size_t v6;
  NSObject *v8;
  const char *v9;
  const char *v10;
  int v11;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  int v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  char *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = (char *)(*(_QWORD *)a2 + *(int *)(a2 + 16));
  v4 = *(unsigned __int16 *)(a2 + 24);
  v5 = (char *)(*(_QWORD *)a2 + *(int *)(a2 + 20));
  v6 = *(unsigned __int16 *)(a2 + 26);
  if (!a1 || (*(_WORD *)(a1 + 736) & 0x800) == 0)
  {
    if (gLogDatapath)
    {
      v8 = __nwlog_obj();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v9 = " ";
        v10 = (const char *)(a1 + 636);
        v11 = *(_DWORD *)(*(_QWORD *)(a1 + 336) + 1280);
        v12 = *(_QWORD *)(a1 + 240);
        if (!a1)
        {
          v9 = "";
          v10 = "";
        }
        v13 = 136448259;
        v14 = "nw_http3_stream_fields_process_field";
        v15 = 2082;
        v16 = v10;
        v17 = 2080;
        v18 = v9;
        v19 = 1024;
        v20 = v11;
        v21 = 2048;
        v22 = v12;
        v23 = 1040;
        v24 = v4;
        v25 = 2080;
        v26 = v3;
        v27 = 1040;
        v28 = v6;
        v29 = 2085;
        v30 = v5;
        _os_log_impl(&dword_182FBE000, v8, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> received header field %.*s: %{sensitive}.*s", (uint8_t *)&v13, 0x50u);
      }
    }
  }
  return (nw_http_parsed_fields_add(*(void **)(a1 + 504), v3, v4, v5, v6) - 1);
}

void ___ZL38nw_protocol_http3_get_listen_callbacksv_block_invoke()
{
  nw_protocol_http3_get_listen_callbacks(void)::listen_protocol_callbacks = (uint64_t)nw_protocol_http3_listen_protocol_new_flow;
  unk_1EDCE4BF8 = nw_protocol_http3_listen_protocol_disconnected;
}

BOOL nw_protocol_http3_listen_protocol_new_flow(nw_listen_protocol *a1, nw_endpoint *a2, nw_parameters *a3)
{
  char *handle;
  _WORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(_QWORD, uint64_t, _QWORD);
  unsigned __int8 *v12;
  void *v13;
  _BOOL4 has_datagram_variant_flow_id;
  void *v15;
  uint64_t datagram_variant_flow_id;
  uint64_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  void (**v26)(uint64_t, uint64_t);
  void (*v27)(uint64_t, uint64_t);
  uint64_t v28;
  void (*v29)(uint64_t, uint64_t);
  uint64_t id;
  uint64_t v31;
  int v32;
  void (***v33)(_QWORD, nw_endpoint *, nw_parameters *);
  int v34;
  uint64_t v35;
  int v36;
  _QWORD *v37;
  char v38;
  nw_protocol *protocol_handler;
  nw_protocol_callbacks *callbacks;
  void (*add_input_handler)(nw_protocol *, _QWORD *);
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  void *v45;
  int v46;
  uint64_t v47;
  int v48;
  unsigned int v49;
  _BOOL8 result;
  char *v51;
  NSObject *v52;
  os_log_type_t v53;
  const char *v54;
  NSObject *v55;
  int v56;
  char *backtrace_string;
  _BOOL4 v58;
  const char *v59;
  _BOOL4 v60;
  nw_protocol *v61;
  const char *v62;
  nw_protocol_identifier *identifier;
  char *v64;
  NSObject *v65;
  os_log_type_t v66;
  nw_protocol *v67;
  const char *v68;
  nw_protocol_identifier *v69;
  const char *v70;
  NSObject *v71;
  int v72;
  char *v73;
  _BOOL4 v74;
  nw_protocol *v75;
  const char *v76;
  nw_protocol_identifier *v77;
  NSObject *v78;
  void *v79;
  NSObject *v80;
  NSObject *v81;
  int v82;
  NSObject *v83;
  int v84;
  const char *v85;
  const char *v86;
  nw_protocol *v87;
  const char *v88;
  nw_protocol_identifier *v89;
  char *v90;
  NSObject *v91;
  os_log_type_t v92;
  const char *v93;
  const char *v94;
  char *v95;
  _BOOL4 v96;
  const char *v97;
  NSObject *v98;
  int v99;
  nw_endpoint *v100;
  nw_protocol *v101;
  const char *v102;
  nw_protocol_identifier *v103;
  const char *v104;
  const char *v105;
  char *v106;
  NSObject *v107;
  os_log_type_t v108;
  const char *v109;
  const char *v110;
  char *v111;
  _BOOL4 v112;
  const char *v113;
  const char *v114;
  const char *v115;
  _QWORD v116[5];
  char v117;
  _QWORD v118[5];
  uint64_t v119;
  uint64_t *v120;
  uint64_t v121;
  uint64_t v122;
  os_log_type_t type[8];
  os_log_type_t *v124;
  uint64_t v125;
  _QWORD *v126;
  _BYTE aBlock[24];
  uint64_t v128;
  os_log_type_t *v129;
  nw_endpoint *v130;
  __int16 v131;
  uint64_t v132;
  uint64_t v133;

  v133 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)aBlock = 136446210;
    *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
    v51 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v119) = 0;
    if (!__nwlog_fault(v51, type, &v119))
      goto LABEL_127;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v52 = __nwlog_obj();
      v53 = type[0];
      if (os_log_type_enabled(v52, type[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        v54 = "%{public}s called with null listener";
LABEL_126:
        _os_log_impl(&dword_182FBE000, v52, v53, v54, aBlock, 0xCu);
      }
LABEL_127:
      if (v51)
        free(v51);
      return 0;
    }
    if (!(_BYTE)v119)
    {
      v52 = __nwlog_obj();
      v53 = type[0];
      if (os_log_type_enabled(v52, type[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        v54 = "%{public}s called with null listener, backtrace limit exceeded";
        goto LABEL_126;
      }
      goto LABEL_127;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = type[0];
    v58 = os_log_type_enabled(v52, type[0]);
    if (!backtrace_string)
    {
      if (v58)
      {
        *(_DWORD *)aBlock = 136446210;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        v54 = "%{public}s called with null listener, no backtrace";
        goto LABEL_126;
      }
      goto LABEL_127;
    }
    if (v58)
    {
      *(_DWORD *)aBlock = 136446466;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = backtrace_string;
      v59 = "%{public}s called with null listener, dumping backtrace:%{public}s";
LABEL_82:
      _os_log_impl(&dword_182FBE000, v52, v53, v59, aBlock, 0x16u);
    }
LABEL_83:
    free(backtrace_string);
    goto LABEL_127;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)aBlock = 136446210;
    *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
    v51 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v119) = 0;
    if (!__nwlog_fault(v51, type, &v119))
      goto LABEL_127;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v52 = __nwlog_obj();
      v53 = type[0];
      if (os_log_type_enabled(v52, type[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        v54 = "%{public}s called with null http3";
        goto LABEL_126;
      }
      goto LABEL_127;
    }
    if (!(_BYTE)v119)
    {
      v52 = __nwlog_obj();
      v53 = type[0];
      if (os_log_type_enabled(v52, type[0]))
      {
        *(_DWORD *)aBlock = 136446210;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        v54 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_126;
      }
      goto LABEL_127;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v52 = __nwlog_obj();
    v53 = type[0];
    v60 = os_log_type_enabled(v52, type[0]);
    if (!backtrace_string)
    {
      if (v60)
      {
        *(_DWORD *)aBlock = 136446210;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        v54 = "%{public}s called with null http3, no backtrace";
        goto LABEL_126;
      }
      goto LABEL_127;
    }
    if (v60)
    {
      *(_DWORD *)aBlock = 136446466;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = backtrace_string;
      v59 = "%{public}s called with null http3, dumping backtrace:%{public}s";
      goto LABEL_82;
    }
    goto LABEL_83;
  }
  v7 = handle + 1373;
  if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
  {
    if (gLogDatapath)
    {
      v55 = __nwlog_obj();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
      {
        v56 = *((_DWORD *)handle + 320);
        *(_DWORD *)aBlock = 136447234;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = handle + 1289;
        *(_WORD *)&aBlock[22] = 2080;
        v128 = (uint64_t)" ";
        LOWORD(v129) = 1024;
        *(_DWORD *)((char *)&v129 + 2) = v56;
        HIWORD(v129) = 2112;
        v130 = a2;
        _os_log_impl(&dword_182FBE000, v55, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> creating new inbound flow from %@", aBlock, 0x30u);
      }
    }
  }
  v119 = 0;
  v120 = &v119;
  v121 = 0x2000000000;
  v122 = 0;
  v8 = *((_QWORD *)handle + 4);
  v9 = MEMORY[0x1E0C809B0];
  if (v8)
  {
    v10 = *(_QWORD *)(v8 + 24);
    if (v10)
    {
      v11 = *(uint64_t (**)(_QWORD, uint64_t, _QWORD))(v10 + 224);
      if (v11)
      {
        v12 = (unsigned __int8 *)v11(*((_QWORD *)handle + 4), 255, 0);
        v118[0] = v9;
        v118[1] = 0x40000000;
        v118[2] = ___ZL42nw_protocol_http3_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke;
        v118[3] = &unk_1E14A8608;
        v118[4] = &v119;
        nw_array_apply(v12, (uint64_t)v118);
        if (v12)
          os_release(v12);
      }
    }
  }
  v13 = (void *)v120[3];
  if (!v13)
    goto LABEL_59;
  has_datagram_variant_flow_id = nw_quic_stream_get_has_datagram_variant_flow_id(v13);
  v15 = (void *)v120[3];
  if (has_datagram_variant_flow_id)
  {
    datagram_variant_flow_id = nw_quic_stream_get_datagram_variant_flow_id(v15);
    if ((((unsigned __int16)*v7 | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v71 = __nwlog_obj();
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
        {
          v72 = *((_DWORD *)handle + 320);
          *(_DWORD *)aBlock = 136447234;
          *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
          *(_WORD *)&aBlock[12] = 2082;
          *(_QWORD *)&aBlock[14] = handle + 1289;
          *(_WORD *)&aBlock[22] = 2080;
          v128 = (uint64_t)" ";
          LOWORD(v129) = 1024;
          *(_DWORD *)((char *)&v129 + 2) = v72;
          HIWORD(v129) = 2048;
          v130 = (nw_endpoint *)datagram_variant_flow_id;
          _os_log_impl(&dword_182FBE000, v71, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Received datagram flow %llu", aBlock, 0x30u);
        }
      }
    }
    v17 = *((_QWORD *)handle + 110);
    if (!v17)
    {
LABEL_15:
      if ((((unsigned __int16)*v7 | (handle[1375] << 16)) & 0x400000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v18 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          v19 = *((_DWORD *)handle + 320);
          *(_DWORD *)aBlock = 136447234;
          *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
          *(_WORD *)&aBlock[12] = 2082;
          *(_QWORD *)&aBlock[14] = handle + 1289;
          *(_WORD *)&aBlock[22] = 2080;
          v128 = (uint64_t)" ";
          LOWORD(v129) = 1024;
          *(_DWORD *)((char *)&v129 + 2) = v19;
          HIWORD(v129) = 2048;
          v130 = (nw_endpoint *)datagram_variant_flow_id;
          v20 = "%{public}s %{public}s%s<i%u> Rejecting datagram flow ID %llu";
          v21 = v18;
          v22 = 48;
LABEL_58:
          _os_log_impl(&dword_182FBE000, v21, OS_LOG_TYPE_ERROR, v20, aBlock, v22);
          v47 = 0;
LABEL_62:
          _Block_object_dispose(&v119, 8);
          return v47;
        }
      }
LABEL_59:
      v47 = 0;
      goto LABEL_62;
    }
    while (1)
    {
      v23 = *(_QWORD *)(v17 + 544);
      if ((*(_WORD *)(v17 + 736) & 0x20) != 0 && datagram_variant_flow_id == *(_QWORD *)(v17 + 248))
        break;
      v17 = *(_QWORD *)(v17 + 544);
      if (!v23)
        goto LABEL_15;
    }
    if ((*(_WORD *)(v17 + 736) & 0x800) == 0)
    {
      if (gLogDatapath)
      {
        v98 = __nwlog_obj();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
        {
          v99 = *(_DWORD *)(*(_QWORD *)(v17 + 336) + 1280);
          v100 = *(nw_endpoint **)(v17 + 240);
          *(_DWORD *)aBlock = 136447490;
          *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
          *(_WORD *)&aBlock[12] = 2082;
          *(_QWORD *)&aBlock[14] = v17 + 636;
          *(_WORD *)&aBlock[22] = 2080;
          v128 = (uint64_t)" ";
          LOWORD(v129) = 1024;
          *(_DWORD *)((char *)&v129 + 2) = v99;
          HIWORD(v129) = 2048;
          v130 = v100;
          v131 = 2048;
          v132 = datagram_variant_flow_id;
          _os_log_impl(&dword_182FBE000, v98, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%llu> Accepting datagram flow ID %llu", aBlock, 0x3Au);
        }
      }
    }
    v24 = *(_WORD *)(v17 + 736) & 0xFFDF | (*(unsigned __int8 *)(v17 + 738) << 16);
    *(_WORD *)(v17 + 736) = *(_WORD *)(v17 + 736) & 0xFFCF | 0x10;
    *(_BYTE *)(v17 + 738) = BYTE2(v24);
    if (*(_DWORD *)(v17 + 372) == 4)
      *(_DWORD *)(v17 + 372) = 8;
    v25 = v17 + 64;
    nw_protocol_set_input_handler(v17 + 64, *(_QWORD *)(v17 + 48));
    *(_OWORD *)(v17 + 64) = *(_OWORD *)v17;
    if (v8)
    {
      v26 = *(void (***)(uint64_t, uint64_t))(v8 + 24);
      if (v26)
      {
        v27 = *v26;
        if (v27)
        {
          v27(v8, v17 + 64);
          nw_protocol_set_output_handler(v17 + 64, v8);
          goto LABEL_29;
        }
      }
      __nwlog_obj();
      v85 = *(const char **)(v8 + 16);
      if (!v85)
        v85 = "invalid";
    }
    else
    {
      __nwlog_obj();
      v85 = "invalid";
    }
    *(_DWORD *)aBlock = 136446466;
    *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
    *(_WORD *)&aBlock[12] = 2082;
    *(_QWORD *)&aBlock[14] = v85;
    v90 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v117 = 0;
    if (__nwlog_fault(v90, type, &v117))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v91 = __nwlog_obj();
        v92 = type[0];
        if (!os_log_type_enabled(v91, type[0]))
          goto LABEL_172;
        v93 = "invalid";
        if (v8 && *(_QWORD *)(v8 + 16))
          v93 = *(const char **)(v8 + 16);
        *(_DWORD *)aBlock = 136446466;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = v93;
        v94 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
LABEL_171:
        _os_log_impl(&dword_182FBE000, v91, v92, v94, aBlock, 0x16u);
        goto LABEL_172;
      }
      if (!v117)
      {
        v91 = __nwlog_obj();
        v92 = type[0];
        if (!os_log_type_enabled(v91, type[0]))
          goto LABEL_172;
        v104 = "invalid";
        if (v8 && *(_QWORD *)(v8 + 16))
          v104 = *(const char **)(v8 + 16);
        *(_DWORD *)aBlock = 136446466;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = v104;
        v94 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_171;
      }
      v95 = (char *)__nw_create_backtrace_string();
      v91 = __nwlog_obj();
      v92 = type[0];
      v96 = os_log_type_enabled(v91, type[0]);
      if (!v95)
      {
        if (!v96)
          goto LABEL_172;
        v105 = "invalid";
        if (v8 && *(_QWORD *)(v8 + 16))
          v105 = *(const char **)(v8 + 16);
        *(_DWORD *)aBlock = 136446466;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = v105;
        v94 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
        goto LABEL_171;
      }
      if (v96)
      {
        v97 = "invalid";
        if (v8 && *(_QWORD *)(v8 + 16))
          v97 = *(const char **)(v8 + 16);
        *(_DWORD *)aBlock = 136446722;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = v97;
        *(_WORD *)&aBlock[22] = 2082;
        v128 = (uint64_t)v95;
        _os_log_impl(&dword_182FBE000, v91, v92, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", aBlock, 0x20u);
      }
      free(v95);
    }
LABEL_172:
    if (v90)
      free(v90);
    nw_protocol_set_output_handler(v25, v8);
    if (!v8)
    {
      __nwlog_obj();
      v86 = "invalid";
      goto LABEL_176;
    }
LABEL_29:
    v28 = *(_QWORD *)(v8 + 24);
    if (v28)
    {
      v29 = *(void (**)(uint64_t, uint64_t))(v28 + 24);
      if (v29)
      {
        v29(v8, v25);
LABEL_61:
        v47 = 1;
        goto LABEL_62;
      }
    }
    __nwlog_obj();
    v86 = *(const char **)(v8 + 16);
    if (!v86)
      v86 = "invalid";
LABEL_176:
    *(_DWORD *)aBlock = 136446466;
    *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
    *(_WORD *)&aBlock[12] = 2082;
    *(_QWORD *)&aBlock[14] = v86;
    v106 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v117 = 0;
    if (!__nwlog_fault(v106, type, &v117))
      goto LABEL_202;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v107 = __nwlog_obj();
      v108 = type[0];
      if (!os_log_type_enabled(v107, type[0]))
        goto LABEL_202;
      v109 = "invalid";
      if (v8 && *(_QWORD *)(v8 + 16))
        v109 = *(const char **)(v8 + 16);
      *(_DWORD *)aBlock = 136446466;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = v109;
      v110 = "%{public}s protocol %{public}s has invalid connect callback";
    }
    else if (v117)
    {
      v111 = (char *)__nw_create_backtrace_string();
      v107 = __nwlog_obj();
      v108 = type[0];
      v112 = os_log_type_enabled(v107, type[0]);
      if (v111)
      {
        if (v112)
        {
          v113 = "invalid";
          if (v8 && *(_QWORD *)(v8 + 16))
            v113 = *(const char **)(v8 + 16);
          *(_DWORD *)aBlock = 136446722;
          *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
          *(_WORD *)&aBlock[12] = 2082;
          *(_QWORD *)&aBlock[14] = v113;
          *(_WORD *)&aBlock[22] = 2082;
          v128 = (uint64_t)v111;
          _os_log_impl(&dword_182FBE000, v107, v108, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", aBlock, 0x20u);
        }
        free(v111);
        goto LABEL_202;
      }
      if (!v112)
      {
LABEL_202:
        if (v106)
          free(v106);
        goto LABEL_61;
      }
      v115 = "invalid";
      if (v8 && *(_QWORD *)(v8 + 16))
        v115 = *(const char **)(v8 + 16);
      *(_DWORD *)aBlock = 136446466;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = v115;
      v110 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }
    else
    {
      v107 = __nwlog_obj();
      v108 = type[0];
      if (!os_log_type_enabled(v107, type[0]))
        goto LABEL_202;
      v114 = "invalid";
      if (v8 && *(_QWORD *)(v8 + 16))
        v114 = *(const char **)(v8 + 16);
      *(_DWORD *)aBlock = 136446466;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = v114;
      v110 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v107, v108, v110, aBlock, 0x16u);
    goto LABEL_202;
  }
  id = nw_quic_stream_get_id(v15);
  v31 = id;
  v32 = (handle[1375] >> 6) & 1;
  if (!gLogDatapath)
    LOBYTE(v32) = 1;
  if ((id & 2) == 0)
  {
    if ((v32 & 1) == 0)
    {
      v81 = __nwlog_obj();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
      {
        v82 = *((_DWORD *)handle + 320);
        *(_DWORD *)aBlock = 136446978;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = handle + 1289;
        *(_WORD *)&aBlock[22] = 2080;
        v128 = (uint64_t)" ";
        LOWORD(v129) = 1024;
        *(_DWORD *)((char *)&v129 + 2) = v82;
        _os_log_impl(&dword_182FBE000, v81, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> new incoming flow is bidi-stream, calling our listen handler", aBlock, 0x26u);
      }
    }
    v33 = (void (***)(_QWORD, nw_endpoint *, nw_parameters *))*((_QWORD *)handle + 136);
    v34 = (unsigned __int16)*v7 | (handle[1375] << 16);
    if (v33)
    {
      if ((*v7 & 1) != 0)
      {
        *((_QWORD *)handle + 123) = v31;
        handle[1375] = BYTE2(v34);
        *v7 = v34 | 0x8000;
        (**v33)(v33, a2, a3);
        v48 = (unsigned __int16)*v7;
        v49 = v48 & 0xFFFF7FFF | (handle[1375] << 16);
        *v7 = v48 & 0x7FFF;
        handle[1375] = BYTE2(v49);
        goto LABEL_61;
      }
      if ((v34 & 0x400000) != 0)
        goto LABEL_59;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_59;
      v36 = *((_DWORD *)handle + 320);
      *(_DWORD *)aBlock = 136446978;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = handle + 1289;
      *(_WORD *)&aBlock[22] = 2080;
      v128 = (uint64_t)" ";
      LOWORD(v129) = 1024;
      *(_DWORD *)((char *)&v129 + 2) = v36;
      v20 = "%{public}s %{public}s%s<i%u> Rejecting server initiated stream";
    }
    else
    {
      if ((v34 & 0x400000) != 0)
        goto LABEL_59;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v35 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        goto LABEL_59;
      v46 = *((_DWORD *)handle + 320);
      *(_DWORD *)aBlock = 136446978;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = handle + 1289;
      *(_WORD *)&aBlock[22] = 2080;
      v128 = (uint64_t)" ";
      LOWORD(v129) = 1024;
      *(_DWORD *)((char *)&v129 + 2) = v46;
      v20 = "%{public}s %{public}s%s<i%u> No listen handler found for inbound stream";
    }
    v21 = v35;
    v22 = 38;
    goto LABEL_58;
  }
  if ((v32 & 1) == 0)
  {
    v83 = __nwlog_obj();
    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
    {
      v84 = *((_DWORD *)handle + 320);
      *(_DWORD *)aBlock = 136446978;
      *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
      *(_WORD *)&aBlock[12] = 2082;
      *(_QWORD *)&aBlock[14] = handle + 1289;
      *(_WORD *)&aBlock[22] = 2080;
      v128 = (uint64_t)" ";
      LOWORD(v129) = 1024;
      *(_DWORD *)((char *)&v129 + 2) = v84;
      _os_log_impl(&dword_182FBE000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> New incoming flow is uni-stream, opening", aBlock, 0x26u);
    }
  }
  v37 = malloc_type_calloc(1uLL, 0x88uLL, 0xEAFB8F1AuLL);
  if (v37)
  {
LABEL_43:
    v37[16] = 0;
    *((_OWORD *)v37 + 6) = 0u;
    *((_OWORD *)v37 + 7) = 0u;
    *((_OWORD *)v37 + 4) = 0u;
    *((_OWORD *)v37 + 5) = 0u;
    *((_OWORD *)v37 + 2) = 0u;
    *((_OWORD *)v37 + 3) = 0u;
    *(_OWORD *)v37 = 0u;
    *((_OWORD *)v37 + 1) = 0u;
    if (gLogDatapath)
    {
      v80 = __nwlog_obj();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)aBlock = 136446466;
        *(_QWORD *)&aBlock[4] = "nw_http3_uni_stream_create_inbound";
        *(_WORD *)&aBlock[12] = 2048;
        *(_QWORD *)&aBlock[14] = v37;
        _os_log_impl(&dword_182FBE000, v80, OS_LOG_TYPE_DEBUG, "%{public}s created uni_stream %p", aBlock, 0x16u);
      }
    }
    *(_QWORD *)type = 0;
    v124 = type;
    v125 = 0x2000000000;
    v126 = v37;
    *(_QWORD *)aBlock = v9;
    *(_QWORD *)&aBlock[8] = 0x40000000;
    *(_QWORD *)&aBlock[16] = ___ZL34nw_http3_uni_stream_create_inboundP17nw_protocol_http3_block_invoke;
    v128 = (uint64_t)&unk_1E14A8658;
    v129 = type;
    v37[12] = _Block_copy(aBlock);
    _Block_object_dispose(type, 8);
    v37[2] = &g_http3_uni_stream_protocol_identifier;
    if (nw_protocol_http3_uni_stream_get_callbacks(void)::onceToken != -1)
      dispatch_once(&nw_protocol_http3_uni_stream_get_callbacks(void)::onceToken, &__block_literal_global_60_60293);
    v37[3] = &nw_protocol_http3_uni_stream_get_callbacks(void)::protocol_callbacks;
    v37[5] = v37;
    v38 = *((_BYTE *)v37 + 131);
    v37[9] = handle;
    v37[13] = 0;
    v37[14] = v37 + 13;
    *((_WORD *)v37 + 64) = 0;
    *((_BYTE *)v37 + 131) = v38 & 0xF2 | 8;
    *(_OWORD *)v37 = *(_OWORD *)handle;
    nw_protocol_set_input_handler((uint64_t)v37, (uint64_t)handle);
    protocol_handler = a1->protocol_handler;
    if (protocol_handler)
    {
      callbacks = protocol_handler->callbacks;
      if (callbacks)
      {
        add_input_handler = (void (*)(nw_protocol *, _QWORD *))callbacks->add_input_handler;
        if (add_input_handler)
        {
          add_input_handler(protocol_handler, v37);
LABEL_50:
          v42 = *((_QWORD *)handle + 112);
          v37[10] = v42;
          if (v42)
            v43 = (_QWORD *)(v42 + 88);
          else
            v43 = handle + 904;
          *v43 = v37 + 10;
          *((_QWORD *)handle + 112) = v37;
          v37[11] = handle + 896;
          v44 = v37[12];
          v45 = (void *)*((_QWORD *)handle + 157);
          v116[0] = v9;
          v116[1] = 0x40000000;
          v116[2] = ___ZL42nw_protocol_http3_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke_171;
          v116[3] = &unk_1E14A8630;
          v116[4] = v44;
          nw_queue_context_async(v45, v116);
          goto LABEL_61;
        }
      }
    }
    __nwlog_obj();
    v61 = a1->protocol_handler;
    v62 = "invalid";
    if (v61)
    {
      identifier = v61->identifier;
      if (identifier)
        v62 = (const char *)identifier;
    }
    *(_DWORD *)aBlock = 136446466;
    *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
    *(_WORD *)&aBlock[12] = 2082;
    *(_QWORD *)&aBlock[14] = v62;
    v64 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v117 = 0;
    if (__nwlog_fault(v64, type, &v117))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v65 = __nwlog_obj();
        v66 = type[0];
        if (!os_log_type_enabled(v65, type[0]))
          goto LABEL_159;
        v67 = a1->protocol_handler;
        v68 = "invalid";
        if (v67)
        {
          v69 = v67->identifier;
          if (v69)
            v68 = (const char *)v69;
        }
        *(_DWORD *)aBlock = 136446466;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = v68;
        v70 = "%{public}s protocol %{public}s has invalid add_input_handler callback";
        goto LABEL_158;
      }
      if (!v117)
      {
        v65 = __nwlog_obj();
        v66 = type[0];
        if (!os_log_type_enabled(v65, type[0]))
          goto LABEL_159;
        v87 = a1->protocol_handler;
        v88 = "invalid";
        if (v87)
        {
          v89 = v87->identifier;
          if (v89)
            v88 = (const char *)v89;
        }
        *(_DWORD *)aBlock = 136446466;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = v88;
        v70 = "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded";
        goto LABEL_158;
      }
      v73 = (char *)__nw_create_backtrace_string();
      v65 = __nwlog_obj();
      v66 = type[0];
      v74 = os_log_type_enabled(v65, type[0]);
      if (v73)
      {
        if (v74)
        {
          v75 = a1->protocol_handler;
          v76 = "invalid";
          if (v75)
          {
            v77 = v75->identifier;
            if (v77)
              v76 = (const char *)v77;
          }
          *(_DWORD *)aBlock = 136446722;
          *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
          *(_WORD *)&aBlock[12] = 2082;
          *(_QWORD *)&aBlock[14] = v76;
          *(_WORD *)&aBlock[22] = 2082;
          v128 = (uint64_t)v73;
          _os_log_impl(&dword_182FBE000, v65, v66, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", aBlock, 0x20u);
        }
        free(v73);
        goto LABEL_159;
      }
      if (v74)
      {
        v101 = a1->protocol_handler;
        v102 = "invalid";
        if (v101)
        {
          v103 = v101->identifier;
          if (v103)
            v102 = (const char *)v103;
        }
        *(_DWORD *)aBlock = 136446466;
        *(_QWORD *)&aBlock[4] = "nw_protocol_http3_listen_protocol_new_flow";
        *(_WORD *)&aBlock[12] = 2082;
        *(_QWORD *)&aBlock[14] = v102;
        v70 = "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace";
LABEL_158:
        _os_log_impl(&dword_182FBE000, v65, v66, v70, aBlock, 0x16u);
      }
    }
LABEL_159:
    if (v64)
      free(v64);
    goto LABEL_50;
  }
  v78 = __nwlog_obj();
  os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
  *(_DWORD *)aBlock = 136446722;
  *(_QWORD *)&aBlock[4] = "strict_calloc";
  *(_WORD *)&aBlock[12] = 2048;
  *(_QWORD *)&aBlock[14] = 1;
  *(_WORD *)&aBlock[22] = 2048;
  v128 = 136;
  v79 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v79);
  if (!result)
  {
    free(v79);
    goto LABEL_43;
  }
  __break(1u);
  return result;
}

void nw_protocol_http3_listen_protocol_disconnected(nw_listen_protocol *a1, nw_protocol *a2)
{
  char *handle;
  nw_protocol_callbacks *callbacks;
  void (*remove_listen_handler)(nw_protocol *, char *);
  nw_protocol_identifier *identifier;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  nw_protocol_identifier *v14;
  const char *v15;
  char *v16;
  _BOOL4 v17;
  nw_protocol_identifier *v18;
  NSObject *v19;
  int v20;
  nw_protocol_identifier *v21;
  char *backtrace_string;
  _BOOL4 v23;
  char *v24;
  _BOOL4 v25;
  nw_protocol_identifier *v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  nw_protocol_identifier *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_http3_listen_protocol_disconnected";
    v7 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v7, &type, &v27))
      goto LABEL_74;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_http3_listen_protocol_disconnected";
      v10 = "%{public}s called with null listener";
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v8 = __nwlog_obj();
      v9 = type;
      v23 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v30 = "nw_protocol_http3_listen_protocol_disconnected";
          v31 = 2082;
          v32 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_74:
        if (!v7)
          return;
LABEL_75:
        free(v7);
        return;
      }
      if (!v23)
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_http3_listen_protocol_disconnected";
      v10 = "%{public}s called with null listener, no backtrace";
    }
    else
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v30 = "nw_protocol_http3_listen_protocol_disconnected";
      v10 = "%{public}s called with null listener, backtrace limit exceeded";
    }
LABEL_73:
    _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    goto LABEL_74;
  }
  handle = (char *)a1->handle;
  if (handle)
  {
    if (((*(unsigned __int16 *)(handle + 1373) | (handle[1375] << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v19 = __nwlog_obj();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          v20 = *((_DWORD *)handle + 320);
          *(_DWORD *)buf = 136446978;
          v30 = "nw_protocol_http3_listen_protocol_disconnected";
          v31 = 2082;
          v32 = (nw_protocol_identifier *)(handle + 1289);
          v33 = 2080;
          v34 = " ";
          v35 = 1024;
          v36 = v20;
          _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> listen protocol is disconnected", buf, 0x26u);
        }
      }
    }
    if (a2)
    {
      callbacks = a2->callbacks;
      if (callbacks)
      {
        remove_listen_handler = (void (*)(nw_protocol *, char *))callbacks->remove_listen_handler;
        if (remove_listen_handler)
        {
          remove_listen_handler(a2, handle + 136);
LABEL_9:
          nw_http3_async_close_connection_if_no_stream((uint64_t)handle);
          if ((*(_WORD *)(handle + 1373) & 0x800) == 0)
            nw_protocol_set_output_handler((uint64_t)handle, 0);
          return;
        }
      }
      __nwlog_obj();
      identifier = a2->identifier;
      if (!identifier)
        identifier = (nw_protocol_identifier *)"invalid";
    }
    else
    {
      __nwlog_obj();
      identifier = (nw_protocol_identifier *)"invalid";
    }
    *(_DWORD *)buf = 136446466;
    v30 = "nw_protocol_http3_listen_protocol_disconnected";
    v31 = 2082;
    v32 = identifier;
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (__nwlog_fault(v11, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
          goto LABEL_63;
        v14 = (nw_protocol_identifier *)"invalid";
        if (a2 && a2->identifier)
          v14 = a2->identifier;
        *(_DWORD *)buf = 136446466;
        v30 = "nw_protocol_http3_listen_protocol_disconnected";
        v31 = 2082;
        v32 = v14;
        v15 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback";
        goto LABEL_62;
      }
      if (!v27)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
          goto LABEL_63;
        v21 = (nw_protocol_identifier *)"invalid";
        if (a2 && a2->identifier)
          v21 = a2->identifier;
        *(_DWORD *)buf = 136446466;
        v30 = "nw_protocol_http3_listen_protocol_disconnected";
        v31 = 2082;
        v32 = v21;
        v15 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, backtrace limit exceeded";
        goto LABEL_62;
      }
      v16 = (char *)__nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v17 = os_log_type_enabled(v12, type);
      if (v16)
      {
        if (v17)
        {
          v18 = (nw_protocol_identifier *)"invalid";
          if (a2 && a2->identifier)
            v18 = a2->identifier;
          *(_DWORD *)buf = 136446722;
          v30 = "nw_protocol_http3_listen_protocol_disconnected";
          v31 = 2082;
          v32 = v18;
          v33 = 2082;
          v34 = v16;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid remove_listen_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v16);
        goto LABEL_63;
      }
      if (v17)
      {
        v26 = (nw_protocol_identifier *)"invalid";
        if (a2 && a2->identifier)
          v26 = a2->identifier;
        *(_DWORD *)buf = 136446466;
        v30 = "nw_protocol_http3_listen_protocol_disconnected";
        v31 = 2082;
        v32 = v26;
        v15 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, no backtrace";
LABEL_62:
        _os_log_impl(&dword_182FBE000, v12, v13, v15, buf, 0x16u);
      }
    }
LABEL_63:
    if (v11)
      free(v11);
    goto LABEL_9;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v30 = "nw_protocol_http3_listen_protocol_disconnected";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v27 = 0;
  if (!__nwlog_fault(v7, &type, &v27))
    goto LABEL_74;
  if (type == OS_LOG_TYPE_FAULT)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_74;
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_http3_listen_protocol_disconnected";
    v10 = "%{public}s called with null http3";
    goto LABEL_73;
  }
  if (!v27)
  {
    v8 = __nwlog_obj();
    v9 = type;
    if (!os_log_type_enabled(v8, type))
      goto LABEL_74;
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_http3_listen_protocol_disconnected";
    v10 = "%{public}s called with null http3, backtrace limit exceeded";
    goto LABEL_73;
  }
  v24 = (char *)__nw_create_backtrace_string();
  v8 = __nwlog_obj();
  v9 = type;
  v25 = os_log_type_enabled(v8, type);
  if (!v24)
  {
    if (!v25)
      goto LABEL_74;
    *(_DWORD *)buf = 136446210;
    v30 = "nw_protocol_http3_listen_protocol_disconnected";
    v10 = "%{public}s called with null http3, no backtrace";
    goto LABEL_73;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    v30 = "nw_protocol_http3_listen_protocol_disconnected";
    v31 = 2082;
    v32 = (nw_protocol_identifier *)v24;
    _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v24);
  if (v7)
    goto LABEL_75;
}

uint64_t nw_http3_get_default_output_handler(uint64_t a1)
{
  char *v2;
  NSObject *v3;
  os_log_type_t v4;
  const char *v5;
  char *backtrace_string;
  _BOOL4 v7;
  char v8;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
    return *(_QWORD *)(a1 + 32);
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v11 = "nw_http3_get_default_output_handler";
  v2 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_http3_get_default_output_handler";
        v5 = "%{public}s called with null http3";
LABEL_17:
        _os_log_impl(&dword_182FBE000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v3 = __nwlog_obj();
      v4 = type;
      v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          v11 = "nw_http3_get_default_output_handler";
          v12 = 2082;
          v13 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v3, v4, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_http3_get_default_output_handler";
        v5 = "%{public}s called with null http3, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = __nwlog_obj();
      v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        v11 = "nw_http3_get_default_output_handler";
        v5 = "%{public}s called with null http3, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2)
    free(v2);
  return 0;
}

uint64_t ___ZL42nw_protocol_http3_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  if (nw_protocol_metadata_is_quic_stream(a3))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
  return 1;
}

uint64_t ___ZL34nw_http3_uni_stream_create_inboundP17nw_protocol_http3_block_invoke(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void ___ZL42nw_protocol_http3_listen_protocol_new_flowP18nw_listen_protocolP11nw_endpointP13nw_parameters_block_invoke_171(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void (*v5)(void);
  uint64_t v6;
  const char *v7;
  const char *v8;
  char *v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  const char *v13;
  const char *v14;
  const char *v15;
  char *backtrace_string;
  _BOOL4 v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  char v27;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v1)
  {
    v2 = v1;
    v3 = *(_QWORD *)(v1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 24);
      if (v4)
      {
        v5 = *(void (**)(void))(v4 + 24);
        if (v5)
        {
          v5();
          return;
        }
      }
    }
    __nwlog_obj();
    v6 = *(_QWORD *)(v2 + 32);
    v7 = "invalid";
    if (v6)
    {
      v8 = *(const char **)(v6 + 16);
      if (v8)
        v7 = v8;
    }
    *(_DWORD *)buf = 136446466;
    v30 = "nw_protocol_http3_listen_protocol_new_flow_block_invoke";
    v31 = 2082;
    v32 = v7;
    v9 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v27 = 0;
    if (!__nwlog_fault(v9, &type, &v27))
      goto LABEL_35;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_35;
      v12 = *(_QWORD *)(v2 + 32);
      v13 = "invalid";
      if (v12)
      {
        v14 = *(const char **)(v12 + 16);
        if (v14)
          v13 = v14;
      }
      *(_DWORD *)buf = 136446466;
      v30 = "nw_protocol_http3_listen_protocol_new_flow_block_invoke";
      v31 = 2082;
      v32 = v13;
      v15 = "%{public}s protocol %{public}s has invalid connect callback";
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v10 = __nwlog_obj();
      v11 = type;
      v17 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v17)
        {
          v18 = *(_QWORD *)(v2 + 32);
          v19 = "invalid";
          if (v18)
          {
            v20 = *(const char **)(v18 + 16);
            if (v20)
              v19 = v20;
          }
          *(_DWORD *)buf = 136446722;
          v30 = "nw_protocol_http3_listen_protocol_new_flow_block_invoke";
          v31 = 2082;
          v32 = v19;
          v33 = 2082;
          v34 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v10, v11, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_35;
      }
      if (!v17)
      {
LABEL_35:
        if (v9)
          free(v9);
        return;
      }
      v24 = *(_QWORD *)(v2 + 32);
      v25 = "invalid";
      if (v24)
      {
        v26 = *(const char **)(v24 + 16);
        if (v26)
          v25 = v26;
      }
      *(_DWORD *)buf = 136446466;
      v30 = "nw_protocol_http3_listen_protocol_new_flow_block_invoke";
      v31 = 2082;
      v32 = v25;
      v15 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
    }
    else
    {
      v10 = __nwlog_obj();
      v11 = type;
      if (!os_log_type_enabled(v10, type))
        goto LABEL_35;
      v21 = *(_QWORD *)(v2 + 32);
      v22 = "invalid";
      if (v21)
      {
        v23 = *(const char **)(v21 + 16);
        if (v23)
          v22 = v23;
      }
      *(_DWORD *)buf = 136446466;
      v30 = "nw_protocol_http3_listen_protocol_new_flow_block_invoke";
      v31 = 2082;
      v32 = v22;
      v15 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v10, v11, v15, buf, 0x16u);
    goto LABEL_35;
  }
}

double ___ZL42nw_protocol_http3_uni_stream_get_callbacksv_block_invoke()
{
  double result;

  qword_1EDCE4E80 = 0;
  *(_QWORD *)algn_1EDCE4E79 = 0;
  strcpy((char *)&g_http3_uni_stream_protocol_identifier, "http3-uni-stream");
  *(_QWORD *)&result = 0x100000004;
  qword_1EDCE4E88 = 0x100000004;
  nw_protocol_http3_uni_stream_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_default_add_input_handler;
  *(_QWORD *)algn_1EDCE4C38 = nw_protocol_default_remove_input_handler;
  qword_1EDCE4CB0 = (uint64_t)nw_protocol_default_get_local;
  unk_1EDCE4CB8 = nw_protocol_default_get_remote;
  qword_1EDCE4CA0 = (uint64_t)nw_protocol_default_get_parameters;
  unk_1EDCE4CA8 = nw_protocol_default_get_path;
  qword_1EDCE4CF0 = (uint64_t)nw_protocol_default_output_finished;
  unk_1EDCE4CF8 = nw_protocol_default_get_output_local;
  qword_1EDCE4C40 = (uint64_t)nw_protocol_default_replace_input_handler;
  unk_1EDCE4C48 = nw_protocol_default_connect;
  qword_1EDCE4D30 = (uint64_t)nw_protocol_default_reset;
  unk_1EDCE4D38 = nw_protocol_default_input_flush;
  qword_1EDCE4D00 = (uint64_t)nw_protocol_default_get_output_interface;
  unk_1EDCE4D08 = nw_protocol_default_waiting_for_output;
  qword_1EDCE4CC0 = (uint64_t)nw_protocol_default_register_notification;
  unk_1EDCE4CC8 = nw_protocol_default_unregister_notification;
  qword_1EDCE4CD0 = (uint64_t)nw_protocol_default_notify;
  unk_1EDCE4CD8 = nw_protocol_default_updated_path;
  qword_1EDCE4D10 = (uint64_t)nw_protocol_default_copy_info;
  unk_1EDCE4D18 = nw_protocol_default_add_listen_handler;
  qword_1EDCE4D20 = (uint64_t)nw_protocol_default_remove_listen_handler;
  unk_1EDCE4D28 = nw_protocol_default_get_message_properties;
  qword_1EDCE4C50 = (uint64_t)nw_protocol_default_disconnect;
  unk_1EDCE4C58 = nw_protocol_http3_uni_stream_connected;
  qword_1EDCE4C60 = (uint64_t)nw_protocol_http3_uni_stream_disconnected;
  unk_1EDCE4C68 = nw_protocol_http3_uni_stream_error;
  qword_1EDCE4C70 = (uint64_t)nw_protocol_http3_uni_stream_input_available;
  unk_1EDCE4C78 = nw_protocol_default_output_available;
  qword_1EDCE4C80 = (uint64_t)nw_protocol_http3_uni_stream_get_input_frames;
  unk_1EDCE4C88 = nw_protocol_http3_uni_stream_get_output_frames;
  qword_1EDCE4C90 = (uint64_t)nw_protocol_http3_uni_stream_finalize_output_frames;
  unk_1EDCE4C98 = nw_protocol_default_link_state;
  qword_1EDCE4CE0 = (uint64_t)nw_protocol_http3_uni_stream_supports_external_data;
  unk_1EDCE4CE8 = nw_protocol_http3_uni_stream_input_finished;
  return result;
}

void nw_protocol_http3_uni_stream_connected(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*connected)(void);
  nw_protocol *v7;
  nw_protocol *v8;
  const char *v9;
  const char *name;
  char *v11;
  NSObject *v12;
  os_log_type_t v13;
  nw_protocol *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  os_log_type_t v20;
  const char *v21;
  NSObject *v22;
  char *v23;
  _BOOL4 v24;
  nw_protocol *v25;
  const char *v26;
  const char *v27;
  char *backtrace_string;
  _BOOL4 v29;
  char *v30;
  _BOOL4 v31;
  nw_protocol *v32;
  const char *v33;
  const char *v34;
  nw_protocol *v35;
  const char *v36;
  const char *v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  nw_protocol *v43;
  __int16 v44;
  char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_http3_uni_stream_connected";
    v18 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v18, &type, &v38))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v21 = "%{public}s called with null protocol";
      goto LABEL_74;
    }
    if (!v38)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v21 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v29 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (!v29)
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v21 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_74;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v42 = 2082;
      v43 = (nw_protocol *)backtrace_string;
      _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_75:
    if (!v18)
      return;
    goto LABEL_76;
  }
  handle = (nw_protocol *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_http3_uni_stream_connected";
    v18 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v18, &type, &v38))
      goto LABEL_75;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v21 = "%{public}s called with null http3_stream";
      goto LABEL_74;
    }
    if (!v38)
    {
      v19 = __nwlog_obj();
      v20 = type;
      if (!os_log_type_enabled(v19, type))
        goto LABEL_75;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v21 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_74;
    }
    v30 = (char *)__nw_create_backtrace_string();
    v19 = __nwlog_obj();
    v20 = type;
    v31 = os_log_type_enabled(v19, type);
    if (v30)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_http3_uni_stream_connected";
        v42 = 2082;
        v43 = (nw_protocol *)v30;
        _os_log_impl(&dword_182FBE000, v19, v20, "%{public}s called with null http3_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v30);
      if (!v18)
        return;
LABEL_76:
      free(v18);
      return;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v21 = "%{public}s called with null http3_stream, no backtrace";
LABEL_74:
      _os_log_impl(&dword_182FBE000, v19, v20, v21, buf, 0xCu);
      goto LABEL_75;
    }
    goto LABEL_75;
  }
  if (gLogDatapath)
  {
    v22 = __nwlog_obj();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_http3_uni_stream_connected";
      v42 = 2048;
      v43 = handle;
      _os_log_impl(&dword_182FBE000, v22, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  if (handle->output_handler == a2)
  {
    if ((handle[2].flow_id[3] & 1) == 0)
      handle[2].flow_id[3] |= 2u;
    default_input_handler = handle->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        connected = (void (*)(void))callbacks->connected;
        if (connected)
        {
          connected();
LABEL_11:
          if ((handle[2].flow_id[3] & 1) == 0)
            nw_protocol_http3_uni_stream_get_input_frames(handle, v7, 0, 0, 0xFFFFFFFF, 0);
          return;
        }
      }
    }
    __nwlog_obj();
    v8 = handle->default_input_handler;
    v9 = "invalid";
    if (v8)
    {
      name = v8->identifier->name;
      if (name)
        v9 = name;
    }
    *(_DWORD *)buf = 136446466;
    v41 = "nw_protocol_http3_uni_stream_connected";
    v42 = 2082;
    v43 = (nw_protocol *)v9;
    v11 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v11, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
          goto LABEL_68;
        v14 = handle->default_input_handler;
        v15 = "invalid";
        if (v14)
        {
          v16 = v14->identifier->name;
          if (v16)
            v15 = v16;
        }
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_http3_uni_stream_connected";
        v42 = 2082;
        v43 = (nw_protocol *)v15;
        v17 = "%{public}s protocol %{public}s has invalid connected callback";
        goto LABEL_67;
      }
      if (!v38)
      {
        v12 = __nwlog_obj();
        v13 = type;
        if (!os_log_type_enabled(v12, type))
          goto LABEL_68;
        v32 = handle->default_input_handler;
        v33 = "invalid";
        if (v32)
        {
          v34 = v32->identifier->name;
          if (v34)
            v33 = v34;
        }
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_http3_uni_stream_connected";
        v42 = 2082;
        v43 = (nw_protocol *)v33;
        v17 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_67;
      }
      v23 = (char *)__nw_create_backtrace_string();
      v12 = __nwlog_obj();
      v13 = type;
      v24 = os_log_type_enabled(v12, type);
      if (v23)
      {
        if (v24)
        {
          v25 = handle->default_input_handler;
          v26 = "invalid";
          if (v25)
          {
            v27 = v25->identifier->name;
            if (v27)
              v26 = v27;
          }
          *(_DWORD *)buf = 136446722;
          v41 = "nw_protocol_http3_uni_stream_connected";
          v42 = 2082;
          v43 = (nw_protocol *)v26;
          v44 = 2082;
          v45 = v23;
          _os_log_impl(&dword_182FBE000, v12, v13, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v23);
        goto LABEL_68;
      }
      if (v24)
      {
        v35 = handle->default_input_handler;
        v36 = "invalid";
        if (v35)
        {
          v37 = v35->identifier->name;
          if (v37)
            v36 = v37;
        }
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_http3_uni_stream_connected";
        v42 = 2082;
        v43 = (nw_protocol *)v36;
        v17 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
LABEL_67:
        _os_log_impl(&dword_182FBE000, v12, v13, v17, buf, 0x16u);
      }
    }
LABEL_68:
    if (v11)
      free(v11);
    goto LABEL_11;
  }
}

void nw_protocol_http3_uni_stream_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  char v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(void);
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  const char *v12;
  const char *v13;
  const char *v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  NSObject *v25;
  char *v26;
  _BOOL4 v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  char *v33;
  _BOOL4 v34;
  const char *v35;
  _BOOL4 v36;
  uint64_t v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  char *v43;
  _QWORD v44[5];
  char v45;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v48;
  __int16 v49;
  _QWORD *v50;
  __int16 v51;
  char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_http3_uni_stream_disconnected";
    v21 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v24 = "%{public}s called with null protocol";
    }
    else if (v45)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v32 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v48 = "nw_protocol_http3_uni_stream_disconnected";
          v49 = 2082;
          v50 = backtrace_string;
          _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_94:
        if (!v21)
          return;
        goto LABEL_95;
      }
      if (!v32)
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v24 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v24 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_93;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_http3_uni_stream_disconnected";
    v21 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45))
      goto LABEL_94;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        v22 = __nwlog_obj();
        v23 = type;
        if (!os_log_type_enabled(v22, type))
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        v48 = "nw_protocol_http3_uni_stream_disconnected";
        v24 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_93;
      }
      v33 = (char *)__nw_create_backtrace_string();
      v22 = __nwlog_obj();
      v23 = type;
      v34 = os_log_type_enabled(v22, type);
      if (!v33)
      {
        if (!v34)
          goto LABEL_94;
        *(_DWORD *)buf = 136446210;
        v48 = "nw_protocol_http3_uni_stream_disconnected";
        v24 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_93;
      }
      if (v34)
      {
        *(_DWORD *)buf = 136446466;
        v48 = "nw_protocol_http3_uni_stream_disconnected";
        v49 = 2082;
        v50 = v33;
        v35 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
LABEL_65:
        _os_log_impl(&dword_182FBE000, v22, v23, v35, buf, 0x16u);
      }
LABEL_66:
      free(v33);
      if (!v21)
        return;
LABEL_95:
      v43 = (char *)v21;
      goto LABEL_96;
    }
    v22 = __nwlog_obj();
    v23 = type;
    if (!os_log_type_enabled(v22, type))
      goto LABEL_94;
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_http3_uni_stream_disconnected";
    v24 = "%{public}s called with null http3_stream";
LABEL_93:
    _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0xCu);
    goto LABEL_94;
  }
  if (!handle[9])
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v48 = "nw_protocol_http3_uni_stream_disconnected";
    v21 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v45 = 0;
    if (!__nwlog_fault(v21, &type, &v45))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v24 = "%{public}s called with null http3_stream->http3_connection";
      goto LABEL_93;
    }
    if (!v45)
    {
      v22 = __nwlog_obj();
      v23 = type;
      if (!os_log_type_enabled(v22, type))
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v24 = "%{public}s called with null http3_stream->http3_connection, backtrace limit exceeded";
      goto LABEL_93;
    }
    v33 = (char *)__nw_create_backtrace_string();
    v22 = __nwlog_obj();
    v23 = type;
    v36 = os_log_type_enabled(v22, type);
    if (!v33)
    {
      if (!v36)
        goto LABEL_94;
      *(_DWORD *)buf = 136446210;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v24 = "%{public}s called with null http3_stream->http3_connection, no backtrace";
      goto LABEL_93;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v49 = 2082;
      v50 = v33;
      v35 = "%{public}s called with null http3_stream->http3_connection, dumping backtrace:%{public}s";
      goto LABEL_65;
    }
    goto LABEL_66;
  }
  if (gLogDatapath)
  {
    v25 = __nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v49 = 2048;
      v50 = handle;
      _os_log_impl(&dword_182FBE000, v25, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  v3 = *((_BYTE *)handle + 131);
  if ((v3 & 1) == 0)
  {
    if ((*((_BYTE *)handle + 131) & 2) == 0)
      return;
    v3 &= ~2u;
    *((_BYTE *)handle + 131) = v3;
  }
  if ((v3 & 8) != 0)
  {
    if ((v3 & 4) == 0)
    {
      v7 = handle[10];
      v8 = (_QWORD *)handle[11];
      if (v7)
      {
        *(_QWORD *)(v7 + 88) = v8;
        v8 = (_QWORD *)handle[11];
      }
      else
      {
        *(_QWORD *)(handle[9] + 904) = v8;
      }
      *v8 = v7;
    }
    v9 = handle[12];
    v10 = *(void **)(handle[9] + 1256);
    v44[0] = MEMORY[0x1E0C809B0];
    v44[1] = 0x40000000;
    v44[2] = ___ZL41nw_protocol_http3_uni_stream_disconnectedP11nw_protocolS0__block_invoke;
    v44[3] = &unk_1E14A7DC0;
    v44[4] = v9;
    nw_queue_context_async(v10, v44);
    return;
  }
  v4 = handle[6];
  if (v4)
  {
    v5 = *(_QWORD *)(v4 + 24);
    if (v5)
    {
      v6 = *(void (**)(void))(v5 + 48);
      if (v6)
      {
        v6();
        return;
      }
    }
  }
  __nwlog_obj();
  v11 = handle[6];
  v12 = "invalid";
  if (v11)
  {
    v13 = *(const char **)(v11 + 16);
    if (v13)
      v12 = v13;
  }
  *(_DWORD *)buf = 136446466;
  v48 = "nw_protocol_http3_uni_stream_disconnected";
  v49 = 2082;
  v50 = v12;
  v14 = (const char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v45 = 0;
  if (__nwlog_fault(v14, &type, &v45))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_85;
      v17 = handle[6];
      v18 = "invalid";
      if (v17)
      {
        v19 = *(const char **)(v17 + 16);
        if (v19)
          v18 = v19;
      }
      *(_DWORD *)buf = 136446466;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v49 = 2082;
      v50 = v18;
      v20 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_84:
      _os_log_impl(&dword_182FBE000, v15, v16, v20, buf, 0x16u);
      goto LABEL_85;
    }
    if (!v45)
    {
      v15 = __nwlog_obj();
      v16 = type;
      if (!os_log_type_enabled(v15, type))
        goto LABEL_85;
      v37 = handle[6];
      v38 = "invalid";
      if (v37)
      {
        v39 = *(const char **)(v37 + 16);
        if (v39)
          v38 = v39;
      }
      *(_DWORD *)buf = 136446466;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v49 = 2082;
      v50 = v38;
      v20 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_84;
    }
    v26 = (char *)__nw_create_backtrace_string();
    v15 = __nwlog_obj();
    v16 = type;
    v27 = os_log_type_enabled(v15, type);
    if (!v26)
    {
      if (!v27)
        goto LABEL_85;
      v40 = handle[6];
      v41 = "invalid";
      if (v40)
      {
        v42 = *(const char **)(v40 + 16);
        if (v42)
          v41 = v42;
      }
      *(_DWORD *)buf = 136446466;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v49 = 2082;
      v50 = v41;
      v20 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
      goto LABEL_84;
    }
    if (v27)
    {
      v28 = handle[6];
      v29 = "invalid";
      if (v28)
      {
        v30 = *(const char **)(v28 + 16);
        if (v30)
          v29 = v30;
      }
      *(_DWORD *)buf = 136446722;
      v48 = "nw_protocol_http3_uni_stream_disconnected";
      v49 = 2082;
      v50 = v29;
      v51 = 2082;
      v52 = v26;
      _os_log_impl(&dword_182FBE000, v15, v16, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v26);
  }
LABEL_85:
  if (v14)
  {
    v43 = (char *)v14;
LABEL_96:
    free(v43);
  }
}

void nw_protocol_http3_uni_stream_error(nw_protocol *a1, nw_protocol *a2)
{
  _QWORD *handle;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(void);
  uint64_t v7;
  const char *v8;
  const char *v9;
  char *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  const char *v16;
  NSObject *v17;
  os_log_type_t v18;
  NSObject *v19;
  char *v20;
  _BOOL4 v21;
  uint64_t v22;
  const char *v23;
  const char *v24;
  char *backtrace_string;
  _BOOL4 v26;
  const char *v27;
  _BOOL4 v28;
  uint64_t v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  NSObject *v35;
  os_log_type_t v36;
  uint32_t v37;
  char v38;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  _QWORD *v43;
  __int16 v44;
  char *v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_http3_uni_stream_error";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v10, &type, &v38))
      goto LABEL_74;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_error";
      v16 = "%{public}s called with null protocol";
LABEL_72:
      v35 = v17;
      v36 = v18;
      v37 = 12;
      goto LABEL_73;
    }
    if (!v38)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_error";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v26 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v26)
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_error";
      v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_72;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_http3_uni_stream_error";
      v42 = 2082;
      v43 = backtrace_string;
      v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_50:
      _os_log_impl(&dword_182FBE000, v17, v18, v27, buf, 0x16u);
    }
LABEL_51:
    free(backtrace_string);
    if (!v10)
      return;
LABEL_75:
    free(v10);
    return;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v41 = "nw_protocol_http3_uni_stream_error";
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (!__nwlog_fault(v10, &type, &v38))
      goto LABEL_74;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_error";
      v16 = "%{public}s called with null http3_stream";
      goto LABEL_72;
    }
    if (!v38)
    {
      v17 = __nwlog_obj();
      v18 = type;
      if (!os_log_type_enabled(v17, type))
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_error";
      v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v17 = __nwlog_obj();
    v18 = type;
    v28 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v28)
        goto LABEL_74;
      *(_DWORD *)buf = 136446210;
      v41 = "nw_protocol_http3_uni_stream_error";
      v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_72;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_http3_uni_stream_error";
      v42 = 2082;
      v43 = backtrace_string;
      v27 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_50;
    }
    goto LABEL_51;
  }
  if (gLogDatapath)
  {
    v19 = __nwlog_obj();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v41 = "nw_protocol_http3_uni_stream_error";
      v42 = 2048;
      v43 = handle;
      _os_log_impl(&dword_182FBE000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  if ((*((_BYTE *)handle + 131) & 3) != 0 && (*((_BYTE *)handle + 131) & 8) == 0)
  {
    v4 = handle[6];
    if (v4)
    {
      v5 = *(_QWORD *)(v4 + 24);
      if (v5)
      {
        v6 = *(void (**)(void))(v5 + 56);
        if (v6)
        {
          v6();
          return;
        }
      }
    }
    __nwlog_obj();
    v7 = handle[6];
    v8 = "invalid";
    if (v7)
    {
      v9 = *(const char **)(v7 + 16);
      if (v9)
        v8 = v9;
    }
    *(_DWORD *)buf = 136446466;
    v41 = "nw_protocol_http3_uni_stream_error";
    v42 = 2082;
    v43 = v8;
    v10 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v38 = 0;
    if (__nwlog_fault(v10, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_74;
        v13 = handle[6];
        v14 = "invalid";
        if (v13)
        {
          v15 = *(const char **)(v13 + 16);
          if (v15)
            v14 = v15;
        }
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_http3_uni_stream_error";
        v42 = 2082;
        v43 = v14;
        v16 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_67:
        v35 = v11;
        v36 = v12;
        v37 = 22;
LABEL_73:
        _os_log_impl(&dword_182FBE000, v35, v36, v16, buf, v37);
        goto LABEL_74;
      }
      if (!v38)
      {
        v11 = __nwlog_obj();
        v12 = type;
        if (!os_log_type_enabled(v11, type))
          goto LABEL_74;
        v29 = handle[6];
        v30 = "invalid";
        if (v29)
        {
          v31 = *(const char **)(v29 + 16);
          if (v31)
            v30 = v31;
        }
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_http3_uni_stream_error";
        v42 = 2082;
        v43 = v30;
        v16 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_67;
      }
      v20 = (char *)__nw_create_backtrace_string();
      v11 = __nwlog_obj();
      v12 = type;
      v21 = os_log_type_enabled(v11, type);
      if (!v20)
      {
        if (!v21)
          goto LABEL_74;
        v32 = handle[6];
        v33 = "invalid";
        if (v32)
        {
          v34 = *(const char **)(v32 + 16);
          if (v34)
            v33 = v34;
        }
        *(_DWORD *)buf = 136446466;
        v41 = "nw_protocol_http3_uni_stream_error";
        v42 = 2082;
        v43 = v33;
        v16 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
        goto LABEL_67;
      }
      if (v21)
      {
        v22 = handle[6];
        v23 = "invalid";
        if (v22)
        {
          v24 = *(const char **)(v22 + 16);
          if (v24)
            v23 = v24;
        }
        *(_DWORD *)buf = 136446722;
        v41 = "nw_protocol_http3_uni_stream_error";
        v42 = 2082;
        v43 = v23;
        v44 = 2082;
        v45 = v20;
        _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v20);
    }
LABEL_74:
    if (!v10)
      return;
    goto LABEL_75;
  }
}

void nw_protocol_http3_uni_stream_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  void *handle;
  nw_protocol *v4;
  nw_protocol_callbacks *callbacks;
  void (*input_finished)(nw_protocol *, nw_protocol *);
  uint64_t v7;
  const char *v8;
  const char *v9;
  const char *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  const char *v16;
  nw_protocol_callbacks *v17;
  NSObject *v18;
  os_log_type_t v19;
  NSObject *v20;
  char *v21;
  _BOOL4 v22;
  const char *v23;
  _BOOL4 v24;
  nw_protocol_identifier *identifier;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  nw_protocol_identifier *v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  uint64_t v33;
  const char *v34;
  const char *v35;
  char *v36;
  _BOOL4 v37;
  nw_protocol_identifier *v38;
  uint64_t v39;
  const char *v40;
  const char *v41;
  NSObject *v42;
  os_log_type_t v43;
  uint32_t v44;
  _BOOL4 v45;
  nw_protocol_identifier *v46;
  uint64_t v47;
  const char *v48;
  const char *v49;
  char *v50;
  nw_protocol_identifier *v51;
  char v52;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  nw_protocol_identifier *v57;
  __int16 v58;
  char *v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        v20 = __nwlog_obj();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2048;
          v57 = (nw_protocol_identifier *)handle;
          _os_log_impl(&dword_182FBE000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
        }
      }
      if ((*((_BYTE *)handle + 131) & 2) == 0)
        return;
      if ((*((_BYTE *)handle + 131) & 8) == 0)
      {
        v4 = (nw_protocol *)*((_QWORD *)handle + 6);
        if (!v4
          || (callbacks = v4->callbacks) == 0
          || (input_finished = (void (*)(nw_protocol *, nw_protocol *))callbacks->input_finished) == 0)
        {
          __nwlog_obj();
          v7 = *((_QWORD *)handle + 6);
          v8 = "invalid";
          if (v7)
          {
            v9 = *(const char **)(v7 + 16);
            if (v9)
              v8 = v9;
          }
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = (nw_protocol_identifier *)v8;
          v10 = (const char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v52 = 0;
          if (__nwlog_fault(v10, &type, &v52))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              v11 = __nwlog_obj();
              v12 = type;
              if (!os_log_type_enabled(v11, type))
                goto LABEL_93;
              v13 = *((_QWORD *)handle + 6);
              v14 = "invalid";
              if (v13)
              {
                v15 = *(const char **)(v13 + 16);
                if (v15)
                  v14 = v15;
              }
              *(_DWORD *)buf = 136446466;
              v55 = "nw_protocol_http3_uni_stream_input_finished";
              v56 = 2082;
              v57 = (nw_protocol_identifier *)v14;
              v16 = "%{public}s protocol %{public}s has invalid input_finished callback";
LABEL_91:
              v42 = v11;
              v43 = v12;
              v44 = 22;
              goto LABEL_92;
            }
            if (!v52)
            {
              v11 = __nwlog_obj();
              v12 = type;
              if (!os_log_type_enabled(v11, type))
                goto LABEL_93;
              v39 = *((_QWORD *)handle + 6);
              v40 = "invalid";
              if (v39)
              {
                v41 = *(const char **)(v39 + 16);
                if (v41)
                  v40 = v41;
              }
              *(_DWORD *)buf = 136446466;
              v55 = "nw_protocol_http3_uni_stream_input_finished";
              v56 = 2082;
              v57 = (nw_protocol_identifier *)v40;
              v16 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
              goto LABEL_91;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            v11 = __nwlog_obj();
            v12 = type;
            v32 = os_log_type_enabled(v11, type);
            if (!backtrace_string)
            {
              if (!v32)
                goto LABEL_93;
              v47 = *((_QWORD *)handle + 6);
              v48 = "invalid";
              if (v47)
              {
                v49 = *(const char **)(v47 + 16);
                if (v49)
                  v48 = v49;
              }
              *(_DWORD *)buf = 136446466;
              v55 = "nw_protocol_http3_uni_stream_input_finished";
              v56 = 2082;
              v57 = (nw_protocol_identifier *)v48;
              v16 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
              goto LABEL_91;
            }
            if (v32)
            {
              v33 = *((_QWORD *)handle + 6);
              v34 = "invalid";
              if (v33)
              {
                v35 = *(const char **)(v33 + 16);
                if (v35)
                  v34 = v35;
              }
              *(_DWORD *)buf = 136446722;
              v55 = "nw_protocol_http3_uni_stream_input_finished";
              v56 = 2082;
              v57 = (nw_protocol_identifier *)v34;
              v58 = 2082;
              v59 = backtrace_string;
              _os_log_impl(&dword_182FBE000, v11, v12, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
          }
LABEL_93:
          if (v10)
            goto LABEL_94;
          return;
        }
LABEL_22:
        input_finished(v4, a1);
        return;
      }
      v17 = a1->callbacks;
      if (v17)
      {
        input_finished = (void (*)(nw_protocol *, nw_protocol *))v17->disconnect;
        if (input_finished)
        {
          v4 = a1;
          goto LABEL_22;
        }
      }
      __nwlog_obj();
      identifier = a1->identifier;
      if (!identifier)
        identifier = (nw_protocol_identifier *)"invalid";
      *(_DWORD *)buf = 136446466;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v56 = 2082;
      v57 = identifier;
      v26 = (const char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v52 = 0;
      if (__nwlog_fault(v26, &type, &v52))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          v27 = __nwlog_obj();
          v28 = type;
          if (!os_log_type_enabled(v27, type))
            goto LABEL_101;
          v29 = a1->identifier;
          if (!v29)
            v29 = (nw_protocol_identifier *)"invalid";
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v29;
          v30 = "%{public}s protocol %{public}s has invalid disconnect callback";
LABEL_100:
          _os_log_impl(&dword_182FBE000, v27, v28, v30, buf, 0x16u);
          goto LABEL_101;
        }
        if (!v52)
        {
          v27 = __nwlog_obj();
          v28 = type;
          v45 = os_log_type_enabled(v27, type);
          v46 = (nw_protocol_identifier *)"invalid";
          if (!v45)
            goto LABEL_101;
          if (a1->identifier)
            v46 = a1->identifier;
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v46;
          v30 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
          goto LABEL_100;
        }
        v36 = (char *)__nw_create_backtrace_string();
        v27 = __nwlog_obj();
        v28 = type;
        v37 = os_log_type_enabled(v27, type);
        if (!v36)
        {
          v51 = (nw_protocol_identifier *)"invalid";
          if (!v37)
            goto LABEL_101;
          if (a1->identifier)
            v51 = a1->identifier;
          *(_DWORD *)buf = 136446466;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v51;
          v30 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
          goto LABEL_100;
        }
        if (v37)
        {
          v38 = (nw_protocol_identifier *)"invalid";
          if (a1->identifier)
            v38 = a1->identifier;
          *(_DWORD *)buf = 136446722;
          v55 = "nw_protocol_http3_uni_stream_input_finished";
          v56 = 2082;
          v57 = v38;
          v58 = 2082;
          v59 = v36;
          _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v36);
      }
LABEL_101:
      if (v26)
      {
        v50 = (char *)v26;
        goto LABEL_95;
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_http3_uni_stream_input_finished";
    v10 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v10, &type, &v52))
      goto LABEL_93;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v16 = "%{public}s called with null http3_stream";
      goto LABEL_81;
    }
    if (!v52)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v16 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_81;
    }
    v21 = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v24 = os_log_type_enabled(v18, type);
    if (!v21)
    {
      if (!v24)
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v16 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_81;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v56 = 2082;
      v57 = (nw_protocol_identifier *)v21;
      v23 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v55 = "nw_protocol_http3_uni_stream_input_finished";
    v10 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v52 = 0;
    if (!__nwlog_fault(v10, &type, &v52))
      goto LABEL_93;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v16 = "%{public}s called with null protocol";
LABEL_81:
      v42 = v18;
      v43 = v19;
      v44 = 12;
LABEL_92:
      _os_log_impl(&dword_182FBE000, v42, v43, v16, buf, v44);
      goto LABEL_93;
    }
    if (!v52)
    {
      v18 = __nwlog_obj();
      v19 = type;
      if (!os_log_type_enabled(v18, type))
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v16 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_81;
    }
    v21 = (char *)__nw_create_backtrace_string();
    v18 = __nwlog_obj();
    v19 = type;
    v22 = os_log_type_enabled(v18, type);
    if (!v21)
    {
      if (!v22)
        goto LABEL_93;
      *(_DWORD *)buf = 136446210;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v16 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_81;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v55 = "nw_protocol_http3_uni_stream_input_finished";
      v56 = 2082;
      v57 = (nw_protocol_identifier *)v21;
      v23 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_42:
      _os_log_impl(&dword_182FBE000, v18, v19, v23, buf, 0x16u);
    }
  }
  free(v21);
  if (v10)
  {
LABEL_94:
    v50 = (char *)v10;
LABEL_95:
    free(v50);
  }
}

void nw_protocol_http3_uni_stream_input_available(nw_protocol *a1, nw_protocol *a2)
{
  nw_protocol *handle;
  nw_protocol *default_input_handler;
  nw_protocol_callbacks *callbacks;
  void (*input_available)(void);
  char *v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  NSObject *v10;
  nw_protocol *v11;
  const char *v12;
  const char *name;
  NSObject *v14;
  os_log_type_t v15;
  nw_protocol *v16;
  const char *v17;
  const char *v18;
  char *v19;
  _BOOL4 v20;
  const char *v21;
  _BOOL4 v22;
  char *backtrace_string;
  _BOOL4 v24;
  nw_protocol *v25;
  const char *v26;
  const char *v27;
  nw_protocol *v28;
  const char *v29;
  const char *v30;
  NSObject *v31;
  os_log_type_t v32;
  uint32_t v33;
  nw_protocol *v34;
  const char *v35;
  const char *v36;
  char v37;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  nw_protocol *v42;
  __int16 v43;
  char *v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = (nw_protocol *)a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        v10 = __nwlog_obj();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_protocol_http3_uni_stream_input_available";
          v41 = 2048;
          v42 = handle;
          _os_log_impl(&dword_182FBE000, v10, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
        }
      }
      if ((handle[2].flow_id[3] & 2) == 0)
        return;
      if ((handle[2].flow_id[3] & 4) == 0)
      {
        nw_protocol_http3_uni_stream_get_input_frames(handle, a2, 0, 0, 0xFFFFFFFF, 0);
        return;
      }
      default_input_handler = handle->default_input_handler;
      if (default_input_handler)
      {
        callbacks = default_input_handler->callbacks;
        if (callbacks)
        {
          input_available = (void (*)(void))callbacks->input_available;
          if (input_available)
          {
            input_available();
            return;
          }
        }
      }
      __nwlog_obj();
      v11 = handle->default_input_handler;
      v12 = "invalid";
      if (v11)
      {
        name = v11->identifier->name;
        if (name)
          v12 = name;
      }
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v41 = 2082;
      v42 = (nw_protocol *)v12;
      v6 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (!__nwlog_fault(v6, &type, &v37))
        goto LABEL_72;
      if (type == OS_LOG_TYPE_FAULT)
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_72;
        v16 = handle->default_input_handler;
        v17 = "invalid";
        if (v16)
        {
          v18 = v16->identifier->name;
          if (v18)
            v17 = v18;
        }
        *(_DWORD *)buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_input_available";
        v41 = 2082;
        v42 = (nw_protocol *)v17;
        v9 = "%{public}s protocol %{public}s has invalid input_available callback";
      }
      else if (v37)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v14 = __nwlog_obj();
        v15 = type;
        v24 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v24)
          {
            v25 = handle->default_input_handler;
            v26 = "invalid";
            if (v25)
            {
              v27 = v25->identifier->name;
              if (v27)
                v26 = v27;
            }
            *(_DWORD *)buf = 136446722;
            v40 = "nw_protocol_http3_uni_stream_input_available";
            v41 = 2082;
            v42 = (nw_protocol *)v26;
            v43 = 2082;
            v44 = backtrace_string;
            _os_log_impl(&dword_182FBE000, v14, v15, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
LABEL_72:
          if (v6)
            goto LABEL_73;
          return;
        }
        if (!v24)
          goto LABEL_72;
        v34 = handle->default_input_handler;
        v35 = "invalid";
        if (v34)
        {
          v36 = v34->identifier->name;
          if (v36)
            v35 = v36;
        }
        *(_DWORD *)buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_input_available";
        v41 = 2082;
        v42 = (nw_protocol *)v35;
        v9 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
      }
      else
      {
        v14 = __nwlog_obj();
        v15 = type;
        if (!os_log_type_enabled(v14, type))
          goto LABEL_72;
        v28 = handle->default_input_handler;
        v29 = "invalid";
        if (v28)
        {
          v30 = v28->identifier->name;
          if (v30)
            v29 = v30;
        }
        *(_DWORD *)buf = 136446466;
        v40 = "nw_protocol_http3_uni_stream_input_available";
        v41 = 2082;
        v42 = (nw_protocol *)v29;
        v9 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      }
      v31 = v14;
      v32 = v15;
      v33 = 22;
LABEL_71:
      _os_log_impl(&dword_182FBE000, v31, v32, v9, buf, v33);
      goto LABEL_72;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_http3_uni_stream_input_available";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v6, &type, &v37))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v9 = "%{public}s called with null http3_stream";
      goto LABEL_64;
    }
    if (!v37)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v9 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_64;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v22 = os_log_type_enabled(v7, type);
    if (!v19)
    {
      if (!v22)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v9 = "%{public}s called with null http3_stream, no backtrace";
      goto LABEL_64;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v41 = 2082;
      v42 = (nw_protocol *)v19;
      v21 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_40;
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_protocol_http3_uni_stream_input_available";
    v6 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v37 = 0;
    if (!__nwlog_fault(v6, &type, &v37))
      goto LABEL_72;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v9 = "%{public}s called with null protocol";
LABEL_64:
      v31 = v7;
      v32 = v8;
      v33 = 12;
      goto LABEL_71;
    }
    if (!v37)
    {
      v7 = __nwlog_obj();
      v8 = type;
      if (!os_log_type_enabled(v7, type))
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_64;
    }
    v19 = (char *)__nw_create_backtrace_string();
    v7 = __nwlog_obj();
    v8 = type;
    v20 = os_log_type_enabled(v7, type);
    if (!v19)
    {
      if (!v20)
        goto LABEL_72;
      *(_DWORD *)buf = 136446210;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v9 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_64;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      v40 = "nw_protocol_http3_uni_stream_input_available";
      v41 = 2082;
      v42 = (nw_protocol *)v19;
      v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_40:
      _os_log_impl(&dword_182FBE000, v7, v8, v21, buf, 0x16u);
    }
  }
  free(v19);
  if (v6)
LABEL_73:
    free(v6);
}

uint64_t nw_protocol_http3_uni_stream_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  char *handle;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  unsigned int (*get_input_frames)(void);
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  nw_frame **v22;
  uint64_t v23;
  char v24;
  nw_protocol *v25;
  nw_protocol_callbacks *v26;
  uint64_t (*v27)(void);
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t (*v32)(void);
  unsigned __int8 *v33;
  uint64_t v34;
  void (*v35)(char *, uint64_t);
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  NSObject *v41;
  char *backtrace_string;
  _BOOL4 v43;
  const char *v44;
  _BOOL4 v45;
  const char *v46;
  char *v47;
  NSObject *v48;
  os_log_type_t v49;
  const char *v50;
  const char *v51;
  char *v52;
  _BOOL4 v53;
  const char *v54;
  const char *v55;
  const char *v56;
  _QWORD v57[2];
  uint64_t (*v58)(_QWORD *);
  void *v59;
  _BYTE *v60;
  os_log_type_t *v61;
  _QWORD v62[2];
  BOOL (*v63)(uint64_t, uint64_t);
  void *v64;
  os_log_type_t *v65;
  char *v66;
  nw_protocol *v67;
  os_log_type_t type[8];
  os_log_type_t *v69;
  uint64_t v70;
  uint64_t v71;
  char v72;
  os_log_type_t v73;
  _BYTE buf[24];
  char *v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
    v37 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v73 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v37, type, &v73))
      goto LABEL_83;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v73 == OS_LOG_TYPE_DEFAULT)
      {
        v38 = __nwlog_obj();
        v39 = type[0];
        if (!os_log_type_enabled(v38, type[0]))
          goto LABEL_83;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
        v40 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_82;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = __nwlog_obj();
      v39 = type[0];
      v43 = os_log_type_enabled(v38, type[0]);
      if (!backtrace_string)
      {
        if (!v43)
          goto LABEL_83;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
        v40 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_82;
      }
      if (v43)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_72:
        _os_log_impl(&dword_182FBE000, v38, v39, v44, buf, 0x16u);
      }
LABEL_73:
      free(backtrace_string);
      goto LABEL_83;
    }
    v38 = __nwlog_obj();
    v39 = type[0];
    if (!os_log_type_enabled(v38, type[0]))
      goto LABEL_83;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
    v40 = "%{public}s called with null protocol";
LABEL_82:
    _os_log_impl(&dword_182FBE000, v38, v39, v40, buf, 0xCu);
LABEL_83:
    if (v37)
      free(v37);
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
    v37 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v73 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v37, type, &v73))
      goto LABEL_83;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v38 = __nwlog_obj();
      v39 = type[0];
      if (!os_log_type_enabled(v38, type[0]))
        goto LABEL_83;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
      v40 = "%{public}s called with null http3_stream";
      goto LABEL_82;
    }
    if (v73 == OS_LOG_TYPE_DEFAULT)
    {
      v38 = __nwlog_obj();
      v39 = type[0];
      if (!os_log_type_enabled(v38, type[0]))
        goto LABEL_83;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
      v40 = "%{public}s called with null http3_stream, backtrace limit exceeded";
      goto LABEL_82;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = __nwlog_obj();
    v39 = type[0];
    v45 = os_log_type_enabled(v38, type[0]);
    if (backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = backtrace_string;
        v44 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
        goto LABEL_72;
      }
      goto LABEL_73;
    }
    if (!v45)
      goto LABEL_83;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
    v40 = "%{public}s called with null http3_stream, no backtrace";
    goto LABEL_82;
  }
  if (gLogDatapath)
  {
    v41 = __nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "nw_protocol_http3_uni_stream_get_input_frames";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = handle;
      _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  if ((handle[131] & 2) == 0)
    return 0;
  if ((handle[131] & 4) == 0)
  {
    output_handler = a1->output_handler;
    if (!output_handler)
      return 0;
    callbacks = output_handler->callbacks;
    if (!callbacks)
      return 0;
    get_input_frames = (unsigned int (*)(void))callbacks->get_input_frames;
    if (!get_input_frames || !get_input_frames())
      return 0;
    *(_QWORD *)type = 0;
    v69 = type;
    v70 = 0x2000000000;
    v71 = -1;
    v62[0] = MEMORY[0x1E0C809B0];
    v62[1] = 0x40000000;
    v63 = ___ZL45nw_protocol_http3_uni_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    v64 = &unk_1E14A7DE8;
    v65 = type;
    v66 = handle;
    v67 = a1;
    v14 = *((_QWORD *)handle + 13);
    do
    {
      if (!v14)
        break;
      v15 = *(_QWORD *)(v14 + 32);
      v16 = ((uint64_t (*)(_QWORD *))v63)(v62);
      v14 = v15;
    }
    while ((v16 & 1) != 0);
    if ((handle[131] & 4) == 0 || (handle[131] & 2) == 0)
    {
LABEL_51:
      _Block_object_dispose(type, 8);
      return 0;
    }
    v17 = *((_QWORD *)v69 + 3);
    v19 = *((_QWORD *)handle + 9);
    v18 = *((_QWORD *)handle + 10);
    v20 = (_QWORD *)*((_QWORD *)handle + 11);
    if (v18)
    {
      *(_QWORD *)(v18 + 88) = v20;
      v20 = (_QWORD *)*((_QWORD *)handle + 11);
    }
    else
    {
      *(_QWORD *)(v19 + 904) = v20;
    }
    *v20 = v18;
    switch(v17)
    {
      case 3:
        if (!*(_QWORD *)(v19 + 1080))
        {
          handle[131] &= ~8u;
          *(_QWORD *)(v19 + 1080) = handle;
          nw_http3_decoder_stream_process_input(v19);
          goto LABEL_51;
        }
        goto LABEL_41;
      case 2:
        if (!*(_QWORD *)(v19 + 1064))
        {
          handle[131] &= ~8u;
          *(_QWORD *)(v19 + 1064) = handle;
          nw_http3_encoder_stream_process_input(v19);
          goto LABEL_51;
        }
        goto LABEL_41;
      case 0:
        if (!*(_QWORD *)(v19 + 1048))
        {
          handle[131] &= ~8u;
          *(_QWORD *)(v19 + 1048) = handle;
          *(_QWORD *)(v19 + 208) = handle;
          nw_http3_control_stream_process_input(v19);
          goto LABEL_51;
        }
LABEL_41:
        nw_http3_fail_all_streams((nw_protocol *)v19, 259);
        goto LABEL_51;
    }
    v30 = *((_QWORD *)handle + 4);
    if (v30)
    {
      v31 = *(_QWORD *)(v30 + 24);
      if (v31)
      {
        v32 = *(uint64_t (**)(void))(v31 + 224);
        if (v32)
        {
          v33 = (unsigned __int8 *)v32();
          nw_array_apply(v33, (uint64_t)&__block_literal_global_66);
          if (v33)
            os_release(v33);
        }
      }
    }
    v34 = *((_QWORD *)handle + 3);
    if (v34)
    {
      v35 = *(void (**)(char *, uint64_t))(v34 + 32);
      if (v35)
      {
        v35(handle, v19);
        goto LABEL_51;
      }
    }
    __nwlog_obj();
    v46 = (const char *)*((_QWORD *)handle + 2);
    if (!v46)
      v46 = "invalid";
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "nw_http3_uni_stream_type_received";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v46;
    v47 = (char *)_os_log_send_and_compose_impl();
    v73 = OS_LOG_TYPE_ERROR;
    v72 = 0;
    if (__nwlog_fault(v47, &v73, &v72))
    {
      if (v73 == OS_LOG_TYPE_FAULT)
      {
        v48 = __nwlog_obj();
        v49 = v73;
        if (!os_log_type_enabled(v48, v73))
          goto LABEL_109;
        v50 = (const char *)*((_QWORD *)handle + 2);
        if (!v50)
          v50 = "invalid";
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http3_uni_stream_type_received";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v50;
        v51 = "%{public}s protocol %{public}s has invalid disconnect callback";
        goto LABEL_108;
      }
      if (!v72)
      {
        v48 = __nwlog_obj();
        v49 = v73;
        if (!os_log_type_enabled(v48, v73))
          goto LABEL_109;
        v55 = (const char *)*((_QWORD *)handle + 2);
        if (!v55)
          v55 = "invalid";
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http3_uni_stream_type_received";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v55;
        v51 = "%{public}s protocol %{public}s has invalid disconnect callback, backtrace limit exceeded";
        goto LABEL_108;
      }
      v52 = (char *)__nw_create_backtrace_string();
      v48 = __nwlog_obj();
      v49 = v73;
      v53 = os_log_type_enabled(v48, v73);
      if (v52)
      {
        if (v53)
        {
          v54 = (const char *)*((_QWORD *)handle + 2);
          if (!v54)
            v54 = "invalid";
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "nw_http3_uni_stream_type_received";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v54;
          *(_WORD *)&buf[22] = 2082;
          v75 = v52;
          _os_log_impl(&dword_182FBE000, v48, v49, "%{public}s protocol %{public}s has invalid disconnect callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v52);
        goto LABEL_109;
      }
      if (v53)
      {
        v56 = (const char *)*((_QWORD *)handle + 2);
        if (!v56)
          v56 = "invalid";
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "nw_http3_uni_stream_type_received";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v56;
        v51 = "%{public}s protocol %{public}s has invalid disconnect callback, no backtrace";
LABEL_108:
        _os_log_impl(&dword_182FBE000, v48, v49, v51, buf, 0x16u);
      }
    }
LABEL_109:
    if (v47)
      free(v47);
    goto LABEL_51;
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  LODWORD(v75) = 0;
  *(_QWORD *)&buf[16] = 0x2000000000;
  *(_QWORD *)type = 0;
  v69 = type;
  LODWORD(v71) = 0;
  v70 = 0x2000000000;
  v22 = (nw_frame **)(handle + 104);
  v21 = *((_QWORD *)handle + 13);
  v57[0] = MEMORY[0x1E0C809B0];
  v57[1] = 0x40000000;
  v58 = (uint64_t (*)(_QWORD *))___ZL45nw_protocol_http3_uni_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2;
  v59 = &unk_1E14A7E10;
  v60 = buf;
  v61 = type;
  do
  {
    if (!v21)
      break;
    v23 = *(_QWORD *)(v21 + 32);
    v24 = v58(v57);
    v21 = v23;
  }
  while ((v24 & 1) != 0);
  if (a3 <= *(_DWORD *)(*(_QWORD *)&buf[8] + 24) || a5 <= *((_DWORD *)v69 + 6))
    goto LABEL_27;
  v25 = a1->output_handler;
  if (v25)
  {
    v26 = v25->callbacks;
    if (v26)
    {
      v27 = (uint64_t (*)(void))v26->get_input_frames;
      if (v27)
      {
        v28 = v27();
        if (v28)
        {
          *((_DWORD *)v69 + 6) += v28;
LABEL_27:
          if (*v22)
          {
            *a6->tqh_last = *v22;
            *(_QWORD *)(*((_QWORD *)handle + 13) + 40) = a6->tqh_last;
            a6->tqh_last = (nw_frame **)*((_QWORD *)handle + 14);
            *((_QWORD *)handle + 13) = 0;
            *((_QWORD *)handle + 14) = v22;
          }
          v29 = *((unsigned int *)v69 + 6);
          goto LABEL_30;
        }
      }
    }
  }
  v29 = 0;
LABEL_30:
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v29;
}

BOOL nw_protocol_http3_uni_stream_get_output_frames(nw_protocol *a1, nw_protocol *a2, int a3, int a4, unsigned int a5, nw_frame_array_s *a6)
{
  _QWORD *handle;
  unint64_t v11;
  unsigned int v12;
  nw_protocol *output_handler;
  NSObject *v14;
  void *v15;
  _BOOL8 result;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  nw_protocol_callbacks *callbacks;
  uint64_t (*get_output_frames)(nw_protocol *, nw_protocol *);
  uint64_t v22;
  nw_frame *tqh_first;
  unsigned int v24;
  unsigned int v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  char *v34;
  _BOOL4 v35;
  char *v36;
  const char *v37;
  NSObject *v38;
  os_log_type_t v39;
  const char *v40;
  NSObject *v41;
  char *backtrace_string;
  _BOOL4 v43;
  const char *v44;
  _BOOL4 v45;
  NSObject *v46;
  _QWORD *v47;
  NSObject *v48;
  _QWORD *v49;
  char v50;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  _BYTE v55[10];
  _BYTE v56[10];
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_protocol_http3_uni_stream_get_output_frames";
    v37 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v37, &type, &v50))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v40 = "%{public}s called with null protocol";
LABEL_93:
        _os_log_impl(&dword_182FBE000, v38, v39, v40, buf, 0xCu);
      }
LABEL_94:
      if (!v37)
        return 0;
      v36 = (char *)v37;
      goto LABEL_53;
    }
    if (!v50)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v40 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = __nwlog_obj();
    v39 = type;
    v43 = os_log_type_enabled(v38, type);
    if (!backtrace_string)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v40 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      v53 = "nw_protocol_http3_uni_stream_get_output_frames";
      v54 = 2082;
      *(_QWORD *)v55 = backtrace_string;
      v44 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_74:
      _os_log_impl(&dword_182FBE000, v38, v39, v44, buf, 0x16u);
    }
LABEL_75:
    free(backtrace_string);
    goto LABEL_94;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v53 = "nw_protocol_http3_uni_stream_get_output_frames";
    v37 = (const char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v50 = 0;
    if (!__nwlog_fault(v37, &type, &v50))
      goto LABEL_94;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v40 = "%{public}s called with null http3_stream";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    if (!v50)
    {
      v38 = __nwlog_obj();
      v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v40 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = __nwlog_obj();
    v39 = type;
    v45 = os_log_type_enabled(v38, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v40 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_93;
      }
      goto LABEL_94;
    }
    if (v45)
    {
      *(_DWORD *)buf = 136446466;
      v53 = "nw_protocol_http3_uni_stream_get_output_frames";
      v54 = 2082;
      *(_QWORD *)v55 = backtrace_string;
      v44 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_74;
    }
    goto LABEL_75;
  }
  if (gLogDatapath)
  {
    v41 = __nwlog_obj();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      v53 = "nw_protocol_http3_uni_stream_get_output_frames";
      v54 = 2048;
      *(_QWORD *)v55 = handle;
      _os_log_impl(&dword_182FBE000, v41, OS_LOG_TYPE_DEBUG, "%{public}s called on http3_uni_stream %p", buf, 0x16u);
    }
  }
  v11 = handle[8];
  if (v11 == -1 || *((_BYTE *)handle + 130))
  {
    v12 = 0;
    output_handler = a1->output_handler;
    if (!output_handler)
      return 0;
    goto LABEL_23;
  }
  if (v11 < 0x40)
  {
    v12 = 1;
    goto LABEL_18;
  }
  if (v11 < 0x4000)
  {
    v12 = 2;
    goto LABEL_18;
  }
  if (!(v11 >> 30))
  {
    v12 = 4;
    goto LABEL_18;
  }
  if (!(v11 >> 62))
  {
    v12 = 8;
    goto LABEL_18;
  }
  v14 = __nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  v53 = "_http_vle_length";
  v54 = 2048;
  *(_QWORD *)v55 = v11;
  v15 = (void *)_os_log_send_and_compose_impl();
  result = __nwlog_abort((uint64_t)v15);
  if (!result)
  {
    free(v15);
    v12 = 0;
LABEL_18:
    v17 = __CFADD__(a3, v12);
    v18 = a3 + v12;
    if (v17)
    {
      if (gLogDatapath)
      {
        v49 = handle;
        v46 = __nwlog_obj();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          v53 = "nw_protocol_http3_uni_stream_get_output_frames";
          v54 = 2082;
          *(_QWORD *)v55 = "minimum_bytes";
          *(_WORD *)&v55[8] = 2048;
          *(_QWORD *)v56 = v12;
          *(_WORD *)&v56[8] = 2048;
          v57 = v18;
          _os_log_impl(&dword_182FBE000, v46, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
        }
        handle = v49;
        v17 = __CFADD__(a4, v12);
        v19 = a4 + v12;
        if (!v17)
        {
LABEL_22:
          output_handler = a1->output_handler;
          if (!output_handler)
            return 0;
LABEL_23:
          callbacks = output_handler->callbacks;
          if (!callbacks)
            return 0;
          get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *))callbacks->get_output_frames;
          if (!get_output_frames)
            return 0;
          v22 = get_output_frames(output_handler, a1);
          if (!(_DWORD)v22 || !v12)
            return v22;
          tqh_first = a6->tqh_first;
          v24 = nw_frame_unclaimed_length(tqh_first);
          if (v24 >= v12)
          {
            if (nw_frame_uses_external_data((uint64_t)tqh_first))
            {
              v31 = (uint64_t)tqh_first;
              v32 = 0;
              v33 = v12;
            }
            else
            {
              v31 = (uint64_t)tqh_first;
              v32 = v12;
              v33 = 0;
            }
            nw_frame_claim(v31, v30, v32, v33);
            *((_BYTE *)handle + 130) = v12;
            return v22;
          }
          v25 = v24;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446722;
          v53 = "nw_protocol_http3_uni_stream_get_output_frames";
          v54 = 1024;
          *(_DWORD *)v55 = v12;
          *(_WORD *)&v55[4] = 1024;
          *(_DWORD *)&v55[6] = v25;
          v26 = (const char *)_os_log_send_and_compose_impl();
          type = OS_LOG_TYPE_ERROR;
          v50 = 0;
          if (__nwlog_fault(v26, &type, &v50))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v27 = gLogObj;
              v28 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type))
                goto LABEL_51;
              *(_DWORD *)buf = 136446722;
              v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              v29 = "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u)";
LABEL_50:
              _os_log_impl(&dword_182FBE000, v27, v28, v29, buf, 0x18u);
              goto LABEL_51;
            }
            if (!v50)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v27 = gLogObj;
              v28 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type))
                goto LABEL_51;
              *(_DWORD *)buf = 136446722;
              v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              v29 = "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u), backtrace limit exceeded";
              goto LABEL_50;
            }
            v34 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v27 = gLogObj;
            v28 = type;
            v35 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (!v34)
            {
              if (!v35)
                goto LABEL_51;
              *(_DWORD *)buf = 136446722;
              v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              v29 = "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u), no backtrace";
              goto LABEL_50;
            }
            if (v35)
            {
              *(_DWORD *)buf = 136446978;
              v53 = "nw_protocol_http3_uni_stream_get_output_frames";
              v54 = 1024;
              *(_DWORD *)v55 = v12;
              *(_WORD *)&v55[4] = 1024;
              *(_DWORD *)&v55[6] = v25;
              *(_WORD *)v56 = 2082;
              *(_QWORD *)&v56[2] = v34;
              _os_log_impl(&dword_182FBE000, v27, v28, "%{public}s Expected http3_stream_type_length (%u) to be <= claimed_length (%u), dumping backtrace:%{public}s", buf, 0x22u);
            }
            free(v34);
          }
LABEL_51:
          if (v26)
          {
            v36 = (char *)v26;
LABEL_53:
            free(v36);
          }
          return 0;
        }
      }
      else
      {
        v17 = __CFADD__(a4, v12);
        v19 = a4 + v12;
        if (!v17)
          goto LABEL_22;
      }
    }
    else
    {
      v17 = __CFADD__(a4, v12);
      v19 = a4 + v12;
      if (!v17)
        goto LABEL_22;
    }
    if (gLogDatapath)
    {
      v47 = handle;
      v48 = __nwlog_obj();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        v53 = "nw_protocol_http3_uni_stream_get_output_frames";
        v54 = 2082;
        *(_QWORD *)v55 = "maximum_bytes";
        *(_WORD *)&v55[8] = 2048;
        *(_QWORD *)v56 = v12;
        *(_WORD *)&v56[8] = 2048;
        v57 = v19;
        _os_log_impl(&dword_182FBE000, v48, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
      }
      handle = v47;
      output_handler = a1->output_handler;
      if (!output_handler)
        return 0;
    }
    else
    {
      output_handler = a1->output_handler;
      if (!output_handler)
        return 0;
    }
    goto LABEL_23;
  }
  __break(1u);
  return result;
}

uint64_t nw_protocol_http3_uni_stream_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  unsigned __int8 *handle;
  nw_frame *tqh_first;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *subrange;
  uint64_t v10;
  void *v11;
  unint64_t v12;
  unint64_t v13;
  NSObject *v14;
  void *v15;
  uint64_t result;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  NSObject *concat;
  char *v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  char *v25;
  _BOOL4 v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  const char *v30;
  char *backtrace_string;
  _BOOL4 v32;
  const char *v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  char v37;
  os_log_type_t type;
  unsigned int v39;
  unint64_t __src;
  size_t offset;
  uint8_t buf[4];
  const char *v43;
  __int16 v44;
  _BYTE v45[10];
  __int16 v46;
  char *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    BYTE4(offset) = 0;
    if (!__nwlog_fault(v27, &__src, (_BYTE *)&offset + 4))
      goto LABEL_107;
    if (__src != 17)
    {
      if (!BYTE4(offset))
      {
        v28 = __nwlog_obj();
        v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
          v30 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_106;
        }
        goto LABEL_107;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = __src;
      v32 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
          v30 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_106;
        }
        goto LABEL_107;
      }
      if (!v32)
        goto LABEL_93;
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_92;
    }
    v28 = __nwlog_obj();
    v29 = __src;
    if (!os_log_type_enabled(v28, (os_log_type_t)__src))
      goto LABEL_107;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    v30 = "%{public}s called with null protocol";
LABEL_106:
    _os_log_impl(&dword_182FBE000, v28, v29, v30, buf, 0xCu);
    goto LABEL_107;
  }
  handle = (unsigned __int8 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    BYTE4(offset) = 0;
    if (!__nwlog_fault(v27, &__src, (_BYTE *)&offset + 4))
      goto LABEL_107;
    if (__src != 17)
    {
      if (!BYTE4(offset))
      {
        v28 = __nwlog_obj();
        v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
          v30 = "%{public}s called with null http3_stream, backtrace limit exceeded";
          goto LABEL_106;
        }
        goto LABEL_107;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v28 = __nwlog_obj();
      v29 = __src;
      v34 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
          v30 = "%{public}s called with null http3_stream, no backtrace";
          goto LABEL_106;
        }
        goto LABEL_107;
      }
      if (!v34)
        goto LABEL_93;
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      v33 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_92;
    }
    v28 = __nwlog_obj();
    v29 = __src;
    if (!os_log_type_enabled(v28, (os_log_type_t)__src))
      goto LABEL_107;
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    v30 = "%{public}s called with null http3_stream";
    goto LABEL_106;
  }
  if (!handle[130])
    return ((uint64_t (*)(nw_protocol *, nw_frame_array_s *))a1->output_handler->callbacks->finalize_output_frames)(a1->output_handler, a2);
  tqh_first = a2->tqh_first;
  if (!nw_frame_uses_external_data((uint64_t)a2->tqh_first))
  {
    nw_frame_unclaim((uint64_t)tqh_first, v6, handle[130], 0);
    HIDWORD(offset) = 0;
    v10 = nw_frame_unclaimed_bytes((uint64_t)tqh_first, (_DWORD *)&offset + 1);
    if (v10)
    {
      v11 = (void *)v10;
      __src = 0;
      v12 = *((_QWORD *)handle + 8);
      if (v12 > 0x3F)
      {
        if (v12 >> 14)
        {
          if (v12 >> 30)
          {
            if (v12 >> 62)
            {
              v14 = __nwlog_obj();
              os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
              *(_DWORD *)buf = 136446466;
              v43 = "_http_vle_encode";
              v44 = 2048;
              *(_QWORD *)v45 = v12;
              v15 = (void *)_os_log_send_and_compose_impl();
              result = __nwlog_abort((uint64_t)v15);
              if ((_DWORD)result)
                goto LABEL_110;
              free(v15);
            }
            else
            {
              __src = bswap64(v12 | 0xC000000000000000);
            }
          }
          else
          {
            __src = bswap32(v12 | 0x80000000);
          }
        }
        else
        {
          __src = bswap32(v12 | 0x4000) >> 16;
        }
      }
      else
      {
        __src = *((_QWORD *)handle + 8);
      }
      memcpy(v11, &__src, handle[130]);
LABEL_53:
      *((_QWORD *)handle + 8) = -1;
      handle[130] = 0;
      return ((uint64_t (*)(nw_protocol *, nw_frame_array_s *))a1->output_handler->callbacks->finalize_output_frames)(a1->output_handler, a2);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    v27 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    LOBYTE(offset) = 0;
    if (!__nwlog_fault(v27, &__src, &offset))
      goto LABEL_107;
    if (__src == 17)
    {
      v28 = __nwlog_obj();
      v29 = __src;
      if (!os_log_type_enabled(v28, (os_log_type_t)__src))
        goto LABEL_107;
      *(_DWORD *)buf = 136446210;
      v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
      v30 = "%{public}s called with null unclaimed_bytes";
      goto LABEL_106;
    }
    if (!(_BYTE)offset)
    {
      v28 = __nwlog_obj();
      v29 = __src;
      if (os_log_type_enabled(v28, (os_log_type_t)__src))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
        v30 = "%{public}s called with null unclaimed_bytes, backtrace limit exceeded";
        goto LABEL_106;
      }
      goto LABEL_107;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = __src;
    v35 = os_log_type_enabled(v28, (os_log_type_t)__src);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
        v30 = "%{public}s called with null unclaimed_bytes, no backtrace";
        goto LABEL_106;
      }
      goto LABEL_107;
    }
    if (!v35)
      goto LABEL_93;
    *(_DWORD *)buf = 136446466;
    v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    v44 = 2082;
    *(_QWORD *)v45 = backtrace_string;
    v33 = "%{public}s called with null unclaimed_bytes, dumping backtrace:%{public}s";
LABEL_92:
    _os_log_impl(&dword_182FBE000, v28, v29, v33, buf, 0x16u);
    goto LABEL_93;
  }
  nw_frame_unclaim((uint64_t)tqh_first, v6, 0, handle[130]);
  offset = 0;
  v7 = nw_frame_copy_external_data((uint64_t)tqh_first, (_DWORD *)&offset + 1, &offset);
  v8 = v7;
  if (HIDWORD(offset))
  {
    subrange = dispatch_data_create_subrange(v7, HIDWORD(offset), 0xFFFFFFFFFFFFFFFFLL);
    if (v8)
      dispatch_release(v8);
  }
  else
  {
    subrange = v7;
  }
  if (subrange)
  {
    __src = 0;
    v13 = *((_QWORD *)handle + 8);
    if (v13 <= 0x3F)
    {
      __src = *((_QWORD *)handle + 8);
      goto LABEL_32;
    }
    if (!(v13 >> 14))
    {
      __src = bswap32(v13 | 0x4000) >> 16;
      goto LABEL_32;
    }
    if (!(v13 >> 30))
    {
      __src = bswap32(v13 | 0x80000000);
      goto LABEL_32;
    }
    if (!(v13 >> 62))
    {
      __src = bswap64(v13 | 0xC000000000000000);
      goto LABEL_32;
    }
    v17 = __nwlog_obj();
    os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    v43 = "_http_vle_encode";
    v44 = 2048;
    *(_QWORD *)v45 = v13;
    v18 = (void *)_os_log_send_and_compose_impl();
    result = __nwlog_abort((uint64_t)v18);
    if (!(_DWORD)result)
    {
      free(v18);
LABEL_32:
      v19 = dispatch_data_create(&__src, handle[130], 0, 0);
      concat = dispatch_data_create_concat(v19, subrange);
      if (v19)
        dispatch_release(v19);
      dispatch_release(subrange);
      v39 = 0;
      nw_frame_set_external_data((uint64_t)tqh_first, concat, &v39);
      if (concat)
        dispatch_release(concat);
      if (v39 == (_DWORD)offset)
        goto LABEL_53;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446722;
      v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
      v44 = 1024;
      *(_DWORD *)v45 = v39;
      *(_WORD *)&v45[4] = 1024;
      *(_DWORD *)&v45[6] = offset;
      v21 = (char *)_os_log_send_and_compose_impl();
      type = OS_LOG_TYPE_ERROR;
      v37 = 0;
      if (!__nwlog_fault(v21, &type, &v37))
        goto LABEL_51;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_51;
        *(_DWORD *)buf = 136446722;
        v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
        v44 = 1024;
        *(_DWORD *)v45 = v39;
        *(_WORD *)&v45[4] = 1024;
        *(_DWORD *)&v45[6] = offset;
        v24 = "%{public}s Incorrect frame length set: %u != %u";
      }
      else if (v37)
      {
        v25 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        v26 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v25)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446978;
            v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
            v44 = 1024;
            *(_DWORD *)v45 = v39;
            *(_WORD *)&v45[4] = 1024;
            *(_DWORD *)&v45[6] = offset;
            v46 = 2082;
            v47 = v25;
            _os_log_impl(&dword_182FBE000, v22, v23, "%{public}s Incorrect frame length set: %u != %u, dumping backtrace:%{public}s", buf, 0x22u);
          }
          free(v25);
          goto LABEL_51;
        }
        if (!v26)
        {
LABEL_51:
          if (v21)
            free(v21);
          goto LABEL_53;
        }
        *(_DWORD *)buf = 136446722;
        v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
        v44 = 1024;
        *(_DWORD *)v45 = v39;
        *(_WORD *)&v45[4] = 1024;
        *(_DWORD *)&v45[6] = offset;
        v24 = "%{public}s Incorrect frame length set: %u != %u, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v22 = gLogObj;
        v23 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type))
          goto LABEL_51;
        *(_DWORD *)buf = 136446722;
        v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
        v44 = 1024;
        *(_DWORD *)v45 = v39;
        *(_WORD *)&v45[4] = 1024;
        *(_DWORD *)&v45[6] = offset;
        v24 = "%{public}s Incorrect frame length set: %u != %u, backtrace limit exceeded";
      }
      _os_log_impl(&dword_182FBE000, v22, v23, v24, buf, 0x18u);
      goto LABEL_51;
    }
LABEL_110:
    __break(1u);
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
  v27 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  LOBYTE(v39) = 0;
  if (!__nwlog_fault(v27, &__src, &v39))
    goto LABEL_107;
  if (__src != 17)
  {
    if (!(_BYTE)v39)
    {
      v28 = __nwlog_obj();
      v29 = __src;
      if (os_log_type_enabled(v28, (os_log_type_t)__src))
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
        v30 = "%{public}s called with null external_data, backtrace limit exceeded";
        goto LABEL_106;
      }
      goto LABEL_107;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v28 = __nwlog_obj();
    v29 = __src;
    v36 = os_log_type_enabled(v28, (os_log_type_t)__src);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
        v30 = "%{public}s called with null external_data, no backtrace";
        goto LABEL_106;
      }
      goto LABEL_107;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
      v44 = 2082;
      *(_QWORD *)v45 = backtrace_string;
      v33 = "%{public}s called with null external_data, dumping backtrace:%{public}s";
      goto LABEL_92;
    }
LABEL_93:
    free(backtrace_string);
    goto LABEL_107;
  }
  v28 = __nwlog_obj();
  v29 = __src;
  if (os_log_type_enabled(v28, (os_log_type_t)__src))
  {
    *(_DWORD *)buf = 136446210;
    v43 = "nw_protocol_http3_uni_stream_finalize_output_frames";
    v30 = "%{public}s called with null external_data";
    goto LABEL_106;
  }
LABEL_107:
  if (v27)
    free(v27);
  return 0;
}

uint64_t nw_protocol_http3_uni_stream_supports_external_data(nw_protocol *a1)
{
  unsigned __int8 *handle;
  char *v3;
  NSObject *v4;
  os_log_type_t v5;
  const char *v6;
  char *backtrace_string;
  _BOOL4 v8;
  const char *v9;
  _BOOL4 v10;
  char v11;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    handle = (unsigned __int8 *)a1->handle;
    if (handle)
      return (handle[131] >> 4) & 1;
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_http3_uni_stream_supports_external_data";
    v3 = (char *)_os_log_send_and_compose_impl();
    type = OS_LOG_TYPE_ERROR;
    v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11))
      goto LABEL_32;
    if (type == OS_LOG_TYPE_FAULT)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http3_uni_stream_supports_external_data";
        v6 = "%{public}s called with null http3_stream";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http3_uni_stream_supports_external_data";
        v6 = "%{public}s called with null http3_stream, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http3_uni_stream_supports_external_data";
        v6 = "%{public}s called with null http3_stream, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_http3_uni_stream_supports_external_data";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null http3_stream, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v14 = "nw_protocol_http3_uni_stream_supports_external_data";
  v3 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11))
    goto LABEL_32;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      v4 = __nwlog_obj();
      v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http3_uni_stream_supports_external_data";
        v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v4 = __nwlog_obj();
    v5 = type;
    v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        v14 = "nw_protocol_http3_uni_stream_supports_external_data";
        v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      v14 = "nw_protocol_http3_uni_stream_supports_external_data";
      v15 = 2082;
      v16 = backtrace_string;
      v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_182FBE000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v4 = __nwlog_obj();
  v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    v14 = "nw_protocol_http3_uni_stream_supports_external_data";
    v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_182FBE000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3)
    free(v3);
  return 0;
}

BOOL ___ZL45nw_protocol_http3_uni_stream_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v10;
  unint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned int v19;

  v19 = 0;
  v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v19);
  v5 = *(_QWORD *)(a1 + 40);
  v6 = *(unsigned __int16 *)(v5 + 128);
  if (8 - v6 >= (unint64_t)v19)
    v7 = v19;
  else
    v7 = 8 - v6;
  memcpy((void *)(v5 + v6 + 120), v4, v7);
  v9 = *(_QWORD *)(a1 + 40);
  v10 = *(_WORD *)(v9 + 128) + v7;
  *(_WORD *)(v9 + 128) = v10;
  if (!v10)
  {
    v10 = 0;
LABEL_9:
    v12 = 0;
    v13 = 0;
    goto LABEL_10;
  }
  v11 = *(unsigned __int8 *)(v9 + 120);
  if (v11 <= 0x3F)
  {
    v12 = 1;
LABEL_7:
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v11;
    v10 -= v12;
    v13 = 4;
    goto LABEL_10;
  }
  if (v11 >> 6 == 2)
  {
    if (v10 >= 4u)
    {
      v11 = bswap32(*(_DWORD *)(v9 + 120) & 0xFFFFFF7F);
      v12 = 4;
      goto LABEL_7;
    }
    goto LABEL_9;
  }
  if (v11 >> 6 != 1)
  {
    if (v10 >= 8u)
    {
      v11 = bswap64(*(_QWORD *)(v9 + 120) & 0xFFFFFFFFFFFFFF3FLL);
      v12 = 8;
      goto LABEL_7;
    }
    goto LABEL_9;
  }
  if (v10 >= 2u)
  {
    v11 = bswap32(*(_WORD *)(v9 + 120) & 0xFFBF) >> 16;
    v12 = 2;
    goto LABEL_7;
  }
  v12 = 0;
  v13 = 0;
  v10 = 1;
LABEL_10:
  *(_BYTE *)(v9 + 131) = *(_BYTE *)(v9 + 131) & 0xFB | v13;
  v14 = *(_QWORD *)(a1 + 40);
  *(_WORD *)(v14 + 128) = v10;
  v15 = *(_BYTE *)(v14 + 131);
  if ((v15 & 4) != 0)
  {
    nw_frame_claim(a2, v8, v12 - v6, 0);
  }
  else
  {
    v16 = *(_QWORD *)(a2 + 32);
    v17 = *(_QWORD **)(a2 + 40);
    if (v16)
    {
      *(_QWORD *)(v16 + 40) = v17;
      v17 = *(_QWORD **)(a2 + 40);
    }
    else
    {
      *(_QWORD *)(v14 + 112) = v17;
    }
    *v17 = v16;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
  }
  return (v15 & 4) == 0;
}

void nw_http3_fail_all_streams(nw_protocol *a1, uint64_t a2)
{
  nw_protocol *default_input_handler;
  nw_protocol *output_handler;
  nw_protocol_callbacks *callbacks;
  char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v10;
  NSObject *v11;
  int v12;
  char *backtrace_string;
  _BOOL4 v14;
  char v15;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (((*(unsigned __int16 *)((char *)&a1[21].callbacks + 5) | (HIBYTE(a1[21].callbacks) << 16)) & 0x400000) == 0)
    {
      if (gLogDatapath)
      {
        v11 = __nwlog_obj();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          v12 = *(_DWORD *)a1[20].flow_id;
          *(_DWORD *)buf = 136446978;
          v18 = "nw_http3_fail_all_streams";
          v19 = 2082;
          v20 = (char *)&a1[20].flow_id[9];
          v21 = 2080;
          v22 = " ";
          v23 = 1024;
          v24 = v12;
          _os_log_impl(&dword_182FBE000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    default_input_handler = a1[13].default_input_handler;
    if (default_input_handler)
    {
      do
      {
        output_handler = default_input_handler[8].output_handler;
        nw_protocol_http3_stream_error(default_input_handler, a1, 100);
        default_input_handler = output_handler;
      }
      while (output_handler);
    }
    callbacks = a1[19].callbacks;
    if (callbacks)
      nw_quic_connection_close_with_error(callbacks, a2);
    nw_http3_async_close_connection_if_no_stream((uint64_t)a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v18 = "nw_http3_fail_all_streams";
  v7 = (char *)_os_log_send_and_compose_impl();
  type = OS_LOG_TYPE_ERROR;
  v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_http3_fail_all_streams";
      v10 = "%{public}s called with null http3";
      goto LABEL_25;
    }
    if (!v15)
    {
      v8 = __nwlog_obj();
      v9 = type;
      if (!os_log_type_enabled(v8, type))
        goto LABEL_26;
      *(_DWORD *)buf = 136446210;
      v18 = "nw_http3_fail_all_streams";
      v10 = "%{public}s called with null http3, backtrace limit exceeded";
      goto LABEL_25;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v8 = __nwlog_obj();
    v9 = type;
    v14 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        v18 = "nw_http3_fail_all_streams";
        v19 = 2082;
        v20 = backtrace_string;
        _os_log_impl(&dword_182FBE000, v8, v9, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_26;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      v18 = "nw_http3_fail_all_streams";
      v10 = "%{public}s called with null http3, no backtrace";
LABEL_25:
      _os_log_impl(&dword_182FBE000, v8, v9, v10, buf, 0xCu);
    }
  }
LABEL_26:
  if (v7)
    free(v7);
}

void nw_http3_control_stream_process_input(uint64_t a1)
{
  unsigned __int16 *v2;
  uint64_t v3;
  int v4;
  int v5;
  __CFError *v6;
  uint64_t v7;
  __int16 v8;
  unsigned int v9;
  __n128 v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  _BYTE *v15;
  _QWORD *v16;
  void (*v17)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  os_log_type_t v23;
  NSObject *v24;
  os_log_type_t v25;
  const char *v26;
  char *v27;
  NSObject *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  NSObject *v31;
  os_log_type_t v32;
  int v33;
  unsigned int v34;
  _QWORD *v35;
  void (*v36)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  NSObject *v41;
  os_log_type_t v42;
  NSObject *v43;
  os_log_type_t v44;
  const char *v45;
  char *v46;
  NSObject *v47;
  os_log_type_t v48;
  _BOOL4 v49;
  NSObject *v50;
  os_log_type_t v51;
  NSObject *v52;
  int v53;
  NSObject *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(void);
  NSObject *v59;
  __int16 v60;
  uint64_t v61;
  uint64_t v62;
  char v63;
  id v64;
  void *v65;
  uint64_t v66;
  int v67;
  void *v68;
  NSObject *v69;
  NSObject *v70;
  int v71;
  _BOOL4 v72;
  CFErrorRef v73;
  const __CFArray *v74;
  CFIndex i;
  const __CFArray *v76;
  CFIndex j;
  const __CFString *ValueAtIndex;
  char *c_string_from_cfstring;
  unsigned int port;
  _BOOL8 host_with_numeric_port;
  NSObject *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  NSObject *v86;
  _BOOL4 v87;
  int v88;
  _QWORD *v89;
  void (*v90)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  uint64_t v95;
  os_log_type_t v96;
  NSObject *v97;
  os_log_type_t v98;
  const char *v99;
  char *v100;
  NSObject *v101;
  os_log_type_t v102;
  _BOOL4 v103;
  NSObject *v104;
  os_log_type_t v105;
  uint64_t v106;
  const char *v107;
  char *v108;
  NSObject *v109;
  os_log_type_t v110;
  uint64_t v111;
  const char *v112;
  char *v113;
  NSObject *v114;
  os_log_type_t v115;
  _BOOL4 v116;
  uint64_t v117;
  const char *v118;
  NSObject *v119;
  int v120;
  NSObject *v121;
  int v122;
  NSObject *v123;
  os_log_type_t v124;
  uint64_t v125;
  const char *v126;
  NSObject *v127;
  int v128;
  NSObject *v129;
  int v130;
  uint64_t v131;
  const char *v132;
  NSObject *v133;
  int v134;
  NSObject *v135;
  os_log_type_t v136;
  const char *v137;
  NSObject *v138;
  int v139;
  _QWORD *v140;
  void (*v141)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v142;
  uint64_t v143;
  const char *v144;
  NSObject *v145;
  os_log_type_t v146;
  const char *v147;
  _BOOL4 v148;
  char *v149;
  NSObject *v150;
  int v151;
  _QWORD *v152;
  void (*v153)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v154;
  uint64_t v155;
  const char *v156;
  NSObject *v157;
  os_log_type_t v158;
  const char *v159;
  _BOOL4 v160;
  char *v161;
  nw_protocol *v162;
  uint64_t v163;
  _QWORD *v164;
  void (*v165)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v166;
  uint64_t v167;
  const char *v168;
  NSObject *v169;
  os_log_type_t v170;
  const char *v171;
  _BOOL4 v172;
  char *v173;
  NSObject *v174;
  int v175;
  _QWORD *v176;
  void (*v177)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v178;
  uint64_t v179;
  const char *v180;
  NSObject *v181;
  os_log_type_t v182;
  const char *v183;
  _BOOL4 v184;
  char *v185;
  _BYTE *v186;
  NSObject *v187;
  int v188;
  _QWORD *v189;
  void (*v190)(_QWORD *, uint64_t, uint64_t);
  _QWORD *v191;
  uint64_t v192;
  const char *v193;
  NSObject *v194;
  os_log_type_t v195;
  const char *v196;
  _BOOL4 v197;
  char *v198;
  NSObject *v199;
  os_log_type_t v200;
  const char *v201;
  char *v202;
  NSObject *v203;
  os_log_type_t v204;
  const char *v205;
  char *backtrace_string;
  _BOOL4 v207;
  char *v208;
  _BOOL4 v209;
  uint64_t v210;
  void *object;
  NSObject *trust;
  __SecTrust *v213;
  os_log_type_t v214;
  os_log_type_t v215;
  os_log_type_t v216;
  os_log_type_t v217;
  os_log_type_t v218;
  os_log_type_t log;
  NSObject *loga;
  os_log_type_t logb;
  os_log_type_t logc;
  NSObject *logd;
  os_log_type_t loge;
  os_log_type_t logf;
  NSObject *logg;
  os_log_type_t logh;
  os_log_type_t logi;
  NSObject *logj;
  os_log_type_t logk;
  os_log_type_t logl;
  NSObject *logm;
  os_log_type_t logn;
  void *v234;
  NSObject *v235;
  const char *v236;
  NSObject *v237;
  NSObject *v238;
  const char *v239;
  NSObject *v240;
  NSObject *v241;
  const char *v242;
  NSObject *v243;
  NSObject *v244;
  const char *v245;
  NSObject *v246;
  NSObject *v247;
  char *v248;
  NSObject *v249;
  char *v250;
  char *v251;
  char *v252;
  char *v253;
  char *v254;
  _QWORD v255[2];
  uint64_t (*v256)(_QWORD *);
  void *v257;
  os_log_type_t *v258;
  _BYTE *v259;
  uint64_t v260;
  os_log_type_t type[8];
  _QWORD v262[2];
  uint64_t (*v263)(_QWORD *);
  void *v264;
  os_log_type_t *v265;
  _BYTE *v266;
  char *v267;
  char v268;
  __CFError *v269;
  uint64_t v270;
  os_log_type_t v271[8];
  os_log_type_t *v272;
  uint64_t v273;
  __n128 (*v274)(uint64_t, uint64_t);
  uint64_t (*v275)();
  _QWORD v276[2];
  CFErrorRef error;
  char v278;
  _BYTE v279[24];
  int v280;
  _BYTE buf[24];
  const char *v282;
  __int16 v283;
  int v284;
  __int16 v285;
  CFErrorRef v286;
  __int16 v287;
  uint64_t v288;
  uint64_t v289;

  v289 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
    v198 = (char *)_os_log_send_and_compose_impl();
    v271[0] = OS_LOG_TYPE_ERROR;
    v279[0] = 0;
    if (!__nwlog_fault(v198, v271, v279))
      goto LABEL_361;
    if (v271[0] == OS_LOG_TYPE_FAULT)
    {
      v199 = __nwlog_obj();
      v200 = v271[0];
      if (!os_log_type_enabled(v199, v271[0]))
        goto LABEL_361;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
      v201 = "%{public}s called with null http3";
    }
    else if (v279[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v199 = __nwlog_obj();
      v200 = v271[0];
      v207 = os_log_type_enabled(v199, v271[0]);
      if (backtrace_string)
      {
        if (v207)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_182FBE000, v199, v200, "%{public}s called with null http3, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_361;
      }
      if (!v207)
      {
LABEL_361:
        if (v198)
          free(v198);
        return;
      }
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
      v201 = "%{public}s called with null http3, no backtrace";
    }
    else
    {
      v199 = __nwlog_obj();
      v200 = v271[0];
      if (!os_log_type_enabled(v199, v271[0]))
        goto LABEL_361;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
      v201 = "%{public}s called with null http3, backtrace limit exceeded";
    }
    _os_log_impl(&dword_182FBE000, v199, v200, v201, buf, 0xCu);
    goto LABEL_361;
  }
  v234 = (void *)(a1 + 168);
  v2 = (unsigned __int16 *)(a1 + 1373);
  v3 = a1 + 1289;
  while (1)
  {
    *(_QWORD *)v271 = 0;
    v272 = v271;
    v273 = 0x3802000000;
    v274 = __Block_byref_object_copy__60023;
    v275 = __Block_byref_object_dispose__60024;
    v276[0] = 0;
    v276[1] = v276;
    v269 = 0;
    v270 = -1;
    v268 = 0;
    if (!nw_http3_framer_get_input_frames((uint64_t)v234, 0xFFFFu, 0xFFFFu, 0xFFFFFFFF, &v270, &v269, &v268, 0, (uint64_t)v276))goto LABEL_334;
    v4 = *v2;
    v5 = v4 | (*((unsigned __int8 *)v2 + 2) << 16);
    if ((v4 & 0x1000) != 0)
    {
      v16 = (_QWORD *)*((_QWORD *)v272 + 5);
      if (!v16)
      {
LABEL_35:
        if (v268)
        {
          v33 = *v2;
          v34 = v33 & 0xFFFFEFFF | (*((unsigned __int8 *)v2 + 2) << 16);
          *v2 = v33 & 0xEFFF;
          *((_BYTE *)v2 + 2) = BYTE2(v34);
        }
        goto LABEL_3;
      }
      while (1)
      {
        while (1)
        {
          v17 = (void (*)(_QWORD *, uint64_t, uint64_t))v16[10];
          v18 = (_QWORD *)v16[4];
          if (!v17)
            break;
          v19 = v16[11];
          v16[10] = 0;
          v16[11] = 0;
          v17(v16, 1, v19);
          v16 = v18;
          if (!v18)
            goto LABEL_35;
        }
        v20 = v3;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v21 = (char *)_os_log_send_and_compose_impl();
        v279[0] = 16;
        LOBYTE(error) = 0;
        if (!__nwlog_fault(v21, v279, &error))
          goto LABEL_32;
        if (v279[0] == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v22 = gLogObj;
          v23 = v279[0];
          if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v279[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v24 = v22;
            v25 = v23;
            v26 = "%{public}s called with null frame->finalizer";
LABEL_31:
            _os_log_impl(&dword_182FBE000, v24, v25, v26, buf, 0xCu);
          }
        }
        else if ((_BYTE)error)
        {
          v27 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v28 = gLogObj;
          v29 = v279[0];
          v30 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v279[0]);
          if (v27)
          {
            if (v30)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_frame_finalize";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v27;
              _os_log_impl(&dword_182FBE000, v28, v29, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v27);
            goto LABEL_32;
          }
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v24 = v28;
            v25 = v29;
            v26 = "%{public}s called with null frame->finalizer, no backtrace";
            goto LABEL_31;
          }
        }
        else
        {
          v31 = __nwlog_obj();
          v32 = v279[0];
          if (os_log_type_enabled(v31, (os_log_type_t)v279[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v24 = v31;
            v25 = v32;
            v26 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_31;
          }
        }
LABEL_32:
        if (v21)
          free(v21);
        v3 = v20;
        v16 = v18;
        if (!v18)
          goto LABEL_35;
      }
    }
    if (v268)
      break;
    v35 = (_QWORD *)*((_QWORD *)v272 + 5);
    if (!v35)
      goto LABEL_59;
    do
    {
      while (1)
      {
        v36 = (void (*)(_QWORD *, uint64_t, uint64_t))v35[10];
        v37 = (_QWORD *)v35[4];
        if (!v36)
          break;
        v38 = v35[11];
        v35[10] = 0;
        v35[11] = 0;
        v36(v35, 1, v38);
        v35 = v37;
        if (!v37)
          goto LABEL_58;
      }
      v39 = v3;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v40 = (char *)_os_log_send_and_compose_impl();
      v279[0] = 16;
      LOBYTE(error) = 0;
      if (__nwlog_fault(v40, v279, &error))
      {
        if (v279[0] == 17)
        {
          v41 = __nwlog_obj();
          v42 = v279[0];
          if (!os_log_type_enabled(v41, (os_log_type_t)v279[0]))
            goto LABEL_55;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v43 = v41;
          v44 = v42;
          v45 = "%{public}s called with null frame->finalizer";
LABEL_54:
          _os_log_impl(&dword_182FBE000, v43, v44, v45, buf, 0xCu);
          goto LABEL_55;
        }
        if (!(_BYTE)error)
        {
          v50 = __nwlog_obj();
          v51 = v279[0];
          if (!os_log_type_enabled(v50, (os_log_type_t)v279[0]))
            goto LABEL_55;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v43 = v50;
          v44 = v51;
          v45 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_54;
        }
        v46 = (char *)__nw_create_backtrace_string();
        v47 = __nwlog_obj();
        v48 = v279[0];
        v49 = os_log_type_enabled(v47, (os_log_type_t)v279[0]);
        if (!v46)
        {
          if (!v49)
            goto LABEL_55;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v43 = v47;
          v44 = v48;
          v45 = "%{public}s called with null frame->finalizer, no backtrace";
          goto LABEL_54;
        }
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v46;
          _os_log_impl(&dword_182FBE000, v47, v48, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v46);
      }
LABEL_55:
      if (v40)
        free(v40);
      v3 = v39;
      v35 = v37;
    }
    while (v37);
LABEL_58:
    v5 = *v2 | (*((unsigned __int8 *)v2 + 2) << 16);
LABEL_59:
    *((_BYTE *)v2 + 2) = BYTE2(v5);
    *v2 = v5 | 0x1000;
    if ((v5 & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v52 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v53 = *(_DWORD *)(a1 + 1280);
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v3;
        *(_WORD *)&buf[22] = 2080;
        v282 = " ";
        v283 = 1024;
        v284 = v53;
        v285 = 2048;
        v286 = v269;
        v287 = 2048;
        v288 = v270;
        _os_log_impl(&dword_182FBE000, v52, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Dropping oversized frame %llu of type %llu on control stream", buf, 0x3Au);
      }
    }
LABEL_3:
    _Block_object_dispose(v271, 8);
  }
  v6 = (__CFError *)v270;
  v7 = *(_QWORD *)(a1 + 1176);
  if (v270 != 4)
  {
    if (v7)
    {
      if (v270 <= 4287504052)
      {
        if (v270 == 7)
        {
          if ((v5 & 0x400000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v54 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              v55 = *(_DWORD *)(a1 + 1280);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v3;
              *(_WORD *)&buf[22] = 2080;
              v282 = " ";
              v283 = 1024;
              v284 = v55;
              _os_log_impl(&dword_182FBE000, v54, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> received a GOAWAY, connection will not be reused", buf, 0x26u);
            }
          }
          nw_http3_async_close_connection_if_no_stream(a1);
          v56 = *(_QWORD *)(a1 + 32);
          if (v56)
          {
            v57 = *(_QWORD *)(v56 + 24);
            if (v57)
            {
              v58 = *(void (**)(void))(v57 + 240);
              if (v58)
              {
                v58();
LABEL_72:
                nw_http3_notify_do_not_reuse(a1);
                goto LABEL_137;
              }
            }
          }
          __nwlog_obj();
          v106 = *(_QWORD *)(a1 + 32);
          if (v106)
          {
            v107 = *(const char **)(v106 + 16);
            if (!v107)
              v107 = "invalid";
          }
          else
          {
            v107 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v107;
          v108 = (char *)_os_log_send_and_compose_impl();
          v279[0] = 16;
          LOBYTE(error) = 0;
          if (__nwlog_fault(v108, v279, &error))
          {
            if (v279[0] == 17)
            {
              v109 = __nwlog_obj();
              v110 = v279[0];
              if (!os_log_type_enabled(v109, (os_log_type_t)v279[0]))
                goto LABEL_208;
              v111 = *(_QWORD *)(a1 + 32);
              if (v111)
              {
                v112 = *(const char **)(v111 + 16);
                if (!v112)
                  v112 = "invalid";
              }
              else
              {
                v112 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v112;
              v135 = v109;
              v136 = v110;
              v137 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback";
              goto LABEL_207;
            }
            if (!(_BYTE)error)
            {
              v123 = __nwlog_obj();
              v124 = v279[0];
              if (!os_log_type_enabled(v123, (os_log_type_t)v279[0]))
                goto LABEL_208;
              v125 = *(_QWORD *)(a1 + 32);
              if (v125)
              {
                v126 = *(const char **)(v125 + 16);
                if (!v126)
                  v126 = "invalid";
              }
              else
              {
                v126 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v126;
              v135 = v123;
              v136 = v124;
              v137 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, backtrace limit exceeded";
              goto LABEL_207;
            }
            v113 = (char *)__nw_create_backtrace_string();
            v114 = __nwlog_obj();
            v115 = v279[0];
            v116 = os_log_type_enabled(v114, (os_log_type_t)v279[0]);
            if (v113)
            {
              if (v116)
              {
                v117 = *(_QWORD *)(a1 + 32);
                if (v117)
                {
                  v118 = *(const char **)(v117 + 16);
                  if (!v118)
                    v118 = "invalid";
                }
                else
                {
                  v118 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v118;
                *(_WORD *)&buf[22] = 2082;
                v282 = v113;
                _os_log_impl(&dword_182FBE000, v114, v115, "%{public}s protocol %{public}s has invalid remove_listen_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v113);
              goto LABEL_208;
            }
            if (v116)
            {
              v131 = *(_QWORD *)(a1 + 32);
              if (v131)
              {
                v132 = *(const char **)(v131 + 16);
                if (!v132)
                  v132 = "invalid";
              }
              else
              {
                v132 = "invalid";
              }
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v132;
              v135 = v114;
              v136 = v115;
              v137 = "%{public}s protocol %{public}s has invalid remove_listen_handler callback, no backtrace";
LABEL_207:
              _os_log_impl(&dword_182FBE000, v135, v136, v137, buf, 0x16u);
            }
          }
LABEL_208:
          if (v108)
            free(v108);
          goto LABEL_72;
        }
        if ((unint64_t)v270 >= 2 && v270 != 5)
        {
LABEL_87:
          if ((v5 & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              v70 = __nwlog_obj();
              if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
              {
                v71 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v3;
                *(_WORD *)&buf[22] = 2080;
                v282 = " ";
                v283 = 1024;
                v284 = v71;
                v285 = 2048;
                v286 = v6;
                _os_log_impl(&dword_182FBE000, v70, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received unsupported frame %llu", buf, 0x30u);
              }
            }
          }
LABEL_137:
          v89 = (_QWORD *)*((_QWORD *)v272 + 5);
          if (!v89)
            goto LABEL_3;
          while (1)
          {
            while (1)
            {
              v90 = (void (*)(_QWORD *, uint64_t, uint64_t))v89[10];
              v91 = (_QWORD *)v89[4];
              if (!v90)
                break;
              v92 = v89[11];
              v89[10] = 0;
              v89[11] = 0;
              v90(v89, 1, v92);
              v89 = v91;
              if (!v91)
                goto LABEL_3;
            }
            v93 = v3;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v94 = (char *)_os_log_send_and_compose_impl();
            v279[0] = 16;
            LOBYTE(error) = 0;
            if (!__nwlog_fault(v94, v279, &error))
              goto LABEL_155;
            if (v279[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v95 = gLogObj;
              v96 = v279[0];
              if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v279[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                v97 = v95;
                v98 = v96;
                v99 = "%{public}s called with null frame->finalizer";
LABEL_154:
                _os_log_impl(&dword_182FBE000, v97, v98, v99, buf, 0xCu);
              }
            }
            else if ((_BYTE)error)
            {
              v100 = (char *)__nw_create_backtrace_string();
              v101 = __nwlog_obj();
              v102 = v279[0];
              v103 = os_log_type_enabled(v101, (os_log_type_t)v279[0]);
              if (v100)
              {
                if (v103)
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v100;
                  _os_log_impl(&dword_182FBE000, v101, v102, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v100);
                goto LABEL_155;
              }
              if (v103)
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                v97 = v101;
                v98 = v102;
                v99 = "%{public}s called with null frame->finalizer, no backtrace";
                goto LABEL_154;
              }
            }
            else
            {
              v104 = __nwlog_obj();
              v105 = v279[0];
              if (os_log_type_enabled(v104, (os_log_type_t)v279[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(_QWORD *)&buf[4] = "__nw_frame_finalize";
                v97 = v104;
                v98 = v105;
                v99 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
                goto LABEL_154;
              }
            }
LABEL_155:
            if (v94)
              free(v94);
            v89 = v91;
            v3 = v93;
            if (!v91)
              goto LABEL_3;
          }
        }
        if ((v5 & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v174 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v175 = *(_DWORD *)(a1 + 1280);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v3;
            *(_WORD *)&buf[22] = 2080;
            v282 = " ";
            v283 = 1024;
            v284 = v175;
            v285 = 2048;
            v286 = v6;
            _os_log_impl(&dword_182FBE000, v174, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Invalid frame %llu on control stream", buf, 0x30u);
          }
        }
        v176 = (_QWORD *)*((_QWORD *)v272 + 5);
        if (!v176)
        {
LABEL_304:
          v162 = (nw_protocol *)a1;
          v163 = 261;
          goto LABEL_305;
        }
        while (1)
        {
          v177 = (void (*)(_QWORD *, uint64_t, uint64_t))v176[10];
          v178 = (_QWORD *)v176[4];
          if (!v177)
            break;
          v179 = v176[11];
          v176[10] = 0;
          v176[11] = 0;
          v177(v176, 1, v179);
LABEL_286:
          v176 = v178;
          if (!v178)
            goto LABEL_304;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v180 = (const char *)_os_log_send_and_compose_impl();
        v279[0] = 16;
        LOBYTE(error) = 0;
        v253 = (char *)v180;
        if (__nwlog_fault(v180, v279, &error))
        {
          if (v279[0] == 17)
          {
            v244 = __nwlog_obj();
            logi = v279[0];
            if (!os_log_type_enabled(v244, (os_log_type_t)v279[0]))
              goto LABEL_302;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v181 = v244;
            v182 = logi;
            v183 = "%{public}s called with null frame->finalizer";
            goto LABEL_301;
          }
          if (!(_BYTE)error)
          {
            v246 = __nwlog_obj();
            logk = v279[0];
            if (!os_log_type_enabled(v246, (os_log_type_t)v279[0]))
              goto LABEL_302;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v181 = v246;
            v182 = logk;
            v183 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
            goto LABEL_301;
          }
          v245 = __nw_create_backtrace_string();
          logj = __nwlog_obj();
          v217 = v279[0];
          v184 = os_log_type_enabled(logj, (os_log_type_t)v279[0]);
          v185 = (char *)v245;
          if (v245)
          {
            if (v184)
            {
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = "__nw_frame_finalize";
              *(_WORD *)&buf[12] = 2082;
              *(_QWORD *)&buf[14] = v245;
              _os_log_impl(&dword_182FBE000, logj, v217, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
              v185 = (char *)v245;
            }
            free(v185);
            goto LABEL_302;
          }
          if (v184)
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            v181 = logj;
            v182 = v217;
            v183 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_301:
            _os_log_impl(&dword_182FBE000, v181, v182, v183, buf, 0xCu);
          }
        }
LABEL_302:
        if (v253)
          free(v253);
        goto LABEL_286;
      }
      if (v270 != 4287504053)
        goto LABEL_87;
      v59 = *(NSObject **)(a1 + 1184);
      if (v59)
      {
        dispatch_release(v59);
        *(_QWORD *)(a1 + 1184) = 0;
      }
      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)v272 + 5, 1, buf);
      v60 = *(_WORD *)buf;
      *(_QWORD *)type = 0;
      *(_QWORD *)(a1 + 1184) = dispatch_data_create_alloc();
      **(_WORD **)type = v60;
      *(_QWORD *)v279 = 0;
      *(_QWORD *)&v279[8] = v279;
      v280 = 0;
      *(_QWORD *)&v279[16] = 0x2000000000;
      v255[0] = MEMORY[0x1E0C809B0];
      v255[1] = 0x40000000;
      v256 = (uint64_t (*)(_QWORD *))___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke_68;
      v257 = &unk_1E14A7E80;
      v259 = v279;
      v260 = *(_QWORD *)type + 2;
      v258 = v271;
      v61 = *((_QWORD *)v272 + 5);
      do
      {
        if (!v61)
          break;
        v62 = *(_QWORD *)(v61 + 32);
        v63 = v256(v255);
        v61 = v62;
      }
      while ((v63 & 1) != 0);
      v64 = nw_quic_connection_copy_sec_protocol_metadata(*(void **)(a1 + 1240));
      if (v64)
      {
        v65 = v64;
        v66 = sec_protocol_metadata_copy_authenticator_trust();
        v67 = *v2 | (*((unsigned __int8 *)v2 + 2) << 16);
        trust = v66;
        if (v66)
        {
          if ((v67 & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              v119 = __nwlog_obj();
              if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
              {
                v120 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v3;
                *(_WORD *)&buf[22] = 2080;
                v282 = " ";
                v283 = 1024;
                v284 = v120;
                v285 = 2112;
                v286 = (CFErrorRef)trust;
                _os_log_impl(&dword_182FBE000, v119, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Received trust %@", buf, 0x30u);
              }
            }
          }
          object = v65;
          v68 = *(void **)(a1 + 1096);
          if (v68)
            v69 = os_retain(v68);
          else
            v69 = 0;
          v213 = sec_trust_copy_ref(trust);
          if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
          {
            if (gLogDatapath)
            {
              v121 = __nwlog_obj();
              if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
              {
                v122 = *(_DWORD *)(a1 + 1280);
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v3;
                *(_WORD *)&buf[22] = 2080;
                v282 = " ";
                v283 = 1024;
                v284 = v122;
                v285 = 2112;
                v286 = v213;
                _os_log_impl(&dword_182FBE000, v121, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Received Authenticator trustRef: %@", buf, 0x30u);
              }
            }
          }
          if (*(_QWORD *)(a1 + 1248))
          {
            if ((nw_parameters_get_should_trust_invalid_certificates(*(void **)(a1 + 1120)) & 1) != 0
              || (error = 0, v72 = SecTrustEvaluateWithError(v213, &error), v73 = error, v72) && !error)
            {
              if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
              {
                if (gLogDatapath)
                {
                  v127 = __nwlog_obj();
                  if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                  {
                    v128 = *(_DWORD *)(a1 + 1280);
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v3;
                    *(_WORD *)&buf[22] = 2080;
                    v282 = " ";
                    v283 = 1024;
                    v284 = v128;
                    _os_log_impl(&dword_182FBE000, v127, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Trusted incoming secondary certificate", buf, 0x26u);
                  }
                }
              }
              v210 = v3;
              if (v213)
              {
                v74 = SecTrustCopyCertificateChain(v213);
                for (i = 0; CFArrayGetCount(v74) > i; ++i)
                {
                  CFArrayGetValueAtIndex(v74, 0);
                  v76 = (const __CFArray *)SecCertificateCopyDNSNames();
                  for (j = 0; CFArrayGetCount(v76) > j; ++j)
                  {
                    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v76, j);
                    c_string_from_cfstring = (char *)nw_utilities_create_c_string_from_cfstring(ValueAtIndex);
                    if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
                    {
                      if (gLogDatapath)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        v82 = gLogObj;
                        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
                        {
                          v83 = *(_DWORD *)(a1 + 1280);
                          *(_DWORD *)buf = 136447234;
                          *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
                          *(_WORD *)&buf[12] = 2082;
                          *(_QWORD *)&buf[14] = v210;
                          *(_WORD *)&buf[22] = 2080;
                          v282 = " ";
                          v283 = 1024;
                          v284 = v83;
                          v285 = 2080;
                          v286 = (CFErrorRef)c_string_from_cfstring;
                          _os_log_impl(&dword_182FBE000, v82, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Received name in cert %s", buf, 0x30u);
                        }
                      }
                    }
                    port = nw_endpoint_get_port(v69);
                    host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(c_string_from_cfstring, port);
                    if (c_string_from_cfstring)
                      free(c_string_from_cfstring);
                    nw_http_connection_metadata_store_secondary_certificate(*(void **)(a1 + 1248), (void *)host_with_numeric_port);
                    if (host_with_numeric_port)
                      os_release((void *)host_with_numeric_port);
                  }
                  if (v76)
                    CFRelease(v76);
                }
                if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
                {
                  if (gLogDatapath)
                  {
                    v133 = __nwlog_obj();
                    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
                    {
                      v134 = *(_DWORD *)(a1 + 1280);
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
                      *(_WORD *)&buf[12] = 2082;
                      *(_QWORD *)&buf[14] = v210;
                      *(_WORD *)&buf[22] = 2080;
                      v282 = " ";
                      v283 = 1024;
                      v284 = v134;
                      v285 = 2112;
                      v286 = v74;
                      _os_log_impl(&dword_182FBE000, v133, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Received Authenticator certChain: %@", buf, 0x30u);
                    }
                  }
                }
                if (v74)
                  CFRelease(v74);
              }
              v3 = v210;
              if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
              {
                if (gLogDatapath)
                {
                  v129 = __nwlog_obj();
                  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
                  {
                    v130 = *(_DWORD *)(a1 + 1280);
                    *(_DWORD *)buf = 136446978;
                    *(_QWORD *)&buf[4] = "nw_http3_all_streams_metadata_changed";
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v210;
                    *(_WORD *)&buf[22] = 2080;
                    v282 = " ";
                    v283 = 1024;
                    v284 = v130;
                    _os_log_impl(&dword_182FBE000, v129, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
                  }
                }
              }
              v84 = *(_QWORD *)(a1 + 880);
              if (v84)
              {
                do
                {
                  v85 = *(_QWORD *)(v84 + 544);
                  if (((*(unsigned __int16 *)(v84 + 736) | (*(unsigned __int8 *)(v84 + 738) << 16)) & 0x20000) != 0)
                    nw_protocol_notify(*(_QWORD **)(v84 + 48), a1, 5);
                  v84 = v85;
                }
                while (v85);
              }
            }
            else
            {
              if (((*v2 | (*((unsigned __int8 *)v2 + 2) << 16)) & 0x400000) == 0)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v86 = gLogObj;
                v87 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
                v73 = error;
                if (v87)
                {
                  v88 = *(_DWORD *)(a1 + 1280);
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v3;
                  *(_WORD *)&buf[22] = 2080;
                  v282 = " ";
                  v283 = 1024;
                  v284 = v88;
                  v285 = 2112;
                  v286 = error;
                  _os_log_impl(&dword_182FBE000, v86, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Trust evaluation on secondary certificate failed with error: %@, ignoring secondary certificates", buf, 0x30u);
                  v73 = error;
                }
              }
              if (v73)
                CFRelease(v73);
            }
          }
          if (v213)
            CFRelease(v213);
          os_release(trust);
          os_release(object);
          v15 = v279;
LABEL_136:
          _Block_object_dispose(v15, 8);
          goto LABEL_137;
        }
        if ((v67 & 0x400000) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v187 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
          {
            v188 = *(_DWORD *)(a1 + 1280);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v3;
            *(_WORD *)&buf[22] = 2080;
            v282 = " ";
            v283 = 1024;
            v284 = v188;
            v285 = 2112;
            v286 = (CFErrorRef)v65;
            _os_log_impl(&dword_182FBE000, v187, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> failed to copy authenticator trust from received certificate, sec_protocol_metadata: %@", buf, 0x30u);
          }
        }
        os_release(v65);
        goto LABEL_311;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
      v202 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(error) = 16;
      v278 = 0;
      if (__nwlog_fault(v202, &error, &v278))
      {
        if (error == 17)
        {
          v203 = __nwlog_obj();
          v204 = error;
          if (!os_log_type_enabled(v203, (os_log_type_t)error))
            goto LABEL_366;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
          v205 = "%{public}s called with null sec_metadata";
          goto LABEL_365;
        }
        if (!v278)
        {
          v203 = __nwlog_obj();
          v204 = error;
          if (!os_log_type_enabled(v203, (os_log_type_t)error))
            goto LABEL_366;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
          v205 = "%{public}s called with null sec_metadata, backtrace limit exceeded";
          goto LABEL_365;
        }
        v208 = (char *)__nw_create_backtrace_string();
        v203 = __nwlog_obj();
        v204 = error;
        v209 = os_log_type_enabled(v203, (os_log_type_t)error);
        if (v208)
        {
          if (v209)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v208;
            _os_log_impl(&dword_182FBE000, v203, v204, "%{public}s called with null sec_metadata, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v208);
          goto LABEL_366;
        }
        if (v209)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "nw_http3_parse_certificate";
          v205 = "%{public}s called with null sec_metadata, no backtrace";
LABEL_365:
          _os_log_impl(&dword_182FBE000, v203, v204, v205, buf, 0xCu);
        }
      }
LABEL_366:
      if (v202)
        free(v202);
LABEL_311:
      v189 = (_QWORD *)*((_QWORD *)v272 + 5);
      if (!v189)
      {
LABEL_332:
        nw_http3_fail_all_streams((nw_protocol *)a1, 262);
        v186 = v279;
        goto LABEL_333;
      }
      while (1)
      {
        v190 = (void (*)(_QWORD *, uint64_t, uint64_t))v189[10];
        v191 = (_QWORD *)v189[4];
        if (!v190)
          break;
        v192 = v189[11];
        v189[10] = 0;
        v189[11] = 0;
        v190(v189, 1, v192);
LABEL_314:
        v189 = v191;
        if (!v191)
          goto LABEL_332;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v193 = (const char *)_os_log_send_and_compose_impl();
      LOBYTE(error) = 16;
      v278 = 0;
      v254 = (char *)v193;
      if (__nwlog_fault(v193, &error, &v278))
      {
        if (error == 17)
        {
          v247 = __nwlog_obj();
          logl = error;
          if (!os_log_type_enabled(v247, (os_log_type_t)error))
            goto LABEL_330;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v194 = v247;
          v195 = logl;
          v196 = "%{public}s called with null frame->finalizer";
          goto LABEL_329;
        }
        if (!v278)
        {
          v249 = __nwlog_obj();
          logn = error;
          if (!os_log_type_enabled(v249, (os_log_type_t)error))
            goto LABEL_330;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v194 = v249;
          v195 = logn;
          v196 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_329;
        }
        v248 = (char *)__nw_create_backtrace_string();
        logm = __nwlog_obj();
        v218 = error;
        v197 = os_log_type_enabled(logm, (os_log_type_t)error);
        if (v248)
        {
          if (v197)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v248;
            _os_log_impl(&dword_182FBE000, logm, v218, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v248);
          goto LABEL_330;
        }
        if (v197)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v194 = logm;
          v195 = v218;
          v196 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_329:
          _os_log_impl(&dword_182FBE000, v194, v195, v196, buf, 0xCu);
        }
      }
LABEL_330:
      if (v254)
        free(v254);
      goto LABEL_314;
    }
    if ((v5 & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v150 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v151 = *(_DWORD *)(a1 + 1280);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v3;
        *(_WORD *)&buf[22] = 2080;
        v282 = " ";
        v283 = 1024;
        v284 = v151;
        _os_log_impl(&dword_182FBE000, v150, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> First frame is not SETTINGS", buf, 0x26u);
      }
    }
    v152 = (_QWORD *)*((_QWORD *)v272 + 5);
    if (!v152)
    {
LABEL_258:
      v162 = (nw_protocol *)a1;
      v163 = 266;
LABEL_305:
      nw_http3_fail_all_streams(v162, v163);
      goto LABEL_334;
    }
    while (1)
    {
      v153 = (void (*)(_QWORD *, uint64_t, uint64_t))v152[10];
      v154 = (_QWORD *)v152[4];
      if (!v153)
        break;
      v155 = v152[11];
      v152[10] = 0;
      v152[11] = 0;
      v153(v152, 1, v155);
LABEL_240:
      v152 = v154;
      if (!v154)
        goto LABEL_258;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "__nw_frame_finalize";
    v156 = (const char *)_os_log_send_and_compose_impl();
    v279[0] = 16;
    LOBYTE(error) = 0;
    v251 = (char *)v156;
    if (__nwlog_fault(v156, v279, &error))
    {
      if (v279[0] == 17)
      {
        v238 = __nwlog_obj();
        logc = v279[0];
        if (!os_log_type_enabled(v238, (os_log_type_t)v279[0]))
          goto LABEL_256;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v157 = v238;
        v158 = logc;
        v159 = "%{public}s called with null frame->finalizer";
        goto LABEL_255;
      }
      if (!(_BYTE)error)
      {
        v240 = __nwlog_obj();
        loge = v279[0];
        if (!os_log_type_enabled(v240, (os_log_type_t)v279[0]))
          goto LABEL_256;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v157 = v240;
        v158 = loge;
        v159 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
        goto LABEL_255;
      }
      v239 = __nw_create_backtrace_string();
      logd = __nwlog_obj();
      v215 = v279[0];
      v160 = os_log_type_enabled(logd, (os_log_type_t)v279[0]);
      v161 = (char *)v239;
      if (v239)
      {
        if (v160)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v239;
          _os_log_impl(&dword_182FBE000, logd, v215, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
          v161 = (char *)v239;
        }
        free(v161);
        goto LABEL_256;
      }
      if (v160)
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "__nw_frame_finalize";
        v157 = logd;
        v158 = v215;
        v159 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_255:
        _os_log_impl(&dword_182FBE000, v157, v158, v159, buf, 0xCu);
      }
    }
LABEL_256:
    if (v251)
      free(v251);
    goto LABEL_240;
  }
  if (v7)
  {
    if ((v5 & 0x400000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v138 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        v139 = *(_DWORD *)(a1 + 1280);
        *(_DWORD *)buf = 136446978;
        *(_QWORD *)&buf[4] = "nw_http3_control_stream_process_input";
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v3;
        *(_WORD *)&buf[22] = 2080;
        v282 = " ";
        v283 = 1024;
        v284 = v139;
        _os_log_impl(&dword_182FBE000, v138, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Duplicated SETTINGS frame", buf, 0x26u);
      }
    }
    v140 = (_QWORD *)*((_QWORD *)v272 + 5);
    if (v140)
    {
      while (1)
      {
        v141 = (void (*)(_QWORD *, uint64_t, uint64_t))v140[10];
        v142 = (_QWORD *)v140[4];
        if (!v141)
          break;
        v143 = v140[11];
        v140[10] = 0;
        v140[11] = 0;
        v141(v140, 1, v143);
LABEL_216:
        v140 = v142;
        if (!v142)
          goto LABEL_304;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "__nw_frame_finalize";
      v144 = (const char *)_os_log_send_and_compose_impl();
      v279[0] = 16;
      LOBYTE(error) = 0;
      v250 = (char *)v144;
      if (__nwlog_fault(v144, v279, &error))
      {
        if (v279[0] == 17)
        {
          v235 = __nwlog_obj();
          log = v279[0];
          if (!os_log_type_enabled(v235, (os_log_type_t)v279[0]))
            goto LABEL_232;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v145 = v235;
          v146 = log;
          v147 = "%{public}s called with null frame->finalizer";
          goto LABEL_231;
        }
        if (!(_BYTE)error)
        {
          v237 = __nwlog_obj();
          logb = v279[0];
          if (!os_log_type_enabled(v237, (os_log_type_t)v279[0]))
            goto LABEL_232;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v145 = v237;
          v146 = logb;
          v147 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
          goto LABEL_231;
        }
        v236 = __nw_create_backtrace_string();
        loga = __nwlog_obj();
        v214 = v279[0];
        v148 = os_log_type_enabled(loga, (os_log_type_t)v279[0]);
        v149 = (char *)v236;
        if (v236)
        {
          if (v148)
          {
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = "__nw_frame_finalize";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v236;
            _os_log_impl(&dword_182FBE000, loga, v214, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
            v149 = (char *)v236;
          }
          free(v149);
          goto LABEL_232;
        }
        if (v148)
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "__nw_frame_finalize";
          v145 = loga;
          v146 = v214;
          v147 = "%{public}s called with null frame->finalizer, no backtrace";
LABEL_231:
          _os_log_impl(&dword_182FBE000, v145, v146, v147, buf, 0xCu);
        }
      }
LABEL_232:
      if (v250)
        free(v250);
      goto LABEL_216;
    }
    goto LABEL_304;
  }
  *(_DWORD *)buf = 0;
  nw_frame_array_get_frame_count((uint64_t *)v272 + 5, 1, buf);
  v8 = *(_WORD *)buf;
  v9 = *(unsigned __int16 *)buf;
  error = 0;
  *(_QWORD *)(a1 + 1176) = dispatch_data_create_alloc();
  *(_WORD *)error = v8;
  v11 = (_DWORD *)((char *)error + 2);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  LODWORD(v282) = 0;
  *(_QWORD *)&buf[16] = 0x2000000000;
  v262[0] = MEMORY[0x1E0C809B0];
  v262[1] = 0x40000000;
  v263 = (uint64_t (*)(_QWORD *))___ZL37nw_http3_control_stream_process_inputP17nw_protocol_http3_block_invoke;
  v264 = &unk_1E14A7E58;
  v266 = buf;
  v267 = (char *)error + 2;
  v265 = v271;
  v12 = *((_QWORD *)v272 + 5);
  do
  {
    if (!v12)
      break;
    v13 = *(_QWORD *)(v12 + 32);
    v14 = v263(v262);
    v12 = v13;
  }
  while ((v14 & 1) != 0);
  if (nw_http3_parse_settings(a1, v11, v9, v10))
  {
    nw_http3_try_persist_0rtt_state(a1);
    v15 = buf;
    goto LABEL_136;
  }
  v164 = (_QWORD *)*((_QWORD *)v272 + 5);
  if (v164)
  {
    while (2)
    {
      v165 = (void (*)(_QWORD *, uint64_t, uint64_t))v164[10];
      v166 = (_QWORD *)v164[4];
      if (v165)
      {
        v167 = v164[11];
        v164[10] = 0;
        v164[11] = 0;
        v165(v164, 1, v167);
        goto LABEL_262;
      }
      __nwlog_obj();
      *(_DWORD *)v279 = 136446210;
      *(_QWORD *)&v279[4] = "__nw_frame_finalize";
      v168 = (const char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      v278 = 0;
      v252 = (char *)v168;
      if (!__nwlog_fault(v168, type, &v278))
        goto LABEL_278;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v241 = __nwlog_obj();
        logf = type[0];
        if (os_log_type_enabled(v241, type[0]))
        {
          *(_DWORD *)v279 = 136446210;
          *(_QWORD *)&v279[4] = "__nw_frame_finalize";
          v169 = v241;
          v170 = logf;
          v171 = "%{public}s called with null frame->finalizer";
          break;
        }
        goto LABEL_278;
      }
      if (v278)
      {
        v242 = __nw_create_backtrace_string();
        logg = __nwlog_obj();
        v216 = type[0];
        v172 = os_log_type_enabled(logg, type[0]);
        v173 = (char *)v242;
        if (v242)
        {
          if (v172)
          {
            *(_DWORD *)v279 = 136446466;
            *(_QWORD *)&v279[4] = "__nw_frame_finalize";
            *(_WORD *)&v279[12] = 2082;
            *(_QWORD *)&v279[14] = v242;
            _os_log_impl(&dword_182FBE000, logg, v216, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", v279, 0x16u);
            v173 = (char *)v242;
          }
          free(v173);
          goto LABEL_278;
        }
        if (!v172)
        {
LABEL_278:
          if (v252)
            free(v252);
LABEL_262:
          v164 = v166;
          if (!v166)
            goto LABEL_306;
          continue;
        }
        *(_DWORD *)v279 = 136446210;
        *(_QWORD *)&v279[4] = "__nw_frame_finalize";
        v169 = logg;
        v170 = v216;
        v171 = "%{public}s called with null frame->finalizer, no backtrace";
      }
      else
      {
        v243 = __nwlog_obj();
        logh = type[0];
        if (!os_log_type_enabled(v243, type[0]))
          goto LABEL_278;
        *(_DWORD *)v279 = 136446210;
        *(_QWORD *)&v279[4] = "__nw_frame_finalize";
        v169 = v243;
        v170 = logh;
        v171 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
      }
      break;
    }
    _os_log_impl(&dword_182FBE000, v169, v170, v171, v279, 0xCu);
    goto LABEL_278;
  }
LABEL_306:
  nw_http3_fail_all_streams((nw_protocol *)a1, 265);
  v186 = buf;
LABEL_333:
  _Block_object_dispose(v186, 8);
LABEL_334:
  _Block_object_dispose(v271, 8);
}

